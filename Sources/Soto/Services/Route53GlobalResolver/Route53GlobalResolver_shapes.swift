//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Route53GlobalResolver {
    // MARK: Enums

    public enum BlockOverrideDnsQueryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cname = "CNAME"
        public var description: String { return self.rawValue }
    }

    public enum CRResourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case operational = "OPERATIONAL"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ConfidenceThreshold: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum DnsAdvancedProtection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dga = "DGA"
        case dnsTunneling = "DNS_TUNNELING"
        public var description: String { return self.rawValue }
    }

    public enum DnsProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case do53 = "DO53"
        case doh = "DOH"
        case dot = "DOT"
        public var description: String { return self.rawValue }
    }

    public enum DnsSecValidationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum EdnsClientSubnetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum FirewallBlockResponse: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nodata = "NODATA"
        case nxdomain = "NXDOMAIN"
        case override = "OVERRIDE"
        public var description: String { return self.rawValue }
    }

    public enum FirewallRuleAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alert = "ALERT"
        case allow = "ALLOW"
        case block = "BLOCK"
        public var description: String { return self.rawValue }
    }

    public enum FirewallRulesFailOpenType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum HostedZoneAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case operational = "OPERATIONAL"
        public var description: String { return self.rawValue }
    }

    public enum IpAddressType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ipv4 = "IPV4"
        case ipv6 = "IPV6"
        public var description: String { return self.rawValue }
    }

    public enum ProfileResourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case disabled = "DISABLED"
        case disabling = "DISABLING"
        case enabling = "ENABLING"
        case operational = "OPERATIONAL"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum TokenStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case operational = "OPERATIONAL"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CANNOT_PARSE"
        case fieldValidationFailed = "FIELD_VALIDATION_FAILED"
        case other = "OTHER"
        case unknownOperation = "UNKNOWN_OPERATION"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessSourcesItem: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access source.
        public let arn: String
        /// The CIDR block that defines the IP address range for the access source.
        public let cidr: String
        /// The date and time when the access source was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the DNS view that the access source is associated with.
        public let dnsViewId: String
        /// The unique identifier of the access source.
        public let id: String
        /// The IP address type of the access source.
        public let ipAddressType: IpAddressType
        /// The name of the access source.
        public let name: String?
        /// The protocol used by the access source.
        public let `protocol`: DnsProtocol
        /// The current status of the access source.
        public let status: CRResourceStatus
        /// The date and time when the access source was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, cidr: String, createdAt: Date, dnsViewId: String, id: String, ipAddressType: IpAddressType, name: String? = nil, protocol: DnsProtocol, status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.cidr = cidr
            self.createdAt = createdAt
            self.dnsViewId = dnsViewId
            self.id = id
            self.ipAddressType = ipAddressType
            self.name = name
            self.`protocol` = `protocol`
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cidr = "cidr"
            case createdAt = "createdAt"
            case dnsViewId = "dnsViewId"
            case id = "id"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case `protocol` = "protocol"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct AccessTokenItem: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the token.
        public let arn: String
        /// The date and time when the token was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the DNS view associated with the token.
        public let dnsViewId: String
        /// The date and time when the token expires.
        @CustomCoding<ISO8601DateCoder>
        public var expiresAt: Date
        /// The ID of the global resolver associated with the token.
        public let globalResolverId: String
        /// The unique identifier of the token.
        public let id: String
        /// The name of the token.
        public let name: String?
        /// The current status of the token.
        public let status: TokenStatus
        /// The date and time when the token was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, dnsViewId: String, expiresAt: Date, globalResolverId: String, id: String, name: String? = nil, status: TokenStatus, updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.dnsViewId = dnsViewId
            self.expiresAt = expiresAt
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case dnsViewId = "dnsViewId"
            case expiresAt = "expiresAt"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct AssociateHostedZoneInput: AWSEncodableShape {
        /// The ID of the Route 53 private hosted zone to associate with the Route 53 Global Resolver resource.
        public let hostedZoneId: String
        /// Name for the private hosted zone association.
        public let name: String
        /// An Amazon Resource Name (ARN) of the Route 53 Global Resolver the private hosted zone will be associated to.
        public let resourceArn: String

        @inlinable
        public init(hostedZoneId: String, name: String, resourceArn: String) {
            self.hostedZoneId = hostedZoneId
            self.name = name
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hostedZoneId, key: "hostedZoneId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.resourceArn, forKey: .resourceArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, max: 32)
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:[-.a-z0-9]{1,63}:[-.a-z0-9]{0,63}:[-.a-z0-9]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case resourceArn = "resourceArn"
        }
    }

    public struct AssociateHostedZoneOutput: AWSDecodableShape {
        /// The date and time the private hosted zone association was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// ID of the private hosted zone.
        public let hostedZoneId: String
        /// Name of the hosted zone (also the domain associated with the hosted zone).
        public let hostedZoneName: String
        /// ID of the association.
        public let id: String
        /// Name for the private hosted zone association.
        public let name: String
        /// An Amazon Resource Name (ARN) of the Route 53 Global Resolver the private hosted zone is associated to.
        public let resourceArn: String
        /// Aggregate status for all the AWS Regions in which the Route 53 Global Resolver exists.
        public let status: HostedZoneAssociationStatus
        /// The date and time the private hosted zone association was modified.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, hostedZoneId: String, hostedZoneName: String, id: String, name: String, resourceArn: String, status: HostedZoneAssociationStatus, updatedAt: Date) {
            self.createdAt = createdAt
            self.hostedZoneId = hostedZoneId
            self.hostedZoneName = hostedZoneName
            self.id = id
            self.name = name
            self.resourceArn = resourceArn
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case hostedZoneId = "hostedZoneId"
            case hostedZoneName = "hostedZoneName"
            case id = "id"
            case name = "name"
            case resourceArn = "resourceArn"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct BatchCreateFirewallRuleInput: AWSEncodableShape {
        /// The BatchCreateFirewallRuleInputItem objects contain the information for each Firewall rule.
        public let firewallRules: [BatchCreateFirewallRuleInputItem]

        @inlinable
        public init(firewallRules: [BatchCreateFirewallRuleInputItem]) {
            self.firewallRules = firewallRules
        }

        public func validate(name: String) throws {
            try self.firewallRules.forEach {
                try $0.validate(name: "\(name).firewallRules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case firewallRules = "firewallRules"
        }
    }

    public struct BatchCreateFirewallRuleInputItem: AWSEncodableShape {
        /// The action to take when a DNS query matches the firewall rule.
        public let action: FirewallRuleAction
        /// The DNS record type for the custom response when the action is BLOCK.
        public let blockOverrideDnsType: BlockOverrideDnsQueryType?
        /// The custom domain name for the BLOCK response.
        public let blockOverrideDomain: String?
        /// The TTL value for the custom response when the action is BLOCK.
        public let blockOverrideTtl: Int?
        /// The type of block response to return when the action is BLOCK.
        public let blockResponse: FirewallBlockResponse?
        /// A unique string that identifies the request and ensures idempotency.
        public let clientToken: String
        /// The confidence threshold for advanced threat detection.
        public let confidenceThreshold: ConfidenceThreshold?
        /// A description of the firewall rule.
        public let description: String?
        /// Whether to enable advanced DNS threat protection for the firewall rule.
        public let dnsAdvancedProtection: DnsAdvancedProtection?
        /// The ID of the DNS view to associate the firewall rule with.
        public let dnsViewId: String
        /// The ID of the firewall domain list to associate with the rule.
        public let firewallDomainListId: String?
        /// A name for the firewall rule.
        public let name: String
        /// The priority of the firewall rule.
        public let priority: Int64?
        /// The DNS query type that the firewall rule should match.
        public let qType: String?

        @inlinable
        public init(action: FirewallRuleAction, blockOverrideDnsType: BlockOverrideDnsQueryType? = nil, blockOverrideDomain: String? = nil, blockOverrideTtl: Int? = nil, blockResponse: FirewallBlockResponse? = nil, clientToken: String, confidenceThreshold: ConfidenceThreshold? = nil, description: String? = nil, dnsAdvancedProtection: DnsAdvancedProtection? = nil, dnsViewId: String, firewallDomainListId: String? = nil, name: String, priority: Int64? = nil, qType: String? = nil) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.clientToken = clientToken
            self.confidenceThreshold = confidenceThreshold
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.name = name
            self.priority = priority
            self.qType = qType
        }

        public func validate(name: String) throws {
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, max: 256)
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, min: 1)
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, pattern: "^\\*?[-a-zA-Z0-9.]+$")
            try self.validate(self.blockOverrideTtl, name: "blockOverrideTtl", parent: name, max: 604800)
            try self.validate(self.blockOverrideTtl, name: "blockOverrideTtl", parent: name, min: 0)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, max: 64)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, max: 64)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, min: 1)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
            try self.validate(self.priority, name: "priority", parent: name, max: 10000)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.qType, name: "qType", parent: name, max: 16)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case blockOverrideDnsType = "blockOverrideDnsType"
            case blockOverrideDomain = "blockOverrideDomain"
            case blockOverrideTtl = "blockOverrideTtl"
            case blockResponse = "blockResponse"
            case clientToken = "clientToken"
            case confidenceThreshold = "confidenceThreshold"
            case description = "description"
            case dnsAdvancedProtection = "dnsAdvancedProtection"
            case dnsViewId = "dnsViewId"
            case firewallDomainListId = "firewallDomainListId"
            case name = "name"
            case priority = "priority"
            case qType = "qType"
        }
    }

    public struct BatchCreateFirewallRuleOutput: AWSDecodableShape {
        /// High level information about the DNS Firewall rules that failed to create.
        public let failures: [BatchCreateFirewallRuleOutputItem]
        /// High level information about the DNS Firewall rules that were created.
        public let successes: [BatchCreateFirewallRuleOutputItem]

        @inlinable
        public init(failures: [BatchCreateFirewallRuleOutputItem], successes: [BatchCreateFirewallRuleOutputItem]) {
            self.failures = failures
            self.successes = successes
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "failures"
            case successes = "successes"
        }
    }

    public struct BatchCreateFirewallRuleOutputItem: AWSDecodableShape {
        /// The HTTP response code for the batch operation result.
        public let code: Int
        /// The firewall rule that was created in the batch operation.
        public let firewallRule: BatchCreateFirewallRuleResult
        /// A message describing the result of the batch operation, including error details if applicable.
        public let message: String?

        @inlinable
        public init(code: Int, firewallRule: BatchCreateFirewallRuleResult, message: String? = nil) {
            self.code = code
            self.firewallRule = firewallRule
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case firewallRule = "firewallRule"
            case message = "message"
        }
    }

    public struct BatchCreateFirewallRuleResult: AWSDecodableShape {
        /// The action configured for the created firewall rule.
        public let action: FirewallRuleAction
        /// The DNS record type configured for the created firewall rule's custom response.
        public let blockOverrideDnsType: BlockOverrideDnsQueryType?
        /// The custom domain name configured for the created firewall rule's BLOCK response.
        public let blockOverrideDomain: String?
        /// The TTL value configured for the created firewall rule's custom response.
        public let blockOverrideTtl: Int?
        /// The type of block response configured for the created firewall rule.
        public let blockResponse: FirewallBlockResponse?
        /// The unique string that identified the request and ensured idempotency.
        public let clientToken: String
        /// The confidence threshold configured for the created firewall rule's advanced threat detection.
        public let confidenceThreshold: ConfidenceThreshold?
        /// The date and time when the firewall rule was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description of the created firewall rule.
        public let description: String?
        /// Whether advanced DNS threat protection is enabled for the created firewall rule.
        public let dnsAdvancedProtection: DnsAdvancedProtection?
        /// The ID of the DNS view associated with the created firewall rule.
        public let dnsViewId: String
        /// The ID of the firewall domain list associated with the created firewall rule.
        public let firewallDomainListId: String?
        /// The unique identifier of the created firewall rule.
        public let id: String?
        /// The name of the managed domain list associated with the created firewall rule.
        public let managedDomainListName: String?
        /// The name of the created firewall rule.
        public let name: String
        /// The priority of the created firewall rule.
        public let priority: Int64?
        /// The DNS query type that the created firewall rule matches.
        public let queryType: String?
        /// The current status of the created firewall rule.
        public let status: CRResourceStatus?
        /// The date and time when the firewall rule was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(action: FirewallRuleAction, blockOverrideDnsType: BlockOverrideDnsQueryType? = nil, blockOverrideDomain: String? = nil, blockOverrideTtl: Int? = nil, blockResponse: FirewallBlockResponse? = nil, clientToken: String, confidenceThreshold: ConfidenceThreshold? = nil, createdAt: Date? = nil, description: String? = nil, dnsAdvancedProtection: DnsAdvancedProtection? = nil, dnsViewId: String, firewallDomainListId: String? = nil, id: String? = nil, managedDomainListName: String? = nil, name: String, priority: Int64? = nil, queryType: String? = nil, status: CRResourceStatus? = nil, updatedAt: Date? = nil) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.clientToken = clientToken
            self.confidenceThreshold = confidenceThreshold
            self.createdAt = createdAt
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.id = id
            self.managedDomainListName = managedDomainListName
            self.name = name
            self.priority = priority
            self.queryType = queryType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case blockOverrideDnsType = "blockOverrideDnsType"
            case blockOverrideDomain = "blockOverrideDomain"
            case blockOverrideTtl = "blockOverrideTtl"
            case blockResponse = "blockResponse"
            case clientToken = "clientToken"
            case confidenceThreshold = "confidenceThreshold"
            case createdAt = "createdAt"
            case description = "description"
            case dnsAdvancedProtection = "dnsAdvancedProtection"
            case dnsViewId = "dnsViewId"
            case firewallDomainListId = "firewallDomainListId"
            case id = "id"
            case managedDomainListName = "managedDomainListName"
            case name = "name"
            case priority = "priority"
            case queryType = "queryType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct BatchDeleteFirewallRuleInput: AWSEncodableShape {
        /// An array of the DNS Firewall IDs to be deleted.
        public let firewallRules: [BatchDeleteFirewallRuleInputItem]

        @inlinable
        public init(firewallRules: [BatchDeleteFirewallRuleInputItem]) {
            self.firewallRules = firewallRules
        }

        public func validate(name: String) throws {
            try self.firewallRules.forEach {
                try $0.validate(name: "\(name).firewallRules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case firewallRules = "firewallRules"
        }
    }

    public struct BatchDeleteFirewallRuleInputItem: AWSEncodableShape {
        /// The ID of the DNS Firewall rule to delete.
        public let firewallRuleId: String

        @inlinable
        public init(firewallRuleId: String) {
            self.firewallRuleId = firewallRuleId
        }

        public func validate(name: String) throws {
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, max: 64)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, min: 1)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case firewallRuleId = "firewallRuleId"
        }
    }

    public struct BatchDeleteFirewallRuleOutput: AWSDecodableShape {
        /// High level information about the DNS Firewall rules that failed to delete.
        public let failures: [BatchDeleteFirewallRuleOutputItem]
        /// High level information about the DNS Firewall rules that were deleted successfully.
        public let successes: [BatchDeleteFirewallRuleOutputItem]

        @inlinable
        public init(failures: [BatchDeleteFirewallRuleOutputItem], successes: [BatchDeleteFirewallRuleOutputItem]) {
            self.failures = failures
            self.successes = successes
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "failures"
            case successes = "successes"
        }
    }

    public struct BatchDeleteFirewallRuleOutputItem: AWSDecodableShape {
        /// The response code for the delete operation.
        public let code: Int
        /// The firewall rule that was deleted in the batch operation.
        public let firewallRule: BatchDeleteFirewallRuleResult
        /// The response message for the delete operation.
        public let message: String?

        @inlinable
        public init(code: Int, firewallRule: BatchDeleteFirewallRuleResult, message: String? = nil) {
            self.code = code
            self.firewallRule = firewallRule
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case firewallRule = "firewallRule"
            case message = "message"
        }
    }

    public struct BatchDeleteFirewallRuleResult: AWSDecodableShape {
        /// The unique string that identified the request and ensured idempotency.
        public let clientToken: String?
        /// The unique identifier of the deleted firewall rule.
        public let id: String
        /// The name of the deleted firewall rule.
        public let name: String?
        /// The final status of the deleted firewall rule.
        public let status: CRResourceStatus?

        @inlinable
        public init(clientToken: String? = nil, id: String, name: String? = nil, status: CRResourceStatus? = nil) {
            self.clientToken = clientToken
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct BatchUpdateFirewallRuleInput: AWSEncodableShape {
        /// The DNS Firewall rule IDs to be updated.
        public let firewallRules: [BatchUpdateFirewallRuleInputItem]

        @inlinable
        public init(firewallRules: [BatchUpdateFirewallRuleInputItem]) {
            self.firewallRules = firewallRules
        }

        public func validate(name: String) throws {
            try self.firewallRules.forEach {
                try $0.validate(name: "\(name).firewallRules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case firewallRules = "firewallRules"
        }
    }

    public struct BatchUpdateFirewallRuleInputItem: AWSEncodableShape {
        /// The action to take when a DNS query matches the firewall rule.
        public let action: FirewallRuleAction?
        /// The DNS record type for the custom response when the action is BLOCK.
        public let blockOverrideDnsType: BlockOverrideDnsQueryType?
        /// The custom domain name for the BLOCK response.
        public let blockOverrideDomain: String?
        /// The TTL value for the custom response when the action is BLOCK.
        public let blockOverrideTtl: Int?
        /// The type of block response to return when the action is BLOCK.
        public let blockResponse: FirewallBlockResponse?
        /// The confidence threshold for advanced threat detection.
        public let confidenceThreshold: ConfidenceThreshold?
        /// A description of the firewall rule.
        public let description: String?
        /// Whether to enable advanced DNS threat protection for the firewall rule.
        public let dnsAdvancedProtection: DnsAdvancedProtection?
        /// The unique identifier of the firewall rule to update.
        public let firewallRuleId: String
        /// A name for the firewall rule.
        public let name: String?
        /// The priority of the firewall rule.
        public let priority: Int64?

        @inlinable
        public init(action: FirewallRuleAction? = nil, blockOverrideDnsType: BlockOverrideDnsQueryType? = nil, blockOverrideDomain: String? = nil, blockOverrideTtl: Int? = nil, blockResponse: FirewallBlockResponse? = nil, confidenceThreshold: ConfidenceThreshold? = nil, description: String? = nil, dnsAdvancedProtection: DnsAdvancedProtection? = nil, firewallRuleId: String, name: String? = nil, priority: Int64? = nil) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.confidenceThreshold = confidenceThreshold
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.firewallRuleId = firewallRuleId
            self.name = name
            self.priority = priority
        }

        public func validate(name: String) throws {
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, max: 256)
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, min: 1)
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, pattern: "^\\*?[-a-zA-Z0-9.]+$")
            try self.validate(self.blockOverrideTtl, name: "blockOverrideTtl", parent: name, max: 604800)
            try self.validate(self.blockOverrideTtl, name: "blockOverrideTtl", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, max: 64)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, min: 1)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
            try self.validate(self.priority, name: "priority", parent: name, max: 10000)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case blockOverrideDnsType = "blockOverrideDnsType"
            case blockOverrideDomain = "blockOverrideDomain"
            case blockOverrideTtl = "blockOverrideTtl"
            case blockResponse = "blockResponse"
            case confidenceThreshold = "confidenceThreshold"
            case description = "description"
            case dnsAdvancedProtection = "dnsAdvancedProtection"
            case firewallRuleId = "firewallRuleId"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct BatchUpdateFirewallRuleOutput: AWSDecodableShape {
        /// High level information about the DNS Firewall rules that failed to update.
        public let failures: [BatchUpdateFirewallRuleOutputItem]
        /// High level information about the DNS Firewall rules that were successfully updated.
        public let successes: [BatchUpdateFirewallRuleOutputItem]

        @inlinable
        public init(failures: [BatchUpdateFirewallRuleOutputItem], successes: [BatchUpdateFirewallRuleOutputItem]) {
            self.failures = failures
            self.successes = successes
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "failures"
            case successes = "successes"
        }
    }

    public struct BatchUpdateFirewallRuleOutputItem: AWSDecodableShape {
        /// The response code for the update operation.
        public let code: Int
        /// The firewall rule that was updated in the batch operation.
        public let firewallRule: BatchUpdateFirewallRuleResult
        /// The response message for the update operation.
        public let message: String?

        @inlinable
        public init(code: Int, firewallRule: BatchUpdateFirewallRuleResult, message: String? = nil) {
            self.code = code
            self.firewallRule = firewallRule
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case firewallRule = "firewallRule"
            case message = "message"
        }
    }

    public struct BatchUpdateFirewallRuleResult: AWSDecodableShape {
        /// The action configured for the updated firewall rule.
        public let action: FirewallRuleAction?
        /// The DNS record type configured for the updated firewall rule's custom response.
        public let blockOverrideDnsType: BlockOverrideDnsQueryType?
        /// The custom domain name configured for the updated firewall rule's BLOCK response.
        public let blockOverrideDomain: String?
        /// The TTL value configured for the updated firewall rule's custom response.
        public let blockOverrideTtl: Int?
        /// The type of block response configured for the updated firewall rule.
        public let blockResponse: FirewallBlockResponse?
        /// The unique string that identified the request and ensured idempotency.
        public let clientToken: String?
        /// The confidence threshold configured for the updated firewall rule's advanced threat detection.
        public let confidenceThreshold: ConfidenceThreshold?
        /// The date and time when the firewall rule was originally created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description of the updated firewall rule.
        public let description: String?
        /// Whether advanced DNS threat protection is enabled for the updated firewall rule.
        public let dnsAdvancedProtection: DnsAdvancedProtection?
        /// The ID of the DNS view associated with the updated firewall rule.
        public let dnsViewId: String?
        /// The ID of the firewall domain list associated with the updated firewall rule.
        public let firewallDomainListId: String?
        /// The unique identifier of the updated firewall rule.
        public let id: String
        /// The name of the updated firewall rule.
        public let name: String?
        /// The priority of the updated firewall rule.
        public let priority: Int64?
        /// The DNS query type that the updated firewall rule matches.
        public let queryType: String?
        /// The current status of the updated firewall rule.
        public let status: CRResourceStatus?
        /// The date and time when the firewall rule was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(action: FirewallRuleAction? = nil, blockOverrideDnsType: BlockOverrideDnsQueryType? = nil, blockOverrideDomain: String? = nil, blockOverrideTtl: Int? = nil, blockResponse: FirewallBlockResponse? = nil, clientToken: String? = nil, confidenceThreshold: ConfidenceThreshold? = nil, createdAt: Date? = nil, description: String? = nil, dnsAdvancedProtection: DnsAdvancedProtection? = nil, dnsViewId: String? = nil, firewallDomainListId: String? = nil, id: String, name: String? = nil, priority: Int64? = nil, queryType: String? = nil, status: CRResourceStatus? = nil, updatedAt: Date? = nil) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.clientToken = clientToken
            self.confidenceThreshold = confidenceThreshold
            self.createdAt = createdAt
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.id = id
            self.name = name
            self.priority = priority
            self.queryType = queryType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case blockOverrideDnsType = "blockOverrideDnsType"
            case blockOverrideDomain = "blockOverrideDomain"
            case blockOverrideTtl = "blockOverrideTtl"
            case blockResponse = "blockResponse"
            case clientToken = "clientToken"
            case confidenceThreshold = "confidenceThreshold"
            case createdAt = "createdAt"
            case description = "description"
            case dnsAdvancedProtection = "dnsAdvancedProtection"
            case dnsViewId = "dnsViewId"
            case firewallDomainListId = "firewallDomainListId"
            case id = "id"
            case name = "name"
            case priority = "priority"
            case queryType = "queryType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The ID of the conflicting resource.
        public let resourceId: String?
        /// The type of the conflicting resource.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CreateAccessSourceInput: AWSEncodableShape {
        /// The IP address or CIDR range that is allowed to send DNS queries to the Route 53 Global Resolver.
        public let cidr: String
        /// A unique string that identifies the request and ensures idempotency.
        public let clientToken: String?
        /// The ID of the DNS view to associate with this access source.
        public let dnsViewId: String
        /// The IP address type for this access source. Valid values are IPv4 and IPv6 (if the Route 53 Global Resolver supports dual-stack).
        public let ipAddressType: IpAddressType?
        /// A descriptive name for the access source.
        public let name: String?
        /// The DNS protocol that is permitted for this access source. Valid values are Do53 (DNS over port 53), DoT (DNS over TLS), and DoH (DNS over HTTPS).
        public let `protocol`: DnsProtocol
        /// Tags to associate with the access source.
        public let tags: [String: String]?

        @inlinable
        public init(cidr: String, clientToken: String? = CreateAccessSourceInput.idempotencyToken(), dnsViewId: String, ipAddressType: IpAddressType? = nil, name: String? = nil, protocol: DnsProtocol, tags: [String: String]? = nil) {
            self.cidr = cidr
            self.clientToken = clientToken
            self.dnsViewId = dnsViewId
            self.ipAddressType = ipAddressType
            self.name = name
            self.`protocol` = `protocol`
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.cidr, name: "cidr", parent: name, max: 42)
            try self.validate(self.cidr, name: "cidr", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, max: 64)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "cidr"
            case clientToken = "clientToken"
            case dnsViewId = "dnsViewId"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case `protocol` = "protocol"
            case tags = "tags"
        }
    }

    public struct CreateAccessSourceOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access source.
        public let arn: String
        /// The IP address or CIDR range that is allowed to send DNS queries to the Route 53 Global Resolver.
        public let cidr: String
        /// The date and time when the access source was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the DNS view associated with this access source.
        public let dnsViewId: String
        /// The unique identifier for the access source.
        public let id: String
        /// The IP address type for this access source (IPv4 or IPv6).
        public let ipAddressType: IpAddressType
        /// The descriptive name of the access source.
        public let name: String?
        /// The DNS protocol that is permitted for this access source (Do53, DoT, or DoH).
        public let `protocol`: DnsProtocol
        /// The operational status of the access source.
        public let status: CRResourceStatus
        /// The date and time when the access source was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, cidr: String, createdAt: Date, dnsViewId: String, id: String, ipAddressType: IpAddressType, name: String? = nil, protocol: DnsProtocol, status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.cidr = cidr
            self.createdAt = createdAt
            self.dnsViewId = dnsViewId
            self.id = id
            self.ipAddressType = ipAddressType
            self.name = name
            self.`protocol` = `protocol`
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cidr = "cidr"
            case createdAt = "createdAt"
            case dnsViewId = "dnsViewId"
            case id = "id"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case `protocol` = "protocol"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateAccessTokenInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
        public let clientToken: String?
        /// The ID of the DNS view to associate with this token.
        public let dnsViewId: String
        /// The date and time when the token expires. Tokens can have a minimum expiration of 30 days and maximum of 365 days from creation.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// A descriptive name for the access token.
        public let name: String?
        /// An array of user-defined keys and optional values. These tags can be used for categorization and organization.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateAccessTokenInput.idempotencyToken(), dnsViewId: String, expiresAt: Date? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.dnsViewId = dnsViewId
            self.expiresAt = expiresAt
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.dnsViewId, key: "dnsViewId")
            try container.encodeIfPresent(self.expiresAt, forKey: .expiresAt)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, max: 64)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case expiresAt = "expiresAt"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateAccessTokenOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access token.
        public let arn: String
        /// The unique string that identifies the request and ensures idempotency.
        public let clientToken: String?
        /// The date and time when the access token was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the DNS view associated with this access token.
        public let dnsViewId: String
        /// The date and time when the access token expires.
        @CustomCoding<ISO8601DateCoder>
        public var expiresAt: Date
        /// The unique identifier for the access token.
        public let id: String
        /// The name of the access token.
        public let name: String?
        /// The operational status of the access token.
        public let status: TokenStatus
        /// The access token value. This token should be included in DoH and DoT requests for authentication. Keep this value secure as it provides access to your Route 53 Global Resolver.
        public let value: String

        @inlinable
        public init(arn: String, clientToken: String? = nil, createdAt: Date, dnsViewId: String, expiresAt: Date, id: String, name: String? = nil, status: TokenStatus, value: String) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.dnsViewId = dnsViewId
            self.expiresAt = expiresAt
            self.id = id
            self.name = name
            self.status = status
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case dnsViewId = "dnsViewId"
            case expiresAt = "expiresAt"
            case id = "id"
            case name = "name"
            case status = "status"
            case value = "value"
        }
    }

    public struct CreateDNSViewInput: AWSEncodableShape {
        /// A unique string that identifies the request and ensures idempotency.
        public let clientToken: String?
        /// An optional description for the DNS view.
        public let description: String?
        /// Whether to enable DNSSEC validation for DNS queries in this DNS view. When enabled, the resolver verifies the authenticity and integrity of DNS responses from public name servers for DNSSEC-signed domains.
        public let dnssecValidation: DnsSecValidationType?
        /// Whether to enable EDNS Client Subnet injection for DNS queries in this DNS view. When enabled, client subnet information is forwarded to provide more accurate geographic-based DNS responses.
        public let ednsClientSubnet: EdnsClientSubnetType?
        /// Determines the behavior when Route 53 Global Resolver cannot apply DNS firewall rules due to service impairment. When enabled, DNS queries are allowed through; when disabled, queries are blocked.
        public let firewallRulesFailOpen: FirewallRulesFailOpenType?
        /// The ID of the Route 53 Global Resolver to associate with this DNS view.
        public let globalResolverId: String
        /// A descriptive name for the DNS view.
        public let name: String
        /// Tags to associate with the DNS view.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateDNSViewInput.idempotencyToken(), description: String? = nil, dnssecValidation: DnsSecValidationType? = nil, ednsClientSubnet: EdnsClientSubnetType? = nil, firewallRulesFailOpen: FirewallRulesFailOpenType? = nil, globalResolverId: String, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.dnssecValidation = dnssecValidation
            self.ednsClientSubnet = ednsClientSubnet
            self.firewallRulesFailOpen = firewallRulesFailOpen
            self.globalResolverId = globalResolverId
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.dnssecValidation, forKey: .dnssecValidation)
            try container.encodeIfPresent(self.ednsClientSubnet, forKey: .ednsClientSubnet)
            try container.encodeIfPresent(self.firewallRulesFailOpen, forKey: .firewallRulesFailOpen)
            request.encodePath(self.globalResolverId, key: "globalResolverId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, max: 64)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, min: 1)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case dnssecValidation = "dnssecValidation"
            case ednsClientSubnet = "ednsClientSubnet"
            case firewallRulesFailOpen = "firewallRulesFailOpen"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateDNSViewOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the DNS view.
        public let arn: String
        /// The unique string that identifies the request and ensures idempotency.
        public let clientToken: String?
        /// The date and time when the DNS view was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the DNS view.
        public let description: String?
        /// Whether DNSSEC validation is enabled for DNS queries in this DNS view.
        public let dnssecValidation: DnsSecValidationType
        /// Whether EDNS Client Subnet injection is enabled for DNS queries in this DNS view.
        public let ednsClientSubnet: EdnsClientSubnetType
        /// The behavior when Route 53 Global Resolver cannot apply DNS firewall rules due to service impairment.
        public let firewallRulesFailOpen: FirewallRulesFailOpenType
        /// The ID of the Route 53 Global Resolver instance the DNS view is created for.
        public let globalResolverId: String
        /// The unique identifier for the DNS view.
        public let id: String
        /// The descriptive name of the DNS view.
        public let name: String
        /// The operational status of the DNS view.
        public let status: ProfileResourceStatus
        /// The date and time when the DNS view was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String? = nil, createdAt: Date, description: String? = nil, dnssecValidation: DnsSecValidationType, ednsClientSubnet: EdnsClientSubnetType, firewallRulesFailOpen: FirewallRulesFailOpenType, globalResolverId: String, id: String, name: String, status: ProfileResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnssecValidation = dnssecValidation
            self.ednsClientSubnet = ednsClientSubnet
            self.firewallRulesFailOpen = firewallRulesFailOpen
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnssecValidation = "dnssecValidation"
            case ednsClientSubnet = "ednsClientSubnet"
            case firewallRulesFailOpen = "firewallRulesFailOpen"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateFirewallDomainListInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
        public let clientToken: String?
        /// An optional description for the firewall domain list.
        public let description: String?
        /// The ID of the Route 53 Global Resolver that the domain list will be associated with.
        public let globalResolverId: String
        /// A descriptive name for the firewall domain list.
        public let name: String
        /// An array of user-defined keys and optional values. These tags can be used for categorization and organization.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateFirewallDomainListInput.idempotencyToken(), description: String? = nil, globalResolverId: String, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.globalResolverId = globalResolverId
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalResolverId, key: "globalResolverId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, max: 64)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, min: 1)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateFirewallDomainListOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) for the domain list.
        public let arn: String
        /// The time and date the domain list was created on.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Description for the domain list.
        public let description: String?
        /// Number of domains in the domain list.
        public let domainCount: Int
        /// The ID of the Route 53 Global Resolver that the domain list is associated with.
        public let globalResolverId: String
        /// ID of the domain list.
        public let id: String
        /// Name of the domain list.
        public let name: String
        /// Creation status of the domain list.
        public let status: CRResourceStatus
        /// The time and date the domain list was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, domainCount: Int, globalResolverId: String, id: String, name: String, status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainCount = domainCount
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case domainCount = "domainCount"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateFirewallRuleInput: AWSEncodableShape {
        /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:    ALLOW - Permit the request to go through.    ALERT - Permit the request and send metrics and logs to CloudWatch.    BLOCK - Disallow the request. This option requires additional details in the rule's BlockResponse.
        public let action: FirewallRuleAction
        /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
        public let blockOverrideDnsType: BlockOverrideDnsQueryType?
        /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
        public let blockOverrideDomain: String?
        /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
        public let blockOverrideTtl: Int?
        /// The response to return when the action is BLOCK. Valid values are NXDOMAIN (domain does not exist), NODATA (domain exists but no records), or OVERRIDE (return custom response).
        public let blockResponse: FirewallBlockResponse?
        /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
        public let clientToken: String?
        /// The confidence threshold for advanced threat detection. Valid values are HIGH, MEDIUM, or LOW, indicating the accuracy level required for threat detection.
        public let confidenceThreshold: ConfidenceThreshold?
        /// An optional description for the firewall rule.
        public let description: String?
        /// Whether to enable advanced DNS threat protection for this rule. Advanced protection can detect and block DNS tunneling and Domain Generation Algorithm (DGA) threats.
        public let dnsAdvancedProtection: DnsAdvancedProtection?
        /// The ID of the DNS view to associate with this firewall rule.
        public let dnsViewId: String
        /// The ID of the firewall domain list to use in this rule.
        public let firewallDomainListId: String?
        /// A descriptive name for the firewall rule.
        public let name: String
        /// The priority of this rule. Rules are evaluated in priority order, with lower numbers having higher priority. When a DNS query matches multiple rules, the rule with the highest priority (lowest number) is applied.
        public let priority: Int64?
        /// The DNS query type to match for this rule. Examples include A (IPv4 address), AAAA (IPv6 address), MX (mail exchange), or TXT (text record).
        public let qType: String?

        @inlinable
        public init(action: FirewallRuleAction, blockOverrideDnsType: BlockOverrideDnsQueryType? = nil, blockOverrideDomain: String? = nil, blockOverrideTtl: Int? = nil, blockResponse: FirewallBlockResponse? = nil, clientToken: String? = CreateFirewallRuleInput.idempotencyToken(), confidenceThreshold: ConfidenceThreshold? = nil, description: String? = nil, dnsAdvancedProtection: DnsAdvancedProtection? = nil, dnsViewId: String, firewallDomainListId: String? = nil, name: String, priority: Int64? = nil, qType: String? = nil) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.clientToken = clientToken
            self.confidenceThreshold = confidenceThreshold
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.name = name
            self.priority = priority
            self.qType = qType
        }

        public func validate(name: String) throws {
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, max: 256)
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, min: 1)
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, pattern: "^\\*?[-a-zA-Z0-9.]+$")
            try self.validate(self.blockOverrideTtl, name: "blockOverrideTtl", parent: name, max: 604800)
            try self.validate(self.blockOverrideTtl, name: "blockOverrideTtl", parent: name, min: 0)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, max: 64)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, max: 64)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, min: 1)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
            try self.validate(self.priority, name: "priority", parent: name, max: 10000)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.qType, name: "qType", parent: name, max: 16)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case blockOverrideDnsType = "blockOverrideDnsType"
            case blockOverrideDomain = "blockOverrideDomain"
            case blockOverrideTtl = "blockOverrideTtl"
            case blockResponse = "blockResponse"
            case clientToken = "clientToken"
            case confidenceThreshold = "confidenceThreshold"
            case description = "description"
            case dnsAdvancedProtection = "dnsAdvancedProtection"
            case dnsViewId = "dnsViewId"
            case firewallDomainListId = "firewallDomainListId"
            case name = "name"
            case priority = "priority"
            case qType = "qType"
        }
    }

    public struct CreateFirewallRuleOutput: AWSDecodableShape {
        /// The action that DNS Firewall takes on DNS queries that match this rule.
        public let action: FirewallRuleAction
        /// The DNS record type for the custom response when blockResponse is OVERRIDE.
        public let blockOverrideDnsType: BlockOverrideDnsQueryType?
        /// The custom domain to return when the action is BLOCK and blockResponse is OVERRIDE.
        public let blockOverrideDomain: String?
        /// The time-to-live (TTL) value for the custom response when blockResponse is OVERRIDE.
        public let blockOverrideTtl: Int?
        /// The response to return when the action is BLOCK.
        public let blockResponse: FirewallBlockResponse?
        /// The confidence threshold for advanced threat detection.
        public let confidenceThreshold: ConfidenceThreshold?
        /// The date and time when the firewall rule was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the firewall rule.
        public let description: String?
        /// Whether advanced DNS threat protection is enabled for this rule.
        public let dnsAdvancedProtection: DnsAdvancedProtection?
        /// The ID of the DNS view associated with this firewall rule.
        public let dnsViewId: String
        /// The ID of the firewall domain list used in this rule.
        public let firewallDomainListId: String?
        /// The unique identifier for the firewall rule.
        public let id: String
        /// The name of the firewall rule.
        public let name: String
        /// The priority of the firewall rule.
        public let priority: Int64
        /// The DNS query type that this rule matches.
        public let queryType: String?
        /// The operational status of the firewall rule.
        public let status: CRResourceStatus
        /// The date and time when the firewall rule was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(action: FirewallRuleAction, blockOverrideDnsType: BlockOverrideDnsQueryType? = nil, blockOverrideDomain: String? = nil, blockOverrideTtl: Int? = nil, blockResponse: FirewallBlockResponse? = nil, confidenceThreshold: ConfidenceThreshold? = nil, createdAt: Date, description: String? = nil, dnsAdvancedProtection: DnsAdvancedProtection? = nil, dnsViewId: String, firewallDomainListId: String? = nil, id: String, name: String, priority: Int64, queryType: String? = nil, status: CRResourceStatus, updatedAt: Date) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.confidenceThreshold = confidenceThreshold
            self.createdAt = createdAt
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.id = id
            self.name = name
            self.priority = priority
            self.queryType = queryType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case blockOverrideDnsType = "blockOverrideDnsType"
            case blockOverrideDomain = "blockOverrideDomain"
            case blockOverrideTtl = "blockOverrideTtl"
            case blockResponse = "blockResponse"
            case confidenceThreshold = "confidenceThreshold"
            case createdAt = "createdAt"
            case description = "description"
            case dnsAdvancedProtection = "dnsAdvancedProtection"
            case dnsViewId = "dnsViewId"
            case firewallDomainListId = "firewallDomainListId"
            case id = "id"
            case name = "name"
            case priority = "priority"
            case queryType = "queryType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateGlobalResolverInput: AWSEncodableShape {
        /// A unique string that identifies the request and ensures idempotency. If you make multiple requests with the same client token, only one Route 53 Global Resolver is created.
        public let clientToken: String?
        /// An optional description for the Route 53 Global Resolver instance. Maximum length of 1024 characters.
        public let description: String?
        /// A descriptive name for the Route 53 Global Resolver instance. Maximum length of 64 characters.
        public let name: String
        /// The AWS region where query resolution logs and metrics will be aggregated and delivered. If not specified, logging is not enabled.
        public let observabilityRegion: String?
        /// List of AWS regions where the Route 53 Global Resolver will operate. The resolver will be distributed across these regions to provide global availability and low-latency DNS resolution.
        public let regions: [String]
        /// Tags to associate with the Route 53 Global Resolver. Tags are key-value pairs that help you organize and identify your resources.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateGlobalResolverInput.idempotencyToken(), description: String? = nil, name: String, observabilityRegion: String? = nil, regions: [String], tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.observabilityRegion = observabilityRegion
            self.regions = regions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
            try self.validate(self.observabilityRegion, name: "observabilityRegion", parent: name, max: 32)
            try self.regions.forEach {
                try validate($0, name: "regions[]", parent: name, max: 32)
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case observabilityRegion = "observabilityRegion"
            case regions = "regions"
            case tags = "tags"
        }
    }

    public struct CreateGlobalResolverOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Route 53 Global Resolver.
        public let arn: String
        /// The unique string that identifies the request and ensures idempotency.
        public let clientToken: String
        /// The date and time when the Route 53 Global Resolver was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the Route 53 Global Resolver.
        public let description: String?
        /// The hostname that DNS clients should use for TLS certificate validation when connecting to the Route 53 Global Resolver. This value resolves to the global anycast IP addresses for the resolver.
        public let dnsName: String
        /// The unique identifier for the Route 53 Global Resolver.
        public let id: String
        /// The global anycast IPv4 addresses associated with the Route 53 Global Resolver. DNS clients can send queries to these addresses from anywhere on the internet.
        public let ipv4Addresses: [String]
        /// The name of the Route 53 Global Resolver.
        public let name: String
        /// The AWS Region where observability data for the Route 53 Global Resolver is stored.
        public let observabilityRegion: String?
        /// The AWS Regions where the Route 53 Global Resolver is deployed and operational.
        public let regions: [String]
        /// The current status of the Route 53 Global Resolver. Possible values are CREATING (being provisioned), UPDATING (being modified), OPERATIONAL (ready to serve queries), or DELETING (being removed).
        public let status: CRResourceStatus
        /// The date and time when the Route 53 Global Resolver was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String, createdAt: Date, description: String? = nil, dnsName: String, id: String, ipv4Addresses: [String], name: String, observabilityRegion: String? = nil, regions: [String], status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnsName = dnsName
            self.id = id
            self.ipv4Addresses = ipv4Addresses
            self.name = name
            self.observabilityRegion = observabilityRegion
            self.regions = regions
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnsName = "dnsName"
            case id = "id"
            case ipv4Addresses = "ipv4Addresses"
            case name = "name"
            case observabilityRegion = "observabilityRegion"
            case regions = "regions"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DNSViewSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the DNS view.
        public let arn: String
        /// The unique string that identifies the request and ensures idempotency.
        public let clientToken: String
        /// The date and time when the DNS view was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A description of the DNS view.
        public let description: String?
        /// Whether DNSSEC validation is enabled for the DNS view.
        public let dnssecValidation: DnsSecValidationType
        /// Whether EDNS Client Subnet injection is enabled for the DNS view.
        public let ednsClientSubnet: EdnsClientSubnetType
        /// Whether firewall rules fail open when they cannot be evaluated.
        public let firewallRulesFailOpen: FirewallRulesFailOpenType
        /// The ID of the global resolver that the DNS view is associated with.
        public let globalResolverId: String
        /// The unique identifier of the DNS view.
        public let id: String
        /// The name of the DNS view.
        public let name: String
        /// The current status of the DNS view.
        public let status: ProfileResourceStatus
        /// The date and time when the DNS view was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String, createdAt: Date, description: String? = nil, dnssecValidation: DnsSecValidationType, ednsClientSubnet: EdnsClientSubnetType, firewallRulesFailOpen: FirewallRulesFailOpenType, globalResolverId: String, id: String, name: String, status: ProfileResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnssecValidation = dnssecValidation
            self.ednsClientSubnet = ednsClientSubnet
            self.firewallRulesFailOpen = firewallRulesFailOpen
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnssecValidation = "dnssecValidation"
            case ednsClientSubnet = "ednsClientSubnet"
            case firewallRulesFailOpen = "firewallRulesFailOpen"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteAccessSourceInput: AWSEncodableShape {
        /// The unique identifier of the access source to delete.
        public let accessSourceId: String

        @inlinable
        public init(accessSourceId: String) {
            self.accessSourceId = accessSourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessSourceId, key: "accessSourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessSourceId, name: "accessSourceId", parent: name, max: 64)
            try self.validate(self.accessSourceId, name: "accessSourceId", parent: name, min: 1)
            try self.validate(self.accessSourceId, name: "accessSourceId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessSourceOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted access source.
        public let arn: String
        /// The IP address or CIDR range of the deleted access source.
        public let cidr: String
        /// The date and time when the access source was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the DNS view that was associated with the deleted access source.
        public let dnsViewId: String
        /// The unique identifier of the deleted access source.
        public let id: String
        /// The IP address type of the deleted access source (IPv4 or IPv6).
        public let ipAddressType: IpAddressType
        /// The name of the deleted access source.
        public let name: String?
        /// The DNS protocol that was permitted for the deleted access source.
        public let `protocol`: DnsProtocol
        /// The final status of the deleted access source.
        public let status: CRResourceStatus
        /// The date and time when the access source was last updated before deletion.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, cidr: String, createdAt: Date, dnsViewId: String, id: String, ipAddressType: IpAddressType, name: String? = nil, protocol: DnsProtocol, status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.cidr = cidr
            self.createdAt = createdAt
            self.dnsViewId = dnsViewId
            self.id = id
            self.ipAddressType = ipAddressType
            self.name = name
            self.`protocol` = `protocol`
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cidr = "cidr"
            case createdAt = "createdAt"
            case dnsViewId = "dnsViewId"
            case id = "id"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case `protocol` = "protocol"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteAccessTokenInput: AWSEncodableShape {
        /// The unique identifier of the access token to delete.
        public let accessTokenId: String

        @inlinable
        public init(accessTokenId: String) {
            self.accessTokenId = accessTokenId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessTokenId, key: "accessTokenId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessTokenId, name: "accessTokenId", parent: name, max: 64)
            try self.validate(self.accessTokenId, name: "accessTokenId", parent: name, min: 1)
            try self.validate(self.accessTokenId, name: "accessTokenId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessTokenOutput: AWSDecodableShape {
        /// The date and time when the access token was deleted.
        @CustomCoding<ISO8601DateCoder>
        public var deletedAt: Date
        /// The unique identifier of the deleted access token.
        public let id: String
        /// The final status of the deleted access token.
        public let status: TokenStatus

        @inlinable
        public init(deletedAt: Date, id: String, status: TokenStatus) {
            self.deletedAt = deletedAt
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case deletedAt = "deletedAt"
            case id = "id"
            case status = "status"
        }
    }

    public struct DeleteDNSViewInput: AWSEncodableShape {
        /// The unique identifier of the DNS view to delete.
        public let dnsViewId: String

        @inlinable
        public init(dnsViewId: String) {
            self.dnsViewId = dnsViewId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dnsViewId, key: "dnsViewId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, max: 64)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDNSViewOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted DNS view.
        public let arn: String
        /// The unique string that identifies the request and ensures idempotency.
        public let clientToken: String?
        /// The date and time when the DNS view was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the deleted DNS view.
        public let description: String?
        /// Whether DNSSEC validation was enabled for the deleted DNS view.
        public let dnssecValidation: DnsSecValidationType
        /// Whether EDNS Client Subnet injection was enabled for the deleted DNS view.
        public let ednsClientSubnet: EdnsClientSubnetType
        /// The firewall rules fail-open behavior that was configured for the deleted DNS view.
        public let firewallRulesFailOpen: FirewallRulesFailOpenType
        /// The ID of the Route 53 Global Resolver that the deleted DNS view was associated with.
        public let globalResolverId: String
        /// The unique identifier of the deleted DNS view.
        public let id: String
        /// The name of the deleted DNS view.
        public let name: String
        /// The final status of the deleted DNS view.
        public let status: ProfileResourceStatus
        /// The date and time when the DNS view was last updated before deletion.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String? = nil, createdAt: Date, description: String? = nil, dnssecValidation: DnsSecValidationType, ednsClientSubnet: EdnsClientSubnetType, firewallRulesFailOpen: FirewallRulesFailOpenType, globalResolverId: String, id: String, name: String, status: ProfileResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnssecValidation = dnssecValidation
            self.ednsClientSubnet = ednsClientSubnet
            self.firewallRulesFailOpen = firewallRulesFailOpen
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnssecValidation = "dnssecValidation"
            case ednsClientSubnet = "ednsClientSubnet"
            case firewallRulesFailOpen = "firewallRulesFailOpen"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteFirewallDomainListInput: AWSEncodableShape {
        /// The unique identifier of the firewall domain list to delete.
        public let firewallDomainListId: String

        @inlinable
        public init(firewallDomainListId: String) {
            self.firewallDomainListId = firewallDomainListId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.firewallDomainListId, key: "firewallDomainListId")
        }

        public func validate(name: String) throws {
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, max: 64)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, min: 1)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFirewallDomainListOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted firewall domain list.
        public let arn: String
        /// The unique identifier of the deleted firewall domain list.
        public let id: String
        /// The name of the deleted firewall domain list.
        public let name: String
        /// The final status of the deleted firewall domain list.
        public let status: CRResourceStatus

        @inlinable
        public init(arn: String, id: String, name: String, status: CRResourceStatus) {
            self.arn = arn
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct DeleteFirewallRuleInput: AWSEncodableShape {
        /// The unique identifier of the firewall rule to delete.
        public let firewallRuleId: String

        @inlinable
        public init(firewallRuleId: String) {
            self.firewallRuleId = firewallRuleId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.firewallRuleId, key: "firewallRuleId")
        }

        public func validate(name: String) throws {
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, max: 64)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, min: 1)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFirewallRuleOutput: AWSDecodableShape {
        /// The action that was configured for the deleted firewall rule.
        public let action: FirewallRuleAction
        /// The DNS record type that was configured for the deleted firewall rule's custom response.
        public let blockOverrideDnsType: BlockOverrideDnsQueryType?
        /// The custom domain that was configured for the deleted firewall rule's BLOCK response.
        public let blockOverrideDomain: String?
        /// The TTL value that was configured for the deleted firewall rule's custom response.
        public let blockOverrideTtl: Int?
        /// The block response type that was configured for the deleted firewall rule.
        public let blockResponse: FirewallBlockResponse?
        /// The confidence threshold that was configured for the deleted firewall rule's advanced threat detection.
        public let confidenceThreshold: ConfidenceThreshold?
        /// The date and time when the firewall rule was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the deleted firewall rule.
        public let description: String?
        /// Whether advanced DNS threat protection was enabled for the deleted firewall rule.
        public let dnsAdvancedProtection: DnsAdvancedProtection?
        /// The ID of the DNS view that was associated with the deleted firewall rule.
        public let dnsViewId: String
        /// The ID of the firewall domain list that was associated with the deleted firewall rule.
        public let firewallDomainListId: String?
        /// The unique identifier of the deleted firewall rule.
        public let id: String
        /// The name of the deleted firewall rule.
        public let name: String
        /// The priority that was configured for the deleted firewall rule.
        public let priority: Int64
        /// The DNS query type that the deleted firewall rule was configured to match.
        public let queryType: String?
        /// The final status of the deleted firewall rule.
        public let status: CRResourceStatus
        /// The date and time when the firewall rule was last updated before deletion.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(action: FirewallRuleAction, blockOverrideDnsType: BlockOverrideDnsQueryType? = nil, blockOverrideDomain: String? = nil, blockOverrideTtl: Int? = nil, blockResponse: FirewallBlockResponse? = nil, confidenceThreshold: ConfidenceThreshold? = nil, createdAt: Date, description: String? = nil, dnsAdvancedProtection: DnsAdvancedProtection? = nil, dnsViewId: String, firewallDomainListId: String? = nil, id: String, name: String, priority: Int64, queryType: String? = nil, status: CRResourceStatus, updatedAt: Date) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.confidenceThreshold = confidenceThreshold
            self.createdAt = createdAt
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.id = id
            self.name = name
            self.priority = priority
            self.queryType = queryType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case blockOverrideDnsType = "blockOverrideDnsType"
            case blockOverrideDomain = "blockOverrideDomain"
            case blockOverrideTtl = "blockOverrideTtl"
            case blockResponse = "blockResponse"
            case confidenceThreshold = "confidenceThreshold"
            case createdAt = "createdAt"
            case description = "description"
            case dnsAdvancedProtection = "dnsAdvancedProtection"
            case dnsViewId = "dnsViewId"
            case firewallDomainListId = "firewallDomainListId"
            case id = "id"
            case name = "name"
            case priority = "priority"
            case queryType = "queryType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteGlobalResolverInput: AWSEncodableShape {
        /// The unique identifier of the Route 53 Global Resolver to delete.
        public let globalResolverId: String

        @inlinable
        public init(globalResolverId: String) {
            self.globalResolverId = globalResolverId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalResolverId, key: "globalResolverId")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, max: 64)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, min: 1)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGlobalResolverOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted Route 53 Global Resolver.
        public let arn: String
        /// The unique string that identifies the request and ensures idempotency.
        public let clientToken: String
        /// The date and time when the Route 53 Global Resolver was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the deleted Route 53 Global Resolver.
        public let description: String?
        /// The hostname that DNS clients used for TLS certificate validation when connecting to the deleted Route 53 Global Resolver.
        public let dnsName: String
        /// The unique identifier of the deleted Route 53 Global Resolver.
        public let id: String
        /// The global anycast IPv4 addresses that were associated with the deleted Route 53 Global Resolver.
        public let ipv4Addresses: [String]
        /// The name of the deleted Route 53 Global Resolver.
        public let name: String
        /// The AWS Region where observability data for the deleted Route 53 Global Resolver was stored.
        public let observabilityRegion: String?
        /// The AWS Regions where the deleted Route 53 Global Resolver was deployed and operational.
        public let regions: [String]
        /// The final status of the deleted Route 53 Global Resolver.
        public let status: CRResourceStatus
        /// The date and time when the Route 53 Global Resolver was last updated before deletion.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String, createdAt: Date, description: String? = nil, dnsName: String, id: String, ipv4Addresses: [String], name: String, observabilityRegion: String? = nil, regions: [String], status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnsName = dnsName
            self.id = id
            self.ipv4Addresses = ipv4Addresses
            self.name = name
            self.observabilityRegion = observabilityRegion
            self.regions = regions
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnsName = "dnsName"
            case id = "id"
            case ipv4Addresses = "ipv4Addresses"
            case name = "name"
            case observabilityRegion = "observabilityRegion"
            case regions = "regions"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DisableDNSViewInput: AWSEncodableShape {
        /// The unique identifier of the DNS view to disable.
        public let dnsViewId: String

        @inlinable
        public init(dnsViewId: String) {
            self.dnsViewId = dnsViewId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dnsViewId, key: "dnsViewId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, max: 64)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisableDNSViewOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the disabled DNS view.
        public let arn: String
        /// The unique string that identifies the request and ensures idempotency.
        public let clientToken: String?
        /// The date and time when the DNS view was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the disabled DNS view.
        public let description: String?
        /// Whether DNSSEC validation is enabled for the disabled DNS view.
        public let dnssecValidation: DnsSecValidationType
        /// Whether EDNS Client Subnet injection is enabled for the disabled DNS view.
        public let ednsClientSubnet: EdnsClientSubnetType
        /// The firewall rules fail-open behavior configured for the disabled DNS view.
        public let firewallRulesFailOpen: FirewallRulesFailOpenType
        /// The ID of the Route 53 Global Resolver that the disabled DNS view is associated with.
        public let globalResolverId: String
        /// The unique identifier of the disabled DNS view.
        public let id: String
        /// The name of the disabled DNS view.
        public let name: String
        /// The current status of the disabled DNS view.
        public let status: ProfileResourceStatus
        /// The date and time when the DNS view was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String? = nil, createdAt: Date, description: String? = nil, dnssecValidation: DnsSecValidationType, ednsClientSubnet: EdnsClientSubnetType, firewallRulesFailOpen: FirewallRulesFailOpenType, globalResolverId: String, id: String, name: String, status: ProfileResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnssecValidation = dnssecValidation
            self.ednsClientSubnet = ednsClientSubnet
            self.firewallRulesFailOpen = firewallRulesFailOpen
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnssecValidation = "dnssecValidation"
            case ednsClientSubnet = "ednsClientSubnet"
            case firewallRulesFailOpen = "firewallRulesFailOpen"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DisassociateHostedZoneInput: AWSEncodableShape {
        /// The ID of the Route 53 private hosted zone to disassociate.
        public let hostedZoneId: String
        /// The Amazon Resource Name (ARN) of the Route 53 Global Resolver resource to disassociate the hosted zone from.
        public let resourceArn: String

        @inlinable
        public init(hostedZoneId: String, resourceArn: String) {
            self.hostedZoneId = hostedZoneId
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hostedZoneId, key: "hostedZoneId")
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, max: 32)
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:[-.a-z0-9]{1,63}:[-.a-z0-9]{0,63}:[-.a-z0-9]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateHostedZoneOutput: AWSDecodableShape {
        /// The date and time when the association was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the Route 53 private hosted zone that was disassociated.
        public let hostedZoneId: String
        /// The name of the Route 53 private hosted zone that was disassociated.
        public let hostedZoneName: String
        /// The unique identifier of the disassociation.
        public let id: String
        /// The name of the association that was removed.
        public let name: String
        /// The Amazon Resource Name (ARN) of the Route 53 Global Resolver resource that the hosted zone was disassociated from.
        public let resourceArn: String
        /// The final status of the disassociation.
        public let status: HostedZoneAssociationStatus
        /// The date and time when the association was last updated before disassociation.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, hostedZoneId: String, hostedZoneName: String, id: String, name: String, resourceArn: String, status: HostedZoneAssociationStatus, updatedAt: Date) {
            self.createdAt = createdAt
            self.hostedZoneId = hostedZoneId
            self.hostedZoneName = hostedZoneName
            self.id = id
            self.name = name
            self.resourceArn = resourceArn
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case hostedZoneId = "hostedZoneId"
            case hostedZoneName = "hostedZoneName"
            case id = "id"
            case name = "name"
            case resourceArn = "resourceArn"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct EnableDNSViewInput: AWSEncodableShape {
        /// The unique identifier of the DNS view to enable.
        public let dnsViewId: String

        @inlinable
        public init(dnsViewId: String) {
            self.dnsViewId = dnsViewId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dnsViewId, key: "dnsViewId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, max: 64)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct EnableDNSViewOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the enabled DNS view.
        public let arn: String
        /// The unique string that identifies the request and ensures idempotency.
        public let clientToken: String?
        /// The date and time when the DNS view was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the enabled DNS view.
        public let description: String?
        /// Whether DNSSEC validation is enabled for the enabled DNS view.
        public let dnssecValidation: DnsSecValidationType
        /// Whether EDNS Client Subnet injection is enabled for the enabled DNS view.
        public let ednsClientSubnet: EdnsClientSubnetType
        /// The firewall rules fail-open behavior configured for the enabled DNS view.
        public let firewallRulesFailOpen: FirewallRulesFailOpenType
        /// The ID of the Route 53 Global Resolver that the enabled DNS view is associated with.
        public let globalResolverId: String
        /// The unique identifier of the enabled DNS view.
        public let id: String
        /// The name of the enabled DNS view.
        public let name: String
        /// The current status of the enabled DNS view.
        public let status: ProfileResourceStatus
        /// The date and time when the DNS view was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String? = nil, createdAt: Date, description: String? = nil, dnssecValidation: DnsSecValidationType, ednsClientSubnet: EdnsClientSubnetType, firewallRulesFailOpen: FirewallRulesFailOpenType, globalResolverId: String, id: String, name: String, status: ProfileResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnssecValidation = dnssecValidation
            self.ednsClientSubnet = ednsClientSubnet
            self.firewallRulesFailOpen = firewallRulesFailOpen
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnssecValidation = "dnssecValidation"
            case ednsClientSubnet = "ednsClientSubnet"
            case firewallRulesFailOpen = "firewallRulesFailOpen"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct FirewallDomainListsItem: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the firewall domain list.
        public let arn: String
        /// The date and time when the firewall domain list was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A description of the firewall domain list.
        public let description: String?
        /// The ID of the global resolver that the firewall domain list is associated with.
        public let globalResolverId: String
        /// The unique identifier of the firewall domain list.
        public let id: String
        /// The name of the firewall domain list.
        public let name: String
        /// The current status of the firewall domain list.
        public let status: CRResourceStatus
        /// The date and time when the firewall domain list was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, globalResolverId: String, id: String, name: String, status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct FirewallRulesItem: AWSDecodableShape {
        /// The action configured for the firewall rule.
        public let action: FirewallRuleAction
        /// The DNS record type configured for the firewall rule's custom response.
        public let blockOverrideDnsType: BlockOverrideDnsQueryType?
        /// The custom domain name configured for the firewall rule's BLOCK response.
        public let blockOverrideDomain: String?
        /// The TTL value configured for the firewall rule's custom response.
        public let blockOverrideTtl: Int?
        /// The type of block response configured for the firewall rule.
        public let blockResponse: FirewallBlockResponse?
        /// The confidence threshold configured for the firewall rule's advanced threat detection.
        public let confidenceThreshold: ConfidenceThreshold?
        /// The date and time when the firewall rule was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the firewall rule.
        public let description: String?
        /// Whether advanced DNS threat protection is enabled for the firewall rule.
        public let dnsAdvancedProtection: DnsAdvancedProtection?
        /// The ID of the DNS view associated with the firewall rule.
        public let dnsViewId: String
        /// The ID of the firewall domain list associated with the firewall rule.
        public let firewallDomainListId: String?
        /// The unique identifier of the firewall rule.
        public let id: String
        /// The name of the firewall rule.
        public let name: String
        /// The priority of the firewall rule.
        public let priority: Int64
        /// The DNS query type that the firewall rule matches.
        public let queryType: String?
        /// The current status of the firewall rule.
        public let status: CRResourceStatus
        /// The date and time when the firewall rule was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(action: FirewallRuleAction, blockOverrideDnsType: BlockOverrideDnsQueryType? = nil, blockOverrideDomain: String? = nil, blockOverrideTtl: Int? = nil, blockResponse: FirewallBlockResponse? = nil, confidenceThreshold: ConfidenceThreshold? = nil, createdAt: Date, description: String? = nil, dnsAdvancedProtection: DnsAdvancedProtection? = nil, dnsViewId: String, firewallDomainListId: String? = nil, id: String, name: String, priority: Int64, queryType: String? = nil, status: CRResourceStatus, updatedAt: Date) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.confidenceThreshold = confidenceThreshold
            self.createdAt = createdAt
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.id = id
            self.name = name
            self.priority = priority
            self.queryType = queryType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case blockOverrideDnsType = "blockOverrideDnsType"
            case blockOverrideDomain = "blockOverrideDomain"
            case blockOverrideTtl = "blockOverrideTtl"
            case blockResponse = "blockResponse"
            case confidenceThreshold = "confidenceThreshold"
            case createdAt = "createdAt"
            case description = "description"
            case dnsAdvancedProtection = "dnsAdvancedProtection"
            case dnsViewId = "dnsViewId"
            case firewallDomainListId = "firewallDomainListId"
            case id = "id"
            case name = "name"
            case priority = "priority"
            case queryType = "queryType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetAccessSourceInput: AWSEncodableShape {
        /// The unique identifier of the access source to retrieve.
        public let accessSourceId: String

        @inlinable
        public init(accessSourceId: String) {
            self.accessSourceId = accessSourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessSourceId, key: "accessSourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessSourceId, name: "accessSourceId", parent: name, max: 64)
            try self.validate(self.accessSourceId, name: "accessSourceId", parent: name, min: 1)
            try self.validate(self.accessSourceId, name: "accessSourceId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessSourceOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access source.
        public let arn: String
        /// The IP range for the rule's parameters in CIDR notation.
        public let cidr: String
        /// The time and date the rule was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// ID for the DNS view that the rule is associated to.
        public let dnsViewId: String
        /// ID for the rule.
        public let id: String
        /// The IP address type.
        public let ipAddressType: IpAddressType
        /// Name for the access source.
        public let name: String?
        /// The protocol determines how data is transmitted to a Global Resolver instance.
        public let `protocol`: DnsProtocol
        /// Information about the status of the rule.
        public let status: CRResourceStatus
        /// The time and date the access source was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, cidr: String, createdAt: Date, dnsViewId: String, id: String, ipAddressType: IpAddressType, name: String? = nil, protocol: DnsProtocol, status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.cidr = cidr
            self.createdAt = createdAt
            self.dnsViewId = dnsViewId
            self.id = id
            self.ipAddressType = ipAddressType
            self.name = name
            self.`protocol` = `protocol`
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cidr = "cidr"
            case createdAt = "createdAt"
            case dnsViewId = "dnsViewId"
            case id = "id"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case `protocol` = "protocol"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetAccessTokenInput: AWSEncodableShape {
        /// ID of the token.
        public let accessTokenId: String

        @inlinable
        public init(accessTokenId: String) {
            self.accessTokenId = accessTokenId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessTokenId, key: "accessTokenId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessTokenId, name: "accessTokenId", parent: name, max: 64)
            try self.validate(self.accessTokenId, name: "accessTokenId", parent: name, min: 1)
            try self.validate(self.accessTokenId, name: "accessTokenId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessTokenOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the token.
        public let arn: String
        /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
        public let clientToken: String?
        /// The time and date the token was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// ID of the DNS view the token is associated to.
        public let dnsViewId: String
        /// The token's expiration time and date.
        @CustomCoding<ISO8601DateCoder>
        public var expiresAt: Date
        /// ID of the Global Resolver.
        public let globalResolverId: String
        /// ID of the token.
        public let id: String
        /// Name of the token.
        public let name: String?
        /// The operational status of the token.
        public let status: TokenStatus
        /// The time and date the token was created.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The value of the token.
        public let value: String

        @inlinable
        public init(arn: String, clientToken: String? = nil, createdAt: Date, dnsViewId: String, expiresAt: Date, globalResolverId: String, id: String, name: String? = nil, status: TokenStatus, updatedAt: Date, value: String) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.dnsViewId = dnsViewId
            self.expiresAt = expiresAt
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case dnsViewId = "dnsViewId"
            case expiresAt = "expiresAt"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case value = "value"
        }
    }

    public struct GetDNSViewInput: AWSEncodableShape {
        /// The ID of the DNS view to retrieve information about.
        public let dnsViewId: String

        @inlinable
        public init(dnsViewId: String) {
            self.dnsViewId = dnsViewId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dnsViewId, key: "dnsViewId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, max: 64)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDNSViewOutput: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the DNS view.
        public let arn: String
        /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
        public let clientToken: String?
        /// The time and date the DNS view was creates on.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Description of the DNS view.
        public let description: String?
        /// Specifies whether DNSSEC is enabled or disabled for the DNS view.
        public let dnssecValidation: DnsSecValidationType
        /// Specifies whether edns0 client subnet is enabled.
        public let ednsClientSubnet: EdnsClientSubnetType
        /// Specifies the DNS Firewall failure mode configuration. When enabled, the DNS Firewall allows DNS queries to proceed if it's unable to properly evaluate them. When disabled, the DNS Firewall blocks DNS queries it's unable to evaluate.
        public let firewallRulesFailOpen: FirewallRulesFailOpenType
        /// ID of the Global Resolver the DNS view is associated to.
        public let globalResolverId: String
        /// ID of the DNS view.
        public let id: String
        /// Name of the DNS view.
        public let name: String
        /// Operational status of the DNS view.
        public let status: ProfileResourceStatus
        /// The time and date the DNS view was updated on.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String? = nil, createdAt: Date, description: String? = nil, dnssecValidation: DnsSecValidationType, ednsClientSubnet: EdnsClientSubnetType, firewallRulesFailOpen: FirewallRulesFailOpenType, globalResolverId: String, id: String, name: String, status: ProfileResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnssecValidation = dnssecValidation
            self.ednsClientSubnet = ednsClientSubnet
            self.firewallRulesFailOpen = firewallRulesFailOpen
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnssecValidation = "dnssecValidation"
            case ednsClientSubnet = "ednsClientSubnet"
            case firewallRulesFailOpen = "firewallRulesFailOpen"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetFirewallDomainListInput: AWSEncodableShape {
        /// ID of the domain list.
        public let firewallDomainListId: String

        @inlinable
        public init(firewallDomainListId: String) {
            self.firewallDomainListId = firewallDomainListId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.firewallDomainListId, key: "firewallDomainListId")
        }

        public func validate(name: String) throws {
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, max: 64)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, min: 1)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFirewallDomainListOutput: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the domain list.
        public let arn: String
        /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
        public let clientToken: String?
        /// The time and date the domain list was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the domain list.
        public let description: String?
        /// Number of domains in the domain list.
        public let domainCount: Int
        /// ID of the Global Resolver that the domain list is associated to.
        public let globalResolverId: String
        /// ID of the domain list.
        public let id: String
        /// Name of the domain list.
        public let name: String
        /// Operational status of the domain list.
        public let status: CRResourceStatus
        /// Additional information about the status of the domain list.
        public let statusMessage: String?
        /// The date and time the domain list was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String? = nil, createdAt: Date, description: String? = nil, domainCount: Int, globalResolverId: String, id: String, name: String, status: CRResourceStatus, statusMessage: String? = nil, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.domainCount = domainCount
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case domainCount = "domainCount"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case statusMessage = "statusMessage"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetFirewallRuleInput: AWSEncodableShape {
        /// ID of the DNS Firewall rule.
        public let firewallRuleId: String

        @inlinable
        public init(firewallRuleId: String) {
            self.firewallRuleId = firewallRuleId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.firewallRuleId, key: "firewallRuleId")
        }

        public func validate(name: String) throws {
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, max: 64)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, min: 1)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFirewallRuleOutput: AWSDecodableShape {
        /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list, or a threat in a DNS Firewall Advanced rule.
        public let action: FirewallRuleAction
        /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public let blockOverrideDnsType: BlockOverrideDnsQueryType?
        /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public let blockOverrideDomain: String?
        /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public let blockOverrideTtl: Int?
        /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
        public let blockResponse: FirewallBlockResponse?
        /// The confidence threshold for DNS Firewall Advanced. You must provide this value when you create a DNS Firewall Advanced rule.
        public let confidenceThreshold: ConfidenceThreshold?
        /// The time and date the DNS Firewall rule was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the DNS Firewall rule.
        public let description: String?
        /// The type of the DNS Firewall Advanced rule. Valid values are DGA and DNS_TUNNELING.
        public let dnsAdvancedProtection: DnsAdvancedProtection?
        /// The DNS view ID the DNS Firewall is associated with.
        public let dnsViewId: String
        /// The ID of a DNS Firewall domain list.
        public let firewallDomainListId: String?
        /// ID of the DNS Firewall rule.
        public let id: String
        /// The name of the DNS Firewall rule.
        public let name: String
        /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
        public let priority: Int64
        /// The DNS query type you want the rule to evaluate.
        public let queryType: String?
        /// The operational status of the DNS Firewall rule.
        public let status: CRResourceStatus
        /// The date and time the DNS Firewall rule was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(action: FirewallRuleAction, blockOverrideDnsType: BlockOverrideDnsQueryType? = nil, blockOverrideDomain: String? = nil, blockOverrideTtl: Int? = nil, blockResponse: FirewallBlockResponse? = nil, confidenceThreshold: ConfidenceThreshold? = nil, createdAt: Date, description: String? = nil, dnsAdvancedProtection: DnsAdvancedProtection? = nil, dnsViewId: String, firewallDomainListId: String? = nil, id: String, name: String, priority: Int64, queryType: String? = nil, status: CRResourceStatus, updatedAt: Date) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.confidenceThreshold = confidenceThreshold
            self.createdAt = createdAt
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.id = id
            self.name = name
            self.priority = priority
            self.queryType = queryType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case blockOverrideDnsType = "blockOverrideDnsType"
            case blockOverrideDomain = "blockOverrideDomain"
            case blockOverrideTtl = "blockOverrideTtl"
            case blockResponse = "blockResponse"
            case confidenceThreshold = "confidenceThreshold"
            case createdAt = "createdAt"
            case description = "description"
            case dnsAdvancedProtection = "dnsAdvancedProtection"
            case dnsViewId = "dnsViewId"
            case firewallDomainListId = "firewallDomainListId"
            case id = "id"
            case name = "name"
            case priority = "priority"
            case queryType = "queryType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetGlobalResolverInput: AWSEncodableShape {
        /// The ID of the Route 53 Global Resolver to retrieve information about.
        public let globalResolverId: String

        @inlinable
        public init(globalResolverId: String) {
            self.globalResolverId = globalResolverId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalResolverId, key: "globalResolverId")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, max: 64)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, min: 1)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGlobalResolverOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Global Resolver.
        public let arn: String
        /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
        public let clientToken: String
        /// The date and time the Global Resolver was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the Global Resolver.
        public let description: String?
        /// The hostname used by the customers' DNS clients for certification validation.
        public let dnsName: String
        /// The ID of the Global Resolver.
        public let id: String
        /// List of anycast IPv4 addresses associated with the Global Resolver instance.
        public let ipv4Addresses: [String]
        /// The name of the Global Resolver.
        public let name: String
        /// The AWS Regions in which the users' Global Resolver query resolution logs will be propagated.
        public let observabilityRegion: String?
        /// The AWS Regions in which the Global Resolver operate.
        public let regions: [String]
        /// The operational status of the Global Resolver.
        public let status: CRResourceStatus
        /// The date and time the Global Resolver was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String, createdAt: Date, description: String? = nil, dnsName: String, id: String, ipv4Addresses: [String], name: String, observabilityRegion: String? = nil, regions: [String], status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnsName = dnsName
            self.id = id
            self.ipv4Addresses = ipv4Addresses
            self.name = name
            self.observabilityRegion = observabilityRegion
            self.regions = regions
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnsName = "dnsName"
            case id = "id"
            case ipv4Addresses = "ipv4Addresses"
            case name = "name"
            case observabilityRegion = "observabilityRegion"
            case regions = "regions"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetHostedZoneAssociationInput: AWSEncodableShape {
        /// ID of the private hosted zone association.
        public let hostedZoneAssociationId: String

        @inlinable
        public init(hostedZoneAssociationId: String) {
            self.hostedZoneAssociationId = hostedZoneAssociationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hostedZoneAssociationId, key: "hostedZoneAssociationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.hostedZoneAssociationId, name: "hostedZoneAssociationId", parent: name, max: 64)
            try self.validate(self.hostedZoneAssociationId, name: "hostedZoneAssociationId", parent: name, min: 1)
            try self.validate(self.hostedZoneAssociationId, name: "hostedZoneAssociationId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetHostedZoneAssociationOutput: AWSDecodableShape {
        /// The time and date the private hosted zone association was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// ID of the hosted zone associated to the DNS view.
        public let hostedZoneId: String
        /// Name of the domain associated with the private hosted zone.
        public let hostedZoneName: String
        /// ID of the private hosted zone association.
        public let id: String
        /// Name of the private hosted zone association.
        public let name: String
        /// Amazon Resource Name (ARN) of the DNS view the private hosted zone is associated to.
        public let resourceArn: String
        /// The operational status of the private hosted zone association.
        public let status: HostedZoneAssociationStatus
        /// The time and date the private hosted zone association was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, hostedZoneId: String, hostedZoneName: String, id: String, name: String, resourceArn: String, status: HostedZoneAssociationStatus, updatedAt: Date) {
            self.createdAt = createdAt
            self.hostedZoneId = hostedZoneId
            self.hostedZoneName = hostedZoneName
            self.id = id
            self.name = name
            self.resourceArn = resourceArn
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case hostedZoneId = "hostedZoneId"
            case hostedZoneName = "hostedZoneName"
            case id = "id"
            case name = "name"
            case resourceArn = "resourceArn"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetManagedFirewallDomainListInput: AWSEncodableShape {
        /// ID of the Managed Domain List.
        public let managedFirewallDomainListId: String

        @inlinable
        public init(managedFirewallDomainListId: String) {
            self.managedFirewallDomainListId = managedFirewallDomainListId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedFirewallDomainListId, key: "managedFirewallDomainListId")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedFirewallDomainListId, name: "managedFirewallDomainListId", parent: name, max: 64)
            try self.validate(self.managedFirewallDomainListId, name: "managedFirewallDomainListId", parent: name, min: 1)
            try self.validate(self.managedFirewallDomainListId, name: "managedFirewallDomainListId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedFirewallDomainListOutput: AWSDecodableShape {
        /// Description of the Managed Domain List.
        public let description: String?
        /// ID of the Managed Domain List.
        public let id: String
        /// Type of the managed category. This is either THREAT or CONTENT.
        public let managedListType: String
        /// Name of the Managed Domain List.
        public let name: String

        @inlinable
        public init(description: String? = nil, id: String, managedListType: String, name: String) {
            self.description = description
            self.id = id
            self.managedListType = managedListType
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case id = "id"
            case managedListType = "managedListType"
            case name = "name"
        }
    }

    public struct GlobalResolversItem: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the global resolver.
        public let arn: String
        /// The unique string that identifies the request and ensures idempotency.
        public let clientToken: String
        /// The date and time when the global resolver was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A description of the global resolver.
        public let description: String?
        /// The DNS name of the global resolver.
        public let dnsName: String
        /// The unique identifier of the global resolver.
        public let id: String
        /// The IPv4 addresses assigned to the global resolver.
        public let ipv4Addresses: [String]
        /// The name of the global resolver.
        public let name: String
        /// The AWS Region where observability data is collected for the global resolver.
        public let observabilityRegion: String?
        /// The AWS Regions where the global resolver is deployed.
        public let regions: [String]
        /// The current status of the global resolver.
        public let status: CRResourceStatus
        /// The date and time when the global resolver was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String, createdAt: Date, description: String? = nil, dnsName: String, id: String, ipv4Addresses: [String], name: String, observabilityRegion: String? = nil, regions: [String], status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnsName = dnsName
            self.id = id
            self.ipv4Addresses = ipv4Addresses
            self.name = name
            self.observabilityRegion = observabilityRegion
            self.regions = regions
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnsName = "dnsName"
            case id = "id"
            case ipv4Addresses = "ipv4Addresses"
            case name = "name"
            case observabilityRegion = "observabilityRegion"
            case regions = "regions"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct HostedZoneAssociationSummary: AWSDecodableShape {
        /// The date and time when the hosted zone association was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the hosted zone.
        public let hostedZoneId: String
        /// The name of the hosted zone.
        public let hostedZoneName: String
        /// The unique identifier of the hosted zone association.
        public let id: String
        /// The name of the hosted zone association.
        public let name: String
        /// The Amazon Resource Name (ARN) of the resource associated with the hosted zone.
        public let resourceArn: String
        /// The current status of the hosted zone association.
        public let status: HostedZoneAssociationStatus
        /// The date and time when the hosted zone association was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, hostedZoneId: String, hostedZoneName: String, id: String, name: String, resourceArn: String, status: HostedZoneAssociationStatus, updatedAt: Date) {
            self.createdAt = createdAt
            self.hostedZoneId = hostedZoneId
            self.hostedZoneName = hostedZoneName
            self.id = id
            self.name = name
            self.resourceArn = resourceArn
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case hostedZoneId = "hostedZoneId"
            case hostedZoneName = "hostedZoneName"
            case id = "id"
            case name = "name"
            case resourceArn = "resourceArn"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct ImportFirewallDomainsInput: AWSEncodableShape {
        /// The fully qualified URL of the file in Amazon S3 that contains the list of domains to import. The file should contain one domain per line.
        public let domainFileUrl: String
        /// ID of the DNS Firewall domain list that you want to import the domain list to.
        public let firewallDomainListId: String
        /// This value is REPLACE, and it updates the domain list to match the list of domains in the imported file.
        public let operation: String

        @inlinable
        public init(domainFileUrl: String, firewallDomainListId: String, operation: String) {
            self.domainFileUrl = domainFileUrl
            self.firewallDomainListId = firewallDomainListId
            self.operation = operation
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.domainFileUrl, forKey: .domainFileUrl)
            request.encodePath(self.firewallDomainListId, key: "firewallDomainListId")
            try container.encode(self.operation, forKey: .operation)
        }

        public func validate(name: String) throws {
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, max: 64)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, min: 1)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainFileUrl = "domainFileUrl"
            case operation = "operation"
        }
    }

    public struct ImportFirewallDomainsOutput: AWSDecodableShape {
        /// ID of the DNS Firewall domain list that you imported the domain list to.
        public let id: String
        /// Name of the DNS Firewall domain list.
        public let name: String
        /// Operational status of the DNS Firewall domain list.
        public let status: CRResourceStatus

        @inlinable
        public init(id: String, name: String, status: CRResourceStatus) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// Number of seconds in which the caller can retry the request.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ListAccessSourcesInput: AWSEncodableShape {
        /// Values to filter the results.
        public let filters: [String: [String]]?
        /// The maximum number of results to retrieve in a single call.
        public let maxResults: Int?
        /// A pagination token used for large sets of results that can't be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(filters: [String: [String]]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.filters)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessSourcesOutput: AWSDecodableShape {
        /// An array containing information about the access sources, such as the ID, CIDR etc.
        public let accessSources: [AccessSourcesItem]
        /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
        public let nextToken: String?

        @inlinable
        public init(accessSources: [AccessSourcesItem], nextToken: String? = nil) {
            self.accessSources = accessSources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessSources = "accessSources"
            case nextToken = "nextToken"
        }
    }

    public struct ListAccessTokensInput: AWSEncodableShape {
        /// The ID of the DNS view to list the tokens for.
        public let dnsViewId: String
        /// Filtering parameters.
        public let filters: [String: [String]]?
        /// The maximum number of results to retrieve in a single call.
        public let maxResults: Int?
        /// A pagination token used for large sets of results that can't be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(dnsViewId: String, filters: [String: [String]]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dnsViewId = dnsViewId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dnsViewId, key: "dnsViewId")
            request.encodeQuery(self.filters)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        public func validate(name: String) throws {
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, max: 64)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessTokensOutput: AWSDecodableShape {
        /// List of the tokens.
        public let accessTokens: [AccessTokenItem]?
        /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
        public let nextToken: String?

        @inlinable
        public init(accessTokens: [AccessTokenItem]? = nil, nextToken: String? = nil) {
            self.accessTokens = accessTokens
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessTokens = "accessTokens"
            case nextToken = "nextToken"
        }
    }

    public struct ListDNSViewsInput: AWSEncodableShape {
        /// The Global Resolver ID.
        public let globalResolverId: String
        /// The maximum number of results to retrieve in a single call.
        public let maxResults: Int?
        /// A pagination token used for large sets of results that can't be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(globalResolverId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.globalResolverId = globalResolverId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalResolverId, key: "globalResolverId")
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, max: 64)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, min: 1)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDNSViewsOutput: AWSDecodableShape {
        /// An array of information about the DNS views, such as whether DNSSEC is enabled, creation time, etc.
        public let dnsViews: [DNSViewSummary]
        /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
        public let nextToken: String?

        @inlinable
        public init(dnsViews: [DNSViewSummary], nextToken: String? = nil) {
            self.dnsViews = dnsViews
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dnsViews = "dnsViews"
            case nextToken = "nextToken"
        }
    }

    public struct ListFirewallDomainListsInput: AWSEncodableShape {
        /// The ID of the Global Resolver that contains the DNS view the domain lists are associated to.
        public let globalResolverId: String?
        /// The maximum number of results to retrieve in a single call.
        public let maxResults: Int?
        /// A pagination token used for large sets of results that can't be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(globalResolverId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.globalResolverId = globalResolverId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.globalResolverId, key: "global_resolver_id")
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, max: 64)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, min: 1)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFirewallDomainListsOutput: AWSDecodableShape {
        /// List of the DNS Firewall domain lists.
        public let firewallDomainLists: [FirewallDomainListsItem]
        /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
        public let nextToken: String?

        @inlinable
        public init(firewallDomainLists: [FirewallDomainListsItem], nextToken: String? = nil) {
            self.firewallDomainLists = firewallDomainLists
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case firewallDomainLists = "firewallDomainLists"
            case nextToken = "nextToken"
        }
    }

    public struct ListFirewallDomainsInput: AWSEncodableShape {
        /// ID of the DNS Firewall domain list.
        public let firewallDomainListId: String
        /// The maximum number of results to retrieve in a single call.
        public let maxResults: Int?
        /// A pagination token used for large sets of results that can't be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(firewallDomainListId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.firewallDomainListId = firewallDomainListId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.firewallDomainListId, key: "firewallDomainListId")
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        public func validate(name: String) throws {
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, max: 64)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, min: 1)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFirewallDomainsOutput: AWSDecodableShape {
        /// List of domains in the specified domain list.
        public let domains: [String]
        /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
        public let nextToken: String?

        @inlinable
        public init(domains: [String], nextToken: String? = nil) {
            self.domains = domains
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domains = "domains"
            case nextToken = "nextToken"
        }
    }

    public struct ListFirewallRulesInput: AWSEncodableShape {
        /// ID of the DNS view.
        public let dnsViewId: String
        /// Values to filter the results.
        public let filters: [String: [String]]?
        /// The maximum number of results to retrieve in a single call.
        public let maxResults: Int?
        /// A pagination token used for large sets of results that can't be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(dnsViewId: String, filters: [String: [String]]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dnsViewId = dnsViewId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.dnsViewId, key: "dnsview_id")
            request.encodeQuery(self.filters)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        public func validate(name: String) throws {
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, max: 64)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFirewallRulesOutput: AWSDecodableShape {
        /// List of the firewall rules and information about them.
        public let firewallRules: [FirewallRulesItem]
        /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
        public let nextToken: String?

        @inlinable
        public init(firewallRules: [FirewallRulesItem], nextToken: String? = nil) {
            self.firewallRules = firewallRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case firewallRules = "firewallRules"
            case nextToken = "nextToken"
        }
    }

    public struct ListGlobalResolversInput: AWSEncodableShape {
        /// The maximum number of Route 53 Global Resolver instances to return in the response. Valid range is 1-100.
        public let maxResults: Int?
        /// The token for the next page of results. This value is returned in the response if there are more results to retrieve.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGlobalResolversOutput: AWSDecodableShape {
        /// Paginated list of Global Resolvers.
        public let globalResolvers: [GlobalResolversItem]
        /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
        public let nextToken: String?

        @inlinable
        public init(globalResolvers: [GlobalResolversItem], nextToken: String? = nil) {
            self.globalResolvers = globalResolvers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case globalResolvers = "globalResolvers"
            case nextToken = "nextToken"
        }
    }

    public struct ListHostedZoneAssociationsInput: AWSEncodableShape {
        /// The maximum number of results to retrieve in a single call.
        public let maxResults: Int?
        /// A pagination token used for large sets of results that can't be returned in a single response.
        public let nextToken: String?
        /// Amazon Resource Name (ARN) of the DNS view.
        public let resourceArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:[-.a-z0-9]{1,63}:[-.a-z0-9]{0,63}:[-.a-z0-9]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListHostedZoneAssociationsOutput: AWSDecodableShape {
        /// List of the private hosted zone associations.
        public let hostedZoneAssociations: [HostedZoneAssociationSummary]
        /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
        public let nextToken: String?

        @inlinable
        public init(hostedZoneAssociations: [HostedZoneAssociationSummary], nextToken: String? = nil) {
            self.hostedZoneAssociations = hostedZoneAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case hostedZoneAssociations = "hostedZoneAssociations"
            case nextToken = "nextToken"
        }
    }

    public struct ListManagedFirewallDomainListsInput: AWSEncodableShape {
        /// The category of the Manage DNS list either THREAT or CONTENT.
        public let managedFirewallDomainListType: String
        /// The maximum number of results to retrieve in a single call.
        public let maxResults: Int?
        /// A pagination token used for large sets of results that can't be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(managedFirewallDomainListType: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.managedFirewallDomainListType = managedFirewallDomainListType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedFirewallDomainListType, key: "managedFirewallDomainListType")
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListManagedFirewallDomainListsOutput: AWSDecodableShape {
        /// List of the Managed Domain Lists.
        public let managedFirewallDomainLists: [ManagedFirewallDomainListsItem]
        /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
        public let nextToken: String?

        @inlinable
        public init(managedFirewallDomainLists: [ManagedFirewallDomainListsItem], nextToken: String? = nil) {
            self.managedFirewallDomainLists = managedFirewallDomainLists
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case managedFirewallDomainLists = "managedFirewallDomainLists"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:[-.a-z0-9]{1,63}:[-.a-z0-9]{0,63}:[-.a-z0-9]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// An array of user-defined keys and optional values. These tags can be used for categorization and organization.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ManagedFirewallDomainListsItem: AWSDecodableShape {
        /// A description of the managed firewall domain list.
        public let description: String?
        /// The unique identifier of the managed firewall domain list.
        public let id: String
        /// The type of the managed firewall domain list.
        public let managedListType: String
        /// The name of the managed firewall domain list.
        public let name: String

        @inlinable
        public init(description: String? = nil, id: String, managedListType: String, name: String) {
            self.description = description
            self.id = id
            self.managedListType = managedListType
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case id = "id"
            case managedListType = "managedListType"
            case name = "name"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The unique ID of the resource referenced in the failed request.
        public let resourceId: String?
        /// The resource type of the resource referenced in the failed request.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The quota code recognized by the AWS Service Quotas service.
        public let quotaCode: String?
        /// The unique ID of the resource referenced in the failed request.
        public let resourceId: String?
        /// The resource type of the resource referenced in the failed request.
        public let resourceType: String
        /// The code for the AWS service that owns the quota.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, resourceId: String? = nil, resourceType: String, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the resource to be tagged.
        public let resourceArn: String
        /// An array of user-defined keys and optional values. These tags can be used for categorization and organization.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:[-.a-z0-9]{1,63}:[-.a-z0-9]{0,63}:[-.a-z0-9]{0,63}:[^/].{0,1023}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// The quota code recognized by the AWS Service Quotas service.
        public let quotaCode: String?
        /// Number of seconds in which the caller can retry the request.
        public let retryAfterSeconds: Int?
        /// The code for the AWS service that owns the quota.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys associated with the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:[-.a-z0-9]{1,63}:[-.a-z0-9]{0,63}:[-.a-z0-9]{0,63}:[^/].{0,1023}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccessSourceInput: AWSEncodableShape {
        /// The unique identifier of the access source to update.
        public let accessSourceId: String
        /// The CIDR block for the access source.
        public let cidr: String?
        /// The IP address type for the access source.
        public let ipAddressType: IpAddressType?
        /// The name of the access source.
        public let name: String?
        /// The protocol for the access source.
        public let `protocol`: DnsProtocol?

        @inlinable
        public init(accessSourceId: String, cidr: String? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil, protocol: DnsProtocol? = nil) {
            self.accessSourceId = accessSourceId
            self.cidr = cidr
            self.ipAddressType = ipAddressType
            self.name = name
            self.`protocol` = `protocol`
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessSourceId, key: "accessSourceId")
            try container.encodeIfPresent(self.cidr, forKey: .cidr)
            try container.encodeIfPresent(self.ipAddressType, forKey: .ipAddressType)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.`protocol`, forKey: .`protocol`)
        }

        public func validate(name: String) throws {
            try self.validate(self.accessSourceId, name: "accessSourceId", parent: name, max: 64)
            try self.validate(self.accessSourceId, name: "accessSourceId", parent: name, min: 1)
            try self.validate(self.accessSourceId, name: "accessSourceId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.cidr, name: "cidr", parent: name, max: 42)
            try self.validate(self.cidr, name: "cidr", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "cidr"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case `protocol` = "protocol"
        }
    }

    public struct UpdateAccessSourceOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated access source.
        public let arn: String
        /// The CIDR block of the updated access source.
        public let cidr: String
        /// The date and time when the access source was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the DNS view associated with the updated access source.
        public let dnsViewId: String
        /// The unique identifier of the updated access source.
        public let id: String
        /// The IP address type of the updated access source.
        public let ipAddressType: IpAddressType
        /// The name of the updated access source.
        public let name: String?
        /// The protocol of the updated access source.
        public let `protocol`: DnsProtocol
        /// The current status of the updated access source.
        public let status: CRResourceStatus
        /// The date and time when the access source was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, cidr: String, createdAt: Date, dnsViewId: String, id: String, ipAddressType: IpAddressType, name: String? = nil, protocol: DnsProtocol, status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.cidr = cidr
            self.createdAt = createdAt
            self.dnsViewId = dnsViewId
            self.id = id
            self.ipAddressType = ipAddressType
            self.name = name
            self.`protocol` = `protocol`
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cidr = "cidr"
            case createdAt = "createdAt"
            case dnsViewId = "dnsViewId"
            case id = "id"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case `protocol` = "protocol"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateAccessTokenInput: AWSEncodableShape {
        /// The ID of the token.
        public let accessTokenId: String
        /// The new name of the token.
        public let name: String

        @inlinable
        public init(accessTokenId: String, name: String) {
            self.accessTokenId = accessTokenId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessTokenId, key: "accessTokenId")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.accessTokenId, name: "accessTokenId", parent: name, max: 64)
            try self.validate(self.accessTokenId, name: "accessTokenId", parent: name, min: 1)
            try self.validate(self.accessTokenId, name: "accessTokenId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct UpdateAccessTokenOutput: AWSDecodableShape {
        /// The ID of the token.
        public let id: String
        /// The name of the token.
        public let name: String

        @inlinable
        public init(id: String, name: String) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct UpdateDNSViewInput: AWSEncodableShape {
        /// A description of the DNS view.
        public let description: String?
        /// Whether to enable DNSSEC validation for the DNS view.
        public let dnssecValidation: DnsSecValidationType?
        /// The unique identifier of the DNS view to update.
        public let dnsViewId: String
        /// Whether to enable EDNS Client Subnet injection for the DNS view.
        public let ednsClientSubnet: EdnsClientSubnetType?
        /// Whether firewall rules should fail open when they cannot be evaluated.
        public let firewallRulesFailOpen: FirewallRulesFailOpenType?
        /// The name of the DNS view.
        public let name: String?

        @inlinable
        public init(description: String? = nil, dnssecValidation: DnsSecValidationType? = nil, dnsViewId: String, ednsClientSubnet: EdnsClientSubnetType? = nil, firewallRulesFailOpen: FirewallRulesFailOpenType? = nil, name: String? = nil) {
            self.description = description
            self.dnssecValidation = dnssecValidation
            self.dnsViewId = dnsViewId
            self.ednsClientSubnet = ednsClientSubnet
            self.firewallRulesFailOpen = firewallRulesFailOpen
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.dnssecValidation, forKey: .dnssecValidation)
            request.encodePath(self.dnsViewId, key: "dnsViewId")
            try container.encodeIfPresent(self.ednsClientSubnet, forKey: .ednsClientSubnet)
            try container.encodeIfPresent(self.firewallRulesFailOpen, forKey: .firewallRulesFailOpen)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, max: 64)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, min: 1)
            try self.validate(self.dnsViewId, name: "dnsViewId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case dnssecValidation = "dnssecValidation"
            case ednsClientSubnet = "ednsClientSubnet"
            case firewallRulesFailOpen = "firewallRulesFailOpen"
            case name = "name"
        }
    }

    public struct UpdateDNSViewOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated DNS view.
        public let arn: String
        /// The unique string that identifies the request and ensures idempotency.
        public let clientToken: String?
        /// The date and time when the DNS view was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the updated DNS view.
        public let description: String?
        /// Whether DNSSEC validation is enabled for the updated DNS view.
        public let dnssecValidation: DnsSecValidationType
        /// Whether EDNS Client Subnet injection is enabled for the updated DNS view.
        public let ednsClientSubnet: EdnsClientSubnetType
        /// Whether firewall rules fail open when they cannot be evaluated for the updated DNS view.
        public let firewallRulesFailOpen: FirewallRulesFailOpenType
        /// The ID of the global resolver associated with the updated DNS view.
        public let globalResolverId: String
        /// The unique identifier of the updated DNS view.
        public let id: String
        /// The name of the updated DNS view.
        public let name: String
        /// The current status of the updated DNS view.
        public let status: ProfileResourceStatus
        /// The date and time when the DNS view was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String? = nil, createdAt: Date, description: String? = nil, dnssecValidation: DnsSecValidationType, ednsClientSubnet: EdnsClientSubnetType, firewallRulesFailOpen: FirewallRulesFailOpenType, globalResolverId: String, id: String, name: String, status: ProfileResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnssecValidation = dnssecValidation
            self.ednsClientSubnet = ednsClientSubnet
            self.firewallRulesFailOpen = firewallRulesFailOpen
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnssecValidation = "dnssecValidation"
            case ednsClientSubnet = "ednsClientSubnet"
            case firewallRulesFailOpen = "firewallRulesFailOpen"
            case globalResolverId = "globalResolverId"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateFirewallDomainsInput: AWSEncodableShape {
        /// A list of the domains. You can add up to 1000 domains per request.
        public let domains: [String]
        /// The ID of the DNS Firewall domain list to which you want to add the domains.
        public let firewallDomainListId: String
        /// The operation for updating the domain list. The allowed values are ADD, REMOVE, and REPLACE.
        public let operation: String

        @inlinable
        public init(domains: [String], firewallDomainListId: String, operation: String) {
            self.domains = domains
            self.firewallDomainListId = firewallDomainListId
            self.operation = operation
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.domains, forKey: .domains)
            request.encodePath(self.firewallDomainListId, key: "firewallDomainListId")
            try container.encode(self.operation, forKey: .operation)
        }

        public func validate(name: String) throws {
            try self.domains.forEach {
                try validate($0, name: "domains[]", parent: name, max: 256)
                try validate($0, name: "domains[]", parent: name, min: 1)
                try validate($0, name: "domains[]", parent: name, pattern: "^\\*?[-a-zA-Z0-9.]+$")
            }
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, max: 64)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, min: 1)
            try self.validate(self.firewallDomainListId, name: "firewallDomainListId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domains = "domains"
            case operation = "operation"
        }
    }

    public struct UpdateFirewallDomainsOutput: AWSDecodableShape {
        /// The ID of the DNS Firewall domain list.
        public let id: String
        /// The name of the domain list.
        public let name: String
        /// The operational status of the domain list.
        public let status: CRResourceStatus

        @inlinable
        public init(id: String, name: String, status: CRResourceStatus) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct UpdateFirewallRuleInput: AWSEncodableShape {
        /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list, or a threat in a DNS Firewall Advanced rule.
        public let action: FirewallRuleAction?
        /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public let blockOverrideDnsType: BlockOverrideDnsQueryType?
        /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public let blockOverrideDomain: String?
        /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public let blockOverrideTtl: Int?
        /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
        public let blockResponse: FirewallBlockResponse?
        /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
        public let clientToken: String
        /// The confidence threshold for DNS Firewall Advanced. You must provide this value when you create a DNS Firewall Advanced rule.
        public let confidenceThreshold: ConfidenceThreshold?
        /// The description for the Firewall rule.
        public let description: String?
        /// The type of the DNS Firewall Advanced rule. Valid values are DGA and DNS_TUNNELING.
        public let dnsAdvancedProtection: DnsAdvancedProtection?
        /// The ID of the DNS Firewall rule.
        public let firewallRuleId: String
        /// The name of the DNS Firewall rule.
        public let name: String?
        /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
        public let priority: Int64?

        @inlinable
        public init(action: FirewallRuleAction? = nil, blockOverrideDnsType: BlockOverrideDnsQueryType? = nil, blockOverrideDomain: String? = nil, blockOverrideTtl: Int? = nil, blockResponse: FirewallBlockResponse? = nil, clientToken: String = UpdateFirewallRuleInput.idempotencyToken(), confidenceThreshold: ConfidenceThreshold? = nil, description: String? = nil, dnsAdvancedProtection: DnsAdvancedProtection? = nil, firewallRuleId: String, name: String? = nil, priority: Int64? = nil) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.clientToken = clientToken
            self.confidenceThreshold = confidenceThreshold
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.firewallRuleId = firewallRuleId
            self.name = name
            self.priority = priority
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.action, forKey: .action)
            try container.encodeIfPresent(self.blockOverrideDnsType, forKey: .blockOverrideDnsType)
            try container.encodeIfPresent(self.blockOverrideDomain, forKey: .blockOverrideDomain)
            try container.encodeIfPresent(self.blockOverrideTtl, forKey: .blockOverrideTtl)
            try container.encodeIfPresent(self.blockResponse, forKey: .blockResponse)
            try container.encode(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.confidenceThreshold, forKey: .confidenceThreshold)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.dnsAdvancedProtection, forKey: .dnsAdvancedProtection)
            request.encodePath(self.firewallRuleId, key: "firewallRuleId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.priority, forKey: .priority)
        }

        public func validate(name: String) throws {
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, max: 256)
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, min: 1)
            try self.validate(self.blockOverrideDomain, name: "blockOverrideDomain", parent: name, pattern: "^\\*?[-a-zA-Z0-9.]+$")
            try self.validate(self.blockOverrideTtl, name: "blockOverrideTtl", parent: name, max: 604800)
            try self.validate(self.blockOverrideTtl, name: "blockOverrideTtl", parent: name, min: 0)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, max: 64)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, min: 1)
            try self.validate(self.firewallRuleId, name: "firewallRuleId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
            try self.validate(self.priority, name: "priority", parent: name, max: 10000)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case blockOverrideDnsType = "blockOverrideDnsType"
            case blockOverrideDomain = "blockOverrideDomain"
            case blockOverrideTtl = "blockOverrideTtl"
            case blockResponse = "blockResponse"
            case clientToken = "clientToken"
            case confidenceThreshold = "confidenceThreshold"
            case description = "description"
            case dnsAdvancedProtection = "dnsAdvancedProtection"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct UpdateFirewallRuleOutput: AWSDecodableShape {
        /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list, or a threat in a DNS Firewall Advanced rule.
        public let action: FirewallRuleAction
        /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public let blockOverrideDnsType: BlockOverrideDnsQueryType?
        /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public let blockOverrideDomain: String?
        /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public let blockOverrideTtl: Int?
        /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
        public let blockResponse: FirewallBlockResponse?
        /// The confidence threshold for DNS Firewall Advanced. You must provide this value when you create a DNS Firewall Advanced rule.
        public let confidenceThreshold: ConfidenceThreshold?
        /// The time and date the Firewall rule was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the Firewall rule.
        public let description: String?
        /// The type of the DNS Firewall Advanced rule. Valid values are DGA and DNS_TUNNELING.
        public let dnsAdvancedProtection: DnsAdvancedProtection?
        /// The ID of the DNS view the Firewall rule is associated with.
        public let dnsViewId: String
        /// The ID of the domain list associated with the Firewall rule.
        public let firewallDomainListId: String?
        /// The ID of the Firewall rule.
        public let id: String
        /// The name of the Firewall rule.
        public let name: String
        /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
        public let priority: Int64
        /// The DNS query type you want the rule to evaluate.
        public let queryType: String?
        /// The operational status of the firewall rule.
        public let status: CRResourceStatus
        /// The time and date the rule was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(action: FirewallRuleAction, blockOverrideDnsType: BlockOverrideDnsQueryType? = nil, blockOverrideDomain: String? = nil, blockOverrideTtl: Int? = nil, blockResponse: FirewallBlockResponse? = nil, confidenceThreshold: ConfidenceThreshold? = nil, createdAt: Date, description: String? = nil, dnsAdvancedProtection: DnsAdvancedProtection? = nil, dnsViewId: String, firewallDomainListId: String? = nil, id: String, name: String, priority: Int64, queryType: String? = nil, status: CRResourceStatus, updatedAt: Date) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.confidenceThreshold = confidenceThreshold
            self.createdAt = createdAt
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.id = id
            self.name = name
            self.priority = priority
            self.queryType = queryType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case blockOverrideDnsType = "blockOverrideDnsType"
            case blockOverrideDomain = "blockOverrideDomain"
            case blockOverrideTtl = "blockOverrideTtl"
            case blockResponse = "blockResponse"
            case confidenceThreshold = "confidenceThreshold"
            case createdAt = "createdAt"
            case description = "description"
            case dnsAdvancedProtection = "dnsAdvancedProtection"
            case dnsViewId = "dnsViewId"
            case firewallDomainListId = "firewallDomainListId"
            case id = "id"
            case name = "name"
            case priority = "priority"
            case queryType = "queryType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateGlobalResolverInput: AWSEncodableShape {
        /// The description of the Global Resolver.
        public let description: String?
        /// The ID of the Global Resolver.
        public let globalResolverId: String
        /// The name of the Global Resolver.
        public let name: String?
        /// The AWS Regions in which the users' Global Resolver query resolution logs will be propagated.
        public let observabilityRegion: String?

        @inlinable
        public init(description: String? = nil, globalResolverId: String, name: String? = nil, observabilityRegion: String? = nil) {
            self.description = description
            self.globalResolverId = globalResolverId
            self.name = name
            self.observabilityRegion = observabilityRegion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalResolverId, key: "globalResolverId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.observabilityRegion, forKey: .observabilityRegion)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, max: 64)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, min: 1)
            try self.validate(self.globalResolverId, name: "globalResolverId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
            try self.validate(self.observabilityRegion, name: "observabilityRegion", parent: name, max: 32)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case observabilityRegion = "observabilityRegion"
        }
    }

    public struct UpdateGlobalResolverOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Global Resolver.
        public let arn: String
        /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
        public let clientToken: String
        /// The time and date the Global Resolverwas created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Description of the Global Resolver.
        public let description: String?
        /// The hostname to be used by the customers' DNS clients for certification validation.
        public let dnsName: String
        /// The ID of the Global Resolver.
        public let id: String
        /// List of anycast IPv4 addresses associated with the Global Resolver instance.
        public let ipv4Addresses: [String]
        /// Name of the Global Resolver.
        public let name: String
        /// The AWS Regions in which the users' Global Resolver query resolution logs will be propagated.
        public let observabilityRegion: String?
        /// The AWS Regions in which the Global Resolver will operate.
        public let regions: [String]
        /// The operational status of the Global Resolver.
        public let status: CRResourceStatus
        /// The time and date the Global Resolver was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, clientToken: String, createdAt: Date, description: String? = nil, dnsName: String, id: String, ipv4Addresses: [String], name: String, observabilityRegion: String? = nil, regions: [String], status: CRResourceStatus, updatedAt: Date) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnsName = dnsName
            self.id = id
            self.ipv4Addresses = ipv4Addresses
            self.name = name
            self.observabilityRegion = observabilityRegion
            self.regions = regions
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case description = "description"
            case dnsName = "dnsName"
            case id = "id"
            case ipv4Addresses = "ipv4Addresses"
            case name = "name"
            case observabilityRegion = "observabilityRegion"
            case regions = "regions"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateHostedZoneAssociationInput: AWSEncodableShape {
        /// The ID of the private hosted zone association.
        public let hostedZoneAssociationId: String
        /// The name you want to update the hosted zone association to.
        public let name: String?

        @inlinable
        public init(hostedZoneAssociationId: String, name: String? = nil) {
            self.hostedZoneAssociationId = hostedZoneAssociationId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hostedZoneAssociationId, key: "hostedZoneAssociationId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.hostedZoneAssociationId, name: "hostedZoneAssociationId", parent: name, max: 64)
            try self.validate(self.hostedZoneAssociationId, name: "hostedZoneAssociationId", parent: name, min: 1)
            try self.validate(self.hostedZoneAssociationId, name: "hostedZoneAssociationId", parent: name, pattern: "^[-.a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!^[0-9]+$)([a-zA-Z0-9-_/' ']+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct UpdateHostedZoneAssociationOutput: AWSDecodableShape {
        /// The time and date the private hosted zone association was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ID of the private hosted zone.
        public let hostedZoneId: String
        /// The name of the domain associated with the private hosted zone.
        public let hostedZoneName: String
        /// The ID of the private hosted zone association.
        public let id: String
        /// The name of the private hosted zone association.
        public let name: String
        /// The Amazon Resource Name (ARN) of the private hosted zone association.
        public let resourceArn: String
        /// The operational status of the private hosted zone association.
        public let status: HostedZoneAssociationStatus
        /// The time and date the private hosted zone association was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, hostedZoneId: String, hostedZoneName: String, id: String, name: String, resourceArn: String, status: HostedZoneAssociationStatus, updatedAt: Date) {
            self.createdAt = createdAt
            self.hostedZoneId = hostedZoneId
            self.hostedZoneName = hostedZoneName
            self.id = id
            self.name = name
            self.resourceArn = resourceArn
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case hostedZoneId = "hostedZoneId"
            case hostedZoneName = "hostedZoneName"
            case id = "id"
            case name = "name"
            case resourceArn = "resourceArn"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The list of fields that aren't valid.
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        /// Reason the request failed validation.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The validation error message for the field.
        public let message: String
        /// The name of the field that failed validation.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }
}

// MARK: - Errors

/// Error enum for Route53GlobalResolver
public struct Route53GlobalResolverErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Route53GlobalResolver
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have permission to perform this operation. Check your IAM permissions and try again.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request conflicts with the current state of the resource. This can occur when trying to modify a resource that is not in a valid state for the requested operation.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error occurred. Try again later.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource was not found. Verify the resource ID and try again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would exceed one or more service quotas. Check your current usage and quotas, then try again.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was throttled due to too many requests. Wait a moment and try again.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input parameters are invalid. Check the parameter values and try again.
    public static var validationException: Self { .init(.validationException) }
}

extension Route53GlobalResolverErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": Route53GlobalResolver.ConflictException.self,
        "InternalServerException": Route53GlobalResolver.InternalServerException.self,
        "ResourceNotFoundException": Route53GlobalResolver.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": Route53GlobalResolver.ServiceQuotaExceededException.self,
        "ThrottlingException": Route53GlobalResolver.ThrottlingException.self,
        "ValidationException": Route53GlobalResolver.ValidationException.self
    ]
}

extension Route53GlobalResolverErrorType: Equatable {
    public static func == (lhs: Route53GlobalResolverErrorType, rhs: Route53GlobalResolverErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension Route53GlobalResolverErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
