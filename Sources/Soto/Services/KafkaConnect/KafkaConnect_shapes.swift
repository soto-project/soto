//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension KafkaConnect {
    // MARK: Enums

    public enum ConnectorState: String, CustomStringConvertible, Codable, _SotoSendable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case running = "RUNNING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum CustomPluginContentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case jar = "JAR"
        case zip = "ZIP"
        public var description: String { return self.rawValue }
    }

    public enum CustomPluginState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum KafkaClusterClientAuthenticationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case iam = "IAM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum KafkaClusterEncryptionInTransitType: String, CustomStringConvertible, Codable, _SotoSendable {
        case plaintext = "PLAINTEXT"
        case tls = "TLS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ApacheKafkaCluster: AWSEncodableShape {
        /// The bootstrap servers of the cluster.
        public let bootstrapServers: String
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        public let vpc: Vpc

        public init(bootstrapServers: String, vpc: Vpc) {
            self.bootstrapServers = bootstrapServers
            self.vpc = vpc
        }

        private enum CodingKeys: String, CodingKey {
            case bootstrapServers
            case vpc
        }
    }

    public struct ApacheKafkaClusterDescription: AWSDecodableShape {
        /// The bootstrap servers of the cluster.
        public let bootstrapServers: String?
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        public let vpc: VpcDescription?

        public init(bootstrapServers: String? = nil, vpc: VpcDescription? = nil) {
            self.bootstrapServers = bootstrapServers
            self.vpc = vpc
        }

        private enum CodingKeys: String, CodingKey {
            case bootstrapServers
            case vpc
        }
    }

    public struct AutoScaling: AWSEncodableShape {
        /// The maximum number of workers allocated to the connector.
        public let maxWorkerCount: Int
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int
        /// The minimum number of workers allocated to the connector.
        public let minWorkerCount: Int
        /// The sacle-in policy for the connector.
        public let scaleInPolicy: ScaleInPolicy?
        /// The sacle-out policy for the connector.
        public let scaleOutPolicy: ScaleOutPolicy?

        public init(maxWorkerCount: Int, mcuCount: Int, minWorkerCount: Int, scaleInPolicy: ScaleInPolicy? = nil, scaleOutPolicy: ScaleOutPolicy? = nil) {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, max: 10)
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, min: 1)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, max: 8)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, min: 1)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, max: 10)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, min: 1)
            try self.scaleInPolicy?.validate(name: "\(name).scaleInPolicy")
            try self.scaleOutPolicy?.validate(name: "\(name).scaleOutPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case maxWorkerCount
            case mcuCount
            case minWorkerCount
            case scaleInPolicy
            case scaleOutPolicy
        }
    }

    public struct AutoScalingDescription: AWSDecodableShape {
        /// The maximum number of workers allocated to the connector.
        public let maxWorkerCount: Int?
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int?
        /// The minimum number of workers allocated to the connector.
        public let minWorkerCount: Int?
        /// The sacle-in policy for the connector.
        public let scaleInPolicy: ScaleInPolicyDescription?
        /// The sacle-out policy for the connector.&gt;
        public let scaleOutPolicy: ScaleOutPolicyDescription?

        public init(maxWorkerCount: Int? = nil, mcuCount: Int? = nil, minWorkerCount: Int? = nil, scaleInPolicy: ScaleInPolicyDescription? = nil, scaleOutPolicy: ScaleOutPolicyDescription? = nil) {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case maxWorkerCount
            case mcuCount
            case minWorkerCount
            case scaleInPolicy
            case scaleOutPolicy
        }
    }

    public struct AutoScalingUpdate: AWSEncodableShape {
        /// The target maximum number of workers allocated to the connector.
        public let maxWorkerCount: Int
        /// The target number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int
        /// The target minimum number of workers allocated to the connector.
        public let minWorkerCount: Int
        /// The target sacle-in policy for the connector.
        public let scaleInPolicy: ScaleInPolicyUpdate
        /// The target sacle-out policy for the connector.
        public let scaleOutPolicy: ScaleOutPolicyUpdate

        public init(maxWorkerCount: Int, mcuCount: Int, minWorkerCount: Int, scaleInPolicy: ScaleInPolicyUpdate, scaleOutPolicy: ScaleOutPolicyUpdate) {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, max: 10)
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, min: 1)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, max: 8)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, min: 1)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, max: 10)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, min: 1)
            try self.scaleInPolicy.validate(name: "\(name).scaleInPolicy")
            try self.scaleOutPolicy.validate(name: "\(name).scaleOutPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case maxWorkerCount
            case mcuCount
            case minWorkerCount
            case scaleInPolicy
            case scaleOutPolicy
        }
    }

    public struct Capacity: AWSEncodableShape {
        /// Information about the auto scaling parameters for the connector.
        public let autoScaling: AutoScaling?
        /// Details about a fixed capacity allocated to a connector.
        public let provisionedCapacity: ProvisionedCapacity?

        public init(autoScaling: AutoScaling? = nil, provisionedCapacity: ProvisionedCapacity? = nil) {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }

        public func validate(name: String) throws {
            try self.autoScaling?.validate(name: "\(name).autoScaling")
            try self.provisionedCapacity?.validate(name: "\(name).provisionedCapacity")
        }

        private enum CodingKeys: String, CodingKey {
            case autoScaling
            case provisionedCapacity
        }
    }

    public struct CapacityDescription: AWSDecodableShape {
        /// Describes the connector's auto scaling capacity.
        public let autoScaling: AutoScalingDescription?
        /// Describes a connector's provisioned capacity.
        public let provisionedCapacity: ProvisionedCapacityDescription?

        public init(autoScaling: AutoScalingDescription? = nil, provisionedCapacity: ProvisionedCapacityDescription? = nil) {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }

        private enum CodingKeys: String, CodingKey {
            case autoScaling
            case provisionedCapacity
        }
    }

    public struct CapacityUpdate: AWSEncodableShape {
        /// The target auto scaling setting.
        public let autoScaling: AutoScalingUpdate?
        /// The target settings for provisioned capacity.
        public let provisionedCapacity: ProvisionedCapacityUpdate?

        public init(autoScaling: AutoScalingUpdate? = nil, provisionedCapacity: ProvisionedCapacityUpdate? = nil) {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }

        public func validate(name: String) throws {
            try self.autoScaling?.validate(name: "\(name).autoScaling")
            try self.provisionedCapacity?.validate(name: "\(name).provisionedCapacity")
        }

        private enum CodingKeys: String, CodingKey {
            case autoScaling
            case provisionedCapacity
        }
    }

    public struct CloudWatchLogsLogDelivery: AWSEncodableShape {
        /// Whether log delivery to Amazon CloudWatch Logs is enabled.
        public let enabled: Bool
        /// The name of the CloudWatch log group that is the destination for log delivery.
        public let logGroup: String?

        public init(enabled: Bool, logGroup: String? = nil) {
            self.enabled = enabled
            self.logGroup = logGroup
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
            case logGroup
        }
    }

    public struct CloudWatchLogsLogDeliveryDescription: AWSDecodableShape {
        /// Whether log delivery to Amazon CloudWatch Logs is enabled.
        public let enabled: Bool?
        /// The name of the CloudWatch log group that is the destination for log delivery.
        public let logGroup: String?

        public init(enabled: Bool? = nil, logGroup: String? = nil) {
            self.enabled = enabled
            self.logGroup = logGroup
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
            case logGroup
        }
    }

    public struct ConnectorSummary: AWSDecodableShape {
        /// The connector's compute capacity settings.
        public let capacity: CapacityDescription?
        /// The Amazon Resource Name (ARN) of the connector.
        public let connectorArn: String?
        /// The description of the connector.
        public let connectorDescription: String?
        /// The name of the connector.
        public let connectorName: String?
        /// The state of the connector.
        public let connectorState: ConnectorState?
        /// The time that the connector was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The current version of the connector.
        public let currentVersion: String?
        /// The details of the Apache Kafka cluster to which the connector is connected.
        public let kafkaCluster: KafkaClusterDescription?
        /// The type of client authentication used to connect to the Apache Kafka cluster. The value is NONE when no client authentication is used.
        public let kafkaClusterClientAuthentication: KafkaClusterClientAuthenticationDescription?
        /// Details of encryption in transit to the Apache Kafka cluster.
        public let kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransitDescription?
        /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
        public let kafkaConnectVersion: String?
        /// The settings for delivering connector logs to Amazon CloudWatch Logs.
        public let logDelivery: LogDeliveryDescription?
        /// Specifies which plugins were used for this connector.
        public let plugins: [PluginDescription]?
        /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access Amazon Web Services resources.
        public let serviceExecutionRoleArn: String?
        /// The worker configurations that are in use with the connector.
        public let workerConfiguration: WorkerConfigurationDescription?

        public init(capacity: CapacityDescription? = nil, connectorArn: String? = nil, connectorDescription: String? = nil, connectorName: String? = nil, connectorState: ConnectorState? = nil, creationTime: Date? = nil, currentVersion: String? = nil, kafkaCluster: KafkaClusterDescription? = nil, kafkaClusterClientAuthentication: KafkaClusterClientAuthenticationDescription? = nil, kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransitDescription? = nil, kafkaConnectVersion: String? = nil, logDelivery: LogDeliveryDescription? = nil, plugins: [PluginDescription]? = nil, serviceExecutionRoleArn: String? = nil, workerConfiguration: WorkerConfigurationDescription? = nil) {
            self.capacity = capacity
            self.connectorArn = connectorArn
            self.connectorDescription = connectorDescription
            self.connectorName = connectorName
            self.connectorState = connectorState
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.kafkaCluster = kafkaCluster
            self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
            self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
            self.kafkaConnectVersion = kafkaConnectVersion
            self.logDelivery = logDelivery
            self.plugins = plugins
            self.serviceExecutionRoleArn = serviceExecutionRoleArn
            self.workerConfiguration = workerConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case capacity
            case connectorArn
            case connectorDescription
            case connectorName
            case connectorState
            case creationTime
            case currentVersion
            case kafkaCluster
            case kafkaClusterClientAuthentication
            case kafkaClusterEncryptionInTransit
            case kafkaConnectVersion
            case logDelivery
            case plugins
            case serviceExecutionRoleArn
            case workerConfiguration
        }
    }

    public struct CreateConnectorRequest: AWSEncodableShape {
        /// Information about the capacity allocated to the connector. Exactly one of the two properties must be specified.
        public let capacity: Capacity
        /// A map of keys to values that represent the configuration for the connector.
        public let connectorConfiguration: [String: String]
        /// A summary description of the connector.
        public let connectorDescription: String?
        /// The name of the connector.
        public let connectorName: String
        /// Specifies which Apache Kafka cluster to connect to.
        public let kafkaCluster: KafkaCluster
        /// Details of the client authentication used by the Apache Kafka cluster.
        public let kafkaClusterClientAuthentication: KafkaClusterClientAuthentication
        /// Details of encryption in transit to the Apache Kafka cluster.
        public let kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransit
        /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
        public let kafkaConnectVersion: String
        /// Details about log delivery.
        public let logDelivery: LogDelivery?
        /// Specifies which plugins to use for the connector.
        public let plugins: [Plugin]
        /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access the Amazon Web Services resources that it needs. The types of resources depends on the logic of the connector. For example, a connector that has Amazon S3 as a destination must have permissions that allow it to write to the S3 destination bucket.
        public let serviceExecutionRoleArn: String
        /// Specifies which worker configuration to use with the connector.
        public let workerConfiguration: WorkerConfiguration?

        public init(capacity: Capacity, connectorConfiguration: [String: String], connectorDescription: String? = nil, connectorName: String, kafkaCluster: KafkaCluster, kafkaClusterClientAuthentication: KafkaClusterClientAuthentication, kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransit, kafkaConnectVersion: String, logDelivery: LogDelivery? = nil, plugins: [Plugin], serviceExecutionRoleArn: String, workerConfiguration: WorkerConfiguration? = nil) {
            self.capacity = capacity
            self.connectorConfiguration = connectorConfiguration
            self.connectorDescription = connectorDescription
            self.connectorName = connectorName
            self.kafkaCluster = kafkaCluster
            self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
            self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
            self.kafkaConnectVersion = kafkaConnectVersion
            self.logDelivery = logDelivery
            self.plugins = plugins
            self.serviceExecutionRoleArn = serviceExecutionRoleArn
            self.workerConfiguration = workerConfiguration
        }

        public func validate(name: String) throws {
            try self.capacity.validate(name: "\(name).capacity")
            try self.validate(self.connectorDescription, name: "connectorDescription", parent: name, max: 1024)
            try self.validate(self.connectorName, name: "connectorName", parent: name, max: 128)
            try self.validate(self.connectorName, name: "connectorName", parent: name, min: 1)
            try self.plugins.forEach {
                try $0.validate(name: "\(name).plugins[]")
            }
            try self.workerConfiguration?.validate(name: "\(name).workerConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case capacity
            case connectorConfiguration
            case connectorDescription
            case connectorName
            case kafkaCluster
            case kafkaClusterClientAuthentication
            case kafkaClusterEncryptionInTransit
            case kafkaConnectVersion
            case logDelivery
            case plugins
            case serviceExecutionRoleArn
            case workerConfiguration
        }
    }

    public struct CreateConnectorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that Amazon assigned to the connector.
        public let connectorArn: String?
        /// The name of the connector.
        public let connectorName: String?
        /// The state of the connector.
        public let connectorState: ConnectorState?

        public init(connectorArn: String? = nil, connectorName: String? = nil, connectorState: ConnectorState? = nil) {
            self.connectorArn = connectorArn
            self.connectorName = connectorName
            self.connectorState = connectorState
        }

        private enum CodingKeys: String, CodingKey {
            case connectorArn
            case connectorName
            case connectorState
        }
    }

    public struct CreateCustomPluginRequest: AWSEncodableShape {
        /// The type of the plugin file.
        public let contentType: CustomPluginContentType
        /// A summary description of the custom plugin.
        public let description: String?
        /// Information about the location of a custom plugin.
        public let location: CustomPluginLocation
        /// The name of the custom plugin.
        public let name: String

        public init(contentType: CustomPluginContentType, description: String? = nil, location: CustomPluginLocation, name: String) {
            self.contentType = contentType
            self.description = description
            self.location = location
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType
            case description
            case location
            case name
        }
    }

    public struct CreateCustomPluginResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that Amazon assigned to the custom plugin.
        public let customPluginArn: String?
        /// The state of the custom plugin.
        public let customPluginState: CustomPluginState?
        /// The name of the custom plugin.
        public let name: String?
        /// The revision of the custom plugin.
        public let revision: Int64?

        public init(customPluginArn: String? = nil, customPluginState: CustomPluginState? = nil, name: String? = nil, revision: Int64? = nil) {
            self.customPluginArn = customPluginArn
            self.customPluginState = customPluginState
            self.name = name
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case customPluginArn
            case customPluginState
            case name
            case revision
        }
    }

    public struct CreateWorkerConfigurationRequest: AWSEncodableShape {
        /// A summary description of the worker configuration.
        public let description: String?
        /// The name of the worker configuration.
        public let name: String
        /// Base64 encoded contents of connect-distributed.properties file.
        public let propertiesFileContent: String

        public init(description: String? = nil, name: String, propertiesFileContent: String) {
            self.description = description
            self.name = name
            self.propertiesFileContent = propertiesFileContent
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case propertiesFileContent
        }
    }

    public struct CreateWorkerConfigurationResponse: AWSDecodableShape {
        /// The time that the worker configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The latest revision of the worker configuration.
        public let latestRevision: WorkerConfigurationRevisionSummary?
        /// The name of the worker configuration.
        public let name: String?
        /// The Amazon Resource Name (ARN) that Amazon assigned to the worker configuration.
        public let workerConfigurationArn: String?

        public init(creationTime: Date? = nil, latestRevision: WorkerConfigurationRevisionSummary? = nil, name: String? = nil, workerConfigurationArn: String? = nil) {
            self.creationTime = creationTime
            self.latestRevision = latestRevision
            self.name = name
            self.workerConfigurationArn = workerConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case latestRevision
            case name
            case workerConfigurationArn
        }
    }

    public struct CustomPlugin: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public let customPluginArn: String
        /// The revision of the custom plugin.
        public let revision: Int64

        public init(customPluginArn: String, revision: Int64) {
            self.customPluginArn = customPluginArn
            self.revision = revision
        }

        public func validate(name: String) throws {
            try self.validate(self.revision, name: "revision", parent: name, max: -9_223_372_036_854_775_808)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customPluginArn
            case revision
        }
    }

    public struct CustomPluginDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public let customPluginArn: String?
        /// The revision of the custom plugin.
        public let revision: Int64?

        public init(customPluginArn: String? = nil, revision: Int64? = nil) {
            self.customPluginArn = customPluginArn
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case customPluginArn
            case revision
        }
    }

    public struct CustomPluginFileDescription: AWSDecodableShape {
        /// The hex-encoded MD5 checksum of the custom plugin file. You can use it to validate the file.
        public let fileMd5: String?
        /// The size in bytes of the custom plugin file. You can use it to validate the file.
        public let fileSize: Int64?

        public init(fileMd5: String? = nil, fileSize: Int64? = nil) {
            self.fileMd5 = fileMd5
            self.fileSize = fileSize
        }

        private enum CodingKeys: String, CodingKey {
            case fileMd5
            case fileSize
        }
    }

    public struct CustomPluginLocation: AWSEncodableShape {
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the plugin file stored in Amazon S3.
        public let s3Location: S3Location

        public init(s3Location: S3Location) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location
        }
    }

    public struct CustomPluginLocationDescription: AWSDecodableShape {
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the plugin file stored in Amazon S3.
        public let s3Location: S3LocationDescription?

        public init(s3Location: S3LocationDescription? = nil) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location
        }
    }

    public struct CustomPluginRevisionSummary: AWSDecodableShape {
        /// The format of the plugin file.
        public let contentType: CustomPluginContentType?
        /// The time that the custom plugin was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the custom plugin.
        public let description: String?
        /// Details about the custom plugin file.
        public let fileDescription: CustomPluginFileDescription?
        /// Information about the location of the custom plugin.
        public let location: CustomPluginLocationDescription?
        /// The revision of the custom plugin.
        public let revision: Int64?

        public init(contentType: CustomPluginContentType? = nil, creationTime: Date? = nil, description: String? = nil, fileDescription: CustomPluginFileDescription? = nil, location: CustomPluginLocationDescription? = nil, revision: Int64? = nil) {
            self.contentType = contentType
            self.creationTime = creationTime
            self.description = description
            self.fileDescription = fileDescription
            self.location = location
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case contentType
            case creationTime
            case description
            case fileDescription
            case location
            case revision
        }
    }

    public struct CustomPluginSummary: AWSDecodableShape {
        /// The time that the custom plugin was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public let customPluginArn: String?
        /// The state of the custom plugin.
        public let customPluginState: CustomPluginState?
        /// A description of the custom plugin.
        public let description: String?
        /// The latest revision of the custom plugin.
        public let latestRevision: CustomPluginRevisionSummary?
        /// The name of the custom plugin.
        public let name: String?

        public init(creationTime: Date? = nil, customPluginArn: String? = nil, customPluginState: CustomPluginState? = nil, description: String? = nil, latestRevision: CustomPluginRevisionSummary? = nil, name: String? = nil) {
            self.creationTime = creationTime
            self.customPluginArn = customPluginArn
            self.customPluginState = customPluginState
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case customPluginArn
            case customPluginState
            case description
            case latestRevision
            case name
        }
    }

    public struct DeleteConnectorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "connectorArn", location: .uri("connectorArn")),
            AWSMemberEncoding(label: "currentVersion", location: .querystring("currentVersion"))
        ]

        /// The Amazon Resource Name (ARN) of the connector that you want to delete.
        public let connectorArn: String
        /// The current version of the connector that you want to delete.
        public let currentVersion: String?

        public init(connectorArn: String, currentVersion: String? = nil) {
            self.connectorArn = connectorArn
            self.currentVersion = currentVersion
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConnectorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the connector that you requested to delete.
        public let connectorArn: String?
        /// The state of the connector that you requested to delete.
        public let connectorState: ConnectorState?

        public init(connectorArn: String? = nil, connectorState: ConnectorState? = nil) {
            self.connectorArn = connectorArn
            self.connectorState = connectorState
        }

        private enum CodingKeys: String, CodingKey {
            case connectorArn
            case connectorState
        }
    }

    public struct DeleteCustomPluginRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "customPluginArn", location: .uri("customPluginArn"))
        ]

        /// The Amazon Resource Name (ARN) of the custom plugin that you want to delete.
        public let customPluginArn: String

        public init(customPluginArn: String) {
            self.customPluginArn = customPluginArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCustomPluginResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom plugin that you requested to delete.
        public let customPluginArn: String?
        /// The state of the custom plugin.
        public let customPluginState: CustomPluginState?

        public init(customPluginArn: String? = nil, customPluginState: CustomPluginState? = nil) {
            self.customPluginArn = customPluginArn
            self.customPluginState = customPluginState
        }

        private enum CodingKeys: String, CodingKey {
            case customPluginArn
            case customPluginState
        }
    }

    public struct DescribeConnectorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "connectorArn", location: .uri("connectorArn"))
        ]

        /// The Amazon Resource Name (ARN) of the connector that you want to describe.
        public let connectorArn: String

        public init(connectorArn: String) {
            self.connectorArn = connectorArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConnectorResponse: AWSDecodableShape {
        /// Information about the capacity of the connector, whether it is auto scaled or provisioned.
        public let capacity: CapacityDescription?
        /// The Amazon Resource Name (ARN) of the connector.
        public let connectorArn: String?
        /// A map of keys to values that represent the configuration for the connector.
        public let connectorConfiguration: [String: String]?
        /// A summary description of the connector.
        public let connectorDescription: String?
        /// The name of the connector.
        public let connectorName: String?
        /// The state of the connector.
        public let connectorState: ConnectorState?
        /// The time the connector was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The current version of the connector.
        public let currentVersion: String?
        /// The Apache Kafka cluster that the connector is connected to.
        public let kafkaCluster: KafkaClusterDescription?
        /// The type of client authentication used to connect to the Apache Kafka cluster. The value is NONE when no client authentication is used.
        public let kafkaClusterClientAuthentication: KafkaClusterClientAuthenticationDescription?
        /// Details of encryption in transit to the Apache Kafka cluster.
        public let kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransitDescription?
        /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
        public let kafkaConnectVersion: String?
        /// Details about delivering logs to Amazon CloudWatch Logs.
        public let logDelivery: LogDeliveryDescription?
        /// Specifies which plugins were used for this connector.
        public let plugins: [PluginDescription]?
        /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access Amazon Web Services resources.
        public let serviceExecutionRoleArn: String?
        /// Details about the state of a connector.
        public let stateDescription: StateDescription?
        /// Specifies which worker configuration was used for the connector.
        public let workerConfiguration: WorkerConfigurationDescription?

        public init(capacity: CapacityDescription? = nil, connectorArn: String? = nil, connectorConfiguration: [String: String]? = nil, connectorDescription: String? = nil, connectorName: String? = nil, connectorState: ConnectorState? = nil, creationTime: Date? = nil, currentVersion: String? = nil, kafkaCluster: KafkaClusterDescription? = nil, kafkaClusterClientAuthentication: KafkaClusterClientAuthenticationDescription? = nil, kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransitDescription? = nil, kafkaConnectVersion: String? = nil, logDelivery: LogDeliveryDescription? = nil, plugins: [PluginDescription]? = nil, serviceExecutionRoleArn: String? = nil, stateDescription: StateDescription? = nil, workerConfiguration: WorkerConfigurationDescription? = nil) {
            self.capacity = capacity
            self.connectorArn = connectorArn
            self.connectorConfiguration = connectorConfiguration
            self.connectorDescription = connectorDescription
            self.connectorName = connectorName
            self.connectorState = connectorState
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.kafkaCluster = kafkaCluster
            self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
            self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
            self.kafkaConnectVersion = kafkaConnectVersion
            self.logDelivery = logDelivery
            self.plugins = plugins
            self.serviceExecutionRoleArn = serviceExecutionRoleArn
            self.stateDescription = stateDescription
            self.workerConfiguration = workerConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case capacity
            case connectorArn
            case connectorConfiguration
            case connectorDescription
            case connectorName
            case connectorState
            case creationTime
            case currentVersion
            case kafkaCluster
            case kafkaClusterClientAuthentication
            case kafkaClusterEncryptionInTransit
            case kafkaConnectVersion
            case logDelivery
            case plugins
            case serviceExecutionRoleArn
            case stateDescription
            case workerConfiguration
        }
    }

    public struct DescribeCustomPluginRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "customPluginArn", location: .uri("customPluginArn"))
        ]

        /// Returns information about a custom plugin.
        public let customPluginArn: String

        public init(customPluginArn: String) {
            self.customPluginArn = customPluginArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCustomPluginResponse: AWSDecodableShape {
        /// The time that the custom plugin was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public let customPluginArn: String?
        /// The state of the custom plugin.
        public let customPluginState: CustomPluginState?
        /// The description of the custom plugin.
        public let description: String?
        /// The latest successfully created revision of the custom plugin. If there are no successfully created revisions, this field will be absent.
        public let latestRevision: CustomPluginRevisionSummary?
        /// The name of the custom plugin.
        public let name: String?
        /// Details about the state of a custom plugin.
        public let stateDescription: StateDescription?

        public init(creationTime: Date? = nil, customPluginArn: String? = nil, customPluginState: CustomPluginState? = nil, description: String? = nil, latestRevision: CustomPluginRevisionSummary? = nil, name: String? = nil, stateDescription: StateDescription? = nil) {
            self.creationTime = creationTime
            self.customPluginArn = customPluginArn
            self.customPluginState = customPluginState
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
            self.stateDescription = stateDescription
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case customPluginArn
            case customPluginState
            case description
            case latestRevision
            case name
            case stateDescription
        }
    }

    public struct DescribeWorkerConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workerConfigurationArn", location: .uri("workerConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the worker configuration that you want to get information about.
        public let workerConfigurationArn: String

        public init(workerConfigurationArn: String) {
            self.workerConfigurationArn = workerConfigurationArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeWorkerConfigurationResponse: AWSDecodableShape {
        /// The time that the worker configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the worker configuration.
        public let description: String?
        /// The latest revision of the custom configuration.
        public let latestRevision: WorkerConfigurationRevisionDescription?
        /// The name of the worker configuration.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the custom configuration.
        public let workerConfigurationArn: String?

        public init(creationTime: Date? = nil, description: String? = nil, latestRevision: WorkerConfigurationRevisionDescription? = nil, name: String? = nil, workerConfigurationArn: String? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
            self.workerConfigurationArn = workerConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case latestRevision
            case name
            case workerConfigurationArn
        }
    }

    public struct FirehoseLogDelivery: AWSEncodableShape {
        /// The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
        public let deliveryStream: String?
        /// Specifies whether connector logs get delivered to Amazon Kinesis Data Firehose.
        public let enabled: Bool

        public init(deliveryStream: String? = nil, enabled: Bool) {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStream
            case enabled
        }
    }

    public struct FirehoseLogDeliveryDescription: AWSDecodableShape {
        /// The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
        public let deliveryStream: String?
        /// Specifies whether connector logs get delivered to Amazon Kinesis Data Firehose.
        public let enabled: Bool?

        public init(deliveryStream: String? = nil, enabled: Bool? = nil) {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStream
            case enabled
        }
    }

    public struct KafkaCluster: AWSEncodableShape {
        /// The Apache Kafka cluster to which the connector is connected.
        public let apacheKafkaCluster: ApacheKafkaCluster

        public init(apacheKafkaCluster: ApacheKafkaCluster) {
            self.apacheKafkaCluster = apacheKafkaCluster
        }

        private enum CodingKeys: String, CodingKey {
            case apacheKafkaCluster
        }
    }

    public struct KafkaClusterClientAuthentication: AWSEncodableShape {
        /// The type of client authentication used to connect to the Apache Kafka cluster. Value NONE means that no client authentication is used.
        public let authenticationType: KafkaClusterClientAuthenticationType

        public init(authenticationType: KafkaClusterClientAuthenticationType) {
            self.authenticationType = authenticationType
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType
        }
    }

    public struct KafkaClusterClientAuthenticationDescription: AWSDecodableShape {
        /// The type of client authentication used to connect to the Apache Kafka cluster. Value NONE means that no client authentication is used.
        public let authenticationType: KafkaClusterClientAuthenticationType?

        public init(authenticationType: KafkaClusterClientAuthenticationType? = nil) {
            self.authenticationType = authenticationType
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType
        }
    }

    public struct KafkaClusterDescription: AWSDecodableShape {
        /// The Apache Kafka cluster to which the connector is connected.
        public let apacheKafkaCluster: ApacheKafkaClusterDescription?

        public init(apacheKafkaCluster: ApacheKafkaClusterDescription? = nil) {
            self.apacheKafkaCluster = apacheKafkaCluster
        }

        private enum CodingKeys: String, CodingKey {
            case apacheKafkaCluster
        }
    }

    public struct KafkaClusterEncryptionInTransit: AWSEncodableShape {
        /// The type of encryption in transit to the Apache Kafka cluster.
        public let encryptionType: KafkaClusterEncryptionInTransitType

        public init(encryptionType: KafkaClusterEncryptionInTransitType) {
            self.encryptionType = encryptionType
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType
        }
    }

    public struct KafkaClusterEncryptionInTransitDescription: AWSDecodableShape {
        /// The type of encryption in transit to the Apache Kafka cluster.
        public let encryptionType: KafkaClusterEncryptionInTransitType?

        public init(encryptionType: KafkaClusterEncryptionInTransitType? = nil) {
            self.encryptionType = encryptionType
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType
        }
    }

    public struct ListConnectorsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "connectorNamePrefix", location: .querystring("connectorNamePrefix")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The name prefix that you want to use to search for and list connectors.
        public let connectorNamePrefix: String?
        /// The maximum number of connectors to list in one response.
        public let maxResults: Int?
        /// If the response of a ListConnectors operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
        public let nextToken: String?

        public init(connectorNamePrefix: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectorNamePrefix = connectorNamePrefix
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConnectorsResponse: AWSDecodableShape {
        /// An array of connector descriptions.
        public let connectors: [ConnectorSummary]?
        /// If the response of a ListConnectors operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where it left off.
        public let nextToken: String?

        public init(connectors: [ConnectorSummary]? = nil, nextToken: String? = nil) {
            self.connectors = connectors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectors
            case nextToken
        }
    }

    public struct ListCustomPluginsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of custom plugins to list in one response.
        public let maxResults: Int?
        /// If the response of a ListCustomPlugins operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCustomPluginsResponse: AWSDecodableShape {
        /// An array of custom plugin descriptions.
        public let customPlugins: [CustomPluginSummary]?
        /// If the response of a ListCustomPlugins operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
        public let nextToken: String?

        public init(customPlugins: [CustomPluginSummary]? = nil, nextToken: String? = nil) {
            self.customPlugins = customPlugins
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case customPlugins
            case nextToken
        }
    }

    public struct ListWorkerConfigurationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of worker configurations to list in one response.
        public let maxResults: Int?
        /// If the response of a ListWorkerConfigurations operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkerConfigurationsResponse: AWSDecodableShape {
        /// If the response of a ListWorkerConfigurations operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
        public let nextToken: String?
        /// An array of worker configuration descriptions.
        public let workerConfigurations: [WorkerConfigurationSummary]?

        public init(nextToken: String? = nil, workerConfigurations: [WorkerConfigurationSummary]? = nil) {
            self.nextToken = nextToken
            self.workerConfigurations = workerConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case workerConfigurations
        }
    }

    public struct LogDelivery: AWSEncodableShape {
        /// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
        public let workerLogDelivery: WorkerLogDelivery

        public init(workerLogDelivery: WorkerLogDelivery) {
            self.workerLogDelivery = workerLogDelivery
        }

        private enum CodingKeys: String, CodingKey {
            case workerLogDelivery
        }
    }

    public struct LogDeliveryDescription: AWSDecodableShape {
        /// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
        public let workerLogDelivery: WorkerLogDeliveryDescription?

        public init(workerLogDelivery: WorkerLogDeliveryDescription? = nil) {
            self.workerLogDelivery = workerLogDelivery
        }

        private enum CodingKeys: String, CodingKey {
            case workerLogDelivery
        }
    }

    public struct Plugin: AWSEncodableShape {
        /// Details about a custom plugin.
        public let customPlugin: CustomPlugin

        public init(customPlugin: CustomPlugin) {
            self.customPlugin = customPlugin
        }

        public func validate(name: String) throws {
            try self.customPlugin.validate(name: "\(name).customPlugin")
        }

        private enum CodingKeys: String, CodingKey {
            case customPlugin
        }
    }

    public struct PluginDescription: AWSDecodableShape {
        /// Details about a custom plugin.
        public let customPlugin: CustomPluginDescription?

        public init(customPlugin: CustomPluginDescription? = nil) {
            self.customPlugin = customPlugin
        }

        private enum CodingKeys: String, CodingKey {
            case customPlugin
        }
    }

    public struct ProvisionedCapacity: AWSEncodableShape {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int
        /// The number of workers that are allocated to the connector.
        public let workerCount: Int

        public init(mcuCount: Int, workerCount: Int) {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }

        public func validate(name: String) throws {
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, max: 8)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, min: 1)
            try self.validate(self.workerCount, name: "workerCount", parent: name, max: 10)
            try self.validate(self.workerCount, name: "workerCount", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case mcuCount
            case workerCount
        }
    }

    public struct ProvisionedCapacityDescription: AWSDecodableShape {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int?
        /// The number of workers that are allocated to the connector.
        public let workerCount: Int?

        public init(mcuCount: Int? = nil, workerCount: Int? = nil) {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }

        private enum CodingKeys: String, CodingKey {
            case mcuCount
            case workerCount
        }
    }

    public struct ProvisionedCapacityUpdate: AWSEncodableShape {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int
        /// The number of workers that are allocated to the connector.
        public let workerCount: Int

        public init(mcuCount: Int, workerCount: Int) {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }

        public func validate(name: String) throws {
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, max: 8)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, min: 1)
            try self.validate(self.workerCount, name: "workerCount", parent: name, max: 10)
            try self.validate(self.workerCount, name: "workerCount", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case mcuCount
            case workerCount
        }
    }

    public struct S3Location: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of an S3 bucket.
        public let bucketArn: String
        /// The file key for an object in an S3 bucket.
        public let fileKey: String
        /// The version of an object in an S3 bucket.
        public let objectVersion: String?

        public init(bucketArn: String, fileKey: String, objectVersion: String? = nil) {
            self.bucketArn = bucketArn
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn
            case fileKey
            case objectVersion
        }
    }

    public struct S3LocationDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an S3 bucket.
        public let bucketArn: String?
        /// The file key for an object in an S3 bucket.
        public let fileKey: String?
        /// The version of an object in an S3 bucket.
        public let objectVersion: String?

        public init(bucketArn: String? = nil, fileKey: String? = nil, objectVersion: String? = nil) {
            self.bucketArn = bucketArn
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn
            case fileKey
            case objectVersion
        }
    }

    public struct S3LogDelivery: AWSEncodableShape {
        /// The name of the S3 bucket that is the destination for log delivery.
        public let bucket: String?
        /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
        public let enabled: Bool
        /// The S3 prefix that is the destination for log delivery.
        public let prefix: String?

        public init(bucket: String? = nil, enabled: Bool, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket
            case enabled
            case prefix
        }
    }

    public struct S3LogDeliveryDescription: AWSDecodableShape {
        /// The name of the S3 bucket that is the destination for log delivery.
        public let bucket: String?
        /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
        public let enabled: Bool?
        /// The S3 prefix that is the destination for log delivery.
        public let prefix: String?

        public init(bucket: String? = nil, enabled: Bool? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket
            case enabled
            case prefix
        }
    }

    public struct ScaleInPolicy: AWSEncodableShape {
        /// Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
        public let cpuUtilizationPercentage: Int

        public init(cpuUtilizationPercentage: Int) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, max: 100)
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage
        }
    }

    public struct ScaleInPolicyDescription: AWSDecodableShape {
        /// Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
        public let cpuUtilizationPercentage: Int?

        public init(cpuUtilizationPercentage: Int? = nil) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage
        }
    }

    public struct ScaleInPolicyUpdate: AWSEncodableShape {
        /// The target CPU utilization percentage threshold at which you want connector scale in to be triggered.
        public let cpuUtilizationPercentage: Int

        public init(cpuUtilizationPercentage: Int) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, max: 100)
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage
        }
    }

    public struct ScaleOutPolicy: AWSEncodableShape {
        /// The CPU utilization percentage threshold at which you want connector scale out to be triggered.
        public let cpuUtilizationPercentage: Int

        public init(cpuUtilizationPercentage: Int) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, max: 100)
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage
        }
    }

    public struct ScaleOutPolicyDescription: AWSDecodableShape {
        /// The CPU utilization percentage threshold at which you want connector scale out to be triggered.
        public let cpuUtilizationPercentage: Int?

        public init(cpuUtilizationPercentage: Int? = nil) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage
        }
    }

    public struct ScaleOutPolicyUpdate: AWSEncodableShape {
        /// The target CPU utilization percentage threshold at which you want connector scale out to be triggered.
        public let cpuUtilizationPercentage: Int

        public init(cpuUtilizationPercentage: Int) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, max: 100)
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage
        }
    }

    public struct StateDescription: AWSDecodableShape {
        /// A code that describes the state of a resource.
        public let code: String?
        /// A message that describes the state of a resource.
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
        }
    }

    public struct UpdateConnectorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "connectorArn", location: .uri("connectorArn")),
            AWSMemberEncoding(label: "currentVersion", location: .querystring("currentVersion"))
        ]

        /// The target capacity.
        public let capacity: CapacityUpdate
        /// The Amazon Resource Name (ARN) of the connector that you want to update.
        public let connectorArn: String
        /// The current version of the connector that you want to update.
        public let currentVersion: String

        public init(capacity: CapacityUpdate, connectorArn: String, currentVersion: String) {
            self.capacity = capacity
            self.connectorArn = connectorArn
            self.currentVersion = currentVersion
        }

        public func validate(name: String) throws {
            try self.capacity.validate(name: "\(name).capacity")
        }

        private enum CodingKeys: String, CodingKey {
            case capacity
        }
    }

    public struct UpdateConnectorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the connector.
        public let connectorArn: String?
        /// The state of the connector.
        public let connectorState: ConnectorState?

        public init(connectorArn: String? = nil, connectorState: ConnectorState? = nil) {
            self.connectorArn = connectorArn
            self.connectorState = connectorState
        }

        private enum CodingKeys: String, CodingKey {
            case connectorArn
            case connectorState
        }
    }

    public struct Vpc: AWSEncodableShape {
        /// The security groups for the connector.
        public let securityGroups: [String]?
        /// The subnets for the connector.
        public let subnets: [String]

        public init(securityGroups: [String]? = nil, subnets: [String]) {
            self.securityGroups = securityGroups
            self.subnets = subnets
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroups
            case subnets
        }
    }

    public struct VpcDescription: AWSDecodableShape {
        /// The security groups for the connector.
        public let securityGroups: [String]?
        /// The subnets for the connector.
        public let subnets: [String]?

        public init(securityGroups: [String]? = nil, subnets: [String]? = nil) {
            self.securityGroups = securityGroups
            self.subnets = subnets
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroups
            case subnets
        }
    }

    public struct WorkerConfiguration: AWSEncodableShape {
        /// The revision of the worker configuration.
        public let revision: Int64
        /// The Amazon Resource Name (ARN) of the worker configuration.
        public let workerConfigurationArn: String

        public init(revision: Int64, workerConfigurationArn: String) {
            self.revision = revision
            self.workerConfigurationArn = workerConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.revision, name: "revision", parent: name, max: -9_223_372_036_854_775_808)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case revision
            case workerConfigurationArn
        }
    }

    public struct WorkerConfigurationDescription: AWSDecodableShape {
        /// The revision of the worker configuration.
        public let revision: Int64?
        /// The Amazon Resource Name (ARN) of the worker configuration.
        public let workerConfigurationArn: String?

        public init(revision: Int64? = nil, workerConfigurationArn: String? = nil) {
            self.revision = revision
            self.workerConfigurationArn = workerConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case revision
            case workerConfigurationArn
        }
    }

    public struct WorkerConfigurationRevisionDescription: AWSDecodableShape {
        /// The time that the worker configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the worker configuration revision.
        public let description: String?
        /// Base64 encoded contents of the connect-distributed.properties file.
        public let propertiesFileContent: String?
        /// The description of a revision of the worker configuration.
        public let revision: Int64?

        public init(creationTime: Date? = nil, description: String? = nil, propertiesFileContent: String? = nil, revision: Int64? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.propertiesFileContent = propertiesFileContent
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case propertiesFileContent
            case revision
        }
    }

    public struct WorkerConfigurationRevisionSummary: AWSDecodableShape {
        /// The time that a worker configuration revision was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of a worker configuration revision.
        public let description: String?
        /// The revision of a worker configuration.
        public let revision: Int64?

        public init(creationTime: Date? = nil, description: String? = nil, revision: Int64? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case revision
        }
    }

    public struct WorkerConfigurationSummary: AWSDecodableShape {
        /// The time that a worker configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of a worker configuration.
        public let description: String?
        /// The latest revision of a worker configuration.
        public let latestRevision: WorkerConfigurationRevisionSummary?
        /// The name of the worker configuration.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the worker configuration.
        public let workerConfigurationArn: String?

        public init(creationTime: Date? = nil, description: String? = nil, latestRevision: WorkerConfigurationRevisionSummary? = nil, name: String? = nil, workerConfigurationArn: String? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
            self.workerConfigurationArn = workerConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case latestRevision
            case name
            case workerConfigurationArn
        }
    }

    public struct WorkerLogDelivery: AWSEncodableShape {
        /// Details about delivering logs to Amazon CloudWatch Logs.
        public let cloudWatchLogs: CloudWatchLogsLogDelivery?
        /// Details about delivering logs to Amazon Kinesis Data Firehose.
        public let firehose: FirehoseLogDelivery?
        /// Details about delivering logs to Amazon S3.
        public let s3: S3LogDelivery?

        public init(cloudWatchLogs: CloudWatchLogsLogDelivery? = nil, firehose: FirehoseLogDelivery? = nil, s3: S3LogDelivery? = nil) {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogs
            case firehose
            case s3
        }
    }

    public struct WorkerLogDeliveryDescription: AWSDecodableShape {
        /// Details about delivering logs to Amazon CloudWatch Logs.
        public let cloudWatchLogs: CloudWatchLogsLogDeliveryDescription?
        /// Details about delivering logs to Amazon Kinesis Data Firehose.
        public let firehose: FirehoseLogDeliveryDescription?
        /// Details about delivering logs to Amazon S3.
        public let s3: S3LogDeliveryDescription?

        public init(cloudWatchLogs: CloudWatchLogsLogDeliveryDescription? = nil, firehose: FirehoseLogDeliveryDescription? = nil, s3: S3LogDeliveryDescription? = nil) {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogs
            case firehose
            case s3
        }
    }
}

// MARK: - Errors

/// Error enum for KafkaConnect
public struct KafkaConnectErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case internalServerErrorException = "InternalServerErrorException"
        case notFoundException = "NotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case tooManyRequestsException = "TooManyRequestsException"
        case unauthorizedException = "UnauthorizedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize KafkaConnect
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// HTTP Status Code 400: Bad request due to incorrect input. Correct your request and then retry it.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// HTTP Status Code 409: Conflict. A resource with this name already exists. Retry your request with another name.
    public static var conflictException: Self { .init(.conflictException) }
    /// HTTP Status Code 403: Access forbidden. Correct your credentials and then retry your request.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// HTTP Status Code 500: Unexpected internal server error. Retrying your request might resolve the issue.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// HTTP Status Code 404: Resource not found due to incorrect input. Correct your request and then retry it.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// HTTP Status Code 503: Service Unavailable. Retrying your request in some time might resolve the issue.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// HTTP Status Code 429: Limit exceeded. Resource limit reached.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// HTTP Status Code 401: Unauthorized request. The provided credentials couldn&#39;t be validated.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
}

extension KafkaConnectErrorType: Equatable {
    public static func == (lhs: KafkaConnectErrorType, rhs: KafkaConnectErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension KafkaConnectErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
