//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension KafkaConnect {
    // MARK: Enums

    public enum ConnectorState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case running = "RUNNING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum CustomPluginContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jar = "JAR"
        case zip = "ZIP"
        public var description: String { return self.rawValue }
    }

    public enum CustomPluginState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum KafkaClusterClientAuthenticationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iam = "IAM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum KafkaClusterEncryptionInTransitType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case plaintext = "PLAINTEXT"
        case tls = "TLS"
        public var description: String { return self.rawValue }
    }

    public enum WorkerConfigurationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ApacheKafkaCluster: AWSEncodableShape {
        /// The bootstrap servers of the cluster.
        public let bootstrapServers: String
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        public let vpc: Vpc

        public init(bootstrapServers: String, vpc: Vpc) {
            self.bootstrapServers = bootstrapServers
            self.vpc = vpc
        }

        private enum CodingKeys: String, CodingKey {
            case bootstrapServers = "bootstrapServers"
            case vpc = "vpc"
        }
    }

    public struct ApacheKafkaClusterDescription: AWSDecodableShape {
        /// The bootstrap servers of the cluster.
        public let bootstrapServers: String?
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        public let vpc: VpcDescription?

        public init(bootstrapServers: String? = nil, vpc: VpcDescription? = nil) {
            self.bootstrapServers = bootstrapServers
            self.vpc = vpc
        }

        private enum CodingKeys: String, CodingKey {
            case bootstrapServers = "bootstrapServers"
            case vpc = "vpc"
        }
    }

    public struct AutoScaling: AWSEncodableShape {
        /// The maximum number of workers allocated to the connector.
        public let maxWorkerCount: Int
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int
        /// The minimum number of workers allocated to the connector.
        public let minWorkerCount: Int
        /// The sacle-in policy for the connector.
        public let scaleInPolicy: ScaleInPolicy?
        /// The sacle-out policy for the connector.
        public let scaleOutPolicy: ScaleOutPolicy?

        public init(maxWorkerCount: Int = 0, mcuCount: Int = 0, minWorkerCount: Int = 0, scaleInPolicy: ScaleInPolicy? = nil, scaleOutPolicy: ScaleOutPolicy? = nil) {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, max: 10)
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, min: 1)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, max: 8)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, min: 1)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, max: 10)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, min: 1)
            try self.scaleInPolicy?.validate(name: "\(name).scaleInPolicy")
            try self.scaleOutPolicy?.validate(name: "\(name).scaleOutPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case maxWorkerCount = "maxWorkerCount"
            case mcuCount = "mcuCount"
            case minWorkerCount = "minWorkerCount"
            case scaleInPolicy = "scaleInPolicy"
            case scaleOutPolicy = "scaleOutPolicy"
        }
    }

    public struct AutoScalingDescription: AWSDecodableShape {
        /// The maximum number of workers allocated to the connector.
        public let maxWorkerCount: Int?
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int?
        /// The minimum number of workers allocated to the connector.
        public let minWorkerCount: Int?
        /// The sacle-in policy for the connector.
        public let scaleInPolicy: ScaleInPolicyDescription?
        /// The sacle-out policy for the connector.&gt;
        public let scaleOutPolicy: ScaleOutPolicyDescription?

        public init(maxWorkerCount: Int? = nil, mcuCount: Int? = nil, minWorkerCount: Int? = nil, scaleInPolicy: ScaleInPolicyDescription? = nil, scaleOutPolicy: ScaleOutPolicyDescription? = nil) {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case maxWorkerCount = "maxWorkerCount"
            case mcuCount = "mcuCount"
            case minWorkerCount = "minWorkerCount"
            case scaleInPolicy = "scaleInPolicy"
            case scaleOutPolicy = "scaleOutPolicy"
        }
    }

    public struct AutoScalingUpdate: AWSEncodableShape {
        /// The target maximum number of workers allocated to the connector.
        public let maxWorkerCount: Int
        /// The target number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int
        /// The target minimum number of workers allocated to the connector.
        public let minWorkerCount: Int
        /// The target sacle-in policy for the connector.
        public let scaleInPolicy: ScaleInPolicyUpdate
        /// The target sacle-out policy for the connector.
        public let scaleOutPolicy: ScaleOutPolicyUpdate

        public init(maxWorkerCount: Int = 0, mcuCount: Int = 0, minWorkerCount: Int = 0, scaleInPolicy: ScaleInPolicyUpdate, scaleOutPolicy: ScaleOutPolicyUpdate) {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, max: 10)
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, min: 1)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, max: 8)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, min: 1)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, max: 10)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, min: 1)
            try self.scaleInPolicy.validate(name: "\(name).scaleInPolicy")
            try self.scaleOutPolicy.validate(name: "\(name).scaleOutPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case maxWorkerCount = "maxWorkerCount"
            case mcuCount = "mcuCount"
            case minWorkerCount = "minWorkerCount"
            case scaleInPolicy = "scaleInPolicy"
            case scaleOutPolicy = "scaleOutPolicy"
        }
    }

    public struct Capacity: AWSEncodableShape {
        /// Information about the auto scaling parameters for the connector.
        public let autoScaling: AutoScaling?
        /// Details about a fixed capacity allocated to a connector.
        public let provisionedCapacity: ProvisionedCapacity?

        public init(autoScaling: AutoScaling? = nil, provisionedCapacity: ProvisionedCapacity? = nil) {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }

        public func validate(name: String) throws {
            try self.autoScaling?.validate(name: "\(name).autoScaling")
            try self.provisionedCapacity?.validate(name: "\(name).provisionedCapacity")
        }

        private enum CodingKeys: String, CodingKey {
            case autoScaling = "autoScaling"
            case provisionedCapacity = "provisionedCapacity"
        }
    }

    public struct CapacityDescription: AWSDecodableShape {
        /// Describes the connector's auto scaling capacity.
        public let autoScaling: AutoScalingDescription?
        /// Describes a connector's provisioned capacity.
        public let provisionedCapacity: ProvisionedCapacityDescription?

        public init(autoScaling: AutoScalingDescription? = nil, provisionedCapacity: ProvisionedCapacityDescription? = nil) {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }

        private enum CodingKeys: String, CodingKey {
            case autoScaling = "autoScaling"
            case provisionedCapacity = "provisionedCapacity"
        }
    }

    public struct CapacityUpdate: AWSEncodableShape {
        /// The target auto scaling setting.
        public let autoScaling: AutoScalingUpdate?
        /// The target settings for provisioned capacity.
        public let provisionedCapacity: ProvisionedCapacityUpdate?

        public init(autoScaling: AutoScalingUpdate? = nil, provisionedCapacity: ProvisionedCapacityUpdate? = nil) {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }

        public func validate(name: String) throws {
            try self.autoScaling?.validate(name: "\(name).autoScaling")
            try self.provisionedCapacity?.validate(name: "\(name).provisionedCapacity")
        }

        private enum CodingKeys: String, CodingKey {
            case autoScaling = "autoScaling"
            case provisionedCapacity = "provisionedCapacity"
        }
    }

    public struct CloudWatchLogsLogDelivery: AWSEncodableShape {
        /// Whether log delivery to Amazon CloudWatch Logs is enabled.
        public let enabled: Bool
        /// The name of the CloudWatch log group that is the destination for log delivery.
        public let logGroup: String?

        public init(enabled: Bool = false, logGroup: String? = nil) {
            self.enabled = enabled
            self.logGroup = logGroup
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case logGroup = "logGroup"
        }
    }

    public struct CloudWatchLogsLogDeliveryDescription: AWSDecodableShape {
        /// Whether log delivery to Amazon CloudWatch Logs is enabled.
        public let enabled: Bool?
        /// The name of the CloudWatch log group that is the destination for log delivery.
        public let logGroup: String?

        public init(enabled: Bool? = nil, logGroup: String? = nil) {
            self.enabled = enabled
            self.logGroup = logGroup
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case logGroup = "logGroup"
        }
    }

    public struct ConnectorSummary: AWSDecodableShape {
        /// The connector's compute capacity settings.
        public let capacity: CapacityDescription?
        /// The Amazon Resource Name (ARN) of the connector.
        public let connectorArn: String?
        /// The description of the connector.
        public let connectorDescription: String?
        /// The name of the connector.
        public let connectorName: String?
        /// The state of the connector.
        public let connectorState: ConnectorState?
        /// The time that the connector was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The current version of the connector.
        public let currentVersion: String?
        /// The details of the Apache Kafka cluster to which the connector is connected.
        public let kafkaCluster: KafkaClusterDescription?
        /// The type of client authentication used to connect to the Apache Kafka cluster. The value is NONE when no client authentication is used.
        public let kafkaClusterClientAuthentication: KafkaClusterClientAuthenticationDescription?
        /// Details of encryption in transit to the Apache Kafka cluster.
        public let kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransitDescription?
        /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
        public let kafkaConnectVersion: String?
        /// The settings for delivering connector logs to Amazon CloudWatch Logs.
        public let logDelivery: LogDeliveryDescription?
        /// Specifies which plugins were used for this connector.
        public let plugins: [PluginDescription]?
        /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access Amazon Web Services resources.
        public let serviceExecutionRoleArn: String?
        /// The worker configurations that are in use with the connector.
        public let workerConfiguration: WorkerConfigurationDescription?

        public init(capacity: CapacityDescription? = nil, connectorArn: String? = nil, connectorDescription: String? = nil, connectorName: String? = nil, connectorState: ConnectorState? = nil, creationTime: Date? = nil, currentVersion: String? = nil, kafkaCluster: KafkaClusterDescription? = nil, kafkaClusterClientAuthentication: KafkaClusterClientAuthenticationDescription? = nil, kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransitDescription? = nil, kafkaConnectVersion: String? = nil, logDelivery: LogDeliveryDescription? = nil, plugins: [PluginDescription]? = nil, serviceExecutionRoleArn: String? = nil, workerConfiguration: WorkerConfigurationDescription? = nil) {
            self.capacity = capacity
            self.connectorArn = connectorArn
            self.connectorDescription = connectorDescription
            self.connectorName = connectorName
            self.connectorState = connectorState
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.kafkaCluster = kafkaCluster
            self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
            self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
            self.kafkaConnectVersion = kafkaConnectVersion
            self.logDelivery = logDelivery
            self.plugins = plugins
            self.serviceExecutionRoleArn = serviceExecutionRoleArn
            self.workerConfiguration = workerConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "capacity"
            case connectorArn = "connectorArn"
            case connectorDescription = "connectorDescription"
            case connectorName = "connectorName"
            case connectorState = "connectorState"
            case creationTime = "creationTime"
            case currentVersion = "currentVersion"
            case kafkaCluster = "kafkaCluster"
            case kafkaClusterClientAuthentication = "kafkaClusterClientAuthentication"
            case kafkaClusterEncryptionInTransit = "kafkaClusterEncryptionInTransit"
            case kafkaConnectVersion = "kafkaConnectVersion"
            case logDelivery = "logDelivery"
            case plugins = "plugins"
            case serviceExecutionRoleArn = "serviceExecutionRoleArn"
            case workerConfiguration = "workerConfiguration"
        }
    }

    public struct CreateConnectorRequest: AWSEncodableShape {
        /// Information about the capacity allocated to the connector. Exactly one of the two properties must be specified.
        public let capacity: Capacity
        /// A map of keys to values that represent the configuration for the connector.
        public let connectorConfiguration: [String: String]
        /// A summary description of the connector.
        public let connectorDescription: String?
        /// The name of the connector.
        public let connectorName: String
        /// Specifies which Apache Kafka cluster to connect to.
        public let kafkaCluster: KafkaCluster
        /// Details of the client authentication used by the Apache Kafka cluster.
        public let kafkaClusterClientAuthentication: KafkaClusterClientAuthentication
        /// Details of encryption in transit to the Apache Kafka cluster.
        public let kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransit
        /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
        public let kafkaConnectVersion: String
        /// Details about log delivery.
        public let logDelivery: LogDelivery?
        ///  Amazon MSK Connect does not currently support specifying multiple plugins as a list. To use more than one plugin for your connector, you can create a single custom plugin using a ZIP file that bundles multiple plugins together.  Specifies which plugin to use for the connector. You must specify a single-element list containing one customPlugin object.
        public let plugins: [Plugin]
        /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access the Amazon Web Services resources that it needs. The types of resources depends on the logic of the connector. For example, a connector that has Amazon S3 as a destination must have permissions that allow it to write to the S3 destination bucket.
        public let serviceExecutionRoleArn: String
        /// The tags you want to attach to the connector.
        public let tags: [String: String]?
        /// Specifies which worker configuration to use with the connector.
        public let workerConfiguration: WorkerConfiguration?

        public init(capacity: Capacity, connectorConfiguration: [String: String], connectorDescription: String? = nil, connectorName: String, kafkaCluster: KafkaCluster, kafkaClusterClientAuthentication: KafkaClusterClientAuthentication, kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransit, kafkaConnectVersion: String, logDelivery: LogDelivery? = nil, plugins: [Plugin], serviceExecutionRoleArn: String, tags: [String: String]? = nil, workerConfiguration: WorkerConfiguration? = nil) {
            self.capacity = capacity
            self.connectorConfiguration = connectorConfiguration
            self.connectorDescription = connectorDescription
            self.connectorName = connectorName
            self.kafkaCluster = kafkaCluster
            self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
            self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
            self.kafkaConnectVersion = kafkaConnectVersion
            self.logDelivery = logDelivery
            self.plugins = plugins
            self.serviceExecutionRoleArn = serviceExecutionRoleArn
            self.tags = tags
            self.workerConfiguration = workerConfiguration
        }

        public func validate(name: String) throws {
            try self.capacity.validate(name: "\(name).capacity")
            try self.validate(self.connectorDescription, name: "connectorDescription", parent: name, max: 1024)
            try self.validate(self.connectorName, name: "connectorName", parent: name, max: 128)
            try self.validate(self.connectorName, name: "connectorName", parent: name, min: 1)
            try self.plugins.forEach {
                try $0.validate(name: "\(name).plugins[]")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.workerConfiguration?.validate(name: "\(name).workerConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "capacity"
            case connectorConfiguration = "connectorConfiguration"
            case connectorDescription = "connectorDescription"
            case connectorName = "connectorName"
            case kafkaCluster = "kafkaCluster"
            case kafkaClusterClientAuthentication = "kafkaClusterClientAuthentication"
            case kafkaClusterEncryptionInTransit = "kafkaClusterEncryptionInTransit"
            case kafkaConnectVersion = "kafkaConnectVersion"
            case logDelivery = "logDelivery"
            case plugins = "plugins"
            case serviceExecutionRoleArn = "serviceExecutionRoleArn"
            case tags = "tags"
            case workerConfiguration = "workerConfiguration"
        }
    }

    public struct CreateConnectorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that Amazon assigned to the connector.
        public let connectorArn: String?
        /// The name of the connector.
        public let connectorName: String?
        /// The state of the connector.
        public let connectorState: ConnectorState?

        public init(connectorArn: String? = nil, connectorName: String? = nil, connectorState: ConnectorState? = nil) {
            self.connectorArn = connectorArn
            self.connectorName = connectorName
            self.connectorState = connectorState
        }

        private enum CodingKeys: String, CodingKey {
            case connectorArn = "connectorArn"
            case connectorName = "connectorName"
            case connectorState = "connectorState"
        }
    }

    public struct CreateCustomPluginRequest: AWSEncodableShape {
        /// The type of the plugin file.
        public let contentType: CustomPluginContentType
        /// A summary description of the custom plugin.
        public let description: String?
        /// Information about the location of a custom plugin.
        public let location: CustomPluginLocation
        /// The name of the custom plugin.
        public let name: String
        /// The tags you want to attach to the custom plugin.
        public let tags: [String: String]?

        public init(contentType: CustomPluginContentType, description: String? = nil, location: CustomPluginLocation, name: String, tags: [String: String]? = nil) {
            self.contentType = contentType
            self.description = description
            self.location = location
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case description = "description"
            case location = "location"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateCustomPluginResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that Amazon assigned to the custom plugin.
        public let customPluginArn: String?
        /// The state of the custom plugin.
        public let customPluginState: CustomPluginState?
        /// The name of the custom plugin.
        public let name: String?
        /// The revision of the custom plugin.
        public let revision: Int64?

        public init(customPluginArn: String? = nil, customPluginState: CustomPluginState? = nil, name: String? = nil, revision: Int64? = nil) {
            self.customPluginArn = customPluginArn
            self.customPluginState = customPluginState
            self.name = name
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case customPluginArn = "customPluginArn"
            case customPluginState = "customPluginState"
            case name = "name"
            case revision = "revision"
        }
    }

    public struct CreateWorkerConfigurationRequest: AWSEncodableShape {
        /// A summary description of the worker configuration.
        public let description: String?
        /// The name of the worker configuration.
        public let name: String
        /// Base64 encoded contents of connect-distributed.properties file.
        public let propertiesFileContent: String
        /// The tags you want to attach to the worker configuration.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, propertiesFileContent: String, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.propertiesFileContent = propertiesFileContent
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case propertiesFileContent = "propertiesFileContent"
            case tags = "tags"
        }
    }

    public struct CreateWorkerConfigurationResponse: AWSDecodableShape {
        /// The time that the worker configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The latest revision of the worker configuration.
        public let latestRevision: WorkerConfigurationRevisionSummary?
        /// The name of the worker configuration.
        public let name: String?
        /// The Amazon Resource Name (ARN) that Amazon assigned to the worker configuration.
        public let workerConfigurationArn: String?
        /// The state of the worker configuration.
        public let workerConfigurationState: WorkerConfigurationState?

        public init(creationTime: Date? = nil, latestRevision: WorkerConfigurationRevisionSummary? = nil, name: String? = nil, workerConfigurationArn: String? = nil, workerConfigurationState: WorkerConfigurationState? = nil) {
            self.creationTime = creationTime
            self.latestRevision = latestRevision
            self.name = name
            self.workerConfigurationArn = workerConfigurationArn
            self.workerConfigurationState = workerConfigurationState
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case latestRevision = "latestRevision"
            case name = "name"
            case workerConfigurationArn = "workerConfigurationArn"
            case workerConfigurationState = "workerConfigurationState"
        }
    }

    public struct CustomPlugin: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public let customPluginArn: String
        /// The revision of the custom plugin.
        public let revision: Int64

        public init(customPluginArn: String, revision: Int64 = 0) {
            self.customPluginArn = customPluginArn
            self.revision = revision
        }

        public func validate(name: String) throws {
            try self.validate(self.revision, name: "revision", parent: name, max: -9223372036854775808)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customPluginArn = "customPluginArn"
            case revision = "revision"
        }
    }

    public struct CustomPluginDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public let customPluginArn: String?
        /// The revision of the custom plugin.
        public let revision: Int64?

        public init(customPluginArn: String? = nil, revision: Int64? = nil) {
            self.customPluginArn = customPluginArn
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case customPluginArn = "customPluginArn"
            case revision = "revision"
        }
    }

    public struct CustomPluginFileDescription: AWSDecodableShape {
        /// The hex-encoded MD5 checksum of the custom plugin file. You can use it to validate the file.
        public let fileMd5: String?
        /// The size in bytes of the custom plugin file. You can use it to validate the file.
        public let fileSize: Int64?

        public init(fileMd5: String? = nil, fileSize: Int64? = nil) {
            self.fileMd5 = fileMd5
            self.fileSize = fileSize
        }

        private enum CodingKeys: String, CodingKey {
            case fileMd5 = "fileMd5"
            case fileSize = "fileSize"
        }
    }

    public struct CustomPluginLocation: AWSEncodableShape {
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the plugin file stored in Amazon S3.
        public let s3Location: S3Location

        public init(s3Location: S3Location) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct CustomPluginLocationDescription: AWSDecodableShape {
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the plugin file stored in Amazon S3.
        public let s3Location: S3LocationDescription?

        public init(s3Location: S3LocationDescription? = nil) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct CustomPluginRevisionSummary: AWSDecodableShape {
        /// The format of the plugin file.
        public let contentType: CustomPluginContentType?
        /// The time that the custom plugin was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the custom plugin.
        public let description: String?
        /// Details about the custom plugin file.
        public let fileDescription: CustomPluginFileDescription?
        /// Information about the location of the custom plugin.
        public let location: CustomPluginLocationDescription?
        /// The revision of the custom plugin.
        public let revision: Int64?

        public init(contentType: CustomPluginContentType? = nil, creationTime: Date? = nil, description: String? = nil, fileDescription: CustomPluginFileDescription? = nil, location: CustomPluginLocationDescription? = nil, revision: Int64? = nil) {
            self.contentType = contentType
            self.creationTime = creationTime
            self.description = description
            self.fileDescription = fileDescription
            self.location = location
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case creationTime = "creationTime"
            case description = "description"
            case fileDescription = "fileDescription"
            case location = "location"
            case revision = "revision"
        }
    }

    public struct CustomPluginSummary: AWSDecodableShape {
        /// The time that the custom plugin was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public let customPluginArn: String?
        /// The state of the custom plugin.
        public let customPluginState: CustomPluginState?
        /// A description of the custom plugin.
        public let description: String?
        /// The latest revision of the custom plugin.
        public let latestRevision: CustomPluginRevisionSummary?
        /// The name of the custom plugin.
        public let name: String?

        public init(creationTime: Date? = nil, customPluginArn: String? = nil, customPluginState: CustomPluginState? = nil, description: String? = nil, latestRevision: CustomPluginRevisionSummary? = nil, name: String? = nil) {
            self.creationTime = creationTime
            self.customPluginArn = customPluginArn
            self.customPluginState = customPluginState
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case customPluginArn = "customPluginArn"
            case customPluginState = "customPluginState"
            case description = "description"
            case latestRevision = "latestRevision"
            case name = "name"
        }
    }

    public struct DeleteConnectorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the connector that you want to delete.
        public let connectorArn: String
        /// The current version of the connector that you want to delete.
        public let currentVersion: String?

        public init(connectorArn: String, currentVersion: String? = nil) {
            self.connectorArn = connectorArn
            self.currentVersion = currentVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectorArn, key: "connectorArn")
            request.encodeQuery(self.currentVersion, key: "currentVersion")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConnectorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the connector that you requested to delete.
        public let connectorArn: String?
        /// The state of the connector that you requested to delete.
        public let connectorState: ConnectorState?

        public init(connectorArn: String? = nil, connectorState: ConnectorState? = nil) {
            self.connectorArn = connectorArn
            self.connectorState = connectorState
        }

        private enum CodingKeys: String, CodingKey {
            case connectorArn = "connectorArn"
            case connectorState = "connectorState"
        }
    }

    public struct DeleteCustomPluginRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the custom plugin that you want to delete.
        public let customPluginArn: String

        public init(customPluginArn: String) {
            self.customPluginArn = customPluginArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.customPluginArn, key: "customPluginArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCustomPluginResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom plugin that you requested to delete.
        public let customPluginArn: String?
        /// The state of the custom plugin.
        public let customPluginState: CustomPluginState?

        public init(customPluginArn: String? = nil, customPluginState: CustomPluginState? = nil) {
            self.customPluginArn = customPluginArn
            self.customPluginState = customPluginState
        }

        private enum CodingKeys: String, CodingKey {
            case customPluginArn = "customPluginArn"
            case customPluginState = "customPluginState"
        }
    }

    public struct DeleteWorkerConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the worker configuration that you want to delete.
        public let workerConfigurationArn: String

        public init(workerConfigurationArn: String) {
            self.workerConfigurationArn = workerConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workerConfigurationArn, key: "workerConfigurationArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWorkerConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the worker configuration that you requested to delete.
        public let workerConfigurationArn: String?
        /// The state of the worker configuration.
        public let workerConfigurationState: WorkerConfigurationState?

        public init(workerConfigurationArn: String? = nil, workerConfigurationState: WorkerConfigurationState? = nil) {
            self.workerConfigurationArn = workerConfigurationArn
            self.workerConfigurationState = workerConfigurationState
        }

        private enum CodingKeys: String, CodingKey {
            case workerConfigurationArn = "workerConfigurationArn"
            case workerConfigurationState = "workerConfigurationState"
        }
    }

    public struct DescribeConnectorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the connector that you want to describe.
        public let connectorArn: String

        public init(connectorArn: String) {
            self.connectorArn = connectorArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectorArn, key: "connectorArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConnectorResponse: AWSDecodableShape {
        /// Information about the capacity of the connector, whether it is auto scaled or provisioned.
        public let capacity: CapacityDescription?
        /// The Amazon Resource Name (ARN) of the connector.
        public let connectorArn: String?
        /// A map of keys to values that represent the configuration for the connector.
        public let connectorConfiguration: [String: String]?
        /// A summary description of the connector.
        public let connectorDescription: String?
        /// The name of the connector.
        public let connectorName: String?
        /// The state of the connector.
        public let connectorState: ConnectorState?
        /// The time the connector was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The current version of the connector.
        public let currentVersion: String?
        /// The Apache Kafka cluster that the connector is connected to.
        public let kafkaCluster: KafkaClusterDescription?
        /// The type of client authentication used to connect to the Apache Kafka cluster. The value is NONE when no client authentication is used.
        public let kafkaClusterClientAuthentication: KafkaClusterClientAuthenticationDescription?
        /// Details of encryption in transit to the Apache Kafka cluster.
        public let kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransitDescription?
        /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
        public let kafkaConnectVersion: String?
        /// Details about delivering logs to Amazon CloudWatch Logs.
        public let logDelivery: LogDeliveryDescription?
        /// Specifies which plugins were used for this connector.
        public let plugins: [PluginDescription]?
        /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access Amazon Web Services resources.
        public let serviceExecutionRoleArn: String?
        /// Details about the state of a connector.
        public let stateDescription: StateDescription?
        /// Specifies which worker configuration was used for the connector.
        public let workerConfiguration: WorkerConfigurationDescription?

        public init(capacity: CapacityDescription? = nil, connectorArn: String? = nil, connectorConfiguration: [String: String]? = nil, connectorDescription: String? = nil, connectorName: String? = nil, connectorState: ConnectorState? = nil, creationTime: Date? = nil, currentVersion: String? = nil, kafkaCluster: KafkaClusterDescription? = nil, kafkaClusterClientAuthentication: KafkaClusterClientAuthenticationDescription? = nil, kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransitDescription? = nil, kafkaConnectVersion: String? = nil, logDelivery: LogDeliveryDescription? = nil, plugins: [PluginDescription]? = nil, serviceExecutionRoleArn: String? = nil, stateDescription: StateDescription? = nil, workerConfiguration: WorkerConfigurationDescription? = nil) {
            self.capacity = capacity
            self.connectorArn = connectorArn
            self.connectorConfiguration = connectorConfiguration
            self.connectorDescription = connectorDescription
            self.connectorName = connectorName
            self.connectorState = connectorState
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.kafkaCluster = kafkaCluster
            self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
            self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
            self.kafkaConnectVersion = kafkaConnectVersion
            self.logDelivery = logDelivery
            self.plugins = plugins
            self.serviceExecutionRoleArn = serviceExecutionRoleArn
            self.stateDescription = stateDescription
            self.workerConfiguration = workerConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "capacity"
            case connectorArn = "connectorArn"
            case connectorConfiguration = "connectorConfiguration"
            case connectorDescription = "connectorDescription"
            case connectorName = "connectorName"
            case connectorState = "connectorState"
            case creationTime = "creationTime"
            case currentVersion = "currentVersion"
            case kafkaCluster = "kafkaCluster"
            case kafkaClusterClientAuthentication = "kafkaClusterClientAuthentication"
            case kafkaClusterEncryptionInTransit = "kafkaClusterEncryptionInTransit"
            case kafkaConnectVersion = "kafkaConnectVersion"
            case logDelivery = "logDelivery"
            case plugins = "plugins"
            case serviceExecutionRoleArn = "serviceExecutionRoleArn"
            case stateDescription = "stateDescription"
            case workerConfiguration = "workerConfiguration"
        }
    }

    public struct DescribeCustomPluginRequest: AWSEncodableShape {
        /// Returns information about a custom plugin.
        public let customPluginArn: String

        public init(customPluginArn: String) {
            self.customPluginArn = customPluginArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.customPluginArn, key: "customPluginArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCustomPluginResponse: AWSDecodableShape {
        /// The time that the custom plugin was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public let customPluginArn: String?
        /// The state of the custom plugin.
        public let customPluginState: CustomPluginState?
        /// The description of the custom plugin.
        public let description: String?
        /// The latest successfully created revision of the custom plugin. If there are no successfully created revisions, this field will be absent.
        public let latestRevision: CustomPluginRevisionSummary?
        /// The name of the custom plugin.
        public let name: String?
        /// Details about the state of a custom plugin.
        public let stateDescription: StateDescription?

        public init(creationTime: Date? = nil, customPluginArn: String? = nil, customPluginState: CustomPluginState? = nil, description: String? = nil, latestRevision: CustomPluginRevisionSummary? = nil, name: String? = nil, stateDescription: StateDescription? = nil) {
            self.creationTime = creationTime
            self.customPluginArn = customPluginArn
            self.customPluginState = customPluginState
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
            self.stateDescription = stateDescription
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case customPluginArn = "customPluginArn"
            case customPluginState = "customPluginState"
            case description = "description"
            case latestRevision = "latestRevision"
            case name = "name"
            case stateDescription = "stateDescription"
        }
    }

    public struct DescribeWorkerConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the worker configuration that you want to get information about.
        public let workerConfigurationArn: String

        public init(workerConfigurationArn: String) {
            self.workerConfigurationArn = workerConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workerConfigurationArn, key: "workerConfigurationArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeWorkerConfigurationResponse: AWSDecodableShape {
        /// The time that the worker configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the worker configuration.
        public let description: String?
        /// The latest revision of the custom configuration.
        public let latestRevision: WorkerConfigurationRevisionDescription?
        /// The name of the worker configuration.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the custom configuration.
        public let workerConfigurationArn: String?
        /// The state of the worker configuration.
        public let workerConfigurationState: WorkerConfigurationState?

        public init(creationTime: Date? = nil, description: String? = nil, latestRevision: WorkerConfigurationRevisionDescription? = nil, name: String? = nil, workerConfigurationArn: String? = nil, workerConfigurationState: WorkerConfigurationState? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
            self.workerConfigurationArn = workerConfigurationArn
            self.workerConfigurationState = workerConfigurationState
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case latestRevision = "latestRevision"
            case name = "name"
            case workerConfigurationArn = "workerConfigurationArn"
            case workerConfigurationState = "workerConfigurationState"
        }
    }

    public struct FirehoseLogDelivery: AWSEncodableShape {
        /// The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
        public let deliveryStream: String?
        /// Specifies whether connector logs get delivered to Amazon Kinesis Data Firehose.
        public let enabled: Bool

        public init(deliveryStream: String? = nil, enabled: Bool = false) {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStream = "deliveryStream"
            case enabled = "enabled"
        }
    }

    public struct FirehoseLogDeliveryDescription: AWSDecodableShape {
        /// The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
        public let deliveryStream: String?
        /// Specifies whether connector logs get delivered to Amazon Kinesis Data Firehose.
        public let enabled: Bool?

        public init(deliveryStream: String? = nil, enabled: Bool? = nil) {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStream = "deliveryStream"
            case enabled = "enabled"
        }
    }

    public struct KafkaCluster: AWSEncodableShape {
        /// The Apache Kafka cluster to which the connector is connected.
        public let apacheKafkaCluster: ApacheKafkaCluster

        public init(apacheKafkaCluster: ApacheKafkaCluster) {
            self.apacheKafkaCluster = apacheKafkaCluster
        }

        private enum CodingKeys: String, CodingKey {
            case apacheKafkaCluster = "apacheKafkaCluster"
        }
    }

    public struct KafkaClusterClientAuthentication: AWSEncodableShape {
        /// The type of client authentication used to connect to the Apache Kafka cluster. Value NONE means that no client authentication is used.
        public let authenticationType: KafkaClusterClientAuthenticationType

        public init(authenticationType: KafkaClusterClientAuthenticationType) {
            self.authenticationType = authenticationType
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "authenticationType"
        }
    }

    public struct KafkaClusterClientAuthenticationDescription: AWSDecodableShape {
        /// The type of client authentication used to connect to the Apache Kafka cluster. Value NONE means that no client authentication is used.
        public let authenticationType: KafkaClusterClientAuthenticationType?

        public init(authenticationType: KafkaClusterClientAuthenticationType? = nil) {
            self.authenticationType = authenticationType
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "authenticationType"
        }
    }

    public struct KafkaClusterDescription: AWSDecodableShape {
        /// The Apache Kafka cluster to which the connector is connected.
        public let apacheKafkaCluster: ApacheKafkaClusterDescription?

        public init(apacheKafkaCluster: ApacheKafkaClusterDescription? = nil) {
            self.apacheKafkaCluster = apacheKafkaCluster
        }

        private enum CodingKeys: String, CodingKey {
            case apacheKafkaCluster = "apacheKafkaCluster"
        }
    }

    public struct KafkaClusterEncryptionInTransit: AWSEncodableShape {
        /// The type of encryption in transit to the Apache Kafka cluster.
        public let encryptionType: KafkaClusterEncryptionInTransitType

        public init(encryptionType: KafkaClusterEncryptionInTransitType) {
            self.encryptionType = encryptionType
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
        }
    }

    public struct KafkaClusterEncryptionInTransitDescription: AWSDecodableShape {
        /// The type of encryption in transit to the Apache Kafka cluster.
        public let encryptionType: KafkaClusterEncryptionInTransitType?

        public init(encryptionType: KafkaClusterEncryptionInTransitType? = nil) {
            self.encryptionType = encryptionType
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
        }
    }

    public struct ListConnectorsRequest: AWSEncodableShape {
        /// The name prefix that you want to use to search for and list connectors.
        public let connectorNamePrefix: String?
        /// The maximum number of connectors to list in one response.
        public let maxResults: Int?
        /// If the response of a ListConnectors operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
        public let nextToken: String?

        public init(connectorNamePrefix: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectorNamePrefix = connectorNamePrefix
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.connectorNamePrefix, key: "connectorNamePrefix")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConnectorsResponse: AWSDecodableShape {
        /// An array of connector descriptions.
        public let connectors: [ConnectorSummary]?
        /// If the response of a ListConnectors operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where it left off.
        public let nextToken: String?

        public init(connectors: [ConnectorSummary]? = nil, nextToken: String? = nil) {
            self.connectors = connectors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectors = "connectors"
            case nextToken = "nextToken"
        }
    }

    public struct ListCustomPluginsRequest: AWSEncodableShape {
        /// The maximum number of custom plugins to list in one response.
        public let maxResults: Int?
        /// Lists custom plugin names that start with the specified text string.
        public let namePrefix: String?
        /// If the response of a ListCustomPlugins operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
        public let nextToken: String?

        public init(maxResults: Int? = nil, namePrefix: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.namePrefix = namePrefix
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.namePrefix, key: "namePrefix")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCustomPluginsResponse: AWSDecodableShape {
        /// An array of custom plugin descriptions.
        public let customPlugins: [CustomPluginSummary]?
        /// If the response of a ListCustomPlugins operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
        public let nextToken: String?

        public init(customPlugins: [CustomPluginSummary]? = nil, nextToken: String? = nil) {
            self.customPlugins = customPlugins
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case customPlugins = "customPlugins"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which you want to list all attached tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Lists the tags attached to the specified resource in the corresponding request.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWorkerConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of worker configurations to list in one response.
        public let maxResults: Int?
        /// Lists worker configuration names that start with the specified text string.
        public let namePrefix: String?
        /// If the response of a ListWorkerConfigurations operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
        public let nextToken: String?

        public init(maxResults: Int? = nil, namePrefix: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.namePrefix = namePrefix
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.namePrefix, key: "namePrefix")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkerConfigurationsResponse: AWSDecodableShape {
        /// If the response of a ListWorkerConfigurations operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
        public let nextToken: String?
        /// An array of worker configuration descriptions.
        public let workerConfigurations: [WorkerConfigurationSummary]?

        public init(nextToken: String? = nil, workerConfigurations: [WorkerConfigurationSummary]? = nil) {
            self.nextToken = nextToken
            self.workerConfigurations = workerConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workerConfigurations = "workerConfigurations"
        }
    }

    public struct LogDelivery: AWSEncodableShape {
        /// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
        public let workerLogDelivery: WorkerLogDelivery

        public init(workerLogDelivery: WorkerLogDelivery) {
            self.workerLogDelivery = workerLogDelivery
        }

        private enum CodingKeys: String, CodingKey {
            case workerLogDelivery = "workerLogDelivery"
        }
    }

    public struct LogDeliveryDescription: AWSDecodableShape {
        /// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
        public let workerLogDelivery: WorkerLogDeliveryDescription?

        public init(workerLogDelivery: WorkerLogDeliveryDescription? = nil) {
            self.workerLogDelivery = workerLogDelivery
        }

        private enum CodingKeys: String, CodingKey {
            case workerLogDelivery = "workerLogDelivery"
        }
    }

    public struct Plugin: AWSEncodableShape {
        /// Details about a custom plugin.
        public let customPlugin: CustomPlugin

        public init(customPlugin: CustomPlugin) {
            self.customPlugin = customPlugin
        }

        public func validate(name: String) throws {
            try self.customPlugin.validate(name: "\(name).customPlugin")
        }

        private enum CodingKeys: String, CodingKey {
            case customPlugin = "customPlugin"
        }
    }

    public struct PluginDescription: AWSDecodableShape {
        /// Details about a custom plugin.
        public let customPlugin: CustomPluginDescription?

        public init(customPlugin: CustomPluginDescription? = nil) {
            self.customPlugin = customPlugin
        }

        private enum CodingKeys: String, CodingKey {
            case customPlugin = "customPlugin"
        }
    }

    public struct ProvisionedCapacity: AWSEncodableShape {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int
        /// The number of workers that are allocated to the connector.
        public let workerCount: Int

        public init(mcuCount: Int = 0, workerCount: Int = 0) {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }

        public func validate(name: String) throws {
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, max: 8)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, min: 1)
            try self.validate(self.workerCount, name: "workerCount", parent: name, max: 10)
            try self.validate(self.workerCount, name: "workerCount", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case mcuCount = "mcuCount"
            case workerCount = "workerCount"
        }
    }

    public struct ProvisionedCapacityDescription: AWSDecodableShape {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int?
        /// The number of workers that are allocated to the connector.
        public let workerCount: Int?

        public init(mcuCount: Int? = nil, workerCount: Int? = nil) {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }

        private enum CodingKeys: String, CodingKey {
            case mcuCount = "mcuCount"
            case workerCount = "workerCount"
        }
    }

    public struct ProvisionedCapacityUpdate: AWSEncodableShape {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public let mcuCount: Int
        /// The number of workers that are allocated to the connector.
        public let workerCount: Int

        public init(mcuCount: Int = 0, workerCount: Int = 0) {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }

        public func validate(name: String) throws {
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, max: 8)
            try self.validate(self.mcuCount, name: "mcuCount", parent: name, min: 1)
            try self.validate(self.workerCount, name: "workerCount", parent: name, max: 10)
            try self.validate(self.workerCount, name: "workerCount", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case mcuCount = "mcuCount"
            case workerCount = "workerCount"
        }
    }

    public struct S3Location: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of an S3 bucket.
        public let bucketArn: String
        /// The file key for an object in an S3 bucket.
        public let fileKey: String
        /// The version of an object in an S3 bucket.
        public let objectVersion: String?

        public init(bucketArn: String, fileKey: String, objectVersion: String? = nil) {
            self.bucketArn = bucketArn
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "bucketArn"
            case fileKey = "fileKey"
            case objectVersion = "objectVersion"
        }
    }

    public struct S3LocationDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an S3 bucket.
        public let bucketArn: String?
        /// The file key for an object in an S3 bucket.
        public let fileKey: String?
        /// The version of an object in an S3 bucket.
        public let objectVersion: String?

        public init(bucketArn: String? = nil, fileKey: String? = nil, objectVersion: String? = nil) {
            self.bucketArn = bucketArn
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "bucketArn"
            case fileKey = "fileKey"
            case objectVersion = "objectVersion"
        }
    }

    public struct S3LogDelivery: AWSEncodableShape {
        /// The name of the S3 bucket that is the destination for log delivery.
        public let bucket: String?
        /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
        public let enabled: Bool
        /// The S3 prefix that is the destination for log delivery.
        public let prefix: String?

        public init(bucket: String? = nil, enabled: Bool = false, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case enabled = "enabled"
            case prefix = "prefix"
        }
    }

    public struct S3LogDeliveryDescription: AWSDecodableShape {
        /// The name of the S3 bucket that is the destination for log delivery.
        public let bucket: String?
        /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
        public let enabled: Bool?
        /// The S3 prefix that is the destination for log delivery.
        public let prefix: String?

        public init(bucket: String? = nil, enabled: Bool? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case enabled = "enabled"
            case prefix = "prefix"
        }
    }

    public struct ScaleInPolicy: AWSEncodableShape {
        /// Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
        public let cpuUtilizationPercentage: Int

        public init(cpuUtilizationPercentage: Int = 0) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, max: 100)
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage = "cpuUtilizationPercentage"
        }
    }

    public struct ScaleInPolicyDescription: AWSDecodableShape {
        /// Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
        public let cpuUtilizationPercentage: Int?

        public init(cpuUtilizationPercentage: Int? = nil) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage = "cpuUtilizationPercentage"
        }
    }

    public struct ScaleInPolicyUpdate: AWSEncodableShape {
        /// The target CPU utilization percentage threshold at which you want connector scale in to be triggered.
        public let cpuUtilizationPercentage: Int

        public init(cpuUtilizationPercentage: Int = 0) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, max: 100)
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage = "cpuUtilizationPercentage"
        }
    }

    public struct ScaleOutPolicy: AWSEncodableShape {
        /// The CPU utilization percentage threshold at which you want connector scale out to be triggered.
        public let cpuUtilizationPercentage: Int

        public init(cpuUtilizationPercentage: Int = 0) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, max: 100)
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage = "cpuUtilizationPercentage"
        }
    }

    public struct ScaleOutPolicyDescription: AWSDecodableShape {
        /// The CPU utilization percentage threshold at which you want connector scale out to be triggered.
        public let cpuUtilizationPercentage: Int?

        public init(cpuUtilizationPercentage: Int? = nil) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage = "cpuUtilizationPercentage"
        }
    }

    public struct ScaleOutPolicyUpdate: AWSEncodableShape {
        /// The target CPU utilization percentage threshold at which you want connector scale out to be triggered.
        public let cpuUtilizationPercentage: Int

        public init(cpuUtilizationPercentage: Int = 0) {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, max: 100)
            try self.validate(self.cpuUtilizationPercentage, name: "cpuUtilizationPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cpuUtilizationPercentage = "cpuUtilizationPercentage"
        }
    }

    public struct StateDescription: AWSDecodableShape {
        /// A code that describes the state of a resource.
        public let code: String?
        /// A message that describes the state of a resource.
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to which you want to attach tags.
        public let resourceArn: String
        /// The tags that you want to attach to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource from which you want to remove tags.
        public let resourceArn: String
        /// The keys of the tags that you want to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConnectorRequest: AWSEncodableShape {
        /// The target capacity.
        public let capacity: CapacityUpdate
        /// The Amazon Resource Name (ARN) of the connector that you want to update.
        public let connectorArn: String
        /// The current version of the connector that you want to update.
        public let currentVersion: String

        public init(capacity: CapacityUpdate, connectorArn: String, currentVersion: String) {
            self.capacity = capacity
            self.connectorArn = connectorArn
            self.currentVersion = currentVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.capacity, forKey: .capacity)
            request.encodePath(self.connectorArn, key: "connectorArn")
            request.encodeQuery(self.currentVersion, key: "currentVersion")
        }

        public func validate(name: String) throws {
            try self.capacity.validate(name: "\(name).capacity")
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "capacity"
        }
    }

    public struct UpdateConnectorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the connector.
        public let connectorArn: String?
        /// The state of the connector.
        public let connectorState: ConnectorState?

        public init(connectorArn: String? = nil, connectorState: ConnectorState? = nil) {
            self.connectorArn = connectorArn
            self.connectorState = connectorState
        }

        private enum CodingKeys: String, CodingKey {
            case connectorArn = "connectorArn"
            case connectorState = "connectorState"
        }
    }

    public struct Vpc: AWSEncodableShape {
        /// The security groups for the connector.
        public let securityGroups: [String]?
        /// The subnets for the connector.
        public let subnets: [String]

        public init(securityGroups: [String]? = nil, subnets: [String]) {
            self.securityGroups = securityGroups
            self.subnets = subnets
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroups = "securityGroups"
            case subnets = "subnets"
        }
    }

    public struct VpcDescription: AWSDecodableShape {
        /// The security groups for the connector.
        public let securityGroups: [String]?
        /// The subnets for the connector.
        public let subnets: [String]?

        public init(securityGroups: [String]? = nil, subnets: [String]? = nil) {
            self.securityGroups = securityGroups
            self.subnets = subnets
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroups = "securityGroups"
            case subnets = "subnets"
        }
    }

    public struct WorkerConfiguration: AWSEncodableShape {
        /// The revision of the worker configuration.
        public let revision: Int64
        /// The Amazon Resource Name (ARN) of the worker configuration.
        public let workerConfigurationArn: String

        public init(revision: Int64 = 0, workerConfigurationArn: String) {
            self.revision = revision
            self.workerConfigurationArn = workerConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.revision, name: "revision", parent: name, max: -9223372036854775808)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case revision = "revision"
            case workerConfigurationArn = "workerConfigurationArn"
        }
    }

    public struct WorkerConfigurationDescription: AWSDecodableShape {
        /// The revision of the worker configuration.
        public let revision: Int64?
        /// The Amazon Resource Name (ARN) of the worker configuration.
        public let workerConfigurationArn: String?

        public init(revision: Int64? = nil, workerConfigurationArn: String? = nil) {
            self.revision = revision
            self.workerConfigurationArn = workerConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case revision = "revision"
            case workerConfigurationArn = "workerConfigurationArn"
        }
    }

    public struct WorkerConfigurationRevisionDescription: AWSDecodableShape {
        /// The time that the worker configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the worker configuration revision.
        public let description: String?
        /// Base64 encoded contents of the connect-distributed.properties file.
        public let propertiesFileContent: String?
        /// The description of a revision of the worker configuration.
        public let revision: Int64?

        public init(creationTime: Date? = nil, description: String? = nil, propertiesFileContent: String? = nil, revision: Int64? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.propertiesFileContent = propertiesFileContent
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case propertiesFileContent = "propertiesFileContent"
            case revision = "revision"
        }
    }

    public struct WorkerConfigurationRevisionSummary: AWSDecodableShape {
        /// The time that a worker configuration revision was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of a worker configuration revision.
        public let description: String?
        /// The revision of a worker configuration.
        public let revision: Int64?

        public init(creationTime: Date? = nil, description: String? = nil, revision: Int64? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case revision = "revision"
        }
    }

    public struct WorkerConfigurationSummary: AWSDecodableShape {
        /// The time that a worker configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of a worker configuration.
        public let description: String?
        /// The latest revision of a worker configuration.
        public let latestRevision: WorkerConfigurationRevisionSummary?
        /// The name of the worker configuration.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the worker configuration.
        public let workerConfigurationArn: String?
        /// The state of the worker configuration.
        public let workerConfigurationState: WorkerConfigurationState?

        public init(creationTime: Date? = nil, description: String? = nil, latestRevision: WorkerConfigurationRevisionSummary? = nil, name: String? = nil, workerConfigurationArn: String? = nil, workerConfigurationState: WorkerConfigurationState? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
            self.workerConfigurationArn = workerConfigurationArn
            self.workerConfigurationState = workerConfigurationState
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case latestRevision = "latestRevision"
            case name = "name"
            case workerConfigurationArn = "workerConfigurationArn"
            case workerConfigurationState = "workerConfigurationState"
        }
    }

    public struct WorkerLogDelivery: AWSEncodableShape {
        /// Details about delivering logs to Amazon CloudWatch Logs.
        public let cloudWatchLogs: CloudWatchLogsLogDelivery?
        /// Details about delivering logs to Amazon Kinesis Data Firehose.
        public let firehose: FirehoseLogDelivery?
        /// Details about delivering logs to Amazon S3.
        public let s3: S3LogDelivery?

        public init(cloudWatchLogs: CloudWatchLogsLogDelivery? = nil, firehose: FirehoseLogDelivery? = nil, s3: S3LogDelivery? = nil) {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogs = "cloudWatchLogs"
            case firehose = "firehose"
            case s3 = "s3"
        }
    }

    public struct WorkerLogDeliveryDescription: AWSDecodableShape {
        /// Details about delivering logs to Amazon CloudWatch Logs.
        public let cloudWatchLogs: CloudWatchLogsLogDeliveryDescription?
        /// Details about delivering logs to Amazon Kinesis Data Firehose.
        public let firehose: FirehoseLogDeliveryDescription?
        /// Details about delivering logs to Amazon S3.
        public let s3: S3LogDeliveryDescription?

        public init(cloudWatchLogs: CloudWatchLogsLogDeliveryDescription? = nil, firehose: FirehoseLogDeliveryDescription? = nil, s3: S3LogDeliveryDescription? = nil) {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogs = "cloudWatchLogs"
            case firehose = "firehose"
            case s3 = "s3"
        }
    }
}

// MARK: - Errors

/// Error enum for KafkaConnect
public struct KafkaConnectErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case internalServerErrorException = "InternalServerErrorException"
        case notFoundException = "NotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case tooManyRequestsException = "TooManyRequestsException"
        case unauthorizedException = "UnauthorizedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize KafkaConnect
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// HTTP Status Code 400: Bad request due to incorrect input. Correct your request and then retry it.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// HTTP Status Code 409: Conflict. A resource with this name already exists. Retry your request with another name.
    public static var conflictException: Self { .init(.conflictException) }
    /// HTTP Status Code 403: Access forbidden. Correct your credentials and then retry your request.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// HTTP Status Code 500: Unexpected internal server error. Retrying your request might resolve the issue.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// HTTP Status Code 404: Resource not found due to incorrect input. Correct your request and then retry it.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// HTTP Status Code 503: Service Unavailable. Retrying your request in some time might resolve the issue.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// HTTP Status Code 429: Limit exceeded. Resource limit reached.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// HTTP Status Code 401: Unauthorized request. The provided credentials couldn't be validated.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
}

extension KafkaConnectErrorType: Equatable {
    public static func == (lhs: KafkaConnectErrorType, rhs: KafkaConnectErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension KafkaConnectErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
