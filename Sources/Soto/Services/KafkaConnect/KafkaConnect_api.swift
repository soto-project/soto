//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS KafkaConnect service.
public struct KafkaConnect: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the KafkaConnect client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "KafkaConnect",
            serviceIdentifier: "kafkaconnect",
            serviceProtocol: .restjson,
            apiVersion: "2021-09-14",
            endpoint: endpoint,
            errorType: KafkaConnectErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Creates a connector using the specified properties.
    @Sendable
    @inlinable
    public func createConnector(_ input: CreateConnectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateConnectorResponse {
        try await self.client.execute(
            operation: "CreateConnector", 
            path: "/v1/connectors", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a connector using the specified properties.
    ///
    /// Parameters:
    ///   - capacity: Information about the capacity allocated to the connector. Exactly one of the two properties must be specified.
    ///   - connectorConfiguration: A map of keys to values that represent the configuration for the connector.
    ///   - connectorDescription: A summary description of the connector.
    ///   - connectorName: The name of the connector.
    ///   - kafkaCluster: Specifies which Apache Kafka cluster to connect to.
    ///   - kafkaClusterClientAuthentication: Details of the client authentication used by the Apache Kafka cluster.
    ///   - kafkaClusterEncryptionInTransit: Details of encryption in transit to the Apache Kafka cluster.
    ///   - kafkaConnectVersion: The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
    ///   - logDelivery: Details about log delivery.
    ///   - plugins:  Amazon MSK Connect does not currently support specifying multiple plugins as a list. To use more than one plugin for your connector, you can create a single custom plugin using a ZIP file that bundles multiple plugins together.  Specifies which plugin to use for the connector. You must specify a single-element list containing one customPlugin object.
    ///   - serviceExecutionRoleArn: The Amazon Resource Name (ARN) of the IAM role used by the connector to access the Amazon Web Services resources that it needs. The types of resources depends on the logic of the connector. For example, a connector that has Amazon S3 as a destination must have permissions that allow it to write to the S3 destination bucket.
    ///   - tags: The tags you want to attach to the connector.
    ///   - workerConfiguration: Specifies which worker configuration to use with the connector.
    ///   - logger: Logger use during operation
    @inlinable
    public func createConnector(
        capacity: Capacity,
        connectorConfiguration: [String: String],
        connectorDescription: String? = nil,
        connectorName: String,
        kafkaCluster: KafkaCluster,
        kafkaClusterClientAuthentication: KafkaClusterClientAuthentication,
        kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransit,
        kafkaConnectVersion: String,
        logDelivery: LogDelivery? = nil,
        plugins: [Plugin],
        serviceExecutionRoleArn: String,
        tags: [String: String]? = nil,
        workerConfiguration: WorkerConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateConnectorResponse {
        let input = CreateConnectorRequest(
            capacity: capacity, 
            connectorConfiguration: connectorConfiguration, 
            connectorDescription: connectorDescription, 
            connectorName: connectorName, 
            kafkaCluster: kafkaCluster, 
            kafkaClusterClientAuthentication: kafkaClusterClientAuthentication, 
            kafkaClusterEncryptionInTransit: kafkaClusterEncryptionInTransit, 
            kafkaConnectVersion: kafkaConnectVersion, 
            logDelivery: logDelivery, 
            plugins: plugins, 
            serviceExecutionRoleArn: serviceExecutionRoleArn, 
            tags: tags, 
            workerConfiguration: workerConfiguration
        )
        return try await self.createConnector(input, logger: logger)
    }

    /// Creates a custom plugin using the specified properties.
    @Sendable
    @inlinable
    public func createCustomPlugin(_ input: CreateCustomPluginRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCustomPluginResponse {
        try await self.client.execute(
            operation: "CreateCustomPlugin", 
            path: "/v1/custom-plugins", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a custom plugin using the specified properties.
    ///
    /// Parameters:
    ///   - contentType: The type of the plugin file.
    ///   - description: A summary description of the custom plugin.
    ///   - location: Information about the location of a custom plugin.
    ///   - name: The name of the custom plugin.
    ///   - tags: The tags you want to attach to the custom plugin.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCustomPlugin(
        contentType: CustomPluginContentType,
        description: String? = nil,
        location: CustomPluginLocation,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCustomPluginResponse {
        let input = CreateCustomPluginRequest(
            contentType: contentType, 
            description: description, 
            location: location, 
            name: name, 
            tags: tags
        )
        return try await self.createCustomPlugin(input, logger: logger)
    }

    /// Creates a worker configuration using the specified properties.
    @Sendable
    @inlinable
    public func createWorkerConfiguration(_ input: CreateWorkerConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkerConfigurationResponse {
        try await self.client.execute(
            operation: "CreateWorkerConfiguration", 
            path: "/v1/worker-configurations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a worker configuration using the specified properties.
    ///
    /// Parameters:
    ///   - description: A summary description of the worker configuration.
    ///   - name: The name of the worker configuration.
    ///   - propertiesFileContent: Base64 encoded contents of connect-distributed.properties file.
    ///   - tags: The tags you want to attach to the worker configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func createWorkerConfiguration(
        description: String? = nil,
        name: String,
        propertiesFileContent: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateWorkerConfigurationResponse {
        let input = CreateWorkerConfigurationRequest(
            description: description, 
            name: name, 
            propertiesFileContent: propertiesFileContent, 
            tags: tags
        )
        return try await self.createWorkerConfiguration(input, logger: logger)
    }

    /// Deletes the specified connector.
    @Sendable
    @inlinable
    public func deleteConnector(_ input: DeleteConnectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteConnectorResponse {
        try await self.client.execute(
            operation: "DeleteConnector", 
            path: "/v1/connectors/{connectorArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified connector.
    ///
    /// Parameters:
    ///   - connectorArn: The Amazon Resource Name (ARN) of the connector that you want to delete.
    ///   - currentVersion: The current version of the connector that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteConnector(
        connectorArn: String,
        currentVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteConnectorResponse {
        let input = DeleteConnectorRequest(
            connectorArn: connectorArn, 
            currentVersion: currentVersion
        )
        return try await self.deleteConnector(input, logger: logger)
    }

    /// Deletes a custom plugin.
    @Sendable
    @inlinable
    public func deleteCustomPlugin(_ input: DeleteCustomPluginRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCustomPluginResponse {
        try await self.client.execute(
            operation: "DeleteCustomPlugin", 
            path: "/v1/custom-plugins/{customPluginArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a custom plugin.
    ///
    /// Parameters:
    ///   - customPluginArn: The Amazon Resource Name (ARN) of the custom plugin that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCustomPlugin(
        customPluginArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCustomPluginResponse {
        let input = DeleteCustomPluginRequest(
            customPluginArn: customPluginArn
        )
        return try await self.deleteCustomPlugin(input, logger: logger)
    }

    /// Deletes the specified worker configuration.
    @Sendable
    @inlinable
    public func deleteWorkerConfiguration(_ input: DeleteWorkerConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteWorkerConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteWorkerConfiguration", 
            path: "/v1/worker-configurations/{workerConfigurationArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified worker configuration.
    ///
    /// Parameters:
    ///   - workerConfigurationArn: The Amazon Resource Name (ARN) of the worker configuration that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteWorkerConfiguration(
        workerConfigurationArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteWorkerConfigurationResponse {
        let input = DeleteWorkerConfigurationRequest(
            workerConfigurationArn: workerConfigurationArn
        )
        return try await self.deleteWorkerConfiguration(input, logger: logger)
    }

    /// Returns summary information about the connector.
    @Sendable
    @inlinable
    public func describeConnector(_ input: DescribeConnectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeConnectorResponse {
        try await self.client.execute(
            operation: "DescribeConnector", 
            path: "/v1/connectors/{connectorArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns summary information about the connector.
    ///
    /// Parameters:
    ///   - connectorArn: The Amazon Resource Name (ARN) of the connector that you want to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeConnector(
        connectorArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeConnectorResponse {
        let input = DescribeConnectorRequest(
            connectorArn: connectorArn
        )
        return try await self.describeConnector(input, logger: logger)
    }

    /// Returns information about the specified connector's operations.
    @Sendable
    @inlinable
    public func describeConnectorOperation(_ input: DescribeConnectorOperationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeConnectorOperationResponse {
        try await self.client.execute(
            operation: "DescribeConnectorOperation", 
            path: "/v1/connectorOperations/{connectorOperationArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about the specified connector's operations.
    ///
    /// Parameters:
    ///   - connectorOperationArn: ARN of the connector operation to be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeConnectorOperation(
        connectorOperationArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeConnectorOperationResponse {
        let input = DescribeConnectorOperationRequest(
            connectorOperationArn: connectorOperationArn
        )
        return try await self.describeConnectorOperation(input, logger: logger)
    }

    /// A summary description of the custom plugin.
    @Sendable
    @inlinable
    public func describeCustomPlugin(_ input: DescribeCustomPluginRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeCustomPluginResponse {
        try await self.client.execute(
            operation: "DescribeCustomPlugin", 
            path: "/v1/custom-plugins/{customPluginArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// A summary description of the custom plugin.
    ///
    /// Parameters:
    ///   - customPluginArn: Returns information about a custom plugin.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeCustomPlugin(
        customPluginArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeCustomPluginResponse {
        let input = DescribeCustomPluginRequest(
            customPluginArn: customPluginArn
        )
        return try await self.describeCustomPlugin(input, logger: logger)
    }

    /// Returns information about a worker configuration.
    @Sendable
    @inlinable
    public func describeWorkerConfiguration(_ input: DescribeWorkerConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeWorkerConfigurationResponse {
        try await self.client.execute(
            operation: "DescribeWorkerConfiguration", 
            path: "/v1/worker-configurations/{workerConfigurationArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a worker configuration.
    ///
    /// Parameters:
    ///   - workerConfigurationArn: The Amazon Resource Name (ARN) of the worker configuration that you want to get information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeWorkerConfiguration(
        workerConfigurationArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeWorkerConfigurationResponse {
        let input = DescribeWorkerConfigurationRequest(
            workerConfigurationArn: workerConfigurationArn
        )
        return try await self.describeWorkerConfiguration(input, logger: logger)
    }

    /// Lists information about a connector's operation(s).
    @Sendable
    @inlinable
    public func listConnectorOperations(_ input: ListConnectorOperationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListConnectorOperationsResponse {
        try await self.client.execute(
            operation: "ListConnectorOperations", 
            path: "/v1/connectors/{connectorArn}/operations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists information about a connector's operation(s).
    ///
    /// Parameters:
    ///   - connectorArn: The Amazon Resource Name (ARN) of the connector for which to list operations.
    ///   - maxResults: Maximum number of connector operations to fetch in one get request.
    ///   - nextToken: If the response is truncated, it includes a NextToken. Send this NextToken in a subsequent request to continue listing from where it left off.
    ///   - logger: Logger use during operation
    @inlinable
    public func listConnectorOperations(
        connectorArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListConnectorOperationsResponse {
        let input = ListConnectorOperationsRequest(
            connectorArn: connectorArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listConnectorOperations(input, logger: logger)
    }

    /// Returns a list of all the connectors in this account and Region. The list is limited to connectors whose name starts with the specified prefix. The response also includes a description of each of the listed connectors.
    @Sendable
    @inlinable
    public func listConnectors(_ input: ListConnectorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListConnectorsResponse {
        try await self.client.execute(
            operation: "ListConnectors", 
            path: "/v1/connectors", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the connectors in this account and Region. The list is limited to connectors whose name starts with the specified prefix. The response also includes a description of each of the listed connectors.
    ///
    /// Parameters:
    ///   - connectorNamePrefix: The name prefix that you want to use to search for and list connectors.
    ///   - maxResults: The maximum number of connectors to list in one response.
    ///   - nextToken: If the response of a ListConnectors operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    ///   - logger: Logger use during operation
    @inlinable
    public func listConnectors(
        connectorNamePrefix: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListConnectorsResponse {
        let input = ListConnectorsRequest(
            connectorNamePrefix: connectorNamePrefix, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listConnectors(input, logger: logger)
    }

    /// Returns a list of all of the custom plugins in this account and Region.
    @Sendable
    @inlinable
    public func listCustomPlugins(_ input: ListCustomPluginsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCustomPluginsResponse {
        try await self.client.execute(
            operation: "ListCustomPlugins", 
            path: "/v1/custom-plugins", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all of the custom plugins in this account and Region.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of custom plugins to list in one response.
    ///   - namePrefix: Lists custom plugin names that start with the specified text string.
    ///   - nextToken: If the response of a ListCustomPlugins operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCustomPlugins(
        maxResults: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCustomPluginsResponse {
        let input = ListCustomPluginsRequest(
            maxResults: maxResults, 
            namePrefix: namePrefix, 
            nextToken: nextToken
        )
        return try await self.listCustomPlugins(input, logger: logger)
    }

    /// Lists all the tags attached to the specified resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/v1/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the tags attached to the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which you want to list all attached tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Returns a list of all of the worker configurations in this account and Region.
    @Sendable
    @inlinable
    public func listWorkerConfigurations(_ input: ListWorkerConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkerConfigurationsResponse {
        try await self.client.execute(
            operation: "ListWorkerConfigurations", 
            path: "/v1/worker-configurations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all of the worker configurations in this account and Region.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of worker configurations to list in one response.
    ///   - namePrefix: Lists worker configuration names that start with the specified text string.
    ///   - nextToken: If the response of a ListWorkerConfigurations operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkerConfigurations(
        maxResults: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkerConfigurationsResponse {
        let input = ListWorkerConfigurationsRequest(
            maxResults: maxResults, 
            namePrefix: namePrefix, 
            nextToken: nextToken
        )
        return try await self.listWorkerConfigurations(input, logger: logger)
    }

    /// Attaches tags to the specified resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/v1/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Attaches tags to the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource to which you want to attach tags.
    ///   - tags: The tags that you want to attach to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes tags from the specified resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/v1/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes tags from the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource from which you want to remove tags.
    ///   - tagKeys: The keys of the tags that you want to remove from the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates the specified connector.
    @Sendable
    @inlinable
    public func updateConnector(_ input: UpdateConnectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateConnectorResponse {
        try await self.client.execute(
            operation: "UpdateConnector", 
            path: "/v1/connectors/{connectorArn}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified connector.
    ///
    /// Parameters:
    ///   - capacity: The target capacity.
    ///   - connectorArn: The Amazon Resource Name (ARN) of the connector that you want to update.
    ///   - connectorConfiguration: A map of keys to values that represent the configuration for the connector.
    ///   - currentVersion: The current version of the connector that you want to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateConnector(
        capacity: CapacityUpdate? = nil,
        connectorArn: String,
        connectorConfiguration: [String: String]? = nil,
        currentVersion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateConnectorResponse {
        let input = UpdateConnectorRequest(
            capacity: capacity, 
            connectorArn: connectorArn, 
            connectorConfiguration: connectorConfiguration, 
            currentVersion: currentVersion
        )
        return try await self.updateConnector(input, logger: logger)
    }
}

extension KafkaConnect {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: KafkaConnect, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension KafkaConnect {
    /// Return PaginatorSequence for operation ``listConnectorOperations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listConnectorOperationsPaginator(
        _ input: ListConnectorOperationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListConnectorOperationsRequest, ListConnectorOperationsResponse> {
        return .init(
            input: input,
            command: self.listConnectorOperations,
            inputKey: \ListConnectorOperationsRequest.nextToken,
            outputKey: \ListConnectorOperationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listConnectorOperations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - connectorArn: The Amazon Resource Name (ARN) of the connector for which to list operations.
    ///   - maxResults: Maximum number of connector operations to fetch in one get request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listConnectorOperationsPaginator(
        connectorArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListConnectorOperationsRequest, ListConnectorOperationsResponse> {
        let input = ListConnectorOperationsRequest(
            connectorArn: connectorArn, 
            maxResults: maxResults
        )
        return self.listConnectorOperationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listConnectors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listConnectorsPaginator(
        _ input: ListConnectorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListConnectorsRequest, ListConnectorsResponse> {
        return .init(
            input: input,
            command: self.listConnectors,
            inputKey: \ListConnectorsRequest.nextToken,
            outputKey: \ListConnectorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listConnectors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - connectorNamePrefix: The name prefix that you want to use to search for and list connectors.
    ///   - maxResults: The maximum number of connectors to list in one response.
    ///   - logger: Logger used for logging
    @inlinable
    public func listConnectorsPaginator(
        connectorNamePrefix: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListConnectorsRequest, ListConnectorsResponse> {
        let input = ListConnectorsRequest(
            connectorNamePrefix: connectorNamePrefix, 
            maxResults: maxResults
        )
        return self.listConnectorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCustomPlugins(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCustomPluginsPaginator(
        _ input: ListCustomPluginsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCustomPluginsRequest, ListCustomPluginsResponse> {
        return .init(
            input: input,
            command: self.listCustomPlugins,
            inputKey: \ListCustomPluginsRequest.nextToken,
            outputKey: \ListCustomPluginsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCustomPlugins(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of custom plugins to list in one response.
    ///   - namePrefix: Lists custom plugin names that start with the specified text string.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCustomPluginsPaginator(
        maxResults: Int? = nil,
        namePrefix: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCustomPluginsRequest, ListCustomPluginsResponse> {
        let input = ListCustomPluginsRequest(
            maxResults: maxResults, 
            namePrefix: namePrefix
        )
        return self.listCustomPluginsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkerConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkerConfigurationsPaginator(
        _ input: ListWorkerConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkerConfigurationsRequest, ListWorkerConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listWorkerConfigurations,
            inputKey: \ListWorkerConfigurationsRequest.nextToken,
            outputKey: \ListWorkerConfigurationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkerConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of worker configurations to list in one response.
    ///   - namePrefix: Lists worker configuration names that start with the specified text string.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkerConfigurationsPaginator(
        maxResults: Int? = nil,
        namePrefix: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkerConfigurationsRequest, ListWorkerConfigurationsResponse> {
        let input = ListWorkerConfigurationsRequest(
            maxResults: maxResults, 
            namePrefix: namePrefix
        )
        return self.listWorkerConfigurationsPaginator(input, logger: logger)
    }
}

extension KafkaConnect.ListConnectorOperationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> KafkaConnect.ListConnectorOperationsRequest {
        return .init(
            connectorArn: self.connectorArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension KafkaConnect.ListConnectorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> KafkaConnect.ListConnectorsRequest {
        return .init(
            connectorNamePrefix: self.connectorNamePrefix,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension KafkaConnect.ListCustomPluginsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> KafkaConnect.ListCustomPluginsRequest {
        return .init(
            maxResults: self.maxResults,
            namePrefix: self.namePrefix,
            nextToken: token
        )
    }
}

extension KafkaConnect.ListWorkerConfigurationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> KafkaConnect.ListWorkerConfigurationsRequest {
        return .init(
            maxResults: self.maxResults,
            namePrefix: self.namePrefix,
            nextToken: token
        )
    }
}
