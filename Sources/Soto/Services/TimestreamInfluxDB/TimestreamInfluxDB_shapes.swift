//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension TimestreamInfluxDB {
    // MARK: Enums

    public enum DbInstanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dbInflux12Xlarge = "db.influx.12xlarge"
        case dbInflux16Xlarge = "db.influx.16xlarge"
        case dbInflux2Xlarge = "db.influx.2xlarge"
        case dbInflux4Xlarge = "db.influx.4xlarge"
        case dbInflux8Xlarge = "db.influx.8xlarge"
        case dbInfluxLarge = "db.influx.large"
        case dbInfluxMedium = "db.influx.medium"
        case dbInfluxXlarge = "db.influx.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum DbStorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case influxIoIncludedT1 = "InfluxIOIncludedT1"
        case influxIoIncludedT2 = "InfluxIOIncludedT2"
        case influxIoIncludedT3 = "InfluxIOIncludedT3"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case singleAz = "SINGLE_AZ"
        case withMultiazStandby = "WITH_MULTIAZ_STANDBY"
        public var description: String { return self.rawValue }
    }

    public enum LogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "debug"
        case error = "error"
        case info = "info"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case modifying = "MODIFYING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum TracingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jaeger = "jaeger"
        case log = "log"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateDbInstanceInput: AWSEncodableShape {
        /// The amount of storage to allocate for your DB storage type in GiB (gibibytes).
        public let allocatedStorage: Int
        /// The name of the initial InfluxDB bucket. All InfluxDB data is stored in a bucket. A bucket combines the concept of a database and a retention period (the duration of time that each data point persists). A bucket belongs to an organization.
        public let bucket: String?
        /// The Timestream for InfluxDB DB instance type to run InfluxDB on.
        public let dbInstanceType: DbInstanceType
        /// The id of the DB parameter group to assign to your DB instance. DB parameter groups specify how the database is configured. For example, DB parameter groups can specify the limit for query concurrency.
        public let dbParameterGroupIdentifier: String?
        /// The Timestream for InfluxDB DB storage type to read and write InfluxDB data. You can choose between 3 different types of provisioned Influx IOPS included storage according to your workloads requirements:   Influx IO Included 3000 IOPS   Influx IO Included 12000 IOPS   Influx IO Included 16000 IOPS
        public let dbStorageType: DbStorageType?
        /// Specifies whether the DB instance will be deployed as a standalone instance or with a Multi-AZ standby for high availability.
        public let deploymentType: DeploymentType?
        /// Configuration for sending InfluxDB engine logs to a specified S3 bucket.
        public let logDeliveryConfiguration: LogDeliveryConfiguration?
        /// The name that uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and CLI commands. This name will also be a prefix included in the endpoint. DB instance names must be unique per customer and per region.
        public let name: String
        /// The name of the initial organization for the initial admin user in InfluxDB. An InfluxDB organization is a workspace for a group of users.
        public let organization: String?
        /// The password of the initial admin user created in InfluxDB. This password will allow you to access the InfluxDB UI to perform various administrative tasks and also use the InfluxDB CLI to create an operator token. These attributes will be stored in a Secret created in AWS SecretManager in your account.
        public let password: String
        /// Configures the DB instance with a public IP to facilitate access.
        public let publiclyAccessible: Bool?
        /// A list of key-value pairs to associate with the DB instance.
        public let tags: [String: String]?
        /// The username of the initial admin user created in InfluxDB. Must start with a letter and can't end with a hyphen or contain two consecutive hyphens. For example, my-user1. This username will allow you to access the InfluxDB UI to perform various administrative tasks and also use the InfluxDB CLI to create an operator token. These attributes will be stored in a Secret created in Amazon Secrets Manager in your account.
        public let username: String?
        /// A list of VPC security group IDs to associate with the DB instance.
        public let vpcSecurityGroupIds: [String]
        /// A list of VPC subnet IDs to associate with the DB instance. Provide at least two VPC subnet IDs in different availability zones when deploying with a Multi-AZ standby.
        public let vpcSubnetIds: [String]

        public init(allocatedStorage: Int, bucket: String? = nil, dbInstanceType: DbInstanceType, dbParameterGroupIdentifier: String? = nil, dbStorageType: DbStorageType? = nil, deploymentType: DeploymentType? = nil, logDeliveryConfiguration: LogDeliveryConfiguration? = nil, name: String, organization: String? = nil, password: String, publiclyAccessible: Bool? = nil, tags: [String: String]? = nil, username: String? = nil, vpcSecurityGroupIds: [String], vpcSubnetIds: [String]) {
            self.allocatedStorage = allocatedStorage
            self.bucket = bucket
            self.dbInstanceType = dbInstanceType
            self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
            self.dbStorageType = dbStorageType
            self.deploymentType = deploymentType
            self.logDeliveryConfiguration = logDeliveryConfiguration
            self.name = name
            self.organization = organization
            self.password = password
            self.publiclyAccessible = publiclyAccessible
            self.tags = tags
            self.username = username
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }

        public func validate(name: String) throws {
            try self.validate(self.allocatedStorage, name: "allocatedStorage", parent: name, max: 16384)
            try self.validate(self.allocatedStorage, name: "allocatedStorage", parent: name, min: 20)
            try self.validate(self.bucket, name: "bucket", parent: name, max: 64)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 2)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "^[^_][^\"]*$")
            try self.validate(self.dbParameterGroupIdentifier, name: "dbParameterGroupIdentifier", parent: name, max: 64)
            try self.validate(self.dbParameterGroupIdentifier, name: "dbParameterGroupIdentifier", parent: name, min: 3)
            try self.validate(self.dbParameterGroupIdentifier, name: "dbParameterGroupIdentifier", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 40)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
            try self.validate(self.organization, name: "organization", parent: name, max: 64)
            try self.validate(self.organization, name: "organization", parent: name, min: 1)
            try self.validate(self.password, name: "password", parent: name, max: 64)
            try self.validate(self.password, name: "password", parent: name, min: 8)
            try self.validate(self.password, name: "password", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.username, name: "username", parent: name, max: 64)
            try self.validate(self.username, name: "username", parent: name, min: 1)
            try self.vpcSecurityGroupIds.forEach {
                try validate($0, name: "vpcSecurityGroupIds[]", parent: name, max: 64)
                try validate($0, name: "vpcSecurityGroupIds[]", parent: name, pattern: "^sg-[a-z0-9]+$")
            }
            try self.validate(self.vpcSecurityGroupIds, name: "vpcSecurityGroupIds", parent: name, max: 5)
            try self.validate(self.vpcSecurityGroupIds, name: "vpcSecurityGroupIds", parent: name, min: 1)
            try self.vpcSubnetIds.forEach {
                try validate($0, name: "vpcSubnetIds[]", parent: name, max: 64)
                try validate($0, name: "vpcSubnetIds[]", parent: name, pattern: "^subnet-[a-z0-9]+$")
            }
            try self.validate(self.vpcSubnetIds, name: "vpcSubnetIds", parent: name, max: 3)
            try self.validate(self.vpcSubnetIds, name: "vpcSubnetIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "allocatedStorage"
            case bucket = "bucket"
            case dbInstanceType = "dbInstanceType"
            case dbParameterGroupIdentifier = "dbParameterGroupIdentifier"
            case dbStorageType = "dbStorageType"
            case deploymentType = "deploymentType"
            case logDeliveryConfiguration = "logDeliveryConfiguration"
            case name = "name"
            case organization = "organization"
            case password = "password"
            case publiclyAccessible = "publiclyAccessible"
            case tags = "tags"
            case username = "username"
            case vpcSecurityGroupIds = "vpcSecurityGroupIds"
            case vpcSubnetIds = "vpcSubnetIds"
        }
    }

    public struct CreateDbInstanceOutput: AWSDecodableShape {
        /// The amount of storage allocated for your DB storage type (in gibibytes).
        public let allocatedStorage: Int?
        /// The Amazon Resource Name (ARN) of the DB instance.
        public let arn: String
        /// The Availability Zone in which the DB instance resides.
        public let availabilityZone: String?
        /// The Timestream for InfluxDB instance type that InfluxDB runs on.
        public let dbInstanceType: DbInstanceType?
        /// The id of the DB parameter group assigned to your DB instance.
        public let dbParameterGroupIdentifier: String?
        /// The Timestream for InfluxDB DB storage type that InfluxDB stores data on.
        public let dbStorageType: DbStorageType?
        /// Specifies whether the Timestream for InfluxDB is deployed as Single-AZ or with a MultiAZ Standby for High availability.
        public let deploymentType: DeploymentType?
        /// The endpoint used to connect to InfluxDB. The default InfluxDB port is 8086.
        public let endpoint: String?
        /// A service-generated unique identifier.
        public let id: String
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.
        public let influxAuthParametersSecretArn: String?
        /// Configuration for sending InfluxDB engine logs to send to specified S3 bucket.
        public let logDeliveryConfiguration: LogDeliveryConfiguration?
        /// The customer-supplied name that uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and CLI commands.
        public let name: String
        /// Indicates if the DB instance has a public IP to facilitate access.
        public let publiclyAccessible: Bool?
        /// The Availability Zone in which the standby instance is located when deploying with a MultiAZ standby instance.
        public let secondaryAvailabilityZone: String?
        /// The status of the DB instance.
        public let status: Status?
        /// A list of VPC security group IDs associated with the DB instance.
        public let vpcSecurityGroupIds: [String]?
        /// A list of VPC subnet IDs associated with the DB instance.
        public let vpcSubnetIds: [String]

        public init(allocatedStorage: Int? = nil, arn: String, availabilityZone: String? = nil, dbInstanceType: DbInstanceType? = nil, dbParameterGroupIdentifier: String? = nil, dbStorageType: DbStorageType? = nil, deploymentType: DeploymentType? = nil, endpoint: String? = nil, id: String, influxAuthParametersSecretArn: String? = nil, logDeliveryConfiguration: LogDeliveryConfiguration? = nil, name: String, publiclyAccessible: Bool? = nil, secondaryAvailabilityZone: String? = nil, status: Status? = nil, vpcSecurityGroupIds: [String]? = nil, vpcSubnetIds: [String]) {
            self.allocatedStorage = allocatedStorage
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.dbInstanceType = dbInstanceType
            self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
            self.dbStorageType = dbStorageType
            self.deploymentType = deploymentType
            self.endpoint = endpoint
            self.id = id
            self.influxAuthParametersSecretArn = influxAuthParametersSecretArn
            self.logDeliveryConfiguration = logDeliveryConfiguration
            self.name = name
            self.publiclyAccessible = publiclyAccessible
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.status = status
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "allocatedStorage"
            case arn = "arn"
            case availabilityZone = "availabilityZone"
            case dbInstanceType = "dbInstanceType"
            case dbParameterGroupIdentifier = "dbParameterGroupIdentifier"
            case dbStorageType = "dbStorageType"
            case deploymentType = "deploymentType"
            case endpoint = "endpoint"
            case id = "id"
            case influxAuthParametersSecretArn = "influxAuthParametersSecretArn"
            case logDeliveryConfiguration = "logDeliveryConfiguration"
            case name = "name"
            case publiclyAccessible = "publiclyAccessible"
            case secondaryAvailabilityZone = "secondaryAvailabilityZone"
            case status = "status"
            case vpcSecurityGroupIds = "vpcSecurityGroupIds"
            case vpcSubnetIds = "vpcSubnetIds"
        }
    }

    public struct CreateDbParameterGroupInput: AWSEncodableShape {
        /// A description of the DB parameter group.
        public let description: String?
        /// The name of the DB parameter group. The name must be unique per customer and per region.
        public let name: String
        /// A list of the parameters that comprise the DB parameter group.
        public let parameters: Parameters?
        /// A list of key-value pairs to associate with the DB parameter group.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, parameters: Parameters? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.parameters = parameters
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case parameters = "parameters"
            case tags = "tags"
        }
    }

    public struct CreateDbParameterGroupOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARM) of the DB parameter group.
        public let arn: String
        /// The description of the DB parameter group.
        public let description: String?
        /// A service-generated unique identifier.
        public let id: String
        /// The customer-supplied name that uniquely identifies the DB parameter group when interacting with the Amazon Timestream for InfluxDB API and CLI commands.
        public let name: String
        /// A list of the parameters that comprise the DB parameter group.
        public let parameters: Parameters?

        public init(arn: String, description: String? = nil, id: String, name: String, parameters: Parameters? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case id = "id"
            case name = "name"
            case parameters = "parameters"
        }
    }

    public struct DbInstanceSummary: AWSDecodableShape {
        /// The amount of storage to allocate for your DbStorageType in GiB (gibibytes).
        public let allocatedStorage: Int?
        /// The Amazon Resource Name (ARN) of the DB instance.
        public let arn: String
        /// The Timestream for InfluxDB instance type to run InfluxDB on.
        public let dbInstanceType: DbInstanceType?
        /// The storage type for your DB instance.
        public let dbStorageType: DbStorageType?
        /// Single-Instance or with a MultiAZ Standby for High availability.
        public let deploymentType: DeploymentType?
        /// The endpoint used to connect to InfluxDB. The default InfluxDB port is 8086.
        public let endpoint: String?
        /// The service-generated unique identifier of the DB instance.
        public let id: String
        /// This customer-supplied name uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and AWS CLI commands.
        public let name: String
        /// The status of the DB instance.
        public let status: Status?

        public init(allocatedStorage: Int? = nil, arn: String, dbInstanceType: DbInstanceType? = nil, dbStorageType: DbStorageType? = nil, deploymentType: DeploymentType? = nil, endpoint: String? = nil, id: String, name: String, status: Status? = nil) {
            self.allocatedStorage = allocatedStorage
            self.arn = arn
            self.dbInstanceType = dbInstanceType
            self.dbStorageType = dbStorageType
            self.deploymentType = deploymentType
            self.endpoint = endpoint
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "allocatedStorage"
            case arn = "arn"
            case dbInstanceType = "dbInstanceType"
            case dbStorageType = "dbStorageType"
            case deploymentType = "deploymentType"
            case endpoint = "endpoint"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct DbParameterGroupSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the DB parameter group.
        public let arn: String
        /// A description of the DB parameter group.
        public let description: String?
        /// A service-generated unique identifier.
        public let id: String
        /// This customer-supplied name uniquely identifies the parameter group.
        public let name: String

        public init(arn: String, description: String? = nil, id: String, name: String) {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case id = "id"
            case name = "name"
        }
    }

    public struct DeleteDbInstanceInput: AWSEncodableShape {
        /// The id of the DB instance.
        public let identifier: String

        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 3)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct DeleteDbInstanceOutput: AWSDecodableShape {
        /// The amount of storage allocated for your DB storage type (in gibibytes).
        public let allocatedStorage: Int?
        /// The Amazon Resource Name (ARN) of the DB instance.
        public let arn: String
        /// The Availability Zone in which the DB instance resides.
        public let availabilityZone: String?
        /// The Timestream for InfluxDB instance type that InfluxDB runs on.
        public let dbInstanceType: DbInstanceType?
        /// The id of the DB parameter group assigned to your DB instance.
        public let dbParameterGroupIdentifier: String?
        /// The Timestream for InfluxDB DB storage type that InfluxDB stores data on.
        public let dbStorageType: DbStorageType?
        /// Specifies whether the Timestream for InfluxDB is deployed as Single-AZ or with a MultiAZ Standby for High availability.
        public let deploymentType: DeploymentType?
        /// The endpoint used to connect to InfluxDB. The default InfluxDB port is 8086.
        public let endpoint: String?
        /// A service-generated unique identifier.
        public let id: String
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.
        public let influxAuthParametersSecretArn: String?
        /// Configuration for sending InfluxDB engine logs to send to specified S3 bucket.
        public let logDeliveryConfiguration: LogDeliveryConfiguration?
        /// The customer-supplied name that uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and CLI commands.
        public let name: String
        /// Indicates if the DB instance has a public IP to facilitate access.
        public let publiclyAccessible: Bool?
        /// The Availability Zone in which the standby instance is located when deploying with a MultiAZ standby instance.
        public let secondaryAvailabilityZone: String?
        /// The status of the DB instance.
        public let status: Status?
        /// A list of VPC security group IDs associated with the DB instance.
        public let vpcSecurityGroupIds: [String]?
        /// A list of VPC subnet IDs associated with the DB instance.
        public let vpcSubnetIds: [String]

        public init(allocatedStorage: Int? = nil, arn: String, availabilityZone: String? = nil, dbInstanceType: DbInstanceType? = nil, dbParameterGroupIdentifier: String? = nil, dbStorageType: DbStorageType? = nil, deploymentType: DeploymentType? = nil, endpoint: String? = nil, id: String, influxAuthParametersSecretArn: String? = nil, logDeliveryConfiguration: LogDeliveryConfiguration? = nil, name: String, publiclyAccessible: Bool? = nil, secondaryAvailabilityZone: String? = nil, status: Status? = nil, vpcSecurityGroupIds: [String]? = nil, vpcSubnetIds: [String]) {
            self.allocatedStorage = allocatedStorage
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.dbInstanceType = dbInstanceType
            self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
            self.dbStorageType = dbStorageType
            self.deploymentType = deploymentType
            self.endpoint = endpoint
            self.id = id
            self.influxAuthParametersSecretArn = influxAuthParametersSecretArn
            self.logDeliveryConfiguration = logDeliveryConfiguration
            self.name = name
            self.publiclyAccessible = publiclyAccessible
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.status = status
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "allocatedStorage"
            case arn = "arn"
            case availabilityZone = "availabilityZone"
            case dbInstanceType = "dbInstanceType"
            case dbParameterGroupIdentifier = "dbParameterGroupIdentifier"
            case dbStorageType = "dbStorageType"
            case deploymentType = "deploymentType"
            case endpoint = "endpoint"
            case id = "id"
            case influxAuthParametersSecretArn = "influxAuthParametersSecretArn"
            case logDeliveryConfiguration = "logDeliveryConfiguration"
            case name = "name"
            case publiclyAccessible = "publiclyAccessible"
            case secondaryAvailabilityZone = "secondaryAvailabilityZone"
            case status = "status"
            case vpcSecurityGroupIds = "vpcSecurityGroupIds"
            case vpcSubnetIds = "vpcSubnetIds"
        }
    }

    public struct GetDbInstanceInput: AWSEncodableShape {
        /// The id of the DB instance.
        public let identifier: String

        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 3)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct GetDbInstanceOutput: AWSDecodableShape {
        /// The amount of storage allocated for your DB storage type (in gibibytes).
        public let allocatedStorage: Int?
        /// The Amazon Resource Name (ARN) of the DB instance.
        public let arn: String
        /// The Availability Zone in which the DB instance resides.
        public let availabilityZone: String?
        /// The Timestream for InfluxDB instance type that InfluxDB runs on.
        public let dbInstanceType: DbInstanceType?
        /// The id of the DB parameter group assigned to your DB instance.
        public let dbParameterGroupIdentifier: String?
        /// The Timestream for InfluxDB DB storage type that InfluxDB stores data on.
        public let dbStorageType: DbStorageType?
        /// Specifies whether the Timestream for InfluxDB is deployed as Single-AZ or with a MultiAZ Standby for High availability.
        public let deploymentType: DeploymentType?
        /// The endpoint used to connect to InfluxDB. The default InfluxDB port is 8086.
        public let endpoint: String?
        /// A service-generated unique identifier.
        public let id: String
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.
        public let influxAuthParametersSecretArn: String?
        /// Configuration for sending InfluxDB engine logs to send to specified S3 bucket.
        public let logDeliveryConfiguration: LogDeliveryConfiguration?
        /// The customer-supplied name that uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and CLI commands.
        public let name: String
        /// Indicates if the DB instance has a public IP to facilitate access.
        public let publiclyAccessible: Bool?
        /// The Availability Zone in which the standby instance is located when deploying with a MultiAZ standby instance.
        public let secondaryAvailabilityZone: String?
        /// The status of the DB instance.
        public let status: Status?
        /// A list of VPC security group IDs associated with the DB instance.
        public let vpcSecurityGroupIds: [String]?
        /// A list of VPC subnet IDs associated with the DB instance.
        public let vpcSubnetIds: [String]

        public init(allocatedStorage: Int? = nil, arn: String, availabilityZone: String? = nil, dbInstanceType: DbInstanceType? = nil, dbParameterGroupIdentifier: String? = nil, dbStorageType: DbStorageType? = nil, deploymentType: DeploymentType? = nil, endpoint: String? = nil, id: String, influxAuthParametersSecretArn: String? = nil, logDeliveryConfiguration: LogDeliveryConfiguration? = nil, name: String, publiclyAccessible: Bool? = nil, secondaryAvailabilityZone: String? = nil, status: Status? = nil, vpcSecurityGroupIds: [String]? = nil, vpcSubnetIds: [String]) {
            self.allocatedStorage = allocatedStorage
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.dbInstanceType = dbInstanceType
            self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
            self.dbStorageType = dbStorageType
            self.deploymentType = deploymentType
            self.endpoint = endpoint
            self.id = id
            self.influxAuthParametersSecretArn = influxAuthParametersSecretArn
            self.logDeliveryConfiguration = logDeliveryConfiguration
            self.name = name
            self.publiclyAccessible = publiclyAccessible
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.status = status
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "allocatedStorage"
            case arn = "arn"
            case availabilityZone = "availabilityZone"
            case dbInstanceType = "dbInstanceType"
            case dbParameterGroupIdentifier = "dbParameterGroupIdentifier"
            case dbStorageType = "dbStorageType"
            case deploymentType = "deploymentType"
            case endpoint = "endpoint"
            case id = "id"
            case influxAuthParametersSecretArn = "influxAuthParametersSecretArn"
            case logDeliveryConfiguration = "logDeliveryConfiguration"
            case name = "name"
            case publiclyAccessible = "publiclyAccessible"
            case secondaryAvailabilityZone = "secondaryAvailabilityZone"
            case status = "status"
            case vpcSecurityGroupIds = "vpcSecurityGroupIds"
            case vpcSubnetIds = "vpcSubnetIds"
        }
    }

    public struct GetDbParameterGroupInput: AWSEncodableShape {
        /// The id of the DB parameter group.
        public let identifier: String

        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 3)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct GetDbParameterGroupOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the DB parameter group.
        public let arn: String
        /// A description of the DB parameter group.
        public let description: String?
        /// A service-generated unique identifier.
        public let id: String
        /// The customer-supplied name that uniquely identifies the DB parameter group when interacting with the Amazon Timestream for InfluxDB API and CLI commands.
        public let name: String
        /// The parameters that comprise the DB parameter group.
        public let parameters: Parameters?

        public init(arn: String, description: String? = nil, id: String, name: String, parameters: Parameters? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case id = "id"
            case name = "name"
            case parameters = "parameters"
        }
    }

    public struct InfluxDBv2Parameters: AWSEncodableShape & AWSDecodableShape {
        /// Include option to show detailed logs for Flux queries. Default: false
        public let fluxLogEnabled: Bool?
        /// Log output level. InfluxDB outputs log entries with severity levels greater than or equal to the level specified. Default: info
        public let logLevel: LogLevel?
        /// Disable the HTTP /metrics endpoint which exposes internal InfluxDB metrics. Default: false
        public let metricsDisabled: Bool?
        /// Disable the task scheduler. If problematic tasks prevent InfluxDB from starting, use this option to start InfluxDB without scheduling or executing tasks. Default: false
        public let noTasks: Bool?
        /// Number of queries allowed to execute concurrently. Setting to 0 allows an unlimited number of concurrent queries. Default: 0
        public let queryConcurrency: Int?
        /// Maximum number of queries allowed in execution queue. When queue limit is reached, new queries are rejected. Setting to 0 allows an unlimited number of queries in the queue. Default: 0
        public let queryQueueSize: Int?
        /// Enable tracing in InfluxDB and specifies the tracing type. Tracing is disabled by default.
        public let tracingType: TracingType?

        public init(fluxLogEnabled: Bool? = nil, logLevel: LogLevel? = nil, metricsDisabled: Bool? = nil, noTasks: Bool? = nil, queryConcurrency: Int? = nil, queryQueueSize: Int? = nil, tracingType: TracingType? = nil) {
            self.fluxLogEnabled = fluxLogEnabled
            self.logLevel = logLevel
            self.metricsDisabled = metricsDisabled
            self.noTasks = noTasks
            self.queryConcurrency = queryConcurrency
            self.queryQueueSize = queryQueueSize
            self.tracingType = tracingType
        }

        private enum CodingKeys: String, CodingKey {
            case fluxLogEnabled = "fluxLogEnabled"
            case logLevel = "logLevel"
            case metricsDisabled = "metricsDisabled"
            case noTasks = "noTasks"
            case queryConcurrency = "queryConcurrency"
            case queryQueueSize = "queryQueueSize"
            case tracingType = "tracingType"
        }
    }

    public struct ListDbInstancesInput: AWSEncodableShape {
        /// The maximum number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let maxResults: Int?
        /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDbInstancesOutput: AWSDecodableShape {
        /// A list of Timestream for InfluxDB DB instance summaries.
        public let items: [DbInstanceSummary]
        /// Token from a previous call of the operation. When this value is provided, the service returns results from where the previous response left off.
        public let nextToken: String?

        public init(items: [DbInstanceSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListDbParameterGroupsInput: AWSEncodableShape {
        /// The maximum number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let maxResults: Int?
        /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDbParameterGroupsOutput: AWSDecodableShape {
        /// A list of Timestream for InfluxDB DB parameter group summaries.
        public let items: [DbParameterGroupSummary]
        /// Token from a previous call of the operation. When this value is provided, the service returns results from where the previous response left off.
        public let nextToken: String?

        public init(items: [DbParameterGroupSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the tagged resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[a-z\\-]*:timestream\\-influxdb:[a-z0-9\\-]+:[0-9]{12}:(db\\-instance|db\\-parameter\\-group)/[a-zA-Z0-9]{3,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags used to categorize and track resources.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct LogDeliveryConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration for S3 bucket log delivery.
        public let s3Configuration: S3Configuration

        public init(s3Configuration: S3Configuration) {
            self.s3Configuration = s3Configuration
        }

        private enum CodingKeys: String, CodingKey {
            case s3Configuration = "s3Configuration"
        }
    }

    public struct S3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the S3 bucket to deliver logs to.
        public let bucketName: String
        /// Indicates whether log delivery to the S3 bucket is enabled.
        public let enabled: Bool

        public init(bucketName: String, enabled: Bool) {
            self.bucketName = bucketName
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case enabled = "enabled"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the tagged resource.
        public let resourceArn: String
        /// A list of tags used to categorize and track resources.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[a-z\\-]*:timestream\\-influxdb:[a-z0-9\\-]+:[0-9]{12}:(db\\-instance|db\\-parameter\\-group)/[a-zA-Z0-9]{3,64}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the tagged resource.
        public let resourceArn: String
        /// The keys used to identify the tags.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tagKeys, forKey: .tagKeys)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[a-z\\-]*:timestream\\-influxdb:[a-z0-9\\-]+:[0-9]{12}:(db\\-instance|db\\-parameter\\-group)/[a-zA-Z0-9]{3,64}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "tagKeys"
        }
    }

    public struct UpdateDbInstanceInput: AWSEncodableShape {
        /// The id of the DB parameter group to assign to your DB instance. DB parameter groups specify how the database is configured. For example, DB parameter groups can specify the limit for query concurrency.
        public let dbParameterGroupIdentifier: String?
        /// The id of the DB instance.
        public let identifier: String
        /// Configuration for sending InfluxDB engine logs to send to specified S3 bucket.
        public let logDeliveryConfiguration: LogDeliveryConfiguration?

        public init(dbParameterGroupIdentifier: String? = nil, identifier: String, logDeliveryConfiguration: LogDeliveryConfiguration? = nil) {
            self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
            self.identifier = identifier
            self.logDeliveryConfiguration = logDeliveryConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.dbParameterGroupIdentifier, name: "dbParameterGroupIdentifier", parent: name, max: 64)
            try self.validate(self.dbParameterGroupIdentifier, name: "dbParameterGroupIdentifier", parent: name, min: 3)
            try self.validate(self.dbParameterGroupIdentifier, name: "dbParameterGroupIdentifier", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 3)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupIdentifier = "dbParameterGroupIdentifier"
            case identifier = "identifier"
            case logDeliveryConfiguration = "logDeliveryConfiguration"
        }
    }

    public struct UpdateDbInstanceOutput: AWSDecodableShape {
        /// The amount of storage allocated for your DB storage type (in gibibytes).
        public let allocatedStorage: Int?
        /// The Amazon Resource Name (ARN) of the DB instance.
        public let arn: String
        /// The Availability Zone in which the DB instance resides.
        public let availabilityZone: String?
        /// The Timestream for InfluxDB instance type that InfluxDB runs on.
        public let dbInstanceType: DbInstanceType?
        /// The id of the DB parameter group assigned to your DB instance.
        public let dbParameterGroupIdentifier: String?
        /// The Timestream for InfluxDB DB storage type that InfluxDB stores data on.
        public let dbStorageType: DbStorageType?
        /// Specifies whether the Timestream for InfluxDB is deployed as Single-AZ or with a MultiAZ Standby for High availability.
        public let deploymentType: DeploymentType?
        /// The endpoint used to connect to InfluxDB. The default InfluxDB port is 8086.
        public let endpoint: String?
        /// A service-generated unique identifier.
        public let id: String
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.
        public let influxAuthParametersSecretArn: String?
        /// Configuration for sending InfluxDB engine logs to send to specified S3 bucket.
        public let logDeliveryConfiguration: LogDeliveryConfiguration?
        /// This customer-supplied name uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and AWS CLI commands.
        public let name: String
        /// Indicates if the DB instance has a public IP to facilitate access.
        public let publiclyAccessible: Bool?
        /// The Availability Zone in which the standby instance is located when deploying with a MultiAZ standby instance.
        public let secondaryAvailabilityZone: String?
        /// The status of the DB instance.
        public let status: Status?
        /// A list of VPC security group IDs associated with the DB instance.
        public let vpcSecurityGroupIds: [String]?
        /// A list of VPC subnet IDs associated with the DB instance.
        public let vpcSubnetIds: [String]

        public init(allocatedStorage: Int? = nil, arn: String, availabilityZone: String? = nil, dbInstanceType: DbInstanceType? = nil, dbParameterGroupIdentifier: String? = nil, dbStorageType: DbStorageType? = nil, deploymentType: DeploymentType? = nil, endpoint: String? = nil, id: String, influxAuthParametersSecretArn: String? = nil, logDeliveryConfiguration: LogDeliveryConfiguration? = nil, name: String, publiclyAccessible: Bool? = nil, secondaryAvailabilityZone: String? = nil, status: Status? = nil, vpcSecurityGroupIds: [String]? = nil, vpcSubnetIds: [String]) {
            self.allocatedStorage = allocatedStorage
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.dbInstanceType = dbInstanceType
            self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
            self.dbStorageType = dbStorageType
            self.deploymentType = deploymentType
            self.endpoint = endpoint
            self.id = id
            self.influxAuthParametersSecretArn = influxAuthParametersSecretArn
            self.logDeliveryConfiguration = logDeliveryConfiguration
            self.name = name
            self.publiclyAccessible = publiclyAccessible
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.status = status
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "allocatedStorage"
            case arn = "arn"
            case availabilityZone = "availabilityZone"
            case dbInstanceType = "dbInstanceType"
            case dbParameterGroupIdentifier = "dbParameterGroupIdentifier"
            case dbStorageType = "dbStorageType"
            case deploymentType = "deploymentType"
            case endpoint = "endpoint"
            case id = "id"
            case influxAuthParametersSecretArn = "influxAuthParametersSecretArn"
            case logDeliveryConfiguration = "logDeliveryConfiguration"
            case name = "name"
            case publiclyAccessible = "publiclyAccessible"
            case secondaryAvailabilityZone = "secondaryAvailabilityZone"
            case status = "status"
            case vpcSecurityGroupIds = "vpcSecurityGroupIds"
            case vpcSubnetIds = "vpcSubnetIds"
        }
    }

    public struct Parameters: AWSEncodableShape & AWSDecodableShape {
        /// All the customer-modifiable InfluxDB v2 parameters in Timestream for InfluxDB.
        public let influxDBv2: InfluxDBv2Parameters?

        public init(influxDBv2: InfluxDBv2Parameters? = nil) {
            self.influxDBv2 = influxDBv2
        }

        private enum CodingKeys: String, CodingKey {
            case influxDBv2 = "InfluxDBv2"
        }
    }
}

// MARK: - Errors

/// Error enum for TimestreamInfluxDB
public struct TimestreamInfluxDBErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize TimestreamInfluxDB
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request conflicts with an existing resource in Timestream for InfluxDB.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request processing has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested resource was not found or does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request exceeds the service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by Timestream for InfluxDB.
    public static var validationException: Self { .init(.validationException) }
}

extension TimestreamInfluxDBErrorType: Equatable {
    public static func == (lhs: TimestreamInfluxDBErrorType, rhs: TimestreamInfluxDBErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension TimestreamInfluxDBErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
