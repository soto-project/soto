//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import SotoCore

/// Error enum for Neptune
public struct NeptuneErrorType: AWSErrorType {
    enum Code: String {
        case authorizationNotFoundFault = "AuthorizationNotFound"
        case certificateNotFoundFault = "CertificateNotFound"
        case dbClusterAlreadyExistsFault = "DBClusterAlreadyExistsFault"
        case dbClusterEndpointAlreadyExistsFault = "DBClusterEndpointAlreadyExistsFault"
        case dbClusterEndpointNotFoundFault = "DBClusterEndpointNotFoundFault"
        case dbClusterEndpointQuotaExceededFault = "DBClusterEndpointQuotaExceededFault"
        case dbClusterNotFoundFault = "DBClusterNotFoundFault"
        case dbClusterParameterGroupNotFoundFault = "DBClusterParameterGroupNotFound"
        case dbClusterQuotaExceededFault = "DBClusterQuotaExceededFault"
        case dbClusterRoleAlreadyExistsFault = "DBClusterRoleAlreadyExists"
        case dbClusterRoleNotFoundFault = "DBClusterRoleNotFound"
        case dbClusterRoleQuotaExceededFault = "DBClusterRoleQuotaExceeded"
        case dbClusterSnapshotAlreadyExistsFault = "DBClusterSnapshotAlreadyExistsFault"
        case dbClusterSnapshotNotFoundFault = "DBClusterSnapshotNotFoundFault"
        case dbInstanceAlreadyExistsFault = "DBInstanceAlreadyExists"
        case dbInstanceNotFoundFault = "DBInstanceNotFound"
        case dbParameterGroupAlreadyExistsFault = "DBParameterGroupAlreadyExists"
        case dbParameterGroupNotFoundFault = "DBParameterGroupNotFound"
        case dbParameterGroupQuotaExceededFault = "DBParameterGroupQuotaExceeded"
        case dbSecurityGroupNotFoundFault = "DBSecurityGroupNotFound"
        case dbSnapshotAlreadyExistsFault = "DBSnapshotAlreadyExists"
        case dbSnapshotNotFoundFault = "DBSnapshotNotFound"
        case dbSubnetGroupAlreadyExistsFault = "DBSubnetGroupAlreadyExists"
        case dbSubnetGroupDoesNotCoverEnoughAZs = "DBSubnetGroupDoesNotCoverEnoughAZs"
        case dbSubnetGroupNotFoundFault = "DBSubnetGroupNotFoundFault"
        case dbSubnetGroupQuotaExceededFault = "DBSubnetGroupQuotaExceeded"
        case dbSubnetQuotaExceededFault = "DBSubnetQuotaExceededFault"
        case dbUpgradeDependencyFailureFault = "DBUpgradeDependencyFailure"
        case domainNotFoundFault = "DomainNotFoundFault"
        case eventSubscriptionQuotaExceededFault = "EventSubscriptionQuotaExceeded"
        case globalClusterAlreadyExistsFault = "GlobalClusterAlreadyExistsFault"
        case globalClusterNotFoundFault = "GlobalClusterNotFoundFault"
        case globalClusterQuotaExceededFault = "GlobalClusterQuotaExceededFault"
        case instanceQuotaExceededFault = "InstanceQuotaExceeded"
        case insufficientDBClusterCapacityFault = "InsufficientDBClusterCapacityFault"
        case insufficientDBInstanceCapacityFault = "InsufficientDBInstanceCapacity"
        case insufficientStorageClusterCapacityFault = "InsufficientStorageClusterCapacity"
        case invalidDBClusterEndpointStateFault = "InvalidDBClusterEndpointStateFault"
        case invalidDBClusterSnapshotStateFault = "InvalidDBClusterSnapshotStateFault"
        case invalidDBClusterStateFault = "InvalidDBClusterStateFault"
        case invalidDBInstanceStateFault = "InvalidDBInstanceState"
        case invalidDBParameterGroupStateFault = "InvalidDBParameterGroupState"
        case invalidDBSecurityGroupStateFault = "InvalidDBSecurityGroupState"
        case invalidDBSnapshotStateFault = "InvalidDBSnapshotState"
        case invalidDBSubnetGroupStateFault = "InvalidDBSubnetGroupStateFault"
        case invalidDBSubnetStateFault = "InvalidDBSubnetStateFault"
        case invalidEventSubscriptionStateFault = "InvalidEventSubscriptionState"
        case invalidGlobalClusterStateFault = "InvalidGlobalClusterStateFault"
        case invalidRestoreFault = "InvalidRestoreFault"
        case invalidSubnet = "InvalidSubnet"
        case invalidVPCNetworkStateFault = "InvalidVPCNetworkStateFault"
        case kmsKeyNotAccessibleFault = "KMSKeyNotAccessibleFault"
        case optionGroupNotFoundFault = "OptionGroupNotFoundFault"
        case provisionedIopsNotAvailableInAZFault = "ProvisionedIopsNotAvailableInAZFault"
        case resourceNotFoundFault = "ResourceNotFoundFault"
        case sharedSnapshotQuotaExceededFault = "SharedSnapshotQuotaExceeded"
        case snapshotQuotaExceededFault = "SnapshotQuotaExceeded"
        case snsInvalidTopicFault = "SNSInvalidTopic"
        case snsNoAuthorizationFault = "SNSNoAuthorization"
        case snsTopicArnNotFoundFault = "SNSTopicArnNotFound"
        case sourceNotFoundFault = "SourceNotFound"
        case storageQuotaExceededFault = "StorageQuotaExceeded"
        case storageTypeNotSupportedFault = "StorageTypeNotSupported"
        case subnetAlreadyInUse = "SubnetAlreadyInUse"
        case subscriptionAlreadyExistFault = "SubscriptionAlreadyExist"
        case subscriptionCategoryNotFoundFault = "SubscriptionCategoryNotFound"
        case subscriptionNotFoundFault = "SubscriptionNotFound"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Neptune
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Specified CIDRIP or EC2 security group is not authorized for the specified DB security group. Neptune may not also be authorized via IAM to perform necessary actions on your behalf.
    public static var authorizationNotFoundFault: Self { .init(.authorizationNotFoundFault) }
    ///  CertificateIdentifier does not refer to an existing certificate.
    public static var certificateNotFoundFault: Self { .init(.certificateNotFoundFault) }
    /// User already has a DB cluster with the given identifier.
    public static var dbClusterAlreadyExistsFault: Self { .init(.dbClusterAlreadyExistsFault) }
    /// The specified custom endpoint cannot be created because it already exists.
    public static var dbClusterEndpointAlreadyExistsFault: Self { .init(.dbClusterEndpointAlreadyExistsFault) }
    /// The specified custom endpoint doesn't exist.
    public static var dbClusterEndpointNotFoundFault: Self { .init(.dbClusterEndpointNotFoundFault) }
    /// The cluster already has the maximum number of custom endpoints.
    public static var dbClusterEndpointQuotaExceededFault: Self { .init(.dbClusterEndpointQuotaExceededFault) }
    ///  DBClusterIdentifier does not refer to an existing DB cluster.
    public static var dbClusterNotFoundFault: Self { .init(.dbClusterNotFoundFault) }
    ///  DBClusterParameterGroupName does not refer to an existing DB Cluster parameter group.
    public static var dbClusterParameterGroupNotFoundFault: Self { .init(.dbClusterParameterGroupNotFoundFault) }
    /// User attempted to create a new DB cluster and the user has already reached the maximum allowed DB cluster quota.
    public static var dbClusterQuotaExceededFault: Self { .init(.dbClusterQuotaExceededFault) }
    /// The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.
    public static var dbClusterRoleAlreadyExistsFault: Self { .init(.dbClusterRoleAlreadyExistsFault) }
    /// The specified IAM role Amazon Resource Name (ARN) is not associated with the specified DB cluster.
    public static var dbClusterRoleNotFoundFault: Self { .init(.dbClusterRoleNotFoundFault) }
    /// You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.
    public static var dbClusterRoleQuotaExceededFault: Self { .init(.dbClusterRoleQuotaExceededFault) }
    /// User already has a DB cluster snapshot with the given identifier.
    public static var dbClusterSnapshotAlreadyExistsFault: Self { .init(.dbClusterSnapshotAlreadyExistsFault) }
    ///  DBClusterSnapshotIdentifier does not refer to an existing DB cluster snapshot.
    public static var dbClusterSnapshotNotFoundFault: Self { .init(.dbClusterSnapshotNotFoundFault) }
    /// User already has a DB instance with the given identifier.
    public static var dbInstanceAlreadyExistsFault: Self { .init(.dbInstanceAlreadyExistsFault) }
    ///  DBInstanceIdentifier does not refer to an existing DB instance.
    public static var dbInstanceNotFoundFault: Self { .init(.dbInstanceNotFoundFault) }
    /// A DB parameter group with the same name exists.
    public static var dbParameterGroupAlreadyExistsFault: Self { .init(.dbParameterGroupAlreadyExistsFault) }
    ///  DBParameterGroupName does not refer to an existing DB parameter group.
    public static var dbParameterGroupNotFoundFault: Self { .init(.dbParameterGroupNotFoundFault) }
    /// Request would result in user exceeding the allowed number of DB parameter groups.
    public static var dbParameterGroupQuotaExceededFault: Self { .init(.dbParameterGroupQuotaExceededFault) }
    ///  DBSecurityGroupName does not refer to an existing DB security group.
    public static var dbSecurityGroupNotFoundFault: Self { .init(.dbSecurityGroupNotFoundFault) }
    ///  DBSnapshotIdentifier is already used by an existing snapshot.
    public static var dbSnapshotAlreadyExistsFault: Self { .init(.dbSnapshotAlreadyExistsFault) }
    ///  DBSnapshotIdentifier does not refer to an existing DB snapshot.
    public static var dbSnapshotNotFoundFault: Self { .init(.dbSnapshotNotFoundFault) }
    ///  DBSubnetGroupName is already used by an existing DB subnet group.
    public static var dbSubnetGroupAlreadyExistsFault: Self { .init(.dbSubnetGroupAlreadyExistsFault) }
    /// Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.
    public static var dbSubnetGroupDoesNotCoverEnoughAZs: Self { .init(.dbSubnetGroupDoesNotCoverEnoughAZs) }
    ///  DBSubnetGroupName does not refer to an existing DB subnet group.
    public static var dbSubnetGroupNotFoundFault: Self { .init(.dbSubnetGroupNotFoundFault) }
    /// Request would result in user exceeding the allowed number of DB subnet groups.
    public static var dbSubnetGroupQuotaExceededFault: Self { .init(.dbSubnetGroupQuotaExceededFault) }
    /// Request would result in user exceeding the allowed number of subnets in a DB subnet groups.
    public static var dbSubnetQuotaExceededFault: Self { .init(.dbSubnetQuotaExceededFault) }
    /// The DB upgrade failed because a resource the DB depends on could not be modified.
    public static var dbUpgradeDependencyFailureFault: Self { .init(.dbUpgradeDependencyFailureFault) }
    ///  Domain does not refer to an existing Active Directory Domain.
    public static var domainNotFoundFault: Self { .init(.domainNotFoundFault) }
    /// You have exceeded the number of events you can subscribe to.
    public static var eventSubscriptionQuotaExceededFault: Self { .init(.eventSubscriptionQuotaExceededFault) }
    /// The GlobalClusterIdentifier already exists. Choose a new global database identifier (unique name) to create a new global database cluster.
    public static var globalClusterAlreadyExistsFault: Self { .init(.globalClusterAlreadyExistsFault) }
    /// The GlobalClusterIdentifier doesn't refer to an existing global database cluster.
    public static var globalClusterNotFoundFault: Self { .init(.globalClusterNotFoundFault) }
    /// The number of global database clusters for this account is already at the maximum allowed.
    public static var globalClusterQuotaExceededFault: Self { .init(.globalClusterQuotaExceededFault) }
    /// Request would result in user exceeding the allowed number of DB instances.
    public static var instanceQuotaExceededFault: Self { .init(.instanceQuotaExceededFault) }
    /// The DB cluster does not have enough capacity for the current operation.
    public static var insufficientDBClusterCapacityFault: Self { .init(.insufficientDBClusterCapacityFault) }
    /// Specified DB instance class is not available in the specified Availability Zone.
    public static var insufficientDBInstanceCapacityFault: Self { .init(.insufficientDBInstanceCapacityFault) }
    /// There is insufficient storage available for the current action. You may be able to resolve this error by updating your subnet group to use different Availability Zones that have more storage available.
    public static var insufficientStorageClusterCapacityFault: Self { .init(.insufficientStorageClusterCapacityFault) }
    /// The requested operation cannot be performed on the endpoint while the endpoint is in this state.
    public static var invalidDBClusterEndpointStateFault: Self { .init(.invalidDBClusterEndpointStateFault) }
    /// The supplied value is not a valid DB cluster snapshot state.
    public static var invalidDBClusterSnapshotStateFault: Self { .init(.invalidDBClusterSnapshotStateFault) }
    /// The DB cluster is not in a valid state.
    public static var invalidDBClusterStateFault: Self { .init(.invalidDBClusterStateFault) }
    /// The specified DB instance is not in the available state.
    public static var invalidDBInstanceStateFault: Self { .init(.invalidDBInstanceStateFault) }
    /// The DB parameter group is in use or is in an invalid state. If you are attempting to delete the parameter group, you cannot delete it when the parameter group is in this state.
    public static var invalidDBParameterGroupStateFault: Self { .init(.invalidDBParameterGroupStateFault) }
    /// The state of the DB security group does not allow deletion.
    public static var invalidDBSecurityGroupStateFault: Self { .init(.invalidDBSecurityGroupStateFault) }
    /// The state of the DB snapshot does not allow deletion.
    public static var invalidDBSnapshotStateFault: Self { .init(.invalidDBSnapshotStateFault) }
    /// The DB subnet group cannot be deleted because it is in use.
    public static var invalidDBSubnetGroupStateFault: Self { .init(.invalidDBSubnetGroupStateFault) }
    /// The DB subnet is not in the available state.
    public static var invalidDBSubnetStateFault: Self { .init(.invalidDBSubnetStateFault) }
    /// The event subscription is in an invalid state.
    public static var invalidEventSubscriptionStateFault: Self { .init(.invalidEventSubscriptionStateFault) }
    /// The global cluster is in an invalid state and can't perform the requested operation.
    public static var invalidGlobalClusterStateFault: Self { .init(.invalidGlobalClusterStateFault) }
    /// Cannot restore from vpc backup to non-vpc DB instance.
    public static var invalidRestoreFault: Self { .init(.invalidRestoreFault) }
    /// The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.
    public static var invalidSubnet: Self { .init(.invalidSubnet) }
    /// DB subnet group does not cover all Availability Zones after it is created because users' change.
    public static var invalidVPCNetworkStateFault: Self { .init(.invalidVPCNetworkStateFault) }
    /// Error accessing KMS key.
    public static var kmsKeyNotAccessibleFault: Self { .init(.kmsKeyNotAccessibleFault) }
    /// The designated option group could not be found.
    public static var optionGroupNotFoundFault: Self { .init(.optionGroupNotFoundFault) }
    /// Provisioned IOPS not available in the specified Availability Zone.
    public static var provisionedIopsNotAvailableInAZFault: Self { .init(.provisionedIopsNotAvailableInAZFault) }
    /// The specified resource ID was not found.
    public static var resourceNotFoundFault: Self { .init(.resourceNotFoundFault) }
    /// You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.
    public static var sharedSnapshotQuotaExceededFault: Self { .init(.sharedSnapshotQuotaExceededFault) }
    /// Request would result in user exceeding the allowed number of DB snapshots.
    public static var snapshotQuotaExceededFault: Self { .init(.snapshotQuotaExceededFault) }
    /// The SNS topic is invalid.
    public static var snsInvalidTopicFault: Self { .init(.snsInvalidTopicFault) }
    /// There is no SNS authorization.
    public static var snsNoAuthorizationFault: Self { .init(.snsNoAuthorizationFault) }
    /// The ARN of the SNS topic could not be found.
    public static var snsTopicArnNotFoundFault: Self { .init(.snsTopicArnNotFoundFault) }
    /// The source could not be found.
    public static var sourceNotFoundFault: Self { .init(.sourceNotFoundFault) }
    /// Request would result in user exceeding the allowed amount of storage available across all DB instances.
    public static var storageQuotaExceededFault: Self { .init(.storageQuotaExceededFault) }
    ///  StorageType specified cannot be associated with the DB Instance.
    public static var storageTypeNotSupportedFault: Self { .init(.storageTypeNotSupportedFault) }
    /// The DB subnet is already in use in the Availability Zone.
    public static var subnetAlreadyInUse: Self { .init(.subnetAlreadyInUse) }
    /// This subscription already exists.
    public static var subscriptionAlreadyExistFault: Self { .init(.subscriptionAlreadyExistFault) }
    /// The designated subscription category could not be found.
    public static var subscriptionCategoryNotFoundFault: Self { .init(.subscriptionCategoryNotFoundFault) }
    /// The designated subscription could not be found.
    public static var subscriptionNotFoundFault: Self { .init(.subscriptionNotFoundFault) }
}

extension NeptuneErrorType: Equatable {
    public static func == (lhs: NeptuneErrorType, rhs: NeptuneErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension NeptuneErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
