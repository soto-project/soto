//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IoTThingsGraph {
    // MARK: Enums

    public enum DefinitionLanguage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case graphql = "GRAPHQL"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentTarget: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloud = "CLOUD"
        case greengrass = "GREENGRASS"
        public var description: String { return self.rawValue }
    }

    public enum EntityFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        case namespace = "NAMESPACE"
        case referencedEntityId = "REFERENCED_ENTITY_ID"
        case semanticTypePath = "SEMANTIC_TYPE_PATH"
        public var description: String { return self.rawValue }
    }

    public enum EntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `enum` = "ENUM"
        case action = "ACTION"
        case capability = "CAPABILITY"
        case device = "DEVICE"
        case deviceModel = "DEVICE_MODEL"
        case event = "EVENT"
        case mapping = "MAPPING"
        case property = "PROPERTY"
        case service = "SERVICE"
        case state = "STATE"
        public var description: String { return self.rawValue }
    }

    public enum FlowExecutionEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case acknowledgeTaskMessage = "ACKNOWLEDGE_TASK_MESSAGE"
        case activityFailed = "ACTIVITY_FAILED"
        case activityScheduled = "ACTIVITY_SCHEDULED"
        case activityStarted = "ACTIVITY_STARTED"
        case activitySucceeded = "ACTIVITY_SUCCEEDED"
        case executionAborted = "EXECUTION_ABORTED"
        case executionFailed = "EXECUTION_FAILED"
        case executionStarted = "EXECUTION_STARTED"
        case executionSucceeded = "EXECUTION_SUCCEEDED"
        case scheduleNextReadyStepsTask = "SCHEDULE_NEXT_READY_STEPS_TASK"
        case startFlowExecutionTask = "START_FLOW_EXECUTION_TASK"
        case stepFailed = "STEP_FAILED"
        case stepStarted = "STEP_STARTED"
        case stepSucceeded = "STEP_SUCCEEDED"
        case thingActionTask = "THING_ACTION_TASK"
        case thingActionTaskFailed = "THING_ACTION_TASK_FAILED"
        case thingActionTaskSucceeded = "THING_ACTION_TASK_SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum FlowExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aborted = "ABORTED"
        case failed = "FAILED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum FlowTemplateFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deviceModelId = "DEVICE_MODEL_ID"
        public var description: String { return self.rawValue }
    }

    public enum NamespaceDeletionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum NamespaceDeletionStatusErrorCodes: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case validationFailed = "VALIDATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum SystemInstanceDeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bootstrap = "BOOTSTRAP"
        case deletedInTarget = "DELETED_IN_TARGET"
        case deployInProgress = "DEPLOY_IN_PROGRESS"
        case deployedInTarget = "DEPLOYED_IN_TARGET"
        case failed = "FAILED"
        case notDeployed = "NOT_DEPLOYED"
        case pendingDelete = "PENDING_DELETE"
        case undeployInProgress = "UNDEPLOY_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum SystemInstanceFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case greengrassGroupName = "GREENGRASS_GROUP_NAME"
        case status = "STATUS"
        case systemTemplateId = "SYSTEM_TEMPLATE_ID"
        public var description: String { return self.rawValue }
    }

    public enum SystemTemplateFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case flowTemplateId = "FLOW_TEMPLATE_ID"
        public var description: String { return self.rawValue }
    }

    public enum UploadStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateEntityToThingRequest: AWSEncodableShape {
        /// The ID of the device to be associated with the thing. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
        public let entityId: String
        /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
        public let namespaceVersion: Int64?
        /// The name of the thing to which the entity is to be associated.
        public let thingName: String

        @inlinable
        public init(entityId: String, namespaceVersion: Int64? = nil, thingName: String) {
            self.entityId = entityId
            self.namespaceVersion = namespaceVersion
            self.thingName = thingName
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 160)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
            try self.validate(self.thingName, name: "thingName", parent: name, max: 128)
            try self.validate(self.thingName, name: "thingName", parent: name, min: 1)
            try self.validate(self.thingName, name: "thingName", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "entityId"
            case namespaceVersion = "namespaceVersion"
            case thingName = "thingName"
        }
    }

    public struct AssociateEntityToThingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateFlowTemplateRequest: AWSEncodableShape {
        /// The namespace version in which the workflow is to be created. If no value is specified, the latest version is used by default.
        public let compatibleNamespaceVersion: Int64?
        /// The workflow DefinitionDocument.
        public let definition: DefinitionDocument

        @inlinable
        public init(compatibleNamespaceVersion: Int64? = nil, definition: DefinitionDocument) {
            self.compatibleNamespaceVersion = compatibleNamespaceVersion
            self.definition = definition
        }

        public func validate(name: String) throws {
            try self.definition.validate(name: "\(name).definition")
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleNamespaceVersion = "compatibleNamespaceVersion"
            case definition = "definition"
        }
    }

    public struct CreateFlowTemplateResponse: AWSDecodableShape {
        /// The summary object that describes the created workflow.
        public let summary: FlowTemplateSummary?

        @inlinable
        public init(summary: FlowTemplateSummary? = nil) {
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case summary = "summary"
        }
    }

    public struct CreateSystemInstanceRequest: AWSEncodableShape {
        public let definition: DefinitionDocument
        /// The ARN of the IAM role that AWS IoT Things Graph will assume when it executes the flow. This role must have  read and write access to AWS Lambda and AWS IoT and any other AWS services that the flow uses when it executes.  This  value is required if the value of the target parameter is CLOUD.
        public let flowActionsRoleArn: String?
        /// The name of the Greengrass group where the system instance will be deployed. This value is required if  the value of the target parameter is GREENGRASS.
        public let greengrassGroupName: String?
        public let metricsConfiguration: MetricsConfiguration?
        /// The name of the Amazon Simple Storage Service bucket that will be used to store and deploy the system instance's resource file. This value is required if  the value of the target parameter is GREENGRASS.
        public let s3BucketName: String?
        /// Metadata, consisting of key-value pairs, that can be used to categorize your system instances.
        public let tags: [Tag]?
        /// The target type of the deployment. Valid values are GREENGRASS and CLOUD.
        public let target: DeploymentTarget

        @inlinable
        public init(definition: DefinitionDocument, flowActionsRoleArn: String? = nil, greengrassGroupName: String? = nil, metricsConfiguration: MetricsConfiguration? = nil, s3BucketName: String? = nil, tags: [Tag]? = nil, target: DeploymentTarget) {
            self.definition = definition
            self.flowActionsRoleArn = flowActionsRoleArn
            self.greengrassGroupName = greengrassGroupName
            self.metricsConfiguration = metricsConfiguration
            self.s3BucketName = s3BucketName
            self.tags = tags
            self.target = target
        }

        public func validate(name: String) throws {
            try self.definition.validate(name: "\(name).definition")
            try self.validate(self.flowActionsRoleArn, name: "flowActionsRoleArn", parent: name, max: 2048)
            try self.validate(self.flowActionsRoleArn, name: "flowActionsRoleArn", parent: name, min: 20)
            try self.metricsConfiguration?.validate(name: "\(name).metricsConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case flowActionsRoleArn = "flowActionsRoleArn"
            case greengrassGroupName = "greengrassGroupName"
            case metricsConfiguration = "metricsConfiguration"
            case s3BucketName = "s3BucketName"
            case tags = "tags"
            case target = "target"
        }
    }

    public struct CreateSystemInstanceResponse: AWSDecodableShape {
        /// The summary object that describes the new system instance.
        public let summary: SystemInstanceSummary?

        @inlinable
        public init(summary: SystemInstanceSummary? = nil) {
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case summary = "summary"
        }
    }

    public struct CreateSystemTemplateRequest: AWSEncodableShape {
        /// The namespace version in which the system is to be created. If no value is specified, the latest version is used by default.
        public let compatibleNamespaceVersion: Int64?
        /// The DefinitionDocument used to create the system.
        public let definition: DefinitionDocument

        @inlinable
        public init(compatibleNamespaceVersion: Int64? = nil, definition: DefinitionDocument) {
            self.compatibleNamespaceVersion = compatibleNamespaceVersion
            self.definition = definition
        }

        public func validate(name: String) throws {
            try self.definition.validate(name: "\(name).definition")
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleNamespaceVersion = "compatibleNamespaceVersion"
            case definition = "definition"
        }
    }

    public struct CreateSystemTemplateResponse: AWSDecodableShape {
        /// The summary object that describes the created system.
        public let summary: SystemTemplateSummary?

        @inlinable
        public init(summary: SystemTemplateSummary? = nil) {
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case summary = "summary"
        }
    }

    public struct DefinitionDocument: AWSEncodableShape & AWSDecodableShape {
        /// The language used to define the entity. GRAPHQL is the only valid value.
        public let language: DefinitionLanguage
        /// The GraphQL text that defines the entity.
        public let text: String

        @inlinable
        public init(language: DefinitionLanguage, text: String) {
            self.language = language
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 1048576)
        }

        private enum CodingKeys: String, CodingKey {
            case language = "language"
            case text = "text"
        }
    }

    public struct DeleteFlowTemplateRequest: AWSEncodableShape {
        /// The ID of the workflow to be deleted. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteFlowTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteNamespaceRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteNamespaceResponse: AWSDecodableShape {
        /// The ARN of the namespace to be deleted.
        public let namespaceArn: String?
        /// The name of the namespace to be deleted.
        public let namespaceName: String?

        @inlinable
        public init(namespaceArn: String? = nil, namespaceName: String? = nil) {
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceArn = "namespaceArn"
            case namespaceName = "namespaceName"
        }
    }

    public struct DeleteSystemInstanceRequest: AWSEncodableShape {
        /// The ID of the system instance to be deleted.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteSystemInstanceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSystemTemplateRequest: AWSEncodableShape {
        /// The ID of the system to be deleted. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteSystemTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DependencyRevision: AWSDecodableShape {
        /// The ID of the workflow or system.
        public let id: String?
        /// The revision number of the workflow or system.
        public let revisionNumber: Int64?

        @inlinable
        public init(id: String? = nil, revisionNumber: Int64? = nil) {
            self.id = id
            self.revisionNumber = revisionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case revisionNumber = "revisionNumber"
        }
    }

    public struct DeploySystemInstanceRequest: AWSEncodableShape {
        /// The ID of the system instance. This value is returned by the CreateSystemInstance action. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:deployment:DEPLOYMENTNAME
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeploySystemInstanceResponse: AWSDecodableShape {
        /// The ID of the Greengrass deployment used to deploy the system instance.
        public let greengrassDeploymentId: String?
        /// An object that contains summary information about a system instance that was deployed.
        public let summary: SystemInstanceSummary

        @inlinable
        public init(greengrassDeploymentId: String? = nil, summary: SystemInstanceSummary) {
            self.greengrassDeploymentId = greengrassDeploymentId
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case greengrassDeploymentId = "greengrassDeploymentId"
            case summary = "summary"
        }
    }

    public struct DeprecateFlowTemplateRequest: AWSEncodableShape {
        /// The ID of the workflow to be deleted. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeprecateFlowTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeprecateSystemTemplateRequest: AWSEncodableShape {
        /// The ID of the system to delete. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeprecateSystemTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeNamespaceRequest: AWSEncodableShape {
        /// The name of the user's namespace. Set this to aws to get the public namespace.
        public let namespaceName: String?

        @inlinable
        public init(namespaceName: String? = nil) {
            self.namespaceName = namespaceName
        }

        public func validate(name: String) throws {
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceName = "namespaceName"
        }
    }

    public struct DescribeNamespaceResponse: AWSDecodableShape {
        /// The ARN of the namespace.
        public let namespaceArn: String?
        /// The name of the namespace.
        public let namespaceName: String?
        /// The version of the user's namespace to describe.
        public let namespaceVersion: Int64?
        /// The name of the public namespace that the latest namespace version is tracking.
        public let trackingNamespaceName: String?
        /// The version of the public namespace that the latest version is tracking.
        public let trackingNamespaceVersion: Int64?

        @inlinable
        public init(namespaceArn: String? = nil, namespaceName: String? = nil, namespaceVersion: Int64? = nil, trackingNamespaceName: String? = nil, trackingNamespaceVersion: Int64? = nil) {
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.namespaceVersion = namespaceVersion
            self.trackingNamespaceName = trackingNamespaceName
            self.trackingNamespaceVersion = trackingNamespaceVersion
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceArn = "namespaceArn"
            case namespaceName = "namespaceName"
            case namespaceVersion = "namespaceVersion"
            case trackingNamespaceName = "trackingNamespaceName"
            case trackingNamespaceVersion = "trackingNamespaceVersion"
        }
    }

    public struct DissociateEntityFromThingRequest: AWSEncodableShape {
        /// The entity type from which to disassociate the thing.
        public let entityType: EntityType
        /// The name of the thing to disassociate.
        public let thingName: String

        @inlinable
        public init(entityType: EntityType, thingName: String) {
            self.entityType = entityType
            self.thingName = thingName
        }

        public func validate(name: String) throws {
            try self.validate(self.thingName, name: "thingName", parent: name, max: 128)
            try self.validate(self.thingName, name: "thingName", parent: name, min: 1)
            try self.validate(self.thingName, name: "thingName", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityType = "entityType"
            case thingName = "thingName"
        }
    }

    public struct DissociateEntityFromThingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EntityDescription: AWSDecodableShape {
        /// The entity ARN.
        public let arn: String?
        /// The time at which the entity was created.
        public let createdAt: Date?
        /// The definition document of the entity.
        public let definition: DefinitionDocument?
        /// The entity ID.
        public let id: String?
        /// The entity type.
        public let type: EntityType?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, definition: DefinitionDocument? = nil, id: String? = nil, type: EntityType? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.definition = definition
            self.id = id
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case definition = "definition"
            case id = "id"
            case type = "type"
        }
    }

    public struct EntityFilter: AWSEncodableShape {
        /// The name of the entity search filter field. REFERENCED_ENTITY_ID filters on entities that are used by the entity in the result set. For example,  you can filter on the ID of a property that is used in a state.
        public let name: EntityFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        public let value: [String]?

        @inlinable
        public init(name: EntityFilterName? = nil, value: [String]? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct FlowExecutionMessage: AWSDecodableShape {
        /// The type of flow event .
        public let eventType: FlowExecutionEventType?
        /// The unique identifier of the message.
        public let messageId: String?
        /// A string containing information about the flow event.
        public let payload: String?
        /// The date and time when the message was last updated.
        public let timestamp: Date?

        @inlinable
        public init(eventType: FlowExecutionEventType? = nil, messageId: String? = nil, payload: String? = nil, timestamp: Date? = nil) {
            self.eventType = eventType
            self.messageId = messageId
            self.payload = payload
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case eventType = "eventType"
            case messageId = "messageId"
            case payload = "payload"
            case timestamp = "timestamp"
        }
    }

    public struct FlowExecutionSummary: AWSDecodableShape {
        /// The date and time when the flow execution summary was created.
        public let createdAt: Date?
        /// The ID of the flow execution.
        public let flowExecutionId: String?
        /// The ID of the flow.
        public let flowTemplateId: String?
        /// The current status of the flow execution.
        public let status: FlowExecutionStatus?
        /// The ID of the system instance that contains the flow.
        public let systemInstanceId: String?
        /// The date and time when the flow execution summary was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, flowExecutionId: String? = nil, flowTemplateId: String? = nil, status: FlowExecutionStatus? = nil, systemInstanceId: String? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.flowExecutionId = flowExecutionId
            self.flowTemplateId = flowTemplateId
            self.status = status
            self.systemInstanceId = systemInstanceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case flowExecutionId = "flowExecutionId"
            case flowTemplateId = "flowTemplateId"
            case status = "status"
            case systemInstanceId = "systemInstanceId"
            case updatedAt = "updatedAt"
        }
    }

    public struct FlowTemplateDescription: AWSDecodableShape {
        /// A workflow's definition document.
        public let definition: DefinitionDocument?
        /// An object that contains summary information about a workflow.
        public let summary: FlowTemplateSummary?
        /// The version of the user's namespace against which the workflow was validated. Use this value in your system instance.
        public let validatedNamespaceVersion: Int64?

        @inlinable
        public init(definition: DefinitionDocument? = nil, summary: FlowTemplateSummary? = nil, validatedNamespaceVersion: Int64? = nil) {
            self.definition = definition
            self.summary = summary
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case summary = "summary"
            case validatedNamespaceVersion = "validatedNamespaceVersion"
        }
    }

    public struct FlowTemplateFilter: AWSEncodableShape {
        /// The name of the search filter field.
        public let name: FlowTemplateFilterName
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        public let value: [String]

        @inlinable
        public init(name: FlowTemplateFilterName, value: [String]) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.value.forEach {
                try validate($0, name: "value[]", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct FlowTemplateSummary: AWSDecodableShape {
        /// The ARN of the workflow.
        public let arn: String?
        /// The date when the workflow was created.
        public let createdAt: Date?
        /// The ID of the workflow.
        public let id: String?
        /// The revision number of the workflow.
        public let revisionNumber: Int64?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, revisionNumber: Int64? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.revisionNumber = revisionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case revisionNumber = "revisionNumber"
        }
    }

    public struct GetEntitiesRequest: AWSEncodableShape {
        /// An array of entity IDs. The IDs should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
        public let ids: [String]
        /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
        public let namespaceVersion: Int64?

        @inlinable
        public init(ids: [String], namespaceVersion: Int64? = nil) {
            self.ids = ids
            self.namespaceVersion = namespaceVersion
        }

        public func validate(name: String) throws {
            try self.ids.forEach {
                try validate($0, name: "ids[]", parent: name, max: 160)
                try validate($0, name: "ids[]", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
            }
            try self.validate(self.ids, name: "ids", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case ids = "ids"
            case namespaceVersion = "namespaceVersion"
        }
    }

    public struct GetEntitiesResponse: AWSDecodableShape {
        /// An array of descriptions for the specified entities.
        public let descriptions: [EntityDescription]?

        @inlinable
        public init(descriptions: [EntityDescription]? = nil) {
            self.descriptions = descriptions
        }

        private enum CodingKeys: String, CodingKey {
            case descriptions = "descriptions"
        }
    }

    public struct GetFlowTemplateRequest: AWSEncodableShape {
        /// The ID of the workflow. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
        public let id: String
        /// The number of the workflow revision to retrieve.
        public let revisionNumber: Int64?

        @inlinable
        public init(id: String, revisionNumber: Int64? = nil) {
            self.id = id
            self.revisionNumber = revisionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case revisionNumber = "revisionNumber"
        }
    }

    public struct GetFlowTemplateResponse: AWSDecodableShape {
        /// The object that describes the specified workflow.
        public let description: FlowTemplateDescription?

        @inlinable
        public init(description: FlowTemplateDescription? = nil) {
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct GetFlowTemplateRevisionsRequest: AWSEncodableShape {
        /// The ID of the workflow. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
        public let id: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The string that specifies the next page of results. Use this when you're paginating results.
        public let nextToken: String?

        @inlinable
        public init(id: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.id = id
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetFlowTemplateRevisionsResponse: AWSDecodableShape {
        /// The string to specify as nextToken when you request the next page of results.
        public let nextToken: String?
        /// An array of objects that provide summary data about each revision.
        public let summaries: [FlowTemplateSummary]?

        @inlinable
        public init(nextToken: String? = nil, summaries: [FlowTemplateSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct GetNamespaceDeletionStatusRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetNamespaceDeletionStatusResponse: AWSDecodableShape {
        /// An error code returned by the namespace deletion task.
        public let errorCode: NamespaceDeletionStatusErrorCodes?
        /// An error code returned by the namespace deletion task.
        public let errorMessage: String?
        /// The ARN of the namespace that is being deleted.
        public let namespaceArn: String?
        /// The name of the namespace that is being deleted.
        public let namespaceName: String?
        /// The status of the deletion request.
        public let status: NamespaceDeletionStatus?

        @inlinable
        public init(errorCode: NamespaceDeletionStatusErrorCodes? = nil, errorMessage: String? = nil, namespaceArn: String? = nil, namespaceName: String? = nil, status: NamespaceDeletionStatus? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case namespaceArn = "namespaceArn"
            case namespaceName = "namespaceName"
            case status = "status"
        }
    }

    public struct GetSystemInstanceRequest: AWSEncodableShape {
        /// The ID of the system deployment instance. This value is returned by CreateSystemInstance. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:deployment:DEPLOYMENTNAME
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct GetSystemInstanceResponse: AWSDecodableShape {
        /// An object that describes the system instance.
        public let description: SystemInstanceDescription?

        @inlinable
        public init(description: SystemInstanceDescription? = nil) {
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct GetSystemTemplateRequest: AWSEncodableShape {
        /// The ID of the system to get. This ID must be in the user's namespace. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
        public let id: String
        /// The number that specifies the revision of the system to get.
        public let revisionNumber: Int64?

        @inlinable
        public init(id: String, revisionNumber: Int64? = nil) {
            self.id = id
            self.revisionNumber = revisionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case revisionNumber = "revisionNumber"
        }
    }

    public struct GetSystemTemplateResponse: AWSDecodableShape {
        /// An object that contains summary data about the system.
        public let description: SystemTemplateDescription?

        @inlinable
        public init(description: SystemTemplateDescription? = nil) {
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct GetSystemTemplateRevisionsRequest: AWSEncodableShape {
        /// The ID of the system template. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
        public let id: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The string that specifies the next page of results. Use this when you're paginating results.
        public let nextToken: String?

        @inlinable
        public init(id: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.id = id
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetSystemTemplateRevisionsResponse: AWSDecodableShape {
        /// The string to specify as nextToken when you request the next page of results.
        public let nextToken: String?
        /// An array of objects that contain summary data about the system template revisions.
        public let summaries: [SystemTemplateSummary]?

        @inlinable
        public init(nextToken: String? = nil, summaries: [SystemTemplateSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct GetUploadStatusRequest: AWSEncodableShape {
        /// The ID of the upload. This value is returned by the UploadEntityDefinitions action.
        public let uploadId: String

        @inlinable
        public init(uploadId: String) {
            self.uploadId = uploadId
        }

        public func validate(name: String) throws {
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 40)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case uploadId = "uploadId"
        }
    }

    public struct GetUploadStatusResponse: AWSDecodableShape {
        /// The date at which the upload was created.
        public let createdDate: Date
        /// The reason for an upload failure.
        public let failureReason: [String]?
        /// The ARN of the upload.
        public let namespaceArn: String?
        /// The name of the upload's namespace.
        public let namespaceName: String?
        /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
        public let namespaceVersion: Int64?
        /// The ID of the upload.
        public let uploadId: String
        /// The status of the upload. The initial status is IN_PROGRESS. The response show all validation failures if the upload fails.
        public let uploadStatus: UploadStatus

        @inlinable
        public init(createdDate: Date, failureReason: [String]? = nil, namespaceArn: String? = nil, namespaceName: String? = nil, namespaceVersion: Int64? = nil, uploadId: String, uploadStatus: UploadStatus) {
            self.createdDate = createdDate
            self.failureReason = failureReason
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.namespaceVersion = namespaceVersion
            self.uploadId = uploadId
            self.uploadStatus = uploadStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case failureReason = "failureReason"
            case namespaceArn = "namespaceArn"
            case namespaceName = "namespaceName"
            case namespaceVersion = "namespaceVersion"
            case uploadId = "uploadId"
            case uploadStatus = "uploadStatus"
        }
    }

    public struct ListFlowExecutionMessagesRequest: AWSEncodableShape {
        /// The ID of the flow execution.
        public let flowExecutionId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The string that specifies the next page of results. Use this when you're paginating results.
        public let nextToken: String?

        @inlinable
        public init(flowExecutionId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.flowExecutionId = flowExecutionId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case flowExecutionId = "flowExecutionId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListFlowExecutionMessagesResponse: AWSDecodableShape {
        /// A list of objects that contain information about events in the specified flow execution.
        public let messages: [FlowExecutionMessage]?
        /// The string to specify as nextToken when you request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(messages: [FlowExecutionMessage]? = nil, nextToken: String? = nil) {
            self.messages = messages
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case messages = "messages"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The maximum number of tags to return.
        public let maxResults: Int?
        /// The token that specifies the next page of results to return.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the resource whose tags are to be returned.
        public let resourceArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The token that specifies the next page of results to return.
        public let nextToken: String?
        /// List of tags returned by the ListTagsForResource operation.
        public let tags: [Tag]?

        @inlinable
        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tags = "tags"
        }
    }

    public struct MetricsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean that specifies whether cloud metrics are collected.
        public let cloudMetricEnabled: Bool?
        /// The ARN of the role that is used to collect cloud metrics.
        public let metricRuleRoleArn: String?

        @inlinable
        public init(cloudMetricEnabled: Bool? = nil, metricRuleRoleArn: String? = nil) {
            self.cloudMetricEnabled = cloudMetricEnabled
            self.metricRuleRoleArn = metricRuleRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.metricRuleRoleArn, name: "metricRuleRoleArn", parent: name, max: 2048)
            try self.validate(self.metricRuleRoleArn, name: "metricRuleRoleArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case cloudMetricEnabled = "cloudMetricEnabled"
            case metricRuleRoleArn = "metricRuleRoleArn"
        }
    }

    public struct SearchEntitiesRequest: AWSEncodableShape {
        /// The entity types for which to search.
        public let entityTypes: [EntityType]
        /// Optional filter to apply to the search. Valid filters are NAME NAMESPACE, SEMANTIC_TYPE_PATH and REFERENCED_ENTITY_ID.  REFERENCED_ENTITY_ID filters on entities that are used by the entity in the result set. For example,  you can filter on the ID of a property that is used in a state. Multiple filters function as OR criteria in the query. Multiple values passed inside the filter function as AND criteria.
        public let filters: [EntityFilter]?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
        public let namespaceVersion: Int64?
        /// The string that specifies the next page of results. Use this when you're paginating results.
        public let nextToken: String?

        @inlinable
        public init(entityTypes: [EntityType], filters: [EntityFilter]? = nil, maxResults: Int? = nil, namespaceVersion: Int64? = nil, nextToken: String? = nil) {
            self.entityTypes = entityTypes
            self.filters = filters
            self.maxResults = maxResults
            self.namespaceVersion = namespaceVersion
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case entityTypes = "entityTypes"
            case filters = "filters"
            case maxResults = "maxResults"
            case namespaceVersion = "namespaceVersion"
            case nextToken = "nextToken"
        }
    }

    public struct SearchEntitiesResponse: AWSDecodableShape {
        /// An array of descriptions for each entity returned in the search result.
        public let descriptions: [EntityDescription]?
        /// The string to specify as nextToken when you request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(descriptions: [EntityDescription]? = nil, nextToken: String? = nil) {
            self.descriptions = descriptions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case descriptions = "descriptions"
            case nextToken = "nextToken"
        }
    }

    public struct SearchFlowExecutionsRequest: AWSEncodableShape {
        /// The date and time of the latest flow execution to return.
        public let endTime: Date?
        /// The ID of a flow execution.
        public let flowExecutionId: String?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The string that specifies the next page of results. Use this when you're paginating results.
        public let nextToken: String?
        /// The date and time of the earliest flow execution to return.
        public let startTime: Date?
        /// The ID of the system instance that contains the flow.
        public let systemInstanceId: String

        @inlinable
        public init(endTime: Date? = nil, flowExecutionId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, startTime: Date? = nil, systemInstanceId: String) {
            self.endTime = endTime
            self.flowExecutionId = flowExecutionId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
            self.systemInstanceId = systemInstanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.systemInstanceId, name: "systemInstanceId", parent: name, max: 160)
            try self.validate(self.systemInstanceId, name: "systemInstanceId", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case flowExecutionId = "flowExecutionId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case startTime = "startTime"
            case systemInstanceId = "systemInstanceId"
        }
    }

    public struct SearchFlowExecutionsResponse: AWSDecodableShape {
        /// The string to specify as nextToken when you request the next page of results.
        public let nextToken: String?
        /// An array of objects that contain summary information about each workflow execution in the result set.
        public let summaries: [FlowExecutionSummary]?

        @inlinable
        public init(nextToken: String? = nil, summaries: [FlowExecutionSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct SearchFlowTemplatesRequest: AWSEncodableShape {
        /// An array of objects that limit the result set. The only valid filter is DEVICE_MODEL_ID.
        public let filters: [FlowTemplateFilter]?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The string that specifies the next page of results. Use this when you're paginating results.
        public let nextToken: String?

        @inlinable
        public init(filters: [FlowTemplateFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct SearchFlowTemplatesResponse: AWSDecodableShape {
        /// The string to specify as nextToken when you request the next page of results.
        public let nextToken: String?
        /// An array of objects that contain summary information about each workflow in the result set.
        public let summaries: [FlowTemplateSummary]?

        @inlinable
        public init(nextToken: String? = nil, summaries: [FlowTemplateSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct SearchSystemInstancesRequest: AWSEncodableShape {
        /// Optional filter to apply to the search. Valid filters are SYSTEM_TEMPLATE_ID, STATUS, and  GREENGRASS_GROUP_NAME. Multiple filters function as OR criteria in the query. Multiple values passed inside the filter function as AND criteria.
        public let filters: [SystemInstanceFilter]?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The string that specifies the next page of results. Use this when you're paginating results.
        public let nextToken: String?

        @inlinable
        public init(filters: [SystemInstanceFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct SearchSystemInstancesResponse: AWSDecodableShape {
        /// The string to specify as nextToken when you request the next page of results.
        public let nextToken: String?
        /// An array of objects that contain summary data abour the system instances in the result set.
        public let summaries: [SystemInstanceSummary]?

        @inlinable
        public init(nextToken: String? = nil, summaries: [SystemInstanceSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct SearchSystemTemplatesRequest: AWSEncodableShape {
        /// An array of filters that limit the result set. The only valid filter is FLOW_TEMPLATE_ID.
        public let filters: [SystemTemplateFilter]?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The string that specifies the next page of results. Use this when you're paginating results.
        public let nextToken: String?

        @inlinable
        public init(filters: [SystemTemplateFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct SearchSystemTemplatesResponse: AWSDecodableShape {
        /// The string to specify as nextToken when you request the next page of results.
        public let nextToken: String?
        /// An array of objects that contain summary information about each system deployment in the result set.
        public let summaries: [SystemTemplateSummary]?

        @inlinable
        public init(nextToken: String? = nil, summaries: [SystemTemplateSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct SearchThingsRequest: AWSEncodableShape {
        /// The ID of the entity to which the things are associated. The IDs should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
        public let entityId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
        public let namespaceVersion: Int64?
        /// The string that specifies the next page of results. Use this when you're paginating results.
        public let nextToken: String?

        @inlinable
        public init(entityId: String, maxResults: Int? = nil, namespaceVersion: Int64? = nil, nextToken: String? = nil) {
            self.entityId = entityId
            self.maxResults = maxResults
            self.namespaceVersion = namespaceVersion
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 160)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "entityId"
            case maxResults = "maxResults"
            case namespaceVersion = "namespaceVersion"
            case nextToken = "nextToken"
        }
    }

    public struct SearchThingsResponse: AWSDecodableShape {
        /// The string to specify as nextToken when you request the next page of results.
        public let nextToken: String?
        /// An array of things in the result set.
        public let things: [Thing]?

        @inlinable
        public init(nextToken: String? = nil, things: [Thing]? = nil) {
            self.nextToken = nextToken
            self.things = things
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case things = "things"
        }
    }

    public struct SystemInstanceDescription: AWSDecodableShape {
        public let definition: DefinitionDocument?
        /// The AWS Identity and Access Management (IAM) role that AWS IoT Things Graph assumes during flow execution in a  cloud deployment. This role must have read and write permissionss to AWS Lambda and AWS IoT and to any other  AWS services that the flow uses.
        public let flowActionsRoleArn: String?
        public let metricsConfiguration: MetricsConfiguration?
        /// The Amazon Simple Storage Service bucket where information about a system instance is stored.
        public let s3BucketName: String?
        /// An object that contains summary information about a system instance.
        public let summary: SystemInstanceSummary?
        /// A list of objects that contain all of the IDs and revision numbers of workflows and systems that are used in a system instance.
        public let validatedDependencyRevisions: [DependencyRevision]?
        /// The version of the user's namespace against which the system instance was validated.
        public let validatedNamespaceVersion: Int64?

        @inlinable
        public init(definition: DefinitionDocument? = nil, flowActionsRoleArn: String? = nil, metricsConfiguration: MetricsConfiguration? = nil, s3BucketName: String? = nil, summary: SystemInstanceSummary? = nil, validatedDependencyRevisions: [DependencyRevision]? = nil, validatedNamespaceVersion: Int64? = nil) {
            self.definition = definition
            self.flowActionsRoleArn = flowActionsRoleArn
            self.metricsConfiguration = metricsConfiguration
            self.s3BucketName = s3BucketName
            self.summary = summary
            self.validatedDependencyRevisions = validatedDependencyRevisions
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case flowActionsRoleArn = "flowActionsRoleArn"
            case metricsConfiguration = "metricsConfiguration"
            case s3BucketName = "s3BucketName"
            case summary = "summary"
            case validatedDependencyRevisions = "validatedDependencyRevisions"
            case validatedNamespaceVersion = "validatedNamespaceVersion"
        }
    }

    public struct SystemInstanceFilter: AWSEncodableShape {
        /// The name of the search filter field.
        public let name: SystemInstanceFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        public let value: [String]?

        @inlinable
        public init(name: SystemInstanceFilterName? = nil, value: [String]? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct SystemInstanceSummary: AWSDecodableShape {
        /// The ARN of the system instance.
        public let arn: String?
        /// The date when the system instance was created.
        public let createdAt: Date?
        /// The ID of the Greengrass group where the system instance is deployed.
        public let greengrassGroupId: String?
        /// The ID of the Greengrass group where the system instance is deployed.
        public let greengrassGroupName: String?
        /// The version of the Greengrass group where the system instance is deployed.
        public let greengrassGroupVersionId: String?
        /// The ID of the system instance.
        public let id: String?
        /// The status of the system instance.
        public let status: SystemInstanceDeploymentStatus?
        /// The target of the system instance.
        public let target: DeploymentTarget?
        ///   The date and time when the system instance was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, greengrassGroupId: String? = nil, greengrassGroupName: String? = nil, greengrassGroupVersionId: String? = nil, id: String? = nil, status: SystemInstanceDeploymentStatus? = nil, target: DeploymentTarget? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.greengrassGroupId = greengrassGroupId
            self.greengrassGroupName = greengrassGroupName
            self.greengrassGroupVersionId = greengrassGroupVersionId
            self.id = id
            self.status = status
            self.target = target
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case greengrassGroupId = "greengrassGroupId"
            case greengrassGroupName = "greengrassGroupName"
            case greengrassGroupVersionId = "greengrassGroupVersionId"
            case id = "id"
            case status = "status"
            case target = "target"
            case updatedAt = "updatedAt"
        }
    }

    public struct SystemTemplateDescription: AWSDecodableShape {
        /// The definition document of a system.
        public let definition: DefinitionDocument?
        /// An object that contains summary information about a system.
        public let summary: SystemTemplateSummary?
        /// The namespace version against which the system was validated. Use this value in your system instance.
        public let validatedNamespaceVersion: Int64?

        @inlinable
        public init(definition: DefinitionDocument? = nil, summary: SystemTemplateSummary? = nil, validatedNamespaceVersion: Int64? = nil) {
            self.definition = definition
            self.summary = summary
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case summary = "summary"
            case validatedNamespaceVersion = "validatedNamespaceVersion"
        }
    }

    public struct SystemTemplateFilter: AWSEncodableShape {
        /// The name of the system search filter field.
        public let name: SystemTemplateFilterName
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        public let value: [String]

        @inlinable
        public init(name: SystemTemplateFilterName, value: [String]) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.value.forEach {
                try validate($0, name: "value[]", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct SystemTemplateSummary: AWSDecodableShape {
        /// The ARN of the system.
        public let arn: String?
        /// The date when the system was created.
        public let createdAt: Date?
        /// The ID of the system.
        public let id: String?
        /// The revision number of the system.
        public let revisionNumber: Int64?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, revisionNumber: Int64? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.revisionNumber = revisionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case revisionNumber = "revisionNumber"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The required name of the tag. The string value can be from 1 to 128 Unicode characters in length.
        public let key: String
        /// The optional value of the tag. The string value can be from 1 to 256 Unicode characters in length.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource whose tags are returned.
        public let resourceArn: String
        /// A list of tags to add to the resource.>
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Thing: AWSDecodableShape {
        /// The ARN of the thing.
        public let thingArn: String?
        /// The name of the thing.
        public let thingName: String?

        @inlinable
        public init(thingArn: String? = nil, thingName: String? = nil) {
            self.thingArn = thingArn
            self.thingName = thingName
        }

        private enum CodingKeys: String, CodingKey {
            case thingArn = "thingArn"
            case thingName = "thingName"
        }
    }

    public struct UndeploySystemInstanceRequest: AWSEncodableShape {
        /// The ID of the system instance to remove from its target.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct UndeploySystemInstanceResponse: AWSDecodableShape {
        /// An object that contains summary information about the system instance that was removed from its target.
        public let summary: SystemInstanceSummary?

        @inlinable
        public init(summary: SystemInstanceSummary? = nil) {
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case summary = "summary"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource whose tags are to be removed.
        public let resourceArn: String
        /// A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed.  This parameter to the API requires a JSON text string argument. For information on how to format a JSON parameter for the various command line tool environments, see Using JSON for Parameters in the AWS CLI User Guide.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFlowTemplateRequest: AWSEncodableShape {
        /// The version of the user's namespace. If no value is specified, the latest version is used by default. Use the GetFlowTemplateRevisions if you want to find earlier revisions of the flow  to update.
        public let compatibleNamespaceVersion: Int64?
        /// The DefinitionDocument that contains the updated workflow definition.
        public let definition: DefinitionDocument
        /// The ID of the workflow to be updated. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
        public let id: String

        @inlinable
        public init(compatibleNamespaceVersion: Int64? = nil, definition: DefinitionDocument, id: String) {
            self.compatibleNamespaceVersion = compatibleNamespaceVersion
            self.definition = definition
            self.id = id
        }

        public func validate(name: String) throws {
            try self.definition.validate(name: "\(name).definition")
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleNamespaceVersion = "compatibleNamespaceVersion"
            case definition = "definition"
            case id = "id"
        }
    }

    public struct UpdateFlowTemplateResponse: AWSDecodableShape {
        /// An object containing summary information about the updated workflow.
        public let summary: FlowTemplateSummary?

        @inlinable
        public init(summary: FlowTemplateSummary? = nil) {
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case summary = "summary"
        }
    }

    public struct UpdateSystemTemplateRequest: AWSEncodableShape {
        /// The version of the user's namespace. Defaults to the latest version of the user's namespace. If no value is specified, the latest version is used by default.
        public let compatibleNamespaceVersion: Int64?
        /// The DefinitionDocument that contains the updated system definition.
        public let definition: DefinitionDocument
        /// The ID of the system to be updated. The ID should be in the following format.  urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
        public let id: String

        @inlinable
        public init(compatibleNamespaceVersion: Int64? = nil, definition: DefinitionDocument, id: String) {
            self.compatibleNamespaceVersion = compatibleNamespaceVersion
            self.definition = definition
            self.id = id
        }

        public func validate(name: String) throws {
            try self.definition.validate(name: "\(name).definition")
            try self.validate(self.id, name: "id", parent: name, max: 160)
            try self.validate(self.id, name: "id", parent: name, pattern: "^urn:tdm:(([a-z]{2}-(gov-)?[a-z]{4,9}-[0-9]{1,3}/[0-9]+/)*[\\p{Alnum}_]+(/[\\p{Alnum}_]+)*):([\\p{Alpha}]*):([\\p{Alnum}_]+(/[\\p{Alnum}_]+)*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleNamespaceVersion = "compatibleNamespaceVersion"
            case definition = "definition"
            case id = "id"
        }
    }

    public struct UpdateSystemTemplateResponse: AWSDecodableShape {
        /// An object containing summary information about the updated system.
        public let summary: SystemTemplateSummary?

        @inlinable
        public init(summary: SystemTemplateSummary? = nil) {
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case summary = "summary"
        }
    }

    public struct UploadEntityDefinitionsRequest: AWSEncodableShape {
        /// A Boolean that specifies whether to deprecate all entities in the latest version before uploading the new DefinitionDocument.  If set to true, the upload will create a new namespace version.
        public let deprecateExistingEntities: Bool?
        /// The DefinitionDocument that defines the updated entities.
        public let document: DefinitionDocument?
        /// A Boolean that specifies whether to synchronize with the latest version of the public namespace. If set to true, the upload will create a new namespace version.
        public let syncWithPublicNamespace: Bool?

        @inlinable
        public init(deprecateExistingEntities: Bool? = nil, document: DefinitionDocument? = nil, syncWithPublicNamespace: Bool? = nil) {
            self.deprecateExistingEntities = deprecateExistingEntities
            self.document = document
            self.syncWithPublicNamespace = syncWithPublicNamespace
        }

        public func validate(name: String) throws {
            try self.document?.validate(name: "\(name).document")
        }

        private enum CodingKeys: String, CodingKey {
            case deprecateExistingEntities = "deprecateExistingEntities"
            case document = "document"
            case syncWithPublicNamespace = "syncWithPublicNamespace"
        }
    }

    public struct UploadEntityDefinitionsResponse: AWSDecodableShape {
        /// The ID that specifies the upload action. You can use this to track the status of the upload.
        public let uploadId: String

        @inlinable
        public init(uploadId: String) {
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case uploadId = "uploadId"
        }
    }
}

// MARK: - Errors

/// Error enum for IoTThingsGraph
public struct IoTThingsGraphErrorType: AWSErrorType {
    enum Code: String {
        case internalFailureException = "InternalFailureException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTThingsGraph
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    public static var internalFailureException: Self { .init(.internalFailureException) }
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    public static var limitExceededException: Self { .init(.limitExceededException) }
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    public static var throttlingException: Self { .init(.throttlingException) }
}

extension IoTThingsGraphErrorType: Equatable {
    public static func == (lhs: IoTThingsGraphErrorType, rhs: IoTThingsGraphErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTThingsGraphErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
