//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension PartnerCentralBenefits {
    // MARK: Enums

    public enum BenefitAllocationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case fulfilled = "FULFILLED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum BenefitApplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionRequired = "ACTION_REQUIRED"
        case approved = "APPROVED"
        case canceled = "CANCELED"
        case inReview = "IN_REVIEW"
        case pendingSubmission = "PENDING_SUBMISSION"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum BenefitStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum CurrencyCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `try` = "TRY"
        case aed = "AED"
        case amd = "AMD"
        case ars = "ARS"
        case aud = "AUD"
        case awg = "AWG"
        case azn = "AZN"
        case bbd = "BBD"
        case bdt = "BDT"
        case bgn = "BGN"
        case bmd = "BMD"
        case bnd = "BND"
        case bob = "BOB"
        case brl = "BRL"
        case bsd = "BSD"
        case byr = "BYR"
        case bzd = "BZD"
        case cad = "CAD"
        case chf = "CHF"
        case clp = "CLP"
        case cny = "CNY"
        case cop = "COP"
        case crc = "CRC"
        case czk = "CZK"
        case dkk = "DKK"
        case dop = "DOP"
        case eek = "EEK"
        case egp = "EGP"
        case eur = "EUR"
        case gbp = "GBP"
        case gel = "GEL"
        case ghs = "GHS"
        case gtq = "GTQ"
        case gyd = "GYD"
        case hkd = "HKD"
        case hnl = "HNL"
        case hrk = "HRK"
        case htg = "HTG"
        case huf = "HUF"
        case idr = "IDR"
        case ils = "ILS"
        case inr = "INR"
        case isk = "ISK"
        case jmd = "JMD"
        case jpy = "JPY"
        case kes = "KES"
        case khr = "KHR"
        case krw = "KRW"
        case kyd = "KYD"
        case kzt = "KZT"
        case lbp = "LBP"
        case lkr = "LKR"
        case ltl = "LTL"
        case lvl = "LVL"
        case mad = "MAD"
        case mnt = "MNT"
        case mop = "MOP"
        case mur = "MUR"
        case mvr = "MVR"
        case mxn = "MXN"
        case myr = "MYR"
        case nad = "NAD"
        case ngn = "NGN"
        case nio = "NIO"
        case nok = "NOK"
        case nzd = "NZD"
        case pab = "PAB"
        case pen = "PEN"
        case php = "PHP"
        case pkr = "PKR"
        case pln = "PLN"
        case pyg = "PYG"
        case qar = "QAR"
        case ron = "RON"
        case rub = "RUB"
        case sar = "SAR"
        case sek = "SEK"
        case sgd = "SGD"
        case sit = "SIT"
        case skk = "SKK"
        case thb = "THB"
        case tnd = "TND"
        case ttd = "TTD"
        case twd = "TWD"
        case tzs = "TZS"
        case uah = "UAH"
        case usd = "USD"
        case uyu = "UYU"
        case uzs = "UZS"
        case vnd = "VND"
        case xaf = "XAF"
        case xcd = "XCD"
        case xof = "XOF"
        case xpf = "XPF"
        case zar = "ZAR"
        public var description: String { return self.rawValue }
    }

    public enum FileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "text/csv"
        case doc = "application/msword"
        case docx = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
        case jpg = "image/jpeg"
        case pdf = "application/pdf"
        case png = "image/png"
        case pptx = "application/vnd.openxmlformats-officedocument.presentationml.presentation"
        case svg = "image/svg+xml"
        case xlsx = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        public var description: String { return self.rawValue }
    }

    public enum FulfillmentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case access = "ACCESS"
        case cash = "CASH"
        case credits = "CREDITS"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case benefitAllocation = "BENEFIT_ALLOCATION"
        case opportunity = "OPPORTUNITY"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionNotPermitted = "ACTION_NOT_PERMITTED"
        case duplicateKeyValue = "DUPLICATE_KEY_VALUE"
        case invalidEnumValue = "INVALID_ENUM_VALUE"
        case invalidResourceState = "INVALID_RESOURCE_STATE"
        case invalidStringFormat = "INVALID_STRING_FORMAT"
        case invalidValue = "INVALID_VALUE"
        case notEnoughValues = "NOT_ENOUGH_VALUES"
        case requiredFieldMissing = "REQUIRED_FIELD_MISSING"
        case tooManyValues = "TOO_MANY_VALUES"
        case valueOutOfRange = "VALUE_OUT_OF_RANGE"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case businessValidationFailed = "BUSINESS_VALIDATION_FAILED"
        case cannotParse = "cannotParse"
        case fieldValidationFailed = "fieldValidationFailed"
        case other = "other"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum FulfillmentDetails: AWSDecodableShape, Sendable {
        /// Details about access-based fulfillment, if applicable to this benefit allocation.
        case accessDetails(AccessDetails)
        /// Details about consumable-based fulfillment, if applicable to this benefit allocation.
        case consumableDetails(ConsumableDetails)
        /// Details about credit-based fulfillment, if applicable to this benefit allocation.
        case creditDetails(CreditDetails)
        /// Details about disbursement-based fulfillment, if applicable to this benefit allocation.
        case disbursementDetails(DisbursementDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDetails:
                let value = try container.decode(AccessDetails.self, forKey: .accessDetails)
                self = .accessDetails(value)
            case .consumableDetails:
                let value = try container.decode(ConsumableDetails.self, forKey: .consumableDetails)
                self = .consumableDetails(value)
            case .creditDetails:
                let value = try container.decode(CreditDetails.self, forKey: .creditDetails)
                self = .creditDetails(value)
            case .disbursementDetails:
                let value = try container.decode(DisbursementDetails.self, forKey: .disbursementDetails)
                self = .disbursementDetails(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDetails = "AccessDetails"
            case consumableDetails = "ConsumableDetails"
            case creditDetails = "CreditDetails"
            case disbursementDetails = "DisbursementDetails"
        }
    }

    // MARK: Shapes

    public struct AccessDetails: AWSDecodableShape {
        /// A description of the access privileges or permissions granted by this benefit.
        public let description: String?

        @inlinable
        public init(description: String? = nil) {
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct AmendBenefitApplicationInput: AWSEncodableShape {
        /// A descriptive reason explaining why the benefit application is being amended.
        public let amendmentReason: String
        /// A list of specific field amendments to apply to the benefit application.
        public let amendments: [Amendment]
        /// The catalog identifier that specifies which benefit catalog the application belongs to.
        public let catalog: String
        /// A unique, case-sensitive identifier to ensure idempotent processing of the amendment request.
        public let clientToken: String
        /// The unique identifier of the benefit application to be amended.
        public let identifier: String
        /// The current revision number of the benefit application to ensure optimistic concurrency control.
        public let revision: String

        @inlinable
        public init(amendmentReason: String, amendments: [Amendment], catalog: String, clientToken: String, identifier: String, revision: String) {
            self.amendmentReason = amendmentReason
            self.amendments = amendments
            self.catalog = catalog
            self.clientToken = clientToken
            self.identifier = identifier
            self.revision = revision
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:.+|benappl-[0-9a-z]{14})$")
        }

        private enum CodingKeys: String, CodingKey {
            case amendmentReason = "AmendmentReason"
            case amendments = "Amendments"
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case identifier = "Identifier"
            case revision = "Revision"
        }
    }

    public struct AmendBenefitApplicationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct Amendment: AWSEncodableShape {
        /// The JSON path or field identifier specifying which field in the benefit application to modify.
        public let fieldPath: String
        /// The new value to set for the specified field in the benefit application.
        public let newValue: String

        @inlinable
        public init(fieldPath: String, newValue: String) {
            self.fieldPath = fieldPath
            self.newValue = newValue
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPath = "FieldPath"
            case newValue = "NewValue"
        }
    }

    public struct AssociateBenefitApplicationResourceInput: AWSEncodableShape {
        /// The unique identifier of the benefit application to associate the resource with.
        public let benefitApplicationIdentifier: String
        /// The catalog identifier that specifies which benefit catalog the application belongs to.
        public let catalog: String
        /// The Amazon Resource Name (ARN) of the AWS resource to associate with the benefit application.
        public let resourceArn: String

        @inlinable
        public init(benefitApplicationIdentifier: String, catalog: String, resourceArn: String) {
            self.benefitApplicationIdentifier = benefitApplicationIdentifier
            self.catalog = catalog
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.benefitApplicationIdentifier, name: "benefitApplicationIdentifier", parent: name, pattern: "^(arn:.+|benappl-[0-9a-z]{14})$")
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case benefitApplicationIdentifier = "BenefitApplicationIdentifier"
            case catalog = "Catalog"
            case resourceArn = "ResourceArn"
        }
    }

    public struct AssociateBenefitApplicationResourceOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the benefit application after the resource association.
        public let arn: String?
        /// The unique identifier of the benefit application after the resource association.
        public let id: String?
        /// The updated revision number of the benefit application after the resource association.
        public let revision: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, revision: String? = nil) {
            self.arn = arn
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case revision = "Revision"
        }
    }

    public struct AssociatedResource: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the AWS resource.
        public let resourceArn: String?
        /// The unique identifier of the AWS resource within its service.
        public let resourceIdentifier: String?
        /// The type of AWS resource (e.g., EC2 instance, S3 bucket, Lambda function).
        public let resourceType: ResourceType?

        @inlinable
        public init(resourceArn: String? = nil, resourceType: ResourceType? = nil) {
            self.resourceArn = resourceArn
            self.resourceIdentifier = nil
            self.resourceType = resourceType
        }

        @available(*, deprecated, message: "Members resourceIdentifier have been deprecated")
        @inlinable
        public init(resourceArn: String? = nil, resourceIdentifier: String? = nil, resourceType: ResourceType? = nil) {
            self.resourceArn = resourceArn
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case resourceIdentifier = "ResourceIdentifier"
            case resourceType = "ResourceType"
        }
    }

    public struct BenefitAllocationSummary: AWSDecodableShape {
        /// The identifiers of the benefits applicable for this allocation.
        public let applicableBenefitIds: [String]?
        /// The Amazon Resource Name (ARN) of the benefit allocation.
        public let arn: String?
        /// The identifier of the benefit application that resulted in this allocation.
        public let benefitApplicationId: String?
        /// The identifier of the benefit that this allocation is based on.
        public let benefitId: String?
        /// The catalog identifier that the benefit allocation belongs to.
        public let catalog: String?
        /// The timestamp when the benefit allocation was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The timestamp when the benefit allocation expires.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// The fulfillment types used for this benefit allocation.
        public let fulfillmentTypes: [FulfillmentType]?
        /// The unique identifier of the benefit allocation.
        public let id: String?
        /// The human-readable name of the benefit allocation.
        public let name: String?
        /// The current status of the benefit allocation.
        public let status: BenefitAllocationStatus?
        /// Additional information explaining the current status of the benefit allocation.
        public let statusReason: String?

        @inlinable
        public init(applicableBenefitIds: [String]? = nil, arn: String? = nil, benefitApplicationId: String? = nil, benefitId: String? = nil, catalog: String? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, fulfillmentTypes: [FulfillmentType]? = nil, id: String? = nil, name: String? = nil, status: BenefitAllocationStatus? = nil, statusReason: String? = nil) {
            self.applicableBenefitIds = applicableBenefitIds
            self.arn = arn
            self.benefitApplicationId = benefitApplicationId
            self.benefitId = benefitId
            self.catalog = catalog
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.fulfillmentTypes = fulfillmentTypes
            self.id = id
            self.name = name
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicableBenefitIds = "ApplicableBenefitIds"
            case arn = "Arn"
            case benefitApplicationId = "BenefitApplicationId"
            case benefitId = "BenefitId"
            case catalog = "Catalog"
            case createdAt = "CreatedAt"
            case expiresAt = "ExpiresAt"
            case fulfillmentTypes = "FulfillmentTypes"
            case id = "Id"
            case name = "Name"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct BenefitApplicationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the benefit application.
        public let arn: String?
        /// AWS resources that are associated with this benefit application.
        public let associatedResources: [String]?
        /// Additional attributes and metadata associated with the benefit application.
        public let benefitApplicationDetails: [String: String]?
        /// The identifier of the benefit being requested in this application.
        public let benefitId: String?
        /// The catalog identifier that the benefit application belongs to.
        public let catalog: String?
        /// The timestamp when the benefit application was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The fulfillment types requested for this benefit application.
        public let fulfillmentTypes: [FulfillmentType]?
        /// The unique identifier of the benefit application.
        public let id: String?
        /// The human-readable name of the benefit application.
        public let name: String?
        /// The AWS partner programs associated with this benefit application.
        public let programs: [String]?
        /// The current stage in the benefit application processing workflow..
        public let stage: String?
        /// The current processing status of the benefit application.
        public let status: BenefitApplicationStatus?
        /// The timestamp when the benefit application was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, associatedResources: [String]? = nil, benefitApplicationDetails: [String: String]? = nil, benefitId: String? = nil, catalog: String? = nil, createdAt: Date? = nil, fulfillmentTypes: [FulfillmentType]? = nil, id: String? = nil, name: String? = nil, programs: [String]? = nil, stage: String? = nil, status: BenefitApplicationStatus? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.associatedResources = associatedResources
            self.benefitApplicationDetails = benefitApplicationDetails
            self.benefitId = benefitId
            self.catalog = catalog
            self.createdAt = createdAt
            self.fulfillmentTypes = fulfillmentTypes
            self.id = id
            self.name = name
            self.programs = programs
            self.stage = stage
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case associatedResources = "AssociatedResources"
            case benefitApplicationDetails = "BenefitApplicationDetails"
            case benefitId = "BenefitId"
            case catalog = "Catalog"
            case createdAt = "CreatedAt"
            case fulfillmentTypes = "FulfillmentTypes"
            case id = "Id"
            case name = "Name"
            case programs = "Programs"
            case stage = "Stage"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct BenefitSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the benefit.
        public let arn: String?
        /// The catalog identifier that the benefit belongs to.
        public let catalog: String?
        /// A brief description of the benefit and its purpose.
        public let description: String?
        /// The available fulfillment types for this benefit.
        public let fulfillmentTypes: [FulfillmentType]?
        /// The unique identifier of the benefit.
        public let id: String?
        /// The human-readable name of the benefit.
        public let name: String?
        /// The AWS partner programs that this benefit is associated with.
        public let programs: [String]?
        /// The current status of the benefit.
        public let status: BenefitStatus?

        @inlinable
        public init(arn: String? = nil, catalog: String? = nil, description: String? = nil, fulfillmentTypes: [FulfillmentType]? = nil, id: String? = nil, name: String? = nil, programs: [String]? = nil, status: BenefitStatus? = nil) {
            self.arn = arn
            self.catalog = catalog
            self.description = description
            self.fulfillmentTypes = fulfillmentTypes
            self.id = id
            self.name = name
            self.programs = programs
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case description = "Description"
            case fulfillmentTypes = "FulfillmentTypes"
            case id = "Id"
            case name = "Name"
            case programs = "Programs"
            case status = "Status"
        }
    }

    public struct CancelBenefitApplicationInput: AWSEncodableShape {
        /// The catalog identifier that specifies which benefit catalog the application belongs to.
        public let catalog: String
        /// A unique, case-sensitive identifier to ensure idempotent processing of the cancellation request.
        public let clientToken: String
        /// The unique identifier of the benefit application to cancel.
        public let identifier: String
        /// A descriptive reason explaining why the benefit application is being cancelled.
        public let reason: String?

        @inlinable
        public init(catalog: String, clientToken: String, identifier: String, reason: String? = nil) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.identifier = identifier
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:.+|benappl-[0-9a-z]{14})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case identifier = "Identifier"
            case reason = "Reason"
        }
    }

    public struct CancelBenefitApplicationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct ConsumableDetails: AWSDecodableShape {
        /// The total amount of the consumable benefit that has been allocated.
        public let allocatedAmount: MonetaryValue?
        /// Detailed information about how the consumable benefit was issued and distributed.
        public let issuanceDetails: IssuanceDetail?
        /// The remaining amount of the consumable benefit that is still available for use.
        public let remainingAmount: MonetaryValue?
        /// The amount of the consumable benefit that has already been used.
        public let utilizedAmount: MonetaryValue?

        @inlinable
        public init(allocatedAmount: MonetaryValue? = nil, issuanceDetails: IssuanceDetail? = nil, remainingAmount: MonetaryValue? = nil, utilizedAmount: MonetaryValue? = nil) {
            self.allocatedAmount = allocatedAmount
            self.issuanceDetails = issuanceDetails
            self.remainingAmount = remainingAmount
            self.utilizedAmount = utilizedAmount
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedAmount = "AllocatedAmount"
            case issuanceDetails = "IssuanceDetails"
            case remainingAmount = "RemainingAmount"
            case utilizedAmount = "UtilizedAmount"
        }
    }

    public struct Contact: AWSEncodableShape & AWSDecodableShape {
        /// The business title or role of the contact person within the organization.
        public let businessTitle: String?
        /// The email address of the contact person.
        public let email: String?
        /// The first name of the contact person.
        public let firstName: String?
        /// The last name of the contact person.
        public let lastName: String?
        /// The phone number of the contact person.
        public let phone: String?

        @inlinable
        public init(businessTitle: String? = nil, email: String? = nil, firstName: String? = nil, lastName: String? = nil, phone: String? = nil) {
            self.businessTitle = businessTitle
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.phone = phone
        }

        public func validate(name: String) throws {
            try self.validate(self.email, name: "email", parent: name, max: 80)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$")
            try self.validate(self.firstName, name: "firstName", parent: name, max: 80)
            try self.validate(self.lastName, name: "lastName", parent: name, max: 80)
        }

        private enum CodingKeys: String, CodingKey {
            case businessTitle = "BusinessTitle"
            case email = "Email"
            case firstName = "FirstName"
            case lastName = "LastName"
            case phone = "Phone"
        }
    }

    public struct CreateBenefitApplicationInput: AWSEncodableShape {
        /// AWS resources that are associated with this benefit application.
        public let associatedResources: [String]?
        /// Detailed information and requirements specific to the benefit being requested.
        public let benefitApplicationDetails: AWSDocument?
        /// The unique identifier of the benefit being requested in this application.
        public let benefitIdentifier: String
        /// The catalog identifier that specifies which benefit catalog to create the application in.
        public let catalog: String
        /// A unique, case-sensitive identifier to ensure idempotent processing of the creation request.
        public let clientToken: String
        /// A detailed description of the benefit application and its intended use.
        public let description: String?
        /// Supporting documents and files attached to the benefit application.
        public let fileDetails: [FileInput]?
        /// The types of fulfillment requested for this benefit application (e.g., credits, access, disbursement).
        public let fulfillmentTypes: [FulfillmentType]?
        /// A human-readable name for the benefit application.
        public let name: String?
        /// Contact information for partner representatives responsible for this benefit application.
        public let partnerContacts: [Contact]?
        /// Key-value pairs to categorize and organize the benefit application.
        public let tags: [Tag]?

        @inlinable
        public init(associatedResources: [String]? = nil, benefitApplicationDetails: AWSDocument? = nil, benefitIdentifier: String, catalog: String, clientToken: String, description: String? = nil, fileDetails: [FileInput]? = nil, fulfillmentTypes: [FulfillmentType]? = nil, name: String? = nil, partnerContacts: [Contact]? = nil, tags: [Tag]? = nil) {
            self.associatedResources = associatedResources
            self.benefitApplicationDetails = benefitApplicationDetails
            self.benefitIdentifier = benefitIdentifier
            self.catalog = catalog
            self.clientToken = clientToken
            self.description = description
            self.fileDetails = fileDetails
            self.fulfillmentTypes = fulfillmentTypes
            self.name = name
            self.partnerContacts = partnerContacts
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.associatedResources?.forEach {
                try validate($0, name: "associatedResources[]", parent: name, pattern: "^arn:aws:([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.+)$")
            }
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.fileDetails?.forEach {
                try $0.validate(name: "\(name).fileDetails[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.partnerContacts?.forEach {
                try $0.validate(name: "\(name).partnerContacts[]")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associatedResources = "AssociatedResources"
            case benefitApplicationDetails = "BenefitApplicationDetails"
            case benefitIdentifier = "BenefitIdentifier"
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case description = "Description"
            case fileDetails = "FileDetails"
            case fulfillmentTypes = "FulfillmentTypes"
            case name = "Name"
            case partnerContacts = "PartnerContacts"
            case tags = "Tags"
        }
    }

    public struct CreateBenefitApplicationOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created benefit application.
        public let arn: String?
        /// The unique identifier assigned to the newly created benefit application.
        public let id: String?
        /// The initial revision number of the newly created benefit application.
        public let revision: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, revision: String? = nil) {
            self.arn = arn
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case revision = "Revision"
        }
    }

    public struct CreditCode: AWSDecodableShape {
        /// The AWS account ID that the credit code is associated with or can be applied to.
        public let awsAccountId: String
        /// The actual credit code string that can be redeemed in the AWS billing console.
        public let awsCreditCode: String
        /// The timestamp when the credit code expires and can no longer be redeemed.
        @CustomCoding<ISO8601DateCoder>
        public var expiresAt: Date
        /// The timestamp when the credit code was issued.
        @CustomCoding<ISO8601DateCoder>
        public var issuedAt: Date
        /// The current status of the credit code (e.g., active, redeemed, expired).
        public let status: BenefitAllocationStatus
        /// The monetary value of the credit code.
        public let value: MonetaryValue

        @inlinable
        public init(awsAccountId: String, awsCreditCode: String, expiresAt: Date, issuedAt: Date, status: BenefitAllocationStatus, value: MonetaryValue) {
            self.awsAccountId = awsAccountId
            self.awsCreditCode = awsCreditCode
            self.expiresAt = expiresAt
            self.issuedAt = issuedAt
            self.status = status
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case awsCreditCode = "AwsCreditCode"
            case expiresAt = "ExpiresAt"
            case issuedAt = "IssuedAt"
            case status = "Status"
            case value = "Value"
        }
    }

    public struct CreditDetails: AWSDecodableShape {
        /// The total amount of credits that have been allocated for this benefit.
        public let allocatedAmount: MonetaryValue
        /// A list of credit codes that have been generated for this benefit allocation.
        public let codes: [CreditCode]
        /// The amount of credits that have actually been issued and are available for use.
        public let issuedAmount: MonetaryValue

        @inlinable
        public init(allocatedAmount: MonetaryValue, codes: [CreditCode], issuedAmount: MonetaryValue) {
            self.allocatedAmount = allocatedAmount
            self.codes = codes
            self.issuedAmount = issuedAmount
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedAmount = "AllocatedAmount"
            case codes = "Codes"
            case issuedAmount = "IssuedAmount"
        }
    }

    public struct DisassociateBenefitApplicationResourceInput: AWSEncodableShape {
        /// The unique identifier of the benefit application to disassociate the resource from.
        public let benefitApplicationIdentifier: String
        /// The catalog identifier that specifies which benefit catalog the application belongs to.
        public let catalog: String
        /// The Amazon Resource Name (ARN) of the AWS resource to disassociate from the benefit application.
        public let resourceArn: String

        @inlinable
        public init(benefitApplicationIdentifier: String, catalog: String, resourceArn: String) {
            self.benefitApplicationIdentifier = benefitApplicationIdentifier
            self.catalog = catalog
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.benefitApplicationIdentifier, name: "benefitApplicationIdentifier", parent: name, pattern: "^(arn:.+|benappl-[0-9a-z]{14})$")
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case benefitApplicationIdentifier = "BenefitApplicationIdentifier"
            case catalog = "Catalog"
            case resourceArn = "ResourceArn"
        }
    }

    public struct DisassociateBenefitApplicationResourceOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the benefit application after the resource disassociation.
        public let arn: String?
        /// The unique identifier of the benefit application after the resource disassociation.
        public let id: String?
        /// The updated revision number of the benefit application after the resource disassociation.
        public let revision: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, revision: String? = nil) {
            self.arn = arn
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case revision = "Revision"
        }
    }

    public struct DisbursementDetails: AWSDecodableShape {
        /// The total amount that has been disbursed for this benefit allocation.
        public let disbursedAmount: MonetaryValue?
        /// Detailed information about how the disbursement was issued and processed.
        public let issuanceDetails: IssuanceDetail?

        @inlinable
        public init(disbursedAmount: MonetaryValue? = nil, issuanceDetails: IssuanceDetail? = nil) {
            self.disbursedAmount = disbursedAmount
            self.issuanceDetails = issuanceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case disbursedAmount = "DisbursedAmount"
            case issuanceDetails = "IssuanceDetails"
        }
    }

    public struct FileDetail: AWSDecodableShape {
        /// The business purpose or use case that this file supports in the benefit application.
        public let businessUseCase: String?
        /// The timestamp when the file was uploaded.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The identifier of the user who uploaded the file.
        public let createdBy: String?
        /// The original name of the uploaded file.
        public let fileName: String?
        /// The current processing status of the file (e.g., uploaded, processing, approved, rejected).
        public let fileStatus: String?
        /// The reason for that particulat file status.
        public let fileStatusReason: String?
        /// The type or category of the file (e.g., document, image, spreadsheet).
        public let fileType: FileType?
        /// The URI or location where the file is stored.
        public let fileURI: String

        @inlinable
        public init(businessUseCase: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, fileName: String? = nil, fileStatus: String? = nil, fileStatusReason: String? = nil, fileType: FileType? = nil, fileURI: String) {
            self.businessUseCase = businessUseCase
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.fileName = fileName
            self.fileStatus = fileStatus
            self.fileStatusReason = fileStatusReason
            self.fileType = fileType
            self.fileURI = fileURI
        }

        private enum CodingKeys: String, CodingKey {
            case businessUseCase = "BusinessUseCase"
            case createdAt = "CreatedAt"
            case createdBy = "CreatedBy"
            case fileName = "FileName"
            case fileStatus = "FileStatus"
            case fileStatusReason = "FileStatusReason"
            case fileType = "FileType"
            case fileURI = "FileURI"
        }
    }

    public struct FileInput: AWSEncodableShape {
        /// The business purpose or use case that this file supports in the benefit application.
        public let businessUseCase: String?
        /// The URI or location where the file should be stored or has been uploaded.
        public let fileURI: String

        @inlinable
        public init(businessUseCase: String? = nil, fileURI: String) {
            self.businessUseCase = businessUseCase
            self.fileURI = fileURI
        }

        public func validate(name: String) throws {
            try self.validate(self.fileURI, name: "fileURI", parent: name, max: 2000)
            try self.validate(self.fileURI, name: "fileURI", parent: name, min: 1)
            try self.validate(self.fileURI, name: "fileURI", parent: name, pattern: "^(s3://|https://).*")
        }

        private enum CodingKeys: String, CodingKey {
            case businessUseCase = "BusinessUseCase"
            case fileURI = "FileURI"
        }
    }

    public struct GetBenefitAllocationInput: AWSEncodableShape {
        /// The catalog identifier that specifies which benefit catalog to query.
        public let catalog: String
        /// The unique identifier of the benefit allocation to retrieve.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:.+|benalloc-[0-9a-z]{14})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case identifier = "Identifier"
        }
    }

    public struct GetBenefitAllocationOutput: AWSDecodableShape {
        /// A list of benefit identifiers that this allocation can be applied to.
        public let applicableBenefitIds: [String]?
        /// The Amazon Resource Name (ARN) of the benefit allocation.
        public let arn: String?
        /// The identifier of the benefit application that resulted in this allocation.
        public let benefitApplicationId: String?
        /// The identifier of the benefit that this allocation is based on.
        public let benefitId: String?
        /// The catalog identifier that the benefit allocation belongs to.
        public let catalog: String?
        /// The timestamp when the benefit allocation was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// A detailed description of the benefit allocation.
        public let description: String?
        /// The timestamp when the benefit allocation expires and is no longer usable.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// Detailed information about how the benefit allocation is fulfilled.
        public let fulfillmentDetail: FulfillmentDetails?
        /// The fulfillment type used for this benefit allocation.
        public let fulfillmentType: FulfillmentType?
        /// The unique identifier of the benefit allocation.
        public let id: String?
        /// The human-readable name of the benefit allocation.
        public let name: String?
        /// The timestamp when the benefit allocation becomes active and usable.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startsAt: Date?
        /// The current status of the benefit allocation (e.g., active, expired, consumed).
        public let status: BenefitAllocationStatus?
        /// Additional information explaining the current status of the benefit allocation.
        public let statusReason: String?
        /// The timestamp when the benefit allocation was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(applicableBenefitIds: [String]? = nil, arn: String? = nil, benefitApplicationId: String? = nil, benefitId: String? = nil, catalog: String? = nil, createdAt: Date? = nil, description: String? = nil, expiresAt: Date? = nil, fulfillmentDetail: FulfillmentDetails? = nil, fulfillmentType: FulfillmentType? = nil, id: String? = nil, name: String? = nil, startsAt: Date? = nil, status: BenefitAllocationStatus? = nil, statusReason: String? = nil, updatedAt: Date? = nil) {
            self.applicableBenefitIds = applicableBenefitIds
            self.arn = arn
            self.benefitApplicationId = benefitApplicationId
            self.benefitId = benefitId
            self.catalog = catalog
            self.createdAt = createdAt
            self.description = description
            self.expiresAt = expiresAt
            self.fulfillmentDetail = fulfillmentDetail
            self.fulfillmentType = fulfillmentType
            self.id = id
            self.name = name
            self.startsAt = startsAt
            self.status = status
            self.statusReason = statusReason
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case applicableBenefitIds = "ApplicableBenefitIds"
            case arn = "Arn"
            case benefitApplicationId = "BenefitApplicationId"
            case benefitId = "BenefitId"
            case catalog = "Catalog"
            case createdAt = "CreatedAt"
            case description = "Description"
            case expiresAt = "ExpiresAt"
            case fulfillmentDetail = "FulfillmentDetail"
            case fulfillmentType = "FulfillmentType"
            case id = "Id"
            case name = "Name"
            case startsAt = "StartsAt"
            case status = "Status"
            case statusReason = "StatusReason"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetBenefitApplicationInput: AWSEncodableShape {
        /// The catalog identifier that specifies which benefit catalog to query.
        public let catalog: String
        /// The unique identifier of the benefit application to retrieve.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:.+|benappl-[0-9a-z]{14})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case identifier = "Identifier"
        }
    }

    public struct GetBenefitApplicationOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the benefit application.
        public let arn: String?
        /// AWS resources that are associated with this benefit application.
        public let associatedResources: [String]?
        /// Detailed information and requirements specific to the benefit being requested.
        public let benefitApplicationDetails: AWSDocument?
        /// The identifier of the benefit being requested in this application.
        public let benefitId: String?
        /// The catalog identifier that the benefit application belongs to.
        public let catalog: String?
        /// The timestamp when the benefit application was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// A detailed description of the benefit application.
        public let description: String?
        /// Supporting documents and files attached to the benefit application.
        public let fileDetails: [FileDetail]?
        /// The fulfillment types requested for this benefit application.
        public let fulfillmentTypes: [FulfillmentType]?
        /// The unique identifier of the benefit application.
        public let id: String?
        /// The human-readable name of the benefit application.
        public let name: String?
        /// Contact information for partner representatives responsible for this benefit application.
        public let partnerContacts: [Contact]?
        /// The AWS partner programs associated with this benefit application.
        public let programs: [String]?
        /// The current revision number of the benefit application.
        public let revision: String?
        /// The current stage in the benefit application processing workflow.
        public let stage: String?
        /// The current processing status of the benefit application.
        public let status: BenefitApplicationStatus?
        /// Additional information explaining the current status of the benefit application.
        public let statusReason: String?
        /// A standardized code representing the reason for the current status.
        public let statusReasonCode: String?
        /// The list of standardized codes representing the reason for the current status.
        public let statusReasonCodes: [String]?
        /// The timestamp when the benefit application was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, associatedResources: [String]? = nil, benefitApplicationDetails: AWSDocument? = nil, benefitId: String? = nil, catalog: String? = nil, createdAt: Date? = nil, description: String? = nil, fileDetails: [FileDetail]? = nil, fulfillmentTypes: [FulfillmentType]? = nil, id: String? = nil, name: String? = nil, partnerContacts: [Contact]? = nil, programs: [String]? = nil, revision: String? = nil, stage: String? = nil, status: BenefitApplicationStatus? = nil, statusReason: String? = nil, statusReasonCodes: [String]? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.associatedResources = associatedResources
            self.benefitApplicationDetails = benefitApplicationDetails
            self.benefitId = benefitId
            self.catalog = catalog
            self.createdAt = createdAt
            self.description = description
            self.fileDetails = fileDetails
            self.fulfillmentTypes = fulfillmentTypes
            self.id = id
            self.name = name
            self.partnerContacts = partnerContacts
            self.programs = programs
            self.revision = revision
            self.stage = stage
            self.status = status
            self.statusReason = statusReason
            self.statusReasonCode = nil
            self.statusReasonCodes = statusReasonCodes
            self.updatedAt = updatedAt
        }

        @available(*, deprecated, message: "Members statusReasonCode have been deprecated")
        @inlinable
        public init(arn: String? = nil, associatedResources: [String]? = nil, benefitApplicationDetails: AWSDocument? = nil, benefitId: String? = nil, catalog: String? = nil, createdAt: Date? = nil, description: String? = nil, fileDetails: [FileDetail]? = nil, fulfillmentTypes: [FulfillmentType]? = nil, id: String? = nil, name: String? = nil, partnerContacts: [Contact]? = nil, programs: [String]? = nil, revision: String? = nil, stage: String? = nil, status: BenefitApplicationStatus? = nil, statusReason: String? = nil, statusReasonCode: String? = nil, statusReasonCodes: [String]? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.associatedResources = associatedResources
            self.benefitApplicationDetails = benefitApplicationDetails
            self.benefitId = benefitId
            self.catalog = catalog
            self.createdAt = createdAt
            self.description = description
            self.fileDetails = fileDetails
            self.fulfillmentTypes = fulfillmentTypes
            self.id = id
            self.name = name
            self.partnerContacts = partnerContacts
            self.programs = programs
            self.revision = revision
            self.stage = stage
            self.status = status
            self.statusReason = statusReason
            self.statusReasonCode = statusReasonCode
            self.statusReasonCodes = statusReasonCodes
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case associatedResources = "AssociatedResources"
            case benefitApplicationDetails = "BenefitApplicationDetails"
            case benefitId = "BenefitId"
            case catalog = "Catalog"
            case createdAt = "CreatedAt"
            case description = "Description"
            case fileDetails = "FileDetails"
            case fulfillmentTypes = "FulfillmentTypes"
            case id = "Id"
            case name = "Name"
            case partnerContacts = "PartnerContacts"
            case programs = "Programs"
            case revision = "Revision"
            case stage = "Stage"
            case status = "Status"
            case statusReason = "StatusReason"
            case statusReasonCode = "StatusReasonCode"
            case statusReasonCodes = "StatusReasonCodes"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetBenefitInput: AWSEncodableShape {
        /// The catalog identifier that specifies which benefit catalog to query.
        public let catalog: String
        /// The unique identifier of the benefit to retrieve.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case identifier = "Identifier"
        }
    }

    public struct GetBenefitOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the benefit.
        public let arn: String?
        /// The schema definition that describes the required fields for requesting this benefit.
        public let benefitRequestSchema: AWSDocument?
        /// The catalog identifier that the benefit belongs to.
        public let catalog: String?
        /// A detailed description of the benefit and its purpose.
        public let description: String?
        /// The available fulfillment types for this benefit (e.g., credits, access, disbursement).
        public let fulfillmentTypes: [FulfillmentType]?
        /// The unique identifier of the benefit.
        public let id: String?
        /// The human-readable name of the benefit.
        public let name: String?
        /// The AWS partner programs that this benefit is associated with.
        public let programs: [String]?
        /// The current status of the benefit (e.g., active, inactive, deprecated).
        public let status: BenefitStatus?

        @inlinable
        public init(arn: String? = nil, benefitRequestSchema: AWSDocument? = nil, catalog: String? = nil, description: String? = nil, fulfillmentTypes: [FulfillmentType]? = nil, id: String? = nil, name: String? = nil, programs: [String]? = nil, status: BenefitStatus? = nil) {
            self.arn = arn
            self.benefitRequestSchema = benefitRequestSchema
            self.catalog = catalog
            self.description = description
            self.fulfillmentTypes = fulfillmentTypes
            self.id = id
            self.name = name
            self.programs = programs
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case benefitRequestSchema = "BenefitRequestSchema"
            case catalog = "Catalog"
            case description = "Description"
            case fulfillmentTypes = "FulfillmentTypes"
            case id = "Id"
            case name = "Name"
            case programs = "Programs"
            case status = "Status"
        }
    }

    public struct IssuanceDetail: AWSDecodableShape {
        /// The monetary amount or value that was issued in this specific issuance.
        public let issuanceAmount: MonetaryValue?
        /// The unique identifier for this specific issuance.
        public let issuanceId: String?
        /// The timestamp when this specific issuance was processed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var issuedAt: Date?

        @inlinable
        public init(issuanceAmount: MonetaryValue? = nil, issuanceId: String? = nil, issuedAt: Date? = nil) {
            self.issuanceAmount = issuanceAmount
            self.issuanceId = issuanceId
            self.issuedAt = issuedAt
        }

        private enum CodingKeys: String, CodingKey {
            case issuanceAmount = "IssuanceAmount"
            case issuanceId = "IssuanceId"
            case issuedAt = "IssuedAt"
        }
    }

    public struct ListBenefitAllocationsInput: AWSEncodableShape {
        /// Filter benefit allocations by specific benefit application identifiers.
        public let benefitApplicationIdentifiers: [String]?
        /// Filter benefit allocations by specific benefit identifiers.
        public let benefitIdentifiers: [String]?
        /// The catalog identifier to filter benefit allocations by catalog.
        public let catalog: String
        /// Filter benefit allocations by specific fulfillment types.
        public let fulfillmentTypes: [FulfillmentType]?
        /// The maximum number of benefit allocations to return in a single response.
        public let maxResults: Int?
        /// A pagination token to retrieve the next set of results from a previous request.
        public let nextToken: String?
        /// Filter benefit allocations by their current status.
        public let status: [BenefitAllocationStatus]?

        @inlinable
        public init(benefitApplicationIdentifiers: [String]? = nil, benefitIdentifiers: [String]? = nil, catalog: String, fulfillmentTypes: [FulfillmentType]? = nil, maxResults: Int? = nil, nextToken: String? = nil, status: [BenefitAllocationStatus]? = nil) {
            self.benefitApplicationIdentifiers = benefitApplicationIdentifiers
            self.benefitIdentifiers = benefitIdentifiers
            self.catalog = catalog
            self.fulfillmentTypes = fulfillmentTypes
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func validate(name: String) throws {
            try self.benefitApplicationIdentifiers?.forEach {
                try validate($0, name: "benefitApplicationIdentifiers[]", parent: name, pattern: "^(arn:.+|benappl-[0-9a-z]{14})$")
            }
            try self.benefitIdentifiers?.forEach {
                try validate($0, name: "benefitIdentifiers[]", parent: name, pattern: "^(arn:.+|ben-[0-9a-z]{14})$")
            }
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case benefitApplicationIdentifiers = "BenefitApplicationIdentifiers"
            case benefitIdentifiers = "BenefitIdentifiers"
            case catalog = "Catalog"
            case fulfillmentTypes = "FulfillmentTypes"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case status = "Status"
        }
    }

    public struct ListBenefitAllocationsOutput: AWSDecodableShape {
        /// A list of benefit allocation summaries matching the specified criteria.
        public let benefitAllocationSummaries: [BenefitAllocationSummary]?
        /// A pagination token to retrieve the next set of results, if more results are available.
        public let nextToken: String?

        @inlinable
        public init(benefitAllocationSummaries: [BenefitAllocationSummary]? = nil, nextToken: String? = nil) {
            self.benefitAllocationSummaries = benefitAllocationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case benefitAllocationSummaries = "BenefitAllocationSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListBenefitApplicationsInput: AWSEncodableShape {
        /// Filter benefit applications by specific AWS resource ARNs.
        public let associatedResourceArns: [String]?
        /// Filter benefit applications by associated AWS resources.
        public let associatedResources: [AssociatedResource]?
        /// Filter benefit applications by specific benefit identifiers.
        public let benefitIdentifiers: [String]?
        /// The catalog identifier to filter benefit applications by catalog.
        public let catalog: String
        /// Filter benefit applications by specific fulfillment types.
        public let fulfillmentTypes: [FulfillmentType]?
        /// The maximum number of benefit applications to return in a single response.
        public let maxResults: Int?
        /// A pagination token to retrieve the next set of results from a previous request.
        public let nextToken: String?
        /// Filter benefit applications by specific AWS partner programs.
        public let programs: [String]?
        /// Filter benefit applications by their current processing stage.
        public let stages: [String]?
        /// Filter benefit applications by their current processing status.
        public let status: [BenefitApplicationStatus]?

        @inlinable
        public init(associatedResourceArns: [String]? = nil, benefitIdentifiers: [String]? = nil, catalog: String, fulfillmentTypes: [FulfillmentType]? = nil, maxResults: Int? = nil, nextToken: String? = nil, programs: [String]? = nil, stages: [String]? = nil, status: [BenefitApplicationStatus]? = nil) {
            self.associatedResourceArns = associatedResourceArns
            self.associatedResources = nil
            self.benefitIdentifiers = benefitIdentifiers
            self.catalog = catalog
            self.fulfillmentTypes = fulfillmentTypes
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.programs = programs
            self.stages = stages
            self.status = status
        }

        @available(*, deprecated, message: "Members associatedResources have been deprecated")
        @inlinable
        public init(associatedResourceArns: [String]? = nil, associatedResources: [AssociatedResource]? = nil, benefitIdentifiers: [String]? = nil, catalog: String, fulfillmentTypes: [FulfillmentType]? = nil, maxResults: Int? = nil, nextToken: String? = nil, programs: [String]? = nil, stages: [String]? = nil, status: [BenefitApplicationStatus]? = nil) {
            self.associatedResourceArns = associatedResourceArns
            self.associatedResources = associatedResources
            self.benefitIdentifiers = benefitIdentifiers
            self.catalog = catalog
            self.fulfillmentTypes = fulfillmentTypes
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.programs = programs
            self.stages = stages
            self.status = status
        }

        public func validate(name: String) throws {
            try self.associatedResourceArns?.forEach {
                try validate($0, name: "associatedResourceArns[]", parent: name, pattern: "^arn:aws:([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.+)$")
            }
            try self.associatedResources?.forEach {
                try $0.validate(name: "\(name).associatedResources[]")
            }
            try self.benefitIdentifiers?.forEach {
                try validate($0, name: "benefitIdentifiers[]", parent: name, pattern: "^(arn:.+|ben-[0-9a-z]{14})$")
            }
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.programs?.forEach {
                try validate($0, name: "programs[]", parent: name, max: 255)
                try validate($0, name: "programs[]", parent: name, min: 1)
                try validate($0, name: "programs[]", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associatedResourceArns = "AssociatedResourceArns"
            case associatedResources = "AssociatedResources"
            case benefitIdentifiers = "BenefitIdentifiers"
            case catalog = "Catalog"
            case fulfillmentTypes = "FulfillmentTypes"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case programs = "Programs"
            case stages = "Stages"
            case status = "Status"
        }
    }

    public struct ListBenefitApplicationsOutput: AWSDecodableShape {
        /// A list of benefit application summaries matching the specified criteria.
        public let benefitApplicationSummaries: [BenefitApplicationSummary]?
        /// A pagination token to retrieve the next set of results, if more results are available.
        public let nextToken: String?

        @inlinable
        public init(benefitApplicationSummaries: [BenefitApplicationSummary]? = nil, nextToken: String? = nil) {
            self.benefitApplicationSummaries = benefitApplicationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case benefitApplicationSummaries = "BenefitApplicationSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListBenefitsInput: AWSEncodableShape {
        /// The catalog identifier to filter benefits by catalog.
        public let catalog: String
        /// Filter benefits by specific fulfillment types.
        public let fulfillmentTypes: [FulfillmentType]?
        /// The maximum number of benefits to return in a single response.
        public let maxResults: Int?
        /// A pagination token to retrieve the next set of results from a previous request.
        public let nextToken: String?
        /// Filter benefits by specific AWS partner programs.
        public let programs: [String]?
        /// Filter benefits by their current status.
        public let status: [BenefitStatus]?

        @inlinable
        public init(catalog: String, fulfillmentTypes: [FulfillmentType]? = nil, maxResults: Int? = nil, nextToken: String? = nil, programs: [String]? = nil, status: [BenefitStatus]? = nil) {
            self.catalog = catalog
            self.fulfillmentTypes = fulfillmentTypes
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.programs = programs
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.programs?.forEach {
                try validate($0, name: "programs[]", parent: name, max: 255)
                try validate($0, name: "programs[]", parent: name, min: 1)
                try validate($0, name: "programs[]", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case fulfillmentTypes = "FulfillmentTypes"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case programs = "Programs"
            case status = "Status"
        }
    }

    public struct ListBenefitsOutput: AWSDecodableShape {
        /// A list of benefit summaries matching the specified criteria.
        public let benefitSummaries: [BenefitSummary]?
        /// A pagination token to retrieve the next set of results, if more results are available.
        public let nextToken: String?

        @inlinable
        public init(benefitSummaries: [BenefitSummary]? = nil, nextToken: String? = nil) {
            self.benefitSummaries = benefitSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case benefitSummaries = "BenefitSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to list tags for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[\\w+=/,.@-]+:partnercentral:[\\w+=/,.@-]*:[0-9]{12}:catalog/([a-zA-Z]+)/[\\w+=,.@-]+(/[\\w+=,.@-]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of key-value pairs representing the tags associated with the resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MonetaryValue: AWSDecodableShape {
        /// The numeric amount of the monetary value.
        public let amount: String
        /// The ISO 4217 currency code (e.g., USD, EUR) for the monetary amount.
        public let currencyCode: CurrencyCode

        @inlinable
        public init(amount: String, currencyCode: CurrencyCode) {
            self.amount = amount
            self.currencyCode = currencyCode
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "Amount"
            case currencyCode = "CurrencyCode"
        }
    }

    public struct RecallBenefitApplicationInput: AWSEncodableShape {
        /// The catalog identifier that specifies which benefit catalog the application belongs to.
        public let catalog: String
        /// A unique, case-sensitive identifier to ensure idempotent processing of the recall request.
        public let clientToken: String?
        /// The unique identifier of the benefit application to recall.
        public let identifier: String
        /// A descriptive reason explaining why the benefit application is being recalled.
        public let reason: String

        @inlinable
        public init(catalog: String, clientToken: String? = nil, identifier: String, reason: String) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.identifier = identifier
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:.+|benappl-[0-9a-z]{14})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case identifier = "Identifier"
            case reason = "Reason"
        }
    }

    public struct RecallBenefitApplicationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        /// A message describing the service quota exceeded error.
        public let message: String
        /// The code identifying the specific quota that would be exceeded.
        public let quotaCode: String
        /// The identifier of the resource that would exceed the quota.
        public let resourceId: String
        /// The type of the resource that would exceed the quota.
        public let resourceType: String

        @inlinable
        public init(message: String, quotaCode: String, resourceId: String, resourceType: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case quotaCode = "QuotaCode"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct SubmitBenefitApplicationInput: AWSEncodableShape {
        /// The catalog identifier that specifies which benefit catalog the application belongs to.
        public let catalog: String
        /// The unique identifier of the benefit application to submit.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:.+|benappl-[0-9a-z]{14})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case identifier = "Identifier"
        }
    }

    public struct SubmitBenefitApplicationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key, which acts as a category or label for the tag.
        public let key: String
        /// The tag value, which provides additional information or context for the tag key.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to add tags to.
        public let resourceArn: String
        /// A list of key-value pairs to add as tags to the resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[\\w+=/,.@-]+:partnercentral:[\\w+=/,.@-]*:[0-9]{12}:catalog/([a-zA-Z]+)/[\\w+=,.@-]+(/[\\w+=,.@-]+)*$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to remove tags from.
        public let resourceArn: String
        /// A list of tag keys to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[\\w+=/,.@-]+:partnercentral:[\\w+=/,.@-]*:[0-9]{12}:catalog/([a-zA-Z]+)/[\\w+=,.@-]+(/[\\w+=,.@-]+)*$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateBenefitApplicationInput: AWSEncodableShape {
        /// Updated detailed information and requirements specific to the benefit being requested.
        public let benefitApplicationDetails: AWSDocument?
        /// The catalog identifier that specifies which benefit catalog the application belongs to.
        public let catalog: String
        /// A unique, case-sensitive identifier to ensure idempotent processing of the update request.
        public let clientToken: String
        /// The updated detailed description of the benefit application.
        public let description: String?
        /// Updated supporting documents and files attached to the benefit application.
        public let fileDetails: [FileInput]?
        /// The unique identifier of the benefit application to update.
        public let identifier: String
        /// The updated human-readable name for the benefit application.
        public let name: String?
        /// Updated contact information for partner representatives responsible for this benefit application.
        public let partnerContacts: [Contact]?
        /// The current revision number of the benefit application to ensure optimistic concurrency control.
        public let revision: String

        @inlinable
        public init(benefitApplicationDetails: AWSDocument? = nil, catalog: String, clientToken: String, description: String? = nil, fileDetails: [FileInput]? = nil, identifier: String, name: String? = nil, partnerContacts: [Contact]? = nil, revision: String) {
            self.benefitApplicationDetails = benefitApplicationDetails
            self.catalog = catalog
            self.clientToken = clientToken
            self.description = description
            self.fileDetails = fileDetails
            self.identifier = identifier
            self.name = name
            self.partnerContacts = partnerContacts
            self.revision = revision
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.fileDetails?.forEach {
                try $0.validate(name: "\(name).fileDetails[]")
            }
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(arn:.+|benappl-[0-9a-z]{14})$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.partnerContacts?.forEach {
                try $0.validate(name: "\(name).partnerContacts[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case benefitApplicationDetails = "BenefitApplicationDetails"
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case description = "Description"
            case fileDetails = "FileDetails"
            case identifier = "Identifier"
            case name = "Name"
            case partnerContacts = "PartnerContacts"
            case revision = "Revision"
        }
    }

    public struct UpdateBenefitApplicationOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated benefit application.
        public let arn: String?
        /// The unique identifier of the updated benefit application.
        public let id: String?
        /// The new revision number of the benefit application after the update.
        public let revision: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, revision: String? = nil) {
            self.arn = arn
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case revision = "Revision"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// A list of fields that failed validation.
        public let fieldList: [ValidationExceptionField]?
        /// A message describing the validation error.
        public let message: String
        /// The reason for the validation failure.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "FieldList"
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// An error code explaining why the field validation failed.
        public let code: ValidationExceptionErrorCode?
        /// A detailed message explaining why the field validation failed.
        public let message: String
        /// The name of the field that failed validation.
        public let name: String

        @inlinable
        public init(code: ValidationExceptionErrorCode? = nil, message: String, name: String) {
            self.code = code
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
            case name = "Name"
        }
    }
}

// MARK: - Errors

/// Error enum for PartnerCentralBenefits
public struct PartnerCentralBenefitsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize PartnerCentralBenefits
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Thrown when the caller does not have sufficient permissions to perform the requested operation.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Thrown when the request conflicts with the current state of the resource, such as attempting to modify a resource that has been changed by another process.
    public static var conflictException: Self { .init(.conflictException) }
    /// Thrown when an unexpected error occurs on the server side during request processing.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Thrown when the requested resource cannot be found or does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Thrown when the request would exceed the service quotas or limits for the account.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Thrown when the request rate exceeds the allowed limits and the request is being throttled.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Thrown when the request contains invalid parameters or fails input validation requirements.
    public static var validationException: Self { .init(.validationException) }
}

extension PartnerCentralBenefitsErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ServiceQuotaExceededException": PartnerCentralBenefits.ServiceQuotaExceededException.self,
        "ValidationException": PartnerCentralBenefits.ValidationException.self
    ]
}

extension PartnerCentralBenefitsErrorType: Equatable {
    public static func == (lhs: PartnerCentralBenefitsErrorType, rhs: PartnerCentralBenefitsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension PartnerCentralBenefitsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
