//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Panorama {
    // MARK: Enums

    public enum ApplicationInstanceHealthStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case notAvailable = "NOT_AVAILABLE"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationInstanceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deploymentError = "DEPLOYMENT_ERROR"
        case deploymentFailed = "DEPLOYMENT_FAILED"
        case deploymentInProgress = "DEPLOYMENT_IN_PROGRESS"
        case deploymentPending = "DEPLOYMENT_PENDING"
        case deploymentRequested = "DEPLOYMENT_REQUESTED"
        case deploymentSucceeded = "DEPLOYMENT_SUCCEEDED"
        case removalFailed = "REMOVAL_FAILED"
        case removalInProgress = "REMOVAL_IN_PROGRESS"
        case removalPending = "REMOVAL_PENDING"
        case removalRequested = "REMOVAL_REQUESTED"
        case removalSucceeded = "REMOVAL_SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dhcp = "DHCP"
        case staticIp = "STATIC_IP"
        public var description: String { return self.rawValue }
    }

    public enum DesiredState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case removed = "REMOVED"
        case running = "RUNNING"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum DeviceAggregatedStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awaitingProvisioning = "AWAITING_PROVISIONING"
        case deleting = "DELETING"
        case error = "ERROR"
        case failed = "FAILED"
        case leaseExpired = "LEASE_EXPIRED"
        case offline = "OFFLINE"
        case online = "ONLINE"
        case pending = "PENDING"
        case rebooting = "REBOOTING"
        case updateNeeded = "UPDATE_NEEDED"
        public var description: String { return self.rawValue }
    }

    public enum DeviceBrand: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsPanorama = "AWS_PANORAMA"
        case lenovo = "LENOVO"
        public var description: String { return self.rawValue }
    }

    public enum DeviceConnectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awaitingCredentials = "AWAITING_CREDENTIALS"
        case error = "ERROR"
        case notAvailable = "NOT_AVAILABLE"
        case offline = "OFFLINE"
        case online = "ONLINE"
        public var description: String { return self.rawValue }
    }

    public enum DeviceReportedStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case installError = "INSTALL_ERROR"
        case installInProgress = "INSTALL_IN_PROGRESS"
        case launched = "LAUNCHED"
        case launchError = "LAUNCH_ERROR"
        case removalFailed = "REMOVAL_FAILED"
        case removalInProgress = "REMOVAL_IN_PROGRESS"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case stopError = "STOP_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum DeviceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awaitingProvisioning = "AWAITING_PROVISIONING"
        case deleting = "DELETING"
        case error = "ERROR"
        case failed = "FAILED"
        case pending = "PENDING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum DeviceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case panoramaAppliance = "PANORAMA_APPLIANCE"
        case panoramaApplianceDeveloperKit = "PANORAMA_APPLIANCE_DEVELOPER_KIT"
        public var description: String { return self.rawValue }
    }

    public enum JobResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case package = "PACKAGE"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ota = "OTA"
        case reboot = "REBOOT"
        public var description: String { return self.rawValue }
    }

    public enum ListDevicesSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createdTime = "CREATED_TIME"
        case deviceAggregatedStatus = "DEVICE_AGGREGATED_STATUS"
        case deviceId = "DEVICE_ID"
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum NetworkConnectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connected = "CONNECTED"
        case connecting = "CONNECTING"
        case notConnected = "NOT_CONNECTED"
        public var description: String { return self.rawValue }
    }

    public enum NodeCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case businessLogic = "BUSINESS_LOGIC"
        case mediaSink = "MEDIA_SINK"
        case mediaSource = "MEDIA_SOURCE"
        case mlModel = "ML_MODEL"
        public var description: String { return self.rawValue }
    }

    public enum NodeFromTemplateJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case pending = "PENDING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum NodeInstanceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case notAvailable = "NOT_AVAILABLE"
        case paused = "PAUSED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum NodeSignalValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pause = "PAUSE"
        case resume = "RESUME"
        public var description: String { return self.rawValue }
    }

    public enum PackageImportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case pending = "PENDING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum PackageImportJobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case marketplaceNodePackageVersion = "MARKETPLACE_NODE_PACKAGE_VERSION"
        case nodePackageVersion = "NODE_PACKAGE_VERSION"
        public var description: String { return self.rawValue }
    }

    public enum PackageVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleting = "DELETING"
        case failed = "FAILED"
        case registerCompleted = "REGISTER_COMPLETED"
        case registerPending = "REGISTER_PENDING"
        public var description: String { return self.rawValue }
    }

    public enum PortType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case boolean = "BOOLEAN"
        case float32 = "FLOAT32"
        case int32 = "INT32"
        case media = "MEDIA"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum StatusFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deploymentError = "DEPLOYMENT_ERROR"
        case deploymentFailed = "DEPLOYMENT_FAILED"
        case deploymentSucceeded = "DEPLOYMENT_SUCCEEDED"
        case processingDeployment = "PROCESSING_DEPLOYMENT"
        case processingRemoval = "PROCESSING_REMOVAL"
        case removalFailed = "REMOVAL_FAILED"
        case removalSucceeded = "REMOVAL_SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum TemplateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rtspCameraStream = "RTSP_CAMERA_STREAM"
        public var description: String { return self.rawValue }
    }

    public enum UpdateProgress: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case downloading = "DOWNLOADING"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        case rebooting = "REBOOTING"
        case verifying = "VERIFYING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AlternateSoftwareMetadata: AWSDecodableShape {
        /// The appliance software version.
        public let version: String?

        public init(version: String? = nil) {
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case version = "Version"
        }
    }

    public struct ApplicationInstance: AWSDecodableShape {
        /// The application instance's ID.
        public let applicationInstanceId: String?
        /// The application instance's ARN.
        public let arn: String?
        /// When the application instance was created.
        public let createdTime: Date?
        /// The device's ID.
        public let defaultRuntimeContextDevice: String?
        /// The device's name.
        public let defaultRuntimeContextDeviceName: String?
        /// The application instance's description.
        public let description: String?
        /// The application instance's health status.
        public let healthStatus: ApplicationInstanceHealthStatus?
        /// The application instance's name.
        public let name: String?
        /// The application's state.
        public let runtimeContextStates: [ReportedRuntimeContextState]?
        /// The application instance's status.
        public let status: ApplicationInstanceStatus?
        /// The application instance's status description.
        public let statusDescription: String?
        /// The application instance's tags.
        public let tags: [String: String]?

        public init(applicationInstanceId: String? = nil, arn: String? = nil, createdTime: Date? = nil, defaultRuntimeContextDevice: String? = nil, defaultRuntimeContextDeviceName: String? = nil, description: String? = nil, healthStatus: ApplicationInstanceHealthStatus? = nil, name: String? = nil, runtimeContextStates: [ReportedRuntimeContextState]? = nil, status: ApplicationInstanceStatus? = nil, statusDescription: String? = nil, tags: [String: String]? = nil) {
            self.applicationInstanceId = applicationInstanceId
            self.arn = arn
            self.createdTime = createdTime
            self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
            self.defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceName
            self.description = description
            self.healthStatus = healthStatus
            self.name = name
            self.runtimeContextStates = runtimeContextStates
            self.status = status
            self.statusDescription = statusDescription
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case applicationInstanceId = "ApplicationInstanceId"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
            case defaultRuntimeContextDeviceName = "DefaultRuntimeContextDeviceName"
            case description = "Description"
            case healthStatus = "HealthStatus"
            case name = "Name"
            case runtimeContextStates = "RuntimeContextStates"
            case status = "Status"
            case statusDescription = "StatusDescription"
            case tags = "Tags"
        }
    }

    public struct CreateApplicationInstanceRequest: AWSEncodableShape {
        /// The ID of an application instance to replace with the new instance.
        public let applicationInstanceIdToReplace: String?
        /// A device's ID.
        public let defaultRuntimeContextDevice: String
        /// A description for the application instance.
        public let description: String?
        /// Setting overrides for the application manifest.
        public let manifestOverridesPayload: ManifestOverridesPayload?
        /// The application's manifest document.
        public let manifestPayload: ManifestPayload
        /// A name for the application instance.
        public let name: String?
        /// The ARN of a runtime role for the application instance.
        public let runtimeRoleArn: String?
        /// Tags for the application instance.
        public let tags: [String: String]?

        public init(applicationInstanceIdToReplace: String? = nil, defaultRuntimeContextDevice: String, description: String? = nil, manifestOverridesPayload: ManifestOverridesPayload? = nil, manifestPayload: ManifestPayload, name: String? = nil, runtimeRoleArn: String? = nil, tags: [String: String]? = nil) {
            self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
            self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
            self.description = description
            self.manifestOverridesPayload = manifestOverridesPayload
            self.manifestPayload = manifestPayload
            self.name = name
            self.runtimeRoleArn = runtimeRoleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationInstanceIdToReplace, name: "applicationInstanceIdToReplace", parent: name, max: 255)
            try self.validate(self.applicationInstanceIdToReplace, name: "applicationInstanceIdToReplace", parent: name, min: 1)
            try self.validate(self.applicationInstanceIdToReplace, name: "applicationInstanceIdToReplace", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.validate(self.defaultRuntimeContextDevice, name: "defaultRuntimeContextDevice", parent: name, max: 255)
            try self.validate(self.defaultRuntimeContextDevice, name: "defaultRuntimeContextDevice", parent: name, min: 1)
            try self.validate(self.defaultRuntimeContextDevice, name: "defaultRuntimeContextDevice", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.*$")
            try self.manifestOverridesPayload?.validate(name: "\(name).manifestOverridesPayload")
            try self.manifestPayload.validate(name: "\(name).manifestPayload")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.validate(self.runtimeRoleArn, name: "runtimeRoleArn", parent: name, max: 255)
            try self.validate(self.runtimeRoleArn, name: "runtimeRoleArn", parent: name, min: 1)
            try self.validate(self.runtimeRoleArn, name: "runtimeRoleArn", parent: name, pattern: "^arn:[a-z0-9][-.a-z0-9]{0,62}:iam::[0-9]{12}:role/.+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^.+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationInstanceIdToReplace = "ApplicationInstanceIdToReplace"
            case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
            case description = "Description"
            case manifestOverridesPayload = "ManifestOverridesPayload"
            case manifestPayload = "ManifestPayload"
            case name = "Name"
            case runtimeRoleArn = "RuntimeRoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateApplicationInstanceResponse: AWSDecodableShape {
        /// The application instance's ID.
        public let applicationInstanceId: String

        public init(applicationInstanceId: String) {
            self.applicationInstanceId = applicationInstanceId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationInstanceId = "ApplicationInstanceId"
        }
    }

    public struct CreateJobForDevicesRequest: AWSEncodableShape {
        /// ID of target device.
        public let deviceIds: [String]
        /// Configuration settings for a software update job.
        public let deviceJobConfig: DeviceJobConfig?
        /// The type of job to run.
        public let jobType: JobType

        public init(deviceIds: [String], deviceJobConfig: DeviceJobConfig? = nil, jobType: JobType) {
            self.deviceIds = deviceIds
            self.deviceJobConfig = deviceJobConfig
            self.jobType = jobType
        }

        public func validate(name: String) throws {
            try self.deviceIds.forEach {
                try validate($0, name: "deviceIds[]", parent: name, max: 255)
                try validate($0, name: "deviceIds[]", parent: name, min: 1)
                try validate($0, name: "deviceIds[]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            }
            try self.validate(self.deviceIds, name: "deviceIds", parent: name, max: 1)
            try self.validate(self.deviceIds, name: "deviceIds", parent: name, min: 1)
            try self.deviceJobConfig?.validate(name: "\(name).deviceJobConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceIds = "DeviceIds"
            case deviceJobConfig = "DeviceJobConfig"
            case jobType = "JobType"
        }
    }

    public struct CreateJobForDevicesResponse: AWSDecodableShape {
        /// A list of jobs.
        public let jobs: [Job]

        public init(jobs: [Job]) {
            self.jobs = jobs
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
        }
    }

    public struct CreateNodeFromTemplateJobRequest: AWSEncodableShape {
        /// Tags for the job.
        public let jobTags: [JobResourceTags]?
        /// A description for the node.
        public let nodeDescription: String?
        /// A name for the node.
        public let nodeName: String
        /// An output package name for the node.
        public let outputPackageName: String
        /// An output package version for the node.
        public let outputPackageVersion: String
        /// Template parameters for the node.
        public let templateParameters: [String: String]
        /// The type of node.
        public let templateType: TemplateType

        public init(jobTags: [JobResourceTags]? = nil, nodeDescription: String? = nil, nodeName: String, outputPackageName: String, outputPackageVersion: String, templateParameters: [String: String], templateType: TemplateType) {
            self.jobTags = jobTags
            self.nodeDescription = nodeDescription
            self.nodeName = nodeName
            self.outputPackageName = outputPackageName
            self.outputPackageVersion = outputPackageVersion
            self.templateParameters = templateParameters
            self.templateType = templateType
        }

        public func validate(name: String) throws {
            try self.jobTags?.forEach {
                try $0.validate(name: "\(name).jobTags[]")
            }
            try self.validate(self.nodeDescription, name: "nodeDescription", parent: name, max: 255)
            try self.validate(self.nodeDescription, name: "nodeDescription", parent: name, pattern: "^.*$")
            try self.validate(self.nodeName, name: "nodeName", parent: name, max: 128)
            try self.validate(self.nodeName, name: "nodeName", parent: name, min: 1)
            try self.validate(self.nodeName, name: "nodeName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.validate(self.outputPackageName, name: "outputPackageName", parent: name, max: 128)
            try self.validate(self.outputPackageName, name: "outputPackageName", parent: name, min: 1)
            try self.validate(self.outputPackageName, name: "outputPackageName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.validate(self.outputPackageVersion, name: "outputPackageVersion", parent: name, max: 255)
            try self.validate(self.outputPackageVersion, name: "outputPackageVersion", parent: name, min: 1)
            try self.validate(self.outputPackageVersion, name: "outputPackageVersion", parent: name, pattern: "^([0-9]+)\\.([0-9]+)$")
            try self.templateParameters.forEach {
                try validate($0.key, name: "templateParameters.key", parent: name, max: 255)
                try validate($0.key, name: "templateParameters.key", parent: name, min: 1)
                try validate($0.key, name: "templateParameters.key", parent: name, pattern: "^.+$")
                try validate($0.value, name: "templateParameters[\"\($0.key)\"]", parent: name, max: 255)
                try validate($0.value, name: "templateParameters[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "templateParameters[\"\($0.key)\"]", parent: name, pattern: "^.+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case jobTags = "JobTags"
            case nodeDescription = "NodeDescription"
            case nodeName = "NodeName"
            case outputPackageName = "OutputPackageName"
            case outputPackageVersion = "OutputPackageVersion"
            case templateParameters = "TemplateParameters"
            case templateType = "TemplateType"
        }
    }

    public struct CreateNodeFromTemplateJobResponse: AWSDecodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct CreatePackageImportJobRequest: AWSEncodableShape {
        /// A client token for the package import job.
        public let clientToken: String
        /// An input config for the package import job.
        public let inputConfig: PackageImportJobInputConfig
        /// Tags for the package import job.
        public let jobTags: [JobResourceTags]?
        /// A job type for the package import job.
        public let jobType: PackageImportJobType
        /// An output config for the package import job.
        public let outputConfig: PackageImportJobOutputConfig

        public init(clientToken: String, inputConfig: PackageImportJobInputConfig, jobTags: [JobResourceTags]? = nil, jobType: PackageImportJobType, outputConfig: PackageImportJobOutputConfig) {
            self.clientToken = clientToken
            self.inputConfig = inputConfig
            self.jobTags = jobTags
            self.jobType = jobType
            self.outputConfig = outputConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.inputConfig.validate(name: "\(name).inputConfig")
            try self.jobTags?.forEach {
                try $0.validate(name: "\(name).jobTags[]")
            }
            try self.outputConfig.validate(name: "\(name).outputConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case inputConfig = "InputConfig"
            case jobTags = "JobTags"
            case jobType = "JobType"
            case outputConfig = "OutputConfig"
        }
    }

    public struct CreatePackageImportJobResponse: AWSDecodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct CreatePackageRequest: AWSEncodableShape {
        /// A name for the package.
        public let packageName: String
        /// Tags for the package.
        public let tags: [String: String]?

        public init(packageName: String, tags: [String: String]? = nil) {
            self.packageName = packageName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.packageName, name: "packageName", parent: name, max: 128)
            try self.validate(self.packageName, name: "packageName", parent: name, min: 1)
            try self.validate(self.packageName, name: "packageName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^.+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case packageName = "PackageName"
            case tags = "Tags"
        }
    }

    public struct CreatePackageResponse: AWSDecodableShape {
        /// The package's ARN.
        public let arn: String?
        /// The package's ID.
        public let packageId: String?
        /// The package's storage location.
        public let storageLocation: StorageLocation

        public init(arn: String? = nil, packageId: String? = nil, storageLocation: StorageLocation) {
            self.arn = arn
            self.packageId = packageId
            self.storageLocation = storageLocation
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case packageId = "PackageId"
            case storageLocation = "StorageLocation"
        }
    }

    public struct DeleteDeviceRequest: AWSEncodableShape {
        /// The device's ID.
        public let deviceId: String

        public init(deviceId: String) {
            self.deviceId = deviceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceId, key: "DeviceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 255)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDeviceResponse: AWSDecodableShape {
        /// The device's ID.
        public let deviceId: String?

        public init(deviceId: String? = nil) {
            self.deviceId = deviceId
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
        }
    }

    public struct DeletePackageRequest: AWSEncodableShape {
        /// Delete the package even if it has artifacts stored in its access point. Deletes the package's artifacts from Amazon S3.
        public let forceDelete: Bool?
        /// The package's ID.
        public let packageId: String

        public init(forceDelete: Bool? = nil, packageId: String) {
            self.forceDelete = forceDelete
            self.packageId = packageId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.forceDelete, key: "ForceDelete")
            request.encodePath(self.packageId, key: "PackageId")
        }

        public func validate(name: String) throws {
            try self.validate(self.packageId, name: "packageId", parent: name, max: 255)
            try self.validate(self.packageId, name: "packageId", parent: name, min: 1)
            try self.validate(self.packageId, name: "packageId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\/]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePackageResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeregisterPackageVersionRequest: AWSEncodableShape {
        /// An owner account.
        public let ownerAccount: String?
        /// A package ID.
        public let packageId: String
        /// A package version.
        public let packageVersion: String
        /// A patch version.
        public let patchVersion: String
        /// If the version was marked latest, the new version to maker as latest.
        public let updatedLatestPatchVersion: String?

        public init(ownerAccount: String? = nil, packageId: String, packageVersion: String, patchVersion: String, updatedLatestPatchVersion: String? = nil) {
            self.ownerAccount = ownerAccount
            self.packageId = packageId
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
            self.updatedLatestPatchVersion = updatedLatestPatchVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.ownerAccount, key: "OwnerAccount")
            request.encodePath(self.packageId, key: "PackageId")
            request.encodePath(self.packageVersion, key: "PackageVersion")
            request.encodePath(self.patchVersion, key: "PatchVersion")
            request.encodeQuery(self.updatedLatestPatchVersion, key: "UpdatedLatestPatchVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, max: 12)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, min: 1)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, pattern: "^[0-9a-z\\_]+$")
            try self.validate(self.packageId, name: "packageId", parent: name, max: 255)
            try self.validate(self.packageId, name: "packageId", parent: name, min: 1)
            try self.validate(self.packageId, name: "packageId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\/]+$")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "^([0-9]+)\\.([0-9]+)$")
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, max: 255)
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, min: 1)
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.updatedLatestPatchVersion, name: "updatedLatestPatchVersion", parent: name, max: 255)
            try self.validate(self.updatedLatestPatchVersion, name: "updatedLatestPatchVersion", parent: name, min: 1)
            try self.validate(self.updatedLatestPatchVersion, name: "updatedLatestPatchVersion", parent: name, pattern: "^[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeregisterPackageVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeApplicationInstanceDetailsRequest: AWSEncodableShape {
        /// The application instance's ID.
        public let applicationInstanceId: String

        public init(applicationInstanceId: String) {
            self.applicationInstanceId = applicationInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationInstanceId, key: "ApplicationInstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, max: 255)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, min: 1)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeApplicationInstanceDetailsResponse: AWSDecodableShape {
        /// The application instance's ID.
        public let applicationInstanceId: String?
        /// The ID of the application instance that this instance replaced.
        public let applicationInstanceIdToReplace: String?
        /// When the application instance was created.
        public let createdTime: Date?
        /// The application instance's default runtime context device.
        public let defaultRuntimeContextDevice: String?
        /// The application instance's description.
        public let description: String?
        /// Parameter overrides for the configuration manifest.
        public let manifestOverridesPayload: ManifestOverridesPayload?
        /// The application instance's configuration manifest.
        public let manifestPayload: ManifestPayload?
        /// The application instance's name.
        public let name: String?

        public init(applicationInstanceId: String? = nil, applicationInstanceIdToReplace: String? = nil, createdTime: Date? = nil, defaultRuntimeContextDevice: String? = nil, description: String? = nil, manifestOverridesPayload: ManifestOverridesPayload? = nil, manifestPayload: ManifestPayload? = nil, name: String? = nil) {
            self.applicationInstanceId = applicationInstanceId
            self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
            self.createdTime = createdTime
            self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
            self.description = description
            self.manifestOverridesPayload = manifestOverridesPayload
            self.manifestPayload = manifestPayload
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case applicationInstanceId = "ApplicationInstanceId"
            case applicationInstanceIdToReplace = "ApplicationInstanceIdToReplace"
            case createdTime = "CreatedTime"
            case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
            case description = "Description"
            case manifestOverridesPayload = "ManifestOverridesPayload"
            case manifestPayload = "ManifestPayload"
            case name = "Name"
        }
    }

    public struct DescribeApplicationInstanceRequest: AWSEncodableShape {
        /// The application instance's ID.
        public let applicationInstanceId: String

        public init(applicationInstanceId: String) {
            self.applicationInstanceId = applicationInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationInstanceId, key: "ApplicationInstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, max: 255)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, min: 1)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeApplicationInstanceResponse: AWSDecodableShape {
        /// The application instance's ID.
        public let applicationInstanceId: String?
        /// The ID of the application instance that this instance replaced.
        public let applicationInstanceIdToReplace: String?
        /// The application instance's ARN.
        public let arn: String?
        /// When the application instance was created.
        public let createdTime: Date?
        /// The device's ID.
        public let defaultRuntimeContextDevice: String?
        /// The device's bane.
        public let defaultRuntimeContextDeviceName: String?
        /// The application instance's description.
        public let description: String?
        /// The application instance's health status.
        public let healthStatus: ApplicationInstanceHealthStatus?
        /// The application instance was updated.
        public let lastUpdatedTime: Date?
        /// The application instance's name.
        public let name: String?
        /// The application instance's state.
        public let runtimeContextStates: [ReportedRuntimeContextState]?
        /// The application instance's runtime role ARN.
        public let runtimeRoleArn: String?
        /// The application instance's status.
        public let status: ApplicationInstanceStatus?
        /// The application instance's status description.
        public let statusDescription: String?
        /// The application instance's tags.
        public let tags: [String: String]?

        public init(applicationInstanceId: String? = nil, applicationInstanceIdToReplace: String? = nil, arn: String? = nil, createdTime: Date? = nil, defaultRuntimeContextDevice: String? = nil, defaultRuntimeContextDeviceName: String? = nil, description: String? = nil, healthStatus: ApplicationInstanceHealthStatus? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, runtimeContextStates: [ReportedRuntimeContextState]? = nil, runtimeRoleArn: String? = nil, status: ApplicationInstanceStatus? = nil, statusDescription: String? = nil, tags: [String: String]? = nil) {
            self.applicationInstanceId = applicationInstanceId
            self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
            self.arn = arn
            self.createdTime = createdTime
            self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
            self.defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceName
            self.description = description
            self.healthStatus = healthStatus
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.runtimeContextStates = runtimeContextStates
            self.runtimeRoleArn = runtimeRoleArn
            self.status = status
            self.statusDescription = statusDescription
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case applicationInstanceId = "ApplicationInstanceId"
            case applicationInstanceIdToReplace = "ApplicationInstanceIdToReplace"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
            case defaultRuntimeContextDeviceName = "DefaultRuntimeContextDeviceName"
            case description = "Description"
            case healthStatus = "HealthStatus"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case runtimeContextStates = "RuntimeContextStates"
            case runtimeRoleArn = "RuntimeRoleArn"
            case status = "Status"
            case statusDescription = "StatusDescription"
            case tags = "Tags"
        }
    }

    public struct DescribeDeviceJobRequest: AWSEncodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "JobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDeviceJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let createdTime: Date?
        /// The device's ARN.
        public let deviceArn: String?
        /// The device's ID.
        public let deviceId: String?
        /// The device's name.
        public let deviceName: String?
        /// The device's type.
        public let deviceType: DeviceType?
        /// For an OTA job, the target version of the device software.
        public let imageVersion: String?
        /// The job's ID.
        public let jobId: String?
        /// The job's type.
        public let jobType: JobType?
        /// The job's status.
        public let status: UpdateProgress?

        public init(createdTime: Date? = nil, deviceArn: String? = nil, deviceId: String? = nil, deviceName: String? = nil, deviceType: DeviceType? = nil, imageVersion: String? = nil, jobId: String? = nil, jobType: JobType? = nil, status: UpdateProgress? = nil) {
            self.createdTime = createdTime
            self.deviceArn = deviceArn
            self.deviceId = deviceId
            self.deviceName = deviceName
            self.deviceType = deviceType
            self.imageVersion = imageVersion
            self.jobId = jobId
            self.jobType = jobType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case deviceArn = "DeviceArn"
            case deviceId = "DeviceId"
            case deviceName = "DeviceName"
            case deviceType = "DeviceType"
            case imageVersion = "ImageVersion"
            case jobId = "JobId"
            case jobType = "JobType"
            case status = "Status"
        }
    }

    public struct DescribeDeviceRequest: AWSEncodableShape {
        /// The device's ID.
        public let deviceId: String

        public init(deviceId: String) {
            self.deviceId = deviceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceId, key: "DeviceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 255)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDeviceResponse: AWSDecodableShape {
        /// Beta software releases available for the device.
        public let alternateSoftwares: [AlternateSoftwareMetadata]?
        /// The device's ARN.
        public let arn: String?
        /// The device's maker.
        public let brand: DeviceBrand?
        /// When the device was created.
        public let createdTime: Date?
        /// The device's networking status.
        public let currentNetworkingStatus: NetworkStatus?
        /// The device's current software version.
        public let currentSoftware: String?
        /// The device's description.
        public let description: String?
        /// A device's aggregated status. Including the device's connection status, provisioning status, and lease status.
        public let deviceAggregatedStatus: DeviceAggregatedStatus?
        /// The device's connection status.
        public let deviceConnectionStatus: DeviceConnectionStatus?
        /// The device's ID.
        public let deviceId: String?
        /// The most recent beta software release.
        public let latestAlternateSoftware: String?
        /// A device's latest job. Includes the target image version, and the job status.
        public let latestDeviceJob: LatestDeviceJob?
        /// The latest software version available for the device.
        public let latestSoftware: String?
        /// The device's lease expiration time.
        public let leaseExpirationTime: Date?
        /// The device's name.
        public let name: String?
        /// The device's networking configuration.
        public let networkingConfiguration: NetworkPayload?
        /// The device's provisioning status.
        public let provisioningStatus: DeviceStatus?
        /// The device's serial number.
        public let serialNumber: String?
        /// The device's tags.
        public let tags: [String: String]?
        /// The device's type.
        public let type: DeviceType?

        public init(alternateSoftwares: [AlternateSoftwareMetadata]? = nil, arn: String? = nil, brand: DeviceBrand? = nil, createdTime: Date? = nil, currentNetworkingStatus: NetworkStatus? = nil, currentSoftware: String? = nil, description: String? = nil, deviceAggregatedStatus: DeviceAggregatedStatus? = nil, deviceConnectionStatus: DeviceConnectionStatus? = nil, deviceId: String? = nil, latestAlternateSoftware: String? = nil, latestDeviceJob: LatestDeviceJob? = nil, latestSoftware: String? = nil, leaseExpirationTime: Date? = nil, name: String? = nil, networkingConfiguration: NetworkPayload? = nil, provisioningStatus: DeviceStatus? = nil, serialNumber: String? = nil, tags: [String: String]? = nil, type: DeviceType? = nil) {
            self.alternateSoftwares = alternateSoftwares
            self.arn = arn
            self.brand = brand
            self.createdTime = createdTime
            self.currentNetworkingStatus = currentNetworkingStatus
            self.currentSoftware = currentSoftware
            self.description = description
            self.deviceAggregatedStatus = deviceAggregatedStatus
            self.deviceConnectionStatus = deviceConnectionStatus
            self.deviceId = deviceId
            self.latestAlternateSoftware = latestAlternateSoftware
            self.latestDeviceJob = latestDeviceJob
            self.latestSoftware = latestSoftware
            self.leaseExpirationTime = leaseExpirationTime
            self.name = name
            self.networkingConfiguration = networkingConfiguration
            self.provisioningStatus = provisioningStatus
            self.serialNumber = serialNumber
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case alternateSoftwares = "AlternateSoftwares"
            case arn = "Arn"
            case brand = "Brand"
            case createdTime = "CreatedTime"
            case currentNetworkingStatus = "CurrentNetworkingStatus"
            case currentSoftware = "CurrentSoftware"
            case description = "Description"
            case deviceAggregatedStatus = "DeviceAggregatedStatus"
            case deviceConnectionStatus = "DeviceConnectionStatus"
            case deviceId = "DeviceId"
            case latestAlternateSoftware = "LatestAlternateSoftware"
            case latestDeviceJob = "LatestDeviceJob"
            case latestSoftware = "LatestSoftware"
            case leaseExpirationTime = "LeaseExpirationTime"
            case name = "Name"
            case networkingConfiguration = "NetworkingConfiguration"
            case provisioningStatus = "ProvisioningStatus"
            case serialNumber = "SerialNumber"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct DescribeNodeFromTemplateJobRequest: AWSEncodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "JobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeNodeFromTemplateJobResponse: AWSDecodableShape {
        /// When the job was created.
        public let createdTime: Date
        /// The job's ID.
        public let jobId: String
        /// The job's tags.
        public let jobTags: [JobResourceTags]?
        /// When the job was updated.
        public let lastUpdatedTime: Date
        /// The node's description.
        public let nodeDescription: String?
        /// The node's name.
        public let nodeName: String
        /// The job's output package name.
        public let outputPackageName: String
        /// The job's output package version.
        public let outputPackageVersion: String
        /// The job's status.
        public let status: NodeFromTemplateJobStatus
        /// The job's status message.
        public let statusMessage: String
        /// The job's template parameters.
        public let templateParameters: [String: String]
        /// The job's template type.
        public let templateType: TemplateType

        public init(createdTime: Date, jobId: String, jobTags: [JobResourceTags]? = nil, lastUpdatedTime: Date, nodeDescription: String? = nil, nodeName: String, outputPackageName: String, outputPackageVersion: String, status: NodeFromTemplateJobStatus, statusMessage: String, templateParameters: [String: String], templateType: TemplateType) {
            self.createdTime = createdTime
            self.jobId = jobId
            self.jobTags = jobTags
            self.lastUpdatedTime = lastUpdatedTime
            self.nodeDescription = nodeDescription
            self.nodeName = nodeName
            self.outputPackageName = outputPackageName
            self.outputPackageVersion = outputPackageVersion
            self.status = status
            self.statusMessage = statusMessage
            self.templateParameters = templateParameters
            self.templateType = templateType
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case jobId = "JobId"
            case jobTags = "JobTags"
            case lastUpdatedTime = "LastUpdatedTime"
            case nodeDescription = "NodeDescription"
            case nodeName = "NodeName"
            case outputPackageName = "OutputPackageName"
            case outputPackageVersion = "OutputPackageVersion"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case templateParameters = "TemplateParameters"
            case templateType = "TemplateType"
        }
    }

    public struct DescribeNodeRequest: AWSEncodableShape {
        /// The node's ID.
        public let nodeId: String
        /// The account ID of the node's owner.
        public let ownerAccount: String?

        public init(nodeId: String, ownerAccount: String? = nil) {
            self.nodeId = nodeId
            self.ownerAccount = ownerAccount
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.nodeId, key: "NodeId")
            request.encodeQuery(self.ownerAccount, key: "OwnerAccount")
        }

        public func validate(name: String) throws {
            try self.validate(self.nodeId, name: "nodeId", parent: name, max: 255)
            try self.validate(self.nodeId, name: "nodeId", parent: name, min: 1)
            try self.validate(self.nodeId, name: "nodeId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]+$")
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, max: 12)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, min: 1)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, pattern: "^[0-9a-z\\_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeNodeResponse: AWSDecodableShape {
        /// The node's asset name.
        public let assetName: String?
        /// The node's category.
        public let category: NodeCategory
        /// When the node was created.
        public let createdTime: Date
        /// The node's description.
        public let description: String
        /// When the node was updated.
        public let lastUpdatedTime: Date
        /// The node's name.
        public let name: String
        /// The node's ID.
        public let nodeId: String
        /// The node's interface.
        public let nodeInterface: NodeInterface
        /// The account ID of the node's owner.
        public let ownerAccount: String
        /// The node's ARN.
        public let packageArn: String?
        /// The node's package ID.
        public let packageId: String
        /// The node's package name.
        public let packageName: String
        /// The node's package version.
        public let packageVersion: String
        /// The node's patch version.
        public let patchVersion: String

        public init(assetName: String? = nil, category: NodeCategory, createdTime: Date, description: String, lastUpdatedTime: Date, name: String, nodeId: String, nodeInterface: NodeInterface, ownerAccount: String, packageArn: String? = nil, packageId: String, packageName: String, packageVersion: String, patchVersion: String) {
            self.assetName = assetName
            self.category = category
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.nodeId = nodeId
            self.nodeInterface = nodeInterface
            self.ownerAccount = ownerAccount
            self.packageArn = packageArn
            self.packageId = packageId
            self.packageName = packageName
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }

        private enum CodingKeys: String, CodingKey {
            case assetName = "AssetName"
            case category = "Category"
            case createdTime = "CreatedTime"
            case description = "Description"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case nodeId = "NodeId"
            case nodeInterface = "NodeInterface"
            case ownerAccount = "OwnerAccount"
            case packageArn = "PackageArn"
            case packageId = "PackageId"
            case packageName = "PackageName"
            case packageVersion = "PackageVersion"
            case patchVersion = "PatchVersion"
        }
    }

    public struct DescribePackageImportJobRequest: AWSEncodableShape {
        /// The job's ID.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "JobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePackageImportJobResponse: AWSDecodableShape {
        /// The job's client token.
        public let clientToken: String?
        /// When the job was created.
        public let createdTime: Date
        /// The job's input config.
        public let inputConfig: PackageImportJobInputConfig
        /// The job's ID.
        public let jobId: String
        /// The job's tags.
        public let jobTags: [JobResourceTags]?
        /// The job's type.
        public let jobType: PackageImportJobType
        /// When the job was updated.
        public let lastUpdatedTime: Date
        /// The job's output.
        public let output: PackageImportJobOutput
        /// The job's output config.
        public let outputConfig: PackageImportJobOutputConfig
        /// The job's status.
        public let status: PackageImportJobStatus
        /// The job's status message.
        public let statusMessage: String

        public init(clientToken: String? = nil, createdTime: Date, inputConfig: PackageImportJobInputConfig, jobId: String, jobTags: [JobResourceTags]? = nil, jobType: PackageImportJobType, lastUpdatedTime: Date, output: PackageImportJobOutput, outputConfig: PackageImportJobOutputConfig, status: PackageImportJobStatus, statusMessage: String) {
            self.clientToken = clientToken
            self.createdTime = createdTime
            self.inputConfig = inputConfig
            self.jobId = jobId
            self.jobTags = jobTags
            self.jobType = jobType
            self.lastUpdatedTime = lastUpdatedTime
            self.output = output
            self.outputConfig = outputConfig
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case createdTime = "CreatedTime"
            case inputConfig = "InputConfig"
            case jobId = "JobId"
            case jobTags = "JobTags"
            case jobType = "JobType"
            case lastUpdatedTime = "LastUpdatedTime"
            case output = "Output"
            case outputConfig = "OutputConfig"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct DescribePackageRequest: AWSEncodableShape {
        /// The package's ID.
        public let packageId: String

        public init(packageId: String) {
            self.packageId = packageId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.packageId, key: "PackageId")
        }

        public func validate(name: String) throws {
            try self.validate(self.packageId, name: "packageId", parent: name, max: 255)
            try self.validate(self.packageId, name: "packageId", parent: name, min: 1)
            try self.validate(self.packageId, name: "packageId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\/]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePackageResponse: AWSDecodableShape {
        /// The package's ARN.
        public let arn: String
        /// When the package was created.
        public let createdTime: Date
        /// The package's ID.
        public let packageId: String
        /// The package's name.
        public let packageName: String
        /// ARNs of accounts that have read access to the package.
        public let readAccessPrincipalArns: [String]?
        /// The package's storage location.
        public let storageLocation: StorageLocation
        /// The package's tags.
        public let tags: [String: String]
        /// ARNs of accounts that have write access to the package.
        public let writeAccessPrincipalArns: [String]?

        public init(arn: String, createdTime: Date, packageId: String, packageName: String, readAccessPrincipalArns: [String]? = nil, storageLocation: StorageLocation, tags: [String: String], writeAccessPrincipalArns: [String]? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.packageId = packageId
            self.packageName = packageName
            self.readAccessPrincipalArns = readAccessPrincipalArns
            self.storageLocation = storageLocation
            self.tags = tags
            self.writeAccessPrincipalArns = writeAccessPrincipalArns
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case packageId = "PackageId"
            case packageName = "PackageName"
            case readAccessPrincipalArns = "ReadAccessPrincipalArns"
            case storageLocation = "StorageLocation"
            case tags = "Tags"
            case writeAccessPrincipalArns = "WriteAccessPrincipalArns"
        }
    }

    public struct DescribePackageVersionRequest: AWSEncodableShape {
        /// The version's owner account.
        public let ownerAccount: String?
        /// The version's ID.
        public let packageId: String
        /// The version's version.
        public let packageVersion: String
        /// The version's patch version.
        public let patchVersion: String?

        public init(ownerAccount: String? = nil, packageId: String, packageVersion: String, patchVersion: String? = nil) {
            self.ownerAccount = ownerAccount
            self.packageId = packageId
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.ownerAccount, key: "OwnerAccount")
            request.encodePath(self.packageId, key: "PackageId")
            request.encodePath(self.packageVersion, key: "PackageVersion")
            request.encodeQuery(self.patchVersion, key: "PatchVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, max: 12)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, min: 1)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, pattern: "^[0-9a-z\\_]+$")
            try self.validate(self.packageId, name: "packageId", parent: name, max: 255)
            try self.validate(self.packageId, name: "packageId", parent: name, min: 1)
            try self.validate(self.packageId, name: "packageId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\/]+$")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "^([0-9]+)\\.([0-9]+)$")
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, max: 255)
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, min: 1)
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, pattern: "^[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePackageVersionResponse: AWSDecodableShape {
        /// Whether the version is the latest available.
        public let isLatestPatch: Bool
        /// The account ID of the version's owner.
        public let ownerAccount: String?
        /// The ARN of the package.
        public let packageArn: String?
        /// The version's ID.
        public let packageId: String
        /// The version's name.
        public let packageName: String
        /// The version's version.
        public let packageVersion: String
        /// The version's patch version.
        public let patchVersion: String
        /// The version's registered time.
        public let registeredTime: Date?
        /// The version's status.
        public let status: PackageVersionStatus
        /// The version's status description.
        public let statusDescription: String?

        public init(isLatestPatch: Bool, ownerAccount: String? = nil, packageArn: String? = nil, packageId: String, packageName: String, packageVersion: String, patchVersion: String, registeredTime: Date? = nil, status: PackageVersionStatus, statusDescription: String? = nil) {
            self.isLatestPatch = isLatestPatch
            self.ownerAccount = ownerAccount
            self.packageArn = packageArn
            self.packageId = packageId
            self.packageName = packageName
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
            self.registeredTime = registeredTime
            self.status = status
            self.statusDescription = statusDescription
        }

        private enum CodingKeys: String, CodingKey {
            case isLatestPatch = "IsLatestPatch"
            case ownerAccount = "OwnerAccount"
            case packageArn = "PackageArn"
            case packageId = "PackageId"
            case packageName = "PackageName"
            case packageVersion = "PackageVersion"
            case patchVersion = "PatchVersion"
            case registeredTime = "RegisteredTime"
            case status = "Status"
            case statusDescription = "StatusDescription"
        }
    }

    public struct Device: AWSDecodableShape {
        /// The device's maker.
        public let brand: DeviceBrand?
        /// When the device was created.
        public let createdTime: Date?
        /// A device's current software.
        public let currentSoftware: String?
        /// A description for the device.
        public let description: String?
        /// A device's aggregated status. Including the device's connection status, provisioning status, and lease status.
        public let deviceAggregatedStatus: DeviceAggregatedStatus?
        /// The device's ID.
        public let deviceId: String?
        /// When the device was updated.
        public let lastUpdatedTime: Date?
        /// A device's latest job. Includes the target image version, and the update job status.
        public let latestDeviceJob: LatestDeviceJob?
        /// The device's lease expiration time.
        public let leaseExpirationTime: Date?
        /// The device's name.
        public let name: String?
        /// The device's provisioning status.
        public let provisioningStatus: DeviceStatus?
        /// The device's tags.
        public let tags: [String: String]?
        /// The device's type.
        public let type: DeviceType?

        public init(brand: DeviceBrand? = nil, createdTime: Date? = nil, currentSoftware: String? = nil, description: String? = nil, deviceAggregatedStatus: DeviceAggregatedStatus? = nil, deviceId: String? = nil, lastUpdatedTime: Date? = nil, latestDeviceJob: LatestDeviceJob? = nil, leaseExpirationTime: Date? = nil, name: String? = nil, provisioningStatus: DeviceStatus? = nil, tags: [String: String]? = nil, type: DeviceType? = nil) {
            self.brand = brand
            self.createdTime = createdTime
            self.currentSoftware = currentSoftware
            self.description = description
            self.deviceAggregatedStatus = deviceAggregatedStatus
            self.deviceId = deviceId
            self.lastUpdatedTime = lastUpdatedTime
            self.latestDeviceJob = latestDeviceJob
            self.leaseExpirationTime = leaseExpirationTime
            self.name = name
            self.provisioningStatus = provisioningStatus
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case brand = "Brand"
            case createdTime = "CreatedTime"
            case currentSoftware = "CurrentSoftware"
            case description = "Description"
            case deviceAggregatedStatus = "DeviceAggregatedStatus"
            case deviceId = "DeviceId"
            case lastUpdatedTime = "LastUpdatedTime"
            case latestDeviceJob = "LatestDeviceJob"
            case leaseExpirationTime = "LeaseExpirationTime"
            case name = "Name"
            case provisioningStatus = "ProvisioningStatus"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct DeviceJob: AWSDecodableShape {
        /// When the job was created.
        public let createdTime: Date?
        /// The ID of the target device.
        public let deviceId: String?
        /// The name of the target device
        public let deviceName: String?
        /// The job's ID.
        public let jobId: String?
        /// The job's type.
        public let jobType: JobType?

        public init(createdTime: Date? = nil, deviceId: String? = nil, deviceName: String? = nil, jobId: String? = nil, jobType: JobType? = nil) {
            self.createdTime = createdTime
            self.deviceId = deviceId
            self.deviceName = deviceName
            self.jobId = jobId
            self.jobType = jobType
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case deviceId = "DeviceId"
            case deviceName = "DeviceName"
            case jobId = "JobId"
            case jobType = "JobType"
        }
    }

    public struct DeviceJobConfig: AWSEncodableShape {
        /// A configuration for an over-the-air (OTA) upgrade. Required for OTA jobs.
        public let otaJobConfig: OTAJobConfig?

        public init(otaJobConfig: OTAJobConfig? = nil) {
            self.otaJobConfig = otaJobConfig
        }

        public func validate(name: String) throws {
            try self.otaJobConfig?.validate(name: "\(name).otaJobConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case otaJobConfig = "OTAJobConfig"
        }
    }

    public struct EthernetPayload: AWSEncodableShape & AWSDecodableShape {
        /// How the device gets an IP address.
        public let connectionType: ConnectionType
        /// Network configuration for a static IP connection.
        public let staticIpConnectionInfo: StaticIpConnectionInfo?

        public init(connectionType: ConnectionType, staticIpConnectionInfo: StaticIpConnectionInfo? = nil) {
            self.connectionType = connectionType
            self.staticIpConnectionInfo = staticIpConnectionInfo
        }

        public func validate(name: String) throws {
            try self.staticIpConnectionInfo?.validate(name: "\(name).staticIpConnectionInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionType = "ConnectionType"
            case staticIpConnectionInfo = "StaticIpConnectionInfo"
        }
    }

    public struct EthernetStatus: AWSDecodableShape {
        /// The device's connection status.
        public let connectionStatus: NetworkConnectionStatus?
        /// The device's physical address.
        public let hwAddress: String?
        /// The device's IP address.
        public let ipAddress: String?

        public init(connectionStatus: NetworkConnectionStatus? = nil, hwAddress: String? = nil, ipAddress: String? = nil) {
            self.connectionStatus = connectionStatus
            self.hwAddress = hwAddress
            self.ipAddress = ipAddress
        }

        private enum CodingKeys: String, CodingKey {
            case connectionStatus = "ConnectionStatus"
            case hwAddress = "HwAddress"
            case ipAddress = "IpAddress"
        }
    }

    public struct Job: AWSDecodableShape {
        /// The target device's ID.
        public let deviceId: String?
        /// The job's ID.
        public let jobId: String?

        public init(deviceId: String? = nil, jobId: String? = nil) {
            self.deviceId = deviceId
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case jobId = "JobId"
        }
    }

    public struct JobResourceTags: AWSEncodableShape & AWSDecodableShape {
        /// The job's type.
        public let resourceType: JobResourceType
        /// The job's tags.
        public let tags: [String: String]

        public init(resourceType: JobResourceType, tags: [String: String]) {
            self.resourceType = resourceType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^.+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "ResourceType"
            case tags = "Tags"
        }
    }

    public struct LatestDeviceJob: AWSDecodableShape {
        /// The target version of the device software.
        public let imageVersion: String?
        /// The job's type.
        public let jobType: JobType?
        /// Status of the latest device job.
        public let status: UpdateProgress?

        public init(imageVersion: String? = nil, jobType: JobType? = nil, status: UpdateProgress? = nil) {
            self.imageVersion = imageVersion
            self.jobType = jobType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case imageVersion = "ImageVersion"
            case jobType = "JobType"
            case status = "Status"
        }
    }

    public struct ListApplicationInstanceDependenciesRequest: AWSEncodableShape {
        /// The application instance's ID.
        public let applicationInstanceId: String
        /// The maximum number of application instance dependencies to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(applicationInstanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationInstanceId = applicationInstanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationInstanceId, key: "ApplicationInstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, max: 255)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, min: 1)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationInstanceDependenciesResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of package objects.
        public let packageObjects: [PackageObject]?

        public init(nextToken: String? = nil, packageObjects: [PackageObject]? = nil) {
            self.nextToken = nextToken
            self.packageObjects = packageObjects
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case packageObjects = "PackageObjects"
        }
    }

    public struct ListApplicationInstanceNodeInstancesRequest: AWSEncodableShape {
        /// The node instances' application instance ID.
        public let applicationInstanceId: String
        /// The maximum number of node instances to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(applicationInstanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationInstanceId = applicationInstanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationInstanceId, key: "ApplicationInstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, max: 255)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, min: 1)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationInstanceNodeInstancesResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of node instances.
        public let nodeInstances: [NodeInstance]?

        public init(nextToken: String? = nil, nodeInstances: [NodeInstance]? = nil) {
            self.nextToken = nextToken
            self.nodeInstances = nodeInstances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case nodeInstances = "NodeInstances"
        }
    }

    public struct ListApplicationInstancesRequest: AWSEncodableShape {
        /// The application instances' device ID.
        public let deviceId: String?
        /// The maximum number of application instances to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// Only include instances with a specific status.
        public let statusFilter: StatusFilter?

        public init(deviceId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, statusFilter: StatusFilter? = nil) {
            self.deviceId = deviceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.statusFilter = statusFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.deviceId, key: "deviceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.statusFilter, key: "statusFilter")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 255)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationInstancesResponse: AWSDecodableShape {
        /// A list of application instances.
        public let applicationInstances: [ApplicationInstance]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(applicationInstances: [ApplicationInstance]? = nil, nextToken: String? = nil) {
            self.applicationInstances = applicationInstances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationInstances = "ApplicationInstances"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevicesJobsRequest: AWSEncodableShape {
        /// Filter results by the job's target device ID.
        public let deviceId: String?
        /// The maximum number of device jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(deviceId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.deviceId = deviceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.deviceId, key: "DeviceId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 255)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDevicesJobsResponse: AWSDecodableShape {
        /// A list of jobs.
        public let deviceJobs: [DeviceJob]?
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(deviceJobs: [DeviceJob]? = nil, nextToken: String? = nil) {
            self.deviceJobs = deviceJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deviceJobs = "DeviceJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevicesRequest: AWSEncodableShape {
        /// Filter based on a device's status.
        public let deviceAggregatedStatusFilter: DeviceAggregatedStatus?
        /// The maximum number of devices to return in one page of results.
        public let maxResults: Int?
        /// Filter based on device's name. Prefixes supported.
        public let nameFilter: String?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The target column to be sorted on. Default column sort is CREATED_TIME.
        public let sortBy: ListDevicesSortBy?
        /// The sorting order for the returned list. SortOrder is DESCENDING by default based on CREATED_TIME. Otherwise, SortOrder is ASCENDING.
        public let sortOrder: SortOrder?

        public init(deviceAggregatedStatusFilter: DeviceAggregatedStatus? = nil, maxResults: Int? = nil, nameFilter: String? = nil, nextToken: String? = nil, sortBy: ListDevicesSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.deviceAggregatedStatusFilter = deviceAggregatedStatusFilter
            self.maxResults = maxResults
            self.nameFilter = nameFilter
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.deviceAggregatedStatusFilter, key: "DeviceAggregatedStatusFilter")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nameFilter, key: "NameFilter")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.sortBy, key: "SortBy")
            request.encodeQuery(self.sortOrder, key: "SortOrder")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDevicesResponse: AWSDecodableShape {
        /// A list of devices.
        public let devices: [Device]
        /// A pagination token that's included if more results are available.
        public let nextToken: String?

        public init(devices: [Device], nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "Devices"
            case nextToken = "NextToken"
        }
    }

    public struct ListNodeFromTemplateJobsRequest: AWSEncodableShape {
        /// The maximum number of node from template jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNodeFromTemplateJobsResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of jobs.
        public let nodeFromTemplateJobs: [NodeFromTemplateJob]

        public init(nextToken: String? = nil, nodeFromTemplateJobs: [NodeFromTemplateJob]) {
            self.nextToken = nextToken
            self.nodeFromTemplateJobs = nodeFromTemplateJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case nodeFromTemplateJobs = "NodeFromTemplateJobs"
        }
    }

    public struct ListNodesRequest: AWSEncodableShape {
        /// Search for nodes by category.
        public let category: NodeCategory?
        /// The maximum number of nodes to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// Search for nodes by the account ID of the nodes' owner.
        public let ownerAccount: String?
        /// Search for nodes by name.
        public let packageName: String?
        /// Search for nodes by version.
        public let packageVersion: String?
        /// Search for nodes by patch version.
        public let patchVersion: String?

        public init(category: NodeCategory? = nil, maxResults: Int? = nil, nextToken: String? = nil, ownerAccount: String? = nil, packageName: String? = nil, packageVersion: String? = nil, patchVersion: String? = nil) {
            self.category = category
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ownerAccount = ownerAccount
            self.packageName = packageName
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.category, key: "category")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.ownerAccount, key: "ownerAccount")
            request.encodeQuery(self.packageName, key: "packageName")
            request.encodeQuery(self.packageVersion, key: "packageVersion")
            request.encodeQuery(self.patchVersion, key: "patchVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, max: 12)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, min: 1)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, pattern: "^[0-9a-z\\_]+$")
            try self.validate(self.packageName, name: "packageName", parent: name, max: 128)
            try self.validate(self.packageName, name: "packageName", parent: name, min: 1)
            try self.validate(self.packageName, name: "packageName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "^([0-9]+)\\.([0-9]+)$")
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, max: 255)
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, min: 1)
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, pattern: "^[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNodesResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of nodes.
        public let nodes: [Node]?

        public init(nextToken: String? = nil, nodes: [Node]? = nil) {
            self.nextToken = nextToken
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case nodes = "Nodes"
        }
    }

    public struct ListPackageImportJobsRequest: AWSEncodableShape {
        /// The maximum number of package import jobs to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackageImportJobsResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of package import jobs.
        public let packageImportJobs: [PackageImportJob]

        public init(nextToken: String? = nil, packageImportJobs: [PackageImportJob]) {
            self.nextToken = nextToken
            self.packageImportJobs = packageImportJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case packageImportJobs = "PackageImportJobs"
        }
    }

    public struct ListPackagesRequest: AWSEncodableShape {
        /// The maximum number of packages to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackagesResponse: AWSDecodableShape {
        /// A pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of packages.
        public let packages: [PackageListItem]?

        public init(nextToken: String? = nil, packages: [PackageListItem]? = nil) {
            self.nextToken = nextToken
            self.packages = packages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case packages = "Packages"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The resource's ARN.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct NetworkPayload: AWSEncodableShape & AWSDecodableShape {
        /// Settings for Ethernet port 0.
        public let ethernet0: EthernetPayload?
        /// Settings for Ethernet port 1.
        public let ethernet1: EthernetPayload?
        /// Network time protocol (NTP) server settings.
        public let ntp: NtpPayload?

        public init(ethernet0: EthernetPayload? = nil, ethernet1: EthernetPayload? = nil, ntp: NtpPayload? = nil) {
            self.ethernet0 = ethernet0
            self.ethernet1 = ethernet1
            self.ntp = ntp
        }

        public func validate(name: String) throws {
            try self.ethernet0?.validate(name: "\(name).ethernet0")
            try self.ethernet1?.validate(name: "\(name).ethernet1")
            try self.ntp?.validate(name: "\(name).ntp")
        }

        private enum CodingKeys: String, CodingKey {
            case ethernet0 = "Ethernet0"
            case ethernet1 = "Ethernet1"
            case ntp = "Ntp"
        }
    }

    public struct NetworkStatus: AWSDecodableShape {
        /// The status of Ethernet port 0.
        public let ethernet0Status: EthernetStatus?
        /// The status of Ethernet port 1.
        public let ethernet1Status: EthernetStatus?
        /// When the network status changed.
        public let lastUpdatedTime: Date?
        /// Details about a network time protocol (NTP) server connection.
        public let ntpStatus: NtpStatus?

        public init(ethernet0Status: EthernetStatus? = nil, ethernet1Status: EthernetStatus? = nil, lastUpdatedTime: Date? = nil, ntpStatus: NtpStatus? = nil) {
            self.ethernet0Status = ethernet0Status
            self.ethernet1Status = ethernet1Status
            self.lastUpdatedTime = lastUpdatedTime
            self.ntpStatus = ntpStatus
        }

        private enum CodingKeys: String, CodingKey {
            case ethernet0Status = "Ethernet0Status"
            case ethernet1Status = "Ethernet1Status"
            case lastUpdatedTime = "LastUpdatedTime"
            case ntpStatus = "NtpStatus"
        }
    }

    public struct Node: AWSDecodableShape {
        /// The node's category.
        public let category: NodeCategory
        /// When the node was created.
        public let createdTime: Date
        /// The node's description.
        public let description: String?
        /// The node's name.
        public let name: String
        /// The node's ID.
        public let nodeId: String
        /// The account ID of the node's owner.
        public let ownerAccount: String?
        /// The node's ARN.
        public let packageArn: String?
        /// The node's package ID.
        public let packageId: String
        /// The node's package name.
        public let packageName: String
        /// The node's package version.
        public let packageVersion: String
        /// The node's patch version.
        public let patchVersion: String

        public init(category: NodeCategory, createdTime: Date, description: String? = nil, name: String, nodeId: String, ownerAccount: String? = nil, packageArn: String? = nil, packageId: String, packageName: String, packageVersion: String, patchVersion: String) {
            self.category = category
            self.createdTime = createdTime
            self.description = description
            self.name = name
            self.nodeId = nodeId
            self.ownerAccount = ownerAccount
            self.packageArn = packageArn
            self.packageId = packageId
            self.packageName = packageName
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case createdTime = "CreatedTime"
            case description = "Description"
            case name = "Name"
            case nodeId = "NodeId"
            case ownerAccount = "OwnerAccount"
            case packageArn = "PackageArn"
            case packageId = "PackageId"
            case packageName = "PackageName"
            case packageVersion = "PackageVersion"
            case patchVersion = "PatchVersion"
        }
    }

    public struct NodeFromTemplateJob: AWSDecodableShape {
        /// When the job was created.
        public let createdTime: Date?
        /// The job's ID.
        public let jobId: String?
        /// The node's name.
        public let nodeName: String?
        /// The job's status.
        public let status: NodeFromTemplateJobStatus?
        /// The job's status message.
        public let statusMessage: String?
        /// The job's template type.
        public let templateType: TemplateType?

        public init(createdTime: Date? = nil, jobId: String? = nil, nodeName: String? = nil, status: NodeFromTemplateJobStatus? = nil, statusMessage: String? = nil, templateType: TemplateType? = nil) {
            self.createdTime = createdTime
            self.jobId = jobId
            self.nodeName = nodeName
            self.status = status
            self.statusMessage = statusMessage
            self.templateType = templateType
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case jobId = "JobId"
            case nodeName = "NodeName"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case templateType = "TemplateType"
        }
    }

    public struct NodeInputPort: AWSDecodableShape {
        /// The input port's default value.
        public let defaultValue: String?
        /// The input port's description.
        public let description: String?
        /// The input port's max connections.
        public let maxConnections: Int?
        /// The input port's name.
        public let name: String?
        /// The input port's type.
        public let type: PortType?

        public init(defaultValue: String? = nil, description: String? = nil, maxConnections: Int? = nil, name: String? = nil, type: PortType? = nil) {
            self.defaultValue = defaultValue
            self.description = description
            self.maxConnections = maxConnections
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case description = "Description"
            case maxConnections = "MaxConnections"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct NodeInstance: AWSDecodableShape {
        /// The instance's current status.
        public let currentStatus: NodeInstanceStatus
        /// The node's ID.
        public let nodeId: String?
        /// The instance's ID.
        public let nodeInstanceId: String
        /// The instance's name.
        public let nodeName: String?
        /// The instance's package name.
        public let packageName: String?
        /// The instance's package patch version.
        public let packagePatchVersion: String?
        /// The instance's package version.
        public let packageVersion: String?

        public init(currentStatus: NodeInstanceStatus, nodeId: String? = nil, nodeInstanceId: String, nodeName: String? = nil, packageName: String? = nil, packagePatchVersion: String? = nil, packageVersion: String? = nil) {
            self.currentStatus = currentStatus
            self.nodeId = nodeId
            self.nodeInstanceId = nodeInstanceId
            self.nodeName = nodeName
            self.packageName = packageName
            self.packagePatchVersion = packagePatchVersion
            self.packageVersion = packageVersion
        }

        private enum CodingKeys: String, CodingKey {
            case currentStatus = "CurrentStatus"
            case nodeId = "NodeId"
            case nodeInstanceId = "NodeInstanceId"
            case nodeName = "NodeName"
            case packageName = "PackageName"
            case packagePatchVersion = "PackagePatchVersion"
            case packageVersion = "PackageVersion"
        }
    }

    public struct NodeInterface: AWSDecodableShape {
        /// The node interface's inputs.
        public let inputs: [NodeInputPort]
        /// The node interface's outputs.
        public let outputs: [NodeOutputPort]

        public init(inputs: [NodeInputPort], outputs: [NodeOutputPort]) {
            self.inputs = inputs
            self.outputs = outputs
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case outputs = "Outputs"
        }
    }

    public struct NodeOutputPort: AWSDecodableShape {
        /// The output port's description.
        public let description: String?
        /// The output port's name.
        public let name: String?
        /// The output port's type.
        public let type: PortType?

        public init(description: String? = nil, name: String? = nil, type: PortType? = nil) {
            self.description = description
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct NodeSignal: AWSEncodableShape {
        /// The camera node's name, from the application manifest.
        public let nodeInstanceId: String
        /// The signal value.
        public let signal: NodeSignalValue

        public init(nodeInstanceId: String, signal: NodeSignalValue) {
            self.nodeInstanceId = nodeInstanceId
            self.signal = signal
        }

        public func validate(name: String) throws {
            try self.validate(self.nodeInstanceId, name: "nodeInstanceId", parent: name, max: 128)
            try self.validate(self.nodeInstanceId, name: "nodeInstanceId", parent: name, min: 1)
            try self.validate(self.nodeInstanceId, name: "nodeInstanceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case nodeInstanceId = "NodeInstanceId"
            case signal = "Signal"
        }
    }

    public struct NtpPayload: AWSEncodableShape & AWSDecodableShape {
        /// NTP servers to use, in order of preference.
        public let ntpServers: [String]

        public init(ntpServers: [String]) {
            self.ntpServers = ntpServers
        }

        public func validate(name: String) throws {
            try self.ntpServers.forEach {
                try validate($0, name: "ntpServers[]", parent: name, max: 255)
                try validate($0, name: "ntpServers[]", parent: name, min: 1)
                try validate($0, name: "ntpServers[]", parent: name, pattern: "(^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$)|(^((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d))(:(6553[0-5]|655[0-2]\\d|65[0-4]\\d{2}|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}))?$)")
            }
            try self.validate(self.ntpServers, name: "ntpServers", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case ntpServers = "NtpServers"
        }
    }

    public struct NtpStatus: AWSDecodableShape {
        /// The connection's status.
        public let connectionStatus: NetworkConnectionStatus?
        /// The IP address of the server.
        public let ipAddress: String?
        /// The domain name of the server.
        public let ntpServerName: String?

        public init(connectionStatus: NetworkConnectionStatus? = nil, ipAddress: String? = nil, ntpServerName: String? = nil) {
            self.connectionStatus = connectionStatus
            self.ipAddress = ipAddress
            self.ntpServerName = ntpServerName
        }

        private enum CodingKeys: String, CodingKey {
            case connectionStatus = "ConnectionStatus"
            case ipAddress = "IpAddress"
            case ntpServerName = "NtpServerName"
        }
    }

    public struct OTAJobConfig: AWSEncodableShape {
        /// Whether to apply the update if it is a major version change.
        public let allowMajorVersionUpdate: Bool?
        /// The target version of the device software.
        public let imageVersion: String

        public init(allowMajorVersionUpdate: Bool? = nil, imageVersion: String) {
            self.allowMajorVersionUpdate = allowMajorVersionUpdate
            self.imageVersion = imageVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.imageVersion, name: "imageVersion", parent: name, max: 255)
            try self.validate(self.imageVersion, name: "imageVersion", parent: name, min: 1)
            try self.validate(self.imageVersion, name: "imageVersion", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowMajorVersionUpdate = "AllowMajorVersionUpdate"
            case imageVersion = "ImageVersion"
        }
    }

    public struct OutPutS3Location: AWSDecodableShape {
        /// The object's bucket.
        public let bucketName: String
        /// The object's key.
        public let objectKey: String

        public init(bucketName: String, objectKey: String) {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case objectKey = "ObjectKey"
        }
    }

    public struct PackageImportJob: AWSDecodableShape {
        /// When the job was created.
        public let createdTime: Date?
        /// The job's ID.
        public let jobId: String?
        /// The job's type.
        public let jobType: PackageImportJobType?
        /// When the job was updated.
        public let lastUpdatedTime: Date?
        /// The job's status.
        public let status: PackageImportJobStatus?
        /// The job's status message.
        public let statusMessage: String?

        public init(createdTime: Date? = nil, jobId: String? = nil, jobType: PackageImportJobType? = nil, lastUpdatedTime: Date? = nil, status: PackageImportJobStatus? = nil, statusMessage: String? = nil) {
            self.createdTime = createdTime
            self.jobId = jobId
            self.jobType = jobType
            self.lastUpdatedTime = lastUpdatedTime
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case jobId = "JobId"
            case jobType = "JobType"
            case lastUpdatedTime = "LastUpdatedTime"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct PackageImportJobInputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The package version's input configuration.
        public let packageVersionInputConfig: PackageVersionInputConfig?

        public init(packageVersionInputConfig: PackageVersionInputConfig? = nil) {
            self.packageVersionInputConfig = packageVersionInputConfig
        }

        public func validate(name: String) throws {
            try self.packageVersionInputConfig?.validate(name: "\(name).packageVersionInputConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case packageVersionInputConfig = "PackageVersionInputConfig"
        }
    }

    public struct PackageImportJobOutput: AWSDecodableShape {
        /// The package's output location.
        public let outputS3Location: OutPutS3Location
        /// The package's ID.
        public let packageId: String
        /// The package's version.
        public let packageVersion: String
        /// The package's patch version.
        public let patchVersion: String

        public init(outputS3Location: OutPutS3Location, packageId: String, packageVersion: String, patchVersion: String) {
            self.outputS3Location = outputS3Location
            self.packageId = packageId
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }

        private enum CodingKeys: String, CodingKey {
            case outputS3Location = "OutputS3Location"
            case packageId = "PackageId"
            case packageVersion = "PackageVersion"
            case patchVersion = "PatchVersion"
        }
    }

    public struct PackageImportJobOutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The package version's output configuration.
        public let packageVersionOutputConfig: PackageVersionOutputConfig?

        public init(packageVersionOutputConfig: PackageVersionOutputConfig? = nil) {
            self.packageVersionOutputConfig = packageVersionOutputConfig
        }

        public func validate(name: String) throws {
            try self.packageVersionOutputConfig?.validate(name: "\(name).packageVersionOutputConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case packageVersionOutputConfig = "PackageVersionOutputConfig"
        }
    }

    public struct PackageListItem: AWSDecodableShape {
        /// The package's ARN.
        public let arn: String?
        /// When the package was created.
        public let createdTime: Date?
        /// The package's ID.
        public let packageId: String?
        /// The package's name.
        public let packageName: String?
        /// The package's tags.
        public let tags: [String: String]?

        public init(arn: String? = nil, createdTime: Date? = nil, packageId: String? = nil, packageName: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.packageId = packageId
            self.packageName = packageName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case packageId = "PackageId"
            case packageName = "PackageName"
            case tags = "Tags"
        }
    }

    public struct PackageObject: AWSDecodableShape {
        /// The object's name.
        public let name: String
        /// The object's package version.
        public let packageVersion: String
        /// The object's patch version.
        public let patchVersion: String

        public init(name: String, packageVersion: String, patchVersion: String) {
            self.name = name
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case packageVersion = "PackageVersion"
            case patchVersion = "PatchVersion"
        }
    }

    public struct PackageVersionInputConfig: AWSEncodableShape & AWSDecodableShape {
        /// A location in Amazon S3.
        public let s3Location: S3Location

        public init(s3Location: S3Location) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.s3Location.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "S3Location"
        }
    }

    public struct PackageVersionOutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates that the version is recommended for all users.
        public let markLatest: Bool?
        /// The output's package name.
        public let packageName: String
        /// The output's package version.
        public let packageVersion: String

        public init(markLatest: Bool? = nil, packageName: String, packageVersion: String) {
            self.markLatest = markLatest
            self.packageName = packageName
            self.packageVersion = packageVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.packageName, name: "packageName", parent: name, max: 128)
            try self.validate(self.packageName, name: "packageName", parent: name, min: 1)
            try self.validate(self.packageName, name: "packageName", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "^([0-9]+)\\.([0-9]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case markLatest = "MarkLatest"
            case packageName = "PackageName"
            case packageVersion = "PackageVersion"
        }
    }

    public struct ProvisionDeviceRequest: AWSEncodableShape {
        /// A description for the device.
        public let description: String?
        /// A name for the device.
        public let name: String
        /// A networking configuration for the device.
        public let networkingConfiguration: NetworkPayload?
        /// Tags for the device.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, networkingConfiguration: NetworkPayload? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.networkingConfiguration = networkingConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.networkingConfiguration?.validate(name: "\(name).networkingConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^.+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case networkingConfiguration = "NetworkingConfiguration"
            case tags = "Tags"
        }
    }

    public struct ProvisionDeviceResponse: AWSDecodableShape {
        /// The device's ARN.
        public let arn: String
        /// The device's configuration bundle.
        public let certificates: AWSBase64Data?
        /// The device's ID.
        public let deviceId: String?
        /// The device's IoT thing name.
        public let iotThingName: String?
        /// The device's status.
        public let status: DeviceStatus

        public init(arn: String, certificates: AWSBase64Data? = nil, deviceId: String? = nil, iotThingName: String? = nil, status: DeviceStatus) {
            self.arn = arn
            self.certificates = certificates
            self.deviceId = deviceId
            self.iotThingName = iotThingName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case certificates = "Certificates"
            case deviceId = "DeviceId"
            case iotThingName = "IotThingName"
            case status = "Status"
        }
    }

    public struct RegisterPackageVersionRequest: AWSEncodableShape {
        /// Whether to mark the new version as the latest version.
        public let markLatest: Bool?
        /// An owner account.
        public let ownerAccount: String?
        /// A package ID.
        public let packageId: String
        /// A package version.
        public let packageVersion: String
        /// A patch version.
        public let patchVersion: String

        public init(markLatest: Bool? = nil, ownerAccount: String? = nil, packageId: String, packageVersion: String, patchVersion: String) {
            self.markLatest = markLatest
            self.ownerAccount = ownerAccount
            self.packageId = packageId
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.markLatest, forKey: .markLatest)
            try container.encodeIfPresent(self.ownerAccount, forKey: .ownerAccount)
            request.encodePath(self.packageId, key: "PackageId")
            request.encodePath(self.packageVersion, key: "PackageVersion")
            request.encodePath(self.patchVersion, key: "PatchVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, max: 12)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, min: 1)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, pattern: "^[0-9a-z\\_]+$")
            try self.validate(self.packageId, name: "packageId", parent: name, max: 255)
            try self.validate(self.packageId, name: "packageId", parent: name, min: 1)
            try self.validate(self.packageId, name: "packageId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\/]+$")
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, max: 255)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, min: 1)
            try self.validate(self.packageVersion, name: "packageVersion", parent: name, pattern: "^([0-9]+)\\.([0-9]+)$")
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, max: 255)
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, min: 1)
            try self.validate(self.patchVersion, name: "patchVersion", parent: name, pattern: "^[a-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case markLatest = "MarkLatest"
            case ownerAccount = "OwnerAccount"
        }
    }

    public struct RegisterPackageVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RemoveApplicationInstanceRequest: AWSEncodableShape {
        /// An application instance ID.
        public let applicationInstanceId: String

        public init(applicationInstanceId: String) {
            self.applicationInstanceId = applicationInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationInstanceId, key: "ApplicationInstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, max: 255)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, min: 1)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveApplicationInstanceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ReportedRuntimeContextState: AWSDecodableShape {
        /// The application's desired state.
        public let desiredState: DesiredState
        /// The application's reported status.
        public let deviceReportedStatus: DeviceReportedStatus
        /// When the device reported the application's state.
        public let deviceReportedTime: Date
        /// The device's name.
        public let runtimeContextName: String

        public init(desiredState: DesiredState, deviceReportedStatus: DeviceReportedStatus, deviceReportedTime: Date, runtimeContextName: String) {
            self.desiredState = desiredState
            self.deviceReportedStatus = deviceReportedStatus
            self.deviceReportedTime = deviceReportedTime
            self.runtimeContextName = runtimeContextName
        }

        private enum CodingKeys: String, CodingKey {
            case desiredState = "DesiredState"
            case deviceReportedStatus = "DeviceReportedStatus"
            case deviceReportedTime = "DeviceReportedTime"
            case runtimeContextName = "RuntimeContextName"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// A bucket name.
        public let bucketName: String
        /// An object key.
        public let objectKey: String
        /// The bucket's Region.
        public let region: String?

        public init(bucketName: String, objectKey: String, region: String? = nil) {
            self.bucketName = bucketName
            self.objectKey = objectKey
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 255)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 1)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^.+$")
            try self.validate(self.objectKey, name: "objectKey", parent: name, max: 255)
            try self.validate(self.objectKey, name: "objectKey", parent: name, min: 1)
            try self.validate(self.objectKey, name: "objectKey", parent: name, pattern: "^.+$")
            try self.validate(self.region, name: "region", parent: name, max: 255)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.validate(self.region, name: "region", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case objectKey = "ObjectKey"
            case region = "Region"
        }
    }

    public struct SignalApplicationInstanceNodeInstancesRequest: AWSEncodableShape {
        /// An application instance ID.
        public let applicationInstanceId: String
        /// A list of signals.
        public let nodeSignals: [NodeSignal]

        public init(applicationInstanceId: String, nodeSignals: [NodeSignal]) {
            self.applicationInstanceId = applicationInstanceId
            self.nodeSignals = nodeSignals
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationInstanceId, key: "ApplicationInstanceId")
            try container.encode(self.nodeSignals, forKey: .nodeSignals)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, max: 255)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, min: 1)
            try self.validate(self.applicationInstanceId, name: "applicationInstanceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
            try self.nodeSignals.forEach {
                try $0.validate(name: "\(name).nodeSignals[]")
            }
            try self.validate(self.nodeSignals, name: "nodeSignals", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nodeSignals = "NodeSignals"
        }
    }

    public struct SignalApplicationInstanceNodeInstancesResponse: AWSDecodableShape {
        /// An application instance ID.
        public let applicationInstanceId: String

        public init(applicationInstanceId: String) {
            self.applicationInstanceId = applicationInstanceId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationInstanceId = "ApplicationInstanceId"
        }
    }

    public struct StaticIpConnectionInfo: AWSEncodableShape & AWSDecodableShape {
        /// The connection's default gateway.
        public let defaultGateway: String
        /// The connection's DNS address.
        public let dns: [String]
        /// The connection's IP address.
        public let ipAddress: String
        /// The connection's DNS mask.
        public let mask: String

        public init(defaultGateway: String, dns: [String], ipAddress: String, mask: String) {
            self.defaultGateway = defaultGateway
            self.dns = dns
            self.ipAddress = ipAddress
            self.mask = mask
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultGateway, name: "defaultGateway", parent: name, max: 255)
            try self.validate(self.defaultGateway, name: "defaultGateway", parent: name, min: 1)
            try self.validate(self.defaultGateway, name: "defaultGateway", parent: name, pattern: "^.+$")
            try self.dns.forEach {
                try validate($0, name: "dns[]", parent: name, max: 255)
                try validate($0, name: "dns[]", parent: name, min: 1)
                try validate($0, name: "dns[]", parent: name, pattern: "^.+$")
            }
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, max: 255)
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, min: 1)
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, pattern: "^((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d))(:(6553[0-5]|655[0-2]\\d|65[0-4]\\d{2}|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}))?$")
            try self.validate(self.mask, name: "mask", parent: name, max: 255)
            try self.validate(self.mask, name: "mask", parent: name, min: 1)
            try self.validate(self.mask, name: "mask", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultGateway = "DefaultGateway"
            case dns = "Dns"
            case ipAddress = "IpAddress"
            case mask = "Mask"
        }
    }

    public struct StorageLocation: AWSDecodableShape {
        /// The location's binary prefix.
        public let binaryPrefixLocation: String
        /// The location's bucket.
        public let bucket: String
        /// The location's generated prefix.
        public let generatedPrefixLocation: String
        /// The location's manifest prefix.
        public let manifestPrefixLocation: String
        /// The location's repo prefix.
        public let repoPrefixLocation: String

        public init(binaryPrefixLocation: String, bucket: String, generatedPrefixLocation: String, manifestPrefixLocation: String, repoPrefixLocation: String) {
            self.binaryPrefixLocation = binaryPrefixLocation
            self.bucket = bucket
            self.generatedPrefixLocation = generatedPrefixLocation
            self.manifestPrefixLocation = manifestPrefixLocation
            self.repoPrefixLocation = repoPrefixLocation
        }

        private enum CodingKeys: String, CodingKey {
            case binaryPrefixLocation = "BinaryPrefixLocation"
            case bucket = "Bucket"
            case generatedPrefixLocation = "GeneratedPrefixLocation"
            case manifestPrefixLocation = "ManifestPrefixLocation"
            case repoPrefixLocation = "RepoPrefixLocation"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource's ARN.
        public let resourceArn: String
        /// Tags for the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^.+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^.+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^.*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The resource's ARN.
        public let resourceArn: String
        /// Tag keys to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^.+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDeviceMetadataRequest: AWSEncodableShape {
        /// A description for the device.
        public let description: String?
        /// The device's ID.
        public let deviceId: String

        public init(description: String? = nil, deviceId: String) {
            self.description = description
            self.deviceId = deviceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.deviceId, key: "DeviceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.*$")
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 255)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[a-zA-Z0-9\\-\\_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateDeviceMetadataResponse: AWSDecodableShape {
        /// The device's ID.
        public let deviceId: String?

        public init(deviceId: String? = nil) {
            self.deviceId = deviceId
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
        }
    }

    public struct ManifestOverridesPayload: AWSEncodableShape & AWSDecodableShape {
        /// The overrides document.
        public let payloadData: String?

        public init(payloadData: String? = nil) {
            self.payloadData = payloadData
        }

        public func validate(name: String) throws {
            try self.validate(self.payloadData, name: "payloadData", parent: name, max: 51200)
            try self.validate(self.payloadData, name: "payloadData", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case payloadData = "PayloadData"
        }
    }

    public struct ManifestPayload: AWSEncodableShape & AWSDecodableShape {
        /// The application manifest.
        public let payloadData: String?

        public init(payloadData: String? = nil) {
            self.payloadData = payloadData
        }

        public func validate(name: String) throws {
            try self.validate(self.payloadData, name: "payloadData", parent: name, max: 51200)
            try self.validate(self.payloadData, name: "payloadData", parent: name, min: 1)
            try self.validate(self.payloadData, name: "payloadData", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case payloadData = "PayloadData"
        }
    }
}

// MARK: - Errors

/// Error enum for Panorama
public struct PanoramaErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Panorama
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The requestor does not have permission to access the target action or resource.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The target resource is in use.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal error occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The target resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would cause a limit to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request contains an invalid parameter value.
    public static var validationException: Self { .init(.validationException) }
}

extension PanoramaErrorType: Equatable {
    public static func == (lhs: PanoramaErrorType, rhs: PanoramaErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension PanoramaErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
