//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Panorama service.
///
/// AWS Panorama  Overview  This is the AWS Panorama API Reference. For an introduction to the service, see What is AWS Panorama? in the AWS Panorama Developer Guide.
public struct Panorama: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Panorama client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Panorama",
            serviceIdentifier: "panorama",
            serviceProtocol: .restjson,
            apiVersion: "2019-07-24",
            endpoint: endpoint,
            errorType: PanoramaErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Creates an application instance and deploys it to a device.
    @Sendable
    @inlinable
    public func createApplicationInstance(_ input: CreateApplicationInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateApplicationInstanceResponse {
        try await self.client.execute(
            operation: "CreateApplicationInstance", 
            path: "/application-instances", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an application instance and deploys it to a device.
    ///
    /// Parameters:
    ///   - applicationInstanceIdToReplace: The ID of an application instance to replace with the new instance.
    ///   - defaultRuntimeContextDevice: A device's ID.
    ///   - description: A description for the application instance.
    ///   - manifestOverridesPayload: Setting overrides for the application manifest.
    ///   - manifestPayload: The application's manifest document.
    ///   - name: A name for the application instance.
    ///   - runtimeRoleArn: The ARN of a runtime role for the application instance.
    ///   - tags: Tags for the application instance.
    ///   - logger: Logger use during operation
    @inlinable
    public func createApplicationInstance(
        applicationInstanceIdToReplace: String? = nil,
        defaultRuntimeContextDevice: String,
        description: String? = nil,
        manifestOverridesPayload: ManifestOverridesPayload? = nil,
        manifestPayload: ManifestPayload,
        name: String? = nil,
        runtimeRoleArn: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateApplicationInstanceResponse {
        let input = CreateApplicationInstanceRequest(
            applicationInstanceIdToReplace: applicationInstanceIdToReplace, 
            defaultRuntimeContextDevice: defaultRuntimeContextDevice, 
            description: description, 
            manifestOverridesPayload: manifestOverridesPayload, 
            manifestPayload: manifestPayload, 
            name: name, 
            runtimeRoleArn: runtimeRoleArn, 
            tags: tags
        )
        return try await self.createApplicationInstance(input, logger: logger)
    }

    /// Creates a job to run on a device. A job can update a device's software or reboot it.
    @Sendable
    @inlinable
    public func createJobForDevices(_ input: CreateJobForDevicesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateJobForDevicesResponse {
        try await self.client.execute(
            operation: "CreateJobForDevices", 
            path: "/jobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a job to run on a device. A job can update a device's software or reboot it.
    ///
    /// Parameters:
    ///   - deviceIds: ID of target device.
    ///   - deviceJobConfig: Configuration settings for a software update job.
    ///   - jobType: The type of job to run.
    ///   - logger: Logger use during operation
    @inlinable
    public func createJobForDevices(
        deviceIds: [String],
        deviceJobConfig: DeviceJobConfig? = nil,
        jobType: JobType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateJobForDevicesResponse {
        let input = CreateJobForDevicesRequest(
            deviceIds: deviceIds, 
            deviceJobConfig: deviceJobConfig, 
            jobType: jobType
        )
        return try await self.createJobForDevices(input, logger: logger)
    }

    /// Creates a camera stream node.
    @Sendable
    @inlinable
    public func createNodeFromTemplateJob(_ input: CreateNodeFromTemplateJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateNodeFromTemplateJobResponse {
        try await self.client.execute(
            operation: "CreateNodeFromTemplateJob", 
            path: "/packages/template-job", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a camera stream node.
    ///
    /// Parameters:
    ///   - jobTags: Tags for the job.
    ///   - nodeDescription: A description for the node.
    ///   - nodeName: A name for the node.
    ///   - outputPackageName: An output package name for the node.
    ///   - outputPackageVersion: An output package version for the node.
    ///   - templateParameters: Template parameters for the node.
    ///   - templateType: The type of node.
    ///   - logger: Logger use during operation
    @inlinable
    public func createNodeFromTemplateJob(
        jobTags: [JobResourceTags]? = nil,
        nodeDescription: String? = nil,
        nodeName: String,
        outputPackageName: String,
        outputPackageVersion: String,
        templateParameters: [String: String],
        templateType: TemplateType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateNodeFromTemplateJobResponse {
        let input = CreateNodeFromTemplateJobRequest(
            jobTags: jobTags, 
            nodeDescription: nodeDescription, 
            nodeName: nodeName, 
            outputPackageName: outputPackageName, 
            outputPackageVersion: outputPackageVersion, 
            templateParameters: templateParameters, 
            templateType: templateType
        )
        return try await self.createNodeFromTemplateJob(input, logger: logger)
    }

    /// Creates a package and storage location in an Amazon S3 access point.
    @Sendable
    @inlinable
    public func createPackage(_ input: CreatePackageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePackageResponse {
        try await self.client.execute(
            operation: "CreatePackage", 
            path: "/packages", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a package and storage location in an Amazon S3 access point.
    ///
    /// Parameters:
    ///   - packageName: A name for the package.
    ///   - tags: Tags for the package.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPackage(
        packageName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePackageResponse {
        let input = CreatePackageRequest(
            packageName: packageName, 
            tags: tags
        )
        return try await self.createPackage(input, logger: logger)
    }

    /// Imports a node package.
    @Sendable
    @inlinable
    public func createPackageImportJob(_ input: CreatePackageImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePackageImportJobResponse {
        try await self.client.execute(
            operation: "CreatePackageImportJob", 
            path: "/packages/import-jobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Imports a node package.
    ///
    /// Parameters:
    ///   - clientToken: A client token for the package import job.
    ///   - inputConfig: An input config for the package import job.
    ///   - jobTags: Tags for the package import job.
    ///   - jobType: A job type for the package import job.
    ///   - outputConfig: An output config for the package import job.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPackageImportJob(
        clientToken: String,
        inputConfig: PackageImportJobInputConfig,
        jobTags: [JobResourceTags]? = nil,
        jobType: PackageImportJobType,
        outputConfig: PackageImportJobOutputConfig,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePackageImportJobResponse {
        let input = CreatePackageImportJobRequest(
            clientToken: clientToken, 
            inputConfig: inputConfig, 
            jobTags: jobTags, 
            jobType: jobType, 
            outputConfig: outputConfig
        )
        return try await self.createPackageImportJob(input, logger: logger)
    }

    /// Deletes a device.
    @Sendable
    @inlinable
    public func deleteDevice(_ input: DeleteDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDeviceResponse {
        try await self.client.execute(
            operation: "DeleteDevice", 
            path: "/devices/{DeviceId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a device.
    ///
    /// Parameters:
    ///   - deviceId: The device's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDevice(
        deviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDeviceResponse {
        let input = DeleteDeviceRequest(
            deviceId: deviceId
        )
        return try await self.deleteDevice(input, logger: logger)
    }

    /// Deletes a package.  To delete a package, you need permission to call s3:DeleteObject in addition to permissions for the AWS Panorama API.
    @Sendable
    @inlinable
    public func deletePackage(_ input: DeletePackageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePackageResponse {
        try await self.client.execute(
            operation: "DeletePackage", 
            path: "/packages/{PackageId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a package.  To delete a package, you need permission to call s3:DeleteObject in addition to permissions for the AWS Panorama API.
    ///
    /// Parameters:
    ///   - forceDelete: Delete the package even if it has artifacts stored in its access point. Deletes the package's artifacts from Amazon S3.
    ///   - packageId: The package's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePackage(
        forceDelete: Bool? = nil,
        packageId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePackageResponse {
        let input = DeletePackageRequest(
            forceDelete: forceDelete, 
            packageId: packageId
        )
        return try await self.deletePackage(input, logger: logger)
    }

    /// Deregisters a package version.
    @Sendable
    @inlinable
    public func deregisterPackageVersion(_ input: DeregisterPackageVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeregisterPackageVersionResponse {
        try await self.client.execute(
            operation: "DeregisterPackageVersion", 
            path: "/packages/{PackageId}/versions/{PackageVersion}/patch/{PatchVersion}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deregisters a package version.
    ///
    /// Parameters:
    ///   - ownerAccount: An owner account.
    ///   - packageId: A package ID.
    ///   - packageVersion: A package version.
    ///   - patchVersion: A patch version.
    ///   - updatedLatestPatchVersion: If the version was marked latest, the new version to maker as latest.
    ///   - logger: Logger use during operation
    @inlinable
    public func deregisterPackageVersion(
        ownerAccount: String? = nil,
        packageId: String,
        packageVersion: String,
        patchVersion: String,
        updatedLatestPatchVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeregisterPackageVersionResponse {
        let input = DeregisterPackageVersionRequest(
            ownerAccount: ownerAccount, 
            packageId: packageId, 
            packageVersion: packageVersion, 
            patchVersion: patchVersion, 
            updatedLatestPatchVersion: updatedLatestPatchVersion
        )
        return try await self.deregisterPackageVersion(input, logger: logger)
    }

    /// Returns information about an application instance on a device.
    @Sendable
    @inlinable
    public func describeApplicationInstance(_ input: DescribeApplicationInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeApplicationInstanceResponse {
        try await self.client.execute(
            operation: "DescribeApplicationInstance", 
            path: "/application-instances/{ApplicationInstanceId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about an application instance on a device.
    ///
    /// Parameters:
    ///   - applicationInstanceId: The application instance's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeApplicationInstance(
        applicationInstanceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeApplicationInstanceResponse {
        let input = DescribeApplicationInstanceRequest(
            applicationInstanceId: applicationInstanceId
        )
        return try await self.describeApplicationInstance(input, logger: logger)
    }

    /// Returns information about an application instance's configuration manifest.
    @Sendable
    @inlinable
    public func describeApplicationInstanceDetails(_ input: DescribeApplicationInstanceDetailsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeApplicationInstanceDetailsResponse {
        try await self.client.execute(
            operation: "DescribeApplicationInstanceDetails", 
            path: "/application-instances/{ApplicationInstanceId}/details", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about an application instance's configuration manifest.
    ///
    /// Parameters:
    ///   - applicationInstanceId: The application instance's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeApplicationInstanceDetails(
        applicationInstanceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeApplicationInstanceDetailsResponse {
        let input = DescribeApplicationInstanceDetailsRequest(
            applicationInstanceId: applicationInstanceId
        )
        return try await self.describeApplicationInstanceDetails(input, logger: logger)
    }

    /// Returns information about a device.
    @Sendable
    @inlinable
    public func describeDevice(_ input: DescribeDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDeviceResponse {
        try await self.client.execute(
            operation: "DescribeDevice", 
            path: "/devices/{DeviceId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a device.
    ///
    /// Parameters:
    ///   - deviceId: The device's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDevice(
        deviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDeviceResponse {
        let input = DescribeDeviceRequest(
            deviceId: deviceId
        )
        return try await self.describeDevice(input, logger: logger)
    }

    /// Returns information about a device job.
    @Sendable
    @inlinable
    public func describeDeviceJob(_ input: DescribeDeviceJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDeviceJobResponse {
        try await self.client.execute(
            operation: "DescribeDeviceJob", 
            path: "/jobs/{JobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a device job.
    ///
    /// Parameters:
    ///   - jobId: The job's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDeviceJob(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDeviceJobResponse {
        let input = DescribeDeviceJobRequest(
            jobId: jobId
        )
        return try await self.describeDeviceJob(input, logger: logger)
    }

    /// Returns information about a node.
    @Sendable
    @inlinable
    public func describeNode(_ input: DescribeNodeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeNodeResponse {
        try await self.client.execute(
            operation: "DescribeNode", 
            path: "/nodes/{NodeId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a node.
    ///
    /// Parameters:
    ///   - nodeId: The node's ID.
    ///   - ownerAccount: The account ID of the node's owner.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeNode(
        nodeId: String,
        ownerAccount: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeNodeResponse {
        let input = DescribeNodeRequest(
            nodeId: nodeId, 
            ownerAccount: ownerAccount
        )
        return try await self.describeNode(input, logger: logger)
    }

    /// Returns information about a job to create a camera stream node.
    @Sendable
    @inlinable
    public func describeNodeFromTemplateJob(_ input: DescribeNodeFromTemplateJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeNodeFromTemplateJobResponse {
        try await self.client.execute(
            operation: "DescribeNodeFromTemplateJob", 
            path: "/packages/template-job/{JobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a job to create a camera stream node.
    ///
    /// Parameters:
    ///   - jobId: The job's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeNodeFromTemplateJob(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeNodeFromTemplateJobResponse {
        let input = DescribeNodeFromTemplateJobRequest(
            jobId: jobId
        )
        return try await self.describeNodeFromTemplateJob(input, logger: logger)
    }

    /// Returns information about a package.
    @Sendable
    @inlinable
    public func describePackage(_ input: DescribePackageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribePackageResponse {
        try await self.client.execute(
            operation: "DescribePackage", 
            path: "/packages/metadata/{PackageId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a package.
    ///
    /// Parameters:
    ///   - packageId: The package's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func describePackage(
        packageId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribePackageResponse {
        let input = DescribePackageRequest(
            packageId: packageId
        )
        return try await self.describePackage(input, logger: logger)
    }

    /// Returns information about a package import job.
    @Sendable
    @inlinable
    public func describePackageImportJob(_ input: DescribePackageImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribePackageImportJobResponse {
        try await self.client.execute(
            operation: "DescribePackageImportJob", 
            path: "/packages/import-jobs/{JobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a package import job.
    ///
    /// Parameters:
    ///   - jobId: The job's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func describePackageImportJob(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribePackageImportJobResponse {
        let input = DescribePackageImportJobRequest(
            jobId: jobId
        )
        return try await self.describePackageImportJob(input, logger: logger)
    }

    /// Returns information about a package version.
    @Sendable
    @inlinable
    public func describePackageVersion(_ input: DescribePackageVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribePackageVersionResponse {
        try await self.client.execute(
            operation: "DescribePackageVersion", 
            path: "/packages/metadata/{PackageId}/versions/{PackageVersion}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a package version.
    ///
    /// Parameters:
    ///   - ownerAccount: The version's owner account.
    ///   - packageId: The version's ID.
    ///   - packageVersion: The version's version.
    ///   - patchVersion: The version's patch version.
    ///   - logger: Logger use during operation
    @inlinable
    public func describePackageVersion(
        ownerAccount: String? = nil,
        packageId: String,
        packageVersion: String,
        patchVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribePackageVersionResponse {
        let input = DescribePackageVersionRequest(
            ownerAccount: ownerAccount, 
            packageId: packageId, 
            packageVersion: packageVersion, 
            patchVersion: patchVersion
        )
        return try await self.describePackageVersion(input, logger: logger)
    }

    /// Returns a list of application instance dependencies.
    @Sendable
    @inlinable
    public func listApplicationInstanceDependencies(_ input: ListApplicationInstanceDependenciesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListApplicationInstanceDependenciesResponse {
        try await self.client.execute(
            operation: "ListApplicationInstanceDependencies", 
            path: "/application-instances/{ApplicationInstanceId}/package-dependencies", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of application instance dependencies.
    ///
    /// Parameters:
    ///   - applicationInstanceId: The application instance's ID.
    ///   - maxResults: The maximum number of application instance dependencies to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listApplicationInstanceDependencies(
        applicationInstanceId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListApplicationInstanceDependenciesResponse {
        let input = ListApplicationInstanceDependenciesRequest(
            applicationInstanceId: applicationInstanceId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listApplicationInstanceDependencies(input, logger: logger)
    }

    /// Returns a list of application node instances.
    @Sendable
    @inlinable
    public func listApplicationInstanceNodeInstances(_ input: ListApplicationInstanceNodeInstancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListApplicationInstanceNodeInstancesResponse {
        try await self.client.execute(
            operation: "ListApplicationInstanceNodeInstances", 
            path: "/application-instances/{ApplicationInstanceId}/node-instances", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of application node instances.
    ///
    /// Parameters:
    ///   - applicationInstanceId: The node instances' application instance ID.
    ///   - maxResults: The maximum number of node instances to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listApplicationInstanceNodeInstances(
        applicationInstanceId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListApplicationInstanceNodeInstancesResponse {
        let input = ListApplicationInstanceNodeInstancesRequest(
            applicationInstanceId: applicationInstanceId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listApplicationInstanceNodeInstances(input, logger: logger)
    }

    /// Returns a list of application instances.
    @Sendable
    @inlinable
    public func listApplicationInstances(_ input: ListApplicationInstancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListApplicationInstancesResponse {
        try await self.client.execute(
            operation: "ListApplicationInstances", 
            path: "/application-instances", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of application instances.
    ///
    /// Parameters:
    ///   - deviceId: The application instances' device ID.
    ///   - maxResults: The maximum number of application instances to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - statusFilter: Only include instances with a specific status.
    ///   - logger: Logger use during operation
    @inlinable
    public func listApplicationInstances(
        deviceId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        statusFilter: StatusFilter? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListApplicationInstancesResponse {
        let input = ListApplicationInstancesRequest(
            deviceId: deviceId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            statusFilter: statusFilter
        )
        return try await self.listApplicationInstances(input, logger: logger)
    }

    /// Returns a list of devices.
    @Sendable
    @inlinable
    public func listDevices(_ input: ListDevicesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDevicesResponse {
        try await self.client.execute(
            operation: "ListDevices", 
            path: "/devices", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of devices.
    ///
    /// Parameters:
    ///   - deviceAggregatedStatusFilter: Filter based on a device's status.
    ///   - maxResults: The maximum number of devices to return in one page of results.
    ///   - nameFilter: Filter based on device's name. Prefixes supported.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - sortBy: The target column to be sorted on. Default column sort is CREATED_TIME.
    ///   - sortOrder: The sorting order for the returned list. SortOrder is DESCENDING by default based on CREATED_TIME. Otherwise, SortOrder is ASCENDING.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDevices(
        deviceAggregatedStatusFilter: DeviceAggregatedStatus? = nil,
        maxResults: Int? = nil,
        nameFilter: String? = nil,
        nextToken: String? = nil,
        sortBy: ListDevicesSortBy? = nil,
        sortOrder: SortOrder? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDevicesResponse {
        let input = ListDevicesRequest(
            deviceAggregatedStatusFilter: deviceAggregatedStatusFilter, 
            maxResults: maxResults, 
            nameFilter: nameFilter, 
            nextToken: nextToken, 
            sortBy: sortBy, 
            sortOrder: sortOrder
        )
        return try await self.listDevices(input, logger: logger)
    }

    /// Returns a list of jobs.
    @Sendable
    @inlinable
    public func listDevicesJobs(_ input: ListDevicesJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDevicesJobsResponse {
        try await self.client.execute(
            operation: "ListDevicesJobs", 
            path: "/jobs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of jobs.
    ///
    /// Parameters:
    ///   - deviceId: Filter results by the job's target device ID.
    ///   - maxResults: The maximum number of device jobs to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDevicesJobs(
        deviceId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDevicesJobsResponse {
        let input = ListDevicesJobsRequest(
            deviceId: deviceId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDevicesJobs(input, logger: logger)
    }

    /// Returns a list of camera stream node jobs.
    @Sendable
    @inlinable
    public func listNodeFromTemplateJobs(_ input: ListNodeFromTemplateJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListNodeFromTemplateJobsResponse {
        try await self.client.execute(
            operation: "ListNodeFromTemplateJobs", 
            path: "/packages/template-job", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of camera stream node jobs.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of node from template jobs to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listNodeFromTemplateJobs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListNodeFromTemplateJobsResponse {
        let input = ListNodeFromTemplateJobsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listNodeFromTemplateJobs(input, logger: logger)
    }

    /// Returns a list of nodes.
    @Sendable
    @inlinable
    public func listNodes(_ input: ListNodesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListNodesResponse {
        try await self.client.execute(
            operation: "ListNodes", 
            path: "/nodes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of nodes.
    ///
    /// Parameters:
    ///   - category: Search for nodes by category.
    ///   - maxResults: The maximum number of nodes to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - ownerAccount: Search for nodes by the account ID of the nodes' owner.
    ///   - packageName: Search for nodes by name.
    ///   - packageVersion: Search for nodes by version.
    ///   - patchVersion: Search for nodes by patch version.
    ///   - logger: Logger use during operation
    @inlinable
    public func listNodes(
        category: NodeCategory? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        ownerAccount: String? = nil,
        packageName: String? = nil,
        packageVersion: String? = nil,
        patchVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListNodesResponse {
        let input = ListNodesRequest(
            category: category, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            ownerAccount: ownerAccount, 
            packageName: packageName, 
            packageVersion: packageVersion, 
            patchVersion: patchVersion
        )
        return try await self.listNodes(input, logger: logger)
    }

    /// Returns a list of package import jobs.
    @Sendable
    @inlinable
    public func listPackageImportJobs(_ input: ListPackageImportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPackageImportJobsResponse {
        try await self.client.execute(
            operation: "ListPackageImportJobs", 
            path: "/packages/import-jobs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of package import jobs.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of package import jobs to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPackageImportJobs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPackageImportJobsResponse {
        let input = ListPackageImportJobsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listPackageImportJobs(input, logger: logger)
    }

    /// Returns a list of packages.
    @Sendable
    @inlinable
    public func listPackages(_ input: ListPackagesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPackagesResponse {
        try await self.client.execute(
            operation: "ListPackages", 
            path: "/packages", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of packages.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of packages to return in one page of results.
    ///   - nextToken: Specify the pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPackages(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPackagesResponse {
        let input = ListPackagesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listPackages(input, logger: logger)
    }

    /// Returns a list of tags for a resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of tags for a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The resource's ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Creates a device and returns a configuration archive. The configuration archive is a ZIP file that contains a provisioning certificate that is valid for 5 minutes. Name the configuration archive certificates-omni_device-name.zip and transfer it to the device within 5 minutes. Use the included USB storage device and connect it to the USB 3.0 port next to the HDMI output.
    @Sendable
    @inlinable
    public func provisionDevice(_ input: ProvisionDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ProvisionDeviceResponse {
        try await self.client.execute(
            operation: "ProvisionDevice", 
            path: "/devices", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a device and returns a configuration archive. The configuration archive is a ZIP file that contains a provisioning certificate that is valid for 5 minutes. Name the configuration archive certificates-omni_device-name.zip and transfer it to the device within 5 minutes. Use the included USB storage device and connect it to the USB 3.0 port next to the HDMI output.
    ///
    /// Parameters:
    ///   - description: A description for the device.
    ///   - name: A name for the device.
    ///   - networkingConfiguration: A networking configuration for the device.
    ///   - tags: Tags for the device.
    ///   - logger: Logger use during operation
    @inlinable
    public func provisionDevice(
        description: String? = nil,
        name: String,
        networkingConfiguration: NetworkPayload? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ProvisionDeviceResponse {
        let input = ProvisionDeviceRequest(
            description: description, 
            name: name, 
            networkingConfiguration: networkingConfiguration, 
            tags: tags
        )
        return try await self.provisionDevice(input, logger: logger)
    }

    /// Registers a package version.
    @Sendable
    @inlinable
    public func registerPackageVersion(_ input: RegisterPackageVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RegisterPackageVersionResponse {
        try await self.client.execute(
            operation: "RegisterPackageVersion", 
            path: "/packages/{PackageId}/versions/{PackageVersion}/patch/{PatchVersion}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Registers a package version.
    ///
    /// Parameters:
    ///   - markLatest: Whether to mark the new version as the latest version.
    ///   - ownerAccount: An owner account.
    ///   - packageId: A package ID.
    ///   - packageVersion: A package version.
    ///   - patchVersion: A patch version.
    ///   - logger: Logger use during operation
    @inlinable
    public func registerPackageVersion(
        markLatest: Bool? = nil,
        ownerAccount: String? = nil,
        packageId: String,
        packageVersion: String,
        patchVersion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RegisterPackageVersionResponse {
        let input = RegisterPackageVersionRequest(
            markLatest: markLatest, 
            ownerAccount: ownerAccount, 
            packageId: packageId, 
            packageVersion: packageVersion, 
            patchVersion: patchVersion
        )
        return try await self.registerPackageVersion(input, logger: logger)
    }

    /// Removes an application instance.
    @Sendable
    @inlinable
    public func removeApplicationInstance(_ input: RemoveApplicationInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RemoveApplicationInstanceResponse {
        try await self.client.execute(
            operation: "RemoveApplicationInstance", 
            path: "/application-instances/{ApplicationInstanceId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes an application instance.
    ///
    /// Parameters:
    ///   - applicationInstanceId: An application instance ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func removeApplicationInstance(
        applicationInstanceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RemoveApplicationInstanceResponse {
        let input = RemoveApplicationInstanceRequest(
            applicationInstanceId: applicationInstanceId
        )
        return try await self.removeApplicationInstance(input, logger: logger)
    }

    /// Signal camera nodes to stop or resume.
    @Sendable
    @inlinable
    public func signalApplicationInstanceNodeInstances(_ input: SignalApplicationInstanceNodeInstancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SignalApplicationInstanceNodeInstancesResponse {
        try await self.client.execute(
            operation: "SignalApplicationInstanceNodeInstances", 
            path: "/application-instances/{ApplicationInstanceId}/node-signals", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Signal camera nodes to stop or resume.
    ///
    /// Parameters:
    ///   - applicationInstanceId: An application instance ID.
    ///   - nodeSignals: A list of signals.
    ///   - logger: Logger use during operation
    @inlinable
    public func signalApplicationInstanceNodeInstances(
        applicationInstanceId: String,
        nodeSignals: [NodeSignal],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SignalApplicationInstanceNodeInstancesResponse {
        let input = SignalApplicationInstanceNodeInstancesRequest(
            applicationInstanceId: applicationInstanceId, 
            nodeSignals: nodeSignals
        )
        return try await self.signalApplicationInstanceNodeInstances(input, logger: logger)
    }

    /// Tags a resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Tags a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The resource's ARN.
    ///   - tags: Tags for the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes tags from a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes tags from a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The resource's ARN.
    ///   - tagKeys: Tag keys to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates a device's metadata.
    @Sendable
    @inlinable
    public func updateDeviceMetadata(_ input: UpdateDeviceMetadataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDeviceMetadataResponse {
        try await self.client.execute(
            operation: "UpdateDeviceMetadata", 
            path: "/devices/{DeviceId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a device's metadata.
    ///
    /// Parameters:
    ///   - description: A description for the device.
    ///   - deviceId: The device's ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDeviceMetadata(
        description: String? = nil,
        deviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDeviceMetadataResponse {
        let input = UpdateDeviceMetadataRequest(
            description: description, 
            deviceId: deviceId
        )
        return try await self.updateDeviceMetadata(input, logger: logger)
    }
}

extension Panorama {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Panorama, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Panorama {
    /// Return PaginatorSequence for operation ``listApplicationInstanceDependencies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationInstanceDependenciesPaginator(
        _ input: ListApplicationInstanceDependenciesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListApplicationInstanceDependenciesRequest, ListApplicationInstanceDependenciesResponse> {
        return .init(
            input: input,
            command: self.listApplicationInstanceDependencies,
            inputKey: \ListApplicationInstanceDependenciesRequest.nextToken,
            outputKey: \ListApplicationInstanceDependenciesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listApplicationInstanceDependencies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - applicationInstanceId: The application instance's ID.
    ///   - maxResults: The maximum number of application instance dependencies to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationInstanceDependenciesPaginator(
        applicationInstanceId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListApplicationInstanceDependenciesRequest, ListApplicationInstanceDependenciesResponse> {
        let input = ListApplicationInstanceDependenciesRequest(
            applicationInstanceId: applicationInstanceId, 
            maxResults: maxResults
        )
        return self.listApplicationInstanceDependenciesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listApplicationInstanceNodeInstances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationInstanceNodeInstancesPaginator(
        _ input: ListApplicationInstanceNodeInstancesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListApplicationInstanceNodeInstancesRequest, ListApplicationInstanceNodeInstancesResponse> {
        return .init(
            input: input,
            command: self.listApplicationInstanceNodeInstances,
            inputKey: \ListApplicationInstanceNodeInstancesRequest.nextToken,
            outputKey: \ListApplicationInstanceNodeInstancesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listApplicationInstanceNodeInstances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - applicationInstanceId: The node instances' application instance ID.
    ///   - maxResults: The maximum number of node instances to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationInstanceNodeInstancesPaginator(
        applicationInstanceId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListApplicationInstanceNodeInstancesRequest, ListApplicationInstanceNodeInstancesResponse> {
        let input = ListApplicationInstanceNodeInstancesRequest(
            applicationInstanceId: applicationInstanceId, 
            maxResults: maxResults
        )
        return self.listApplicationInstanceNodeInstancesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listApplicationInstances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationInstancesPaginator(
        _ input: ListApplicationInstancesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListApplicationInstancesRequest, ListApplicationInstancesResponse> {
        return .init(
            input: input,
            command: self.listApplicationInstances,
            inputKey: \ListApplicationInstancesRequest.nextToken,
            outputKey: \ListApplicationInstancesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listApplicationInstances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - deviceId: The application instances' device ID.
    ///   - maxResults: The maximum number of application instances to return in one page of results.
    ///   - statusFilter: Only include instances with a specific status.
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationInstancesPaginator(
        deviceId: String? = nil,
        maxResults: Int? = nil,
        statusFilter: StatusFilter? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListApplicationInstancesRequest, ListApplicationInstancesResponse> {
        let input = ListApplicationInstancesRequest(
            deviceId: deviceId, 
            maxResults: maxResults, 
            statusFilter: statusFilter
        )
        return self.listApplicationInstancesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDevices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevicesPaginator(
        _ input: ListDevicesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDevicesRequest, ListDevicesResponse> {
        return .init(
            input: input,
            command: self.listDevices,
            inputKey: \ListDevicesRequest.nextToken,
            outputKey: \ListDevicesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDevices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - deviceAggregatedStatusFilter: Filter based on a device's status.
    ///   - maxResults: The maximum number of devices to return in one page of results.
    ///   - nameFilter: Filter based on device's name. Prefixes supported.
    ///   - sortBy: The target column to be sorted on. Default column sort is CREATED_TIME.
    ///   - sortOrder: The sorting order for the returned list. SortOrder is DESCENDING by default based on CREATED_TIME. Otherwise, SortOrder is ASCENDING.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevicesPaginator(
        deviceAggregatedStatusFilter: DeviceAggregatedStatus? = nil,
        maxResults: Int? = nil,
        nameFilter: String? = nil,
        sortBy: ListDevicesSortBy? = nil,
        sortOrder: SortOrder? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDevicesRequest, ListDevicesResponse> {
        let input = ListDevicesRequest(
            deviceAggregatedStatusFilter: deviceAggregatedStatusFilter, 
            maxResults: maxResults, 
            nameFilter: nameFilter, 
            sortBy: sortBy, 
            sortOrder: sortOrder
        )
        return self.listDevicesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDevicesJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevicesJobsPaginator(
        _ input: ListDevicesJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDevicesJobsRequest, ListDevicesJobsResponse> {
        return .init(
            input: input,
            command: self.listDevicesJobs,
            inputKey: \ListDevicesJobsRequest.nextToken,
            outputKey: \ListDevicesJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDevicesJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - deviceId: Filter results by the job's target device ID.
    ///   - maxResults: The maximum number of device jobs to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevicesJobsPaginator(
        deviceId: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDevicesJobsRequest, ListDevicesJobsResponse> {
        let input = ListDevicesJobsRequest(
            deviceId: deviceId, 
            maxResults: maxResults
        )
        return self.listDevicesJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listNodeFromTemplateJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listNodeFromTemplateJobsPaginator(
        _ input: ListNodeFromTemplateJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListNodeFromTemplateJobsRequest, ListNodeFromTemplateJobsResponse> {
        return .init(
            input: input,
            command: self.listNodeFromTemplateJobs,
            inputKey: \ListNodeFromTemplateJobsRequest.nextToken,
            outputKey: \ListNodeFromTemplateJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listNodeFromTemplateJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of node from template jobs to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listNodeFromTemplateJobsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListNodeFromTemplateJobsRequest, ListNodeFromTemplateJobsResponse> {
        let input = ListNodeFromTemplateJobsRequest(
            maxResults: maxResults
        )
        return self.listNodeFromTemplateJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listNodesPaginator(
        _ input: ListNodesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListNodesRequest, ListNodesResponse> {
        return .init(
            input: input,
            command: self.listNodes,
            inputKey: \ListNodesRequest.nextToken,
            outputKey: \ListNodesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - category: Search for nodes by category.
    ///   - maxResults: The maximum number of nodes to return in one page of results.
    ///   - ownerAccount: Search for nodes by the account ID of the nodes' owner.
    ///   - packageName: Search for nodes by name.
    ///   - packageVersion: Search for nodes by version.
    ///   - patchVersion: Search for nodes by patch version.
    ///   - logger: Logger used for logging
    @inlinable
    public func listNodesPaginator(
        category: NodeCategory? = nil,
        maxResults: Int? = nil,
        ownerAccount: String? = nil,
        packageName: String? = nil,
        packageVersion: String? = nil,
        patchVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListNodesRequest, ListNodesResponse> {
        let input = ListNodesRequest(
            category: category, 
            maxResults: maxResults, 
            ownerAccount: ownerAccount, 
            packageName: packageName, 
            packageVersion: packageVersion, 
            patchVersion: patchVersion
        )
        return self.listNodesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPackageImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPackageImportJobsPaginator(
        _ input: ListPackageImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPackageImportJobsRequest, ListPackageImportJobsResponse> {
        return .init(
            input: input,
            command: self.listPackageImportJobs,
            inputKey: \ListPackageImportJobsRequest.nextToken,
            outputKey: \ListPackageImportJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPackageImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of package import jobs to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPackageImportJobsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPackageImportJobsRequest, ListPackageImportJobsResponse> {
        let input = ListPackageImportJobsRequest(
            maxResults: maxResults
        )
        return self.listPackageImportJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPackages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPackagesPaginator(
        _ input: ListPackagesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPackagesRequest, ListPackagesResponse> {
        return .init(
            input: input,
            command: self.listPackages,
            inputKey: \ListPackagesRequest.nextToken,
            outputKey: \ListPackagesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPackages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of packages to return in one page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPackagesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPackagesRequest, ListPackagesResponse> {
        let input = ListPackagesRequest(
            maxResults: maxResults
        )
        return self.listPackagesPaginator(input, logger: logger)
    }
}

extension Panorama.ListApplicationInstanceDependenciesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Panorama.ListApplicationInstanceDependenciesRequest {
        return .init(
            applicationInstanceId: self.applicationInstanceId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Panorama.ListApplicationInstanceNodeInstancesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Panorama.ListApplicationInstanceNodeInstancesRequest {
        return .init(
            applicationInstanceId: self.applicationInstanceId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Panorama.ListApplicationInstancesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Panorama.ListApplicationInstancesRequest {
        return .init(
            deviceId: self.deviceId,
            maxResults: self.maxResults,
            nextToken: token,
            statusFilter: self.statusFilter
        )
    }
}

extension Panorama.ListDevicesJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Panorama.ListDevicesJobsRequest {
        return .init(
            deviceId: self.deviceId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Panorama.ListDevicesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Panorama.ListDevicesRequest {
        return .init(
            deviceAggregatedStatusFilter: self.deviceAggregatedStatusFilter,
            maxResults: self.maxResults,
            nameFilter: self.nameFilter,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}

extension Panorama.ListNodeFromTemplateJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Panorama.ListNodeFromTemplateJobsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Panorama.ListNodesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Panorama.ListNodesRequest {
        return .init(
            category: self.category,
            maxResults: self.maxResults,
            nextToken: token,
            ownerAccount: self.ownerAccount,
            packageName: self.packageName,
            packageVersion: self.packageVersion,
            patchVersion: self.patchVersion
        )
    }
}

extension Panorama.ListPackageImportJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Panorama.ListPackageImportJobsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Panorama.ListPackagesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Panorama.ListPackagesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
