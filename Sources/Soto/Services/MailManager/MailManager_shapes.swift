//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MailManager {
    // MARK: Enums

    public enum AcceptAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum ActionFailurePolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `continue` = "CONTINUE"
        case drop = "DROP"
        public var description: String { return self.rawValue }
    }

    public enum ArchiveBooleanEmailAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hasAttachments = "HAS_ATTACHMENTS"
        public var description: String { return self.rawValue }
    }

    public enum ArchiveBooleanOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case isFalse = "IS_FALSE"
        case isTrue = "IS_TRUE"
        public var description: String { return self.rawValue }
    }

    public enum ArchiveState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case pendingDeletion = "PENDING_DELETION"
        public var description: String { return self.rawValue }
    }

    public enum ArchiveStringEmailAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cc = "CC"
        case envelopeFrom = "ENVELOPE_FROM"
        case envelopeTo = "ENVELOPE_TO"
        case from = "FROM"
        case subject = "SUBJECT"
        case to = "TO"
        public var description: String { return self.rawValue }
    }

    public enum ArchiveStringOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        public var description: String { return self.rawValue }
    }

    public enum ExportState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case preprocessing = "PREPROCESSING"
        case processing = "PROCESSING"
        case queued = "QUEUED"
        public var description: String { return self.rawValue }
    }

    public enum ImportDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum ImportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case created = "CREATED"
        case failed = "FAILED"
        case processing = "PROCESSING"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum IngressAddressListEmailAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case recipient = "RECIPIENT"
        public var description: String { return self.rawValue }
    }

    public enum IngressBooleanOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case isFalse = "IS_FALSE"
        case isTrue = "IS_TRUE"
        public var description: String { return self.rawValue }
    }

    public enum IngressIpOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cidrMatches = "CIDR_MATCHES"
        case notCidrMatches = "NOT_CIDR_MATCHES"
        public var description: String { return self.rawValue }
    }

    public enum IngressIpv4Attribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case senderIp = "SENDER_IP"
        public var description: String { return self.rawValue }
    }

    public enum IngressPointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case closed = "CLOSED"
        case deprovisioning = "DEPROVISIONING"
        case failed = "FAILED"
        case provisioning = "PROVISIONING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum IngressPointStatusToUpdate: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case closed = "CLOSED"
        public var description: String { return self.rawValue }
    }

    public enum IngressPointType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auth = "AUTH"
        case open = "OPEN"
        public var description: String { return self.rawValue }
    }

    public enum IngressStringEmailAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case recipient = "RECIPIENT"
        public var description: String { return self.rawValue }
    }

    public enum IngressStringOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case endsWith = "ENDS_WITH"
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    public enum IngressTlsAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case tlsProtocol = "TLS_PROTOCOL"
        public var description: String { return self.rawValue }
    }

    public enum IngressTlsProtocolAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case tls12 = "TLS1_2"
        case tls13 = "TLS1_3"
        public var description: String { return self.rawValue }
    }

    public enum IngressTlsProtocolOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `is` = "IS"
        case minimumTlsVersion = "MINIMUM_TLS_VERSION"
        public var description: String { return self.rawValue }
    }

    public enum MailFrom: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case preserve = "PRESERVE"
        case replace = "REPLACE"
        public var description: String { return self.rawValue }
    }

    public enum RetentionPeriod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eightYears = "EIGHT_YEARS"
        case eighteenMonths = "EIGHTEEN_MONTHS"
        case fiveYears = "FIVE_YEARS"
        case fourYears = "FOUR_YEARS"
        case nineMonths = "NINE_MONTHS"
        case nineYears = "NINE_YEARS"
        case oneYear = "ONE_YEAR"
        case permanent = "PERMANENT"
        case sevenYears = "SEVEN_YEARS"
        case sixMonths = "SIX_MONTHS"
        case sixYears = "SIX_YEARS"
        case tenYears = "TEN_YEARS"
        case thirtyMonths = "THIRTY_MONTHS"
        case threeMonths = "THREE_MONTHS"
        case threeYears = "THREE_YEARS"
        case twoYears = "TWO_YEARS"
        public var description: String { return self.rawValue }
    }

    public enum RuleAddressListEmailAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cc = "CC"
        case from = "FROM"
        case mailFrom = "MAIL_FROM"
        case recipient = "RECIPIENT"
        case sender = "SENDER"
        case to = "TO"
        public var description: String { return self.rawValue }
    }

    public enum RuleBooleanEmailAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case readReceiptRequested = "READ_RECEIPT_REQUESTED"
        case tls = "TLS"
        case tlsWrapped = "TLS_WRAPPED"
        public var description: String { return self.rawValue }
    }

    public enum RuleBooleanOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case isFalse = "IS_FALSE"
        case isTrue = "IS_TRUE"
        public var description: String { return self.rawValue }
    }

    public enum RuleDmarcOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum RuleDmarcPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "NONE"
        case quarantine = "QUARANTINE"
        case reject = "REJECT"
        public var description: String { return self.rawValue }
    }

    public enum RuleIpEmailAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sourceIp = "SOURCE_IP"
        public var description: String { return self.rawValue }
    }

    public enum RuleIpOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cidrMatches = "CIDR_MATCHES"
        case notCidrMatches = "NOT_CIDR_MATCHES"
        public var description: String { return self.rawValue }
    }

    public enum RuleNumberEmailAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case messageSize = "MESSAGE_SIZE"
        public var description: String { return self.rawValue }
    }

    public enum RuleNumberOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqual = "GREATER_THAN_OR_EQUAL"
        case lessThan = "LESS_THAN"
        case lessThanOrEqual = "LESS_THAN_OR_EQUAL"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum RuleStringEmailAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cc = "CC"
        case from = "FROM"
        case helo = "HELO"
        case mailFrom = "MAIL_FROM"
        case recipient = "RECIPIENT"
        case sender = "SENDER"
        case subject = "SUBJECT"
        case to = "TO"
        public var description: String { return self.rawValue }
    }

    public enum RuleStringOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case endsWith = "ENDS_WITH"
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    public enum RuleVerdict: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fail = "FAIL"
        case gray = "GRAY"
        case pass = "PASS"
        case processingFailed = "PROCESSING_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum RuleVerdictAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dkim = "DKIM"
        case spf = "SPF"
        public var description: String { return self.rawValue }
    }

    public enum RuleVerdictOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum SearchState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case queued = "QUEUED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum ArchiveFilterCondition: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A boolean expression to evaluate against email attributes.
        case booleanExpression(ArchiveBooleanExpression)
        /// A string expression to evaluate against email attributes.
        case stringExpression(ArchiveStringExpression)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .booleanExpression:
                let value = try container.decode(ArchiveBooleanExpression.self, forKey: .booleanExpression)
                self = .booleanExpression(value)
            case .stringExpression:
                let value = try container.decode(ArchiveStringExpression.self, forKey: .stringExpression)
                self = .stringExpression(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .booleanExpression(let value):
                try container.encode(value, forKey: .booleanExpression)
            case .stringExpression(let value):
                try container.encode(value, forKey: .stringExpression)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .stringExpression(let value):
                try value.validate(name: "\(name).stringExpression")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case booleanExpression = "BooleanExpression"
            case stringExpression = "StringExpression"
        }
    }

    public enum IngressBooleanToEvaluate: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The structure type for a boolean condition stating the Add On ARN and its returned value.
        case analysis(IngressAnalysis)
        /// The structure type for a boolean condition that provides the address lists to evaluate incoming traffic on.
        case isInAddressList(IngressIsInAddressList)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .analysis:
                let value = try container.decode(IngressAnalysis.self, forKey: .analysis)
                self = .analysis(value)
            case .isInAddressList:
                let value = try container.decode(IngressIsInAddressList.self, forKey: .isInAddressList)
                self = .isInAddressList(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .analysis(let value):
                try container.encode(value, forKey: .analysis)
            case .isInAddressList(let value):
                try container.encode(value, forKey: .isInAddressList)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .analysis(let value):
                try value.validate(name: "\(name).analysis")
            case .isInAddressList(let value):
                try value.validate(name: "\(name).isInAddressList")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analysis = "Analysis"
            case isInAddressList = "IsInAddressList"
        }
    }

    public enum IngressPointConfiguration: AWSEncodableShape, Sendable {
        /// The SecretsManager::Secret ARN of the ingress endpoint resource.
        case secretArn(String)
        /// The password of the ingress endpoint resource.
        case smtpPassword(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .secretArn(let value):
                try container.encode(value, forKey: .secretArn)
            case .smtpPassword(let value):
                try container.encode(value, forKey: .smtpPassword)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .secretArn(let value):
                try self.validate(value, name: "secretArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):secretsmanager:[a-z0-9-]+:\\d{12}:secret:[a-zA-Z0-9/_+=,.@-]+$")
            case .smtpPassword(let value):
                try self.validate(value, name: "smtpPassword", parent: name, max: 64)
                try self.validate(value, name: "smtpPassword", parent: name, min: 8)
                try self.validate(value, name: "smtpPassword", parent: name, pattern: "^[A-Za-z0-9!@#$%^&*()_+\\-=\\[\\]{}|.,?]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case secretArn = "SecretArn"
            case smtpPassword = "SmtpPassword"
        }
    }

    public enum PolicyCondition: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// This represents a boolean type condition matching on the incoming mail. It performs the boolean operation configured in 'Operator' and evaluates the 'Protocol' object against the 'Value'.
        case booleanExpression(IngressBooleanExpression)
        /// This represents an IP based condition matching on the incoming mail. It performs the operation configured in 'Operator' and evaluates the 'Protocol' object against the 'Value'.
        case ipExpression(IngressIpv4Expression)
        /// This represents a string based condition matching on the incoming mail. It performs the string operation configured in 'Operator' and evaluates the 'Protocol' object against the 'Value'.
        case stringExpression(IngressStringExpression)
        /// This represents a TLS based condition matching on the incoming mail. It performs the operation configured in 'Operator' and evaluates the 'Protocol' object against the 'Value'.
        case tlsExpression(IngressTlsProtocolExpression)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .booleanExpression:
                let value = try container.decode(IngressBooleanExpression.self, forKey: .booleanExpression)
                self = .booleanExpression(value)
            case .ipExpression:
                let value = try container.decode(IngressIpv4Expression.self, forKey: .ipExpression)
                self = .ipExpression(value)
            case .stringExpression:
                let value = try container.decode(IngressStringExpression.self, forKey: .stringExpression)
                self = .stringExpression(value)
            case .tlsExpression:
                let value = try container.decode(IngressTlsProtocolExpression.self, forKey: .tlsExpression)
                self = .tlsExpression(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .booleanExpression(let value):
                try container.encode(value, forKey: .booleanExpression)
            case .ipExpression(let value):
                try container.encode(value, forKey: .ipExpression)
            case .stringExpression(let value):
                try container.encode(value, forKey: .stringExpression)
            case .tlsExpression(let value):
                try container.encode(value, forKey: .tlsExpression)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .booleanExpression(let value):
                try value.validate(name: "\(name).booleanExpression")
            case .ipExpression(let value):
                try value.validate(name: "\(name).ipExpression")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case booleanExpression = "BooleanExpression"
            case ipExpression = "IpExpression"
            case stringExpression = "StringExpression"
            case tlsExpression = "TlsExpression"
        }
    }

    public enum RelayAuthentication: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Keep an empty structure if the relay destination server does not require SMTP credential authentication.
        case noAuthentication(NoAuthentication)
        /// The ARN of the secret created in secrets manager where the relay server's SMTP credentials are stored.
        case secretArn(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .noAuthentication:
                let value = try container.decode(NoAuthentication.self, forKey: .noAuthentication)
                self = .noAuthentication(value)
            case .secretArn:
                let value = try container.decode(String.self, forKey: .secretArn)
                self = .secretArn(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .noAuthentication(let value):
                try container.encode(value, forKey: .noAuthentication)
            case .secretArn(let value):
                try container.encode(value, forKey: .secretArn)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .secretArn(let value):
                try self.validate(value, name: "secretArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-us-gov):secretsmanager:[a-z0-9-]+:\\d{12}:secret:[a-zA-Z0-9/_+=,.@-]+$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case noAuthentication = "NoAuthentication"
            case secretArn = "SecretArn"
        }
    }

    public enum RuleAction: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// This action adds a header. This can be used to add arbitrary email headers.
        case addHeader(AddHeaderAction)
        /// This action archives the email. This can be used to deliver an email to an archive.
        case archive(ArchiveAction)
        /// This action delivers an email to a WorkMail mailbox.
        case deliverToMailbox(DeliverToMailboxAction)
        /// This action delivers an email to an Amazon Q Business application for ingestion into its knowledge base.
        case deliverToQBusiness(DeliverToQBusinessAction)
        /// This action terminates the evaluation of rules in the rule set.
        case drop(DropAction)
        /// This action relays the email to another SMTP server.
        case relay(RelayAction)
        /// The action replaces certain or all recipients with a different set of recipients.
        case replaceRecipient(ReplaceRecipientAction)
        /// This action sends the email to the internet.
        case send(SendAction)
        /// This action writes the MIME content of the email to an S3 bucket.
        case writeToS3(S3Action)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .addHeader:
                let value = try container.decode(AddHeaderAction.self, forKey: .addHeader)
                self = .addHeader(value)
            case .archive:
                let value = try container.decode(ArchiveAction.self, forKey: .archive)
                self = .archive(value)
            case .deliverToMailbox:
                let value = try container.decode(DeliverToMailboxAction.self, forKey: .deliverToMailbox)
                self = .deliverToMailbox(value)
            case .deliverToQBusiness:
                let value = try container.decode(DeliverToQBusinessAction.self, forKey: .deliverToQBusiness)
                self = .deliverToQBusiness(value)
            case .drop:
                let value = try container.decode(DropAction.self, forKey: .drop)
                self = .drop(value)
            case .relay:
                let value = try container.decode(RelayAction.self, forKey: .relay)
                self = .relay(value)
            case .replaceRecipient:
                let value = try container.decode(ReplaceRecipientAction.self, forKey: .replaceRecipient)
                self = .replaceRecipient(value)
            case .send:
                let value = try container.decode(SendAction.self, forKey: .send)
                self = .send(value)
            case .writeToS3:
                let value = try container.decode(S3Action.self, forKey: .writeToS3)
                self = .writeToS3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .addHeader(let value):
                try container.encode(value, forKey: .addHeader)
            case .archive(let value):
                try container.encode(value, forKey: .archive)
            case .deliverToMailbox(let value):
                try container.encode(value, forKey: .deliverToMailbox)
            case .deliverToQBusiness(let value):
                try container.encode(value, forKey: .deliverToQBusiness)
            case .drop(let value):
                try container.encode(value, forKey: .drop)
            case .relay(let value):
                try container.encode(value, forKey: .relay)
            case .replaceRecipient(let value):
                try container.encode(value, forKey: .replaceRecipient)
            case .send(let value):
                try container.encode(value, forKey: .send)
            case .writeToS3(let value):
                try container.encode(value, forKey: .writeToS3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .addHeader(let value):
                try value.validate(name: "\(name).addHeader")
            case .archive(let value):
                try value.validate(name: "\(name).archive")
            case .deliverToMailbox(let value):
                try value.validate(name: "\(name).deliverToMailbox")
            case .deliverToQBusiness(let value):
                try value.validate(name: "\(name).deliverToQBusiness")
            case .relay(let value):
                try value.validate(name: "\(name).relay")
            case .replaceRecipient(let value):
                try value.validate(name: "\(name).replaceRecipient")
            case .send(let value):
                try value.validate(name: "\(name).send")
            case .writeToS3(let value):
                try value.validate(name: "\(name).writeToS3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case addHeader = "AddHeader"
            case archive = "Archive"
            case deliverToMailbox = "DeliverToMailbox"
            case deliverToQBusiness = "DeliverToQBusiness"
            case drop = "Drop"
            case relay = "Relay"
            case replaceRecipient = "ReplaceRecipient"
            case send = "Send"
            case writeToS3 = "WriteToS3"
        }
    }

    public enum RuleBooleanToEvaluate: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The boolean type representing the allowed attribute types for an email.
        case attribute(RuleBooleanEmailAttribute)
        /// The structure representing the address lists and address list attribute that will be used in evaluation of boolean expression.
        case isInAddressList(RuleIsInAddressList)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .attribute:
                let value = try container.decode(RuleBooleanEmailAttribute.self, forKey: .attribute)
                self = .attribute(value)
            case .isInAddressList:
                let value = try container.decode(RuleIsInAddressList.self, forKey: .isInAddressList)
                self = .isInAddressList(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .attribute(let value):
                try container.encode(value, forKey: .attribute)
            case .isInAddressList(let value):
                try container.encode(value, forKey: .isInAddressList)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .isInAddressList(let value):
                try value.validate(name: "\(name).isInAddressList")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
            case isInAddressList = "IsInAddressList"
        }
    }

    public enum RuleCondition: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The condition applies to a boolean expression passed in this field.
        case booleanExpression(RuleBooleanExpression)
        /// The condition applies to a DMARC policy expression passed in this field.
        case dmarcExpression(RuleDmarcExpression)
        /// The condition applies to an IP address expression passed in this field.
        case ipExpression(RuleIpExpression)
        /// The condition applies to a number expression passed in this field.
        case numberExpression(RuleNumberExpression)
        /// The condition applies to a string expression passed in this field.
        case stringExpression(RuleStringExpression)
        /// The condition applies to a verdict expression passed in this field.
        case verdictExpression(RuleVerdictExpression)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .booleanExpression:
                let value = try container.decode(RuleBooleanExpression.self, forKey: .booleanExpression)
                self = .booleanExpression(value)
            case .dmarcExpression:
                let value = try container.decode(RuleDmarcExpression.self, forKey: .dmarcExpression)
                self = .dmarcExpression(value)
            case .ipExpression:
                let value = try container.decode(RuleIpExpression.self, forKey: .ipExpression)
                self = .ipExpression(value)
            case .numberExpression:
                let value = try container.decode(RuleNumberExpression.self, forKey: .numberExpression)
                self = .numberExpression(value)
            case .stringExpression:
                let value = try container.decode(RuleStringExpression.self, forKey: .stringExpression)
                self = .stringExpression(value)
            case .verdictExpression:
                let value = try container.decode(RuleVerdictExpression.self, forKey: .verdictExpression)
                self = .verdictExpression(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .booleanExpression(let value):
                try container.encode(value, forKey: .booleanExpression)
            case .dmarcExpression(let value):
                try container.encode(value, forKey: .dmarcExpression)
            case .ipExpression(let value):
                try container.encode(value, forKey: .ipExpression)
            case .numberExpression(let value):
                try container.encode(value, forKey: .numberExpression)
            case .stringExpression(let value):
                try container.encode(value, forKey: .stringExpression)
            case .verdictExpression(let value):
                try container.encode(value, forKey: .verdictExpression)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .booleanExpression(let value):
                try value.validate(name: "\(name).booleanExpression")
            case .dmarcExpression(let value):
                try value.validate(name: "\(name).dmarcExpression")
            case .ipExpression(let value):
                try value.validate(name: "\(name).ipExpression")
            case .stringExpression(let value):
                try value.validate(name: "\(name).stringExpression")
            case .verdictExpression(let value):
                try value.validate(name: "\(name).verdictExpression")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case booleanExpression = "BooleanExpression"
            case dmarcExpression = "DmarcExpression"
            case ipExpression = "IpExpression"
            case numberExpression = "NumberExpression"
            case stringExpression = "StringExpression"
            case verdictExpression = "VerdictExpression"
        }
    }

    public enum RuleStringToEvaluate: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The email attribute to evaluate in a string condition expression.
        case attribute(RuleStringEmailAttribute)
        /// The email MIME X-Header attribute to evaluate in a string condition expression.
        case mimeHeaderAttribute(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .attribute:
                let value = try container.decode(RuleStringEmailAttribute.self, forKey: .attribute)
                self = .attribute(value)
            case .mimeHeaderAttribute:
                let value = try container.decode(String.self, forKey: .mimeHeaderAttribute)
                self = .mimeHeaderAttribute(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .attribute(let value):
                try container.encode(value, forKey: .attribute)
            case .mimeHeaderAttribute(let value):
                try container.encode(value, forKey: .mimeHeaderAttribute)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .mimeHeaderAttribute(let value):
                try self.validate(value, name: "mimeHeaderAttribute", parent: name, pattern: "^X-[a-zA-Z0-9-]{1,256}$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
            case mimeHeaderAttribute = "MimeHeaderAttribute"
        }
    }

    public enum RuleVerdictToEvaluate: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The Add On ARN and its returned value to evaluate in a verdict condition expression.
        case analysis(Analysis)
        /// The email verdict attribute to evaluate in a string verdict expression.
        case attribute(RuleVerdictAttribute)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .analysis:
                let value = try container.decode(Analysis.self, forKey: .analysis)
                self = .analysis(value)
            case .attribute:
                let value = try container.decode(RuleVerdictAttribute.self, forKey: .attribute)
                self = .attribute(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .analysis(let value):
                try container.encode(value, forKey: .analysis)
            case .attribute(let value):
                try container.encode(value, forKey: .attribute)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .analysis(let value):
                try value.validate(name: "\(name).analysis")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analysis = "Analysis"
            case attribute = "Attribute"
        }
    }

    // MARK: Shapes

    public struct AddHeaderAction: AWSEncodableShape & AWSDecodableShape {
        /// The name of the header to add to an email. The header must be prefixed with "X-". Headers are added regardless of whether the header name pre-existed in the email.
        public let headerName: String
        /// The value of the header to add to the email.
        public let headerValue: String

        @inlinable
        public init(headerName: String, headerValue: String) {
            self.headerName = headerName
            self.headerValue = headerValue
        }

        public func validate(name: String) throws {
            try self.validate(self.headerName, name: "headerName", parent: name, max: 64)
            try self.validate(self.headerName, name: "headerName", parent: name, min: 1)
            try self.validate(self.headerName, name: "headerName", parent: name, pattern: "^[xX]\\-[a-zA-Z0-9\\-]+$")
            try self.validate(self.headerValue, name: "headerValue", parent: name, max: 128)
            try self.validate(self.headerValue, name: "headerValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case headerName = "HeaderName"
            case headerValue = "HeaderValue"
        }
    }

    public struct AddonInstance: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Add On instance.
        public let addonInstanceArn: String?
        /// The unique ID of the Add On instance.
        public let addonInstanceId: String?
        /// The name of the Add On for the instance.
        public let addonName: String?
        /// The subscription ID for the instance.
        public let addonSubscriptionId: String?
        /// The timestamp of when the Add On instance was created.
        public let createdTimestamp: Date?

        @inlinable
        public init(addonInstanceArn: String? = nil, addonInstanceId: String? = nil, addonName: String? = nil, addonSubscriptionId: String? = nil, createdTimestamp: Date? = nil) {
            self.addonInstanceArn = addonInstanceArn
            self.addonInstanceId = addonInstanceId
            self.addonName = addonName
            self.addonSubscriptionId = addonSubscriptionId
            self.createdTimestamp = createdTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case addonInstanceArn = "AddonInstanceArn"
            case addonInstanceId = "AddonInstanceId"
            case addonName = "AddonName"
            case addonSubscriptionId = "AddonSubscriptionId"
            case createdTimestamp = "CreatedTimestamp"
        }
    }

    public struct AddonSubscription: AWSDecodableShape {
        /// The name of the Add On.
        public let addonName: String?
        /// The Amazon Resource Name (ARN) of the Add On subscription.
        public let addonSubscriptionArn: String?
        /// The unique ID of the Add On subscription.
        public let addonSubscriptionId: String?
        /// The timestamp of when the Add On subscription was created.
        public let createdTimestamp: Date?

        @inlinable
        public init(addonName: String? = nil, addonSubscriptionArn: String? = nil, addonSubscriptionId: String? = nil, createdTimestamp: Date? = nil) {
            self.addonName = addonName
            self.addonSubscriptionArn = addonSubscriptionArn
            self.addonSubscriptionId = addonSubscriptionId
            self.createdTimestamp = createdTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case addonName = "AddonName"
            case addonSubscriptionArn = "AddonSubscriptionArn"
            case addonSubscriptionId = "AddonSubscriptionId"
            case createdTimestamp = "CreatedTimestamp"
        }
    }

    public struct AddressFilter: AWSEncodableShape {
        /// Filter to limit the results to addresses having the provided prefix.
        public let addressPrefix: String?

        @inlinable
        public init(addressPrefix: String? = nil) {
            self.addressPrefix = addressPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.addressPrefix, name: "addressPrefix", parent: name, max: 320)
            try self.validate(self.addressPrefix, name: "addressPrefix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case addressPrefix = "AddressPrefix"
        }
    }

    public struct AddressList: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the address list.
        public let addressListArn: String
        /// The identifier of the address list.
        public let addressListId: String
        /// The user-friendly name of the address list.
        public let addressListName: String
        /// The timestamp of when the address list was created.
        public let createdTimestamp: Date
        /// The timestamp of when the address list was last updated.
        public let lastUpdatedTimestamp: Date

        @inlinable
        public init(addressListArn: String, addressListId: String, addressListName: String, createdTimestamp: Date, lastUpdatedTimestamp: Date) {
            self.addressListArn = addressListArn
            self.addressListId = addressListId
            self.addressListName = addressListName
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case addressListArn = "AddressListArn"
            case addressListId = "AddressListId"
            case addressListName = "AddressListName"
            case createdTimestamp = "CreatedTimestamp"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        }
    }

    public struct Analysis: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Add On.
        public let analyzer: String
        /// The returned value from an Add On.
        public let resultField: String

        @inlinable
        public init(analyzer: String, resultField: String) {
            self.analyzer = analyzer
            self.resultField = resultField
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzer, name: "analyzer", parent: name, pattern: "^[a-zA-Z0-9:_/+=,@.#-]+$")
            try self.validate(self.resultField, name: "resultField", parent: name, max: 256)
            try self.validate(self.resultField, name: "resultField", parent: name, min: 1)
            try self.validate(self.resultField, name: "resultField", parent: name, pattern: "^[\\sa-zA-Z0-9_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzer = "Analyzer"
            case resultField = "ResultField"
        }
    }

    public struct Archive: AWSDecodableShape {
        /// The unique identifier of the archive.
        public let archiveId: String
        /// The unique name assigned to the archive.
        public let archiveName: String?
        /// The current state of the archive:    ACTIVE – The archive is ready and available for use.     PENDING_DELETION – The archive has been marked for deletion and will be permanently deleted in 30 days. No further modifications can be made in this state.
        public let archiveState: ArchiveState?
        /// The timestamp of when the archive was last updated.
        public let lastUpdatedTimestamp: Date?

        @inlinable
        public init(archiveId: String, archiveName: String? = nil, archiveState: ArchiveState? = nil, lastUpdatedTimestamp: Date? = nil) {
            self.archiveId = archiveId
            self.archiveName = archiveName
            self.archiveState = archiveState
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
            case archiveName = "ArchiveName"
            case archiveState = "ArchiveState"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        }
    }

    public struct ArchiveAction: AWSEncodableShape & AWSDecodableShape {
        /// A policy that states what to do in the case of failure. The action will fail if there are configuration errors. For example, the specified archive has been deleted.
        public let actionFailurePolicy: ActionFailurePolicy?
        /// The identifier of the archive to send the email to.
        public let targetArchive: String

        @inlinable
        public init(actionFailurePolicy: ActionFailurePolicy? = nil, targetArchive: String) {
            self.actionFailurePolicy = actionFailurePolicy
            self.targetArchive = targetArchive
        }

        public func validate(name: String) throws {
            try self.validate(self.targetArchive, name: "targetArchive", parent: name, max: 2048)
            try self.validate(self.targetArchive, name: "targetArchive", parent: name, min: 1)
            try self.validate(self.targetArchive, name: "targetArchive", parent: name, pattern: "^[a-zA-Z0-9:_/+=,@.#-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionFailurePolicy = "ActionFailurePolicy"
            case targetArchive = "TargetArchive"
        }
    }

    public struct ArchiveBooleanExpression: AWSEncodableShape & AWSDecodableShape {
        /// The email attribute value to evaluate.
        public let evaluate: ArchiveBooleanToEvaluate
        /// The boolean operator to use for evaluation.
        public let `operator`: ArchiveBooleanOperator

        @inlinable
        public init(evaluate: ArchiveBooleanToEvaluate, operator: ArchiveBooleanOperator) {
            self.evaluate = evaluate
            self.`operator` = `operator`
        }

        private enum CodingKeys: String, CodingKey {
            case evaluate = "Evaluate"
            case `operator` = "Operator"
        }
    }

    public struct ArchiveFilters: AWSEncodableShape & AWSDecodableShape {
        /// The filter conditions for emails to include.
        public let include: [ArchiveFilterCondition]?
        /// The filter conditions for emails to exclude.
        public let unless: [ArchiveFilterCondition]?

        @inlinable
        public init(include: [ArchiveFilterCondition]? = nil, unless: [ArchiveFilterCondition]? = nil) {
            self.include = include
            self.unless = unless
        }

        public func validate(name: String) throws {
            try self.include?.forEach {
                try $0.validate(name: "\(name).include[]")
            }
            try self.validate(self.include, name: "include", parent: name, max: 10)
            try self.unless?.forEach {
                try $0.validate(name: "\(name).unless[]")
            }
            try self.validate(self.unless, name: "unless", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case include = "Include"
            case unless = "Unless"
        }
    }

    public struct ArchiveStringExpression: AWSEncodableShape & AWSDecodableShape {
        /// The attribute of the email to evaluate.
        public let evaluate: ArchiveStringToEvaluate
        /// The operator to use when evaluating the string values.
        public let `operator`: ArchiveStringOperator
        /// The list of string values to evaluate the email attribute against.
        public let values: [String]

        @inlinable
        public init(evaluate: ArchiveStringToEvaluate, operator: ArchiveStringOperator, values: [String]) {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 2048)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case evaluate = "Evaluate"
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct CreateAddonInstanceRequest: AWSEncodableShape {
        /// The unique ID of a previously created subscription that an Add On instance is created for. You can only have one instance per subscription.
        public let addonSubscriptionId: String
        /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
        public let clientToken: String?
        /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [Tag]?

        @inlinable
        public init(addonSubscriptionId: String, clientToken: String? = CreateAddonInstanceRequest.idempotencyToken(), tags: [Tag]? = nil) {
            self.addonSubscriptionId = addonSubscriptionId
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.addonSubscriptionId, name: "addonSubscriptionId", parent: name, max: 67)
            try self.validate(self.addonSubscriptionId, name: "addonSubscriptionId", parent: name, min: 4)
            try self.validate(self.addonSubscriptionId, name: "addonSubscriptionId", parent: name, pattern: "^as-[a-zA-Z0-9]{1,64}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case addonSubscriptionId = "AddonSubscriptionId"
            case clientToken = "ClientToken"
            case tags = "Tags"
        }
    }

    public struct CreateAddonInstanceResponse: AWSDecodableShape {
        /// The unique ID of the Add On instance created by this API.
        public let addonInstanceId: String

        @inlinable
        public init(addonInstanceId: String) {
            self.addonInstanceId = addonInstanceId
        }

        private enum CodingKeys: String, CodingKey {
            case addonInstanceId = "AddonInstanceId"
        }
    }

    public struct CreateAddonSubscriptionRequest: AWSEncodableShape {
        /// The name of the Add On to subscribe to. You can only have one subscription for each Add On name.
        public let addonName: String
        /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
        public let clientToken: String?
        /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [Tag]?

        @inlinable
        public init(addonName: String, clientToken: String? = CreateAddonSubscriptionRequest.idempotencyToken(), tags: [Tag]? = nil) {
            self.addonName = addonName
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case addonName = "AddonName"
            case clientToken = "ClientToken"
            case tags = "Tags"
        }
    }

    public struct CreateAddonSubscriptionResponse: AWSDecodableShape {
        /// The unique ID of the Add On subscription created by this API.
        public let addonSubscriptionId: String

        @inlinable
        public init(addonSubscriptionId: String) {
            self.addonSubscriptionId = addonSubscriptionId
        }

        private enum CodingKeys: String, CodingKey {
            case addonSubscriptionId = "AddonSubscriptionId"
        }
    }

    public struct CreateAddressListImportJobRequest: AWSEncodableShape {
        /// The unique identifier of the address list for importing addresses to.
        public let addressListId: String
        /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
        public let clientToken: String?
        /// The format of the input for an import job.
        public let importDataFormat: ImportDataFormat
        /// A user-friendly name for the import job.
        public let name: String

        @inlinable
        public init(addressListId: String, clientToken: String? = CreateAddressListImportJobRequest.idempotencyToken(), importDataFormat: ImportDataFormat, name: String) {
            self.addressListId = addressListId
            self.clientToken = clientToken
            self.importDataFormat = importDataFormat
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.addressListId, name: "addressListId", parent: name, max: 255)
            try self.validate(self.addressListId, name: "addressListId", parent: name, min: 1)
            try self.validate(self.addressListId, name: "addressListId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case addressListId = "AddressListId"
            case clientToken = "ClientToken"
            case importDataFormat = "ImportDataFormat"
            case name = "Name"
        }
    }

    public struct CreateAddressListImportJobResponse: AWSDecodableShape {
        /// The identifier of the created import job.
        public let jobId: String
        /// The pre-signed URL target for uploading the input file.
        public let preSignedUrl: String

        @inlinable
        public init(jobId: String, preSignedUrl: String) {
            self.jobId = jobId
            self.preSignedUrl = preSignedUrl
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case preSignedUrl = "PreSignedUrl"
        }
    }

    public struct CreateAddressListRequest: AWSEncodableShape {
        /// A user-friendly name for the address list.
        public let addressListName: String
        /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
        public let clientToken: String?
        /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [Tag]?

        @inlinable
        public init(addressListName: String, clientToken: String? = CreateAddressListRequest.idempotencyToken(), tags: [Tag]? = nil) {
            self.addressListName = addressListName
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.addressListName, name: "addressListName", parent: name, max: 255)
            try self.validate(self.addressListName, name: "addressListName", parent: name, min: 1)
            try self.validate(self.addressListName, name: "addressListName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case addressListName = "AddressListName"
            case clientToken = "ClientToken"
            case tags = "Tags"
        }
    }

    public struct CreateAddressListResponse: AWSDecodableShape {
        /// The identifier of the created address list.
        public let addressListId: String

        @inlinable
        public init(addressListId: String) {
            self.addressListId = addressListId
        }

        private enum CodingKeys: String, CodingKey {
            case addressListId = "AddressListId"
        }
    }

    public struct CreateArchiveRequest: AWSEncodableShape {
        /// A unique name for the new archive.
        public let archiveName: String
        /// A unique token Amazon SES uses to recognize retries of this request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the KMS key for encrypting emails in the archive.
        public let kmsKeyArn: String?
        /// The period for retaining emails in the archive before automatic deletion.
        public let retention: ArchiveRetention?
        /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [Tag]?

        @inlinable
        public init(archiveName: String, clientToken: String? = CreateArchiveRequest.idempotencyToken(), kmsKeyArn: String? = nil, retention: ArchiveRetention? = nil, tags: [Tag]? = nil) {
            self.archiveName = archiveName
            self.clientToken = clientToken
            self.kmsKeyArn = kmsKeyArn
            self.retention = retention
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.archiveName, name: "archiveName", parent: name, max: 64)
            try self.validate(self.archiveName, name: "archiveName", parent: name, min: 1)
            try self.validate(self.archiveName, name: "archiveName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*[a-zA-Z0-9]$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-z0-9-]{1,20}:[0-9]{12}:(key|alias)/.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case archiveName = "ArchiveName"
            case clientToken = "ClientToken"
            case kmsKeyArn = "KmsKeyArn"
            case retention = "Retention"
            case tags = "Tags"
        }
    }

    public struct CreateArchiveResponse: AWSDecodableShape {
        /// The unique identifier for the newly created archive.
        public let archiveId: String

        @inlinable
        public init(archiveId: String) {
            self.archiveId = archiveId
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
        }
    }

    public struct CreateIngressPointRequest: AWSEncodableShape {
        /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
        public let clientToken: String?
        /// If you choose an Authenticated ingress endpoint, you must configure either an SMTP password or a secret ARN.
        public let ingressPointConfiguration: IngressPointConfiguration?
        /// A user friendly name for an ingress endpoint resource.
        public let ingressPointName: String
        /// The identifier of an existing rule set that you attach to an ingress endpoint resource.
        public let ruleSetId: String
        /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [Tag]?
        /// The identifier of an existing traffic policy that you attach to an ingress endpoint resource.
        public let trafficPolicyId: String
        /// The type of the ingress endpoint to create.
        public let type: IngressPointType

        @inlinable
        public init(clientToken: String? = CreateIngressPointRequest.idempotencyToken(), ingressPointConfiguration: IngressPointConfiguration? = nil, ingressPointName: String, ruleSetId: String, tags: [Tag]? = nil, trafficPolicyId: String, type: IngressPointType) {
            self.clientToken = clientToken
            self.ingressPointConfiguration = ingressPointConfiguration
            self.ingressPointName = ingressPointName
            self.ruleSetId = ruleSetId
            self.tags = tags
            self.trafficPolicyId = trafficPolicyId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.ingressPointConfiguration?.validate(name: "\(name).ingressPointConfiguration")
            try self.validate(self.ingressPointName, name: "ingressPointName", parent: name, max: 63)
            try self.validate(self.ingressPointName, name: "ingressPointName", parent: name, min: 3)
            try self.validate(self.ingressPointName, name: "ingressPointName", parent: name, pattern: "^[A-Za-z0-9_\\-]+$")
            try self.validate(self.ruleSetId, name: "ruleSetId", parent: name, max: 100)
            try self.validate(self.ruleSetId, name: "ruleSetId", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.trafficPolicyId, name: "trafficPolicyId", parent: name, max: 100)
            try self.validate(self.trafficPolicyId, name: "trafficPolicyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case ingressPointConfiguration = "IngressPointConfiguration"
            case ingressPointName = "IngressPointName"
            case ruleSetId = "RuleSetId"
            case tags = "Tags"
            case trafficPolicyId = "TrafficPolicyId"
            case type = "Type"
        }
    }

    public struct CreateIngressPointResponse: AWSDecodableShape {
        /// The unique identifier for a previously created ingress endpoint.
        public let ingressPointId: String

        @inlinable
        public init(ingressPointId: String) {
            self.ingressPointId = ingressPointId
        }

        private enum CodingKeys: String, CodingKey {
            case ingressPointId = "IngressPointId"
        }
    }

    public struct CreateRelayRequest: AWSEncodableShape {
        /// Authentication for the relay destination server—specify the secretARN where the SMTP credentials are stored.
        public let authentication: RelayAuthentication
        /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
        public let clientToken: String?
        /// The unique name of the relay resource.
        public let relayName: String
        /// The destination relay server address.
        public let serverName: String
        /// The destination relay server port.
        public let serverPort: Int
        /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [Tag]?

        @inlinable
        public init(authentication: RelayAuthentication, clientToken: String? = CreateRelayRequest.idempotencyToken(), relayName: String, serverName: String, serverPort: Int, tags: [Tag]? = nil) {
            self.authentication = authentication
            self.clientToken = clientToken
            self.relayName = relayName
            self.serverName = serverName
            self.serverPort = serverPort
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.authentication.validate(name: "\(name).authentication")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.relayName, name: "relayName", parent: name, max: 100)
            try self.validate(self.relayName, name: "relayName", parent: name, min: 1)
            try self.validate(self.relayName, name: "relayName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.serverName, name: "serverName", parent: name, max: 100)
            try self.validate(self.serverName, name: "serverName", parent: name, min: 1)
            try self.validate(self.serverName, name: "serverName", parent: name, pattern: "^[a-zA-Z0-9-\\.]+$")
            try self.validate(self.serverPort, name: "serverPort", parent: name, max: 65535)
            try self.validate(self.serverPort, name: "serverPort", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case authentication = "Authentication"
            case clientToken = "ClientToken"
            case relayName = "RelayName"
            case serverName = "ServerName"
            case serverPort = "ServerPort"
            case tags = "Tags"
        }
    }

    public struct CreateRelayResponse: AWSDecodableShape {
        /// A unique identifier of the created relay resource.
        public let relayId: String

        @inlinable
        public init(relayId: String) {
            self.relayId = relayId
        }

        private enum CodingKeys: String, CodingKey {
            case relayId = "RelayId"
        }
    }

    public struct CreateRuleSetRequest: AWSEncodableShape {
        /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
        public let clientToken: String?
        /// Conditional rules that are evaluated for determining actions on email.
        public let rules: [Rule]
        /// A user-friendly name for the rule set.
        public let ruleSetName: String
        /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateRuleSetRequest.idempotencyToken(), rules: [Rule], ruleSetName: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.rules = rules
            self.ruleSetName = ruleSetName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 40)
            try self.validate(self.ruleSetName, name: "ruleSetName", parent: name, max: 100)
            try self.validate(self.ruleSetName, name: "ruleSetName", parent: name, min: 1)
            try self.validate(self.ruleSetName, name: "ruleSetName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case rules = "Rules"
            case ruleSetName = "RuleSetName"
            case tags = "Tags"
        }
    }

    public struct CreateRuleSetResponse: AWSDecodableShape {
        /// The identifier of the created rule set.
        public let ruleSetId: String

        @inlinable
        public init(ruleSetId: String) {
            self.ruleSetId = ruleSetId
        }

        private enum CodingKeys: String, CodingKey {
            case ruleSetId = "RuleSetId"
        }
    }

    public struct CreateTrafficPolicyRequest: AWSEncodableShape {
        /// A unique token that Amazon SES uses to recognize subsequent retries of the same request.
        public let clientToken: String?
        /// Default action instructs the traﬃc policy to either Allow or Deny (block) messages that fall outside of (or not addressed by) the conditions of your policy statements
        public let defaultAction: AcceptAction
        /// The maximum message size in bytes of email which is allowed in by this traffic policy—anything larger will be blocked.
        public let maxMessageSizeBytes: Int?
        /// Conditional statements for filtering email traffic.
        public let policyStatements: [PolicyStatement]
        /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [Tag]?
        /// A user-friendly name for the traffic policy resource.
        public let trafficPolicyName: String

        @inlinable
        public init(clientToken: String? = CreateTrafficPolicyRequest.idempotencyToken(), defaultAction: AcceptAction, maxMessageSizeBytes: Int? = nil, policyStatements: [PolicyStatement], tags: [Tag]? = nil, trafficPolicyName: String) {
            self.clientToken = clientToken
            self.defaultAction = defaultAction
            self.maxMessageSizeBytes = maxMessageSizeBytes
            self.policyStatements = policyStatements
            self.tags = tags
            self.trafficPolicyName = trafficPolicyName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.maxMessageSizeBytes, name: "maxMessageSizeBytes", parent: name, min: 1)
            try self.policyStatements.forEach {
                try $0.validate(name: "\(name).policyStatements[]")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.trafficPolicyName, name: "trafficPolicyName", parent: name, max: 63)
            try self.validate(self.trafficPolicyName, name: "trafficPolicyName", parent: name, min: 3)
            try self.validate(self.trafficPolicyName, name: "trafficPolicyName", parent: name, pattern: "^[A-Za-z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case defaultAction = "DefaultAction"
            case maxMessageSizeBytes = "MaxMessageSizeBytes"
            case policyStatements = "PolicyStatements"
            case tags = "Tags"
            case trafficPolicyName = "TrafficPolicyName"
        }
    }

    public struct CreateTrafficPolicyResponse: AWSDecodableShape {
        /// The identifier of the traffic policy resource.
        public let trafficPolicyId: String

        @inlinable
        public init(trafficPolicyId: String) {
            self.trafficPolicyId = trafficPolicyId
        }

        private enum CodingKeys: String, CodingKey {
            case trafficPolicyId = "TrafficPolicyId"
        }
    }

    public struct DeleteAddonInstanceRequest: AWSEncodableShape {
        /// The Add On instance ID to delete.
        public let addonInstanceId: String

        @inlinable
        public init(addonInstanceId: String) {
            self.addonInstanceId = addonInstanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.addonInstanceId, name: "addonInstanceId", parent: name, max: 67)
            try self.validate(self.addonInstanceId, name: "addonInstanceId", parent: name, min: 4)
            try self.validate(self.addonInstanceId, name: "addonInstanceId", parent: name, pattern: "^ai-[a-zA-Z0-9]{1,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case addonInstanceId = "AddonInstanceId"
        }
    }

    public struct DeleteAddonInstanceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAddonSubscriptionRequest: AWSEncodableShape {
        /// The Add On subscription ID to delete.
        public let addonSubscriptionId: String

        @inlinable
        public init(addonSubscriptionId: String) {
            self.addonSubscriptionId = addonSubscriptionId
        }

        public func validate(name: String) throws {
            try self.validate(self.addonSubscriptionId, name: "addonSubscriptionId", parent: name, max: 67)
            try self.validate(self.addonSubscriptionId, name: "addonSubscriptionId", parent: name, min: 4)
            try self.validate(self.addonSubscriptionId, name: "addonSubscriptionId", parent: name, pattern: "^as-[a-zA-Z0-9]{1,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case addonSubscriptionId = "AddonSubscriptionId"
        }
    }

    public struct DeleteAddonSubscriptionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAddressListRequest: AWSEncodableShape {
        /// The identifier of an existing address list resource to delete.
        public let addressListId: String

        @inlinable
        public init(addressListId: String) {
            self.addressListId = addressListId
        }

        public func validate(name: String) throws {
            try self.validate(self.addressListId, name: "addressListId", parent: name, max: 255)
            try self.validate(self.addressListId, name: "addressListId", parent: name, min: 1)
            try self.validate(self.addressListId, name: "addressListId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case addressListId = "AddressListId"
        }
    }

    public struct DeleteAddressListResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteArchiveRequest: AWSEncodableShape {
        /// The identifier of the archive to delete.
        public let archiveId: String

        @inlinable
        public init(archiveId: String) {
            self.archiveId = archiveId
        }

        public func validate(name: String) throws {
            try self.validate(self.archiveId, name: "archiveId", parent: name, max: 66)
            try self.validate(self.archiveId, name: "archiveId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
        }
    }

    public struct DeleteArchiveResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIngressPointRequest: AWSEncodableShape {
        /// The identifier of the ingress endpoint resource that you want to delete.
        public let ingressPointId: String

        @inlinable
        public init(ingressPointId: String) {
            self.ingressPointId = ingressPointId
        }

        public func validate(name: String) throws {
            try self.validate(self.ingressPointId, name: "ingressPointId", parent: name, max: 100)
            try self.validate(self.ingressPointId, name: "ingressPointId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ingressPointId = "IngressPointId"
        }
    }

    public struct DeleteIngressPointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRelayRequest: AWSEncodableShape {
        /// The unique relay identifier.
        public let relayId: String

        @inlinable
        public init(relayId: String) {
            self.relayId = relayId
        }

        public func validate(name: String) throws {
            try self.validate(self.relayId, name: "relayId", parent: name, max: 100)
            try self.validate(self.relayId, name: "relayId", parent: name, min: 1)
            try self.validate(self.relayId, name: "relayId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case relayId = "RelayId"
        }
    }

    public struct DeleteRelayResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRuleSetRequest: AWSEncodableShape {
        /// The identifier of an existing rule set resource to delete.
        public let ruleSetId: String

        @inlinable
        public init(ruleSetId: String) {
            self.ruleSetId = ruleSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleSetId, name: "ruleSetId", parent: name, max: 100)
            try self.validate(self.ruleSetId, name: "ruleSetId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ruleSetId = "RuleSetId"
        }
    }

    public struct DeleteRuleSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTrafficPolicyRequest: AWSEncodableShape {
        /// The identifier of the traffic policy that you want to delete.
        public let trafficPolicyId: String

        @inlinable
        public init(trafficPolicyId: String) {
            self.trafficPolicyId = trafficPolicyId
        }

        public func validate(name: String) throws {
            try self.validate(self.trafficPolicyId, name: "trafficPolicyId", parent: name, max: 100)
            try self.validate(self.trafficPolicyId, name: "trafficPolicyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case trafficPolicyId = "TrafficPolicyId"
        }
    }

    public struct DeleteTrafficPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeliverToMailboxAction: AWSEncodableShape & AWSDecodableShape {
        /// A policy that states what to do in the case of failure. The action will fail if there are configuration errors. For example, the mailbox ARN is no longer valid.
        public let actionFailurePolicy: ActionFailurePolicy?
        /// The Amazon Resource Name (ARN) of a WorkMail organization to deliver the email to.
        public let mailboxArn: String
        /// The Amazon Resource Name (ARN) of an IAM role to use to execute this action. The role must have access to the workmail:DeliverToMailbox API.
        public let roleArn: String

        @inlinable
        public init(actionFailurePolicy: ActionFailurePolicy? = nil, mailboxArn: String, roleArn: String) {
            self.actionFailurePolicy = actionFailurePolicy
            self.mailboxArn = mailboxArn
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.mailboxArn, name: "mailboxArn", parent: name, max: 2048)
            try self.validate(self.mailboxArn, name: "mailboxArn", parent: name, min: 1)
            try self.validate(self.mailboxArn, name: "mailboxArn", parent: name, pattern: "^[a-zA-Z0-9:_/+=,@.#-]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^[a-zA-Z0-9:_/+=,@.#-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionFailurePolicy = "ActionFailurePolicy"
            case mailboxArn = "MailboxArn"
            case roleArn = "RoleArn"
        }
    }

    public struct DeliverToQBusinessAction: AWSEncodableShape & AWSDecodableShape {
        /// A policy that states what to do in the case of failure. The action will fail if there are configuration errors. For example, the specified application has been deleted or the role lacks necessary permissions to call the qbusiness:BatchPutDocument API.
        public let actionFailurePolicy: ActionFailurePolicy?
        /// The unique identifier of the Amazon Q Business application instance where the email content will be delivered.
        public let applicationId: String
        /// The identifier of the knowledge base index within the Amazon Q Business application where the email content will be stored and indexed.
        public let indexId: String
        /// The Amazon Resource Name (ARN) of the IAM Role to use while delivering to Amazon Q Business. This role must have access to the qbusiness:BatchPutDocument API for the given application and index.
        public let roleArn: String

        @inlinable
        public init(actionFailurePolicy: ActionFailurePolicy? = nil, applicationId: String, indexId: String, roleArn: String) {
            self.actionFailurePolicy = actionFailurePolicy
            self.applicationId = applicationId
            self.indexId = indexId
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9-]+$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-z0-9-]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^[a-zA-Z0-9:_/+=,@.#-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionFailurePolicy = "ActionFailurePolicy"
            case applicationId = "ApplicationId"
            case indexId = "IndexId"
            case roleArn = "RoleArn"
        }
    }

    public struct DeregisterMemberFromAddressListRequest: AWSEncodableShape {
        /// The address to be removed from the address list.
        public let address: String
        /// The unique identifier of the address list to remove the address from.
        public let addressListId: String

        @inlinable
        public init(address: String, addressListId: String) {
            self.address = address
            self.addressListId = addressListId
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, max: 320)
            try self.validate(self.address, name: "address", parent: name, min: 3)
            try self.validate(self.addressListId, name: "addressListId", parent: name, max: 255)
            try self.validate(self.addressListId, name: "addressListId", parent: name, min: 1)
            try self.validate(self.addressListId, name: "addressListId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case addressListId = "AddressListId"
        }
    }

    public struct DeregisterMemberFromAddressListResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DropAction: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct Envelope: AWSDecodableShape {
        /// The RCPT FROM given by the host from which the email was received.
        public let from: String?
        /// The HELO used by the host from which the email was received.
        public let helo: String?
        /// All SMTP TO entries given by the host from which the email was received.
        public let to: [String]?

        @inlinable
        public init(from: String? = nil, helo: String? = nil, to: [String]? = nil) {
            self.from = from
            self.helo = helo
            self.to = to
        }

        private enum CodingKeys: String, CodingKey {
            case from = "From"
            case helo = "Helo"
            case to = "To"
        }
    }

    public struct ExportStatus: AWSDecodableShape {
        /// The timestamp of when the export job completed (if finished).
        public let completionTimestamp: Date?
        /// An error message if the export job failed.
        public let errorMessage: String?
        /// The current state of the export job.
        public let state: ExportState?
        /// The timestamp of when the export job was submitted.
        public let submissionTimestamp: Date?

        @inlinable
        public init(completionTimestamp: Date? = nil, errorMessage: String? = nil, state: ExportState? = nil, submissionTimestamp: Date? = nil) {
            self.completionTimestamp = completionTimestamp
            self.errorMessage = errorMessage
            self.state = state
            self.submissionTimestamp = submissionTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case completionTimestamp = "CompletionTimestamp"
            case errorMessage = "ErrorMessage"
            case state = "State"
            case submissionTimestamp = "SubmissionTimestamp"
        }
    }

    public struct ExportSummary: AWSDecodableShape {
        /// The unique identifier of the export job.
        public let exportId: String?
        /// The current status of the export job.
        public let status: ExportStatus?

        @inlinable
        public init(exportId: String? = nil, status: ExportStatus? = nil) {
            self.exportId = exportId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case exportId = "ExportId"
            case status = "Status"
        }
    }

    public struct GetAddonInstanceRequest: AWSEncodableShape {
        /// The Add On instance ID to retrieve information for.
        public let addonInstanceId: String

        @inlinable
        public init(addonInstanceId: String) {
            self.addonInstanceId = addonInstanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.addonInstanceId, name: "addonInstanceId", parent: name, max: 67)
            try self.validate(self.addonInstanceId, name: "addonInstanceId", parent: name, min: 4)
            try self.validate(self.addonInstanceId, name: "addonInstanceId", parent: name, pattern: "^ai-[a-zA-Z0-9]{1,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case addonInstanceId = "AddonInstanceId"
        }
    }

    public struct GetAddonInstanceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Add On instance.
        public let addonInstanceArn: String?
        /// The name of the Add On provider associated to the subscription of the instance.
        public let addonName: String?
        /// The subscription ID associated to the instance.
        public let addonSubscriptionId: String?
        /// The timestamp of when the Add On instance was created.
        public let createdTimestamp: Date?

        @inlinable
        public init(addonInstanceArn: String? = nil, addonName: String? = nil, addonSubscriptionId: String? = nil, createdTimestamp: Date? = nil) {
            self.addonInstanceArn = addonInstanceArn
            self.addonName = addonName
            self.addonSubscriptionId = addonSubscriptionId
            self.createdTimestamp = createdTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case addonInstanceArn = "AddonInstanceArn"
            case addonName = "AddonName"
            case addonSubscriptionId = "AddonSubscriptionId"
            case createdTimestamp = "CreatedTimestamp"
        }
    }

    public struct GetAddonSubscriptionRequest: AWSEncodableShape {
        /// The Add On subscription ID to retrieve information for.
        public let addonSubscriptionId: String

        @inlinable
        public init(addonSubscriptionId: String) {
            self.addonSubscriptionId = addonSubscriptionId
        }

        public func validate(name: String) throws {
            try self.validate(self.addonSubscriptionId, name: "addonSubscriptionId", parent: name, max: 67)
            try self.validate(self.addonSubscriptionId, name: "addonSubscriptionId", parent: name, min: 4)
            try self.validate(self.addonSubscriptionId, name: "addonSubscriptionId", parent: name, pattern: "^as-[a-zA-Z0-9]{1,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case addonSubscriptionId = "AddonSubscriptionId"
        }
    }

    public struct GetAddonSubscriptionResponse: AWSDecodableShape {
        /// The name of the Add On for the subscription.
        public let addonName: String?
        /// Amazon Resource Name (ARN) for the subscription.
        public let addonSubscriptionArn: String?
        /// The timestamp of when the Add On subscription was created.
        public let createdTimestamp: Date?

        @inlinable
        public init(addonName: String? = nil, addonSubscriptionArn: String? = nil, createdTimestamp: Date? = nil) {
            self.addonName = addonName
            self.addonSubscriptionArn = addonSubscriptionArn
            self.createdTimestamp = createdTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case addonName = "AddonName"
            case addonSubscriptionArn = "AddonSubscriptionArn"
            case createdTimestamp = "CreatedTimestamp"
        }
    }

    public struct GetAddressListImportJobRequest: AWSEncodableShape {
        /// The identifier of the import job that needs to be retrieved.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct GetAddressListImportJobResponse: AWSDecodableShape {
        /// The unique identifier of the address list the import job was created for.
        public let addressListId: String
        /// The timestamp of when the import job was completed.
        public let completedTimestamp: Date?
        /// The timestamp of when the import job was created.
        public let createdTimestamp: Date
        /// The reason for failure of an import job.
        public let error: String?
        /// The number of input addresses that failed to be imported into the address list.
        public let failedItemsCount: Int?
        /// The format of the input for an import job.
        public let importDataFormat: ImportDataFormat
        /// The number of input addresses successfully imported into the address list.
        public let importedItemsCount: Int?
        /// The identifier of the import job.
        public let jobId: String
        /// A user-friendly name for the import job.
        public let name: String
        /// The pre-signed URL target for uploading the input file.
        public let preSignedUrl: String
        /// The timestamp of when the import job was started.
        public let startTimestamp: Date?
        /// The status of the import job.
        public let status: ImportJobStatus

        @inlinable
        public init(addressListId: String, completedTimestamp: Date? = nil, createdTimestamp: Date, error: String? = nil, failedItemsCount: Int? = nil, importDataFormat: ImportDataFormat, importedItemsCount: Int? = nil, jobId: String, name: String, preSignedUrl: String, startTimestamp: Date? = nil, status: ImportJobStatus) {
            self.addressListId = addressListId
            self.completedTimestamp = completedTimestamp
            self.createdTimestamp = createdTimestamp
            self.error = error
            self.failedItemsCount = failedItemsCount
            self.importDataFormat = importDataFormat
            self.importedItemsCount = importedItemsCount
            self.jobId = jobId
            self.name = name
            self.preSignedUrl = preSignedUrl
            self.startTimestamp = startTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case addressListId = "AddressListId"
            case completedTimestamp = "CompletedTimestamp"
            case createdTimestamp = "CreatedTimestamp"
            case error = "Error"
            case failedItemsCount = "FailedItemsCount"
            case importDataFormat = "ImportDataFormat"
            case importedItemsCount = "ImportedItemsCount"
            case jobId = "JobId"
            case name = "Name"
            case preSignedUrl = "PreSignedUrl"
            case startTimestamp = "StartTimestamp"
            case status = "Status"
        }
    }

    public struct GetAddressListRequest: AWSEncodableShape {
        /// The identifier of an existing address list resource to be retrieved.
        public let addressListId: String

        @inlinable
        public init(addressListId: String) {
            self.addressListId = addressListId
        }

        public func validate(name: String) throws {
            try self.validate(self.addressListId, name: "addressListId", parent: name, max: 255)
            try self.validate(self.addressListId, name: "addressListId", parent: name, min: 1)
            try self.validate(self.addressListId, name: "addressListId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case addressListId = "AddressListId"
        }
    }

    public struct GetAddressListResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the address list resource.
        public let addressListArn: String
        /// The identifier of the address list resource.
        public let addressListId: String
        /// A user-friendly name for the address list resource.
        public let addressListName: String
        /// The date of when then address list was created.
        public let createdTimestamp: Date
        /// The date of when the address list was last updated.
        public let lastUpdatedTimestamp: Date

        @inlinable
        public init(addressListArn: String, addressListId: String, addressListName: String, createdTimestamp: Date, lastUpdatedTimestamp: Date) {
            self.addressListArn = addressListArn
            self.addressListId = addressListId
            self.addressListName = addressListName
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case addressListArn = "AddressListArn"
            case addressListId = "AddressListId"
            case addressListName = "AddressListName"
            case createdTimestamp = "CreatedTimestamp"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        }
    }

    public struct GetArchiveExportRequest: AWSEncodableShape {
        /// The identifier of the export job to get details for.
        public let exportId: String

        @inlinable
        public init(exportId: String) {
            self.exportId = exportId
        }

        public func validate(name: String) throws {
            try self.validate(self.exportId, name: "exportId", parent: name, max: 64)
            try self.validate(self.exportId, name: "exportId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exportId = "ExportId"
        }
    }

    public struct GetArchiveExportResponse: AWSDecodableShape {
        /// The identifier of the archive the email export was performed from.
        public let archiveId: String?
        /// Where the exported emails are being delivered.
        public let exportDestinationConfiguration: ExportDestinationConfiguration?
        /// The criteria used to filter emails included in the export.
        public let filters: ArchiveFilters?
        /// The start of the timestamp range the exported emails cover.
        public let fromTimestamp: Date?
        /// The maximum number of email items included in the export.
        public let maxResults: Int?
        /// The current status of the export job.
        public let status: ExportStatus?
        /// The end of the date range the exported emails cover.
        public let toTimestamp: Date?

        @inlinable
        public init(archiveId: String? = nil, exportDestinationConfiguration: ExportDestinationConfiguration? = nil, filters: ArchiveFilters? = nil, fromTimestamp: Date? = nil, maxResults: Int? = nil, status: ExportStatus? = nil, toTimestamp: Date? = nil) {
            self.archiveId = archiveId
            self.exportDestinationConfiguration = exportDestinationConfiguration
            self.filters = filters
            self.fromTimestamp = fromTimestamp
            self.maxResults = maxResults
            self.status = status
            self.toTimestamp = toTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
            case exportDestinationConfiguration = "ExportDestinationConfiguration"
            case filters = "Filters"
            case fromTimestamp = "FromTimestamp"
            case maxResults = "MaxResults"
            case status = "Status"
            case toTimestamp = "ToTimestamp"
        }
    }

    public struct GetArchiveMessageContentRequest: AWSEncodableShape {
        /// The unique identifier of the archived email message.
        public let archivedMessageId: String

        @inlinable
        public init(archivedMessageId: String) {
            self.archivedMessageId = archivedMessageId
        }

        private enum CodingKeys: String, CodingKey {
            case archivedMessageId = "ArchivedMessageId"
        }
    }

    public struct GetArchiveMessageContentResponse: AWSDecodableShape {
        /// The textual body content of the email message.
        public let body: MessageBody?

        @inlinable
        public init(body: MessageBody? = nil) {
            self.body = body
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
        }
    }

    public struct GetArchiveMessageRequest: AWSEncodableShape {
        /// The unique identifier of the archived email message.
        public let archivedMessageId: String

        @inlinable
        public init(archivedMessageId: String) {
            self.archivedMessageId = archivedMessageId
        }

        private enum CodingKeys: String, CodingKey {
            case archivedMessageId = "ArchivedMessageId"
        }
    }

    public struct GetArchiveMessageResponse: AWSDecodableShape {
        /// The SMTP envelope information of the email.
        public let envelope: Envelope?
        /// A pre-signed URL to temporarily download the full message content.
        public let messageDownloadLink: String?
        /// The metadata about the email.
        public let metadata: Metadata?

        @inlinable
        public init(envelope: Envelope? = nil, messageDownloadLink: String? = nil, metadata: Metadata? = nil) {
            self.envelope = envelope
            self.messageDownloadLink = messageDownloadLink
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case envelope = "Envelope"
            case messageDownloadLink = "MessageDownloadLink"
            case metadata = "Metadata"
        }
    }

    public struct GetArchiveRequest: AWSEncodableShape {
        /// The identifier of the archive to retrieve.
        public let archiveId: String

        @inlinable
        public init(archiveId: String) {
            self.archiveId = archiveId
        }

        public func validate(name: String) throws {
            try self.validate(self.archiveId, name: "archiveId", parent: name, max: 66)
            try self.validate(self.archiveId, name: "archiveId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
        }
    }

    public struct GetArchiveResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the archive.
        public let archiveArn: String
        /// The unique identifier of the archive.
        public let archiveId: String
        /// The unique name assigned to the archive.
        public let archiveName: String
        /// The current state of the archive:    ACTIVE – The archive is ready and available for use.     PENDING_DELETION – The archive has been marked for deletion and will be permanently deleted in 30 days. No further modifications can be made in this state.
        public let archiveState: ArchiveState
        /// The timestamp of when the archive was created.
        public let createdTimestamp: Date?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the archive.
        public let kmsKeyArn: String?
        /// The timestamp of when the archive was modified.
        public let lastUpdatedTimestamp: Date?
        /// The retention period for emails in this archive.
        public let retention: ArchiveRetention

        @inlinable
        public init(archiveArn: String, archiveId: String, archiveName: String, archiveState: ArchiveState, createdTimestamp: Date? = nil, kmsKeyArn: String? = nil, lastUpdatedTimestamp: Date? = nil, retention: ArchiveRetention) {
            self.archiveArn = archiveArn
            self.archiveId = archiveId
            self.archiveName = archiveName
            self.archiveState = archiveState
            self.createdTimestamp = createdTimestamp
            self.kmsKeyArn = kmsKeyArn
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.retention = retention
        }

        private enum CodingKeys: String, CodingKey {
            case archiveArn = "ArchiveArn"
            case archiveId = "ArchiveId"
            case archiveName = "ArchiveName"
            case archiveState = "ArchiveState"
            case createdTimestamp = "CreatedTimestamp"
            case kmsKeyArn = "KmsKeyArn"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case retention = "Retention"
        }
    }

    public struct GetArchiveSearchRequest: AWSEncodableShape {
        /// The identifier of the search job to get details for.
        public let searchId: String

        @inlinable
        public init(searchId: String) {
            self.searchId = searchId
        }

        public func validate(name: String) throws {
            try self.validate(self.searchId, name: "searchId", parent: name, max: 64)
            try self.validate(self.searchId, name: "searchId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case searchId = "SearchId"
        }
    }

    public struct GetArchiveSearchResponse: AWSDecodableShape {
        /// The identifier of the archive the email search was performed in.
        public let archiveId: String?
        /// The criteria used to filter emails included in the search.
        public let filters: ArchiveFilters?
        /// The start timestamp of the range the searched emails cover.
        public let fromTimestamp: Date?
        /// The maximum number of search results to return.
        public let maxResults: Int?
        /// The current status of the search job.
        public let status: SearchStatus?
        /// The end timestamp of the range the searched emails cover.
        public let toTimestamp: Date?

        @inlinable
        public init(archiveId: String? = nil, filters: ArchiveFilters? = nil, fromTimestamp: Date? = nil, maxResults: Int? = nil, status: SearchStatus? = nil, toTimestamp: Date? = nil) {
            self.archiveId = archiveId
            self.filters = filters
            self.fromTimestamp = fromTimestamp
            self.maxResults = maxResults
            self.status = status
            self.toTimestamp = toTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
            case filters = "Filters"
            case fromTimestamp = "FromTimestamp"
            case maxResults = "MaxResults"
            case status = "Status"
            case toTimestamp = "ToTimestamp"
        }
    }

    public struct GetArchiveSearchResultsRequest: AWSEncodableShape {
        /// The identifier of the completed search job.
        public let searchId: String

        @inlinable
        public init(searchId: String) {
            self.searchId = searchId
        }

        public func validate(name: String) throws {
            try self.validate(self.searchId, name: "searchId", parent: name, max: 64)
            try self.validate(self.searchId, name: "searchId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case searchId = "SearchId"
        }
    }

    public struct GetArchiveSearchResultsResponse: AWSDecodableShape {
        /// The list of email result objects matching the search criteria.
        public let rows: [Row]?

        @inlinable
        public init(rows: [Row]? = nil) {
            self.rows = rows
        }

        private enum CodingKeys: String, CodingKey {
            case rows = "Rows"
        }
    }

    public struct GetIngressPointRequest: AWSEncodableShape {
        /// The identifier of an ingress endpoint.
        public let ingressPointId: String

        @inlinable
        public init(ingressPointId: String) {
            self.ingressPointId = ingressPointId
        }

        public func validate(name: String) throws {
            try self.validate(self.ingressPointId, name: "ingressPointId", parent: name, max: 100)
            try self.validate(self.ingressPointId, name: "ingressPointId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ingressPointId = "IngressPointId"
        }
    }

    public struct GetIngressPointResponse: AWSDecodableShape {
        ///  The DNS A Record that identifies your ingress endpoint. Configure your DNS Mail Exchange (MX) record with this value to route emails to Mail Manager.
        public let aRecord: String?
        /// The timestamp of when the ingress endpoint was created.
        public let createdTimestamp: Date?
        /// The Amazon Resource Name (ARN) of the ingress endpoint resource.
        public let ingressPointArn: String?
        /// The authentication configuration of the ingress endpoint resource.
        public let ingressPointAuthConfiguration: IngressPointAuthConfiguration?
        /// The identifier of an ingress endpoint resource.
        public let ingressPointId: String
        /// A user friendly name for the ingress endpoint.
        public let ingressPointName: String
        /// The timestamp of when the ingress endpoint was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The identifier of a rule set resource associated with the ingress endpoint.
        public let ruleSetId: String?
        /// The status of the ingress endpoint resource.
        public let status: IngressPointStatus?
        /// The identifier of the traffic policy resource associated with the ingress endpoint.
        public let trafficPolicyId: String?
        /// The type of ingress endpoint.
        public let type: IngressPointType?

        @inlinable
        public init(aRecord: String? = nil, createdTimestamp: Date? = nil, ingressPointArn: String? = nil, ingressPointAuthConfiguration: IngressPointAuthConfiguration? = nil, ingressPointId: String, ingressPointName: String, lastUpdatedTimestamp: Date? = nil, ruleSetId: String? = nil, status: IngressPointStatus? = nil, trafficPolicyId: String? = nil, type: IngressPointType? = nil) {
            self.aRecord = aRecord
            self.createdTimestamp = createdTimestamp
            self.ingressPointArn = ingressPointArn
            self.ingressPointAuthConfiguration = ingressPointAuthConfiguration
            self.ingressPointId = ingressPointId
            self.ingressPointName = ingressPointName
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.ruleSetId = ruleSetId
            self.status = status
            self.trafficPolicyId = trafficPolicyId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case aRecord = "ARecord"
            case createdTimestamp = "CreatedTimestamp"
            case ingressPointArn = "IngressPointArn"
            case ingressPointAuthConfiguration = "IngressPointAuthConfiguration"
            case ingressPointId = "IngressPointId"
            case ingressPointName = "IngressPointName"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case ruleSetId = "RuleSetId"
            case status = "Status"
            case trafficPolicyId = "TrafficPolicyId"
            case type = "Type"
        }
    }

    public struct GetMemberOfAddressListRequest: AWSEncodableShape {
        /// The address to be retrieved from the address list.
        public let address: String
        /// The unique identifier of the address list to retrieve the address from.
        public let addressListId: String

        @inlinable
        public init(address: String, addressListId: String) {
            self.address = address
            self.addressListId = addressListId
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, max: 320)
            try self.validate(self.address, name: "address", parent: name, min: 3)
            try self.validate(self.addressListId, name: "addressListId", parent: name, max: 255)
            try self.validate(self.addressListId, name: "addressListId", parent: name, min: 1)
            try self.validate(self.addressListId, name: "addressListId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case addressListId = "AddressListId"
        }
    }

    public struct GetMemberOfAddressListResponse: AWSDecodableShape {
        /// The address retrieved from the address list.
        public let address: String
        /// The timestamp of when the address was created.
        public let createdTimestamp: Date

        @inlinable
        public init(address: String, createdTimestamp: Date) {
            self.address = address
            self.createdTimestamp = createdTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case createdTimestamp = "CreatedTimestamp"
        }
    }

    public struct GetRelayRequest: AWSEncodableShape {
        /// A unique relay identifier.
        public let relayId: String

        @inlinable
        public init(relayId: String) {
            self.relayId = relayId
        }

        public func validate(name: String) throws {
            try self.validate(self.relayId, name: "relayId", parent: name, max: 100)
            try self.validate(self.relayId, name: "relayId", parent: name, min: 1)
            try self.validate(self.relayId, name: "relayId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case relayId = "RelayId"
        }
    }

    public struct GetRelayResponse: AWSDecodableShape {
        /// The authentication attribute—contains the secret ARN where the customer relay server credentials are stored.
        public let authentication: RelayAuthentication?
        /// The timestamp of when the relay was created.
        public let createdTimestamp: Date?
        /// The timestamp of when relay was last updated.
        public let lastModifiedTimestamp: Date?
        /// The Amazon Resource Name (ARN) of the relay.
        public let relayArn: String?
        /// The unique relay identifier.
        public let relayId: String
        /// The unique name of the relay.
        public let relayName: String?
        /// The destination relay server address.
        public let serverName: String?
        /// The destination relay server port.
        public let serverPort: Int?

        @inlinable
        public init(authentication: RelayAuthentication? = nil, createdTimestamp: Date? = nil, lastModifiedTimestamp: Date? = nil, relayArn: String? = nil, relayId: String, relayName: String? = nil, serverName: String? = nil, serverPort: Int? = nil) {
            self.authentication = authentication
            self.createdTimestamp = createdTimestamp
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.relayArn = relayArn
            self.relayId = relayId
            self.relayName = relayName
            self.serverName = serverName
            self.serverPort = serverPort
        }

        private enum CodingKeys: String, CodingKey {
            case authentication = "Authentication"
            case createdTimestamp = "CreatedTimestamp"
            case lastModifiedTimestamp = "LastModifiedTimestamp"
            case relayArn = "RelayArn"
            case relayId = "RelayId"
            case relayName = "RelayName"
            case serverName = "ServerName"
            case serverPort = "ServerPort"
        }
    }

    public struct GetRuleSetRequest: AWSEncodableShape {
        /// The identifier of an existing rule set to be retrieved.
        public let ruleSetId: String

        @inlinable
        public init(ruleSetId: String) {
            self.ruleSetId = ruleSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleSetId, name: "ruleSetId", parent: name, max: 100)
            try self.validate(self.ruleSetId, name: "ruleSetId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ruleSetId = "RuleSetId"
        }
    }

    public struct GetRuleSetResponse: AWSDecodableShape {
        /// The date of when then rule set was created.
        public let createdDate: Date
        /// The date of when the rule set was last modified.
        public let lastModificationDate: Date
        /// The rules contained in the rule set.
        public let rules: [Rule]
        /// The Amazon Resource Name (ARN) of the rule set resource.
        public let ruleSetArn: String
        /// The identifier of the rule set resource.
        public let ruleSetId: String
        /// A user-friendly name for the rule set resource.
        public let ruleSetName: String

        @inlinable
        public init(createdDate: Date, lastModificationDate: Date, rules: [Rule], ruleSetArn: String, ruleSetId: String, ruleSetName: String) {
            self.createdDate = createdDate
            self.lastModificationDate = lastModificationDate
            self.rules = rules
            self.ruleSetArn = ruleSetArn
            self.ruleSetId = ruleSetId
            self.ruleSetName = ruleSetName
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "CreatedDate"
            case lastModificationDate = "LastModificationDate"
            case rules = "Rules"
            case ruleSetArn = "RuleSetArn"
            case ruleSetId = "RuleSetId"
            case ruleSetName = "RuleSetName"
        }
    }

    public struct GetTrafficPolicyRequest: AWSEncodableShape {
        /// The identifier of the traffic policy resource.
        public let trafficPolicyId: String

        @inlinable
        public init(trafficPolicyId: String) {
            self.trafficPolicyId = trafficPolicyId
        }

        public func validate(name: String) throws {
            try self.validate(self.trafficPolicyId, name: "trafficPolicyId", parent: name, max: 100)
            try self.validate(self.trafficPolicyId, name: "trafficPolicyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case trafficPolicyId = "TrafficPolicyId"
        }
    }

    public struct GetTrafficPolicyResponse: AWSDecodableShape {
        /// The timestamp of when the traffic policy was created.
        public let createdTimestamp: Date?
        /// The default action of the traffic policy.
        public let defaultAction: AcceptAction?
        /// The timestamp of when the traffic policy was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The maximum message size in bytes of email which is allowed in by this traffic policy—anything larger will be blocked.
        public let maxMessageSizeBytes: Int?
        /// The list of conditions which are in the traffic policy resource.
        public let policyStatements: [PolicyStatement]?
        /// The Amazon Resource Name (ARN) of the traffic policy resource.
        public let trafficPolicyArn: String?
        /// The identifier of the traffic policy resource.
        public let trafficPolicyId: String
        /// A user-friendly name for the traffic policy resource.
        public let trafficPolicyName: String

        @inlinable
        public init(createdTimestamp: Date? = nil, defaultAction: AcceptAction? = nil, lastUpdatedTimestamp: Date? = nil, maxMessageSizeBytes: Int? = nil, policyStatements: [PolicyStatement]? = nil, trafficPolicyArn: String? = nil, trafficPolicyId: String, trafficPolicyName: String) {
            self.createdTimestamp = createdTimestamp
            self.defaultAction = defaultAction
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.maxMessageSizeBytes = maxMessageSizeBytes
            self.policyStatements = policyStatements
            self.trafficPolicyArn = trafficPolicyArn
            self.trafficPolicyId = trafficPolicyId
            self.trafficPolicyName = trafficPolicyName
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case defaultAction = "DefaultAction"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case maxMessageSizeBytes = "MaxMessageSizeBytes"
            case policyStatements = "PolicyStatements"
            case trafficPolicyArn = "TrafficPolicyArn"
            case trafficPolicyId = "TrafficPolicyId"
            case trafficPolicyName = "TrafficPolicyName"
        }
    }

    public struct ImportDataFormat: AWSEncodableShape & AWSDecodableShape {
        /// The type of file that would be passed as an input for the address list import job.
        public let importDataType: ImportDataType

        @inlinable
        public init(importDataType: ImportDataType) {
            self.importDataType = importDataType
        }

        private enum CodingKeys: String, CodingKey {
            case importDataType = "ImportDataType"
        }
    }

    public struct ImportJob: AWSDecodableShape {
        /// The unique identifier of the address list the import job was created for.
        public let addressListId: String
        /// The timestamp of when the import job was completed.
        public let completedTimestamp: Date?
        /// The timestamp of when the import job was created.
        public let createdTimestamp: Date
        /// The reason for failure of an import job.
        public let error: String?
        /// The number of addresses in the input that failed to get imported into address list.
        public let failedItemsCount: Int?
        /// The format of the input for the import job.
        public let importDataFormat: ImportDataFormat
        /// The number of addresses in the input that were successfully imported into the address list.
        public let importedItemsCount: Int?
        /// The identifier of the import job.
        public let jobId: String
        /// A user-friendly name for the import job.
        public let name: String
        /// The pre-signed URL target for uploading the input file.
        public let preSignedUrl: String
        /// The timestamp of when the import job was started.
        public let startTimestamp: Date?
        /// The status of the import job.
        public let status: ImportJobStatus

        @inlinable
        public init(addressListId: String, completedTimestamp: Date? = nil, createdTimestamp: Date, error: String? = nil, failedItemsCount: Int? = nil, importDataFormat: ImportDataFormat, importedItemsCount: Int? = nil, jobId: String, name: String, preSignedUrl: String, startTimestamp: Date? = nil, status: ImportJobStatus) {
            self.addressListId = addressListId
            self.completedTimestamp = completedTimestamp
            self.createdTimestamp = createdTimestamp
            self.error = error
            self.failedItemsCount = failedItemsCount
            self.importDataFormat = importDataFormat
            self.importedItemsCount = importedItemsCount
            self.jobId = jobId
            self.name = name
            self.preSignedUrl = preSignedUrl
            self.startTimestamp = startTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case addressListId = "AddressListId"
            case completedTimestamp = "CompletedTimestamp"
            case createdTimestamp = "CreatedTimestamp"
            case error = "Error"
            case failedItemsCount = "FailedItemsCount"
            case importDataFormat = "ImportDataFormat"
            case importedItemsCount = "ImportedItemsCount"
            case jobId = "JobId"
            case name = "Name"
            case preSignedUrl = "PreSignedUrl"
            case startTimestamp = "StartTimestamp"
            case status = "Status"
        }
    }

    public struct IngressAnalysis: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Add On.
        public let analyzer: String
        /// The returned value from an Add On.
        public let resultField: String

        @inlinable
        public init(analyzer: String, resultField: String) {
            self.analyzer = analyzer
            self.resultField = resultField
        }

        public func validate(name: String) throws {
            try self.validate(self.analyzer, name: "analyzer", parent: name, pattern: "^[a-zA-Z0-9:_/+=,@.#-]+$")
            try self.validate(self.resultField, name: "resultField", parent: name, max: 256)
            try self.validate(self.resultField, name: "resultField", parent: name, min: 1)
            try self.validate(self.resultField, name: "resultField", parent: name, pattern: "^[\\sa-zA-Z0-9_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzer = "Analyzer"
            case resultField = "ResultField"
        }
    }

    public struct IngressBooleanExpression: AWSEncodableShape & AWSDecodableShape {
        /// The operand on which to perform a boolean condition operation.
        public let evaluate: IngressBooleanToEvaluate
        /// The matching operator for a boolean condition expression.
        public let `operator`: IngressBooleanOperator

        @inlinable
        public init(evaluate: IngressBooleanToEvaluate, operator: IngressBooleanOperator) {
            self.evaluate = evaluate
            self.`operator` = `operator`
        }

        public func validate(name: String) throws {
            try self.evaluate.validate(name: "\(name).evaluate")
        }

        private enum CodingKeys: String, CodingKey {
            case evaluate = "Evaluate"
            case `operator` = "Operator"
        }
    }

    public struct IngressIpv4Expression: AWSEncodableShape & AWSDecodableShape {
        /// The left hand side argument of an IP condition expression.
        public let evaluate: IngressIpToEvaluate
        /// The matching operator for an IP condition expression.
        public let `operator`: IngressIpOperator
        /// The right hand side argument of an IP condition expression.
        public let values: [String]

        @inlinable
        public init(evaluate: IngressIpToEvaluate, operator: IngressIpOperator, values: [String]) {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, pattern: "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)/([0-9]|[12][0-9]|3[0-2])$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case evaluate = "Evaluate"
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct IngressIsInAddressList: AWSEncodableShape & AWSDecodableShape {
        /// The address lists that will be used for evaluation.
        public let addressLists: [String]
        /// The email attribute that needs to be evaluated against the address list.
        public let attribute: IngressAddressListEmailAttribute

        @inlinable
        public init(addressLists: [String], attribute: IngressAddressListEmailAttribute) {
            self.addressLists = addressLists
            self.attribute = attribute
        }

        public func validate(name: String) throws {
            try self.validate(self.addressLists, name: "addressLists", parent: name, max: 1)
            try self.validate(self.addressLists, name: "addressLists", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case addressLists = "AddressLists"
            case attribute = "Attribute"
        }
    }

    public struct IngressPoint: AWSDecodableShape {
        ///  The DNS A Record that identifies your ingress endpoint. Configure your DNS Mail Exchange (MX) record with this value to route emails to Mail Manager.
        public let aRecord: String?
        /// The identifier of the ingress endpoint resource.
        public let ingressPointId: String
        /// A user friendly name for the ingress endpoint resource.
        public let ingressPointName: String
        /// The status of the ingress endpoint resource.
        public let status: IngressPointStatus
        /// The type of ingress endpoint resource.
        public let type: IngressPointType

        @inlinable
        public init(aRecord: String? = nil, ingressPointId: String, ingressPointName: String, status: IngressPointStatus, type: IngressPointType) {
            self.aRecord = aRecord
            self.ingressPointId = ingressPointId
            self.ingressPointName = ingressPointName
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case aRecord = "ARecord"
            case ingressPointId = "IngressPointId"
            case ingressPointName = "IngressPointName"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct IngressPointAuthConfiguration: AWSDecodableShape {
        /// The ingress endpoint password configuration for the ingress endpoint resource.
        public let ingressPointPasswordConfiguration: IngressPointPasswordConfiguration?
        /// The ingress endpoint SecretsManager::Secret ARN configuration for the ingress endpoint resource.
        public let secretArn: String?

        @inlinable
        public init(ingressPointPasswordConfiguration: IngressPointPasswordConfiguration? = nil, secretArn: String? = nil) {
            self.ingressPointPasswordConfiguration = ingressPointPasswordConfiguration
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case ingressPointPasswordConfiguration = "IngressPointPasswordConfiguration"
            case secretArn = "SecretArn"
        }
    }

    public struct IngressPointPasswordConfiguration: AWSDecodableShape {
        /// The previous password expiry timestamp of the ingress endpoint resource.
        public let previousSmtpPasswordExpiryTimestamp: Date?
        /// The previous password version of the ingress endpoint resource.
        public let previousSmtpPasswordVersion: String?
        /// The current password expiry timestamp of the ingress endpoint resource.
        public let smtpPasswordVersion: String?

        @inlinable
        public init(previousSmtpPasswordExpiryTimestamp: Date? = nil, previousSmtpPasswordVersion: String? = nil, smtpPasswordVersion: String? = nil) {
            self.previousSmtpPasswordExpiryTimestamp = previousSmtpPasswordExpiryTimestamp
            self.previousSmtpPasswordVersion = previousSmtpPasswordVersion
            self.smtpPasswordVersion = smtpPasswordVersion
        }

        private enum CodingKeys: String, CodingKey {
            case previousSmtpPasswordExpiryTimestamp = "PreviousSmtpPasswordExpiryTimestamp"
            case previousSmtpPasswordVersion = "PreviousSmtpPasswordVersion"
            case smtpPasswordVersion = "SmtpPasswordVersion"
        }
    }

    public struct IngressStringExpression: AWSEncodableShape & AWSDecodableShape {
        /// The left hand side argument of a string condition expression.
        public let evaluate: IngressStringToEvaluate
        /// The matching operator for a string condition expression.
        public let `operator`: IngressStringOperator
        /// The right hand side argument of a string condition expression.
        public let values: [String]

        @inlinable
        public init(evaluate: IngressStringToEvaluate, operator: IngressStringOperator, values: [String]) {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case evaluate = "Evaluate"
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct IngressTlsProtocolExpression: AWSEncodableShape & AWSDecodableShape {
        /// The left hand side argument of a TLS condition expression.
        public let evaluate: IngressTlsProtocolToEvaluate
        /// The matching operator for a TLS condition expression.
        public let `operator`: IngressTlsProtocolOperator
        /// The right hand side argument of a TLS condition expression.
        public let value: IngressTlsProtocolAttribute

        @inlinable
        public init(evaluate: IngressTlsProtocolToEvaluate, operator: IngressTlsProtocolOperator, value: IngressTlsProtocolAttribute) {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case evaluate = "Evaluate"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct ListAddonInstancesRequest: AWSEncodableShape {
        /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
        public let nextToken: String?
        /// The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
        public let pageSize: Int?

        @inlinable
        public init(nextToken: String? = nil, pageSize: Int? = nil) {
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 50)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListAddonInstancesResponse: AWSDecodableShape {
        /// The list of ingress endpoints.
        public let addonInstances: [AddonInstance]?
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(addonInstances: [AddonInstance]? = nil, nextToken: String? = nil) {
            self.addonInstances = addonInstances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case addonInstances = "AddonInstances"
            case nextToken = "NextToken"
        }
    }

    public struct ListAddonSubscriptionsRequest: AWSEncodableShape {
        /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
        public let nextToken: String?
        /// The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
        public let pageSize: Int?

        @inlinable
        public init(nextToken: String? = nil, pageSize: Int? = nil) {
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 50)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListAddonSubscriptionsResponse: AWSDecodableShape {
        /// The list of ingress endpoints.
        public let addonSubscriptions: [AddonSubscription]?
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(addonSubscriptions: [AddonSubscription]? = nil, nextToken: String? = nil) {
            self.addonSubscriptions = addonSubscriptions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case addonSubscriptions = "AddonSubscriptions"
            case nextToken = "NextToken"
        }
    }

    public struct ListAddressListImportJobsRequest: AWSEncodableShape {
        /// The unique identifier of the address list for listing import jobs.
        public let addressListId: String
        /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
        public let nextToken: String?
        /// The maximum number of import jobs that are returned per call. You can use NextToken to retrieve the next page of jobs.
        public let pageSize: Int?

        @inlinable
        public init(addressListId: String, nextToken: String? = nil, pageSize: Int? = nil) {
            self.addressListId = addressListId
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.addressListId, name: "addressListId", parent: name, max: 255)
            try self.validate(self.addressListId, name: "addressListId", parent: name, min: 1)
            try self.validate(self.addressListId, name: "addressListId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 50)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case addressListId = "AddressListId"
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListAddressListImportJobsResponse: AWSDecodableShape {
        /// The list of import jobs.
        public let importJobs: [ImportJob]
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(importJobs: [ImportJob], nextToken: String? = nil) {
            self.importJobs = importJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobs = "ImportJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListAddressListsRequest: AWSEncodableShape {
        /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
        public let nextToken: String?
        /// The maximum number of address list resources that are returned per call. You can use NextToken to retrieve the next page of address lists.
        public let pageSize: Int?

        @inlinable
        public init(nextToken: String? = nil, pageSize: Int? = nil) {
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 50)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListAddressListsResponse: AWSDecodableShape {
        /// The list of address lists.
        public let addressLists: [AddressList]
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(addressLists: [AddressList], nextToken: String? = nil) {
            self.addressLists = addressLists
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case addressLists = "AddressLists"
            case nextToken = "NextToken"
        }
    }

    public struct ListArchiveExportsRequest: AWSEncodableShape {
        /// The identifier of the archive.
        public let archiveId: String
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// The maximum number of archive export jobs that are returned per call. You can use NextToken to obtain further pages of archives.
        public let pageSize: Int?

        @inlinable
        public init(archiveId: String, nextToken: String? = nil, pageSize: Int? = nil) {
            self.archiveId = archiveId
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.archiveId, name: "archiveId", parent: name, max: 66)
            try self.validate(self.archiveId, name: "archiveId", parent: name, min: 3)
            try self.validate(self.archiveId, name: "archiveId", parent: name, pattern: "^a-[\\w]{1,64}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 50)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListArchiveExportsResponse: AWSDecodableShape {
        /// The list of export job identifiers and statuses.
        public let exports: [ExportSummary]?
        /// If present, use to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(exports: [ExportSummary]? = nil, nextToken: String? = nil) {
            self.exports = exports
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case exports = "Exports"
            case nextToken = "NextToken"
        }
    }

    public struct ListArchiveSearchesRequest: AWSEncodableShape {
        /// The identifier of the archive.
        public let archiveId: String
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// The maximum number of archive search jobs that are returned per call. You can use NextToken to obtain further pages of archives.
        public let pageSize: Int?

        @inlinable
        public init(archiveId: String, nextToken: String? = nil, pageSize: Int? = nil) {
            self.archiveId = archiveId
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.archiveId, name: "archiveId", parent: name, max: 66)
            try self.validate(self.archiveId, name: "archiveId", parent: name, min: 3)
            try self.validate(self.archiveId, name: "archiveId", parent: name, pattern: "^a-[\\w]{1,64}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 50)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListArchiveSearchesResponse: AWSDecodableShape {
        /// If present, use to retrieve the next page of results.
        public let nextToken: String?
        /// The list of search job identifiers and statuses.
        public let searches: [SearchSummary]?

        @inlinable
        public init(nextToken: String? = nil, searches: [SearchSummary]? = nil) {
            self.nextToken = nextToken
            self.searches = searches
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case searches = "Searches"
        }
    }

    public struct ListArchivesRequest: AWSEncodableShape {
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// The maximum number of archives that are returned per call. You can use NextToken to obtain further pages of archives.
        public let pageSize: Int?

        @inlinable
        public init(nextToken: String? = nil, pageSize: Int? = nil) {
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 50)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListArchivesResponse: AWSDecodableShape {
        /// The list of archive details.
        public let archives: [Archive]
        /// If present, use to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(archives: [Archive], nextToken: String? = nil) {
            self.archives = archives
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case archives = "Archives"
            case nextToken = "NextToken"
        }
    }

    public struct ListIngressPointsRequest: AWSEncodableShape {
        /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
        public let nextToken: String?
        /// The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
        public let pageSize: Int?

        @inlinable
        public init(nextToken: String? = nil, pageSize: Int? = nil) {
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 50)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListIngressPointsResponse: AWSDecodableShape {
        /// The list of ingress endpoints.
        public let ingressPoints: [IngressPoint]?
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(ingressPoints: [IngressPoint]? = nil, nextToken: String? = nil) {
            self.ingressPoints = ingressPoints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ingressPoints = "IngressPoints"
            case nextToken = "NextToken"
        }
    }

    public struct ListMembersOfAddressListRequest: AWSEncodableShape {
        /// The unique identifier of the address list to list the addresses from.
        public let addressListId: String
        /// Filter to be used to limit the results.
        public let filter: AddressFilter?
        /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
        public let nextToken: String?
        /// The maximum number of address list members that are returned per call. You can use NextToken to retrieve the next page of members.
        public let pageSize: Int?

        @inlinable
        public init(addressListId: String, filter: AddressFilter? = nil, nextToken: String? = nil, pageSize: Int? = nil) {
            self.addressListId = addressListId
            self.filter = filter
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.addressListId, name: "addressListId", parent: name, max: 255)
            try self.validate(self.addressListId, name: "addressListId", parent: name, min: 1)
            try self.validate(self.addressListId, name: "addressListId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 1000)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case addressListId = "AddressListId"
            case filter = "Filter"
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListMembersOfAddressListResponse: AWSDecodableShape {
        /// The list of addresses.
        public let addresses: [SavedAddress]
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(addresses: [SavedAddress], nextToken: String? = nil) {
            self.addresses = addresses
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case addresses = "Addresses"
            case nextToken = "NextToken"
        }
    }

    public struct ListRelaysRequest: AWSEncodableShape {
        /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
        public let nextToken: String?
        /// The number of relays to be returned in one request.
        public let pageSize: Int?

        @inlinable
        public init(nextToken: String? = nil, pageSize: Int? = nil) {
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListRelaysResponse: AWSDecodableShape {
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// The list of returned relays.
        public let relays: [Relay]

        @inlinable
        public init(nextToken: String? = nil, relays: [Relay]) {
            self.nextToken = nextToken
            self.relays = relays
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case relays = "Relays"
        }
    }

    public struct ListRuleSetsRequest: AWSEncodableShape {
        /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
        public let nextToken: String?
        /// The maximum number of rule set resources that are returned per call. You can use NextToken to obtain further rule sets.
        public let pageSize: Int?

        @inlinable
        public init(nextToken: String? = nil, pageSize: Int? = nil) {
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 50)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListRuleSetsResponse: AWSDecodableShape {
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// The list of rule sets.
        public let ruleSets: [RuleSet]

        @inlinable
        public init(nextToken: String? = nil, ruleSets: [RuleSet]) {
            self.nextToken = nextToken
            self.ruleSets = ruleSets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case ruleSets = "RuleSets"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to retrieve tags from.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):ses:[a-z0-9-]{1,20}:[0-9]{12}:(mailmanager-|addon-).+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [Tag]

        @inlinable
        public init(tags: [Tag]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListTrafficPoliciesRequest: AWSEncodableShape {
        /// If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
        public let nextToken: String?
        /// The maximum number of traffic policy resources that are returned per call. You can use NextToken to obtain further traffic policies.
        public let pageSize: Int?

        @inlinable
        public init(nextToken: String? = nil, pageSize: Int? = nil) {
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 50)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pageSize = "PageSize"
        }
    }

    public struct ListTrafficPoliciesResponse: AWSDecodableShape {
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// The list of traffic policies.
        public let trafficPolicies: [TrafficPolicy]?

        @inlinable
        public init(nextToken: String? = nil, trafficPolicies: [TrafficPolicy]? = nil) {
            self.nextToken = nextToken
            self.trafficPolicies = trafficPolicies
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case trafficPolicies = "TrafficPolicies"
        }
    }

    public struct MessageBody: AWSDecodableShape {
        /// The HTML body content of the message.
        public let html: String?
        /// A flag indicating if the email was malformed.
        public let messageMalformed: Bool?
        /// The plain text body content of the message.
        public let text: String?

        @inlinable
        public init(html: String? = nil, messageMalformed: Bool? = nil, text: String? = nil) {
            self.html = html
            self.messageMalformed = messageMalformed
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case html = "Html"
            case messageMalformed = "MessageMalformed"
            case text = "Text"
        }
    }

    public struct Metadata: AWSDecodableShape {
        /// The name of the configuration set used when sent through a configuration set with archiving enabled.
        public let configurationSet: String?
        /// The ID of the ingress endpoint through which the email was received.
        public let ingressPointId: String?
        /// The ID of the rule set that processed the email.
        public let ruleSetId: String?
        /// The name of the host from which the email was received.
        public let senderHostname: String?
        /// The IP address of the host from which the email was received.
        public let senderIpAddress: String?
        /// The name of the API call used when sent through a configuration set with archiving enabled.
        public let sendingMethod: String?
        /// The name of the dedicated IP pool used when sent through a configuration set with archiving enabled.
        public let sendingPool: String?
        /// Specifies the archived email source, identified by either a Rule Set's ARN with an Archive action, or a Configuration Set's Archive ARN.
        public let sourceArn: String?
        /// The identity name used to authorize the sending action when sent through a configuration set with archiving enabled.
        public let sourceIdentity: String?
        /// The timestamp of when the email was received.
        public let timestamp: Date?
        /// The TLS cipher suite used to communicate with the host from which the email was received.
        public let tlsCipherSuite: String?
        /// The TLS protocol used to communicate with the host from which the email was received.
        public let tlsProtocol: String?
        /// The ID of the traffic policy that was in effect when the email was received.
        public let trafficPolicyId: String?

        @inlinable
        public init(configurationSet: String? = nil, ingressPointId: String? = nil, ruleSetId: String? = nil, senderHostname: String? = nil, senderIpAddress: String? = nil, sendingMethod: String? = nil, sendingPool: String? = nil, sourceArn: String? = nil, sourceIdentity: String? = nil, timestamp: Date? = nil, tlsCipherSuite: String? = nil, tlsProtocol: String? = nil, trafficPolicyId: String? = nil) {
            self.configurationSet = configurationSet
            self.ingressPointId = ingressPointId
            self.ruleSetId = ruleSetId
            self.senderHostname = senderHostname
            self.senderIpAddress = senderIpAddress
            self.sendingMethod = sendingMethod
            self.sendingPool = sendingPool
            self.sourceArn = sourceArn
            self.sourceIdentity = sourceIdentity
            self.timestamp = timestamp
            self.tlsCipherSuite = tlsCipherSuite
            self.tlsProtocol = tlsProtocol
            self.trafficPolicyId = trafficPolicyId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSet = "ConfigurationSet"
            case ingressPointId = "IngressPointId"
            case ruleSetId = "RuleSetId"
            case senderHostname = "SenderHostname"
            case senderIpAddress = "SenderIpAddress"
            case sendingMethod = "SendingMethod"
            case sendingPool = "SendingPool"
            case sourceArn = "SourceArn"
            case sourceIdentity = "SourceIdentity"
            case timestamp = "Timestamp"
            case tlsCipherSuite = "TlsCipherSuite"
            case tlsProtocol = "TlsProtocol"
            case trafficPolicyId = "TrafficPolicyId"
        }
    }

    public struct NoAuthentication: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct PolicyStatement: AWSEncodableShape & AWSDecodableShape {
        /// The action that informs a traffic policy resource to either allow or block the email if it matches a condition in the policy statement.
        public let action: AcceptAction
        /// The list of conditions to apply to incoming messages for filtering email traffic.
        public let conditions: [PolicyCondition]

        @inlinable
        public init(action: AcceptAction, conditions: [PolicyCondition]) {
            self.action = action
            self.conditions = conditions
        }

        public func validate(name: String) throws {
            try self.conditions.forEach {
                try $0.validate(name: "\(name).conditions[]")
            }
            try self.validate(self.conditions, name: "conditions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case conditions = "Conditions"
        }
    }

    public struct RegisterMemberToAddressListRequest: AWSEncodableShape {
        /// The address to be added to the address list.
        public let address: String
        /// The unique identifier of the address list where the address should be added.
        public let addressListId: String

        @inlinable
        public init(address: String, addressListId: String) {
            self.address = address
            self.addressListId = addressListId
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, max: 320)
            try self.validate(self.address, name: "address", parent: name, min: 3)
            try self.validate(self.addressListId, name: "addressListId", parent: name, max: 255)
            try self.validate(self.addressListId, name: "addressListId", parent: name, min: 1)
            try self.validate(self.addressListId, name: "addressListId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case addressListId = "AddressListId"
        }
    }

    public struct RegisterMemberToAddressListResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Relay: AWSDecodableShape {
        /// The timestamp of when the relay was last modified.
        public let lastModifiedTimestamp: Date?
        /// The unique relay identifier.
        public let relayId: String?
        /// The unique relay name.
        public let relayName: String?

        @inlinable
        public init(lastModifiedTimestamp: Date? = nil, relayId: String? = nil, relayName: String? = nil) {
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.relayId = relayId
            self.relayName = relayName
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedTimestamp = "LastModifiedTimestamp"
            case relayId = "RelayId"
            case relayName = "RelayName"
        }
    }

    public struct RelayAction: AWSEncodableShape & AWSDecodableShape {
        /// A policy that states what to do in the case of failure. The action will fail if there are configuration errors. For example, the specified relay has been deleted.
        public let actionFailurePolicy: ActionFailurePolicy?
        /// This action specifies whether to preserve or replace original mail from address while relaying received emails to a destination server.
        public let mailFrom: MailFrom?
        /// The identifier of the relay resource to be used when relaying an email.
        public let relay: String

        @inlinable
        public init(actionFailurePolicy: ActionFailurePolicy? = nil, mailFrom: MailFrom? = nil, relay: String) {
            self.actionFailurePolicy = actionFailurePolicy
            self.mailFrom = mailFrom
            self.relay = relay
        }

        public func validate(name: String) throws {
            try self.validate(self.relay, name: "relay", parent: name, max: 2048)
            try self.validate(self.relay, name: "relay", parent: name, min: 1)
            try self.validate(self.relay, name: "relay", parent: name, pattern: "^[a-zA-Z0-9:_/+=,@.#-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionFailurePolicy = "ActionFailurePolicy"
            case mailFrom = "MailFrom"
            case relay = "Relay"
        }
    }

    public struct ReplaceRecipientAction: AWSEncodableShape & AWSDecodableShape {
        /// This action specifies the replacement recipient email addresses to insert.
        public let replaceWith: [String]?

        @inlinable
        public init(replaceWith: [String]? = nil) {
            self.replaceWith = replaceWith
        }

        public func validate(name: String) throws {
            try self.replaceWith?.forEach {
                try validate($0, name: "replaceWith[]", parent: name, max: 254)
                try validate($0, name: "replaceWith[]", parent: name, pattern: "^[0-9A-Za-z@+.-]+$")
            }
            try self.validate(self.replaceWith, name: "replaceWith", parent: name, max: 100)
            try self.validate(self.replaceWith, name: "replaceWith", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case replaceWith = "ReplaceWith"
        }
    }

    public struct Row: AWSDecodableShape {
        /// The unique identifier of the archived message.
        public let archivedMessageId: String?
        /// The email addresses in the CC header.
        public let cc: String?
        /// The date the email was sent.
        public let date: String?
        /// The SMTP envelope information of the email.
        public let envelope: Envelope?
        /// The email address of the sender.
        public let from: String?
        /// A flag indicating if the email has attachments.
        public let hasAttachments: Bool?
        /// The ID of the ingress endpoint through which the email was received.
        public let ingressPointId: String?
        /// The email message ID this is a reply to.
        public let inReplyTo: String?
        /// The unique message ID of the email.
        public let messageId: String?
        /// The received headers from the email delivery path.
        public let receivedHeaders: [String]?
        /// The timestamp of when the email was received.
        public let receivedTimestamp: Date?
        /// The name of the host from which the email was received.
        public let senderHostname: String?
        ///   Mail archived with Mail Manager: The IP address of the client that connects to the ingress endpoint.   Mail sent through a configuration set with the archiving option enabled: The IP address of the client that makes the SendEmail API call.
        public let senderIpAddress: String?
        /// Specifies the archived email source, identified by either a Rule Set's ARN with an Archive action, or a Configuration Set's Archive ARN.
        public let sourceArn: String?
        /// The subject header value of the email.
        public let subject: String?
        /// The email addresses in the To header.
        public let to: String?
        /// The user agent that sent the email.
        public let xMailer: String?
        /// The original user agent that sent the email.
        public let xOriginalMailer: String?
        /// The priority level of the email.
        public let xPriority: String?

        @inlinable
        public init(archivedMessageId: String? = nil, cc: String? = nil, date: String? = nil, envelope: Envelope? = nil, from: String? = nil, hasAttachments: Bool? = nil, ingressPointId: String? = nil, inReplyTo: String? = nil, messageId: String? = nil, receivedHeaders: [String]? = nil, receivedTimestamp: Date? = nil, senderHostname: String? = nil, senderIpAddress: String? = nil, sourceArn: String? = nil, subject: String? = nil, to: String? = nil, xMailer: String? = nil, xOriginalMailer: String? = nil, xPriority: String? = nil) {
            self.archivedMessageId = archivedMessageId
            self.cc = cc
            self.date = date
            self.envelope = envelope
            self.from = from
            self.hasAttachments = hasAttachments
            self.ingressPointId = ingressPointId
            self.inReplyTo = inReplyTo
            self.messageId = messageId
            self.receivedHeaders = receivedHeaders
            self.receivedTimestamp = receivedTimestamp
            self.senderHostname = senderHostname
            self.senderIpAddress = senderIpAddress
            self.sourceArn = sourceArn
            self.subject = subject
            self.to = to
            self.xMailer = xMailer
            self.xOriginalMailer = xOriginalMailer
            self.xPriority = xPriority
        }

        private enum CodingKeys: String, CodingKey {
            case archivedMessageId = "ArchivedMessageId"
            case cc = "Cc"
            case date = "Date"
            case envelope = "Envelope"
            case from = "From"
            case hasAttachments = "HasAttachments"
            case ingressPointId = "IngressPointId"
            case inReplyTo = "InReplyTo"
            case messageId = "MessageId"
            case receivedHeaders = "ReceivedHeaders"
            case receivedTimestamp = "ReceivedTimestamp"
            case senderHostname = "SenderHostname"
            case senderIpAddress = "SenderIpAddress"
            case sourceArn = "SourceArn"
            case subject = "Subject"
            case to = "To"
            case xMailer = "XMailer"
            case xOriginalMailer = "XOriginalMailer"
            case xPriority = "XPriority"
        }
    }

    public struct Rule: AWSEncodableShape & AWSDecodableShape {
        /// The list of actions to execute when the conditions match the incoming email, and none of the "unless conditions" match.
        public let actions: [RuleAction]
        /// The conditions of this rule. All conditions must match the email for the actions to be executed. An empty list of conditions means that all emails match, but are still subject to any "unless conditions"
        public let conditions: [RuleCondition]?
        /// The user-friendly name of the rule.
        public let name: String?
        /// The "unless conditions" of this rule. None of the conditions can match the email for the actions to be executed. If any of these conditions do match the email, then the actions are not executed.
        public let unless: [RuleCondition]?

        @inlinable
        public init(actions: [RuleAction], conditions: [RuleCondition]? = nil, name: String? = nil, unless: [RuleCondition]? = nil) {
            self.actions = actions
            self.conditions = conditions
            self.name = name
            self.unless = unless
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.conditions?.forEach {
                try $0.validate(name: "\(name).conditions[]")
            }
            try self.validate(self.conditions, name: "conditions", parent: name, max: 10)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.unless?.forEach {
                try $0.validate(name: "\(name).unless[]")
            }
            try self.validate(self.unless, name: "unless", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case conditions = "Conditions"
            case name = "Name"
            case unless = "Unless"
        }
    }

    public struct RuleBooleanExpression: AWSEncodableShape & AWSDecodableShape {
        /// The operand on which to perform a boolean condition operation.
        public let evaluate: RuleBooleanToEvaluate
        /// The matching operator for a boolean condition expression.
        public let `operator`: RuleBooleanOperator

        @inlinable
        public init(evaluate: RuleBooleanToEvaluate, operator: RuleBooleanOperator) {
            self.evaluate = evaluate
            self.`operator` = `operator`
        }

        public func validate(name: String) throws {
            try self.evaluate.validate(name: "\(name).evaluate")
        }

        private enum CodingKeys: String, CodingKey {
            case evaluate = "Evaluate"
            case `operator` = "Operator"
        }
    }

    public struct RuleDmarcExpression: AWSEncodableShape & AWSDecodableShape {
        /// The operator to apply to the DMARC policy of the incoming email.
        public let `operator`: RuleDmarcOperator
        /// The values to use for the given DMARC policy operator. For the operator EQUALS, if multiple values are given, they are evaluated as an OR. That is, if any of the given values match, the condition is deemed to match. For the operator NOT_EQUALS, if multiple values are given, they are evaluated as an AND. That is, only if the email's DMARC policy is not equal to any of the given values, then the condition is deemed to match.
        public let values: [RuleDmarcPolicy]

        @inlinable
        public init(operator: RuleDmarcOperator, values: [RuleDmarcPolicy]) {
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct RuleIpExpression: AWSEncodableShape & AWSDecodableShape {
        /// The IP address to evaluate in this condition.
        public let evaluate: RuleIpToEvaluate
        /// The operator to evaluate the IP address.
        public let `operator`: RuleIpOperator
        /// The IP CIDR blocks in format "x.y.z.w/n" (eg 10.0.0.0/8) to match with the email's IP address. For the operator CIDR_MATCHES, if multiple values are given, they are evaluated as an OR. That is, if the IP address is contained within any of the given CIDR ranges, the condition is deemed to match. For NOT_CIDR_MATCHES, if multiple CIDR ranges are given, the condition is deemed to match if the IP address is not contained in any of the given CIDR ranges.
        public let values: [String]

        @inlinable
        public init(evaluate: RuleIpToEvaluate, operator: RuleIpOperator, values: [String]) {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 18)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^(([0-9]|.|/)*)$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case evaluate = "Evaluate"
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct RuleIsInAddressList: AWSEncodableShape & AWSDecodableShape {
        /// The address lists that will be used for evaluation.
        public let addressLists: [String]
        /// The email attribute that needs to be evaluated against the address list.
        public let attribute: RuleAddressListEmailAttribute

        @inlinable
        public init(addressLists: [String], attribute: RuleAddressListEmailAttribute) {
            self.addressLists = addressLists
            self.attribute = attribute
        }

        public func validate(name: String) throws {
            try self.validate(self.addressLists, name: "addressLists", parent: name, max: 1)
            try self.validate(self.addressLists, name: "addressLists", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case addressLists = "AddressLists"
            case attribute = "Attribute"
        }
    }

    public struct RuleNumberExpression: AWSEncodableShape & AWSDecodableShape {
        /// The number to evaluate in a numeric condition expression.
        public let evaluate: RuleNumberToEvaluate
        /// The operator for a numeric condition expression.
        public let `operator`: RuleNumberOperator
        /// The value to evaluate in a numeric condition expression.
        public let value: Double

        @inlinable
        public init(evaluate: RuleNumberToEvaluate, operator: RuleNumberOperator, value: Double) {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case evaluate = "Evaluate"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct RuleSet: AWSDecodableShape {
        /// The last modification date of the rule set.
        public let lastModificationDate: Date?
        /// The identifier of the rule set.
        public let ruleSetId: String?
        /// A user-friendly name for the rule set.
        public let ruleSetName: String?

        @inlinable
        public init(lastModificationDate: Date? = nil, ruleSetId: String? = nil, ruleSetName: String? = nil) {
            self.lastModificationDate = lastModificationDate
            self.ruleSetId = ruleSetId
            self.ruleSetName = ruleSetName
        }

        private enum CodingKeys: String, CodingKey {
            case lastModificationDate = "LastModificationDate"
            case ruleSetId = "RuleSetId"
            case ruleSetName = "RuleSetName"
        }
    }

    public struct RuleStringExpression: AWSEncodableShape & AWSDecodableShape {
        /// The string to evaluate in a string condition expression.
        public let evaluate: RuleStringToEvaluate
        /// The matching operator for a string condition expression.
        public let `operator`: RuleStringOperator
        /// The string(s) to be evaluated in a string condition expression. For all operators, except for NOT_EQUALS, if multiple values are given, the values are processed as an OR. That is, if any of the values match the email's string using the given operator, the condition is deemed to match. However, for NOT_EQUALS, the condition is only deemed to match if none of the given strings match the email's string.
        public let values: [String]

        @inlinable
        public init(evaluate: RuleStringToEvaluate, operator: RuleStringOperator, values: [String]) {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.evaluate.validate(name: "\(name).evaluate")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 4096)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case evaluate = "Evaluate"
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct RuleVerdictExpression: AWSEncodableShape & AWSDecodableShape {
        /// The verdict to evaluate in a verdict condition expression.
        public let evaluate: RuleVerdictToEvaluate
        /// The matching operator for a verdict condition expression.
        public let `operator`: RuleVerdictOperator
        /// The values to match with the email's verdict using the given operator. For the EQUALS operator, if multiple values are given, the condition is deemed to match if any of the given verdicts match that of the email. For the NOT_EQUALS operator, if multiple values are given, the condition is deemed to match of none of the given verdicts match the verdict of the email.
        public let values: [RuleVerdict]

        @inlinable
        public init(evaluate: RuleVerdictToEvaluate, operator: RuleVerdictOperator, values: [RuleVerdict]) {
            self.evaluate = evaluate
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.evaluate.validate(name: "\(name).evaluate")
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case evaluate = "Evaluate"
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct S3Action: AWSEncodableShape & AWSDecodableShape {
        /// A policy that states what to do in the case of failure. The action will fail if there are configuration errors. For example, the specified the bucket has been deleted.
        public let actionFailurePolicy: ActionFailurePolicy?
        /// The Amazon Resource Name (ARN) of the IAM Role to use while writing to S3. This role must have access to the s3:PutObject, kms:Encrypt, and kms:GenerateDataKey APIs for the given bucket.
        public let roleArn: String
        /// The bucket name of the S3 bucket to write to.
        public let s3Bucket: String
        /// The S3 prefix to use for the write to the s3 bucket.
        public let s3Prefix: String?
        /// The KMS Key ID to use to encrypt the message in S3.
        public let s3SseKmsKeyId: String?

        @inlinable
        public init(actionFailurePolicy: ActionFailurePolicy? = nil, roleArn: String, s3Bucket: String, s3Prefix: String? = nil, s3SseKmsKeyId: String? = nil) {
            self.actionFailurePolicy = actionFailurePolicy
            self.roleArn = roleArn
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
            self.s3SseKmsKeyId = s3SseKmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^[a-zA-Z0-9:_/+=,@.#-]+$")
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 62)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 1)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[a-zA-Z0-9.-]+$")
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, max: 62)
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, min: 1)
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, pattern: "^[a-zA-Z0-9!_.*'()/-]+$")
            try self.validate(self.s3SseKmsKeyId, name: "s3SseKmsKeyId", parent: name, max: 2048)
            try self.validate(self.s3SseKmsKeyId, name: "s3SseKmsKeyId", parent: name, min: 20)
            try self.validate(self.s3SseKmsKeyId, name: "s3SseKmsKeyId", parent: name, pattern: "^[a-zA-Z0-9-:/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionFailurePolicy = "ActionFailurePolicy"
            case roleArn = "RoleArn"
            case s3Bucket = "S3Bucket"
            case s3Prefix = "S3Prefix"
            case s3SseKmsKeyId = "S3SseKmsKeyId"
        }
    }

    public struct S3ExportDestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The S3 location to deliver the exported email data.
        public let s3Location: String?

        @inlinable
        public init(s3Location: String? = nil) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Location, name: "s3Location", parent: name, pattern: "^s3://[a-zA-Z0-9.-]{3,63}(/[a-zA-Z0-9!_.*'()/-]*)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "S3Location"
        }
    }

    public struct SavedAddress: AWSDecodableShape {
        /// The email or domain that constitutes the address.
        public let address: String
        /// The timestamp of when the address was added to the address list.
        public let createdTimestamp: Date

        @inlinable
        public init(address: String, createdTimestamp: Date) {
            self.address = address
            self.createdTimestamp = createdTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case createdTimestamp = "CreatedTimestamp"
        }
    }

    public struct SearchStatus: AWSDecodableShape {
        /// The timestamp of when the search completed (if finished).
        public let completionTimestamp: Date?
        /// An error message if the search failed.
        public let errorMessage: String?
        /// The current state of the search job.
        public let state: SearchState?
        /// The timestamp of when the search was submitted.
        public let submissionTimestamp: Date?

        @inlinable
        public init(completionTimestamp: Date? = nil, errorMessage: String? = nil, state: SearchState? = nil, submissionTimestamp: Date? = nil) {
            self.completionTimestamp = completionTimestamp
            self.errorMessage = errorMessage
            self.state = state
            self.submissionTimestamp = submissionTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case completionTimestamp = "CompletionTimestamp"
            case errorMessage = "ErrorMessage"
            case state = "State"
            case submissionTimestamp = "SubmissionTimestamp"
        }
    }

    public struct SearchSummary: AWSDecodableShape {
        /// The unique identifier of the search job.
        public let searchId: String?
        /// The current status of the search job.
        public let status: SearchStatus?

        @inlinable
        public init(searchId: String? = nil, status: SearchStatus? = nil) {
            self.searchId = searchId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case searchId = "SearchId"
            case status = "Status"
        }
    }

    public struct SendAction: AWSEncodableShape & AWSDecodableShape {
        /// A policy that states what to do in the case of failure. The action will fail if there are configuration errors. For example, the caller does not have the permissions to call the sendRawEmail API.
        public let actionFailurePolicy: ActionFailurePolicy?
        /// The Amazon Resource Name (ARN) of the role to use for this action. This role must have access to the ses:SendRawEmail API.
        public let roleArn: String

        @inlinable
        public init(actionFailurePolicy: ActionFailurePolicy? = nil, roleArn: String) {
            self.actionFailurePolicy = actionFailurePolicy
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^[a-zA-Z0-9:_/+=,@.#-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionFailurePolicy = "ActionFailurePolicy"
            case roleArn = "RoleArn"
        }
    }

    public struct StartAddressListImportJobRequest: AWSEncodableShape {
        /// The identifier of the import job that needs to be started.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartAddressListImportJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartArchiveExportRequest: AWSEncodableShape {
        /// The identifier of the archive to export emails from.
        public let archiveId: String
        /// Details on where to deliver the exported email data.
        public let exportDestinationConfiguration: ExportDestinationConfiguration
        /// Criteria to filter which emails are included in the export.
        public let filters: ArchiveFilters?
        /// The start of the timestamp range to include emails from.
        public let fromTimestamp: Date
        /// Whether to include message metadata as JSON files in the export.
        public let includeMetadata: Bool?
        /// The maximum number of email items to include in the export.
        public let maxResults: Int?
        /// The end of the timestamp range to include emails from.
        public let toTimestamp: Date

        @inlinable
        public init(archiveId: String, exportDestinationConfiguration: ExportDestinationConfiguration, filters: ArchiveFilters? = nil, fromTimestamp: Date, includeMetadata: Bool? = nil, maxResults: Int? = nil, toTimestamp: Date) {
            self.archiveId = archiveId
            self.exportDestinationConfiguration = exportDestinationConfiguration
            self.filters = filters
            self.fromTimestamp = fromTimestamp
            self.includeMetadata = includeMetadata
            self.maxResults = maxResults
            self.toTimestamp = toTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.archiveId, name: "archiveId", parent: name, max: 66)
            try self.validate(self.archiveId, name: "archiveId", parent: name, min: 3)
            try self.validate(self.archiveId, name: "archiveId", parent: name, pattern: "^a-[\\w]{1,64}$")
            try self.exportDestinationConfiguration.validate(name: "\(name).exportDestinationConfiguration")
            try self.filters?.validate(name: "\(name).filters")
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
            case exportDestinationConfiguration = "ExportDestinationConfiguration"
            case filters = "Filters"
            case fromTimestamp = "FromTimestamp"
            case includeMetadata = "IncludeMetadata"
            case maxResults = "MaxResults"
            case toTimestamp = "ToTimestamp"
        }
    }

    public struct StartArchiveExportResponse: AWSDecodableShape {
        /// The unique identifier for the initiated export job.
        public let exportId: String?

        @inlinable
        public init(exportId: String? = nil) {
            self.exportId = exportId
        }

        private enum CodingKeys: String, CodingKey {
            case exportId = "ExportId"
        }
    }

    public struct StartArchiveSearchRequest: AWSEncodableShape {
        /// The identifier of the archive to search emails in.
        public let archiveId: String
        /// Criteria to filter which emails are included in the search results.
        public let filters: ArchiveFilters?
        /// The start timestamp of the range to search emails from.
        public let fromTimestamp: Date
        /// The maximum number of search results to return.
        public let maxResults: Int
        /// The end timestamp of the range to search emails from.
        public let toTimestamp: Date

        @inlinable
        public init(archiveId: String, filters: ArchiveFilters? = nil, fromTimestamp: Date, maxResults: Int, toTimestamp: Date) {
            self.archiveId = archiveId
            self.filters = filters
            self.fromTimestamp = fromTimestamp
            self.maxResults = maxResults
            self.toTimestamp = toTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.archiveId, name: "archiveId", parent: name, max: 66)
            try self.validate(self.archiveId, name: "archiveId", parent: name, min: 3)
            try self.validate(self.archiveId, name: "archiveId", parent: name, pattern: "^a-[\\w]{1,64}$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
            case filters = "Filters"
            case fromTimestamp = "FromTimestamp"
            case maxResults = "MaxResults"
            case toTimestamp = "ToTimestamp"
        }
    }

    public struct StartArchiveSearchResponse: AWSDecodableShape {
        /// The unique identifier for the initiated search job.
        public let searchId: String?

        @inlinable
        public init(searchId: String? = nil) {
            self.searchId = searchId
        }

        private enum CodingKeys: String, CodingKey {
            case searchId = "SearchId"
        }
    }

    public struct StopAddressListImportJobRequest: AWSEncodableShape {
        /// The identifier of the import job that needs to be stopped.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopAddressListImportJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopArchiveExportRequest: AWSEncodableShape {
        /// The identifier of the export job to stop.
        public let exportId: String

        @inlinable
        public init(exportId: String) {
            self.exportId = exportId
        }

        public func validate(name: String) throws {
            try self.validate(self.exportId, name: "exportId", parent: name, max: 64)
            try self.validate(self.exportId, name: "exportId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exportId = "ExportId"
        }
    }

    public struct StopArchiveExportResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopArchiveSearchRequest: AWSEncodableShape {
        /// The identifier of the search job to stop.
        public let searchId: String

        @inlinable
        public init(searchId: String) {
            self.searchId = searchId
        }

        public func validate(name: String) throws {
            try self.validate(self.searchId, name: "searchId", parent: name, max: 64)
            try self.validate(self.searchId, name: "searchId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case searchId = "SearchId"
        }
    }

    public struct StopArchiveSearchResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the key-value tag.
        public let key: String
        /// The value of the key-value tag.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9/_\\+=\\.:@\\-]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9/_\\+=\\.:@\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        ///  The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):ses:[a-z0-9-]{1,20}:[0-9]{12}:(mailmanager-|addon-).+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TrafficPolicy: AWSDecodableShape {
        /// Default action instructs the traﬃc policy to either Allow or Deny (block) messages that fall outside of (or not addressed by) the conditions of your policy statements
        public let defaultAction: AcceptAction
        /// The identifier of the traffic policy resource.
        public let trafficPolicyId: String
        /// A user-friendly name of the traffic policy resource.
        public let trafficPolicyName: String

        @inlinable
        public init(defaultAction: AcceptAction, trafficPolicyId: String, trafficPolicyName: String) {
            self.defaultAction = defaultAction
            self.trafficPolicyId = trafficPolicyId
            self.trafficPolicyName = trafficPolicyName
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAction = "DefaultAction"
            case trafficPolicyId = "TrafficPolicyId"
            case trafficPolicyName = "TrafficPolicyName"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        ///  The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):ses:[a-z0-9-]{1,20}:[0-9]{12}:(mailmanager-|addon-).+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[a-zA-Z0-9/_\\+=\\.:@\\-]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateArchiveRequest: AWSEncodableShape {
        /// The identifier of the archive to update.
        public let archiveId: String
        /// A new, unique name for the archive.
        public let archiveName: String?
        /// A new retention period for emails in the archive.
        public let retention: ArchiveRetention?

        @inlinable
        public init(archiveId: String, archiveName: String? = nil, retention: ArchiveRetention? = nil) {
            self.archiveId = archiveId
            self.archiveName = archiveName
            self.retention = retention
        }

        public func validate(name: String) throws {
            try self.validate(self.archiveId, name: "archiveId", parent: name, max: 66)
            try self.validate(self.archiveId, name: "archiveId", parent: name, min: 1)
            try self.validate(self.archiveName, name: "archiveName", parent: name, max: 64)
            try self.validate(self.archiveName, name: "archiveName", parent: name, min: 1)
            try self.validate(self.archiveName, name: "archiveName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*[a-zA-Z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
            case archiveName = "ArchiveName"
            case retention = "Retention"
        }
    }

    public struct UpdateArchiveResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateIngressPointRequest: AWSEncodableShape {
        /// If you choose an Authenticated ingress endpoint, you must configure either an SMTP password or a secret ARN.
        public let ingressPointConfiguration: IngressPointConfiguration?
        /// The identifier for the ingress endpoint you want to update.
        public let ingressPointId: String
        /// A user friendly name for the ingress endpoint resource.
        public let ingressPointName: String?
        /// The identifier of an existing rule set that you attach to an ingress endpoint resource.
        public let ruleSetId: String?
        /// The update status of an ingress endpoint.
        public let statusToUpdate: IngressPointStatusToUpdate?
        /// The identifier of an existing traffic policy that you attach to an ingress endpoint resource.
        public let trafficPolicyId: String?

        @inlinable
        public init(ingressPointConfiguration: IngressPointConfiguration? = nil, ingressPointId: String, ingressPointName: String? = nil, ruleSetId: String? = nil, statusToUpdate: IngressPointStatusToUpdate? = nil, trafficPolicyId: String? = nil) {
            self.ingressPointConfiguration = ingressPointConfiguration
            self.ingressPointId = ingressPointId
            self.ingressPointName = ingressPointName
            self.ruleSetId = ruleSetId
            self.statusToUpdate = statusToUpdate
            self.trafficPolicyId = trafficPolicyId
        }

        public func validate(name: String) throws {
            try self.ingressPointConfiguration?.validate(name: "\(name).ingressPointConfiguration")
            try self.validate(self.ingressPointId, name: "ingressPointId", parent: name, max: 100)
            try self.validate(self.ingressPointId, name: "ingressPointId", parent: name, min: 1)
            try self.validate(self.ingressPointName, name: "ingressPointName", parent: name, max: 63)
            try self.validate(self.ingressPointName, name: "ingressPointName", parent: name, min: 3)
            try self.validate(self.ingressPointName, name: "ingressPointName", parent: name, pattern: "^[A-Za-z0-9_\\-]+$")
            try self.validate(self.ruleSetId, name: "ruleSetId", parent: name, max: 100)
            try self.validate(self.ruleSetId, name: "ruleSetId", parent: name, min: 1)
            try self.validate(self.trafficPolicyId, name: "trafficPolicyId", parent: name, max: 100)
            try self.validate(self.trafficPolicyId, name: "trafficPolicyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ingressPointConfiguration = "IngressPointConfiguration"
            case ingressPointId = "IngressPointId"
            case ingressPointName = "IngressPointName"
            case ruleSetId = "RuleSetId"
            case statusToUpdate = "StatusToUpdate"
            case trafficPolicyId = "TrafficPolicyId"
        }
    }

    public struct UpdateIngressPointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRelayRequest: AWSEncodableShape {
        /// Authentication for the relay destination server—specify the secretARN where the SMTP credentials are stored.
        public let authentication: RelayAuthentication?
        /// The unique relay identifier.
        public let relayId: String
        /// The name of the relay resource.
        public let relayName: String?
        /// The destination relay server address.
        public let serverName: String?
        /// The destination relay server port.
        public let serverPort: Int?

        @inlinable
        public init(authentication: RelayAuthentication? = nil, relayId: String, relayName: String? = nil, serverName: String? = nil, serverPort: Int? = nil) {
            self.authentication = authentication
            self.relayId = relayId
            self.relayName = relayName
            self.serverName = serverName
            self.serverPort = serverPort
        }

        public func validate(name: String) throws {
            try self.authentication?.validate(name: "\(name).authentication")
            try self.validate(self.relayId, name: "relayId", parent: name, max: 100)
            try self.validate(self.relayId, name: "relayId", parent: name, min: 1)
            try self.validate(self.relayId, name: "relayId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.relayName, name: "relayName", parent: name, max: 100)
            try self.validate(self.relayName, name: "relayName", parent: name, min: 1)
            try self.validate(self.relayName, name: "relayName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.serverName, name: "serverName", parent: name, max: 100)
            try self.validate(self.serverName, name: "serverName", parent: name, min: 1)
            try self.validate(self.serverName, name: "serverName", parent: name, pattern: "^[a-zA-Z0-9-\\.]+$")
            try self.validate(self.serverPort, name: "serverPort", parent: name, max: 65535)
            try self.validate(self.serverPort, name: "serverPort", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authentication = "Authentication"
            case relayId = "RelayId"
            case relayName = "RelayName"
            case serverName = "ServerName"
            case serverPort = "ServerPort"
        }
    }

    public struct UpdateRelayResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRuleSetRequest: AWSEncodableShape {
        /// A new set of rules to replace the current rules of the rule set—these rules will override all the rules of the rule set.
        public let rules: [Rule]?
        /// The identifier of a rule set you want to update.
        public let ruleSetId: String
        /// A user-friendly name for the rule set resource.
        public let ruleSetName: String?

        @inlinable
        public init(rules: [Rule]? = nil, ruleSetId: String, ruleSetName: String? = nil) {
            self.rules = rules
            self.ruleSetId = ruleSetId
            self.ruleSetName = ruleSetName
        }

        public func validate(name: String) throws {
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 40)
            try self.validate(self.ruleSetId, name: "ruleSetId", parent: name, max: 100)
            try self.validate(self.ruleSetId, name: "ruleSetId", parent: name, min: 1)
            try self.validate(self.ruleSetName, name: "ruleSetName", parent: name, max: 100)
            try self.validate(self.ruleSetName, name: "ruleSetName", parent: name, min: 1)
            try self.validate(self.ruleSetName, name: "ruleSetName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
            case ruleSetId = "RuleSetId"
            case ruleSetName = "RuleSetName"
        }
    }

    public struct UpdateRuleSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTrafficPolicyRequest: AWSEncodableShape {
        /// Default action instructs the traﬃc policy to either Allow or Deny (block) messages that fall outside of (or not addressed by) the conditions of your policy statements
        public let defaultAction: AcceptAction?
        /// The maximum message size in bytes of email which is allowed in by this traffic policy—anything larger will be blocked.
        public let maxMessageSizeBytes: Int?
        /// The list of conditions to be updated for filtering email traffic.
        public let policyStatements: [PolicyStatement]?
        /// The identifier of the traffic policy that you want to update.
        public let trafficPolicyId: String
        /// A user-friendly name for the traffic policy resource.
        public let trafficPolicyName: String?

        @inlinable
        public init(defaultAction: AcceptAction? = nil, maxMessageSizeBytes: Int? = nil, policyStatements: [PolicyStatement]? = nil, trafficPolicyId: String, trafficPolicyName: String? = nil) {
            self.defaultAction = defaultAction
            self.maxMessageSizeBytes = maxMessageSizeBytes
            self.policyStatements = policyStatements
            self.trafficPolicyId = trafficPolicyId
            self.trafficPolicyName = trafficPolicyName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxMessageSizeBytes, name: "maxMessageSizeBytes", parent: name, min: 1)
            try self.policyStatements?.forEach {
                try $0.validate(name: "\(name).policyStatements[]")
            }
            try self.validate(self.trafficPolicyId, name: "trafficPolicyId", parent: name, max: 100)
            try self.validate(self.trafficPolicyId, name: "trafficPolicyId", parent: name, min: 1)
            try self.validate(self.trafficPolicyName, name: "trafficPolicyName", parent: name, max: 63)
            try self.validate(self.trafficPolicyName, name: "trafficPolicyName", parent: name, min: 3)
            try self.validate(self.trafficPolicyName, name: "trafficPolicyName", parent: name, pattern: "^[A-Za-z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAction = "DefaultAction"
            case maxMessageSizeBytes = "MaxMessageSizeBytes"
            case policyStatements = "PolicyStatements"
            case trafficPolicyId = "TrafficPolicyId"
            case trafficPolicyName = "TrafficPolicyName"
        }
    }

    public struct UpdateTrafficPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ArchiveBooleanToEvaluate: AWSEncodableShape & AWSDecodableShape {
        /// The name of the email attribute to evaluate.
        public let attribute: ArchiveBooleanEmailAttribute?

        @inlinable
        public init(attribute: ArchiveBooleanEmailAttribute? = nil) {
            self.attribute = attribute
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
        }
    }

    public struct ArchiveRetention: AWSEncodableShape & AWSDecodableShape {
        /// The enum value sets the period for retaining emails in an archive.
        public let retentionPeriod: RetentionPeriod?

        @inlinable
        public init(retentionPeriod: RetentionPeriod? = nil) {
            self.retentionPeriod = retentionPeriod
        }

        private enum CodingKeys: String, CodingKey {
            case retentionPeriod = "RetentionPeriod"
        }
    }

    public struct ArchiveStringToEvaluate: AWSEncodableShape & AWSDecodableShape {
        /// The name of the email attribute to evaluate.
        public let attribute: ArchiveStringEmailAttribute?

        @inlinable
        public init(attribute: ArchiveStringEmailAttribute? = nil) {
            self.attribute = attribute
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
        }
    }

    public struct ExportDestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration for delivering to an Amazon S3 bucket.
        public let s3: S3ExportDestinationConfiguration?

        @inlinable
        public init(s3: S3ExportDestinationConfiguration? = nil) {
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "S3"
        }
    }

    public struct IngressIpToEvaluate: AWSEncodableShape & AWSDecodableShape {
        /// An enum type representing the allowed attribute types for an IP condition.
        public let attribute: IngressIpv4Attribute?

        @inlinable
        public init(attribute: IngressIpv4Attribute? = nil) {
            self.attribute = attribute
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
        }
    }

    public struct IngressStringToEvaluate: AWSEncodableShape & AWSDecodableShape {
        /// The enum type representing the allowed attribute types for a string condition.
        public let attribute: IngressStringEmailAttribute?

        @inlinable
        public init(attribute: IngressStringEmailAttribute? = nil) {
            self.attribute = attribute
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
        }
    }

    public struct IngressTlsProtocolToEvaluate: AWSEncodableShape & AWSDecodableShape {
        /// The enum type representing the allowed attribute types for the TLS condition.
        public let attribute: IngressTlsAttribute?

        @inlinable
        public init(attribute: IngressTlsAttribute? = nil) {
            self.attribute = attribute
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
        }
    }

    public struct RuleIpToEvaluate: AWSEncodableShape & AWSDecodableShape {
        /// The attribute of the email to evaluate.
        public let attribute: RuleIpEmailAttribute?

        @inlinable
        public init(attribute: RuleIpEmailAttribute? = nil) {
            self.attribute = attribute
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
        }
    }

    public struct RuleNumberToEvaluate: AWSEncodableShape & AWSDecodableShape {
        /// An email attribute that is used as the number to evaluate.
        public let attribute: RuleNumberEmailAttribute?

        @inlinable
        public init(attribute: RuleNumberEmailAttribute? = nil) {
            self.attribute = attribute
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
        }
    }
}

// MARK: - Errors

/// Error enum for MailManager
public struct MailManagerErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MailManager
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Occurs when a user is denied access to a specific resource or action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request configuration has conflicts. For details, see the accompanying error message.
    public static var conflictException: Self { .init(.conflictException) }
    /// Occurs when a requested resource is not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Occurs when an operation exceeds a predefined service quota or limit.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Occurs when a service's request rate limit is exceeded, resulting in throttling of further requests.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request validation has failed. For details, see the accompanying error message.
    public static var validationException: Self { .init(.validationException) }
}

extension MailManagerErrorType: Equatable {
    public static func == (lhs: MailManagerErrorType, rhs: MailManagerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MailManagerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
