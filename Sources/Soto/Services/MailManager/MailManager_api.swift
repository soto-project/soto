//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS MailManager service.
///
/// Amazon SES Mail Manager API The Amazon SES Mail Manager API contains operations and data types that comprise the Mail Manager feature of Amazon Simple Email Service (SES). Mail Manager is a set of Amazon SES email gateway features designed to help you strengthen your organization's email infrastructure, simplify email workflow management, and streamline email compliance control. To learn more, see the Mail Manager chapter in the Amazon SES Developer Guide.
/// API Reference: https://w.amazon.com/bin/view/AWS/Border
public struct MailManager: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the MailManager client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "MailManagerSvc",
            serviceName: "MailManager",
            serviceIdentifier: "mail-manager",
            signingName: "ses",
            serviceProtocol: .json(version: "1.0"),
            apiVersion: "2023-10-17",
            endpoint: endpoint,
            errorType: MailManagerErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Creates an Add On instance for the subscription indicated in the request. The resulting Amazon Resource Name (ARN) can be used in a conditional statement for a rule set or traffic policy.
    @Sendable
    @inlinable
    public func createAddonInstance(_ input: CreateAddonInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAddonInstanceResponse {
        try await self.client.execute(
            operation: "CreateAddonInstance", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an Add On instance for the subscription indicated in the request. The resulting Amazon Resource Name (ARN) can be used in a conditional statement for a rule set or traffic policy.
    ///
    /// Parameters:
    ///   - addonSubscriptionId: The unique ID of a previously created subscription that an Add On instance is created for. You can only have one instance per subscription.
    ///   - clientToken: A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    ///   - tags: The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAddonInstance(
        addonSubscriptionId: String,
        clientToken: String? = CreateAddonInstanceRequest.idempotencyToken(),
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAddonInstanceResponse {
        let input = CreateAddonInstanceRequest(
            addonSubscriptionId: addonSubscriptionId, 
            clientToken: clientToken, 
            tags: tags
        )
        return try await self.createAddonInstance(input, logger: logger)
    }

    /// Creates a subscription for an Add On representing the acceptance of its terms of use and additional pricing. The subscription can then be used to create an instance for use in rule sets or traffic policies.
    @Sendable
    @inlinable
    public func createAddonSubscription(_ input: CreateAddonSubscriptionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAddonSubscriptionResponse {
        try await self.client.execute(
            operation: "CreateAddonSubscription", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a subscription for an Add On representing the acceptance of its terms of use and additional pricing. The subscription can then be used to create an instance for use in rule sets or traffic policies.
    ///
    /// Parameters:
    ///   - addonName: The name of the Add On to subscribe to. You can only have one subscription for each Add On name.
    ///   - clientToken: A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    ///   - tags: The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAddonSubscription(
        addonName: String,
        clientToken: String? = CreateAddonSubscriptionRequest.idempotencyToken(),
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAddonSubscriptionResponse {
        let input = CreateAddonSubscriptionRequest(
            addonName: addonName, 
            clientToken: clientToken, 
            tags: tags
        )
        return try await self.createAddonSubscription(input, logger: logger)
    }

    /// Creates a new address list.
    @Sendable
    @inlinable
    public func createAddressList(_ input: CreateAddressListRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAddressListResponse {
        try await self.client.execute(
            operation: "CreateAddressList", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new address list.
    ///
    /// Parameters:
    ///   - addressListName: A user-friendly name for the address list.
    ///   - clientToken: A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    ///   - tags: The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAddressList(
        addressListName: String,
        clientToken: String? = CreateAddressListRequest.idempotencyToken(),
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAddressListResponse {
        let input = CreateAddressListRequest(
            addressListName: addressListName, 
            clientToken: clientToken, 
            tags: tags
        )
        return try await self.createAddressList(input, logger: logger)
    }

    /// Creates an import job for an address list.
    @Sendable
    @inlinable
    public func createAddressListImportJob(_ input: CreateAddressListImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAddressListImportJobResponse {
        try await self.client.execute(
            operation: "CreateAddressListImportJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an import job for an address list.
    ///
    /// Parameters:
    ///   - addressListId: The unique identifier of the address list for importing addresses to.
    ///   - clientToken: A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    ///   - importDataFormat: The format of the input for an import job.
    ///   - name: A user-friendly name for the import job.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAddressListImportJob(
        addressListId: String,
        clientToken: String? = CreateAddressListImportJobRequest.idempotencyToken(),
        importDataFormat: ImportDataFormat,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAddressListImportJobResponse {
        let input = CreateAddressListImportJobRequest(
            addressListId: addressListId, 
            clientToken: clientToken, 
            importDataFormat: importDataFormat, 
            name: name
        )
        return try await self.createAddressListImportJob(input, logger: logger)
    }

    /// Creates a new email archive resource for storing and retaining emails.
    @Sendable
    @inlinable
    public func createArchive(_ input: CreateArchiveRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateArchiveResponse {
        try await self.client.execute(
            operation: "CreateArchive", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new email archive resource for storing and retaining emails.
    ///
    /// Parameters:
    ///   - archiveName: A unique name for the new archive.
    ///   - clientToken: A unique token Amazon SES uses to recognize retries of this request.
    ///   - kmsKeyArn: The Amazon Resource Name (ARN) of the KMS key for encrypting emails in the archive.
    ///   - retention: The period for retaining emails in the archive before automatic deletion.
    ///   - tags: The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    ///   - logger: Logger use during operation
    @inlinable
    public func createArchive(
        archiveName: String,
        clientToken: String? = CreateArchiveRequest.idempotencyToken(),
        kmsKeyArn: String? = nil,
        retention: ArchiveRetention? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateArchiveResponse {
        let input = CreateArchiveRequest(
            archiveName: archiveName, 
            clientToken: clientToken, 
            kmsKeyArn: kmsKeyArn, 
            retention: retention, 
            tags: tags
        )
        return try await self.createArchive(input, logger: logger)
    }

    /// Provision a new ingress endpoint resource.
    @Sendable
    @inlinable
    public func createIngressPoint(_ input: CreateIngressPointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateIngressPointResponse {
        try await self.client.execute(
            operation: "CreateIngressPoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provision a new ingress endpoint resource.
    ///
    /// Parameters:
    ///   - clientToken: A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    ///   - ingressPointConfiguration: If you choose an Authenticated ingress endpoint, you must configure either an SMTP password or a secret ARN.
    ///   - ingressPointName: A user friendly name for an ingress endpoint resource.
    ///   - ruleSetId: The identifier of an existing rule set that you attach to an ingress endpoint resource.
    ///   - tags: The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    ///   - trafficPolicyId: The identifier of an existing traffic policy that you attach to an ingress endpoint resource.
    ///   - type: The type of the ingress endpoint to create.
    ///   - logger: Logger use during operation
    @inlinable
    public func createIngressPoint(
        clientToken: String? = CreateIngressPointRequest.idempotencyToken(),
        ingressPointConfiguration: IngressPointConfiguration? = nil,
        ingressPointName: String,
        ruleSetId: String,
        tags: [Tag]? = nil,
        trafficPolicyId: String,
        type: IngressPointType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateIngressPointResponse {
        let input = CreateIngressPointRequest(
            clientToken: clientToken, 
            ingressPointConfiguration: ingressPointConfiguration, 
            ingressPointName: ingressPointName, 
            ruleSetId: ruleSetId, 
            tags: tags, 
            trafficPolicyId: trafficPolicyId, 
            type: type
        )
        return try await self.createIngressPoint(input, logger: logger)
    }

    /// Creates a relay resource which can be used in rules to relay incoming emails to defined relay destinations.
    @Sendable
    @inlinable
    public func createRelay(_ input: CreateRelayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRelayResponse {
        try await self.client.execute(
            operation: "CreateRelay", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a relay resource which can be used in rules to relay incoming emails to defined relay destinations.
    ///
    /// Parameters:
    ///   - authentication: Authentication for the relay destination server—specify the secretARN where the SMTP credentials are stored.
    ///   - clientToken: A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    ///   - relayName: The unique name of the relay resource.
    ///   - serverName: The destination relay server address.
    ///   - serverPort: The destination relay server port.
    ///   - tags: The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRelay(
        authentication: RelayAuthentication,
        clientToken: String? = CreateRelayRequest.idempotencyToken(),
        relayName: String,
        serverName: String,
        serverPort: Int,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRelayResponse {
        let input = CreateRelayRequest(
            authentication: authentication, 
            clientToken: clientToken, 
            relayName: relayName, 
            serverName: serverName, 
            serverPort: serverPort, 
            tags: tags
        )
        return try await self.createRelay(input, logger: logger)
    }

    /// Provision a new rule set.
    @Sendable
    @inlinable
    public func createRuleSet(_ input: CreateRuleSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRuleSetResponse {
        try await self.client.execute(
            operation: "CreateRuleSet", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provision a new rule set.
    ///
    /// Parameters:
    ///   - clientToken: A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    ///   - rules: Conditional rules that are evaluated for determining actions on email.
    ///   - ruleSetName: A user-friendly name for the rule set.
    ///   - tags: The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRuleSet(
        clientToken: String? = CreateRuleSetRequest.idempotencyToken(),
        rules: [Rule],
        ruleSetName: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRuleSetResponse {
        let input = CreateRuleSetRequest(
            clientToken: clientToken, 
            rules: rules, 
            ruleSetName: ruleSetName, 
            tags: tags
        )
        return try await self.createRuleSet(input, logger: logger)
    }

    /// Provision a new traffic policy resource.
    @Sendable
    @inlinable
    public func createTrafficPolicy(_ input: CreateTrafficPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTrafficPolicyResponse {
        try await self.client.execute(
            operation: "CreateTrafficPolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provision a new traffic policy resource.
    ///
    /// Parameters:
    ///   - clientToken: A unique token that Amazon SES uses to recognize subsequent retries of the same request.
    ///   - defaultAction: Default action instructs the traﬃc policy to either Allow or Deny (block) messages that fall outside of (or not addressed by) the conditions of your policy statements
    ///   - maxMessageSizeBytes: The maximum message size in bytes of email which is allowed in by this traffic policy—anything larger will be blocked.
    ///   - policyStatements: Conditional statements for filtering email traffic.
    ///   - tags: The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    ///   - trafficPolicyName: A user-friendly name for the traffic policy resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTrafficPolicy(
        clientToken: String? = CreateTrafficPolicyRequest.idempotencyToken(),
        defaultAction: AcceptAction,
        maxMessageSizeBytes: Int? = nil,
        policyStatements: [PolicyStatement],
        tags: [Tag]? = nil,
        trafficPolicyName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateTrafficPolicyResponse {
        let input = CreateTrafficPolicyRequest(
            clientToken: clientToken, 
            defaultAction: defaultAction, 
            maxMessageSizeBytes: maxMessageSizeBytes, 
            policyStatements: policyStatements, 
            tags: tags, 
            trafficPolicyName: trafficPolicyName
        )
        return try await self.createTrafficPolicy(input, logger: logger)
    }

    /// Deletes an Add On instance.
    @Sendable
    @inlinable
    public func deleteAddonInstance(_ input: DeleteAddonInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAddonInstanceResponse {
        try await self.client.execute(
            operation: "DeleteAddonInstance", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an Add On instance.
    ///
    /// Parameters:
    ///   - addonInstanceId: The Add On instance ID to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAddonInstance(
        addonInstanceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAddonInstanceResponse {
        let input = DeleteAddonInstanceRequest(
            addonInstanceId: addonInstanceId
        )
        return try await self.deleteAddonInstance(input, logger: logger)
    }

    /// Deletes an Add On subscription.
    @Sendable
    @inlinable
    public func deleteAddonSubscription(_ input: DeleteAddonSubscriptionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAddonSubscriptionResponse {
        try await self.client.execute(
            operation: "DeleteAddonSubscription", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an Add On subscription.
    ///
    /// Parameters:
    ///   - addonSubscriptionId: The Add On subscription ID to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAddonSubscription(
        addonSubscriptionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAddonSubscriptionResponse {
        let input = DeleteAddonSubscriptionRequest(
            addonSubscriptionId: addonSubscriptionId
        )
        return try await self.deleteAddonSubscription(input, logger: logger)
    }

    /// Deletes an address list.
    @Sendable
    @inlinable
    public func deleteAddressList(_ input: DeleteAddressListRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAddressListResponse {
        try await self.client.execute(
            operation: "DeleteAddressList", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an address list.
    ///
    /// Parameters:
    ///   - addressListId: The identifier of an existing address list resource to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAddressList(
        addressListId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAddressListResponse {
        let input = DeleteAddressListRequest(
            addressListId: addressListId
        )
        return try await self.deleteAddressList(input, logger: logger)
    }

    /// Initiates deletion of an email archive. This changes the archive state to pending deletion. In this state, no new emails can be added, and existing archived emails become inaccessible (search, export, download). The archive and all of its contents will be permanently deleted 30 days after entering the pending deletion state, regardless of the configured retention period.
    @Sendable
    @inlinable
    public func deleteArchive(_ input: DeleteArchiveRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteArchiveResponse {
        try await self.client.execute(
            operation: "DeleteArchive", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initiates deletion of an email archive. This changes the archive state to pending deletion. In this state, no new emails can be added, and existing archived emails become inaccessible (search, export, download). The archive and all of its contents will be permanently deleted 30 days after entering the pending deletion state, regardless of the configured retention period.
    ///
    /// Parameters:
    ///   - archiveId: The identifier of the archive to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteArchive(
        archiveId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteArchiveResponse {
        let input = DeleteArchiveRequest(
            archiveId: archiveId
        )
        return try await self.deleteArchive(input, logger: logger)
    }

    /// Delete an ingress endpoint resource.
    @Sendable
    @inlinable
    public func deleteIngressPoint(_ input: DeleteIngressPointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteIngressPointResponse {
        try await self.client.execute(
            operation: "DeleteIngressPoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete an ingress endpoint resource.
    ///
    /// Parameters:
    ///   - ingressPointId: The identifier of the ingress endpoint resource that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteIngressPoint(
        ingressPointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteIngressPointResponse {
        let input = DeleteIngressPointRequest(
            ingressPointId: ingressPointId
        )
        return try await self.deleteIngressPoint(input, logger: logger)
    }

    /// Deletes an existing relay resource.
    @Sendable
    @inlinable
    public func deleteRelay(_ input: DeleteRelayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteRelayResponse {
        try await self.client.execute(
            operation: "DeleteRelay", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing relay resource.
    ///
    /// Parameters:
    ///   - relayId: The unique relay identifier.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRelay(
        relayId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteRelayResponse {
        let input = DeleteRelayRequest(
            relayId: relayId
        )
        return try await self.deleteRelay(input, logger: logger)
    }

    /// Delete a rule set.
    @Sendable
    @inlinable
    public func deleteRuleSet(_ input: DeleteRuleSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteRuleSetResponse {
        try await self.client.execute(
            operation: "DeleteRuleSet", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a rule set.
    ///
    /// Parameters:
    ///   - ruleSetId: The identifier of an existing rule set resource to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRuleSet(
        ruleSetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteRuleSetResponse {
        let input = DeleteRuleSetRequest(
            ruleSetId: ruleSetId
        )
        return try await self.deleteRuleSet(input, logger: logger)
    }

    /// Delete a traffic policy resource.
    @Sendable
    @inlinable
    public func deleteTrafficPolicy(_ input: DeleteTrafficPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteTrafficPolicyResponse {
        try await self.client.execute(
            operation: "DeleteTrafficPolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a traffic policy resource.
    ///
    /// Parameters:
    ///   - trafficPolicyId: The identifier of the traffic policy that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTrafficPolicy(
        trafficPolicyId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteTrafficPolicyResponse {
        let input = DeleteTrafficPolicyRequest(
            trafficPolicyId: trafficPolicyId
        )
        return try await self.deleteTrafficPolicy(input, logger: logger)
    }

    /// Removes a member from an address list.
    @Sendable
    @inlinable
    public func deregisterMemberFromAddressList(_ input: DeregisterMemberFromAddressListRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeregisterMemberFromAddressListResponse {
        try await self.client.execute(
            operation: "DeregisterMemberFromAddressList", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a member from an address list.
    ///
    /// Parameters:
    ///   - address: The address to be removed from the address list.
    ///   - addressListId: The unique identifier of the address list to remove the address from.
    ///   - logger: Logger use during operation
    @inlinable
    public func deregisterMemberFromAddressList(
        address: String,
        addressListId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeregisterMemberFromAddressListResponse {
        let input = DeregisterMemberFromAddressListRequest(
            address: address, 
            addressListId: addressListId
        )
        return try await self.deregisterMemberFromAddressList(input, logger: logger)
    }

    /// Gets detailed information about an Add On instance.
    @Sendable
    @inlinable
    public func getAddonInstance(_ input: GetAddonInstanceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAddonInstanceResponse {
        try await self.client.execute(
            operation: "GetAddonInstance", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets detailed information about an Add On instance.
    ///
    /// Parameters:
    ///   - addonInstanceId: The Add On instance ID to retrieve information for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAddonInstance(
        addonInstanceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAddonInstanceResponse {
        let input = GetAddonInstanceRequest(
            addonInstanceId: addonInstanceId
        )
        return try await self.getAddonInstance(input, logger: logger)
    }

    /// Gets detailed information about an Add On subscription.
    @Sendable
    @inlinable
    public func getAddonSubscription(_ input: GetAddonSubscriptionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAddonSubscriptionResponse {
        try await self.client.execute(
            operation: "GetAddonSubscription", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets detailed information about an Add On subscription.
    ///
    /// Parameters:
    ///   - addonSubscriptionId: The Add On subscription ID to retrieve information for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAddonSubscription(
        addonSubscriptionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAddonSubscriptionResponse {
        let input = GetAddonSubscriptionRequest(
            addonSubscriptionId: addonSubscriptionId
        )
        return try await self.getAddonSubscription(input, logger: logger)
    }

    /// Fetch attributes of an address list.
    @Sendable
    @inlinable
    public func getAddressList(_ input: GetAddressListRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAddressListResponse {
        try await self.client.execute(
            operation: "GetAddressList", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Fetch attributes of an address list.
    ///
    /// Parameters:
    ///   - addressListId: The identifier of an existing address list resource to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAddressList(
        addressListId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAddressListResponse {
        let input = GetAddressListRequest(
            addressListId: addressListId
        )
        return try await self.getAddressList(input, logger: logger)
    }

    /// Fetch attributes of an import job.
    @Sendable
    @inlinable
    public func getAddressListImportJob(_ input: GetAddressListImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAddressListImportJobResponse {
        try await self.client.execute(
            operation: "GetAddressListImportJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Fetch attributes of an import job.
    ///
    /// Parameters:
    ///   - jobId: The identifier of the import job that needs to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAddressListImportJob(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAddressListImportJobResponse {
        let input = GetAddressListImportJobRequest(
            jobId: jobId
        )
        return try await self.getAddressListImportJob(input, logger: logger)
    }

    /// Retrieves the full details and current state of a specified email archive.
    @Sendable
    @inlinable
    public func getArchive(_ input: GetArchiveRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetArchiveResponse {
        try await self.client.execute(
            operation: "GetArchive", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the full details and current state of a specified email archive.
    ///
    /// Parameters:
    ///   - archiveId: The identifier of the archive to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getArchive(
        archiveId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetArchiveResponse {
        let input = GetArchiveRequest(
            archiveId: archiveId
        )
        return try await self.getArchive(input, logger: logger)
    }

    /// Retrieves the details and current status of a specific email archive export job.
    @Sendable
    @inlinable
    public func getArchiveExport(_ input: GetArchiveExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetArchiveExportResponse {
        try await self.client.execute(
            operation: "GetArchiveExport", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the details and current status of a specific email archive export job.
    ///
    /// Parameters:
    ///   - exportId: The identifier of the export job to get details for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getArchiveExport(
        exportId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetArchiveExportResponse {
        let input = GetArchiveExportRequest(
            exportId: exportId
        )
        return try await self.getArchiveExport(input, logger: logger)
    }

    /// Returns a pre-signed URL that provides temporary download access to the specific email message stored in the archive.
    @Sendable
    @inlinable
    public func getArchiveMessage(_ input: GetArchiveMessageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetArchiveMessageResponse {
        try await self.client.execute(
            operation: "GetArchiveMessage", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a pre-signed URL that provides temporary download access to the specific email message stored in the archive.
    ///
    /// Parameters:
    ///   - archivedMessageId: The unique identifier of the archived email message.
    ///   - logger: Logger use during operation
    @inlinable
    public func getArchiveMessage(
        archivedMessageId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetArchiveMessageResponse {
        let input = GetArchiveMessageRequest(
            archivedMessageId: archivedMessageId
        )
        return try await self.getArchiveMessage(input, logger: logger)
    }

    /// Returns the textual content of a specific email message stored in the archive. Attachments are not included.
    @Sendable
    @inlinable
    public func getArchiveMessageContent(_ input: GetArchiveMessageContentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetArchiveMessageContentResponse {
        try await self.client.execute(
            operation: "GetArchiveMessageContent", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the textual content of a specific email message stored in the archive. Attachments are not included.
    ///
    /// Parameters:
    ///   - archivedMessageId: The unique identifier of the archived email message.
    ///   - logger: Logger use during operation
    @inlinable
    public func getArchiveMessageContent(
        archivedMessageId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetArchiveMessageContentResponse {
        let input = GetArchiveMessageContentRequest(
            archivedMessageId: archivedMessageId
        )
        return try await self.getArchiveMessageContent(input, logger: logger)
    }

    /// Retrieves the details and current status of a specific email archive search job.
    @Sendable
    @inlinable
    public func getArchiveSearch(_ input: GetArchiveSearchRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetArchiveSearchResponse {
        try await self.client.execute(
            operation: "GetArchiveSearch", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the details and current status of a specific email archive search job.
    ///
    /// Parameters:
    ///   - searchId: The identifier of the search job to get details for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getArchiveSearch(
        searchId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetArchiveSearchResponse {
        let input = GetArchiveSearchRequest(
            searchId: searchId
        )
        return try await self.getArchiveSearch(input, logger: logger)
    }

    /// Returns the results of a completed email archive search job.
    @Sendable
    @inlinable
    public func getArchiveSearchResults(_ input: GetArchiveSearchResultsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetArchiveSearchResultsResponse {
        try await self.client.execute(
            operation: "GetArchiveSearchResults", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the results of a completed email archive search job.
    ///
    /// Parameters:
    ///   - searchId: The identifier of the completed search job.
    ///   - logger: Logger use during operation
    @inlinable
    public func getArchiveSearchResults(
        searchId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetArchiveSearchResultsResponse {
        let input = GetArchiveSearchResultsRequest(
            searchId: searchId
        )
        return try await self.getArchiveSearchResults(input, logger: logger)
    }

    /// Fetch ingress endpoint resource attributes.
    @Sendable
    @inlinable
    public func getIngressPoint(_ input: GetIngressPointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIngressPointResponse {
        try await self.client.execute(
            operation: "GetIngressPoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Fetch ingress endpoint resource attributes.
    ///
    /// Parameters:
    ///   - ingressPointId: The identifier of an ingress endpoint.
    ///   - logger: Logger use during operation
    @inlinable
    public func getIngressPoint(
        ingressPointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetIngressPointResponse {
        let input = GetIngressPointRequest(
            ingressPointId: ingressPointId
        )
        return try await self.getIngressPoint(input, logger: logger)
    }

    /// Fetch attributes of a member in an address list.
    @Sendable
    @inlinable
    public func getMemberOfAddressList(_ input: GetMemberOfAddressListRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMemberOfAddressListResponse {
        try await self.client.execute(
            operation: "GetMemberOfAddressList", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Fetch attributes of a member in an address list.
    ///
    /// Parameters:
    ///   - address: The address to be retrieved from the address list.
    ///   - addressListId: The unique identifier of the address list to retrieve the address from.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMemberOfAddressList(
        address: String,
        addressListId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMemberOfAddressListResponse {
        let input = GetMemberOfAddressListRequest(
            address: address, 
            addressListId: addressListId
        )
        return try await self.getMemberOfAddressList(input, logger: logger)
    }

    /// Fetch the relay resource and it's attributes.
    @Sendable
    @inlinable
    public func getRelay(_ input: GetRelayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRelayResponse {
        try await self.client.execute(
            operation: "GetRelay", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Fetch the relay resource and it's attributes.
    ///
    /// Parameters:
    ///   - relayId: A unique relay identifier.
    ///   - logger: Logger use during operation
    @inlinable
    public func getRelay(
        relayId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetRelayResponse {
        let input = GetRelayRequest(
            relayId: relayId
        )
        return try await self.getRelay(input, logger: logger)
    }

    /// Fetch attributes of a rule set.
    @Sendable
    @inlinable
    public func getRuleSet(_ input: GetRuleSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRuleSetResponse {
        try await self.client.execute(
            operation: "GetRuleSet", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Fetch attributes of a rule set.
    ///
    /// Parameters:
    ///   - ruleSetId: The identifier of an existing rule set to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func getRuleSet(
        ruleSetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetRuleSetResponse {
        let input = GetRuleSetRequest(
            ruleSetId: ruleSetId
        )
        return try await self.getRuleSet(input, logger: logger)
    }

    /// Fetch attributes of a traffic policy resource.
    @Sendable
    @inlinable
    public func getTrafficPolicy(_ input: GetTrafficPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTrafficPolicyResponse {
        try await self.client.execute(
            operation: "GetTrafficPolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Fetch attributes of a traffic policy resource.
    ///
    /// Parameters:
    ///   - trafficPolicyId: The identifier of the traffic policy resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTrafficPolicy(
        trafficPolicyId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTrafficPolicyResponse {
        let input = GetTrafficPolicyRequest(
            trafficPolicyId: trafficPolicyId
        )
        return try await self.getTrafficPolicy(input, logger: logger)
    }

    /// Lists all Add On instances in your account.
    @Sendable
    @inlinable
    public func listAddonInstances(_ input: ListAddonInstancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAddonInstancesResponse {
        try await self.client.execute(
            operation: "ListAddonInstances", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all Add On instances in your account.
    ///
    /// Parameters:
    ///   - nextToken: If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    ///   - pageSize: The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAddonInstances(
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAddonInstancesResponse {
        let input = ListAddonInstancesRequest(
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listAddonInstances(input, logger: logger)
    }

    /// Lists all Add On subscriptions in your account.
    @Sendable
    @inlinable
    public func listAddonSubscriptions(_ input: ListAddonSubscriptionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAddonSubscriptionsResponse {
        try await self.client.execute(
            operation: "ListAddonSubscriptions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all Add On subscriptions in your account.
    ///
    /// Parameters:
    ///   - nextToken: If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    ///   - pageSize: The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAddonSubscriptions(
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAddonSubscriptionsResponse {
        let input = ListAddonSubscriptionsRequest(
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listAddonSubscriptions(input, logger: logger)
    }

    /// Lists jobs for an address list.
    @Sendable
    @inlinable
    public func listAddressListImportJobs(_ input: ListAddressListImportJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAddressListImportJobsResponse {
        try await self.client.execute(
            operation: "ListAddressListImportJobs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists jobs for an address list.
    ///
    /// Parameters:
    ///   - addressListId: The unique identifier of the address list for listing import jobs.
    ///   - nextToken: If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    ///   - pageSize: The maximum number of import jobs that are returned per call. You can use NextToken to retrieve the next page of jobs.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAddressListImportJobs(
        addressListId: String,
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAddressListImportJobsResponse {
        let input = ListAddressListImportJobsRequest(
            addressListId: addressListId, 
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listAddressListImportJobs(input, logger: logger)
    }

    /// Lists address lists for this account.
    @Sendable
    @inlinable
    public func listAddressLists(_ input: ListAddressListsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAddressListsResponse {
        try await self.client.execute(
            operation: "ListAddressLists", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists address lists for this account.
    ///
    /// Parameters:
    ///   - nextToken: If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    ///   - pageSize: The maximum number of address list resources that are returned per call. You can use NextToken to retrieve the next page of address lists.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAddressLists(
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAddressListsResponse {
        let input = ListAddressListsRequest(
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listAddressLists(input, logger: logger)
    }

    /// Returns a list of email archive export jobs.
    @Sendable
    @inlinable
    public func listArchiveExports(_ input: ListArchiveExportsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListArchiveExportsResponse {
        try await self.client.execute(
            operation: "ListArchiveExports", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of email archive export jobs.
    ///
    /// Parameters:
    ///   - archiveId: The identifier of the archive.
    ///   - nextToken: If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    ///   - pageSize: The maximum number of archive export jobs that are returned per call. You can use NextToken to obtain further pages of archives.
    ///   - logger: Logger use during operation
    @inlinable
    public func listArchiveExports(
        archiveId: String,
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListArchiveExportsResponse {
        let input = ListArchiveExportsRequest(
            archiveId: archiveId, 
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listArchiveExports(input, logger: logger)
    }

    /// Returns a list of email archive search jobs.
    @Sendable
    @inlinable
    public func listArchiveSearches(_ input: ListArchiveSearchesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListArchiveSearchesResponse {
        try await self.client.execute(
            operation: "ListArchiveSearches", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of email archive search jobs.
    ///
    /// Parameters:
    ///   - archiveId: The identifier of the archive.
    ///   - nextToken: If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    ///   - pageSize: The maximum number of archive search jobs that are returned per call. You can use NextToken to obtain further pages of archives.
    ///   - logger: Logger use during operation
    @inlinable
    public func listArchiveSearches(
        archiveId: String,
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListArchiveSearchesResponse {
        let input = ListArchiveSearchesRequest(
            archiveId: archiveId, 
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listArchiveSearches(input, logger: logger)
    }

    /// Returns a list of all email archives in your account.
    @Sendable
    @inlinable
    public func listArchives(_ input: ListArchivesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListArchivesResponse {
        try await self.client.execute(
            operation: "ListArchives", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all email archives in your account.
    ///
    /// Parameters:
    ///   - nextToken: If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    ///   - pageSize: The maximum number of archives that are returned per call. You can use NextToken to obtain further pages of archives.
    ///   - logger: Logger use during operation
    @inlinable
    public func listArchives(
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListArchivesResponse {
        let input = ListArchivesRequest(
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listArchives(input, logger: logger)
    }

    /// List all ingress endpoint resources.
    @Sendable
    @inlinable
    public func listIngressPoints(_ input: ListIngressPointsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIngressPointsResponse {
        try await self.client.execute(
            operation: "ListIngressPoints", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all ingress endpoint resources.
    ///
    /// Parameters:
    ///   - nextToken: If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    ///   - pageSize: The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIngressPoints(
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIngressPointsResponse {
        let input = ListIngressPointsRequest(
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listIngressPoints(input, logger: logger)
    }

    /// Lists members of an address list.
    @Sendable
    @inlinable
    public func listMembersOfAddressList(_ input: ListMembersOfAddressListRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMembersOfAddressListResponse {
        try await self.client.execute(
            operation: "ListMembersOfAddressList", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists members of an address list.
    ///
    /// Parameters:
    ///   - addressListId: The unique identifier of the address list to list the addresses from.
    ///   - filter: Filter to be used to limit the results.
    ///   - nextToken: If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    ///   - pageSize: The maximum number of address list members that are returned per call. You can use NextToken to retrieve the next page of members.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMembersOfAddressList(
        addressListId: String,
        filter: AddressFilter? = nil,
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMembersOfAddressListResponse {
        let input = ListMembersOfAddressListRequest(
            addressListId: addressListId, 
            filter: filter, 
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listMembersOfAddressList(input, logger: logger)
    }

    /// Lists all the existing relay resources.
    @Sendable
    @inlinable
    public func listRelays(_ input: ListRelaysRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRelaysResponse {
        try await self.client.execute(
            operation: "ListRelays", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the existing relay resources.
    ///
    /// Parameters:
    ///   - nextToken: If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    ///   - pageSize: The number of relays to be returned in one request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRelays(
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRelaysResponse {
        let input = ListRelaysRequest(
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listRelays(input, logger: logger)
    }

    /// List rule sets for this account.
    @Sendable
    @inlinable
    public func listRuleSets(_ input: ListRuleSetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRuleSetsResponse {
        try await self.client.execute(
            operation: "ListRuleSets", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List rule sets for this account.
    ///
    /// Parameters:
    ///   - nextToken: If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    ///   - pageSize: The maximum number of rule set resources that are returned per call. You can use NextToken to obtain further rule sets.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRuleSets(
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRuleSetsResponse {
        let input = ListRuleSetsRequest(
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listRuleSets(input, logger: logger)
    }

    ///  Retrieves the list of tags (keys and values) assigned to the resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves the list of tags (keys and values) assigned to the resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource to retrieve tags from.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// List traffic policy resources.
    @Sendable
    @inlinable
    public func listTrafficPolicies(_ input: ListTrafficPoliciesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTrafficPoliciesResponse {
        try await self.client.execute(
            operation: "ListTrafficPolicies", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List traffic policy resources.
    ///
    /// Parameters:
    ///   - nextToken: If you received a pagination token from a previous call to this API, you can provide it here to continue paginating through the next page of results.
    ///   - pageSize: The maximum number of traffic policy resources that are returned per call. You can use NextToken to obtain further traffic policies.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTrafficPolicies(
        nextToken: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTrafficPoliciesResponse {
        let input = ListTrafficPoliciesRequest(
            nextToken: nextToken, 
            pageSize: pageSize
        )
        return try await self.listTrafficPolicies(input, logger: logger)
    }

    /// Adds a member to an address list.
    @Sendable
    @inlinable
    public func registerMemberToAddressList(_ input: RegisterMemberToAddressListRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RegisterMemberToAddressListResponse {
        try await self.client.execute(
            operation: "RegisterMemberToAddressList", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds a member to an address list.
    ///
    /// Parameters:
    ///   - address: The address to be added to the address list.
    ///   - addressListId: The unique identifier of the address list where the address should be added.
    ///   - logger: Logger use during operation
    @inlinable
    public func registerMemberToAddressList(
        address: String,
        addressListId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RegisterMemberToAddressListResponse {
        let input = RegisterMemberToAddressListRequest(
            address: address, 
            addressListId: addressListId
        )
        return try await self.registerMemberToAddressList(input, logger: logger)
    }

    /// Starts an import job for an address list.
    @Sendable
    @inlinable
    public func startAddressListImportJob(_ input: StartAddressListImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartAddressListImportJobResponse {
        try await self.client.execute(
            operation: "StartAddressListImportJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts an import job for an address list.
    ///
    /// Parameters:
    ///   - jobId: The identifier of the import job that needs to be started.
    ///   - logger: Logger use during operation
    @inlinable
    public func startAddressListImportJob(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartAddressListImportJobResponse {
        let input = StartAddressListImportJobRequest(
            jobId: jobId
        )
        return try await self.startAddressListImportJob(input, logger: logger)
    }

    /// Initiates an export of emails from the specified archive.
    @Sendable
    @inlinable
    public func startArchiveExport(_ input: StartArchiveExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartArchiveExportResponse {
        try await self.client.execute(
            operation: "StartArchiveExport", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initiates an export of emails from the specified archive.
    ///
    /// Parameters:
    ///   - archiveId: The identifier of the archive to export emails from.
    ///   - exportDestinationConfiguration: Details on where to deliver the exported email data.
    ///   - filters: Criteria to filter which emails are included in the export.
    ///   - fromTimestamp: The start of the timestamp range to include emails from.
    ///   - includeMetadata: Whether to include message metadata as JSON files in the export.
    ///   - maxResults: The maximum number of email items to include in the export.
    ///   - toTimestamp: The end of the timestamp range to include emails from.
    ///   - logger: Logger use during operation
    @inlinable
    public func startArchiveExport(
        archiveId: String,
        exportDestinationConfiguration: ExportDestinationConfiguration,
        filters: ArchiveFilters? = nil,
        fromTimestamp: Date,
        includeMetadata: Bool? = nil,
        maxResults: Int? = nil,
        toTimestamp: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartArchiveExportResponse {
        let input = StartArchiveExportRequest(
            archiveId: archiveId, 
            exportDestinationConfiguration: exportDestinationConfiguration, 
            filters: filters, 
            fromTimestamp: fromTimestamp, 
            includeMetadata: includeMetadata, 
            maxResults: maxResults, 
            toTimestamp: toTimestamp
        )
        return try await self.startArchiveExport(input, logger: logger)
    }

    /// Initiates a search across emails in the specified archive.
    @Sendable
    @inlinable
    public func startArchiveSearch(_ input: StartArchiveSearchRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartArchiveSearchResponse {
        try await self.client.execute(
            operation: "StartArchiveSearch", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initiates a search across emails in the specified archive.
    ///
    /// Parameters:
    ///   - archiveId: The identifier of the archive to search emails in.
    ///   - filters: Criteria to filter which emails are included in the search results.
    ///   - fromTimestamp: The start timestamp of the range to search emails from.
    ///   - maxResults: The maximum number of search results to return.
    ///   - toTimestamp: The end timestamp of the range to search emails from.
    ///   - logger: Logger use during operation
    @inlinable
    public func startArchiveSearch(
        archiveId: String,
        filters: ArchiveFilters? = nil,
        fromTimestamp: Date,
        maxResults: Int,
        toTimestamp: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartArchiveSearchResponse {
        let input = StartArchiveSearchRequest(
            archiveId: archiveId, 
            filters: filters, 
            fromTimestamp: fromTimestamp, 
            maxResults: maxResults, 
            toTimestamp: toTimestamp
        )
        return try await self.startArchiveSearch(input, logger: logger)
    }

    /// Stops an ongoing import job for an address list.
    @Sendable
    @inlinable
    public func stopAddressListImportJob(_ input: StopAddressListImportJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopAddressListImportJobResponse {
        try await self.client.execute(
            operation: "StopAddressListImportJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops an ongoing import job for an address list.
    ///
    /// Parameters:
    ///   - jobId: The identifier of the import job that needs to be stopped.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopAddressListImportJob(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopAddressListImportJobResponse {
        let input = StopAddressListImportJobRequest(
            jobId: jobId
        )
        return try await self.stopAddressListImportJob(input, logger: logger)
    }

    /// Stops an in-progress export of emails from an archive.
    @Sendable
    @inlinable
    public func stopArchiveExport(_ input: StopArchiveExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopArchiveExportResponse {
        try await self.client.execute(
            operation: "StopArchiveExport", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops an in-progress export of emails from an archive.
    ///
    /// Parameters:
    ///   - exportId: The identifier of the export job to stop.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopArchiveExport(
        exportId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopArchiveExportResponse {
        let input = StopArchiveExportRequest(
            exportId: exportId
        )
        return try await self.stopArchiveExport(input, logger: logger)
    }

    /// Stops an in-progress archive search job.
    @Sendable
    @inlinable
    public func stopArchiveSearch(_ input: StopArchiveSearchRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopArchiveSearchResponse {
        try await self.client.execute(
            operation: "StopArchiveSearch", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops an in-progress archive search job.
    ///
    /// Parameters:
    ///   - searchId: The identifier of the search job to stop.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopArchiveSearch(
        searchId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopArchiveSearchResponse {
        let input = StopArchiveSearchRequest(
            searchId: searchId
        )
        return try await self.stopArchiveSearch(input, logger: logger)
    }

    ///  Adds one or more tags (keys and values) to a specified resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Adds one or more tags (keys and values) to a specified resource.
    ///
    /// Parameters:
    ///   - resourceArn:  The Amazon Resource Name (ARN) of the resource that you want to tag.
    ///   - tags:  The tags used to organize, track, or control access for the resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [Tag],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    ///  Remove one or more tags (keys and values) from a specified resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Remove one or more tags (keys and values) from a specified resource.
    ///
    /// Parameters:
    ///   - resourceArn:  The Amazon Resource Name (ARN) of the resource that you want to untag.
    ///   - tagKeys:  The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates the attributes of an existing email archive.
    @Sendable
    @inlinable
    public func updateArchive(_ input: UpdateArchiveRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateArchiveResponse {
        try await self.client.execute(
            operation: "UpdateArchive", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the attributes of an existing email archive.
    ///
    /// Parameters:
    ///   - archiveId: The identifier of the archive to update.
    ///   - archiveName: A new, unique name for the archive.
    ///   - retention: A new retention period for emails in the archive.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateArchive(
        archiveId: String,
        archiveName: String? = nil,
        retention: ArchiveRetention? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateArchiveResponse {
        let input = UpdateArchiveRequest(
            archiveId: archiveId, 
            archiveName: archiveName, 
            retention: retention
        )
        return try await self.updateArchive(input, logger: logger)
    }

    /// Update attributes of a provisioned ingress endpoint resource.
    @Sendable
    @inlinable
    public func updateIngressPoint(_ input: UpdateIngressPointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateIngressPointResponse {
        try await self.client.execute(
            operation: "UpdateIngressPoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update attributes of a provisioned ingress endpoint resource.
    ///
    /// Parameters:
    ///   - ingressPointConfiguration: If you choose an Authenticated ingress endpoint, you must configure either an SMTP password or a secret ARN.
    ///   - ingressPointId: The identifier for the ingress endpoint you want to update.
    ///   - ingressPointName: A user friendly name for the ingress endpoint resource.
    ///   - ruleSetId: The identifier of an existing rule set that you attach to an ingress endpoint resource.
    ///   - statusToUpdate: The update status of an ingress endpoint.
    ///   - trafficPolicyId: The identifier of an existing traffic policy that you attach to an ingress endpoint resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateIngressPoint(
        ingressPointConfiguration: IngressPointConfiguration? = nil,
        ingressPointId: String,
        ingressPointName: String? = nil,
        ruleSetId: String? = nil,
        statusToUpdate: IngressPointStatusToUpdate? = nil,
        trafficPolicyId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateIngressPointResponse {
        let input = UpdateIngressPointRequest(
            ingressPointConfiguration: ingressPointConfiguration, 
            ingressPointId: ingressPointId, 
            ingressPointName: ingressPointName, 
            ruleSetId: ruleSetId, 
            statusToUpdate: statusToUpdate, 
            trafficPolicyId: trafficPolicyId
        )
        return try await self.updateIngressPoint(input, logger: logger)
    }

    /// Updates the attributes of an existing relay resource.
    @Sendable
    @inlinable
    public func updateRelay(_ input: UpdateRelayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateRelayResponse {
        try await self.client.execute(
            operation: "UpdateRelay", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the attributes of an existing relay resource.
    ///
    /// Parameters:
    ///   - authentication: Authentication for the relay destination server—specify the secretARN where the SMTP credentials are stored.
    ///   - relayId: The unique relay identifier.
    ///   - relayName: The name of the relay resource.
    ///   - serverName: The destination relay server address.
    ///   - serverPort: The destination relay server port.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRelay(
        authentication: RelayAuthentication? = nil,
        relayId: String,
        relayName: String? = nil,
        serverName: String? = nil,
        serverPort: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateRelayResponse {
        let input = UpdateRelayRequest(
            authentication: authentication, 
            relayId: relayId, 
            relayName: relayName, 
            serverName: serverName, 
            serverPort: serverPort
        )
        return try await self.updateRelay(input, logger: logger)
    }

    /// Update attributes of an already provisioned rule set.
    @Sendable
    @inlinable
    public func updateRuleSet(_ input: UpdateRuleSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateRuleSetResponse {
        try await self.client.execute(
            operation: "UpdateRuleSet", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update attributes of an already provisioned rule set.
    ///
    /// Parameters:
    ///   - rules: A new set of rules to replace the current rules of the rule set—these rules will override all the rules of the rule set.
    ///   - ruleSetId: The identifier of a rule set you want to update.
    ///   - ruleSetName: A user-friendly name for the rule set resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRuleSet(
        rules: [Rule]? = nil,
        ruleSetId: String,
        ruleSetName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateRuleSetResponse {
        let input = UpdateRuleSetRequest(
            rules: rules, 
            ruleSetId: ruleSetId, 
            ruleSetName: ruleSetName
        )
        return try await self.updateRuleSet(input, logger: logger)
    }

    /// Update attributes of an already provisioned traffic policy resource.
    @Sendable
    @inlinable
    public func updateTrafficPolicy(_ input: UpdateTrafficPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateTrafficPolicyResponse {
        try await self.client.execute(
            operation: "UpdateTrafficPolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update attributes of an already provisioned traffic policy resource.
    ///
    /// Parameters:
    ///   - defaultAction: Default action instructs the traﬃc policy to either Allow or Deny (block) messages that fall outside of (or not addressed by) the conditions of your policy statements
    ///   - maxMessageSizeBytes: The maximum message size in bytes of email which is allowed in by this traffic policy—anything larger will be blocked.
    ///   - policyStatements: The list of conditions to be updated for filtering email traffic.
    ///   - trafficPolicyId: The identifier of the traffic policy that you want to update.
    ///   - trafficPolicyName: A user-friendly name for the traffic policy resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateTrafficPolicy(
        defaultAction: AcceptAction? = nil,
        maxMessageSizeBytes: Int? = nil,
        policyStatements: [PolicyStatement]? = nil,
        trafficPolicyId: String,
        trafficPolicyName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateTrafficPolicyResponse {
        let input = UpdateTrafficPolicyRequest(
            defaultAction: defaultAction, 
            maxMessageSizeBytes: maxMessageSizeBytes, 
            policyStatements: policyStatements, 
            trafficPolicyId: trafficPolicyId, 
            trafficPolicyName: trafficPolicyName
        )
        return try await self.updateTrafficPolicy(input, logger: logger)
    }
}

extension MailManager {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: MailManager, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension MailManager {
    /// Return PaginatorSequence for operation ``listAddonInstances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAddonInstancesPaginator(
        _ input: ListAddonInstancesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAddonInstancesRequest, ListAddonInstancesResponse> {
        return .init(
            input: input,
            command: self.listAddonInstances,
            inputKey: \ListAddonInstancesRequest.nextToken,
            outputKey: \ListAddonInstancesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAddonInstances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - pageSize: The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAddonInstancesPaginator(
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAddonInstancesRequest, ListAddonInstancesResponse> {
        let input = ListAddonInstancesRequest(
            pageSize: pageSize
        )
        return self.listAddonInstancesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAddonSubscriptions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAddonSubscriptionsPaginator(
        _ input: ListAddonSubscriptionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAddonSubscriptionsRequest, ListAddonSubscriptionsResponse> {
        return .init(
            input: input,
            command: self.listAddonSubscriptions,
            inputKey: \ListAddonSubscriptionsRequest.nextToken,
            outputKey: \ListAddonSubscriptionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAddonSubscriptions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - pageSize: The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAddonSubscriptionsPaginator(
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAddonSubscriptionsRequest, ListAddonSubscriptionsResponse> {
        let input = ListAddonSubscriptionsRequest(
            pageSize: pageSize
        )
        return self.listAddonSubscriptionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAddressListImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAddressListImportJobsPaginator(
        _ input: ListAddressListImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAddressListImportJobsRequest, ListAddressListImportJobsResponse> {
        return .init(
            input: input,
            command: self.listAddressListImportJobs,
            inputKey: \ListAddressListImportJobsRequest.nextToken,
            outputKey: \ListAddressListImportJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAddressListImportJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - addressListId: The unique identifier of the address list for listing import jobs.
    ///   - pageSize: The maximum number of import jobs that are returned per call. You can use NextToken to retrieve the next page of jobs.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAddressListImportJobsPaginator(
        addressListId: String,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAddressListImportJobsRequest, ListAddressListImportJobsResponse> {
        let input = ListAddressListImportJobsRequest(
            addressListId: addressListId, 
            pageSize: pageSize
        )
        return self.listAddressListImportJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAddressLists(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAddressListsPaginator(
        _ input: ListAddressListsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAddressListsRequest, ListAddressListsResponse> {
        return .init(
            input: input,
            command: self.listAddressLists,
            inputKey: \ListAddressListsRequest.nextToken,
            outputKey: \ListAddressListsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAddressLists(_:logger:)``.
    ///
    /// - Parameters:
    ///   - pageSize: The maximum number of address list resources that are returned per call. You can use NextToken to retrieve the next page of address lists.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAddressListsPaginator(
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAddressListsRequest, ListAddressListsResponse> {
        let input = ListAddressListsRequest(
            pageSize: pageSize
        )
        return self.listAddressListsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listArchiveExports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listArchiveExportsPaginator(
        _ input: ListArchiveExportsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListArchiveExportsRequest, ListArchiveExportsResponse> {
        return .init(
            input: input,
            command: self.listArchiveExports,
            inputKey: \ListArchiveExportsRequest.nextToken,
            outputKey: \ListArchiveExportsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listArchiveExports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - archiveId: The identifier of the archive.
    ///   - pageSize: The maximum number of archive export jobs that are returned per call. You can use NextToken to obtain further pages of archives.
    ///   - logger: Logger used for logging
    @inlinable
    public func listArchiveExportsPaginator(
        archiveId: String,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListArchiveExportsRequest, ListArchiveExportsResponse> {
        let input = ListArchiveExportsRequest(
            archiveId: archiveId, 
            pageSize: pageSize
        )
        return self.listArchiveExportsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listArchiveSearches(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listArchiveSearchesPaginator(
        _ input: ListArchiveSearchesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListArchiveSearchesRequest, ListArchiveSearchesResponse> {
        return .init(
            input: input,
            command: self.listArchiveSearches,
            inputKey: \ListArchiveSearchesRequest.nextToken,
            outputKey: \ListArchiveSearchesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listArchiveSearches(_:logger:)``.
    ///
    /// - Parameters:
    ///   - archiveId: The identifier of the archive.
    ///   - pageSize: The maximum number of archive search jobs that are returned per call. You can use NextToken to obtain further pages of archives.
    ///   - logger: Logger used for logging
    @inlinable
    public func listArchiveSearchesPaginator(
        archiveId: String,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListArchiveSearchesRequest, ListArchiveSearchesResponse> {
        let input = ListArchiveSearchesRequest(
            archiveId: archiveId, 
            pageSize: pageSize
        )
        return self.listArchiveSearchesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listArchives(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listArchivesPaginator(
        _ input: ListArchivesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListArchivesRequest, ListArchivesResponse> {
        return .init(
            input: input,
            command: self.listArchives,
            inputKey: \ListArchivesRequest.nextToken,
            outputKey: \ListArchivesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listArchives(_:logger:)``.
    ///
    /// - Parameters:
    ///   - pageSize: The maximum number of archives that are returned per call. You can use NextToken to obtain further pages of archives.
    ///   - logger: Logger used for logging
    @inlinable
    public func listArchivesPaginator(
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListArchivesRequest, ListArchivesResponse> {
        let input = ListArchivesRequest(
            pageSize: pageSize
        )
        return self.listArchivesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listIngressPoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIngressPointsPaginator(
        _ input: ListIngressPointsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIngressPointsRequest, ListIngressPointsResponse> {
        return .init(
            input: input,
            command: self.listIngressPoints,
            inputKey: \ListIngressPointsRequest.nextToken,
            outputKey: \ListIngressPointsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIngressPoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - pageSize: The maximum number of ingress endpoint resources that are returned per call. You can use NextToken to obtain further ingress endpoints.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIngressPointsPaginator(
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIngressPointsRequest, ListIngressPointsResponse> {
        let input = ListIngressPointsRequest(
            pageSize: pageSize
        )
        return self.listIngressPointsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMembersOfAddressList(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMembersOfAddressListPaginator(
        _ input: ListMembersOfAddressListRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMembersOfAddressListRequest, ListMembersOfAddressListResponse> {
        return .init(
            input: input,
            command: self.listMembersOfAddressList,
            inputKey: \ListMembersOfAddressListRequest.nextToken,
            outputKey: \ListMembersOfAddressListResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMembersOfAddressList(_:logger:)``.
    ///
    /// - Parameters:
    ///   - addressListId: The unique identifier of the address list to list the addresses from.
    ///   - filter: Filter to be used to limit the results.
    ///   - pageSize: The maximum number of address list members that are returned per call. You can use NextToken to retrieve the next page of members.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMembersOfAddressListPaginator(
        addressListId: String,
        filter: AddressFilter? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMembersOfAddressListRequest, ListMembersOfAddressListResponse> {
        let input = ListMembersOfAddressListRequest(
            addressListId: addressListId, 
            filter: filter, 
            pageSize: pageSize
        )
        return self.listMembersOfAddressListPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRelays(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRelaysPaginator(
        _ input: ListRelaysRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRelaysRequest, ListRelaysResponse> {
        return .init(
            input: input,
            command: self.listRelays,
            inputKey: \ListRelaysRequest.nextToken,
            outputKey: \ListRelaysResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRelays(_:logger:)``.
    ///
    /// - Parameters:
    ///   - pageSize: The number of relays to be returned in one request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRelaysPaginator(
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRelaysRequest, ListRelaysResponse> {
        let input = ListRelaysRequest(
            pageSize: pageSize
        )
        return self.listRelaysPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRuleSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRuleSetsPaginator(
        _ input: ListRuleSetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRuleSetsRequest, ListRuleSetsResponse> {
        return .init(
            input: input,
            command: self.listRuleSets,
            inputKey: \ListRuleSetsRequest.nextToken,
            outputKey: \ListRuleSetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRuleSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - pageSize: The maximum number of rule set resources that are returned per call. You can use NextToken to obtain further rule sets.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRuleSetsPaginator(
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRuleSetsRequest, ListRuleSetsResponse> {
        let input = ListRuleSetsRequest(
            pageSize: pageSize
        )
        return self.listRuleSetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTrafficPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTrafficPoliciesPaginator(
        _ input: ListTrafficPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTrafficPoliciesRequest, ListTrafficPoliciesResponse> {
        return .init(
            input: input,
            command: self.listTrafficPolicies,
            inputKey: \ListTrafficPoliciesRequest.nextToken,
            outputKey: \ListTrafficPoliciesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTrafficPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - pageSize: The maximum number of traffic policy resources that are returned per call. You can use NextToken to obtain further traffic policies.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTrafficPoliciesPaginator(
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTrafficPoliciesRequest, ListTrafficPoliciesResponse> {
        let input = ListTrafficPoliciesRequest(
            pageSize: pageSize
        )
        return self.listTrafficPoliciesPaginator(input, logger: logger)
    }
}

extension MailManager.ListAddonInstancesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListAddonInstancesRequest {
        return .init(
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}

extension MailManager.ListAddonSubscriptionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListAddonSubscriptionsRequest {
        return .init(
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}

extension MailManager.ListAddressListImportJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListAddressListImportJobsRequest {
        return .init(
            addressListId: self.addressListId,
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}

extension MailManager.ListAddressListsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListAddressListsRequest {
        return .init(
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}

extension MailManager.ListArchiveExportsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListArchiveExportsRequest {
        return .init(
            archiveId: self.archiveId,
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}

extension MailManager.ListArchiveSearchesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListArchiveSearchesRequest {
        return .init(
            archiveId: self.archiveId,
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}

extension MailManager.ListArchivesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListArchivesRequest {
        return .init(
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}

extension MailManager.ListIngressPointsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListIngressPointsRequest {
        return .init(
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}

extension MailManager.ListMembersOfAddressListRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListMembersOfAddressListRequest {
        return .init(
            addressListId: self.addressListId,
            filter: self.filter,
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}

extension MailManager.ListRelaysRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListRelaysRequest {
        return .init(
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}

extension MailManager.ListRuleSetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListRuleSetsRequest {
        return .init(
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}

extension MailManager.ListTrafficPoliciesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MailManager.ListTrafficPoliciesRequest {
        return .init(
            nextToken: token,
            pageSize: self.pageSize
        )
    }
}
