//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import SotoCore

/// Error enum for MarketplaceMetering
public struct MarketplaceMeteringErrorType: AWSErrorType {
    enum Code: String {
        case customerNotEntitledException = "CustomerNotEntitledException"
        case disabledApiException = "DisabledApiException"
        case duplicateRequestException = "DuplicateRequestException"
        case expiredTokenException = "ExpiredTokenException"
        case internalServiceErrorException = "InternalServiceErrorException"
        case invalidCustomerIdentifierException = "InvalidCustomerIdentifierException"
        case invalidEndpointRegionException = "InvalidEndpointRegionException"
        case invalidProductCodeException = "InvalidProductCodeException"
        case invalidPublicKeyVersionException = "InvalidPublicKeyVersionException"
        case invalidRegionException = "InvalidRegionException"
        case invalidTagException = "InvalidTagException"
        case invalidTokenException = "InvalidTokenException"
        case invalidUsageAllocationsException = "InvalidUsageAllocationsException"
        case invalidUsageDimensionException = "InvalidUsageDimensionException"
        case platformNotSupportedException = "PlatformNotSupportedException"
        case throttlingException = "ThrottlingException"
        case timestampOutOfBoundsException = "TimestampOutOfBoundsException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MarketplaceMetering
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Exception thrown when the customer does not have a valid subscription for the product.
    public static var customerNotEntitledException: Self { .init(.customerNotEntitledException) }
    /// The API is disabled in the Region.
    public static var disabledApiException: Self { .init(.disabledApiException) }
    /// A metering record has already been emitted by the same EC2 instance, ECS task, or EKS pod for the given {usageDimension, timestamp} with a different usageQuantity.
    public static var duplicateRequestException: Self { .init(.duplicateRequestException) }
    /// The submitted registration token has expired. This can happen if the buyer's browser takes too long to redirect to your page, the buyer has resubmitted the registration token, or your application has held on to the registration token for too long. Your SaaS registration website should redeem this token as soon as it is submitted by the buyer's browser.
    public static var expiredTokenException: Self { .init(.expiredTokenException) }
    /// An internal error has occurred. Retry your request. If the problem persists, post a message with details on the AWS forums.
    public static var internalServiceErrorException: Self { .init(.internalServiceErrorException) }
    /// You have metered usage for a CustomerIdentifier that does not exist.
    public static var invalidCustomerIdentifierException: Self { .init(.invalidCustomerIdentifierException) }
    /// The endpoint being called is in a AWS Region different from your EC2 instance, ECS task, or EKS pod. The Region of the Metering Service endpoint and the AWS Region of the resource must match.
    public static var invalidEndpointRegionException: Self { .init(.invalidEndpointRegionException) }
    /// The product code passed does not match the product code used for publishing the product.
    public static var invalidProductCodeException: Self { .init(.invalidProductCodeException) }
    /// Public Key version is invalid.
    public static var invalidPublicKeyVersionException: Self { .init(.invalidPublicKeyVersionException) }
    /// RegisterUsage must be called in the same AWS Region the ECS task was launched in. This prevents a container from hardcoding a Region (e.g. withRegion(“us-east-1”) when calling RegisterUsage.
    public static var invalidRegionException: Self { .init(.invalidRegionException) }
    /// The tag is invalid, or the number of tags is greater than 5.
    public static var invalidTagException: Self { .init(.invalidTagException) }
    /// Registration token is invalid.
    public static var invalidTokenException: Self { .init(.invalidTokenException) }
    /// The usage allocation objects are invalid, or the number of allocations is greater than 500 for a single usage record.
    public static var invalidUsageAllocationsException: Self { .init(.invalidUsageAllocationsException) }
    /// The usage dimension does not match one of the UsageDimensions associated with products.
    public static var invalidUsageDimensionException: Self { .init(.invalidUsageDimensionException) }
    /// AWS Marketplace does not support metering usage from the underlying platform. Currently, Amazon ECS, Amazon EKS, and AWS Fargate are supported.
    public static var platformNotSupportedException: Self { .init(.platformNotSupportedException) }
    /// The calls to the API are throttled.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The timestamp value passed in the meterUsage() is out of allowed range.
    public static var timestampOutOfBoundsException: Self { .init(.timestampOutOfBoundsException) }
}

extension MarketplaceMeteringErrorType: Equatable {
    public static func == (lhs: MarketplaceMeteringErrorType, rhs: MarketplaceMeteringErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MarketplaceMeteringErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
