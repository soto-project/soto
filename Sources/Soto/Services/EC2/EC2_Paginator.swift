//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension EC2 {
    ///  Describes the attributes of the specified Elastic IP addresses. For requirements, see Using reverse DNS for email applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeAddressesAttributePaginator<Result>(
        _ input: DescribeAddressesAttributeRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeAddressesAttributeResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeAddressesAttribute,
            inputKey: \DescribeAddressesAttributeRequest.nextToken,
            outputKey: \DescribeAddressesAttributeResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeAddressesAttributePaginator(
        _ input: DescribeAddressesAttributeRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeAddressesAttributeResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeAddressesAttribute,
            inputKey: \DescribeAddressesAttributeRequest.nextToken,
            outputKey: \DescribeAddressesAttributeResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the IP address ranges that were specified in calls to ProvisionByoipCidr. To describe the address pools that were created when you provisioned the address ranges, use DescribePublicIpv4Pools or DescribeIpv6Pools.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeByoipCidrsPaginator<Result>(
        _ input: DescribeByoipCidrsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeByoipCidrsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeByoipCidrs,
            inputKey: \DescribeByoipCidrsRequest.nextToken,
            outputKey: \DescribeByoipCidrsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeByoipCidrsPaginator(
        _ input: DescribeByoipCidrsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeByoipCidrsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeByoipCidrs,
            inputKey: \DescribeByoipCidrsRequest.nextToken,
            outputKey: \DescribeByoipCidrsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your Capacity Reservations. The results describe only the Capacity Reservations in the Region that you're currently using.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeCapacityReservationsPaginator<Result>(
        _ input: DescribeCapacityReservationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeCapacityReservationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeCapacityReservations,
            inputKey: \DescribeCapacityReservationsRequest.nextToken,
            outputKey: \DescribeCapacityReservationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeCapacityReservationsPaginator(
        _ input: DescribeCapacityReservationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeCapacityReservationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeCapacityReservations,
            inputKey: \DescribeCapacityReservationsRequest.nextToken,
            outputKey: \DescribeCapacityReservationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your carrier gateways.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeCarrierGatewaysPaginator<Result>(
        _ input: DescribeCarrierGatewaysRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeCarrierGatewaysResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeCarrierGateways,
            inputKey: \DescribeCarrierGatewaysRequest.nextToken,
            outputKey: \DescribeCarrierGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeCarrierGatewaysPaginator(
        _ input: DescribeCarrierGatewaysRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeCarrierGatewaysResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeCarrierGateways,
            inputKey: \DescribeCarrierGatewaysRequest.nextToken,
            outputKey: \DescribeCarrierGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your linked EC2-Classic instances. This request only returns information about EC2-Classic instances linked to a VPC through ClassicLink. You cannot use this request to return information about other instances.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClassicLinkInstancesPaginator<Result>(
        _ input: DescribeClassicLinkInstancesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeClassicLinkInstancesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClassicLinkInstances,
            inputKey: \DescribeClassicLinkInstancesRequest.nextToken,
            outputKey: \DescribeClassicLinkInstancesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClassicLinkInstancesPaginator(
        _ input: DescribeClassicLinkInstancesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeClassicLinkInstancesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClassicLinkInstances,
            inputKey: \DescribeClassicLinkInstancesRequest.nextToken,
            outputKey: \DescribeClassicLinkInstancesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the authorization rules for a specified Client VPN endpoint.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClientVpnAuthorizationRulesPaginator<Result>(
        _ input: DescribeClientVpnAuthorizationRulesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeClientVpnAuthorizationRulesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClientVpnAuthorizationRules,
            inputKey: \DescribeClientVpnAuthorizationRulesRequest.nextToken,
            outputKey: \DescribeClientVpnAuthorizationRulesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClientVpnAuthorizationRulesPaginator(
        _ input: DescribeClientVpnAuthorizationRulesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeClientVpnAuthorizationRulesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClientVpnAuthorizationRules,
            inputKey: \DescribeClientVpnAuthorizationRulesRequest.nextToken,
            outputKey: \DescribeClientVpnAuthorizationRulesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes active client connections and connections that have been terminated within the last 60 minutes for the specified Client VPN endpoint.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClientVpnConnectionsPaginator<Result>(
        _ input: DescribeClientVpnConnectionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeClientVpnConnectionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClientVpnConnections,
            inputKey: \DescribeClientVpnConnectionsRequest.nextToken,
            outputKey: \DescribeClientVpnConnectionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClientVpnConnectionsPaginator(
        _ input: DescribeClientVpnConnectionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeClientVpnConnectionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClientVpnConnections,
            inputKey: \DescribeClientVpnConnectionsRequest.nextToken,
            outputKey: \DescribeClientVpnConnectionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more Client VPN endpoints in the account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClientVpnEndpointsPaginator<Result>(
        _ input: DescribeClientVpnEndpointsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeClientVpnEndpointsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClientVpnEndpoints,
            inputKey: \DescribeClientVpnEndpointsRequest.nextToken,
            outputKey: \DescribeClientVpnEndpointsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClientVpnEndpointsPaginator(
        _ input: DescribeClientVpnEndpointsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeClientVpnEndpointsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClientVpnEndpoints,
            inputKey: \DescribeClientVpnEndpointsRequest.nextToken,
            outputKey: \DescribeClientVpnEndpointsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the routes for the specified Client VPN endpoint.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClientVpnRoutesPaginator<Result>(
        _ input: DescribeClientVpnRoutesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeClientVpnRoutesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClientVpnRoutes,
            inputKey: \DescribeClientVpnRoutesRequest.nextToken,
            outputKey: \DescribeClientVpnRoutesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClientVpnRoutesPaginator(
        _ input: DescribeClientVpnRoutesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeClientVpnRoutesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClientVpnRoutes,
            inputKey: \DescribeClientVpnRoutesRequest.nextToken,
            outputKey: \DescribeClientVpnRoutesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the target networks associated with the specified Client VPN endpoint.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClientVpnTargetNetworksPaginator<Result>(
        _ input: DescribeClientVpnTargetNetworksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeClientVpnTargetNetworksResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClientVpnTargetNetworks,
            inputKey: \DescribeClientVpnTargetNetworksRequest.nextToken,
            outputKey: \DescribeClientVpnTargetNetworksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClientVpnTargetNetworksPaginator(
        _ input: DescribeClientVpnTargetNetworksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeClientVpnTargetNetworksResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClientVpnTargetNetworks,
            inputKey: \DescribeClientVpnTargetNetworksRequest.nextToken,
            outputKey: \DescribeClientVpnTargetNetworksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified customer-owned address pools or all of your customer-owned address pools.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeCoipPoolsPaginator<Result>(
        _ input: DescribeCoipPoolsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeCoipPoolsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeCoipPools,
            inputKey: \DescribeCoipPoolsRequest.nextToken,
            outputKey: \DescribeCoipPoolsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeCoipPoolsPaginator(
        _ input: DescribeCoipPoolsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeCoipPoolsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeCoipPools,
            inputKey: \DescribeCoipPoolsRequest.nextToken,
            outputKey: \DescribeCoipPoolsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your DHCP options sets. For more information, see DHCP Options Sets in the Amazon Virtual Private Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDhcpOptionsPaginator<Result>(
        _ input: DescribeDhcpOptionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeDhcpOptionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDhcpOptions,
            inputKey: \DescribeDhcpOptionsRequest.nextToken,
            outputKey: \DescribeDhcpOptionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDhcpOptionsPaginator(
        _ input: DescribeDhcpOptionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeDhcpOptionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDhcpOptions,
            inputKey: \DescribeDhcpOptionsRequest.nextToken,
            outputKey: \DescribeDhcpOptionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your egress-only internet gateways.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEgressOnlyInternetGatewaysPaginator<Result>(
        _ input: DescribeEgressOnlyInternetGatewaysRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeEgressOnlyInternetGatewaysResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEgressOnlyInternetGateways,
            inputKey: \DescribeEgressOnlyInternetGatewaysRequest.nextToken,
            outputKey: \DescribeEgressOnlyInternetGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEgressOnlyInternetGatewaysPaginator(
        _ input: DescribeEgressOnlyInternetGatewaysRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeEgressOnlyInternetGatewaysResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEgressOnlyInternetGateways,
            inputKey: \DescribeEgressOnlyInternetGatewaysRequest.nextToken,
            outputKey: \DescribeEgressOnlyInternetGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified export image tasks or all of your export image tasks.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeExportImageTasksPaginator<Result>(
        _ input: DescribeExportImageTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeExportImageTasksResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeExportImageTasks,
            inputKey: \DescribeExportImageTasksRequest.nextToken,
            outputKey: \DescribeExportImageTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeExportImageTasksPaginator(
        _ input: DescribeExportImageTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeExportImageTasksResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeExportImageTasks,
            inputKey: \DescribeExportImageTasksRequest.nextToken,
            outputKey: \DescribeExportImageTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the state of fast snapshot restores for your snapshots.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeFastSnapshotRestoresPaginator<Result>(
        _ input: DescribeFastSnapshotRestoresRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeFastSnapshotRestoresResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeFastSnapshotRestores,
            inputKey: \DescribeFastSnapshotRestoresRequest.nextToken,
            outputKey: \DescribeFastSnapshotRestoresResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeFastSnapshotRestoresPaginator(
        _ input: DescribeFastSnapshotRestoresRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeFastSnapshotRestoresResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeFastSnapshotRestores,
            inputKey: \DescribeFastSnapshotRestoresRequest.nextToken,
            outputKey: \DescribeFastSnapshotRestoresResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified EC2 Fleets or all of your EC2 Fleets. For more information, see Monitoring your EC2 Fleet in the Amazon EC2 User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeFleetsPaginator<Result>(
        _ input: DescribeFleetsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeFleetsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeFleets,
            inputKey: \DescribeFleetsRequest.nextToken,
            outputKey: \DescribeFleetsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeFleetsPaginator(
        _ input: DescribeFleetsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeFleetsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeFleets,
            inputKey: \DescribeFleetsRequest.nextToken,
            outputKey: \DescribeFleetsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more flow logs. To view the information in your flow logs (the log streams for the network interfaces), you must use the CloudWatch Logs console or the CloudWatch Logs API.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeFlowLogsPaginator<Result>(
        _ input: DescribeFlowLogsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeFlowLogsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeFlowLogs,
            inputKey: \DescribeFlowLogsRequest.nextToken,
            outputKey: \DescribeFlowLogsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeFlowLogsPaginator(
        _ input: DescribeFlowLogsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeFlowLogsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeFlowLogs,
            inputKey: \DescribeFlowLogsRequest.nextToken,
            outputKey: \DescribeFlowLogsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the Amazon FPGA Images (AFIs) available to you. These include public AFIs, private AFIs that you own, and AFIs owned by other AWS accounts for which you have load permissions.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeFpgaImagesPaginator<Result>(
        _ input: DescribeFpgaImagesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeFpgaImagesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeFpgaImages,
            inputKey: \DescribeFpgaImagesRequest.nextToken,
            outputKey: \DescribeFpgaImagesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeFpgaImagesPaginator(
        _ input: DescribeFpgaImagesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeFpgaImagesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeFpgaImages,
            inputKey: \DescribeFpgaImagesRequest.nextToken,
            outputKey: \DescribeFpgaImagesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the Dedicated Host reservations that are available to purchase. The results describe all of the Dedicated Host reservation offerings, including offerings that might not match the instance family and Region of your Dedicated Hosts. When purchasing an offering, ensure that the instance family and Region of the offering matches that of the Dedicated Hosts with which it is to be associated. For more information about supported instance types, see Dedicated Hosts in the Amazon EC2 User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeHostReservationOfferingsPaginator<Result>(
        _ input: DescribeHostReservationOfferingsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeHostReservationOfferingsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeHostReservationOfferings,
            inputKey: \DescribeHostReservationOfferingsRequest.nextToken,
            outputKey: \DescribeHostReservationOfferingsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeHostReservationOfferingsPaginator(
        _ input: DescribeHostReservationOfferingsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeHostReservationOfferingsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeHostReservationOfferings,
            inputKey: \DescribeHostReservationOfferingsRequest.nextToken,
            outputKey: \DescribeHostReservationOfferingsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes reservations that are associated with Dedicated Hosts in your account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeHostReservationsPaginator<Result>(
        _ input: DescribeHostReservationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeHostReservationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeHostReservations,
            inputKey: \DescribeHostReservationsRequest.nextToken,
            outputKey: \DescribeHostReservationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeHostReservationsPaginator(
        _ input: DescribeHostReservationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeHostReservationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeHostReservations,
            inputKey: \DescribeHostReservationsRequest.nextToken,
            outputKey: \DescribeHostReservationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified Dedicated Hosts or all your Dedicated Hosts. The results describe only the Dedicated Hosts in the Region you're currently using. All listed instances consume capacity on your Dedicated Host. Dedicated Hosts that have recently been released are listed with the state released.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeHostsPaginator<Result>(
        _ input: DescribeHostsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeHostsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeHosts,
            inputKey: \DescribeHostsRequest.nextToken,
            outputKey: \DescribeHostsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeHostsPaginator(
        _ input: DescribeHostsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeHostsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeHosts,
            inputKey: \DescribeHostsRequest.nextToken,
            outputKey: \DescribeHostsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes your IAM instance profile associations.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeIamInstanceProfileAssociationsPaginator<Result>(
        _ input: DescribeIamInstanceProfileAssociationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeIamInstanceProfileAssociationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeIamInstanceProfileAssociations,
            inputKey: \DescribeIamInstanceProfileAssociationsRequest.nextToken,
            outputKey: \DescribeIamInstanceProfileAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeIamInstanceProfileAssociationsPaginator(
        _ input: DescribeIamInstanceProfileAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeIamInstanceProfileAssociationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeIamInstanceProfileAssociations,
            inputKey: \DescribeIamInstanceProfileAssociationsRequest.nextToken,
            outputKey: \DescribeIamInstanceProfileAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Displays details about an import virtual machine or import snapshot tasks that are already created.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeImportImageTasksPaginator<Result>(
        _ input: DescribeImportImageTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeImportImageTasksResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeImportImageTasks,
            inputKey: \DescribeImportImageTasksRequest.nextToken,
            outputKey: \DescribeImportImageTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeImportImageTasksPaginator(
        _ input: DescribeImportImageTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeImportImageTasksResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeImportImageTasks,
            inputKey: \DescribeImportImageTasksRequest.nextToken,
            outputKey: \DescribeImportImageTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes your import snapshot tasks.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeImportSnapshotTasksPaginator<Result>(
        _ input: DescribeImportSnapshotTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeImportSnapshotTasksResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeImportSnapshotTasks,
            inputKey: \DescribeImportSnapshotTasksRequest.nextToken,
            outputKey: \DescribeImportSnapshotTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeImportSnapshotTasksPaginator(
        _ input: DescribeImportSnapshotTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeImportSnapshotTasksResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeImportSnapshotTasks,
            inputKey: \DescribeImportSnapshotTasksRequest.nextToken,
            outputKey: \DescribeImportSnapshotTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the credit option for CPU usage of the specified burstable performance instances. The credit options are standard and unlimited. If you do not specify an instance ID, Amazon EC2 returns burstable performance instances with the unlimited credit option, as well as instances that were previously configured as T2, T3, and T3a with the unlimited credit option. For example, if you resize a T2 instance, while it is configured as unlimited, to an M4 instance, Amazon EC2 returns the M4 instance. If you specify one or more instance IDs, Amazon EC2 returns the credit option (standard or unlimited) of those instances. If you specify an instance ID that is not valid, such as an instance that is not a burstable performance instance, an error is returned. Recently terminated instances might appear in the returned results. This interval is usually less than one hour. If an Availability Zone is experiencing a service disruption and you specify instance IDs in the affected zone, or do not specify any instance IDs at all, the call fails. If you specify only instance IDs in an unaffected zone, the call works normally. For more information, see Burstable performance instances in the Amazon EC2 User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstanceCreditSpecificationsPaginator<Result>(
        _ input: DescribeInstanceCreditSpecificationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInstanceCreditSpecificationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstanceCreditSpecifications,
            inputKey: \DescribeInstanceCreditSpecificationsRequest.nextToken,
            outputKey: \DescribeInstanceCreditSpecificationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstanceCreditSpecificationsPaginator(
        _ input: DescribeInstanceCreditSpecificationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInstanceCreditSpecificationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstanceCreditSpecifications,
            inputKey: \DescribeInstanceCreditSpecificationsRequest.nextToken,
            outputKey: \DescribeInstanceCreditSpecificationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified event windows or all event windows. If you specify event window IDs, the output includes information for only the specified event windows. If you specify filters, the output includes information for only those event windows that meet the filter criteria. If you do not specify event windows IDs or filters, the output includes information for all event windows, which can affect performance. We recommend that you use pagination to ensure that the operation returns quickly and successfully.  For more information, see Define event windows for scheduled events in the Amazon EC2 User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstanceEventWindowsPaginator<Result>(
        _ input: DescribeInstanceEventWindowsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInstanceEventWindowsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstanceEventWindows,
            inputKey: \DescribeInstanceEventWindowsRequest.nextToken,
            outputKey: \DescribeInstanceEventWindowsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstanceEventWindowsPaginator(
        _ input: DescribeInstanceEventWindowsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInstanceEventWindowsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstanceEventWindows,
            inputKey: \DescribeInstanceEventWindowsRequest.nextToken,
            outputKey: \DescribeInstanceEventWindowsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the status of the specified instances or all of your instances. By default, only running instances are described, unless you specifically indicate to return the status of all instances. Instance status includes the following components:    Status checks - Amazon EC2 performs status checks on running EC2 instances to identify hardware and software issues. For more information, see Status checks for your instances and Troubleshooting instances with failed status checks in the Amazon EC2 User Guide.    Scheduled events - Amazon EC2 can schedule events (such as reboot, stop, or terminate) for your instances related to hardware issues, software updates, or system maintenance. For more information, see Scheduled events for your instances in the Amazon EC2 User Guide.    Instance state - You can manage your instances from the moment you launch them through their termination. For more information, see Instance lifecycle in the Amazon EC2 User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstanceStatusPaginator<Result>(
        _ input: DescribeInstanceStatusRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInstanceStatusResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstanceStatus,
            inputKey: \DescribeInstanceStatusRequest.nextToken,
            outputKey: \DescribeInstanceStatusResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstanceStatusPaginator(
        _ input: DescribeInstanceStatusRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInstanceStatusResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstanceStatus,
            inputKey: \DescribeInstanceStatusRequest.nextToken,
            outputKey: \DescribeInstanceStatusResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of all instance types offered. The results can be filtered by location (Region or Availability Zone). If no location is specified, the instance types offered in the current Region are returned.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstanceTypeOfferingsPaginator<Result>(
        _ input: DescribeInstanceTypeOfferingsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInstanceTypeOfferingsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstanceTypeOfferings,
            inputKey: \DescribeInstanceTypeOfferingsRequest.nextToken,
            outputKey: \DescribeInstanceTypeOfferingsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstanceTypeOfferingsPaginator(
        _ input: DescribeInstanceTypeOfferingsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInstanceTypeOfferingsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstanceTypeOfferings,
            inputKey: \DescribeInstanceTypeOfferingsRequest.nextToken,
            outputKey: \DescribeInstanceTypeOfferingsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the details of the instance types that are offered in a location. The results can be filtered by the attributes of the instance types.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstanceTypesPaginator<Result>(
        _ input: DescribeInstanceTypesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInstanceTypesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstanceTypes,
            inputKey: \DescribeInstanceTypesRequest.nextToken,
            outputKey: \DescribeInstanceTypesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstanceTypesPaginator(
        _ input: DescribeInstanceTypesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInstanceTypesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstanceTypes,
            inputKey: \DescribeInstanceTypesRequest.nextToken,
            outputKey: \DescribeInstanceTypesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified instances or all instances. If you specify instance IDs, the output includes information for only the specified instances. If you specify filters, the output includes information for only those instances that meet the filter criteria. If you do not specify instance IDs or filters, the output includes information for all instances, which can affect performance. We recommend that you use pagination to ensure that the operation returns quickly and successfully. If you specify an instance ID that is not valid, an error is returned. If you specify an instance that you do not own, it is not included in the output. Recently terminated instances might appear in the returned results. This interval is usually less than one hour. If you describe instances in the rare case where an Availability Zone is experiencing a service disruption and you specify instance IDs that are in the affected zone, or do not specify any instance IDs at all, the call fails. If you describe instances and specify only instance IDs that are in an unaffected zone, the call works normally.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstancesPaginator<Result>(
        _ input: DescribeInstancesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInstancesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstances,
            inputKey: \DescribeInstancesRequest.nextToken,
            outputKey: \DescribeInstancesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstancesPaginator(
        _ input: DescribeInstancesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInstancesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstances,
            inputKey: \DescribeInstancesRequest.nextToken,
            outputKey: \DescribeInstancesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your internet gateways.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInternetGatewaysPaginator<Result>(
        _ input: DescribeInternetGatewaysRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInternetGatewaysResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInternetGateways,
            inputKey: \DescribeInternetGatewaysRequest.nextToken,
            outputKey: \DescribeInternetGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInternetGatewaysPaginator(
        _ input: DescribeInternetGatewaysRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInternetGatewaysResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInternetGateways,
            inputKey: \DescribeInternetGatewaysRequest.nextToken,
            outputKey: \DescribeInternetGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes your IPv6 address pools.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeIpv6PoolsPaginator<Result>(
        _ input: DescribeIpv6PoolsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeIpv6PoolsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeIpv6Pools,
            inputKey: \DescribeIpv6PoolsRequest.nextToken,
            outputKey: \DescribeIpv6PoolsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeIpv6PoolsPaginator(
        _ input: DescribeIpv6PoolsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeIpv6PoolsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeIpv6Pools,
            inputKey: \DescribeIpv6PoolsRequest.nextToken,
            outputKey: \DescribeIpv6PoolsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more versions of a specified launch template. You can describe all versions, individual versions, or a range of versions. You can also describe all the latest versions or all the default versions of all the launch templates in your account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeLaunchTemplateVersionsPaginator<Result>(
        _ input: DescribeLaunchTemplateVersionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeLaunchTemplateVersionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeLaunchTemplateVersions,
            inputKey: \DescribeLaunchTemplateVersionsRequest.nextToken,
            outputKey: \DescribeLaunchTemplateVersionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeLaunchTemplateVersionsPaginator(
        _ input: DescribeLaunchTemplateVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeLaunchTemplateVersionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeLaunchTemplateVersions,
            inputKey: \DescribeLaunchTemplateVersionsRequest.nextToken,
            outputKey: \DescribeLaunchTemplateVersionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more launch templates.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeLaunchTemplatesPaginator<Result>(
        _ input: DescribeLaunchTemplatesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeLaunchTemplatesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeLaunchTemplates,
            inputKey: \DescribeLaunchTemplatesRequest.nextToken,
            outputKey: \DescribeLaunchTemplatesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeLaunchTemplatesPaginator(
        _ input: DescribeLaunchTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeLaunchTemplatesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeLaunchTemplates,
            inputKey: \DescribeLaunchTemplatesRequest.nextToken,
            outputKey: \DescribeLaunchTemplatesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the associations between virtual interface groups and local gateway route tables.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginator<Result>(
        _ input: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeLocalGatewayRouteTableVirtualInterfaceGroupAssociations,
            inputKey: \DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest.nextToken,
            outputKey: \DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginator(
        _ input: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeLocalGatewayRouteTableVirtualInterfaceGroupAssociations,
            inputKey: \DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest.nextToken,
            outputKey: \DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified associations between VPCs and local gateway route tables.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeLocalGatewayRouteTableVpcAssociationsPaginator<Result>(
        _ input: DescribeLocalGatewayRouteTableVpcAssociationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeLocalGatewayRouteTableVpcAssociationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeLocalGatewayRouteTableVpcAssociations,
            inputKey: \DescribeLocalGatewayRouteTableVpcAssociationsRequest.nextToken,
            outputKey: \DescribeLocalGatewayRouteTableVpcAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeLocalGatewayRouteTableVpcAssociationsPaginator(
        _ input: DescribeLocalGatewayRouteTableVpcAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeLocalGatewayRouteTableVpcAssociationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeLocalGatewayRouteTableVpcAssociations,
            inputKey: \DescribeLocalGatewayRouteTableVpcAssociationsRequest.nextToken,
            outputKey: \DescribeLocalGatewayRouteTableVpcAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more local gateway route tables. By default, all local gateway route tables are described. Alternatively, you can filter the results.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeLocalGatewayRouteTablesPaginator<Result>(
        _ input: DescribeLocalGatewayRouteTablesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeLocalGatewayRouteTablesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeLocalGatewayRouteTables,
            inputKey: \DescribeLocalGatewayRouteTablesRequest.nextToken,
            outputKey: \DescribeLocalGatewayRouteTablesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeLocalGatewayRouteTablesPaginator(
        _ input: DescribeLocalGatewayRouteTablesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeLocalGatewayRouteTablesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeLocalGatewayRouteTables,
            inputKey: \DescribeLocalGatewayRouteTablesRequest.nextToken,
            outputKey: \DescribeLocalGatewayRouteTablesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified local gateway virtual interface groups.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeLocalGatewayVirtualInterfaceGroupsPaginator<Result>(
        _ input: DescribeLocalGatewayVirtualInterfaceGroupsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeLocalGatewayVirtualInterfaceGroupsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeLocalGatewayVirtualInterfaceGroups,
            inputKey: \DescribeLocalGatewayVirtualInterfaceGroupsRequest.nextToken,
            outputKey: \DescribeLocalGatewayVirtualInterfaceGroupsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeLocalGatewayVirtualInterfaceGroupsPaginator(
        _ input: DescribeLocalGatewayVirtualInterfaceGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeLocalGatewayVirtualInterfaceGroupsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeLocalGatewayVirtualInterfaceGroups,
            inputKey: \DescribeLocalGatewayVirtualInterfaceGroupsRequest.nextToken,
            outputKey: \DescribeLocalGatewayVirtualInterfaceGroupsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified local gateway virtual interfaces.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeLocalGatewayVirtualInterfacesPaginator<Result>(
        _ input: DescribeLocalGatewayVirtualInterfacesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeLocalGatewayVirtualInterfacesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeLocalGatewayVirtualInterfaces,
            inputKey: \DescribeLocalGatewayVirtualInterfacesRequest.nextToken,
            outputKey: \DescribeLocalGatewayVirtualInterfacesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeLocalGatewayVirtualInterfacesPaginator(
        _ input: DescribeLocalGatewayVirtualInterfacesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeLocalGatewayVirtualInterfacesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeLocalGatewayVirtualInterfaces,
            inputKey: \DescribeLocalGatewayVirtualInterfacesRequest.nextToken,
            outputKey: \DescribeLocalGatewayVirtualInterfacesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more local gateways. By default, all local gateways are described. Alternatively, you can filter the results.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeLocalGatewaysPaginator<Result>(
        _ input: DescribeLocalGatewaysRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeLocalGatewaysResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeLocalGateways,
            inputKey: \DescribeLocalGatewaysRequest.nextToken,
            outputKey: \DescribeLocalGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeLocalGatewaysPaginator(
        _ input: DescribeLocalGatewaysRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeLocalGatewaysResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeLocalGateways,
            inputKey: \DescribeLocalGatewaysRequest.nextToken,
            outputKey: \DescribeLocalGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes your managed prefix lists and any Amazon Web Services-managed prefix lists. To view the entries for your prefix list, use GetManagedPrefixListEntries.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeManagedPrefixListsPaginator<Result>(
        _ input: DescribeManagedPrefixListsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeManagedPrefixListsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeManagedPrefixLists,
            inputKey: \DescribeManagedPrefixListsRequest.nextToken,
            outputKey: \DescribeManagedPrefixListsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeManagedPrefixListsPaginator(
        _ input: DescribeManagedPrefixListsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeManagedPrefixListsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeManagedPrefixLists,
            inputKey: \DescribeManagedPrefixListsRequest.nextToken,
            outputKey: \DescribeManagedPrefixListsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes your Elastic IP addresses that are being moved to the EC2-VPC platform, or that are being restored to the EC2-Classic platform. This request does not return information about any other Elastic IP addresses in your account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeMovingAddressesPaginator<Result>(
        _ input: DescribeMovingAddressesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeMovingAddressesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeMovingAddresses,
            inputKey: \DescribeMovingAddressesRequest.nextToken,
            outputKey: \DescribeMovingAddressesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeMovingAddressesPaginator(
        _ input: DescribeMovingAddressesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeMovingAddressesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeMovingAddresses,
            inputKey: \DescribeMovingAddressesRequest.nextToken,
            outputKey: \DescribeMovingAddressesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your NAT gateways.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeNatGatewaysPaginator<Result>(
        _ input: DescribeNatGatewaysRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeNatGatewaysResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeNatGateways,
            inputKey: \DescribeNatGatewaysRequest.nextToken,
            outputKey: \DescribeNatGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeNatGatewaysPaginator(
        _ input: DescribeNatGatewaysRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeNatGatewaysResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeNatGateways,
            inputKey: \DescribeNatGatewaysRequest.nextToken,
            outputKey: \DescribeNatGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your network ACLs. For more information, see Network ACLs in the Amazon Virtual Private Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeNetworkAclsPaginator<Result>(
        _ input: DescribeNetworkAclsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeNetworkAclsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeNetworkAcls,
            inputKey: \DescribeNetworkAclsRequest.nextToken,
            outputKey: \DescribeNetworkAclsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeNetworkAclsPaginator(
        _ input: DescribeNetworkAclsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeNetworkAclsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeNetworkAcls,
            inputKey: \DescribeNetworkAclsRequest.nextToken,
            outputKey: \DescribeNetworkAclsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your network insights analyses.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeNetworkInsightsAnalysesPaginator<Result>(
        _ input: DescribeNetworkInsightsAnalysesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeNetworkInsightsAnalysesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeNetworkInsightsAnalyses,
            inputKey: \DescribeNetworkInsightsAnalysesRequest.nextToken,
            outputKey: \DescribeNetworkInsightsAnalysesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeNetworkInsightsAnalysesPaginator(
        _ input: DescribeNetworkInsightsAnalysesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeNetworkInsightsAnalysesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeNetworkInsightsAnalyses,
            inputKey: \DescribeNetworkInsightsAnalysesRequest.nextToken,
            outputKey: \DescribeNetworkInsightsAnalysesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your paths.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeNetworkInsightsPathsPaginator<Result>(
        _ input: DescribeNetworkInsightsPathsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeNetworkInsightsPathsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeNetworkInsightsPaths,
            inputKey: \DescribeNetworkInsightsPathsRequest.nextToken,
            outputKey: \DescribeNetworkInsightsPathsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeNetworkInsightsPathsPaginator(
        _ input: DescribeNetworkInsightsPathsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeNetworkInsightsPathsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeNetworkInsightsPaths,
            inputKey: \DescribeNetworkInsightsPathsRequest.nextToken,
            outputKey: \DescribeNetworkInsightsPathsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the permissions for your network interfaces.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeNetworkInterfacePermissionsPaginator<Result>(
        _ input: DescribeNetworkInterfacePermissionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeNetworkInterfacePermissionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeNetworkInterfacePermissions,
            inputKey: \DescribeNetworkInterfacePermissionsRequest.nextToken,
            outputKey: \DescribeNetworkInterfacePermissionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeNetworkInterfacePermissionsPaginator(
        _ input: DescribeNetworkInterfacePermissionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeNetworkInterfacePermissionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeNetworkInterfacePermissions,
            inputKey: \DescribeNetworkInterfacePermissionsRequest.nextToken,
            outputKey: \DescribeNetworkInterfacePermissionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your network interfaces.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeNetworkInterfacesPaginator<Result>(
        _ input: DescribeNetworkInterfacesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeNetworkInterfacesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeNetworkInterfaces,
            inputKey: \DescribeNetworkInterfacesRequest.nextToken,
            outputKey: \DescribeNetworkInterfacesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeNetworkInterfacesPaginator(
        _ input: DescribeNetworkInterfacesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeNetworkInterfacesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeNetworkInterfaces,
            inputKey: \DescribeNetworkInterfacesRequest.nextToken,
            outputKey: \DescribeNetworkInterfacesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes available Amazon Web Services services in a prefix list format, which includes the prefix list name and prefix list ID of the service and the IP address range for the service. We recommend that you use DescribeManagedPrefixLists instead.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describePrefixListsPaginator<Result>(
        _ input: DescribePrefixListsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribePrefixListsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describePrefixLists,
            inputKey: \DescribePrefixListsRequest.nextToken,
            outputKey: \DescribePrefixListsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describePrefixListsPaginator(
        _ input: DescribePrefixListsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribePrefixListsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describePrefixLists,
            inputKey: \DescribePrefixListsRequest.nextToken,
            outputKey: \DescribePrefixListsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the ID format settings for the root user and all IAM roles and IAM users that have explicitly specified a longer ID (17-character ID) preference.  By default, all IAM roles and IAM users default to the same ID settings as the root user, unless they explicitly override the settings. This request is useful for identifying those IAM users and IAM roles that have overridden the default ID settings. The following resource types support longer IDs: bundle | conversion-task | customer-gateway | dhcp-options | elastic-ip-allocation | elastic-ip-association | export-task | flow-log | image | import-task | instance | internet-gateway | network-acl | network-acl-association | network-interface | network-interface-attachment | prefix-list | reservation | route-table | route-table-association | security-group | snapshot | subnet | subnet-cidr-block-association | volume | vpc | vpc-cidr-block-association | vpc-endpoint | vpc-peering-connection | vpn-connection | vpn-gateway.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describePrincipalIdFormatPaginator<Result>(
        _ input: DescribePrincipalIdFormatRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribePrincipalIdFormatResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describePrincipalIdFormat,
            inputKey: \DescribePrincipalIdFormatRequest.nextToken,
            outputKey: \DescribePrincipalIdFormatResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describePrincipalIdFormatPaginator(
        _ input: DescribePrincipalIdFormatRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribePrincipalIdFormatResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describePrincipalIdFormat,
            inputKey: \DescribePrincipalIdFormatRequest.nextToken,
            outputKey: \DescribePrincipalIdFormatResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified IPv4 address pools.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describePublicIpv4PoolsPaginator<Result>(
        _ input: DescribePublicIpv4PoolsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribePublicIpv4PoolsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describePublicIpv4Pools,
            inputKey: \DescribePublicIpv4PoolsRequest.nextToken,
            outputKey: \DescribePublicIpv4PoolsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describePublicIpv4PoolsPaginator(
        _ input: DescribePublicIpv4PoolsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribePublicIpv4PoolsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describePublicIpv4Pools,
            inputKey: \DescribePublicIpv4PoolsRequest.nextToken,
            outputKey: \DescribePublicIpv4PoolsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes a root volume replacement task. For more information, see Replace a root volume in the Amazon Elastic Compute Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeReplaceRootVolumeTasksPaginator<Result>(
        _ input: DescribeReplaceRootVolumeTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeReplaceRootVolumeTasksResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeReplaceRootVolumeTasks,
            inputKey: \DescribeReplaceRootVolumeTasksRequest.nextToken,
            outputKey: \DescribeReplaceRootVolumeTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeReplaceRootVolumeTasksPaginator(
        _ input: DescribeReplaceRootVolumeTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeReplaceRootVolumeTasksResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeReplaceRootVolumeTasks,
            inputKey: \DescribeReplaceRootVolumeTasksRequest.nextToken,
            outputKey: \DescribeReplaceRootVolumeTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the modifications made to your Reserved Instances. If no parameter is specified, information about all your Reserved Instances modification requests is returned. If a modification ID is specified, only information about the specific modification is returned. For more information, see Modifying Reserved Instances in the Amazon EC2 User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeReservedInstancesModificationsPaginator<Result>(
        _ input: DescribeReservedInstancesModificationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeReservedInstancesModificationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeReservedInstancesModifications,
            inputKey: \DescribeReservedInstancesModificationsRequest.nextToken,
            outputKey: \DescribeReservedInstancesModificationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeReservedInstancesModificationsPaginator(
        _ input: DescribeReservedInstancesModificationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeReservedInstancesModificationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeReservedInstancesModifications,
            inputKey: \DescribeReservedInstancesModificationsRequest.nextToken,
            outputKey: \DescribeReservedInstancesModificationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes Reserved Instance offerings that are available for purchase. With Reserved Instances, you purchase the right to launch instances for a period of time. During that time period, you do not receive insufficient capacity errors, and you pay a lower usage rate than the rate charged for On-Demand instances for the actual time used. If you have listed your own Reserved Instances for sale in the Reserved Instance Marketplace, they will be excluded from these results. This is to ensure that you do not purchase your own Reserved Instances. For more information, see Reserved Instance Marketplace in the Amazon EC2 User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeReservedInstancesOfferingsPaginator<Result>(
        _ input: DescribeReservedInstancesOfferingsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeReservedInstancesOfferingsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeReservedInstancesOfferings,
            inputKey: \DescribeReservedInstancesOfferingsRequest.nextToken,
            outputKey: \DescribeReservedInstancesOfferingsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeReservedInstancesOfferingsPaginator(
        _ input: DescribeReservedInstancesOfferingsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeReservedInstancesOfferingsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeReservedInstancesOfferings,
            inputKey: \DescribeReservedInstancesOfferingsRequest.nextToken,
            outputKey: \DescribeReservedInstancesOfferingsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your route tables. Each subnet in your VPC must be associated with a route table. If a subnet is not explicitly associated with any route table, it is implicitly associated with the main route table. This command does not return the subnet ID for implicit associations. For more information, see Route Tables in the Amazon Virtual Private Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeRouteTablesPaginator<Result>(
        _ input: DescribeRouteTablesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeRouteTablesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeRouteTables,
            inputKey: \DescribeRouteTablesRequest.nextToken,
            outputKey: \DescribeRouteTablesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeRouteTablesPaginator(
        _ input: DescribeRouteTablesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeRouteTablesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeRouteTables,
            inputKey: \DescribeRouteTablesRequest.nextToken,
            outputKey: \DescribeRouteTablesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Finds available schedules that meet the specified criteria. You can search for an available schedule no more than 3 months in advance. You must meet the minimum required duration of 1,200 hours per year. For example, the minimum daily schedule is 4 hours, the minimum weekly schedule is 24 hours, and the minimum monthly schedule is 100 hours. After you find a schedule that meets your needs, call PurchaseScheduledInstances to purchase Scheduled Instances with that schedule.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeScheduledInstanceAvailabilityPaginator<Result>(
        _ input: DescribeScheduledInstanceAvailabilityRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeScheduledInstanceAvailabilityResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeScheduledInstanceAvailability,
            inputKey: \DescribeScheduledInstanceAvailabilityRequest.nextToken,
            outputKey: \DescribeScheduledInstanceAvailabilityResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeScheduledInstanceAvailabilityPaginator(
        _ input: DescribeScheduledInstanceAvailabilityRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeScheduledInstanceAvailabilityResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeScheduledInstanceAvailability,
            inputKey: \DescribeScheduledInstanceAvailabilityRequest.nextToken,
            outputKey: \DescribeScheduledInstanceAvailabilityResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified Scheduled Instances or all your Scheduled Instances.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeScheduledInstancesPaginator<Result>(
        _ input: DescribeScheduledInstancesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeScheduledInstancesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeScheduledInstances,
            inputKey: \DescribeScheduledInstancesRequest.nextToken,
            outputKey: \DescribeScheduledInstancesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeScheduledInstancesPaginator(
        _ input: DescribeScheduledInstancesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeScheduledInstancesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeScheduledInstances,
            inputKey: \DescribeScheduledInstancesRequest.nextToken,
            outputKey: \DescribeScheduledInstancesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your security group rules.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSecurityGroupRulesPaginator<Result>(
        _ input: DescribeSecurityGroupRulesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeSecurityGroupRulesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSecurityGroupRules,
            inputKey: \DescribeSecurityGroupRulesRequest.nextToken,
            outputKey: \DescribeSecurityGroupRulesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSecurityGroupRulesPaginator(
        _ input: DescribeSecurityGroupRulesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeSecurityGroupRulesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSecurityGroupRules,
            inputKey: \DescribeSecurityGroupRulesRequest.nextToken,
            outputKey: \DescribeSecurityGroupRulesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified security groups or all of your security groups. A security group is for use with instances either in the EC2-Classic platform or in a specific VPC. For more information, see Amazon EC2 Security Groups in the Amazon Elastic Compute Cloud User Guide and Security Groups for Your VPC in the Amazon Virtual Private Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSecurityGroupsPaginator<Result>(
        _ input: DescribeSecurityGroupsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeSecurityGroupsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSecurityGroups,
            inputKey: \DescribeSecurityGroupsRequest.nextToken,
            outputKey: \DescribeSecurityGroupsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSecurityGroupsPaginator(
        _ input: DescribeSecurityGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeSecurityGroupsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSecurityGroups,
            inputKey: \DescribeSecurityGroupsRequest.nextToken,
            outputKey: \DescribeSecurityGroupsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified EBS snapshots available to you or all of the EBS snapshots available to you. The snapshots available to you include public snapshots, private snapshots that you own, and private snapshots owned by other AWS accounts for which you have explicit create volume permissions. The create volume permissions fall into the following categories:    public: The owner of the snapshot granted create volume permissions for the snapshot to the all group. All AWS accounts have create volume permissions for these snapshots.    explicit: The owner of the snapshot granted create volume permissions to a specific AWS account.    implicit: An AWS account has implicit create volume permissions for all snapshots it owns.   The list of snapshots returned can be filtered by specifying snapshot IDs, snapshot owners, or AWS accounts with create volume permissions. If no options are specified, Amazon EC2 returns all snapshots for which you have create volume permissions. If you specify one or more snapshot IDs, only snapshots that have the specified IDs are returned. If you specify an invalid snapshot ID, an error is returned. If you specify a snapshot ID for which you do not have access, it is not included in the returned results. If you specify one or more snapshot owners using the OwnerIds option, only snapshots from the specified owners and for which you have access are returned. The results can include the AWS account IDs of the specified owners, amazon for snapshots owned by Amazon, or self for snapshots that you own. If you specify a list of restorable users, only snapshots with create snapshot permissions for those users are returned. You can specify AWS account IDs (if you own the snapshots), self for snapshots for which you own or have explicit permissions, or all for public snapshots. If you are describing a long list of snapshots, we recommend that you paginate the output to make the list more manageable. The MaxResults parameter sets the maximum number of results returned in a single page. If the list of results exceeds your MaxResults value, then that number of results is returned along with a NextToken value that can be passed to a subsequent DescribeSnapshots request to retrieve the remaining results. To get the state of fast snapshot restores for a snapshot, use DescribeFastSnapshotRestores. For more information about EBS snapshots, see Amazon EBS snapshots in the Amazon Elastic Compute Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSnapshotsPaginator<Result>(
        _ input: DescribeSnapshotsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeSnapshotsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSnapshots,
            inputKey: \DescribeSnapshotsRequest.nextToken,
            outputKey: \DescribeSnapshotsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSnapshotsPaginator(
        _ input: DescribeSnapshotsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeSnapshotsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSnapshots,
            inputKey: \DescribeSnapshotsRequest.nextToken,
            outputKey: \DescribeSnapshotsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes your Spot Fleet requests. Spot Fleet requests are deleted 48 hours after they are canceled and their instances are terminated.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSpotFleetRequestsPaginator<Result>(
        _ input: DescribeSpotFleetRequestsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeSpotFleetRequestsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSpotFleetRequests,
            inputKey: \DescribeSpotFleetRequestsRequest.nextToken,
            outputKey: \DescribeSpotFleetRequestsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSpotFleetRequestsPaginator(
        _ input: DescribeSpotFleetRequestsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeSpotFleetRequestsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSpotFleetRequests,
            inputKey: \DescribeSpotFleetRequestsRequest.nextToken,
            outputKey: \DescribeSpotFleetRequestsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified Spot Instance requests. You can use DescribeSpotInstanceRequests to find a running Spot Instance by examining the response. If the status of the Spot Instance is fulfilled, the instance ID appears in the response and contains the identifier of the instance. Alternatively, you can use DescribeInstances with a filter to look for instances where the instance lifecycle is spot. We recommend that you set MaxResults to a value between 5 and 1000 to limit the number of results returned. This paginates the output, which makes the list more manageable and returns the results faster. If the list of results exceeds your MaxResults value, then that number of results is returned along with a NextToken value that can be passed to a subsequent DescribeSpotInstanceRequests request to retrieve the remaining results. Spot Instance requests are deleted four hours after they are canceled and their instances are terminated.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSpotInstanceRequestsPaginator<Result>(
        _ input: DescribeSpotInstanceRequestsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeSpotInstanceRequestsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSpotInstanceRequests,
            inputKey: \DescribeSpotInstanceRequestsRequest.nextToken,
            outputKey: \DescribeSpotInstanceRequestsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSpotInstanceRequestsPaginator(
        _ input: DescribeSpotInstanceRequestsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeSpotInstanceRequestsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSpotInstanceRequests,
            inputKey: \DescribeSpotInstanceRequestsRequest.nextToken,
            outputKey: \DescribeSpotInstanceRequestsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the Spot price history. For more information, see Spot Instance pricing history in the Amazon EC2 User Guide for Linux Instances. When you specify a start and end time, the operation returns the prices of the instance types within that time range. It also returns the last price change before the start time, which is the effective price as of the start time.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSpotPriceHistoryPaginator<Result>(
        _ input: DescribeSpotPriceHistoryRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeSpotPriceHistoryResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSpotPriceHistory,
            inputKey: \DescribeSpotPriceHistoryRequest.nextToken,
            outputKey: \DescribeSpotPriceHistoryResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSpotPriceHistoryPaginator(
        _ input: DescribeSpotPriceHistoryRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeSpotPriceHistoryResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSpotPriceHistory,
            inputKey: \DescribeSpotPriceHistoryRequest.nextToken,
            outputKey: \DescribeSpotPriceHistoryResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  [VPC only] Describes the stale security group rules for security groups in a specified VPC. Rules are stale when they reference a deleted security group in a peer VPC, or a security group in a peer VPC for which the VPC peering connection has been deleted.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeStaleSecurityGroupsPaginator<Result>(
        _ input: DescribeStaleSecurityGroupsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeStaleSecurityGroupsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeStaleSecurityGroups,
            inputKey: \DescribeStaleSecurityGroupsRequest.nextToken,
            outputKey: \DescribeStaleSecurityGroupsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeStaleSecurityGroupsPaginator(
        _ input: DescribeStaleSecurityGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeStaleSecurityGroupsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeStaleSecurityGroups,
            inputKey: \DescribeStaleSecurityGroupsRequest.nextToken,
            outputKey: \DescribeStaleSecurityGroupsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the progress of the AMI store tasks. You can describe the store tasks for specified AMIs. If you don't specify the AMIs, you get a paginated list of store tasks from the last 31 days. For each AMI task, the response indicates if the task is InProgress, Completed, or Failed. For tasks InProgress, the response shows the estimated progress as a percentage. Tasks are listed in reverse chronological order. Currently, only tasks from the past 31 days can be viewed. To use this API, you must have the required permissions. For more information, see Permissions for storing and restoring AMIs using S3 in the Amazon Elastic Compute Cloud User Guide. For more information, see Store and restore an AMI using S3 in the Amazon Elastic Compute Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeStoreImageTasksPaginator<Result>(
        _ input: DescribeStoreImageTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeStoreImageTasksResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeStoreImageTasks,
            inputKey: \DescribeStoreImageTasksRequest.nextToken,
            outputKey: \DescribeStoreImageTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeStoreImageTasksPaginator(
        _ input: DescribeStoreImageTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeStoreImageTasksResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeStoreImageTasks,
            inputKey: \DescribeStoreImageTasksRequest.nextToken,
            outputKey: \DescribeStoreImageTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your subnets. For more information, see Your VPC and Subnets in the Amazon Virtual Private Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSubnetsPaginator<Result>(
        _ input: DescribeSubnetsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeSubnetsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSubnets,
            inputKey: \DescribeSubnetsRequest.nextToken,
            outputKey: \DescribeSubnetsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSubnetsPaginator(
        _ input: DescribeSubnetsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeSubnetsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSubnets,
            inputKey: \DescribeSubnetsRequest.nextToken,
            outputKey: \DescribeSubnetsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified tags for your EC2 resources. For more information about tags, see Tagging Your Resources in the Amazon Elastic Compute Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTagsPaginator<Result>(
        _ input: DescribeTagsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTagsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTags,
            inputKey: \DescribeTagsRequest.nextToken,
            outputKey: \DescribeTagsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTagsPaginator(
        _ input: DescribeTagsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTagsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTags,
            inputKey: \DescribeTagsRequest.nextToken,
            outputKey: \DescribeTagsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more Traffic Mirror filters.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTrafficMirrorFiltersPaginator<Result>(
        _ input: DescribeTrafficMirrorFiltersRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTrafficMirrorFiltersResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTrafficMirrorFilters,
            inputKey: \DescribeTrafficMirrorFiltersRequest.nextToken,
            outputKey: \DescribeTrafficMirrorFiltersResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTrafficMirrorFiltersPaginator(
        _ input: DescribeTrafficMirrorFiltersRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTrafficMirrorFiltersResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTrafficMirrorFilters,
            inputKey: \DescribeTrafficMirrorFiltersRequest.nextToken,
            outputKey: \DescribeTrafficMirrorFiltersResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more Traffic Mirror sessions. By default, all Traffic Mirror sessions are described. Alternatively, you can filter the results.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTrafficMirrorSessionsPaginator<Result>(
        _ input: DescribeTrafficMirrorSessionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTrafficMirrorSessionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTrafficMirrorSessions,
            inputKey: \DescribeTrafficMirrorSessionsRequest.nextToken,
            outputKey: \DescribeTrafficMirrorSessionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTrafficMirrorSessionsPaginator(
        _ input: DescribeTrafficMirrorSessionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTrafficMirrorSessionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTrafficMirrorSessions,
            inputKey: \DescribeTrafficMirrorSessionsRequest.nextToken,
            outputKey: \DescribeTrafficMirrorSessionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Information about one or more Traffic Mirror targets.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTrafficMirrorTargetsPaginator<Result>(
        _ input: DescribeTrafficMirrorTargetsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTrafficMirrorTargetsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTrafficMirrorTargets,
            inputKey: \DescribeTrafficMirrorTargetsRequest.nextToken,
            outputKey: \DescribeTrafficMirrorTargetsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTrafficMirrorTargetsPaginator(
        _ input: DescribeTrafficMirrorTargetsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTrafficMirrorTargetsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTrafficMirrorTargets,
            inputKey: \DescribeTrafficMirrorTargetsRequest.nextToken,
            outputKey: \DescribeTrafficMirrorTargetsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more attachments between resources and transit gateways. By default, all attachments are described. Alternatively, you can filter the results by attachment ID, attachment state, resource ID, or resource owner.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTransitGatewayAttachmentsPaginator<Result>(
        _ input: DescribeTransitGatewayAttachmentsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTransitGatewayAttachmentsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTransitGatewayAttachments,
            inputKey: \DescribeTransitGatewayAttachmentsRequest.nextToken,
            outputKey: \DescribeTransitGatewayAttachmentsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTransitGatewayAttachmentsPaginator(
        _ input: DescribeTransitGatewayAttachmentsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTransitGatewayAttachmentsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTransitGatewayAttachments,
            inputKey: \DescribeTransitGatewayAttachmentsRequest.nextToken,
            outputKey: \DescribeTransitGatewayAttachmentsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more Connect peers.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTransitGatewayConnectPeersPaginator<Result>(
        _ input: DescribeTransitGatewayConnectPeersRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTransitGatewayConnectPeersResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTransitGatewayConnectPeers,
            inputKey: \DescribeTransitGatewayConnectPeersRequest.nextToken,
            outputKey: \DescribeTransitGatewayConnectPeersResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTransitGatewayConnectPeersPaginator(
        _ input: DescribeTransitGatewayConnectPeersRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTransitGatewayConnectPeersResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTransitGatewayConnectPeers,
            inputKey: \DescribeTransitGatewayConnectPeersRequest.nextToken,
            outputKey: \DescribeTransitGatewayConnectPeersResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more Connect attachments.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTransitGatewayConnectsPaginator<Result>(
        _ input: DescribeTransitGatewayConnectsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTransitGatewayConnectsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTransitGatewayConnects,
            inputKey: \DescribeTransitGatewayConnectsRequest.nextToken,
            outputKey: \DescribeTransitGatewayConnectsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTransitGatewayConnectsPaginator(
        _ input: DescribeTransitGatewayConnectsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTransitGatewayConnectsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTransitGatewayConnects,
            inputKey: \DescribeTransitGatewayConnectsRequest.nextToken,
            outputKey: \DescribeTransitGatewayConnectsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more transit gateway multicast domains.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTransitGatewayMulticastDomainsPaginator<Result>(
        _ input: DescribeTransitGatewayMulticastDomainsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTransitGatewayMulticastDomainsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTransitGatewayMulticastDomains,
            inputKey: \DescribeTransitGatewayMulticastDomainsRequest.nextToken,
            outputKey: \DescribeTransitGatewayMulticastDomainsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTransitGatewayMulticastDomainsPaginator(
        _ input: DescribeTransitGatewayMulticastDomainsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTransitGatewayMulticastDomainsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTransitGatewayMulticastDomains,
            inputKey: \DescribeTransitGatewayMulticastDomainsRequest.nextToken,
            outputKey: \DescribeTransitGatewayMulticastDomainsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes your transit gateway peering attachments.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTransitGatewayPeeringAttachmentsPaginator<Result>(
        _ input: DescribeTransitGatewayPeeringAttachmentsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTransitGatewayPeeringAttachmentsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTransitGatewayPeeringAttachments,
            inputKey: \DescribeTransitGatewayPeeringAttachmentsRequest.nextToken,
            outputKey: \DescribeTransitGatewayPeeringAttachmentsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTransitGatewayPeeringAttachmentsPaginator(
        _ input: DescribeTransitGatewayPeeringAttachmentsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTransitGatewayPeeringAttachmentsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTransitGatewayPeeringAttachments,
            inputKey: \DescribeTransitGatewayPeeringAttachmentsRequest.nextToken,
            outputKey: \DescribeTransitGatewayPeeringAttachmentsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more transit gateway route tables. By default, all transit gateway route tables are described. Alternatively, you can filter the results.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTransitGatewayRouteTablesPaginator<Result>(
        _ input: DescribeTransitGatewayRouteTablesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTransitGatewayRouteTablesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTransitGatewayRouteTables,
            inputKey: \DescribeTransitGatewayRouteTablesRequest.nextToken,
            outputKey: \DescribeTransitGatewayRouteTablesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTransitGatewayRouteTablesPaginator(
        _ input: DescribeTransitGatewayRouteTablesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTransitGatewayRouteTablesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTransitGatewayRouteTables,
            inputKey: \DescribeTransitGatewayRouteTablesRequest.nextToken,
            outputKey: \DescribeTransitGatewayRouteTablesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more VPC attachments. By default, all VPC attachments are described. Alternatively, you can filter the results.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTransitGatewayVpcAttachmentsPaginator<Result>(
        _ input: DescribeTransitGatewayVpcAttachmentsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTransitGatewayVpcAttachmentsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTransitGatewayVpcAttachments,
            inputKey: \DescribeTransitGatewayVpcAttachmentsRequest.nextToken,
            outputKey: \DescribeTransitGatewayVpcAttachmentsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTransitGatewayVpcAttachmentsPaginator(
        _ input: DescribeTransitGatewayVpcAttachmentsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTransitGatewayVpcAttachmentsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTransitGatewayVpcAttachments,
            inputKey: \DescribeTransitGatewayVpcAttachmentsRequest.nextToken,
            outputKey: \DescribeTransitGatewayVpcAttachmentsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more transit gateways. By default, all transit gateways are described. Alternatively, you can filter the results.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTransitGatewaysPaginator<Result>(
        _ input: DescribeTransitGatewaysRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeTransitGatewaysResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTransitGateways,
            inputKey: \DescribeTransitGatewaysRequest.nextToken,
            outputKey: \DescribeTransitGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTransitGatewaysPaginator(
        _ input: DescribeTransitGatewaysRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeTransitGatewaysResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTransitGateways,
            inputKey: \DescribeTransitGatewaysRequest.nextToken,
            outputKey: \DescribeTransitGatewaysResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the status of the specified volumes. Volume status provides the result of the checks performed on your volumes to determine events that can impair the performance of your volumes. The performance of a volume can be affected if an issue occurs on the volume's underlying host. If the volume's underlying host experiences a power outage or system issue, after the system is restored, there could be data inconsistencies on the volume. Volume events notify you if this occurs. Volume actions notify you if any action needs to be taken in response to the event. The DescribeVolumeStatus operation provides the following information about the specified volumes:  Status: Reflects the current status of the volume. The possible values are ok, impaired , warning, or insufficient-data. If all checks pass, the overall status of the volume is ok. If the check fails, the overall status is impaired. If the status is insufficient-data, then the checks might still be taking place on your volume at the time. We recommend that you retry the request. For more information about volume status, see Monitoring the status of your volumes in the Amazon Elastic Compute Cloud User Guide.  Events: Reflect the cause of a volume status and might require you to take action. For example, if your volume returns an impaired status, then the volume event might be potential-data-inconsistency. This means that your volume has been affected by an issue with the underlying host, has all I/O operations disabled, and might have inconsistent data.  Actions: Reflect the actions you might have to take in response to an event. For example, if the status of the volume is impaired and the volume event shows potential-data-inconsistency, then the action shows enable-volume-io. This means that you may want to enable the I/O operations for the volume by calling the EnableVolumeIO action and then check the volume for data consistency. Volume status is based on the volume status checks, and does not reflect the volume state. Therefore, volume status does not indicate volumes in the error state (for example, when a volume is incapable of accepting I/O.)
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeVolumeStatusPaginator<Result>(
        _ input: DescribeVolumeStatusRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeVolumeStatusResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeVolumeStatus,
            inputKey: \DescribeVolumeStatusRequest.nextToken,
            outputKey: \DescribeVolumeStatusResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeVolumeStatusPaginator(
        _ input: DescribeVolumeStatusRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeVolumeStatusResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeVolumeStatus,
            inputKey: \DescribeVolumeStatusRequest.nextToken,
            outputKey: \DescribeVolumeStatusResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified EBS volumes or all of your EBS volumes. If you are describing a long list of volumes, we recommend that you paginate the output to make the list more manageable. The MaxResults parameter sets the maximum number of results returned in a single page. If the list of results exceeds your MaxResults value, then that number of results is returned along with a NextToken value that can be passed to a subsequent DescribeVolumes request to retrieve the remaining results. For more information about EBS volumes, see Amazon EBS volumes in the Amazon Elastic Compute Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeVolumesPaginator<Result>(
        _ input: DescribeVolumesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeVolumesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeVolumes,
            inputKey: \DescribeVolumesRequest.nextToken,
            outputKey: \DescribeVolumesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeVolumesPaginator(
        _ input: DescribeVolumesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeVolumesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeVolumes,
            inputKey: \DescribeVolumesRequest.nextToken,
            outputKey: \DescribeVolumesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the most recent volume modification request for the specified EBS volumes. If a volume has never been modified, some information in the output will be null. If a volume has been modified more than once, the output includes only the most recent modification request. You can also use CloudWatch Events to check the status of a modification to an EBS volume. For information about CloudWatch Events, see the Amazon CloudWatch Events User Guide. For more information, see Monitoring volume modifications in the Amazon Elastic Compute Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeVolumesModificationsPaginator<Result>(
        _ input: DescribeVolumesModificationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeVolumesModificationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeVolumesModifications,
            inputKey: \DescribeVolumesModificationsRequest.nextToken,
            outputKey: \DescribeVolumesModificationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeVolumesModificationsPaginator(
        _ input: DescribeVolumesModificationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeVolumesModificationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeVolumesModifications,
            inputKey: \DescribeVolumesModificationsRequest.nextToken,
            outputKey: \DescribeVolumesModificationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the ClassicLink DNS support status of one or more VPCs. If enabled, the DNS hostname of a linked EC2-Classic instance resolves to its private IP address when addressed from an instance in the VPC to which it's linked. Similarly, the DNS hostname of an instance in a VPC resolves to its private IP address when addressed from a linked EC2-Classic instance. For more information, see ClassicLink in the Amazon Elastic Compute Cloud User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeVpcClassicLinkDnsSupportPaginator<Result>(
        _ input: DescribeVpcClassicLinkDnsSupportRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeVpcClassicLinkDnsSupportResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeVpcClassicLinkDnsSupport,
            inputKey: \DescribeVpcClassicLinkDnsSupportRequest.nextToken,
            outputKey: \DescribeVpcClassicLinkDnsSupportResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeVpcClassicLinkDnsSupportPaginator(
        _ input: DescribeVpcClassicLinkDnsSupportRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeVpcClassicLinkDnsSupportResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeVpcClassicLinkDnsSupport,
            inputKey: \DescribeVpcClassicLinkDnsSupportRequest.nextToken,
            outputKey: \DescribeVpcClassicLinkDnsSupportResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the connection notifications for VPC endpoints and VPC endpoint services.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeVpcEndpointConnectionNotificationsPaginator<Result>(
        _ input: DescribeVpcEndpointConnectionNotificationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeVpcEndpointConnectionNotificationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeVpcEndpointConnectionNotifications,
            inputKey: \DescribeVpcEndpointConnectionNotificationsRequest.nextToken,
            outputKey: \DescribeVpcEndpointConnectionNotificationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeVpcEndpointConnectionNotificationsPaginator(
        _ input: DescribeVpcEndpointConnectionNotificationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeVpcEndpointConnectionNotificationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeVpcEndpointConnectionNotifications,
            inputKey: \DescribeVpcEndpointConnectionNotificationsRequest.nextToken,
            outputKey: \DescribeVpcEndpointConnectionNotificationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the VPC endpoint connections to your VPC endpoint services, including any endpoints that are pending your acceptance.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeVpcEndpointConnectionsPaginator<Result>(
        _ input: DescribeVpcEndpointConnectionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeVpcEndpointConnectionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeVpcEndpointConnections,
            inputKey: \DescribeVpcEndpointConnectionsRequest.nextToken,
            outputKey: \DescribeVpcEndpointConnectionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeVpcEndpointConnectionsPaginator(
        _ input: DescribeVpcEndpointConnectionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeVpcEndpointConnectionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeVpcEndpointConnections,
            inputKey: \DescribeVpcEndpointConnectionsRequest.nextToken,
            outputKey: \DescribeVpcEndpointConnectionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the VPC endpoint service configurations in your account (your services).
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeVpcEndpointServiceConfigurationsPaginator<Result>(
        _ input: DescribeVpcEndpointServiceConfigurationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeVpcEndpointServiceConfigurationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeVpcEndpointServiceConfigurations,
            inputKey: \DescribeVpcEndpointServiceConfigurationsRequest.nextToken,
            outputKey: \DescribeVpcEndpointServiceConfigurationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeVpcEndpointServiceConfigurationsPaginator(
        _ input: DescribeVpcEndpointServiceConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeVpcEndpointServiceConfigurationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeVpcEndpointServiceConfigurations,
            inputKey: \DescribeVpcEndpointServiceConfigurationsRequest.nextToken,
            outputKey: \DescribeVpcEndpointServiceConfigurationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the principals (service consumers) that are permitted to discover your VPC endpoint service.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeVpcEndpointServicePermissionsPaginator<Result>(
        _ input: DescribeVpcEndpointServicePermissionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeVpcEndpointServicePermissionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeVpcEndpointServicePermissions,
            inputKey: \DescribeVpcEndpointServicePermissionsRequest.nextToken,
            outputKey: \DescribeVpcEndpointServicePermissionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeVpcEndpointServicePermissionsPaginator(
        _ input: DescribeVpcEndpointServicePermissionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeVpcEndpointServicePermissionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeVpcEndpointServicePermissions,
            inputKey: \DescribeVpcEndpointServicePermissionsRequest.nextToken,
            outputKey: \DescribeVpcEndpointServicePermissionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your VPC endpoints.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeVpcEndpointsPaginator<Result>(
        _ input: DescribeVpcEndpointsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeVpcEndpointsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeVpcEndpoints,
            inputKey: \DescribeVpcEndpointsRequest.nextToken,
            outputKey: \DescribeVpcEndpointsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeVpcEndpointsPaginator(
        _ input: DescribeVpcEndpointsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeVpcEndpointsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeVpcEndpoints,
            inputKey: \DescribeVpcEndpointsRequest.nextToken,
            outputKey: \DescribeVpcEndpointsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your VPC peering connections.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeVpcPeeringConnectionsPaginator<Result>(
        _ input: DescribeVpcPeeringConnectionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeVpcPeeringConnectionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeVpcPeeringConnections,
            inputKey: \DescribeVpcPeeringConnectionsRequest.nextToken,
            outputKey: \DescribeVpcPeeringConnectionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeVpcPeeringConnectionsPaginator(
        _ input: DescribeVpcPeeringConnectionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeVpcPeeringConnectionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeVpcPeeringConnections,
            inputKey: \DescribeVpcPeeringConnectionsRequest.nextToken,
            outputKey: \DescribeVpcPeeringConnectionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your VPCs.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeVpcsPaginator<Result>(
        _ input: DescribeVpcsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeVpcsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeVpcs,
            inputKey: \DescribeVpcsRequest.nextToken,
            outputKey: \DescribeVpcsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeVpcsPaginator(
        _ input: DescribeVpcsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeVpcsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeVpcs,
            inputKey: \DescribeVpcsRequest.nextToken,
            outputKey: \DescribeVpcsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the IPv6 CIDR block associations for a specified IPv6 address pool.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getAssociatedIpv6PoolCidrsPaginator<Result>(
        _ input: GetAssociatedIpv6PoolCidrsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetAssociatedIpv6PoolCidrsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getAssociatedIpv6PoolCidrs,
            inputKey: \GetAssociatedIpv6PoolCidrsRequest.nextToken,
            outputKey: \GetAssociatedIpv6PoolCidrsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getAssociatedIpv6PoolCidrsPaginator(
        _ input: GetAssociatedIpv6PoolCidrsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetAssociatedIpv6PoolCidrsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getAssociatedIpv6PoolCidrs,
            inputKey: \GetAssociatedIpv6PoolCidrsRequest.nextToken,
            outputKey: \GetAssociatedIpv6PoolCidrsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the resource groups to which a Capacity Reservation has been added.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getGroupsForCapacityReservationPaginator<Result>(
        _ input: GetGroupsForCapacityReservationRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetGroupsForCapacityReservationResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getGroupsForCapacityReservation,
            inputKey: \GetGroupsForCapacityReservationRequest.nextToken,
            outputKey: \GetGroupsForCapacityReservationResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getGroupsForCapacityReservationPaginator(
        _ input: GetGroupsForCapacityReservationRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetGroupsForCapacityReservationResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getGroupsForCapacityReservation,
            inputKey: \GetGroupsForCapacityReservationRequest.nextToken,
            outputKey: \GetGroupsForCapacityReservationResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the resources that are associated with the specified managed prefix list.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getManagedPrefixListAssociationsPaginator<Result>(
        _ input: GetManagedPrefixListAssociationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetManagedPrefixListAssociationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getManagedPrefixListAssociations,
            inputKey: \GetManagedPrefixListAssociationsRequest.nextToken,
            outputKey: \GetManagedPrefixListAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getManagedPrefixListAssociationsPaginator(
        _ input: GetManagedPrefixListAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetManagedPrefixListAssociationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getManagedPrefixListAssociations,
            inputKey: \GetManagedPrefixListAssociationsRequest.nextToken,
            outputKey: \GetManagedPrefixListAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the entries for a specified managed prefix list.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getManagedPrefixListEntriesPaginator<Result>(
        _ input: GetManagedPrefixListEntriesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetManagedPrefixListEntriesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getManagedPrefixListEntries,
            inputKey: \GetManagedPrefixListEntriesRequest.nextToken,
            outputKey: \GetManagedPrefixListEntriesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getManagedPrefixListEntriesPaginator(
        _ input: GetManagedPrefixListEntriesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetManagedPrefixListEntriesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getManagedPrefixListEntries,
            inputKey: \GetManagedPrefixListEntriesRequest.nextToken,
            outputKey: \GetManagedPrefixListEntriesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the route tables to which the specified resource attachment propagates routes.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getTransitGatewayAttachmentPropagationsPaginator<Result>(
        _ input: GetTransitGatewayAttachmentPropagationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetTransitGatewayAttachmentPropagationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getTransitGatewayAttachmentPropagations,
            inputKey: \GetTransitGatewayAttachmentPropagationsRequest.nextToken,
            outputKey: \GetTransitGatewayAttachmentPropagationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getTransitGatewayAttachmentPropagationsPaginator(
        _ input: GetTransitGatewayAttachmentPropagationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetTransitGatewayAttachmentPropagationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getTransitGatewayAttachmentPropagations,
            inputKey: \GetTransitGatewayAttachmentPropagationsRequest.nextToken,
            outputKey: \GetTransitGatewayAttachmentPropagationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the associations for the transit gateway multicast domain.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getTransitGatewayMulticastDomainAssociationsPaginator<Result>(
        _ input: GetTransitGatewayMulticastDomainAssociationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetTransitGatewayMulticastDomainAssociationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getTransitGatewayMulticastDomainAssociations,
            inputKey: \GetTransitGatewayMulticastDomainAssociationsRequest.nextToken,
            outputKey: \GetTransitGatewayMulticastDomainAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getTransitGatewayMulticastDomainAssociationsPaginator(
        _ input: GetTransitGatewayMulticastDomainAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetTransitGatewayMulticastDomainAssociationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getTransitGatewayMulticastDomainAssociations,
            inputKey: \GetTransitGatewayMulticastDomainAssociationsRequest.nextToken,
            outputKey: \GetTransitGatewayMulticastDomainAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the prefix list references in a specified transit gateway route table.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getTransitGatewayPrefixListReferencesPaginator<Result>(
        _ input: GetTransitGatewayPrefixListReferencesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetTransitGatewayPrefixListReferencesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getTransitGatewayPrefixListReferences,
            inputKey: \GetTransitGatewayPrefixListReferencesRequest.nextToken,
            outputKey: \GetTransitGatewayPrefixListReferencesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getTransitGatewayPrefixListReferencesPaginator(
        _ input: GetTransitGatewayPrefixListReferencesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetTransitGatewayPrefixListReferencesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getTransitGatewayPrefixListReferences,
            inputKey: \GetTransitGatewayPrefixListReferencesRequest.nextToken,
            outputKey: \GetTransitGatewayPrefixListReferencesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the associations for the specified transit gateway route table.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getTransitGatewayRouteTableAssociationsPaginator<Result>(
        _ input: GetTransitGatewayRouteTableAssociationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetTransitGatewayRouteTableAssociationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getTransitGatewayRouteTableAssociations,
            inputKey: \GetTransitGatewayRouteTableAssociationsRequest.nextToken,
            outputKey: \GetTransitGatewayRouteTableAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getTransitGatewayRouteTableAssociationsPaginator(
        _ input: GetTransitGatewayRouteTableAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetTransitGatewayRouteTableAssociationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getTransitGatewayRouteTableAssociations,
            inputKey: \GetTransitGatewayRouteTableAssociationsRequest.nextToken,
            outputKey: \GetTransitGatewayRouteTableAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the route table propagations for the specified transit gateway route table.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getTransitGatewayRouteTablePropagationsPaginator<Result>(
        _ input: GetTransitGatewayRouteTablePropagationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetTransitGatewayRouteTablePropagationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getTransitGatewayRouteTablePropagations,
            inputKey: \GetTransitGatewayRouteTablePropagationsRequest.nextToken,
            outputKey: \GetTransitGatewayRouteTablePropagationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getTransitGatewayRouteTablePropagationsPaginator(
        _ input: GetTransitGatewayRouteTablePropagationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetTransitGatewayRouteTablePropagationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getTransitGatewayRouteTablePropagations,
            inputKey: \GetTransitGatewayRouteTablePropagationsRequest.nextToken,
            outputKey: \GetTransitGatewayRouteTablePropagationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Searches for routes in the specified local gateway route table.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchLocalGatewayRoutesPaginator<Result>(
        _ input: SearchLocalGatewayRoutesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchLocalGatewayRoutesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: searchLocalGatewayRoutes,
            inputKey: \SearchLocalGatewayRoutesRequest.nextToken,
            outputKey: \SearchLocalGatewayRoutesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchLocalGatewayRoutesPaginator(
        _ input: SearchLocalGatewayRoutesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchLocalGatewayRoutesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: searchLocalGatewayRoutes,
            inputKey: \SearchLocalGatewayRoutesRequest.nextToken,
            outputKey: \SearchLocalGatewayRoutesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Searches one or more transit gateway multicast groups and returns the group membership information.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchTransitGatewayMulticastGroupsPaginator<Result>(
        _ input: SearchTransitGatewayMulticastGroupsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchTransitGatewayMulticastGroupsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: searchTransitGatewayMulticastGroups,
            inputKey: \SearchTransitGatewayMulticastGroupsRequest.nextToken,
            outputKey: \SearchTransitGatewayMulticastGroupsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchTransitGatewayMulticastGroupsPaginator(
        _ input: SearchTransitGatewayMulticastGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchTransitGatewayMulticastGroupsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: searchTransitGatewayMulticastGroups,
            inputKey: \SearchTransitGatewayMulticastGroupsRequest.nextToken,
            outputKey: \SearchTransitGatewayMulticastGroupsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension EC2.DescribeAddressesAttributeRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeAddressesAttributeRequest {
        return .init(
            allocationIds: self.allocationIds,
            attribute: self.attribute,
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeByoipCidrsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeByoipCidrsRequest {
        return .init(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeCapacityReservationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeCapacityReservationsRequest {
        return .init(
            capacityReservationIds: self.capacityReservationIds,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeCarrierGatewaysRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeCarrierGatewaysRequest {
        return .init(
            carrierGatewayIds: self.carrierGatewayIds,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeClassicLinkInstancesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeClassicLinkInstancesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            instanceIds: self.instanceIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeClientVpnAuthorizationRulesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeClientVpnAuthorizationRulesRequest {
        return .init(
            clientVpnEndpointId: self.clientVpnEndpointId,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeClientVpnConnectionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeClientVpnConnectionsRequest {
        return .init(
            clientVpnEndpointId: self.clientVpnEndpointId,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeClientVpnEndpointsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeClientVpnEndpointsRequest {
        return .init(
            clientVpnEndpointIds: self.clientVpnEndpointIds,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeClientVpnRoutesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeClientVpnRoutesRequest {
        return .init(
            clientVpnEndpointId: self.clientVpnEndpointId,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeClientVpnTargetNetworksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeClientVpnTargetNetworksRequest {
        return .init(
            associationIds: self.associationIds,
            clientVpnEndpointId: self.clientVpnEndpointId,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeCoipPoolsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeCoipPoolsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            poolIds: self.poolIds
        )
    }
}

extension EC2.DescribeDhcpOptionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeDhcpOptionsRequest {
        return .init(
            dhcpOptionsIds: self.dhcpOptionsIds,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeEgressOnlyInternetGatewaysRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeEgressOnlyInternetGatewaysRequest {
        return .init(
            dryRun: self.dryRun,
            egressOnlyInternetGatewayIds: self.egressOnlyInternetGatewayIds,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeExportImageTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeExportImageTasksRequest {
        return .init(
            dryRun: self.dryRun,
            exportImageTaskIds: self.exportImageTaskIds,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeFastSnapshotRestoresRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeFastSnapshotRestoresRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeFleetsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeFleetsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            fleetIds: self.fleetIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeFlowLogsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeFlowLogsRequest {
        return .init(
            dryRun: self.dryRun,
            filter: self.filter,
            flowLogIds: self.flowLogIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeFpgaImagesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeFpgaImagesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            fpgaImageIds: self.fpgaImageIds,
            maxResults: self.maxResults,
            nextToken: token,
            owners: self.owners
        )
    }
}

extension EC2.DescribeHostReservationOfferingsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeHostReservationOfferingsRequest {
        return .init(
            filter: self.filter,
            maxDuration: self.maxDuration,
            maxResults: self.maxResults,
            minDuration: self.minDuration,
            nextToken: token,
            offeringId: self.offeringId
        )
    }
}

extension EC2.DescribeHostReservationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeHostReservationsRequest {
        return .init(
            filter: self.filter,
            hostReservationIdSet: self.hostReservationIdSet,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeHostsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeHostsRequest {
        return .init(
            filter: self.filter,
            hostIds: self.hostIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeIamInstanceProfileAssociationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeIamInstanceProfileAssociationsRequest {
        return .init(
            associationIds: self.associationIds,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeImportImageTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeImportImageTasksRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            importTaskIds: self.importTaskIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeImportSnapshotTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeImportSnapshotTasksRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            importTaskIds: self.importTaskIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeInstanceCreditSpecificationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeInstanceCreditSpecificationsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            instanceIds: self.instanceIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeInstanceEventWindowsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeInstanceEventWindowsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            instanceEventWindowIds: self.instanceEventWindowIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeInstanceStatusRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeInstanceStatusRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            includeAllInstances: self.includeAllInstances,
            instanceIds: self.instanceIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeInstanceTypeOfferingsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeInstanceTypeOfferingsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            locationType: self.locationType,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeInstanceTypesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeInstanceTypesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            instanceTypes: self.instanceTypes,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeInstancesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeInstancesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            instanceIds: self.instanceIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeInternetGatewaysRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeInternetGatewaysRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            internetGatewayIds: self.internetGatewayIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeIpv6PoolsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeIpv6PoolsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            poolIds: self.poolIds
        )
    }
}

extension EC2.DescribeLaunchTemplateVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeLaunchTemplateVersionsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            launchTemplateId: self.launchTemplateId,
            launchTemplateName: self.launchTemplateName,
            maxResults: self.maxResults,
            maxVersion: self.maxVersion,
            minVersion: self.minVersion,
            nextToken: token,
            versions: self.versions
        )
    }
}

extension EC2.DescribeLaunchTemplatesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeLaunchTemplatesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            launchTemplateIds: self.launchTemplateIds,
            launchTemplateNames: self.launchTemplateNames,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayRouteTableVirtualInterfaceGroupAssociationIds: self.localGatewayRouteTableVirtualInterfaceGroupAssociationIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeLocalGatewayRouteTableVpcAssociationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeLocalGatewayRouteTableVpcAssociationsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayRouteTableVpcAssociationIds: self.localGatewayRouteTableVpcAssociationIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeLocalGatewayRouteTablesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeLocalGatewayRouteTablesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayRouteTableIds: self.localGatewayRouteTableIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeLocalGatewayVirtualInterfaceGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeLocalGatewayVirtualInterfaceGroupsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayVirtualInterfaceGroupIds: self.localGatewayVirtualInterfaceGroupIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeLocalGatewayVirtualInterfacesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeLocalGatewayVirtualInterfacesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayVirtualInterfaceIds: self.localGatewayVirtualInterfaceIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeLocalGatewaysRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeLocalGatewaysRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayIds: self.localGatewayIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeManagedPrefixListsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeManagedPrefixListsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            prefixListIds: self.prefixListIds
        )
    }
}

extension EC2.DescribeMovingAddressesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeMovingAddressesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            publicIps: self.publicIps
        )
    }
}

extension EC2.DescribeNatGatewaysRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeNatGatewaysRequest {
        return .init(
            dryRun: self.dryRun,
            filter: self.filter,
            maxResults: self.maxResults,
            natGatewayIds: self.natGatewayIds,
            nextToken: token
        )
    }
}

extension EC2.DescribeNetworkAclsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeNetworkAclsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            networkAclIds: self.networkAclIds,
            nextToken: token
        )
    }
}

extension EC2.DescribeNetworkInsightsAnalysesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeNetworkInsightsAnalysesRequest {
        return .init(
            analysisEndTime: self.analysisEndTime,
            analysisStartTime: self.analysisStartTime,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            networkInsightsAnalysisIds: self.networkInsightsAnalysisIds,
            networkInsightsPathId: self.networkInsightsPathId,
            nextToken: token
        )
    }
}

extension EC2.DescribeNetworkInsightsPathsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeNetworkInsightsPathsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            networkInsightsPathIds: self.networkInsightsPathIds,
            nextToken: token
        )
    }
}

extension EC2.DescribeNetworkInterfacePermissionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeNetworkInterfacePermissionsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            networkInterfacePermissionIds: self.networkInterfacePermissionIds,
            nextToken: token
        )
    }
}

extension EC2.DescribeNetworkInterfacesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeNetworkInterfacesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            networkInterfaceIds: self.networkInterfaceIds,
            nextToken: token
        )
    }
}

extension EC2.DescribePrefixListsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribePrefixListsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            prefixListIds: self.prefixListIds
        )
    }
}

extension EC2.DescribePrincipalIdFormatRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribePrincipalIdFormatRequest {
        return .init(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            resources: self.resources
        )
    }
}

extension EC2.DescribePublicIpv4PoolsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribePublicIpv4PoolsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            poolIds: self.poolIds
        )
    }
}

extension EC2.DescribeReplaceRootVolumeTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeReplaceRootVolumeTasksRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            replaceRootVolumeTaskIds: self.replaceRootVolumeTaskIds
        )
    }
}

extension EC2.DescribeReservedInstancesModificationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeReservedInstancesModificationsRequest {
        return .init(
            filters: self.filters,
            nextToken: token,
            reservedInstancesModificationIds: self.reservedInstancesModificationIds
        )
    }
}

extension EC2.DescribeReservedInstancesOfferingsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeReservedInstancesOfferingsRequest {
        return .init(
            availabilityZone: self.availabilityZone,
            dryRun: self.dryRun,
            filters: self.filters,
            includeMarketplace: self.includeMarketplace,
            instanceTenancy: self.instanceTenancy,
            instanceType: self.instanceType,
            maxDuration: self.maxDuration,
            maxInstanceCount: self.maxInstanceCount,
            maxResults: self.maxResults,
            minDuration: self.minDuration,
            nextToken: token,
            offeringClass: self.offeringClass,
            offeringType: self.offeringType,
            productDescription: self.productDescription,
            reservedInstancesOfferingIds: self.reservedInstancesOfferingIds
        )
    }
}

extension EC2.DescribeRouteTablesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeRouteTablesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            routeTableIds: self.routeTableIds
        )
    }
}

extension EC2.DescribeScheduledInstanceAvailabilityRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeScheduledInstanceAvailabilityRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            firstSlotStartTimeRange: self.firstSlotStartTimeRange,
            maxResults: self.maxResults,
            maxSlotDurationInHours: self.maxSlotDurationInHours,
            minSlotDurationInHours: self.minSlotDurationInHours,
            nextToken: token,
            recurrence: self.recurrence
        )
    }
}

extension EC2.DescribeScheduledInstancesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeScheduledInstancesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            scheduledInstanceIds: self.scheduledInstanceIds,
            slotStartTimeRange: self.slotStartTimeRange
        )
    }
}

extension EC2.DescribeSecurityGroupRulesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeSecurityGroupRulesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            securityGroupRuleIds: self.securityGroupRuleIds
        )
    }
}

extension EC2.DescribeSecurityGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeSecurityGroupsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            groupIds: self.groupIds,
            groupNames: self.groupNames,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeSnapshotsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeSnapshotsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            ownerIds: self.ownerIds,
            restorableByUserIds: self.restorableByUserIds,
            snapshotIds: self.snapshotIds
        )
    }
}

extension EC2.DescribeSpotFleetRequestsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeSpotFleetRequestsRequest {
        return .init(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            spotFleetRequestIds: self.spotFleetRequestIds
        )
    }
}

extension EC2.DescribeSpotInstanceRequestsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeSpotInstanceRequestsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            spotInstanceRequestIds: self.spotInstanceRequestIds
        )
    }
}

extension EC2.DescribeSpotPriceHistoryRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeSpotPriceHistoryRequest {
        return .init(
            availabilityZone: self.availabilityZone,
            dryRun: self.dryRun,
            endTime: self.endTime,
            filters: self.filters,
            instanceTypes: self.instanceTypes,
            maxResults: self.maxResults,
            nextToken: token,
            productDescriptions: self.productDescriptions,
            startTime: self.startTime
        )
    }
}

extension EC2.DescribeStaleSecurityGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeStaleSecurityGroupsRequest {
        return .init(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            vpcId: self.vpcId
        )
    }
}

extension EC2.DescribeStoreImageTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeStoreImageTasksRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            imageIds: self.imageIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeSubnetsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeSubnetsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            subnetIds: self.subnetIds
        )
    }
}

extension EC2.DescribeTagsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTagsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeTrafficMirrorFiltersRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTrafficMirrorFiltersRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            trafficMirrorFilterIds: self.trafficMirrorFilterIds
        )
    }
}

extension EC2.DescribeTrafficMirrorSessionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTrafficMirrorSessionsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            trafficMirrorSessionIds: self.trafficMirrorSessionIds
        )
    }
}

extension EC2.DescribeTrafficMirrorTargetsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTrafficMirrorTargetsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            trafficMirrorTargetIds: self.trafficMirrorTargetIds
        )
    }
}

extension EC2.DescribeTransitGatewayAttachmentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTransitGatewayAttachmentsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayAttachmentIds: self.transitGatewayAttachmentIds
        )
    }
}

extension EC2.DescribeTransitGatewayConnectPeersRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTransitGatewayConnectPeersRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayConnectPeerIds: self.transitGatewayConnectPeerIds
        )
    }
}

extension EC2.DescribeTransitGatewayConnectsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTransitGatewayConnectsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayAttachmentIds: self.transitGatewayAttachmentIds
        )
    }
}

extension EC2.DescribeTransitGatewayMulticastDomainsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTransitGatewayMulticastDomainsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayMulticastDomainIds: self.transitGatewayMulticastDomainIds
        )
    }
}

extension EC2.DescribeTransitGatewayPeeringAttachmentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTransitGatewayPeeringAttachmentsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayAttachmentIds: self.transitGatewayAttachmentIds
        )
    }
}

extension EC2.DescribeTransitGatewayRouteTablesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTransitGatewayRouteTablesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayRouteTableIds: self.transitGatewayRouteTableIds
        )
    }
}

extension EC2.DescribeTransitGatewayVpcAttachmentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTransitGatewayVpcAttachmentsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayAttachmentIds: self.transitGatewayAttachmentIds
        )
    }
}

extension EC2.DescribeTransitGatewaysRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeTransitGatewaysRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayIds: self.transitGatewayIds
        )
    }
}

extension EC2.DescribeVolumeStatusRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeVolumeStatusRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            volumeIds: self.volumeIds
        )
    }
}

extension EC2.DescribeVolumesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeVolumesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            volumeIds: self.volumeIds
        )
    }
}

extension EC2.DescribeVolumesModificationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeVolumesModificationsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            volumeIds: self.volumeIds
        )
    }
}

extension EC2.DescribeVpcClassicLinkDnsSupportRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeVpcClassicLinkDnsSupportRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            vpcIds: self.vpcIds
        )
    }
}

extension EC2.DescribeVpcEndpointConnectionNotificationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeVpcEndpointConnectionNotificationsRequest {
        return .init(
            connectionNotificationId: self.connectionNotificationId,
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeVpcEndpointConnectionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeVpcEndpointConnectionsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.DescribeVpcEndpointServiceConfigurationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeVpcEndpointServiceConfigurationsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            serviceIds: self.serviceIds
        )
    }
}

extension EC2.DescribeVpcEndpointServicePermissionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeVpcEndpointServicePermissionsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            serviceId: self.serviceId
        )
    }
}

extension EC2.DescribeVpcEndpointsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeVpcEndpointsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            vpcEndpointIds: self.vpcEndpointIds
        )
    }
}

extension EC2.DescribeVpcPeeringConnectionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeVpcPeeringConnectionsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            vpcPeeringConnectionIds: self.vpcPeeringConnectionIds
        )
    }
}

extension EC2.DescribeVpcsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.DescribeVpcsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            vpcIds: self.vpcIds
        )
    }
}

extension EC2.GetAssociatedIpv6PoolCidrsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.GetAssociatedIpv6PoolCidrsRequest {
        return .init(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            poolId: self.poolId
        )
    }
}

extension EC2.GetGroupsForCapacityReservationRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.GetGroupsForCapacityReservationRequest {
        return .init(
            capacityReservationId: self.capacityReservationId,
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.GetManagedPrefixListAssociationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.GetManagedPrefixListAssociationsRequest {
        return .init(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            prefixListId: self.prefixListId
        )
    }
}

extension EC2.GetManagedPrefixListEntriesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.GetManagedPrefixListEntriesRequest {
        return .init(
            dryRun: self.dryRun,
            maxResults: self.maxResults,
            nextToken: token,
            prefixListId: self.prefixListId,
            targetVersion: self.targetVersion
        )
    }
}

extension EC2.GetTransitGatewayAttachmentPropagationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.GetTransitGatewayAttachmentPropagationsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayAttachmentId: self.transitGatewayAttachmentId
        )
    }
}

extension EC2.GetTransitGatewayMulticastDomainAssociationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.GetTransitGatewayMulticastDomainAssociationsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayMulticastDomainId: self.transitGatewayMulticastDomainId
        )
    }
}

extension EC2.GetTransitGatewayPrefixListReferencesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.GetTransitGatewayPrefixListReferencesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayRouteTableId: self.transitGatewayRouteTableId
        )
    }
}

extension EC2.GetTransitGatewayRouteTableAssociationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.GetTransitGatewayRouteTableAssociationsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayRouteTableId: self.transitGatewayRouteTableId
        )
    }
}

extension EC2.GetTransitGatewayRouteTablePropagationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.GetTransitGatewayRouteTablePropagationsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayRouteTableId: self.transitGatewayRouteTableId
        )
    }
}

extension EC2.SearchLocalGatewayRoutesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.SearchLocalGatewayRoutesRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            localGatewayRouteTableId: self.localGatewayRouteTableId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EC2.SearchTransitGatewayMulticastGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> EC2.SearchTransitGatewayMulticastGroupsRequest {
        return .init(
            dryRun: self.dryRun,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayMulticastDomainId: self.transitGatewayMulticastDomainId
        )
    }
}
