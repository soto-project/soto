//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension Kendra {
    ///  Retrieves search metrics data. The data provides a snapshot of how your users interact with your search application and how effective the application is.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getSnapshotsPaginator<Result>(
        _ input: GetSnapshotsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetSnapshotsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getSnapshots,
            inputKey: \GetSnapshotsRequest.nextToken,
            outputKey: \GetSnapshotsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getSnapshotsPaginator(
        _ input: GetSnapshotsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetSnapshotsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getSnapshots,
            inputKey: \GetSnapshotsRequest.nextToken,
            outputKey: \GetSnapshotsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets statistics about synchronizing Amazon Kendra with a data source.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDataSourceSyncJobsPaginator<Result>(
        _ input: ListDataSourceSyncJobsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDataSourceSyncJobsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listDataSourceSyncJobs,
            inputKey: \ListDataSourceSyncJobsRequest.nextToken,
            outputKey: \ListDataSourceSyncJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDataSourceSyncJobsPaginator(
        _ input: ListDataSourceSyncJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDataSourceSyncJobsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listDataSourceSyncJobs,
            inputKey: \ListDataSourceSyncJobsRequest.nextToken,
            outputKey: \ListDataSourceSyncJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the data sources that you have created.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDataSourcesPaginator<Result>(
        _ input: ListDataSourcesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDataSourcesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listDataSources,
            inputKey: \ListDataSourcesRequest.nextToken,
            outputKey: \ListDataSourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDataSourcesPaginator(
        _ input: ListDataSourcesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDataSourcesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listDataSources,
            inputKey: \ListDataSourcesRequest.nextToken,
            outputKey: \ListDataSourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists specific permissions of users and groups with access to your  Amazon Kendra experience.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listEntityPersonasPaginator<Result>(
        _ input: ListEntityPersonasRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListEntityPersonasResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listEntityPersonas,
            inputKey: \ListEntityPersonasRequest.nextToken,
            outputKey: \ListEntityPersonasResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listEntityPersonasPaginator(
        _ input: ListEntityPersonasRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListEntityPersonasResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listEntityPersonas,
            inputKey: \ListEntityPersonasRequest.nextToken,
            outputKey: \ListEntityPersonasResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists users or groups in your Amazon Web Services SSO identity source that are  granted access to your Amazon Kendra experience. You can create an Amazon Kendra experience  such as a search application. For more information on creating a search  application experience, see Building  a search experience with no code.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listExperienceEntitiesPaginator<Result>(
        _ input: ListExperienceEntitiesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListExperienceEntitiesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listExperienceEntities,
            inputKey: \ListExperienceEntitiesRequest.nextToken,
            outputKey: \ListExperienceEntitiesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listExperienceEntitiesPaginator(
        _ input: ListExperienceEntitiesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListExperienceEntitiesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listExperienceEntities,
            inputKey: \ListExperienceEntitiesRequest.nextToken,
            outputKey: \ListExperienceEntitiesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists one or more Amazon Kendra experiences. You can create an Amazon Kendra experience such  as a search application. For more information on creating a search application  experience, see Building a  search experience with no code.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listExperiencesPaginator<Result>(
        _ input: ListExperiencesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListExperiencesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listExperiences,
            inputKey: \ListExperiencesRequest.nextToken,
            outputKey: \ListExperiencesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listExperiencesPaginator(
        _ input: ListExperiencesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListExperiencesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listExperiences,
            inputKey: \ListExperiencesRequest.nextToken,
            outputKey: \ListExperiencesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets a list of FAQ lists associated with an index.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listFaqsPaginator<Result>(
        _ input: ListFaqsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListFaqsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listFaqs,
            inputKey: \ListFaqsRequest.nextToken,
            outputKey: \ListFaqsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listFaqsPaginator(
        _ input: ListFaqsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListFaqsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listFaqs,
            inputKey: \ListFaqsRequest.nextToken,
            outputKey: \ListFaqsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Provides a list of groups that are mapped to users before a  given ordering or timestamp identifier.  ListGroupsOlderThanOrderingId is currently not supported in the  Amazon Web Services GovCloud (US-West) region.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listGroupsOlderThanOrderingIdPaginator<Result>(
        _ input: ListGroupsOlderThanOrderingIdRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListGroupsOlderThanOrderingIdResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listGroupsOlderThanOrderingId,
            inputKey: \ListGroupsOlderThanOrderingIdRequest.nextToken,
            outputKey: \ListGroupsOlderThanOrderingIdResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listGroupsOlderThanOrderingIdPaginator(
        _ input: ListGroupsOlderThanOrderingIdRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListGroupsOlderThanOrderingIdResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listGroupsOlderThanOrderingId,
            inputKey: \ListGroupsOlderThanOrderingIdRequest.nextToken,
            outputKey: \ListGroupsOlderThanOrderingIdResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the Amazon Kendra indexes that you created.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listIndicesPaginator<Result>(
        _ input: ListIndicesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListIndicesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listIndices,
            inputKey: \ListIndicesRequest.nextToken,
            outputKey: \ListIndicesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listIndicesPaginator(
        _ input: ListIndicesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListIndicesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listIndices,
            inputKey: \ListIndicesRequest.nextToken,
            outputKey: \ListIndicesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the block lists used for query suggestions for an index. For information on the current quota limits for block lists, see  Quotas  for Amazon Kendra.  ListQuerySuggestionsBlockLists is currently not supported in the  Amazon Web Services GovCloud (US-West) region.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listQuerySuggestionsBlockListsPaginator<Result>(
        _ input: ListQuerySuggestionsBlockListsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListQuerySuggestionsBlockListsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listQuerySuggestionsBlockLists,
            inputKey: \ListQuerySuggestionsBlockListsRequest.nextToken,
            outputKey: \ListQuerySuggestionsBlockListsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listQuerySuggestionsBlockListsPaginator(
        _ input: ListQuerySuggestionsBlockListsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListQuerySuggestionsBlockListsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listQuerySuggestionsBlockLists,
            inputKey: \ListQuerySuggestionsBlockListsRequest.nextToken,
            outputKey: \ListQuerySuggestionsBlockListsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the Amazon Kendra thesauri associated with an index.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listThesauriPaginator<Result>(
        _ input: ListThesauriRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListThesauriResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listThesauri,
            inputKey: \ListThesauriRequest.nextToken,
            outputKey: \ListThesauriResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listThesauriPaginator(
        _ input: ListThesauriRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListThesauriResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listThesauri,
            inputKey: \ListThesauriRequest.nextToken,
            outputKey: \ListThesauriResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension Kendra.GetSnapshotsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Kendra.GetSnapshotsRequest {
        return .init(
            indexId: self.indexId,
            interval: self.interval,
            maxResults: self.maxResults,
            metricType: self.metricType,
            nextToken: token
        )
    }
}

extension Kendra.ListDataSourceSyncJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Kendra.ListDataSourceSyncJobsRequest {
        return .init(
            id: self.id,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token,
            startTimeFilter: self.startTimeFilter,
            statusFilter: self.statusFilter
        )
    }
}

extension Kendra.ListDataSourcesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Kendra.ListDataSourcesRequest {
        return .init(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kendra.ListEntityPersonasRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Kendra.ListEntityPersonasRequest {
        return .init(
            id: self.id,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kendra.ListExperienceEntitiesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Kendra.ListExperienceEntitiesRequest {
        return .init(
            id: self.id,
            indexId: self.indexId,
            nextToken: token
        )
    }
}

extension Kendra.ListExperiencesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Kendra.ListExperiencesRequest {
        return .init(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kendra.ListFaqsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Kendra.ListFaqsRequest {
        return .init(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kendra.ListGroupsOlderThanOrderingIdRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Kendra.ListGroupsOlderThanOrderingIdRequest {
        return .init(
            dataSourceId: self.dataSourceId,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token,
            orderingId: self.orderingId
        )
    }
}

extension Kendra.ListIndicesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Kendra.ListIndicesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kendra.ListQuerySuggestionsBlockListsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Kendra.ListQuerySuggestionsBlockListsRequest {
        return .init(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kendra.ListThesauriRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Kendra.ListThesauriRequest {
        return .init(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
