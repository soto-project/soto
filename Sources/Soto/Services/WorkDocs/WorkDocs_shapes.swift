//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension WorkDocs {
    // MARK: Enums

    public enum ActivityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case documentAnnotationAdded = "DOCUMENT_ANNOTATION_ADDED"
        case documentAnnotationDeleted = "DOCUMENT_ANNOTATION_DELETED"
        case documentCheckedIn = "DOCUMENT_CHECKED_IN"
        case documentCheckedOut = "DOCUMENT_CHECKED_OUT"
        case documentCommentAdded = "DOCUMENT_COMMENT_ADDED"
        case documentCommentDeleted = "DOCUMENT_COMMENT_DELETED"
        case documentMoved = "DOCUMENT_MOVED"
        case documentRecycled = "DOCUMENT_RECYCLED"
        case documentRenamed = "DOCUMENT_RENAMED"
        case documentRestored = "DOCUMENT_RESTORED"
        case documentReverted = "DOCUMENT_REVERTED"
        case documentSharePermissionChanged = "DOCUMENT_SHARE_PERMISSION_CHANGED"
        case documentShareableLinkCreated = "DOCUMENT_SHAREABLE_LINK_CREATED"
        case documentShareableLinkPermissionChanged = "DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED"
        case documentShareableLinkRemoved = "DOCUMENT_SHAREABLE_LINK_REMOVED"
        case documentShared = "DOCUMENT_SHARED"
        case documentUnshared = "DOCUMENT_UNSHARED"
        case documentVersionDeleted = "DOCUMENT_VERSION_DELETED"
        case documentVersionDownloaded = "DOCUMENT_VERSION_DOWNLOADED"
        case documentVersionUploaded = "DOCUMENT_VERSION_UPLOADED"
        case documentVersionViewed = "DOCUMENT_VERSION_VIEWED"
        case folderCreated = "FOLDER_CREATED"
        case folderDeleted = "FOLDER_DELETED"
        case folderMoved = "FOLDER_MOVED"
        case folderRecycled = "FOLDER_RECYCLED"
        case folderRenamed = "FOLDER_RENAMED"
        case folderRestored = "FOLDER_RESTORED"
        case folderSharePermissionChanged = "FOLDER_SHARE_PERMISSION_CHANGED"
        case folderShareableLinkCreated = "FOLDER_SHAREABLE_LINK_CREATED"
        case folderShareableLinkPermissionChanged = "FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED"
        case folderShareableLinkRemoved = "FOLDER_SHAREABLE_LINK_REMOVED"
        case folderShared = "FOLDER_SHARED"
        case folderUnshared = "FOLDER_UNSHARED"
        public var description: String { return self.rawValue }
    }

    public enum AdditionalResponseFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case weburl = "WEBURL"
        public var description: String { return self.rawValue }
    }

    public enum BooleanEnumType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `false` = "FALSE"
        case `true` = "TRUE"
        public var description: String { return self.rawValue }
    }

    public enum CommentStatusType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case draft = "DRAFT"
        case published = "PUBLISHED"
        public var description: String { return self.rawValue }
    }

    public enum CommentVisibilityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "PRIVATE"
        case `public` = "PUBLIC"
        public var description: String { return self.rawValue }
    }

    public enum ContentCategoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audio = "AUDIO"
        case document = "DOCUMENT"
        case image = "IMAGE"
        case other = "OTHER"
        case pdf = "PDF"
        case presentation = "PRESENTATION"
        case sourceCode = "SOURCE_CODE"
        case spreadsheet = "SPREADSHEET"
        case video = "VIDEO"
        public var description: String { return self.rawValue }
    }

    public enum DocumentSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case original = "ORIGINAL"
        case withComments = "WITH_COMMENTS"
        public var description: String { return self.rawValue }
    }

    public enum DocumentStatusType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case initialized = "INITIALIZED"
        public var description: String { return self.rawValue }
    }

    public enum DocumentThumbnailType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case large = "LARGE"
        case small = "SMALL"
        case smallHq = "SMALL_HQ"
        public var description: String { return self.rawValue }
    }

    public enum DocumentVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum FolderContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case document = "DOCUMENT"
        case folder = "FOLDER"
        public var description: String { return self.rawValue }
    }

    public enum LanguageCodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case ar = "AR"
        case bg = "BG"
        case bn = "BN"
        case cs = "CS"
        case da = "DA"
        case de = "DE"
        case el = "EL"
        case en = "EN"
        case es = "ES"
        case fa = "FA"
        case fi = "FI"
        case fr = "FR"
        case hi = "HI"
        case hu = "HU"
        case id = "ID"
        case it = "IT"
        case ja = "JA"
        case ko = "KO"
        case lt = "LT"
        case lv = "LV"
        case nl = "NL"
        case no = "NO"
        case pt = "PT"
        case ro = "RO"
        case ru = "RU"
        case sv = "SV"
        case sw = "SW"
        case th = "TH"
        case tr = "TR"
        case zh = "ZH"
        public var description: String { return self.rawValue }
    }

    public enum LocaleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "default"
        case de = "de"
        case en = "en"
        case es = "es"
        case fr = "fr"
        case ja = "ja"
        case ko = "ko"
        case ptBr = "pt_BR"
        case ru = "ru"
        case zhCn = "zh_CN"
        case zhTw = "zh_TW"
        public var description: String { return self.rawValue }
    }

    public enum OrderByFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createdTimestamp = "CREATED_TIMESTAMP"
        case modifiedTimestamp = "MODIFIED_TIMESTAMP"
        case name = "NAME"
        case relevance = "RELEVANCE"
        case size = "SIZE"
        public var description: String { return self.rawValue }
    }

    public enum OrderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum PrincipalRoleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contributor = "CONTRIBUTOR"
        case coowner = "COOWNER"
        case owner = "OWNER"
        case viewer = "VIEWER"
        public var description: String { return self.rawValue }
    }

    public enum PrincipalType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anonymous = "ANONYMOUS"
        case group = "GROUP"
        case invite = "INVITE"
        case organization = "ORGANIZATION"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum ResourceCollectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sharedWithMe = "SHARED_WITH_ME"
        public var description: String { return self.rawValue }
    }

    public enum ResourceSortType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case date = "DATE"
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum ResourceStateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case recycled = "RECYCLED"
        case recycling = "RECYCLING"
        case restoring = "RESTORING"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case document = "DOCUMENT"
        case folder = "FOLDER"
        public var description: String { return self.rawValue }
    }

    public enum ResponseItemType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case comment = "COMMENT"
        case document = "DOCUMENT"
        case documentVersion = "DOCUMENT_VERSION"
        case folder = "FOLDER"
        public var description: String { return self.rawValue }
    }

    public enum RolePermissionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case direct = "DIRECT"
        case inherited = "INHERITED"
        public var description: String { return self.rawValue }
    }

    public enum RoleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contributor = "CONTRIBUTOR"
        case coowner = "COOWNER"
        case owner = "OWNER"
        case viewer = "VIEWER"
        public var description: String { return self.rawValue }
    }

    public enum SearchCollectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case owned = "OWNED"
        case sharedWithMe = "SHARED_WITH_ME"
        public var description: String { return self.rawValue }
    }

    public enum SearchQueryScopeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case content = "CONTENT"
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum SearchResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case comment = "COMMENT"
        case document = "DOCUMENT"
        case documentVersion = "DOCUMENT_VERSION"
        case folder = "FOLDER"
        public var description: String { return self.rawValue }
    }

    public enum ShareStatusType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failure = "FAILURE"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum StorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case quota = "QUOTA"
        case unlimited = "UNLIMITED"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionProtocolType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case https = "HTTPS"
        case sqs = "SQS"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public enum UserFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activePending = "ACTIVE_PENDING"
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public enum UserSortType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fullName = "FULL_NAME"
        case storageLimit = "STORAGE_LIMIT"
        case storageUsed = "STORAGE_USED"
        case userName = "USER_NAME"
        case userStatus = "USER_STATUS"
        public var description: String { return self.rawValue }
    }

    public enum UserStatusType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum UserType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case admin = "ADMIN"
        case minimaluser = "MINIMALUSER"
        case poweruser = "POWERUSER"
        case user = "USER"
        case workspacesuser = "WORKSPACESUSER"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AbortDocumentVersionUploadRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the document.
        public let documentId: String
        /// The ID of the version.
        public let versionId: String

        @inlinable
        public init(authenticationToken: String? = nil, documentId: String, versionId: String) {
            self.authenticationToken = authenticationToken
            self.documentId = documentId
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.documentId, key: "DocumentId")
            request.encodePath(self.versionId, key: "VersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 128)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ActivateUserRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the user.
        public let userId: String

        @inlinable
        public init(authenticationToken: String? = nil, userId: String) {
            self.authenticationToken = authenticationToken
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[&\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ActivateUserResponse: AWSDecodableShape {
        /// The user information.
        public let user: User?

        @inlinable
        public init(user: User? = nil) {
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case user = "User"
        }
    }

    public struct Activity: AWSDecodableShape {
        /// Metadata of the commenting activity. This is an optional field and is filled for commenting activities.
        public let commentMetadata: CommentMetadata?
        /// The user who performed the action.
        public let initiator: UserMetadata?
        /// Indicates whether an activity is indirect or direct. An indirect activity results from a direct activity performed on a parent resource. For example, sharing a parent folder (the direct activity) shares all of the subfolders and documents within the parent folder (the indirect activity).
        public let isIndirectActivity: Bool?
        /// The ID of the organization.
        public let organizationId: String?
        /// The original parent of the resource. This is an optional field and is filled for move activities.
        public let originalParent: ResourceMetadata?
        /// The list of users or groups impacted by this action. This is an optional field and is filled for the following sharing activities: DOCUMENT_SHARED, DOCUMENT_SHARED, DOCUMENT_UNSHARED, FOLDER_SHARED, FOLDER_UNSHARED.
        public let participants: Participants?
        /// The metadata of the resource involved in the user action.
        public let resourceMetadata: ResourceMetadata?
        /// The timestamp when the action was performed.
        public let timeStamp: Date?
        /// The activity type.
        public let type: ActivityType?

        @inlinable
        public init(commentMetadata: CommentMetadata? = nil, initiator: UserMetadata? = nil, isIndirectActivity: Bool? = nil, organizationId: String? = nil, originalParent: ResourceMetadata? = nil, participants: Participants? = nil, resourceMetadata: ResourceMetadata? = nil, timeStamp: Date? = nil, type: ActivityType? = nil) {
            self.commentMetadata = commentMetadata
            self.initiator = initiator
            self.isIndirectActivity = isIndirectActivity
            self.organizationId = organizationId
            self.originalParent = originalParent
            self.participants = participants
            self.resourceMetadata = resourceMetadata
            self.timeStamp = timeStamp
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case commentMetadata = "CommentMetadata"
            case initiator = "Initiator"
            case isIndirectActivity = "IsIndirectActivity"
            case organizationId = "OrganizationId"
            case originalParent = "OriginalParent"
            case participants = "Participants"
            case resourceMetadata = "ResourceMetadata"
            case timeStamp = "TimeStamp"
            case type = "Type"
        }
    }

    public struct AddResourcePermissionsRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The notification options.
        public let notificationOptions: NotificationOptions?
        /// The users, groups, or organization being granted permission.
        public let principals: [SharePrincipal]
        /// The ID of the resource.
        public let resourceId: String

        @inlinable
        public init(authenticationToken: String? = nil, notificationOptions: NotificationOptions? = nil, principals: [SharePrincipal], resourceId: String) {
            self.authenticationToken = authenticationToken
            self.notificationOptions = notificationOptions
            self.principals = principals
            self.resourceId = resourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            try container.encodeIfPresent(self.notificationOptions, forKey: .notificationOptions)
            try container.encode(self.principals, forKey: .principals)
            request.encodePath(self.resourceId, key: "ResourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.notificationOptions?.validate(name: "\(name).notificationOptions")
            try self.principals.forEach {
                try $0.validate(name: "\(name).principals[]")
            }
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 128)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case notificationOptions = "NotificationOptions"
            case principals = "Principals"
        }
    }

    public struct AddResourcePermissionsResponse: AWSDecodableShape {
        /// The share results.
        public let shareResults: [ShareResult]?

        @inlinable
        public init(shareResults: [ShareResult]? = nil) {
            self.shareResults = shareResults
        }

        private enum CodingKeys: String, CodingKey {
            case shareResults = "ShareResults"
        }
    }

    public struct Comment: AWSDecodableShape {
        /// The ID of the comment.
        public let commentId: String
        /// The details of the user who made the comment.
        public let contributor: User?
        /// The time that the comment was created.
        public let createdTimestamp: Date?
        /// The ID of the parent comment.
        public let parentId: String?
        /// If the comment is a reply to another user's comment, this field contains the user ID of the user being replied to.
        public let recipientId: String?
        /// The status of the comment.
        public let status: CommentStatusType?
        /// The text of the comment.
        public let text: String?
        /// The ID of the root comment in the thread.
        public let threadId: String?
        /// The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
        public let visibility: CommentVisibilityType?

        @inlinable
        public init(commentId: String, contributor: User? = nil, createdTimestamp: Date? = nil, parentId: String? = nil, recipientId: String? = nil, status: CommentStatusType? = nil, text: String? = nil, threadId: String? = nil, visibility: CommentVisibilityType? = nil) {
            self.commentId = commentId
            self.contributor = contributor
            self.createdTimestamp = createdTimestamp
            self.parentId = parentId
            self.recipientId = recipientId
            self.status = status
            self.text = text
            self.threadId = threadId
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case commentId = "CommentId"
            case contributor = "Contributor"
            case createdTimestamp = "CreatedTimestamp"
            case parentId = "ParentId"
            case recipientId = "RecipientId"
            case status = "Status"
            case text = "Text"
            case threadId = "ThreadId"
            case visibility = "Visibility"
        }
    }

    public struct CommentMetadata: AWSDecodableShape {
        /// The ID of the comment.
        public let commentId: String?
        /// The status of the comment.
        public let commentStatus: CommentStatusType?
        /// The user who made the comment.
        public let contributor: User?
        /// The ID of the user who made the comment.
        public let contributorId: String?
        /// The timestamp that the comment was created.
        public let createdTimestamp: Date?
        /// The ID of the user being replied to.
        public let recipientId: String?

        @inlinable
        public init(commentId: String? = nil, commentStatus: CommentStatusType? = nil, contributor: User? = nil, contributorId: String? = nil, createdTimestamp: Date? = nil, recipientId: String? = nil) {
            self.commentId = commentId
            self.commentStatus = commentStatus
            self.contributor = contributor
            self.contributorId = contributorId
            self.createdTimestamp = createdTimestamp
            self.recipientId = recipientId
        }

        private enum CodingKeys: String, CodingKey {
            case commentId = "CommentId"
            case commentStatus = "CommentStatus"
            case contributor = "Contributor"
            case contributorId = "ContributorId"
            case createdTimestamp = "CreatedTimestamp"
            case recipientId = "RecipientId"
        }
    }

    public struct CreateCommentRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the document.
        public let documentId: String
        /// Set this parameter to TRUE to send an email out to the document collaborators after the comment is created.
        public let notifyCollaborators: Bool?
        /// The ID of the parent comment.
        public let parentId: String?
        /// The text of the comment.
        public let text: String
        /// The ID of the root comment in the thread.
        public let threadId: String?
        /// The ID of the document version.
        public let versionId: String
        /// The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
        public let visibility: CommentVisibilityType?

        @inlinable
        public init(authenticationToken: String? = nil, documentId: String, notifyCollaborators: Bool? = nil, parentId: String? = nil, text: String, threadId: String? = nil, versionId: String, visibility: CommentVisibilityType? = nil) {
            self.authenticationToken = authenticationToken
            self.documentId = documentId
            self.notifyCollaborators = notifyCollaborators
            self.parentId = parentId
            self.text = text
            self.threadId = threadId
            self.versionId = versionId
            self.visibility = visibility
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.documentId, key: "DocumentId")
            try container.encodeIfPresent(self.notifyCollaborators, forKey: .notifyCollaborators)
            try container.encodeIfPresent(self.parentId, forKey: .parentId)
            try container.encode(self.text, forKey: .text)
            try container.encodeIfPresent(self.threadId, forKey: .threadId)
            request.encodePath(self.versionId, key: "VersionId")
            try container.encodeIfPresent(self.visibility, forKey: .visibility)
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.parentId, name: "parentId", parent: name, max: 128)
            try self.validate(self.parentId, name: "parentId", parent: name, min: 1)
            try self.validate(self.parentId, name: "parentId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.text, name: "text", parent: name, max: 2048)
            try self.validate(self.text, name: "text", parent: name, min: 1)
            try self.validate(self.threadId, name: "threadId", parent: name, max: 128)
            try self.validate(self.threadId, name: "threadId", parent: name, min: 1)
            try self.validate(self.threadId, name: "threadId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 128)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case notifyCollaborators = "NotifyCollaborators"
            case parentId = "ParentId"
            case text = "Text"
            case threadId = "ThreadId"
            case visibility = "Visibility"
        }
    }

    public struct CreateCommentResponse: AWSDecodableShape {
        /// The comment that has been created.
        public let comment: Comment?

        @inlinable
        public init(comment: Comment? = nil) {
            self.comment = comment
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "Comment"
        }
    }

    public struct CreateCustomMetadataRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// Custom metadata in the form of name-value pairs.
        public let customMetadata: [String: String]
        /// The ID of the resource.
        public let resourceId: String
        /// The ID of the version, if the custom metadata is being added to a document version.
        public let versionId: String?

        @inlinable
        public init(authenticationToken: String? = nil, customMetadata: [String: String], resourceId: String, versionId: String? = nil) {
            self.authenticationToken = authenticationToken
            self.customMetadata = customMetadata
            self.resourceId = resourceId
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            try container.encode(self.customMetadata, forKey: .customMetadata)
            request.encodePath(self.resourceId, key: "ResourceId")
            request.encodeQuery(self.versionId, key: "versionid")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.customMetadata.forEach {
                try validate($0.key, name: "customMetadata.key", parent: name, max: 56)
                try validate($0.key, name: "customMetadata.key", parent: name, min: 1)
                try validate($0.key, name: "customMetadata.key", parent: name, pattern: "^[a-zA-Z0-9._+-/=][a-zA-Z0-9 ._+-/=]*$")
                try validate($0.value, name: "customMetadata[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "customMetadata[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "customMetadata[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9._+-/=][a-zA-Z0-9 ._+-/=]*$")
            }
            try self.validate(self.customMetadata, name: "customMetadata", parent: name, max: 8)
            try self.validate(self.customMetadata, name: "customMetadata", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 128)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 128)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customMetadata = "CustomMetadata"
        }
    }

    public struct CreateCustomMetadataResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateFolderRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The name of the new folder.
        public let name: String?
        /// The ID of the parent folder.
        public let parentFolderId: String

        @inlinable
        public init(authenticationToken: String? = nil, name: String? = nil, parentFolderId: String) {
            self.authenticationToken = authenticationToken
            self.name = name
            self.parentFolderId = parentFolderId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encode(self.parentFolderId, forKey: .parentFolderId)
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\u202D\\u202F-\\uFFFF]+$")
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, max: 128)
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, min: 1)
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case parentFolderId = "ParentFolderId"
        }
    }

    public struct CreateFolderResponse: AWSDecodableShape {
        /// The metadata of the folder.
        public let metadata: FolderMetadata?

        @inlinable
        public init(metadata: FolderMetadata? = nil) {
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
        }
    }

    public struct CreateLabelsRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// List of labels to add to the resource.
        public let labels: [String]
        /// The ID of the resource.
        public let resourceId: String

        @inlinable
        public init(authenticationToken: String? = nil, labels: [String], resourceId: String) {
            self.authenticationToken = authenticationToken
            self.labels = labels
            self.resourceId = resourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            try container.encode(self.labels, forKey: .labels)
            request.encodePath(self.resourceId, key: "ResourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.labels.forEach {
                try validate($0, name: "labels[]", parent: name, max: 32)
                try validate($0, name: "labels[]", parent: name, min: 1)
                try validate($0, name: "labels[]", parent: name, pattern: "^[a-zA-Z0-9._+-/=][a-zA-Z0-9 ._+-/=]*$")
            }
            try self.validate(self.labels, name: "labels", parent: name, max: 20)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 128)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case labels = "Labels"
        }
    }

    public struct CreateLabelsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateNotificationSubscriptionRequest: AWSEncodableShape {
        /// The endpoint to receive the notifications. If the protocol is HTTPS, the endpoint is a URL that begins with https.
        public let endpoint: String
        /// The ID of the organization.
        public let organizationId: String
        /// The protocol to use. The supported value is https, which delivers JSON-encoded messages using HTTPS POST.
        public let `protocol`: SubscriptionProtocolType
        /// The notification type.
        public let subscriptionType: SubscriptionType

        @inlinable
        public init(endpoint: String, organizationId: String, protocol: SubscriptionProtocolType, subscriptionType: SubscriptionType) {
            self.endpoint = endpoint
            self.organizationId = organizationId
            self.`protocol` = `protocol`
            self.subscriptionType = subscriptionType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.endpoint, forKey: .endpoint)
            request.encodePath(self.organizationId, key: "OrganizationId")
            try container.encode(self.`protocol`, forKey: .`protocol`)
            try container.encode(self.subscriptionType, forKey: .subscriptionType)
        }

        public func validate(name: String) throws {
            try self.validate(self.endpoint, name: "endpoint", parent: name, max: 256)
            try self.validate(self.endpoint, name: "endpoint", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 256)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^[&\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
            case `protocol` = "Protocol"
            case subscriptionType = "SubscriptionType"
        }
    }

    public struct CreateNotificationSubscriptionResponse: AWSDecodableShape {
        /// The subscription.
        public let subscription: Subscription?

        @inlinable
        public init(subscription: Subscription? = nil) {
            self.subscription = subscription
        }

        private enum CodingKeys: String, CodingKey {
            case subscription = "Subscription"
        }
    }

    public struct CreateUserRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The email address of the user.
        public let emailAddress: String?
        /// The given name of the user.
        public let givenName: String
        /// The ID of the organization.
        public let organizationId: String?
        /// The password of the user.
        public let password: String
        /// The amount of storage for the user.
        public let storageRule: StorageRuleType?
        /// The surname of the user.
        public let surname: String
        /// The time zone ID of the user.
        public let timeZoneId: String?
        /// The login name of the user.
        public let username: String

        @inlinable
        public init(authenticationToken: String? = nil, emailAddress: String? = nil, givenName: String, organizationId: String? = nil, password: String, storageRule: StorageRuleType? = nil, surname: String, timeZoneId: String? = nil, username: String) {
            self.authenticationToken = authenticationToken
            self.emailAddress = emailAddress
            self.givenName = givenName
            self.organizationId = organizationId
            self.password = password
            self.storageRule = storageRule
            self.surname = surname
            self.timeZoneId = timeZoneId
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            try container.encodeIfPresent(self.emailAddress, forKey: .emailAddress)
            try container.encode(self.givenName, forKey: .givenName)
            try container.encodeIfPresent(self.organizationId, forKey: .organizationId)
            try container.encode(self.password, forKey: .password)
            try container.encodeIfPresent(self.storageRule, forKey: .storageRule)
            try container.encode(self.surname, forKey: .surname)
            try container.encodeIfPresent(self.timeZoneId, forKey: .timeZoneId)
            try container.encode(self.username, forKey: .username)
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 256)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 1)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$")
            try self.validate(self.givenName, name: "givenName", parent: name, max: 64)
            try self.validate(self.givenName, name: "givenName", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 256)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.password, name: "password", parent: name, max: 32)
            try self.validate(self.password, name: "password", parent: name, min: 4)
            try self.validate(self.password, name: "password", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.storageRule?.validate(name: "\(name).storageRule")
            try self.validate(self.surname, name: "surname", parent: name, max: 64)
            try self.validate(self.surname, name: "surname", parent: name, min: 1)
            try self.validate(self.timeZoneId, name: "timeZoneId", parent: name, max: 256)
            try self.validate(self.timeZoneId, name: "timeZoneId", parent: name, min: 1)
            try self.validate(self.username, name: "username", parent: name, max: 256)
            try self.validate(self.username, name: "username", parent: name, min: 1)
            try self.validate(self.username, name: "username", parent: name, pattern: "^[\\w\\-+.]+(@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]+)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case emailAddress = "EmailAddress"
            case givenName = "GivenName"
            case organizationId = "OrganizationId"
            case password = "Password"
            case storageRule = "StorageRule"
            case surname = "Surname"
            case timeZoneId = "TimeZoneId"
            case username = "Username"
        }
    }

    public struct CreateUserResponse: AWSDecodableShape {
        /// The user information.
        public let user: User?

        @inlinable
        public init(user: User? = nil) {
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case user = "User"
        }
    }

    public struct DateRangeType: AWSEncodableShape {
        /// Timestamp range end value (in epochs).
        public let endValue: Date?
        /// Timestamp range start value (in epochs)
        public let startValue: Date?

        @inlinable
        public init(endValue: Date? = nil, startValue: Date? = nil) {
            self.endValue = endValue
            self.startValue = startValue
        }

        private enum CodingKeys: String, CodingKey {
            case endValue = "EndValue"
            case startValue = "StartValue"
        }
    }

    public struct DeactivateUserRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the user.
        public let userId: String

        @inlinable
        public init(authenticationToken: String? = nil, userId: String) {
            self.authenticationToken = authenticationToken
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[&\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeactivatingLastSystemUserException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct DeleteCommentRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the comment.
        public let commentId: String
        /// The ID of the document.
        public let documentId: String
        /// The ID of the document version.
        public let versionId: String

        @inlinable
        public init(authenticationToken: String? = nil, commentId: String, documentId: String, versionId: String) {
            self.authenticationToken = authenticationToken
            self.commentId = commentId
            self.documentId = documentId
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.commentId, key: "CommentId")
            request.encodePath(self.documentId, key: "DocumentId")
            request.encodePath(self.versionId, key: "VersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.commentId, name: "commentId", parent: name, max: 128)
            try self.validate(self.commentId, name: "commentId", parent: name, min: 1)
            try self.validate(self.commentId, name: "commentId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 128)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCustomMetadataRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// Flag to indicate removal of all custom metadata properties from the specified resource.
        public let deleteAll: Bool?
        /// List of properties to remove.
        public let keys: [String]?
        /// The ID of the resource, either a document or folder.
        public let resourceId: String
        /// The ID of the version, if the custom metadata is being deleted from a document version.
        public let versionId: String?

        @inlinable
        public init(authenticationToken: String? = nil, deleteAll: Bool? = nil, keys: [String]? = nil, resourceId: String, versionId: String? = nil) {
            self.authenticationToken = authenticationToken
            self.deleteAll = deleteAll
            self.keys = keys
            self.resourceId = resourceId
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodeQuery(self.deleteAll, key: "deleteAll")
            request.encodeQuery(self.keys, key: "keys")
            request.encodePath(self.resourceId, key: "ResourceId")
            request.encodeQuery(self.versionId, key: "versionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.keys?.forEach {
                try validate($0, name: "keys[]", parent: name, max: 56)
                try validate($0, name: "keys[]", parent: name, min: 1)
                try validate($0, name: "keys[]", parent: name, pattern: "^[a-zA-Z0-9._+-/=][a-zA-Z0-9 ._+-/=]*$")
            }
            try self.validate(self.keys, name: "keys", parent: name, max: 8)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 128)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 128)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCustomMetadataResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDocumentRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the document.
        public let documentId: String

        @inlinable
        public init(authenticationToken: String? = nil, documentId: String) {
            self.authenticationToken = authenticationToken
            self.documentId = documentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.documentId, key: "DocumentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDocumentVersionRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// Deletes all versions of a document prior to the current version.
        public let deletePriorVersions: Bool
        /// The ID of the document associated with the version being deleted.
        public let documentId: String
        /// The ID of the version being deleted.
        public let versionId: String

        @inlinable
        public init(authenticationToken: String? = nil, deletePriorVersions: Bool = false, documentId: String, versionId: String) {
            self.authenticationToken = authenticationToken
            self.deletePriorVersions = deletePriorVersions
            self.documentId = documentId
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodeQuery(self.deletePriorVersions, key: "deletePriorVersions")
            request.encodePath(self.documentId, key: "DocumentId")
            request.encodePath(self.versionId, key: "VersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 128)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFolderContentsRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the folder.
        public let folderId: String

        @inlinable
        public init(authenticationToken: String? = nil, folderId: String) {
            self.authenticationToken = authenticationToken
            self.folderId = folderId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.folderId, key: "FolderId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, max: 128)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFolderRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the folder.
        public let folderId: String

        @inlinable
        public init(authenticationToken: String? = nil, folderId: String) {
            self.authenticationToken = authenticationToken
            self.folderId = folderId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.folderId, key: "FolderId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, max: 128)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLabelsRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// Flag to request removal of all labels from the specified resource.
        public let deleteAll: Bool?
        /// List of labels to delete from the resource.
        public let labels: [String]?
        /// The ID of the resource.
        public let resourceId: String

        @inlinable
        public init(authenticationToken: String? = nil, deleteAll: Bool? = nil, labels: [String]? = nil, resourceId: String) {
            self.authenticationToken = authenticationToken
            self.deleteAll = deleteAll
            self.labels = labels
            self.resourceId = resourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodeQuery(self.deleteAll, key: "deleteAll")
            request.encodeQuery(self.labels, key: "labels")
            request.encodePath(self.resourceId, key: "ResourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.labels?.forEach {
                try validate($0, name: "labels[]", parent: name, max: 32)
                try validate($0, name: "labels[]", parent: name, min: 1)
                try validate($0, name: "labels[]", parent: name, pattern: "^[a-zA-Z0-9._+-/=][a-zA-Z0-9 ._+-/=]*$")
            }
            try self.validate(self.labels, name: "labels", parent: name, max: 20)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 128)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLabelsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteNotificationSubscriptionRequest: AWSEncodableShape {
        /// The ID of the organization.
        public let organizationId: String
        /// The ID of the subscription.
        public let subscriptionId: String

        @inlinable
        public init(organizationId: String, subscriptionId: String) {
            self.organizationId = organizationId
            self.subscriptionId = subscriptionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.organizationId, key: "OrganizationId")
            request.encodePath(self.subscriptionId, key: "SubscriptionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 256)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.subscriptionId, name: "subscriptionId", parent: name, max: 256)
            try self.validate(self.subscriptionId, name: "subscriptionId", parent: name, min: 1)
            try self.validate(self.subscriptionId, name: "subscriptionId", parent: name, pattern: "^[&\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Do not set this field when using administrative API actions, as in accessing the API using Amazon Web Services credentials.
        public let authenticationToken: String?
        /// The ID of the user.
        public let userId: String

        @inlinable
        public init(authenticationToken: String? = nil, userId: String) {
            self.authenticationToken = authenticationToken
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[&\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeActivitiesRequest: AWSEncodableShape {
        /// Specifies which activity types to include in the response. If this field is left empty, all activity types are returned.
        public let activityTypes: String?
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The timestamp that determines the end time of the activities. The response includes the activities performed before the specified timestamp.
        public let endTime: Date?
        /// Includes indirect activities. An indirect activity results from a direct activity performed on a parent resource. For example, sharing a parent folder (the direct activity) shares all of the subfolders and documents within the parent folder (the indirect activity).
        public let includeIndirectActivities: Bool?
        /// The maximum number of items to return.
        public let limit: Int?
        /// The marker for the next set of results.
        public let marker: String?
        /// The ID of the organization. This is a mandatory parameter when using administrative API (SigV4) requests.
        public let organizationId: String?
        /// The document or folder ID for which to describe activity types.
        public let resourceId: String?
        /// The timestamp that determines the starting time of the activities. The response includes the activities performed after the specified timestamp.
        public let startTime: Date?
        /// The ID of the user who performed the action. The response includes activities pertaining to this user. This is an optional parameter and is only applicable for administrative API (SigV4) requests.
        public let userId: String?

        @inlinable
        public init(activityTypes: String? = nil, authenticationToken: String? = nil, endTime: Date? = nil, includeIndirectActivities: Bool? = nil, limit: Int? = nil, marker: String? = nil, organizationId: String? = nil, resourceId: String? = nil, startTime: Date? = nil, userId: String? = nil) {
            self.activityTypes = activityTypes
            self.authenticationToken = authenticationToken
            self.endTime = endTime
            self.includeIndirectActivities = includeIndirectActivities
            self.limit = limit
            self.marker = marker
            self.organizationId = organizationId
            self.resourceId = resourceId
            self.startTime = startTime
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.activityTypes, key: "activityTypes")
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodeQuery(self.endTime, key: "endTime")
            request.encodeQuery(self.includeIndirectActivities, key: "includeIndirectActivities")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
            request.encodeQuery(self.organizationId, key: "organizationId")
            request.encodeQuery(self.resourceId, key: "resourceId")
            request.encodeQuery(self.startTime, key: "startTime")
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.activityTypes, name: "activityTypes", parent: name, max: 1024)
            try self.validate(self.activityTypes, name: "activityTypes", parent: name, min: 1)
            try self.validate(self.activityTypes, name: "activityTypes", parent: name, pattern: "^[\\w,]+$")
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 999)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 12288)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, pattern: "^[\\u0000-\\u00FF]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 256)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 256)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[&\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeActivitiesResponse: AWSDecodableShape {
        /// The marker for the next set of results.
        public let marker: String?
        /// The list of activities for the specified user and time period.
        public let userActivities: [Activity]?

        @inlinable
        public init(marker: String? = nil, userActivities: [Activity]? = nil) {
            self.marker = marker
            self.userActivities = userActivities
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case userActivities = "UserActivities"
        }
    }

    public struct DescribeCommentsRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the document.
        public let documentId: String
        /// The maximum number of items to return.
        public let limit: Int?
        /// The marker for the next set of results. This marker was received from a previous call.
        public let marker: String?
        /// The ID of the document version.
        public let versionId: String

        @inlinable
        public init(authenticationToken: String? = nil, documentId: String, limit: Int? = nil, marker: String? = nil, versionId: String) {
            self.authenticationToken = authenticationToken
            self.documentId = documentId
            self.limit = limit
            self.marker = marker
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.documentId, key: "DocumentId")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
            request.encodePath(self.versionId, key: "VersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.limit, name: "limit", parent: name, max: 999)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, pattern: "^[\\u0000-\\u00FF]+$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 128)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCommentsResponse: AWSDecodableShape {
        /// The list of comments for the specified document version.
        public let comments: [Comment]?
        /// The marker for the next set of results. This marker was received from a previous call.
        public let marker: String?

        @inlinable
        public init(comments: [Comment]? = nil, marker: String? = nil) {
            self.comments = comments
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case comments = "Comments"
            case marker = "Marker"
        }
    }

    public struct DescribeDocumentVersionsRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the document.
        public let documentId: String
        /// Specify "SOURCE" to include initialized versions and a URL for the source document.
        public let fields: String?
        /// A comma-separated list of values. Specify "INITIALIZED" to include incomplete versions.
        public let include: String?
        /// The maximum number of versions to return with this call.
        public let limit: Int?
        /// The marker for the next set of results. (You received this marker from a previous call.)
        public let marker: String?

        @inlinable
        public init(authenticationToken: String? = nil, documentId: String, fields: String? = nil, include: String? = nil, limit: Int? = nil, marker: String? = nil) {
            self.authenticationToken = authenticationToken
            self.documentId = documentId
            self.fields = fields
            self.include = include
            self.limit = limit
            self.marker = marker
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.documentId, key: "DocumentId")
            request.encodeQuery(self.fields, key: "fields")
            request.encodeQuery(self.include, key: "include")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.fields, name: "fields", parent: name, max: 256)
            try self.validate(self.fields, name: "fields", parent: name, min: 1)
            try self.validate(self.fields, name: "fields", parent: name, pattern: "^[\\w,]+$")
            try self.validate(self.include, name: "include", parent: name, max: 256)
            try self.validate(self.include, name: "include", parent: name, min: 1)
            try self.validate(self.include, name: "include", parent: name, pattern: "^[\\w,]+$")
            try self.validate(self.limit, name: "limit", parent: name, max: 999)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDocumentVersionsResponse: AWSDecodableShape {
        /// The document versions.
        public let documentVersions: [DocumentVersionMetadata]?
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?

        @inlinable
        public init(documentVersions: [DocumentVersionMetadata]? = nil, marker: String? = nil) {
            self.documentVersions = documentVersions
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case documentVersions = "DocumentVersions"
            case marker = "Marker"
        }
    }

    public struct DescribeFolderContentsRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the folder.
        public let folderId: String
        /// The contents to include. Specify "INITIALIZED" to include initialized documents.
        public let include: String?
        /// The maximum number of items to return with this call.
        public let limit: Int?
        /// The marker for the next set of results. This marker was received from a previous call.
        public let marker: String?
        /// The order for the contents of the folder.
        public let order: OrderType?
        /// The sorting criteria.
        public let sort: ResourceSortType?
        /// The type of items.
        public let type: FolderContentType?

        @inlinable
        public init(authenticationToken: String? = nil, folderId: String, include: String? = nil, limit: Int? = nil, marker: String? = nil, order: OrderType? = nil, sort: ResourceSortType? = nil, type: FolderContentType? = nil) {
            self.authenticationToken = authenticationToken
            self.folderId = folderId
            self.include = include
            self.limit = limit
            self.marker = marker
            self.order = order
            self.sort = sort
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.folderId, key: "FolderId")
            request.encodeQuery(self.include, key: "include")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
            request.encodeQuery(self.order, key: "order")
            request.encodeQuery(self.sort, key: "sort")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, max: 128)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.include, name: "include", parent: name, max: 256)
            try self.validate(self.include, name: "include", parent: name, min: 1)
            try self.validate(self.include, name: "include", parent: name, pattern: "^[\\w,]+$")
            try self.validate(self.limit, name: "limit", parent: name, max: 999)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFolderContentsResponse: AWSDecodableShape {
        /// The documents in the specified folder.
        public let documents: [DocumentMetadata]?
        /// The subfolders in the specified folder.
        public let folders: [FolderMetadata]?
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?

        @inlinable
        public init(documents: [DocumentMetadata]? = nil, folders: [FolderMetadata]? = nil, marker: String? = nil) {
            self.documents = documents
            self.folders = folders
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case documents = "Documents"
            case folders = "Folders"
            case marker = "Marker"
        }
    }

    public struct DescribeGroupsRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The maximum number of items to return with this call.
        public let limit: Int?
        /// The marker for the next set of results. (You received this marker from a previous call.)
        public let marker: String?
        /// The ID of the organization.
        public let organizationId: String?
        /// A query to describe groups by group name.
        public let searchQuery: String

        @inlinable
        public init(authenticationToken: String? = nil, limit: Int? = nil, marker: String? = nil, organizationId: String? = nil, searchQuery: String) {
            self.authenticationToken = authenticationToken
            self.limit = limit
            self.marker = marker
            self.organizationId = organizationId
            self.searchQuery = searchQuery
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
            request.encodeQuery(self.organizationId, key: "organizationId")
            request.encodeQuery(self.searchQuery, key: "searchQuery")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, pattern: "^[\\u0000-\\u00FF]+$")
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 256)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.searchQuery, name: "searchQuery", parent: name, max: 512)
            try self.validate(self.searchQuery, name: "searchQuery", parent: name, min: 1)
            try self.validate(self.searchQuery, name: "searchQuery", parent: name, pattern: "^[\\u0020-\\uFFFF]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGroupsResponse: AWSDecodableShape {
        /// The list of groups.
        public let groups: [GroupMetadata]?
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?

        @inlinable
        public init(groups: [GroupMetadata]? = nil, marker: String? = nil) {
            self.groups = groups
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case marker = "Marker"
        }
    }

    public struct DescribeNotificationSubscriptionsRequest: AWSEncodableShape {
        /// The maximum number of items to return with this call.
        public let limit: Int?
        /// The marker for the next set of results. (You received this marker from a previous call.)
        public let marker: String?
        /// The ID of the organization.
        public let organizationId: String

        @inlinable
        public init(limit: Int? = nil, marker: String? = nil, organizationId: String) {
            self.limit = limit
            self.marker = marker
            self.organizationId = organizationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
            request.encodePath(self.organizationId, key: "OrganizationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 999)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 256)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^[&\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeNotificationSubscriptionsResponse: AWSDecodableShape {
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?
        /// The subscriptions.
        public let subscriptions: [Subscription]?

        @inlinable
        public init(marker: String? = nil, subscriptions: [Subscription]? = nil) {
            self.marker = marker
            self.subscriptions = subscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case subscriptions = "Subscriptions"
        }
    }

    public struct DescribeResourcePermissionsRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The maximum number of items to return with this call.
        public let limit: Int?
        /// The marker for the next set of results. (You received this marker from a previous call)
        public let marker: String?
        /// The ID of the principal to filter permissions by.
        public let principalId: String?
        /// The ID of the resource.
        public let resourceId: String

        @inlinable
        public init(authenticationToken: String? = nil, limit: Int? = nil, marker: String? = nil, principalId: String? = nil, resourceId: String) {
            self.authenticationToken = authenticationToken
            self.limit = limit
            self.marker = marker
            self.principalId = principalId
            self.resourceId = resourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
            request.encodeQuery(self.principalId, key: "principalId")
            request.encodePath(self.resourceId, key: "ResourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 999)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, max: 256)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 128)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeResourcePermissionsResponse: AWSDecodableShape {
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?
        /// The principals.
        public let principals: [Principal]?

        @inlinable
        public init(marker: String? = nil, principals: [Principal]? = nil) {
            self.marker = marker
            self.principals = principals
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case principals = "Principals"
        }
    }

    public struct DescribeRootFoldersRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token.
        public let authenticationToken: String
        /// The maximum number of items to return.
        public let limit: Int?
        /// The marker for the next set of results. (You received this marker from a previous call.)
        public let marker: String?

        @inlinable
        public init(authenticationToken: String, limit: Int? = nil, marker: String? = nil) {
            self.authenticationToken = authenticationToken
            self.limit = limit
            self.marker = marker
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 999)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRootFoldersResponse: AWSDecodableShape {
        /// The user's special folders.
        public let folders: [FolderMetadata]?
        /// The marker for the next set of results.
        public let marker: String?

        @inlinable
        public init(folders: [FolderMetadata]? = nil, marker: String? = nil) {
            self.folders = folders
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case folders = "Folders"
            case marker = "Marker"
        }
    }

    public struct DescribeUsersRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// A comma-separated list of values. Specify "STORAGE_METADATA" to include the user storage quota and utilization information.
        public let fields: String?
        /// The state of the users. Specify "ALL" to include inactive users.
        public let include: UserFilterType?
        /// The maximum number of items to return.
        public let limit: Int?
        /// The marker for the next set of results. (You received this marker from a previous call.)
        public let marker: String?
        /// The order for the results.
        public let order: OrderType?
        /// The ID of the organization.
        public let organizationId: String?
        /// A query to filter users by user name. Remember the following about the Userids and Query parameters:   If you don't use either parameter, the API returns a paginated list of all users on the site.   If you use both parameters, the API ignores the Query parameter.   The Userid parameter only returns user names that match a corresponding user ID.   The Query parameter runs a "prefix" search for users by the GivenName, SurName, or UserName fields included in a  CreateUser API call. For example, querying on  Ma returns Mrcia Oliveira, Mara Garca, and Mateo Jackson. If you use multiple characters, the API only returns data that matches all characters. For example, querying on Ma J only  returns Mateo Jackson.
        public let query: String?
        /// The sorting criteria.
        public let sort: UserSortType?
        /// The IDs of the users.
        public let userIds: String?

        @inlinable
        public init(authenticationToken: String? = nil, fields: String? = nil, include: UserFilterType? = nil, limit: Int? = nil, marker: String? = nil, order: OrderType? = nil, organizationId: String? = nil, query: String? = nil, sort: UserSortType? = nil, userIds: String? = nil) {
            self.authenticationToken = authenticationToken
            self.fields = fields
            self.include = include
            self.limit = limit
            self.marker = marker
            self.order = order
            self.organizationId = organizationId
            self.query = query
            self.sort = sort
            self.userIds = userIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodeQuery(self.fields, key: "fields")
            request.encodeQuery(self.include, key: "include")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
            request.encodeQuery(self.order, key: "order")
            request.encodeQuery(self.organizationId, key: "organizationId")
            request.encodeQuery(self.query, key: "query")
            request.encodeQuery(self.sort, key: "sort")
            request.encodeQuery(self.userIds, key: "userIds")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.fields, name: "fields", parent: name, max: 256)
            try self.validate(self.fields, name: "fields", parent: name, min: 1)
            try self.validate(self.fields, name: "fields", parent: name, pattern: "^[\\w,]+$")
            try self.validate(self.limit, name: "limit", parent: name, max: 999)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 256)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.query, name: "query", parent: name, max: 512)
            try self.validate(self.query, name: "query", parent: name, min: 1)
            try self.validate(self.query, name: "query", parent: name, pattern: "^[\\u0020-\\uFFFF]+$")
            try self.validate(self.userIds, name: "userIds", parent: name, max: 2000)
            try self.validate(self.userIds, name: "userIds", parent: name, min: 1)
            try self.validate(self.userIds, name: "userIds", parent: name, pattern: "^[&\\w+-.@, ]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUsersResponse: AWSDecodableShape {
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?
        /// The total number of users included in the results.
        public let totalNumberOfUsers: Int64?
        /// The users.
        public let users: [User]?

        @inlinable
        public init(marker: String? = nil, users: [User]? = nil) {
            self.marker = marker
            self.totalNumberOfUsers = nil
            self.users = users
        }

        @available(*, deprecated, message: "Members totalNumberOfUsers have been deprecated")
        @inlinable
        public init(marker: String? = nil, totalNumberOfUsers: Int64? = nil, users: [User]? = nil) {
            self.marker = marker
            self.totalNumberOfUsers = totalNumberOfUsers
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case totalNumberOfUsers = "TotalNumberOfUsers"
            case users = "Users"
        }
    }

    public struct DocumentMetadata: AWSDecodableShape {
        /// The time when the document was created.
        public let createdTimestamp: Date?
        /// The ID of the creator.
        public let creatorId: String?
        /// The ID of the document.
        public let id: String?
        /// List of labels on the document.
        public let labels: [String]?
        /// The latest version of the document.
        public let latestVersionMetadata: DocumentVersionMetadata?
        /// The time when the document was updated.
        public let modifiedTimestamp: Date?
        /// The ID of the parent folder.
        public let parentFolderId: String?
        /// The resource state.
        public let resourceState: ResourceStateType?

        @inlinable
        public init(createdTimestamp: Date? = nil, creatorId: String? = nil, id: String? = nil, labels: [String]? = nil, latestVersionMetadata: DocumentVersionMetadata? = nil, modifiedTimestamp: Date? = nil, parentFolderId: String? = nil, resourceState: ResourceStateType? = nil) {
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.labels = labels
            self.latestVersionMetadata = latestVersionMetadata
            self.modifiedTimestamp = modifiedTimestamp
            self.parentFolderId = parentFolderId
            self.resourceState = resourceState
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case creatorId = "CreatorId"
            case id = "Id"
            case labels = "Labels"
            case latestVersionMetadata = "LatestVersionMetadata"
            case modifiedTimestamp = "ModifiedTimestamp"
            case parentFolderId = "ParentFolderId"
            case resourceState = "ResourceState"
        }
    }

    public struct DocumentVersionMetadata: AWSDecodableShape {
        /// The timestamp when the content of the document was originally created.
        public let contentCreatedTimestamp: Date?
        /// The timestamp when the content of the document was modified.
        public let contentModifiedTimestamp: Date?
        /// The content type of the document.
        public let contentType: String?
        /// The timestamp when the document was first uploaded.
        public let createdTimestamp: Date?
        /// The ID of the creator.
        public let creatorId: String?
        /// The ID of the version.
        public let id: String?
        /// The timestamp when the document was last uploaded.
        public let modifiedTimestamp: Date?
        /// The name of the version.
        public let name: String?
        /// The signature of the document.
        public let signature: String?
        /// The size of the document, in bytes.
        public let size: Int64?
        /// The source of the document.
        public let source: [DocumentSourceType: String]?
        /// The status of the document.
        public let status: DocumentStatusType?
        /// The thumbnail of the document.
        public let thumbnail: [DocumentThumbnailType: String]?

        @inlinable
        public init(contentCreatedTimestamp: Date? = nil, contentModifiedTimestamp: Date? = nil, contentType: String? = nil, createdTimestamp: Date? = nil, creatorId: String? = nil, id: String? = nil, modifiedTimestamp: Date? = nil, name: String? = nil, signature: String? = nil, size: Int64? = nil, source: [DocumentSourceType: String]? = nil, status: DocumentStatusType? = nil, thumbnail: [DocumentThumbnailType: String]? = nil) {
            self.contentCreatedTimestamp = contentCreatedTimestamp
            self.contentModifiedTimestamp = contentModifiedTimestamp
            self.contentType = contentType
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.modifiedTimestamp = modifiedTimestamp
            self.name = name
            self.signature = signature
            self.size = size
            self.source = source
            self.status = status
            self.thumbnail = thumbnail
        }

        private enum CodingKeys: String, CodingKey {
            case contentCreatedTimestamp = "ContentCreatedTimestamp"
            case contentModifiedTimestamp = "ContentModifiedTimestamp"
            case contentType = "ContentType"
            case createdTimestamp = "CreatedTimestamp"
            case creatorId = "CreatorId"
            case id = "Id"
            case modifiedTimestamp = "ModifiedTimestamp"
            case name = "Name"
            case signature = "Signature"
            case size = "Size"
            case source = "Source"
            case status = "Status"
            case thumbnail = "Thumbnail"
        }
    }

    public struct EntityNotExistsException: AWSErrorShape {
        /// The IDs of the non-existent resources.
        public let entityIds: [String]?
        public let message: String?

        @inlinable
        public init(entityIds: [String]? = nil, message: String? = nil) {
            self.entityIds = entityIds
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case entityIds = "EntityIds"
            case message = "Message"
        }
    }

    public struct Filters: AWSEncodableShape {
        /// Filter based on resources path.
        public let ancestorIds: [String]?
        /// Filters by content category.
        public let contentCategories: [ContentCategoryType]?
        /// Filter based on resources creation timestamp.
        public let createdRange: DateRangeType?
        /// Filter by labels using exact match.
        public let labels: [String]?
        /// Filter based on resources modified timestamp.
        public let modifiedRange: DateRangeType?
        /// Filter based on UserIds or GroupIds.
        public let principals: [SearchPrincipalType]?
        /// Filters based on entity type.
        public let resourceTypes: [SearchResourceType]?
        /// Filter based on file groupings.
        public let searchCollectionTypes: [SearchCollectionType]?
        /// Filter based on size (in bytes).
        public let sizeRange: LongRangeType?
        /// Filters by the locale of the content or comment.
        public let textLocales: [LanguageCodeType]?

        @inlinable
        public init(ancestorIds: [String]? = nil, contentCategories: [ContentCategoryType]? = nil, createdRange: DateRangeType? = nil, labels: [String]? = nil, modifiedRange: DateRangeType? = nil, principals: [SearchPrincipalType]? = nil, resourceTypes: [SearchResourceType]? = nil, searchCollectionTypes: [SearchCollectionType]? = nil, sizeRange: LongRangeType? = nil, textLocales: [LanguageCodeType]? = nil) {
            self.ancestorIds = ancestorIds
            self.contentCategories = contentCategories
            self.createdRange = createdRange
            self.labels = labels
            self.modifiedRange = modifiedRange
            self.principals = principals
            self.resourceTypes = resourceTypes
            self.searchCollectionTypes = searchCollectionTypes
            self.sizeRange = sizeRange
            self.textLocales = textLocales
        }

        public func validate(name: String) throws {
            try self.ancestorIds?.forEach {
                try validate($0, name: "ancestorIds[]", parent: name, max: 128)
                try validate($0, name: "ancestorIds[]", parent: name, min: 1)
            }
            try self.validate(self.ancestorIds, name: "ancestorIds", parent: name, max: 10)
            try self.validate(self.contentCategories, name: "contentCategories", parent: name, max: 9)
            try self.labels?.forEach {
                try validate($0, name: "labels[]", parent: name, max: 128)
                try validate($0, name: "labels[]", parent: name, min: 1)
            }
            try self.validate(self.labels, name: "labels", parent: name, max: 10)
            try self.principals?.forEach {
                try $0.validate(name: "\(name).principals[]")
            }
            try self.validate(self.principals, name: "principals", parent: name, max: 10)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 4)
            try self.validate(self.searchCollectionTypes, name: "searchCollectionTypes", parent: name, max: 2)
            try self.validate(self.textLocales, name: "textLocales", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ancestorIds = "AncestorIds"
            case contentCategories = "ContentCategories"
            case createdRange = "CreatedRange"
            case labels = "Labels"
            case modifiedRange = "ModifiedRange"
            case principals = "Principals"
            case resourceTypes = "ResourceTypes"
            case searchCollectionTypes = "SearchCollectionTypes"
            case sizeRange = "SizeRange"
            case textLocales = "TextLocales"
        }
    }

    public struct FolderMetadata: AWSDecodableShape {
        /// The time when the folder was created.
        public let createdTimestamp: Date?
        /// The ID of the creator.
        public let creatorId: String?
        /// The ID of the folder.
        public let id: String?
        /// List of labels on the folder.
        public let labels: [String]?
        /// The size of the latest version of the folder metadata.
        public let latestVersionSize: Int64?
        /// The time when the folder was updated.
        public let modifiedTimestamp: Date?
        /// The name of the folder.
        public let name: String?
        /// The ID of the parent folder.
        public let parentFolderId: String?
        /// The resource state of the folder.
        public let resourceState: ResourceStateType?
        /// The unique identifier created from the subfolders and documents of the folder.
        public let signature: String?
        /// The size of the folder metadata.
        public let size: Int64?

        @inlinable
        public init(createdTimestamp: Date? = nil, creatorId: String? = nil, id: String? = nil, labels: [String]? = nil, latestVersionSize: Int64? = nil, modifiedTimestamp: Date? = nil, name: String? = nil, parentFolderId: String? = nil, resourceState: ResourceStateType? = nil, signature: String? = nil, size: Int64? = nil) {
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.labels = labels
            self.latestVersionSize = latestVersionSize
            self.modifiedTimestamp = modifiedTimestamp
            self.name = name
            self.parentFolderId = parentFolderId
            self.resourceState = resourceState
            self.signature = signature
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case creatorId = "CreatorId"
            case id = "Id"
            case labels = "Labels"
            case latestVersionSize = "LatestVersionSize"
            case modifiedTimestamp = "ModifiedTimestamp"
            case name = "Name"
            case parentFolderId = "ParentFolderId"
            case resourceState = "ResourceState"
            case signature = "Signature"
            case size = "Size"
        }
    }

    public struct GetCurrentUserRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token.
        public let authenticationToken: String

        @inlinable
        public init(authenticationToken: String) {
            self.authenticationToken = authenticationToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCurrentUserResponse: AWSDecodableShape {
        /// Metadata of the user.
        public let user: User?

        @inlinable
        public init(user: User? = nil) {
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case user = "User"
        }
    }

    public struct GetDocumentPathRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the document.
        public let documentId: String
        /// A comma-separated list of values. Specify NAME to include the names of the parent folders.
        public let fields: String?
        /// The maximum number of levels in the hierarchy to return.
        public let limit: Int?
        /// This value is not supported.
        public let marker: String?

        @inlinable
        public init(authenticationToken: String? = nil, documentId: String, fields: String? = nil, limit: Int? = nil, marker: String? = nil) {
            self.authenticationToken = authenticationToken
            self.documentId = documentId
            self.fields = fields
            self.limit = limit
            self.marker = marker
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.documentId, key: "DocumentId")
            request.encodeQuery(self.fields, key: "fields")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 256)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.fields, name: "fields", parent: name, max: 256)
            try self.validate(self.fields, name: "fields", parent: name, min: 1)
            try self.validate(self.fields, name: "fields", parent: name, pattern: "^[\\w,]+$")
            try self.validate(self.limit, name: "limit", parent: name, max: 999)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDocumentPathResponse: AWSDecodableShape {
        /// The path information.
        public let path: ResourcePath?

        @inlinable
        public init(path: ResourcePath? = nil) {
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
        }
    }

    public struct GetDocumentRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the document.
        public let documentId: String
        /// Set this to TRUE to include custom metadata in the response.
        public let includeCustomMetadata: Bool?

        @inlinable
        public init(authenticationToken: String? = nil, documentId: String, includeCustomMetadata: Bool? = nil) {
            self.authenticationToken = authenticationToken
            self.documentId = documentId
            self.includeCustomMetadata = includeCustomMetadata
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.documentId, key: "DocumentId")
            request.encodeQuery(self.includeCustomMetadata, key: "includeCustomMetadata")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDocumentResponse: AWSDecodableShape {
        /// The custom metadata on the document.
        public let customMetadata: [String: String]?
        /// The metadata details of the document.
        public let metadata: DocumentMetadata?

        @inlinable
        public init(customMetadata: [String: String]? = nil, metadata: DocumentMetadata? = nil) {
            self.customMetadata = customMetadata
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case customMetadata = "CustomMetadata"
            case metadata = "Metadata"
        }
    }

    public struct GetDocumentVersionRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the document.
        public let documentId: String
        /// A comma-separated list of values. Specify "SOURCE" to include a URL for the source document.
        public let fields: String?
        /// Set this to TRUE to include custom metadata in the response.
        public let includeCustomMetadata: Bool?
        /// The version ID of the document.
        public let versionId: String

        @inlinable
        public init(authenticationToken: String? = nil, documentId: String, fields: String? = nil, includeCustomMetadata: Bool? = nil, versionId: String) {
            self.authenticationToken = authenticationToken
            self.documentId = documentId
            self.fields = fields
            self.includeCustomMetadata = includeCustomMetadata
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.documentId, key: "DocumentId")
            request.encodeQuery(self.fields, key: "fields")
            request.encodeQuery(self.includeCustomMetadata, key: "includeCustomMetadata")
            request.encodePath(self.versionId, key: "VersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.fields, name: "fields", parent: name, max: 256)
            try self.validate(self.fields, name: "fields", parent: name, min: 1)
            try self.validate(self.fields, name: "fields", parent: name, pattern: "^[\\w,]+$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 128)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDocumentVersionResponse: AWSDecodableShape {
        /// The custom metadata on the document version.
        public let customMetadata: [String: String]?
        /// The version metadata.
        public let metadata: DocumentVersionMetadata?

        @inlinable
        public init(customMetadata: [String: String]? = nil, metadata: DocumentVersionMetadata? = nil) {
            self.customMetadata = customMetadata
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case customMetadata = "CustomMetadata"
            case metadata = "Metadata"
        }
    }

    public struct GetFolderPathRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// A comma-separated list of values. Specify "NAME" to include the names of the parent folders.
        public let fields: String?
        /// The ID of the folder.
        public let folderId: String
        /// The maximum number of levels in the hierarchy to return.
        public let limit: Int?
        /// This value is not supported.
        public let marker: String?

        @inlinable
        public init(authenticationToken: String? = nil, fields: String? = nil, folderId: String, limit: Int? = nil, marker: String? = nil) {
            self.authenticationToken = authenticationToken
            self.fields = fields
            self.folderId = folderId
            self.limit = limit
            self.marker = marker
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodeQuery(self.fields, key: "fields")
            request.encodePath(self.folderId, key: "FolderId")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.fields, name: "fields", parent: name, max: 256)
            try self.validate(self.fields, name: "fields", parent: name, min: 1)
            try self.validate(self.fields, name: "fields", parent: name, pattern: "^[\\w,]+$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 256)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.limit, name: "limit", parent: name, max: 999)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFolderPathResponse: AWSDecodableShape {
        /// The path information.
        public let path: ResourcePath?

        @inlinable
        public init(path: ResourcePath? = nil) {
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
        }
    }

    public struct GetFolderRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the folder.
        public let folderId: String
        /// Set to TRUE to include custom metadata in the response.
        public let includeCustomMetadata: Bool?

        @inlinable
        public init(authenticationToken: String? = nil, folderId: String, includeCustomMetadata: Bool? = nil) {
            self.authenticationToken = authenticationToken
            self.folderId = folderId
            self.includeCustomMetadata = includeCustomMetadata
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.folderId, key: "FolderId")
            request.encodeQuery(self.includeCustomMetadata, key: "includeCustomMetadata")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, max: 128)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFolderResponse: AWSDecodableShape {
        /// The custom metadata on the folder.
        public let customMetadata: [String: String]?
        /// The metadata of the folder.
        public let metadata: FolderMetadata?

        @inlinable
        public init(customMetadata: [String: String]? = nil, metadata: FolderMetadata? = nil) {
            self.customMetadata = customMetadata
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case customMetadata = "CustomMetadata"
            case metadata = "Metadata"
        }
    }

    public struct GetResourcesRequest: AWSEncodableShape {
        /// The Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The collection type.
        public let collectionType: ResourceCollectionType?
        /// The maximum number of resources to return.
        public let limit: Int?
        /// The marker for the next set of results. This marker was received from a previous call.
        public let marker: String?
        /// The user ID for the resource collection. This is a required field for accessing the API operation using IAM credentials.
        public let userId: String?

        @inlinable
        public init(authenticationToken: String? = nil, collectionType: ResourceCollectionType? = nil, limit: Int? = nil, marker: String? = nil, userId: String? = nil) {
            self.authenticationToken = authenticationToken
            self.collectionType = collectionType
            self.limit = limit
            self.marker = marker
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodeQuery(self.collectionType, key: "collectionType")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 999)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[&\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourcesResponse: AWSDecodableShape {
        /// The documents in the specified collection.
        public let documents: [DocumentMetadata]?
        /// The folders in the specified folder.
        public let folders: [FolderMetadata]?
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?

        @inlinable
        public init(documents: [DocumentMetadata]? = nil, folders: [FolderMetadata]? = nil, marker: String? = nil) {
            self.documents = documents
            self.folders = folders
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case documents = "Documents"
            case folders = "Folders"
            case marker = "Marker"
        }
    }

    public struct GroupMetadata: AWSDecodableShape {
        /// The ID of the user group.
        public let id: String?
        /// The name of the group.
        public let name: String?

        @inlinable
        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case name = "Name"
        }
    }

    public struct InitiateDocumentVersionUploadRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The timestamp when the content of the document was originally created.
        public let contentCreatedTimestamp: Date?
        /// The timestamp when the content of the document was modified.
        public let contentModifiedTimestamp: Date?
        /// The content type of the document.
        public let contentType: String?
        /// The size of the document, in bytes.
        public let documentSizeInBytes: Int64?
        /// The ID of the document.
        public let id: String?
        /// The name of the document.
        public let name: String?
        /// The ID of the parent folder.
        public let parentFolderId: String?

        @inlinable
        public init(authenticationToken: String? = nil, contentCreatedTimestamp: Date? = nil, contentModifiedTimestamp: Date? = nil, contentType: String? = nil, documentSizeInBytes: Int64? = nil, id: String? = nil, name: String? = nil, parentFolderId: String? = nil) {
            self.authenticationToken = authenticationToken
            self.contentCreatedTimestamp = contentCreatedTimestamp
            self.contentModifiedTimestamp = contentModifiedTimestamp
            self.contentType = contentType
            self.documentSizeInBytes = documentSizeInBytes
            self.id = id
            self.name = name
            self.parentFolderId = parentFolderId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            try container.encodeIfPresent(self.contentCreatedTimestamp, forKey: .contentCreatedTimestamp)
            try container.encodeIfPresent(self.contentModifiedTimestamp, forKey: .contentModifiedTimestamp)
            try container.encodeIfPresent(self.contentType, forKey: .contentType)
            try container.encodeIfPresent(self.documentSizeInBytes, forKey: .documentSizeInBytes)
            try container.encodeIfPresent(self.id, forKey: .id)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.parentFolderId, forKey: .parentFolderId)
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 128)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 128)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\u202D\\u202F-\\uFFFF]+$")
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, max: 128)
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, min: 1)
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case contentCreatedTimestamp = "ContentCreatedTimestamp"
            case contentModifiedTimestamp = "ContentModifiedTimestamp"
            case contentType = "ContentType"
            case documentSizeInBytes = "DocumentSizeInBytes"
            case id = "Id"
            case name = "Name"
            case parentFolderId = "ParentFolderId"
        }
    }

    public struct InitiateDocumentVersionUploadResponse: AWSDecodableShape {
        /// The document metadata.
        public let metadata: DocumentMetadata?
        /// The upload metadata.
        public let uploadMetadata: UploadMetadata?

        @inlinable
        public init(metadata: DocumentMetadata? = nil, uploadMetadata: UploadMetadata? = nil) {
            self.metadata = metadata
            self.uploadMetadata = uploadMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
            case uploadMetadata = "UploadMetadata"
        }
    }

    public struct LongRangeType: AWSEncodableShape {
        /// The size end range (in bytes).
        public let endValue: Int64?
        /// The size start range (in bytes).
        public let startValue: Int64?

        @inlinable
        public init(endValue: Int64? = nil, startValue: Int64? = nil) {
            self.endValue = endValue
            self.startValue = startValue
        }

        private enum CodingKeys: String, CodingKey {
            case endValue = "EndValue"
            case startValue = "StartValue"
        }
    }

    public struct NotificationOptions: AWSEncodableShape {
        /// Text value to be included in the email body.
        public let emailMessage: String?
        /// Boolean value to indicate an email notification should be sent to the recipients.
        public let sendEmail: Bool?

        @inlinable
        public init(emailMessage: String? = nil, sendEmail: Bool? = nil) {
            self.emailMessage = emailMessage
            self.sendEmail = sendEmail
        }

        public func validate(name: String) throws {
            try self.validate(self.emailMessage, name: "emailMessage", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case emailMessage = "EmailMessage"
            case sendEmail = "SendEmail"
        }
    }

    public struct Participants: AWSDecodableShape {
        /// The list of user groups.
        public let groups: [GroupMetadata]?
        /// The list of users.
        public let users: [UserMetadata]?

        @inlinable
        public init(groups: [GroupMetadata]? = nil, users: [UserMetadata]? = nil) {
            self.groups = groups
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case users = "Users"
        }
    }

    public struct PermissionInfo: AWSDecodableShape {
        /// The role of the user.
        public let role: RoleType?
        /// The type of permissions.
        public let type: RolePermissionType?

        @inlinable
        public init(role: RoleType? = nil, type: RolePermissionType? = nil) {
            self.role = role
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case role = "Role"
            case type = "Type"
        }
    }

    public struct Principal: AWSDecodableShape {
        /// The ID of the resource.
        public let id: String?
        /// The permission information for the resource.
        public let roles: [PermissionInfo]?
        /// The type of resource.
        public let type: PrincipalType?

        @inlinable
        public init(id: String? = nil, roles: [PermissionInfo]? = nil, type: PrincipalType? = nil) {
            self.id = id
            self.roles = roles
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case roles = "Roles"
            case type = "Type"
        }
    }

    public struct RemoveAllResourcePermissionsRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the resource.
        public let resourceId: String

        @inlinable
        public init(authenticationToken: String? = nil, resourceId: String) {
            self.authenticationToken = authenticationToken
            self.resourceId = resourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.resourceId, key: "ResourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 128)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveResourcePermissionRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The principal ID of the resource.
        public let principalId: String
        /// The principal type of the resource.
        public let principalType: PrincipalType?
        /// The ID of the resource.
        public let resourceId: String

        @inlinable
        public init(authenticationToken: String? = nil, principalId: String, principalType: PrincipalType? = nil, resourceId: String) {
            self.authenticationToken = authenticationToken
            self.principalId = principalId
            self.principalType = principalType
            self.resourceId = resourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.principalId, key: "PrincipalId")
            request.encodeQuery(self.principalType, key: "type")
            request.encodePath(self.resourceId, key: "ResourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, max: 256)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 128)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ResourceMetadata: AWSDecodableShape {
        /// The ID of the resource.
        public let id: String?
        /// The name of the resource.
        public let name: String?
        /// The original name of the resource before a rename operation.
        public let originalName: String?
        /// The owner of the resource.
        public let owner: UserMetadata?
        /// The parent ID of the resource before a rename operation.
        public let parentId: String?
        /// The type of resource.
        public let type: ResourceType?
        /// The version ID of the resource. This is an optional field and is filled for action on document version.
        public let versionId: String?

        @inlinable
        public init(id: String? = nil, name: String? = nil, originalName: String? = nil, owner: UserMetadata? = nil, parentId: String? = nil, type: ResourceType? = nil, versionId: String? = nil) {
            self.id = id
            self.name = name
            self.originalName = originalName
            self.owner = owner
            self.parentId = parentId
            self.type = type
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case name = "Name"
            case originalName = "OriginalName"
            case owner = "Owner"
            case parentId = "ParentId"
            case type = "Type"
            case versionId = "VersionId"
        }
    }

    public struct ResourcePath: AWSDecodableShape {
        /// The components of the resource path.
        public let components: [ResourcePathComponent]?

        @inlinable
        public init(components: [ResourcePathComponent]? = nil) {
            self.components = components
        }

        private enum CodingKeys: String, CodingKey {
            case components = "Components"
        }
    }

    public struct ResourcePathComponent: AWSDecodableShape {
        /// The ID of the resource path.
        public let id: String?
        /// The name of the resource path.
        public let name: String?

        @inlinable
        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case name = "Name"
        }
    }

    public struct ResponseItem: AWSDecodableShape {
        /// The comment that matches the query.
        public let commentMetadata: CommentMetadata?
        /// The document that matches the query.
        public let documentMetadata: DocumentMetadata?
        /// The document version that matches the metadata.
        public let documentVersionMetadata: DocumentVersionMetadata?
        /// The folder that matches the query.
        public let folderMetadata: FolderMetadata?
        /// The type of item being returned.
        public let resourceType: ResponseItemType?
        /// The webUrl of the item being returned.
        public let webUrl: String?

        @inlinable
        public init(commentMetadata: CommentMetadata? = nil, documentMetadata: DocumentMetadata? = nil, documentVersionMetadata: DocumentVersionMetadata? = nil, folderMetadata: FolderMetadata? = nil, resourceType: ResponseItemType? = nil, webUrl: String? = nil) {
            self.commentMetadata = commentMetadata
            self.documentMetadata = documentMetadata
            self.documentVersionMetadata = documentVersionMetadata
            self.folderMetadata = folderMetadata
            self.resourceType = resourceType
            self.webUrl = webUrl
        }

        private enum CodingKeys: String, CodingKey {
            case commentMetadata = "CommentMetadata"
            case documentMetadata = "DocumentMetadata"
            case documentVersionMetadata = "DocumentVersionMetadata"
            case folderMetadata = "FolderMetadata"
            case resourceType = "ResourceType"
            case webUrl = "WebUrl"
        }
    }

    public struct RestoreDocumentVersionsRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the document.
        public let documentId: String

        @inlinable
        public init(authenticationToken: String? = nil, documentId: String) {
            self.authenticationToken = authenticationToken
            self.documentId = documentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.documentId, key: "DocumentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct SearchPrincipalType: AWSEncodableShape {
        /// UserIds or GroupIds.
        public let id: String
        /// The Role of a User or Group.
        public let roles: [PrincipalRoleType]?

        @inlinable
        public init(id: String, roles: [PrincipalRoleType]? = nil) {
            self.id = id
            self.roles = roles
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.roles, name: "roles", parent: name, max: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case roles = "Roles"
        }
    }

    public struct SearchResourcesRequest: AWSEncodableShape {
        /// A list of attributes to include in the response. Used to request fields that are not normally returned in a standard response.
        public let additionalResponseFields: [AdditionalResponseFieldType]?
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// Filters results based on entity metadata.
        public let filters: Filters?
        /// Max results count per page.
        public let limit: Int?
        /// The marker for the next set of results.
        public let marker: String?
        /// Order by results in one or more categories.
        public let orderBy: [SearchSortResult]?
        /// Filters based on the resource owner OrgId. This is a mandatory parameter when using Admin SigV4 credentials.
        public let organizationId: String?
        /// Filter based on the text field type. A Folder has only a name and no content. A Comment has only content and no name. A Document or Document Version has a name and content
        public let queryScopes: [SearchQueryScopeType]?
        /// The String to search for. Searches across different text fields based on request parameters. Use double quotes around the query string for exact phrase matches.
        public let queryText: String?

        @inlinable
        public init(additionalResponseFields: [AdditionalResponseFieldType]? = nil, authenticationToken: String? = nil, filters: Filters? = nil, limit: Int? = nil, marker: String? = nil, orderBy: [SearchSortResult]? = nil, organizationId: String? = nil, queryScopes: [SearchQueryScopeType]? = nil, queryText: String? = nil) {
            self.additionalResponseFields = additionalResponseFields
            self.authenticationToken = authenticationToken
            self.filters = filters
            self.limit = limit
            self.marker = marker
            self.orderBy = orderBy
            self.organizationId = organizationId
            self.queryScopes = queryScopes
            self.queryText = queryText
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalResponseFields, forKey: .additionalResponseFields)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.limit, forKey: .limit)
            try container.encodeIfPresent(self.marker, forKey: .marker)
            try container.encodeIfPresent(self.orderBy, forKey: .orderBy)
            try container.encodeIfPresent(self.organizationId, forKey: .organizationId)
            try container.encodeIfPresent(self.queryScopes, forKey: .queryScopes)
            try container.encodeIfPresent(self.queryText, forKey: .queryText)
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 2048)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, pattern: "^[\\d]+$")
            try self.validate(self.orderBy, name: "orderBy", parent: name, max: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, max: 256)
            try self.validate(self.organizationId, name: "organizationId", parent: name, min: 1)
            try self.validate(self.organizationId, name: "organizationId", parent: name, pattern: "^[&\\w+-.@]+$")
            try self.validate(self.queryScopes, name: "queryScopes", parent: name, max: 2)
            try self.validate(self.queryText, name: "queryText", parent: name, max: 512)
            try self.validate(self.queryText, name: "queryText", parent: name, min: 1)
            try self.validate(self.queryText, name: "queryText", parent: name, pattern: "^[\\u0020-\\uFFFF]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalResponseFields = "AdditionalResponseFields"
            case filters = "Filters"
            case limit = "Limit"
            case marker = "Marker"
            case orderBy = "OrderBy"
            case organizationId = "OrganizationId"
            case queryScopes = "QueryScopes"
            case queryText = "QueryText"
        }
    }

    public struct SearchResourcesResponse: AWSDecodableShape {
        /// List of Documents, Folders, Comments, and Document Versions matching the query.
        public let items: [ResponseItem]?
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?

        @inlinable
        public init(items: [ResponseItem]? = nil, marker: String? = nil) {
            self.items = items
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case marker = "Marker"
        }
    }

    public struct SearchSortResult: AWSEncodableShape {
        /// Sort search results based on this field name.
        public let field: OrderByFieldType?
        /// Sort direction.
        public let order: SortOrder?

        @inlinable
        public init(field: OrderByFieldType? = nil, order: SortOrder? = nil) {
            self.field = field
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case field = "Field"
            case order = "Order"
        }
    }

    public struct SharePrincipal: AWSEncodableShape {
        /// The ID of the recipient.
        public let id: String
        /// The role of the recipient.
        public let role: RoleType
        /// The type of the recipient.
        public let type: PrincipalType

        @inlinable
        public init(id: String, role: RoleType, type: PrincipalType) {
            self.id = id
            self.role = role
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[&\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case role = "Role"
            case type = "Type"
        }
    }

    public struct ShareResult: AWSDecodableShape {
        /// The ID of the invited user.
        public let inviteePrincipalId: String?
        /// The ID of the principal.
        public let principalId: String?
        /// The role.
        public let role: RoleType?
        /// The ID of the resource that was shared.
        public let shareId: String?
        /// The status.
        public let status: ShareStatusType?
        /// The status message.
        public let statusMessage: String?

        @inlinable
        public init(inviteePrincipalId: String? = nil, principalId: String? = nil, role: RoleType? = nil, shareId: String? = nil, status: ShareStatusType? = nil, statusMessage: String? = nil) {
            self.inviteePrincipalId = inviteePrincipalId
            self.principalId = principalId
            self.role = role
            self.shareId = shareId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case inviteePrincipalId = "InviteePrincipalId"
            case principalId = "PrincipalId"
            case role = "Role"
            case shareId = "ShareId"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct StorageRuleType: AWSEncodableShape & AWSDecodableShape {
        /// The amount of storage allocated, in bytes.
        public let storageAllocatedInBytes: Int64?
        /// The type of storage.
        public let storageType: StorageType?

        @inlinable
        public init(storageAllocatedInBytes: Int64? = nil, storageType: StorageType? = nil) {
            self.storageAllocatedInBytes = storageAllocatedInBytes
            self.storageType = storageType
        }

        public func validate(name: String) throws {
            try self.validate(self.storageAllocatedInBytes, name: "storageAllocatedInBytes", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case storageAllocatedInBytes = "StorageAllocatedInBytes"
            case storageType = "StorageType"
        }
    }

    public struct Subscription: AWSDecodableShape {
        /// The endpoint of the subscription.
        public let endPoint: String?
        /// The protocol of the subscription.
        public let `protocol`: SubscriptionProtocolType?
        /// The ID of the subscription.
        public let subscriptionId: String?

        @inlinable
        public init(endPoint: String? = nil, protocol: SubscriptionProtocolType? = nil, subscriptionId: String? = nil) {
            self.endPoint = endPoint
            self.`protocol` = `protocol`
            self.subscriptionId = subscriptionId
        }

        private enum CodingKeys: String, CodingKey {
            case endPoint = "EndPoint"
            case `protocol` = "Protocol"
            case subscriptionId = "SubscriptionId"
        }
    }

    public struct UnauthorizedOperationException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct UpdateDocumentRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the document.
        public let documentId: String
        /// The name of the document.
        public let name: String?
        /// The ID of the parent folder.
        public let parentFolderId: String?
        /// The resource state of the document. Only ACTIVE and RECYCLED are supported.
        public let resourceState: ResourceStateType?

        @inlinable
        public init(authenticationToken: String? = nil, documentId: String, name: String? = nil, parentFolderId: String? = nil, resourceState: ResourceStateType? = nil) {
            self.authenticationToken = authenticationToken
            self.documentId = documentId
            self.name = name
            self.parentFolderId = parentFolderId
            self.resourceState = resourceState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.documentId, key: "DocumentId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.parentFolderId, forKey: .parentFolderId)
            try container.encodeIfPresent(self.resourceState, forKey: .resourceState)
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\u202D\\u202F-\\uFFFF]+$")
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, max: 128)
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, min: 1)
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case parentFolderId = "ParentFolderId"
            case resourceState = "ResourceState"
        }
    }

    public struct UpdateDocumentVersionRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the document.
        public let documentId: String
        /// The version ID of the document.
        public let versionId: String
        /// The status of the version.
        public let versionStatus: DocumentVersionStatus?

        @inlinable
        public init(authenticationToken: String? = nil, documentId: String, versionId: String, versionStatus: DocumentVersionStatus? = nil) {
            self.authenticationToken = authenticationToken
            self.documentId = documentId
            self.versionId = versionId
            self.versionStatus = versionStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.documentId, key: "DocumentId")
            request.encodePath(self.versionId, key: "VersionId")
            try container.encodeIfPresent(self.versionStatus, forKey: .versionStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, max: 128)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 128)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case versionStatus = "VersionStatus"
        }
    }

    public struct UpdateFolderRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The ID of the folder.
        public let folderId: String
        /// The name of the folder.
        public let name: String?
        /// The ID of the parent folder.
        public let parentFolderId: String?
        /// The resource state of the folder. Only ACTIVE and RECYCLED are accepted values from the API.
        public let resourceState: ResourceStateType?

        @inlinable
        public init(authenticationToken: String? = nil, folderId: String, name: String? = nil, parentFolderId: String? = nil, resourceState: ResourceStateType? = nil) {
            self.authenticationToken = authenticationToken
            self.folderId = folderId
            self.name = name
            self.parentFolderId = parentFolderId
            self.resourceState = resourceState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            request.encodePath(self.folderId, key: "FolderId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.parentFolderId, forKey: .parentFolderId)
            try container.encodeIfPresent(self.resourceState, forKey: .resourceState)
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, max: 128)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w+-.@]+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\u202D\\u202F-\\uFFFF]+$")
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, max: 128)
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, min: 1)
            try self.validate(self.parentFolderId, name: "parentFolderId", parent: name, pattern: "^[\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case parentFolderId = "ParentFolderId"
            case resourceState = "ResourceState"
        }
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
        public let authenticationToken: String?
        /// The given name of the user.
        public let givenName: String?
        /// Boolean value to determine whether the user is granted Power user privileges.
        public let grantPoweruserPrivileges: BooleanEnumType?
        /// The locale of the user.
        public let locale: LocaleType?
        /// The amount of storage for the user.
        public let storageRule: StorageRuleType?
        /// The surname of the user.
        public let surname: String?
        /// The time zone ID of the user.
        public let timeZoneId: String?
        /// The type of the user.
        public let type: UserType?
        /// The ID of the user.
        public let userId: String

        @inlinable
        public init(authenticationToken: String? = nil, givenName: String? = nil, grantPoweruserPrivileges: BooleanEnumType? = nil, locale: LocaleType? = nil, storageRule: StorageRuleType? = nil, surname: String? = nil, timeZoneId: String? = nil, type: UserType? = nil, userId: String) {
            self.authenticationToken = authenticationToken
            self.givenName = givenName
            self.grantPoweruserPrivileges = grantPoweruserPrivileges
            self.locale = locale
            self.storageRule = storageRule
            self.surname = surname
            self.timeZoneId = timeZoneId
            self.type = type
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.authenticationToken, key: "Authentication")
            try container.encodeIfPresent(self.givenName, forKey: .givenName)
            try container.encodeIfPresent(self.grantPoweruserPrivileges, forKey: .grantPoweruserPrivileges)
            try container.encodeIfPresent(self.locale, forKey: .locale)
            try container.encodeIfPresent(self.storageRule, forKey: .storageRule)
            try container.encodeIfPresent(self.surname, forKey: .surname)
            try container.encodeIfPresent(self.timeZoneId, forKey: .timeZoneId)
            try container.encodeIfPresent(self.type, forKey: .type)
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, max: 8199)
            try self.validate(self.authenticationToken, name: "authenticationToken", parent: name, min: 1)
            try self.validate(self.givenName, name: "givenName", parent: name, max: 64)
            try self.validate(self.givenName, name: "givenName", parent: name, min: 1)
            try self.storageRule?.validate(name: "\(name).storageRule")
            try self.validate(self.surname, name: "surname", parent: name, max: 64)
            try self.validate(self.surname, name: "surname", parent: name, min: 1)
            try self.validate(self.timeZoneId, name: "timeZoneId", parent: name, max: 256)
            try self.validate(self.timeZoneId, name: "timeZoneId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[&\\w+-.@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case givenName = "GivenName"
            case grantPoweruserPrivileges = "GrantPoweruserPrivileges"
            case locale = "Locale"
            case storageRule = "StorageRule"
            case surname = "Surname"
            case timeZoneId = "TimeZoneId"
            case type = "Type"
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        /// The user information.
        public let user: User?

        @inlinable
        public init(user: User? = nil) {
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case user = "User"
        }
    }

    public struct UploadMetadata: AWSDecodableShape {
        /// The signed headers.
        public let signedHeaders: [String: String]?
        /// The URL of the upload.
        public let uploadUrl: String?

        @inlinable
        public init(signedHeaders: [String: String]? = nil, uploadUrl: String? = nil) {
            self.signedHeaders = signedHeaders
            self.uploadUrl = uploadUrl
        }

        private enum CodingKeys: String, CodingKey {
            case signedHeaders = "SignedHeaders"
            case uploadUrl = "UploadUrl"
        }
    }

    public struct User: AWSDecodableShape {
        /// The time when the user was created.
        public let createdTimestamp: Date?
        /// The email address of the user.
        public let emailAddress: String?
        /// The given name of the user.
        public let givenName: String?
        /// The ID of the user.
        public let id: String?
        /// The locale of the user.
        public let locale: LocaleType?
        /// The time when the user was modified.
        public let modifiedTimestamp: Date?
        /// The ID of the organization.
        public let organizationId: String?
        /// The ID of the recycle bin folder.
        public let recycleBinFolderId: String?
        /// The ID of the root folder.
        public let rootFolderId: String?
        /// The status of the user.
        public let status: UserStatusType?
        /// The storage for the user.
        public let storage: UserStorageMetadata?
        /// The surname of the user.
        public let surname: String?
        /// The time zone ID of the user.
        public let timeZoneId: String?
        /// The type of user.
        public let type: UserType?
        /// The login name of the user.
        public let username: String?

        @inlinable
        public init(createdTimestamp: Date? = nil, emailAddress: String? = nil, givenName: String? = nil, id: String? = nil, locale: LocaleType? = nil, modifiedTimestamp: Date? = nil, organizationId: String? = nil, recycleBinFolderId: String? = nil, rootFolderId: String? = nil, status: UserStatusType? = nil, storage: UserStorageMetadata? = nil, surname: String? = nil, timeZoneId: String? = nil, type: UserType? = nil, username: String? = nil) {
            self.createdTimestamp = createdTimestamp
            self.emailAddress = emailAddress
            self.givenName = givenName
            self.id = id
            self.locale = locale
            self.modifiedTimestamp = modifiedTimestamp
            self.organizationId = organizationId
            self.recycleBinFolderId = recycleBinFolderId
            self.rootFolderId = rootFolderId
            self.status = status
            self.storage = storage
            self.surname = surname
            self.timeZoneId = timeZoneId
            self.type = type
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case emailAddress = "EmailAddress"
            case givenName = "GivenName"
            case id = "Id"
            case locale = "Locale"
            case modifiedTimestamp = "ModifiedTimestamp"
            case organizationId = "OrganizationId"
            case recycleBinFolderId = "RecycleBinFolderId"
            case rootFolderId = "RootFolderId"
            case status = "Status"
            case storage = "Storage"
            case surname = "Surname"
            case timeZoneId = "TimeZoneId"
            case type = "Type"
            case username = "Username"
        }
    }

    public struct UserMetadata: AWSDecodableShape {
        /// The email address of the user.
        public let emailAddress: String?
        /// The given name of the user before a rename operation.
        public let givenName: String?
        /// The ID of the user.
        public let id: String?
        /// The surname of the user.
        public let surname: String?
        /// The name of the user.
        public let username: String?

        @inlinable
        public init(emailAddress: String? = nil, givenName: String? = nil, id: String? = nil, surname: String? = nil, username: String? = nil) {
            self.emailAddress = emailAddress
            self.givenName = givenName
            self.id = id
            self.surname = surname
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case emailAddress = "EmailAddress"
            case givenName = "GivenName"
            case id = "Id"
            case surname = "Surname"
            case username = "Username"
        }
    }

    public struct UserStorageMetadata: AWSDecodableShape {
        /// The storage for a user.
        public let storageRule: StorageRuleType?
        /// The amount of storage used, in bytes.
        public let storageUtilizedInBytes: Int64?

        @inlinable
        public init(storageRule: StorageRuleType? = nil, storageUtilizedInBytes: Int64? = nil) {
            self.storageRule = storageRule
            self.storageUtilizedInBytes = storageUtilizedInBytes
        }

        private enum CodingKeys: String, CodingKey {
            case storageRule = "StorageRule"
            case storageUtilizedInBytes = "StorageUtilizedInBytes"
        }
    }
}

// MARK: - Errors

/// Error enum for WorkDocs
public struct WorkDocsErrorType: AWSErrorType {
    enum Code: String {
        case concurrentModificationException = "ConcurrentModificationException"
        case conflictingOperationException = "ConflictingOperationException"
        case customMetadataLimitExceededException = "CustomMetadataLimitExceededException"
        case deactivatingLastSystemUserException = "DeactivatingLastSystemUserException"
        case documentLockedForCommentsException = "DocumentLockedForCommentsException"
        case draftUploadOutOfSyncException = "DraftUploadOutOfSyncException"
        case entityAlreadyExistsException = "EntityAlreadyExistsException"
        case entityNotExistsException = "EntityNotExistsException"
        case failedDependencyException = "FailedDependencyException"
        case illegalUserStateException = "IllegalUserStateException"
        case invalidArgumentException = "InvalidArgumentException"
        case invalidCommentOperationException = "InvalidCommentOperationException"
        case invalidOperationException = "InvalidOperationException"
        case invalidPasswordException = "InvalidPasswordException"
        case limitExceededException = "LimitExceededException"
        case prohibitedStateException = "ProhibitedStateException"
        case requestedEntityTooLargeException = "RequestedEntityTooLargeException"
        case resourceAlreadyCheckedOutException = "ResourceAlreadyCheckedOutException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case storageLimitExceededException = "StorageLimitExceededException"
        case storageLimitWillExceedException = "StorageLimitWillExceedException"
        case tooManyLabelsException = "TooManyLabelsException"
        case tooManySubscriptionsException = "TooManySubscriptionsException"
        case unauthorizedOperationException = "UnauthorizedOperationException"
        case unauthorizedResourceAccessException = "UnauthorizedResourceAccessException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize WorkDocs
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The resource hierarchy is changing.
    public static var concurrentModificationException: Self { .init(.concurrentModificationException) }
    /// Another operation is in progress on the resource that conflicts with the current operation.
    public static var conflictingOperationException: Self { .init(.conflictingOperationException) }
    /// The limit has been reached on the number of custom properties for the specified resource.
    public static var customMetadataLimitExceededException: Self { .init(.customMetadataLimitExceededException) }
    /// The last user in the organization is being deactivated.
    public static var deactivatingLastSystemUserException: Self { .init(.deactivatingLastSystemUserException) }
    /// This exception is thrown when the document is locked for comments and user tries to create or delete a comment on that document.
    public static var documentLockedForCommentsException: Self { .init(.documentLockedForCommentsException) }
    /// This exception is thrown when a valid checkout ID is not presented on document version upload calls for a document that has been checked out from Web client.
    public static var draftUploadOutOfSyncException: Self { .init(.draftUploadOutOfSyncException) }
    /// The resource already exists.
    public static var entityAlreadyExistsException: Self { .init(.entityAlreadyExistsException) }
    /// The resource does not exist.
    public static var entityNotExistsException: Self { .init(.entityNotExistsException) }
    /// The Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.
    public static var failedDependencyException: Self { .init(.failedDependencyException) }
    /// The user is undergoing transfer of ownership.
    public static var illegalUserStateException: Self { .init(.illegalUserStateException) }
    /// The pagination marker or limit fields are not valid.
    public static var invalidArgumentException: Self { .init(.invalidArgumentException) }
    /// The requested operation is not allowed on the specified comment object.
    public static var invalidCommentOperationException: Self { .init(.invalidCommentOperationException) }
    /// The operation is invalid.
    public static var invalidOperationException: Self { .init(.invalidOperationException) }
    /// The password is invalid.
    public static var invalidPasswordException: Self { .init(.invalidPasswordException) }
    /// The maximum of 100,000 files and folders under the parent folder has been exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The specified document version is not in the INITIALIZED state.
    public static var prohibitedStateException: Self { .init(.prohibitedStateException) }
    /// The response is too large to return. The request must include a filter to reduce the size of the response.
    public static var requestedEntityTooLargeException: Self { .init(.requestedEntityTooLargeException) }
    /// The resource is already checked out.
    public static var resourceAlreadyCheckedOutException: Self { .init(.resourceAlreadyCheckedOutException) }
    /// One or more of the dependencies is unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The storage limit has been exceeded.
    public static var storageLimitExceededException: Self { .init(.storageLimitExceededException) }
    /// The storage limit will be exceeded.
    public static var storageLimitWillExceedException: Self { .init(.storageLimitWillExceedException) }
    /// The limit has been reached on the number of labels for the specified resource.
    public static var tooManyLabelsException: Self { .init(.tooManyLabelsException) }
    /// You've reached the limit on the number of subscriptions for the WorkDocs instance.
    public static var tooManySubscriptionsException: Self { .init(.tooManySubscriptionsException) }
    /// The operation is not permitted.
    public static var unauthorizedOperationException: Self { .init(.unauthorizedOperationException) }
    /// The caller does not have access to perform the action on the resource.
    public static var unauthorizedResourceAccessException: Self { .init(.unauthorizedResourceAccessException) }
}

extension WorkDocsErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "DeactivatingLastSystemUserException": WorkDocs.DeactivatingLastSystemUserException.self,
        "EntityNotExistsException": WorkDocs.EntityNotExistsException.self,
        "UnauthorizedOperationException": WorkDocs.UnauthorizedOperationException.self
    ]
}

extension WorkDocsErrorType: Equatable {
    public static func == (lhs: WorkDocsErrorType, rhs: WorkDocsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension WorkDocsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
