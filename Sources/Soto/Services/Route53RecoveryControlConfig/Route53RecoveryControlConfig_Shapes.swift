//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension Route53RecoveryControlConfig {
    // MARK: Enums

    public enum RuleType: String, CustomStringConvertible, Codable {
        case and = "AND"
        case atleast = "ATLEAST"
        case or = "OR"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable {
        case deployed = "DEPLOYED"
        case pending = "PENDING"
        case pendingDeletion = "PENDING_DELETION"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssertionRule: AWSDecodableShape {
        /// The routing controls that are part of transactions that are evaluated to determine if a request to change a routing control state is allowed. For example, you might include three routing controls, one for each of three Amazon Web Services Regions.
        public let assertedControls: [String]
        /// The Amazon Resource Name (ARN) of the control panel.
        public let controlPanelArn: String
        /// Name of the assertion rule. You can use any non-white space character in the name.
        public let name: String
        /// The criteria that you set for specific assertion controls (routing controls) that designate how many controls must be enabled as the result of a transaction. For example, if you have three assertion controls, you might specify atleast 2 for your rule configuration. This means that at least two assertion controls must be enabled, so that at least two Amazon Web Services Regions are enabled.
        public let ruleConfig: RuleConfig
        /// The Amazon Resource Name (ARN) of the assertion rule.
        public let safetyRuleArn: String
        /// The deployment status of an assertion rule. Status can be one of the following: PENDING, DEPLOYED, PENDING_DELETION.
        public let status: Status
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        public let waitPeriodMs: Int

        public init(assertedControls: [String], controlPanelArn: String, name: String, ruleConfig: RuleConfig, safetyRuleArn: String, status: Status, waitPeriodMs: Int) {
            self.assertedControls = assertedControls
            self.controlPanelArn = controlPanelArn
            self.name = name
            self.ruleConfig = ruleConfig
            self.safetyRuleArn = safetyRuleArn
            self.status = status
            self.waitPeriodMs = waitPeriodMs
        }

        private enum CodingKeys: String, CodingKey {
            case assertedControls = "AssertedControls"
            case controlPanelArn = "ControlPanelArn"
            case name = "Name"
            case ruleConfig = "RuleConfig"
            case safetyRuleArn = "SafetyRuleArn"
            case status = "Status"
            case waitPeriodMs = "WaitPeriodMs"
        }
    }

    public struct AssertionRuleUpdate: AWSEncodableShape {
        /// The name of the assertion rule. You can use any non-white space character in the name.
        public let name: String
        /// The Amazon Resource Name (ARN) of the assertion rule.
        public let safetyRuleArn: String
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        public let waitPeriodMs: Int

        public init(name: String, safetyRuleArn: String, waitPeriodMs: Int) {
            self.name = name
            self.safetyRuleArn = safetyRuleArn
            self.waitPeriodMs = waitPeriodMs
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case safetyRuleArn = "SafetyRuleArn"
            case waitPeriodMs = "WaitPeriodMs"
        }
    }

    public struct Cluster: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// Endpoints for a cluster. Specify one of these endpoints when you want to set or retrieve a routing control state in the cluster. To get or update the routing control state, see the Amazon Route 53 Application Recovery Controller Cluster (Data Plane) Actions.
        public let clusterEndpoints: [ClusterEndpoint]?
        /// The name of the cluster.
        public let name: String?
        /// Deployment status of a resource. Status can be one of the following: PENDING, DEPLOYED, PENDING_DELETION.
        public let status: Status?

        public init(clusterArn: String? = nil, clusterEndpoints: [ClusterEndpoint]? = nil, name: String? = nil, status: Status? = nil) {
            self.clusterArn = clusterArn
            self.clusterEndpoints = clusterEndpoints
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "ClusterArn"
            case clusterEndpoints = "ClusterEndpoints"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct ClusterEndpoint: AWSDecodableShape {
        /// A cluster endpoint. Specify an endpoint and Amazon Web Services Region when you want to set or retrieve a routing control state in the cluster. To get or update the routing control state, see the Amazon Route 53 Application Recovery Controller Cluster (Data Plane) Actions.
        public let endpoint: String?
        /// The Amazon Web Services Region for a cluster endpoint.
        public let region: String?

        public init(endpoint: String? = nil, region: String? = nil) {
            self.endpoint = endpoint
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
            case region = "Region"
        }
    }

    public struct ControlPanel: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster that includes the control panel.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the control panel.
        public let controlPanelArn: String?
        /// A flag that Amazon Route 53 Application Recovery Controller sets to true to designate the default control panel for a cluster. When you create a cluster, Amazon Route 53 Application Recovery Controller creates a control panel, and sets this flag for that control panel. If you create a control panel yourself, this flag is set to false.
        public let defaultControlPanel: Bool?
        /// The name of the control panel. You can use any non-white space character in the name.
        public let name: String?
        /// The number of routing controls in the control panel.
        public let routingControlCount: Int?
        /// The deployment status of control panel. Status can be one of the following: PENDING, DEPLOYED, PENDING_DELETION.
        public let status: Status?

        public init(clusterArn: String? = nil, controlPanelArn: String? = nil, defaultControlPanel: Bool? = nil, name: String? = nil, routingControlCount: Int? = nil, status: Status? = nil) {
            self.clusterArn = clusterArn
            self.controlPanelArn = controlPanelArn
            self.defaultControlPanel = defaultControlPanel
            self.name = name
            self.routingControlCount = routingControlCount
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "ClusterArn"
            case controlPanelArn = "ControlPanelArn"
            case defaultControlPanel = "DefaultControlPanel"
            case name = "Name"
            case routingControlCount = "RoutingControlCount"
            case status = "Status"
        }
    }

    public struct CreateClusterRequest: AWSEncodableShape {
        /// Unique client idempotency token.
        public let clientToken: String?
        /// The name of the cluster.
        public let clusterName: String

        public init(clientToken: String? = CreateClusterRequest.idempotencyToken(), clusterName: String) {
            self.clientToken = clientToken
            self.clusterName = clusterName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 64)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 1)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case clusterName = "ClusterName"
        }
    }

    public struct CreateClusterResponse: AWSDecodableShape {
        /// The cluster that was created.
        public let cluster: Cluster?

        public init(cluster: Cluster? = nil) {
            self.cluster = cluster
        }

        private enum CodingKeys: String, CodingKey {
            case cluster = "Cluster"
        }
    }

    public struct CreateControlPanelRequest: AWSEncodableShape {
        /// Unique client idempotency token.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the cluster for the control panel.
        public let clusterArn: String
        /// The name of the control panel.
        public let controlPanelName: String

        public init(clientToken: String? = CreateControlPanelRequest.idempotencyToken(), clusterArn: String, controlPanelName: String) {
            self.clientToken = clientToken
            self.clusterArn = clusterArn
            self.controlPanelName = controlPanelName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.controlPanelName, name: "controlPanelName", parent: name, max: 64)
            try self.validate(self.controlPanelName, name: "controlPanelName", parent: name, min: 1)
            try self.validate(self.controlPanelName, name: "controlPanelName", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case clusterArn = "ClusterArn"
            case controlPanelName = "ControlPanelName"
        }
    }

    public struct CreateControlPanelResponse: AWSDecodableShape {
        /// Information about a control panel.
        public let controlPanel: ControlPanel?

        public init(controlPanel: ControlPanel? = nil) {
            self.controlPanel = controlPanel
        }

        private enum CodingKeys: String, CodingKey {
            case controlPanel = "ControlPanel"
        }
    }

    public struct CreateRoutingControlRequest: AWSEncodableShape {
        /// Unique client idempotency token.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the cluster that includes the routing control.
        public let clusterArn: String
        /// The Amazon Resource Name (ARN) of the control panel that includes the routing control.
        public let controlPanelArn: String?
        /// The name of the routing control.
        public let routingControlName: String

        public init(clientToken: String? = CreateRoutingControlRequest.idempotencyToken(), clusterArn: String, controlPanelArn: String? = nil, routingControlName: String) {
            self.clientToken = clientToken
            self.clusterArn = clusterArn
            self.controlPanelArn = controlPanelArn
            self.routingControlName = routingControlName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.routingControlName, name: "routingControlName", parent: name, max: 64)
            try self.validate(self.routingControlName, name: "routingControlName", parent: name, min: 1)
            try self.validate(self.routingControlName, name: "routingControlName", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case clusterArn = "ClusterArn"
            case controlPanelArn = "ControlPanelArn"
            case routingControlName = "RoutingControlName"
        }
    }

    public struct CreateRoutingControlResponse: AWSDecodableShape {
        /// The routing control that is created.
        public let routingControl: RoutingControl?

        public init(routingControl: RoutingControl? = nil) {
            self.routingControl = routingControl
        }

        private enum CodingKeys: String, CodingKey {
            case routingControl = "RoutingControl"
        }
    }

    public struct CreateSafetyRuleRequest: AWSEncodableShape {
        public let assertionRule: NewAssertionRule?
        /// Unique client idempotency token.
        public let clientToken: String?
        public let gatingRule: NewGatingRule?

        public init(assertionRule: NewAssertionRule? = nil, clientToken: String? = CreateSafetyRuleRequest.idempotencyToken(), gatingRule: NewGatingRule? = nil) {
            self.assertionRule = assertionRule
            self.clientToken = clientToken
            self.gatingRule = gatingRule
        }

        public func validate(name: String) throws {
            try self.assertionRule?.validate(name: "\(name).assertionRule")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.gatingRule?.validate(name: "\(name).gatingRule")
        }

        private enum CodingKeys: String, CodingKey {
            case assertionRule = "AssertionRule"
            case clientToken = "ClientToken"
            case gatingRule = "GatingRule"
        }
    }

    public struct CreateSafetyRuleResponse: AWSDecodableShape {
        public let assertionRule: AssertionRule?
        public let gatingRule: GatingRule?

        public init(assertionRule: AssertionRule? = nil, gatingRule: GatingRule? = nil) {
            self.assertionRule = assertionRule
            self.gatingRule = gatingRule
        }

        private enum CodingKeys: String, CodingKey {
            case assertionRule = "AssertionRule"
            case gatingRule = "GatingRule"
        }
    }

    public struct DeleteClusterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "ClusterArn"))
        ]

        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteClusterResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteControlPanelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "controlPanelArn", location: .uri(locationName: "ControlPanelArn"))
        ]

        public let controlPanelArn: String

        public init(controlPanelArn: String) {
            self.controlPanelArn = controlPanelArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteControlPanelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRoutingControlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "routingControlArn", location: .uri(locationName: "RoutingControlArn"))
        ]

        public let routingControlArn: String

        public init(routingControlArn: String) {
            self.routingControlArn = routingControlArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRoutingControlResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSafetyRuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "safetyRuleArn", location: .uri(locationName: "SafetyRuleArn"))
        ]

        public let safetyRuleArn: String

        public init(safetyRuleArn: String) {
            self.safetyRuleArn = safetyRuleArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSafetyRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeClusterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "ClusterArn"))
        ]

        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterResponse: AWSDecodableShape {
        /// The cluster for the DescribeCluster request.
        public let cluster: Cluster?

        public init(cluster: Cluster? = nil) {
            self.cluster = cluster
        }

        private enum CodingKeys: String, CodingKey {
            case cluster = "Cluster"
        }
    }

    public struct DescribeControlPanelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "controlPanelArn", location: .uri(locationName: "ControlPanelArn"))
        ]

        public let controlPanelArn: String

        public init(controlPanelArn: String) {
            self.controlPanelArn = controlPanelArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeControlPanelResponse: AWSDecodableShape {
        /// Information about the control panel.
        public let controlPanel: ControlPanel?

        public init(controlPanel: ControlPanel? = nil) {
            self.controlPanel = controlPanel
        }

        private enum CodingKeys: String, CodingKey {
            case controlPanel = "ControlPanel"
        }
    }

    public struct DescribeRoutingControlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "routingControlArn", location: .uri(locationName: "RoutingControlArn"))
        ]

        public let routingControlArn: String

        public init(routingControlArn: String) {
            self.routingControlArn = routingControlArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRoutingControlResponse: AWSDecodableShape {
        /// Information about the routing control.
        public let routingControl: RoutingControl?

        public init(routingControl: RoutingControl? = nil) {
            self.routingControl = routingControl
        }

        private enum CodingKeys: String, CodingKey {
            case routingControl = "RoutingControl"
        }
    }

    public struct DescribeSafetyRuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "safetyRuleArn", location: .uri(locationName: "SafetyRuleArn"))
        ]

        public let safetyRuleArn: String

        public init(safetyRuleArn: String) {
            self.safetyRuleArn = safetyRuleArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSafetyRuleResponse: AWSDecodableShape {
        public let assertionRule: AssertionRule?
        public let gatingRule: GatingRule?

        public init(assertionRule: AssertionRule? = nil, gatingRule: GatingRule? = nil) {
            self.assertionRule = assertionRule
            self.gatingRule = gatingRule
        }

        private enum CodingKeys: String, CodingKey {
            case assertionRule = "AssertionRule"
            case gatingRule = "GatingRule"
        }
    }

    public struct GatingRule: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the control panel.
        public let controlPanelArn: String
        /// The gating controls for the gating rule. That is, routing controls that are evaluated by the rule configuration that you specify.
        public let gatingControls: [String]
        /// The name for the gating rule.
        public let name: String
        /// The criteria that you set for specific gating controls (routing controls) that designates how many controls must be enabled to allow you to change (set or unset) the target controls.
        public let ruleConfig: RuleConfig
        /// The Amazon Resource Name (ARN) of the gating rule.
        public let safetyRuleArn: String
        /// The deployment status of a gating rule. Status can be one of the following: PENDING, DEPLOYED, PENDING_DELETION.
        public let status: Status
        /// Routing controls that can only be set or unset if the specified RuleConfig evaluates to true for the specified GatingControls. For example, say you have three gating controls, one for each of three Amazon Web Services Regions. Now you specify ATLEAST 2 as your RuleConfig. With these settings, you can only change (set or unset) the routing controls that you have specified as TargetControls if that rule evaluates to true. In other words, your ability to change the routing controls that you have specified as TargetControls is gated by the rule that you set for the routing controls in GatingControls.
        public let targetControls: [String]
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        public let waitPeriodMs: Int

        public init(controlPanelArn: String, gatingControls: [String], name: String, ruleConfig: RuleConfig, safetyRuleArn: String, status: Status, targetControls: [String], waitPeriodMs: Int) {
            self.controlPanelArn = controlPanelArn
            self.gatingControls = gatingControls
            self.name = name
            self.ruleConfig = ruleConfig
            self.safetyRuleArn = safetyRuleArn
            self.status = status
            self.targetControls = targetControls
            self.waitPeriodMs = waitPeriodMs
        }

        private enum CodingKeys: String, CodingKey {
            case controlPanelArn = "ControlPanelArn"
            case gatingControls = "GatingControls"
            case name = "Name"
            case ruleConfig = "RuleConfig"
            case safetyRuleArn = "SafetyRuleArn"
            case status = "Status"
            case targetControls = "TargetControls"
            case waitPeriodMs = "WaitPeriodMs"
        }
    }

    public struct GatingRuleUpdate: AWSEncodableShape {
        /// The name for the gating rule.
        public let name: String
        /// The Amazon Resource Name (ARN) of the gating rule.
        public let safetyRuleArn: String
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        public let waitPeriodMs: Int

        public init(name: String, safetyRuleArn: String, waitPeriodMs: Int) {
            self.name = name
            self.safetyRuleArn = safetyRuleArn
            self.waitPeriodMs = waitPeriodMs
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case safetyRuleArn = "SafetyRuleArn"
            case waitPeriodMs = "WaitPeriodMs"
        }
    }

    public struct ListAssociatedRoute53HealthChecksRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken")),
            AWSMemberEncoding(label: "routingControlArn", location: .uri(locationName: "RoutingControlArn"))
        ]

        public let maxResults: Int?
        public let nextToken: String?
        public let routingControlArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, routingControlArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.routingControlArn = routingControlArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssociatedRoute53HealthChecksResponse: AWSDecodableShape {
        /// Identifiers for the health checks.
        public let healthCheckIds: [String]?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?

        public init(healthCheckIds: [String]? = nil, nextToken: String? = nil) {
            self.healthCheckIds = healthCheckIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case healthCheckIds = "HealthCheckIds"
            case nextToken = "NextToken"
        }
    }

    public struct ListClustersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClustersResponse: AWSDecodableShape {
        /// An array of the clusters in an account.
        public let clusters: [Cluster]?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?

        public init(clusters: [Cluster]? = nil, nextToken: String? = nil) {
            self.clusters = clusters
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusters = "Clusters"
            case nextToken = "NextToken"
        }
    }

    public struct ListControlPanelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .querystring(locationName: "ClusterArn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken"))
        ]

        public let clusterArn: String?
        public let maxResults: Int?
        public let nextToken: String?

        public init(clusterArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListControlPanelsResponse: AWSDecodableShape {
        /// The result of a successful ListControlPanel request.
        public let controlPanels: [ControlPanel]?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?

        public init(controlPanels: [ControlPanel]? = nil, nextToken: String? = nil) {
            self.controlPanels = controlPanels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controlPanels = "ControlPanels"
            case nextToken = "NextToken"
        }
    }

    public struct ListRoutingControlsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "controlPanelArn", location: .uri(locationName: "ControlPanelArn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken"))
        ]

        public let controlPanelArn: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(controlPanelArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.controlPanelArn = controlPanelArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRoutingControlsResponse: AWSDecodableShape {
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// An array of routing controls.
        public let routingControls: [RoutingControl]?

        public init(nextToken: String? = nil, routingControls: [RoutingControl]? = nil) {
            self.nextToken = nextToken
            self.routingControls = routingControls
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case routingControls = "RoutingControls"
        }
    }

    public struct ListSafetyRulesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "controlPanelArn", location: .uri(locationName: "ControlPanelArn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken"))
        ]

        public let controlPanelArn: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(controlPanelArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.controlPanelArn = controlPanelArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSafetyRulesResponse: AWSDecodableShape {
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// The list of safety rules in a control panel.
        public let safetyRules: [Rule]?

        public init(nextToken: String? = nil, safetyRules: [Rule]? = nil) {
            self.nextToken = nextToken
            self.safetyRules = safetyRules
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case safetyRules = "SafetyRules"
        }
    }

    public struct NewAssertionRule: AWSEncodableShape {
        /// The routing controls that are part of transactions that are evaluated to determine if a request to change a routing control state is allowed. For example, you might include three routing controls, one for each of three Amazon Web Services Regions.
        public let assertedControls: [String]
        /// The Amazon Resource Name (ARN) for the control panel.
        public let controlPanelArn: String
        /// The name of the assertion rule. You can use any non-white space character in the name.
        public let name: String
        /// The criteria that you set for specific assertion controls (routing controls) that designate how many controls must be enabled as the result of a transaction. For example, if you have three assertion controls, you might specify atleast 2 for your rule configuration. This means that at least two assertion controls must be enabled, so that at least two Amazon Web Services Regions are enabled.
        public let ruleConfig: RuleConfig
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        public let waitPeriodMs: Int

        public init(assertedControls: [String], controlPanelArn: String, name: String, ruleConfig: RuleConfig, waitPeriodMs: Int) {
            self.assertedControls = assertedControls
            self.controlPanelArn = controlPanelArn
            self.name = name
            self.ruleConfig = ruleConfig
            self.waitPeriodMs = waitPeriodMs
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case assertedControls = "AssertedControls"
            case controlPanelArn = "ControlPanelArn"
            case name = "Name"
            case ruleConfig = "RuleConfig"
            case waitPeriodMs = "WaitPeriodMs"
        }
    }

    public struct NewGatingRule: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the control panel.
        public let controlPanelArn: String
        /// The gating controls for the new gating rule. That is, routing controls that are evaluated by the rule configuration that you specify.
        public let gatingControls: [String]
        /// The name for the new gating rule.
        public let name: String
        /// The criteria that you set for specific gating controls (routing controls) that designates how many controls must be enabled to allow you to change (set or unset) the target controls.
        public let ruleConfig: RuleConfig
        /// Routing controls that can only be set or unset if the specified RuleConfig evaluates to true for the specified GatingControls. For example, say you have three gating controls, one for each of three Amazon Web Services Regions. Now you specify AtLeast 2 as your RuleConfig. With these settings, you can only change (set or unset) the routing controls that you have specified as TargetControls if that rule evaluates to true. In other words, your ability to change the routing controls that you have specified as TargetControls is gated by the rule that you set for the routing controls in GatingControls.
        public let targetControls: [String]
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        public let waitPeriodMs: Int

        public init(controlPanelArn: String, gatingControls: [String], name: String, ruleConfig: RuleConfig, targetControls: [String], waitPeriodMs: Int) {
            self.controlPanelArn = controlPanelArn
            self.gatingControls = gatingControls
            self.name = name
            self.ruleConfig = ruleConfig
            self.targetControls = targetControls
            self.waitPeriodMs = waitPeriodMs
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case controlPanelArn = "ControlPanelArn"
            case gatingControls = "GatingControls"
            case name = "Name"
            case ruleConfig = "RuleConfig"
            case targetControls = "TargetControls"
            case waitPeriodMs = "WaitPeriodMs"
        }
    }

    public struct RoutingControl: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the control panel that includes the routing control.
        public let controlPanelArn: String?
        /// The name of the routing control.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the routing control.
        public let routingControlArn: String?
        /// The deployment status of a routing control. Status can be one of the following: PENDING, DEPLOYED, PENDING_DELETION.
        public let status: Status?

        public init(controlPanelArn: String? = nil, name: String? = nil, routingControlArn: String? = nil, status: Status? = nil) {
            self.controlPanelArn = controlPanelArn
            self.name = name
            self.routingControlArn = routingControlArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case controlPanelArn = "ControlPanelArn"
            case name = "Name"
            case routingControlArn = "RoutingControlArn"
            case status = "Status"
        }
    }

    public struct Rule: AWSDecodableShape {
        /// An assertion rule enforces that, when a routing control state is changed, the criteria set by the rule configuration is met. Otherwise, the change to the routing control is not accepted.
        public let assertion: AssertionRule?
        /// A gating rule verifies that a set of gating controls evaluates as true, based on a rule configuration that you specify. If the gating rule evaluates to true, Amazon Route 53 Application Recovery Controller allows a set of routing control state changes to run and complete against the set of target controls.
        public let gating: GatingRule?

        public init(assertion: AssertionRule? = nil, gating: GatingRule? = nil) {
            self.assertion = assertion
            self.gating = gating
        }

        private enum CodingKeys: String, CodingKey {
            case assertion = "ASSERTION"
            case gating = "GATING"
        }
    }

    public struct RuleConfig: AWSEncodableShape & AWSDecodableShape {
        /// Logical negation of the rule. If the rule would usually evaluate true, it's evaluated as false, and vice versa.
        public let inverted: Bool
        /// The value of N, when you specify an ATLEAST rule type. That is, Threshold is the number of controls that must be set when you specify an ATLEAST type.
        public let threshold: Int
        /// A rule can be one of the following: ATLEAST, AND, or OR.
        public let type: RuleType

        public init(inverted: Bool, threshold: Int, type: RuleType) {
            self.inverted = inverted
            self.threshold = threshold
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case inverted = "Inverted"
            case threshold = "Threshold"
            case type = "Type"
        }
    }

    public struct UpdateControlPanelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the control panel.
        public let controlPanelArn: String
        /// The name of the control panel.
        public let controlPanelName: String

        public init(controlPanelArn: String, controlPanelName: String) {
            self.controlPanelArn = controlPanelArn
            self.controlPanelName = controlPanelName
        }

        public func validate(name: String) throws {
            try self.validate(self.controlPanelName, name: "controlPanelName", parent: name, max: 64)
            try self.validate(self.controlPanelName, name: "controlPanelName", parent: name, min: 1)
            try self.validate(self.controlPanelName, name: "controlPanelName", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case controlPanelArn = "ControlPanelArn"
            case controlPanelName = "ControlPanelName"
        }
    }

    public struct UpdateControlPanelResponse: AWSDecodableShape {
        /// The control panel to update.
        public let controlPanel: ControlPanel?

        public init(controlPanel: ControlPanel? = nil) {
            self.controlPanel = controlPanel
        }

        private enum CodingKeys: String, CodingKey {
            case controlPanel = "ControlPanel"
        }
    }

    public struct UpdateRoutingControlRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the routing control.
        public let routingControlArn: String
        /// The name of the routing control.
        public let routingControlName: String

        public init(routingControlArn: String, routingControlName: String) {
            self.routingControlArn = routingControlArn
            self.routingControlName = routingControlName
        }

        public func validate(name: String) throws {
            try self.validate(self.routingControlName, name: "routingControlName", parent: name, max: 64)
            try self.validate(self.routingControlName, name: "routingControlName", parent: name, min: 1)
            try self.validate(self.routingControlName, name: "routingControlName", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case routingControlArn = "RoutingControlArn"
            case routingControlName = "RoutingControlName"
        }
    }

    public struct UpdateRoutingControlResponse: AWSDecodableShape {
        /// The routing control that was updated.
        public let routingControl: RoutingControl?

        public init(routingControl: RoutingControl? = nil) {
            self.routingControl = routingControl
        }

        private enum CodingKeys: String, CodingKey {
            case routingControl = "RoutingControl"
        }
    }

    public struct UpdateSafetyRuleRequest: AWSEncodableShape {
        public let assertionRuleUpdate: AssertionRuleUpdate?
        public let gatingRuleUpdate: GatingRuleUpdate?

        public init(assertionRuleUpdate: AssertionRuleUpdate? = nil, gatingRuleUpdate: GatingRuleUpdate? = nil) {
            self.assertionRuleUpdate = assertionRuleUpdate
            self.gatingRuleUpdate = gatingRuleUpdate
        }

        public func validate(name: String) throws {
            try self.assertionRuleUpdate?.validate(name: "\(name).assertionRuleUpdate")
            try self.gatingRuleUpdate?.validate(name: "\(name).gatingRuleUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case assertionRuleUpdate = "AssertionRuleUpdate"
            case gatingRuleUpdate = "GatingRuleUpdate"
        }
    }

    public struct UpdateSafetyRuleResponse: AWSDecodableShape {
        public let assertionRule: AssertionRule?
        public let gatingRule: GatingRule?

        public init(assertionRule: AssertionRule? = nil, gatingRule: GatingRule? = nil) {
            self.assertionRule = assertionRule
            self.gatingRule = gatingRule
        }

        private enum CodingKeys: String, CodingKey {
            case assertionRule = "AssertionRule"
            case gatingRule = "GatingRule"
        }
    }
}
