//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS APIGateway service.
///
/// Amazon API Gateway Amazon API Gateway helps developers deliver robust, secure, and scalable mobile and web application back ends. API Gateway allows developers to securely connect mobile and web applications to APIs that run on AWS Lambda, Amazon EC2, or other publicly addressable web services that are hosted outside of AWS.
public struct APIGateway: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the APIGateway client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "apigateway",
            serviceProtocol: .restjson,
            apiVersion: "2015-07-09",
            endpoint: endpoint,
            serviceEndpoints: [
                "fips-ca-central-1": "apigateway-fips.ca-central-1.amazonaws.com",
                "fips-us-east-1": "apigateway-fips.us-east-1.amazonaws.com",
                "fips-us-east-2": "apigateway-fips.us-east-2.amazonaws.com",
                "fips-us-west-1": "apigateway-fips.us-west-1.amazonaws.com",
                "fips-us-west-2": "apigateway-fips.us-west-2.amazonaws.com"
            ],
            errorType: APIGatewayErrorType.self,
            middlewares: [AWSEditHeadersMiddleware(.add(name: "accept", value: "application/json"))],
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Create an ApiKey resource.
    public func createApiKey(_ input: CreateApiKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ApiKey> {
        return self.client.execute(operation: "CreateApiKey", path: "/apikeys", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds a new Authorizer resource to an existing RestApi resource.
    public func createAuthorizer(_ input: CreateAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Authorizer> {
        return self.client.execute(operation: "CreateAuthorizer", path: "/restapis/{restApiId}/authorizers", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new BasePathMapping resource.
    public func createBasePathMapping(_ input: CreateBasePathMappingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BasePathMapping> {
        return self.client.execute(operation: "CreateBasePathMapping", path: "/domainnames/{domainName}/basepathmappings", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a Deployment resource, which makes a specified RestApi callable over the internet.
    public func createDeployment(_ input: CreateDeploymentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Deployment> {
        return self.client.execute(operation: "CreateDeployment", path: "/restapis/{restApiId}/deployments", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a documentation part.
    public func createDocumentationPart(_ input: CreateDocumentationPartRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DocumentationPart> {
        return self.client.execute(operation: "CreateDocumentationPart", path: "/restapis/{restApiId}/documentation/parts", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a documentation version
    public func createDocumentationVersion(_ input: CreateDocumentationVersionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DocumentationVersion> {
        return self.client.execute(operation: "CreateDocumentationVersion", path: "/restapis/{restApiId}/documentation/versions", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new domain name.
    public func createDomainName(_ input: CreateDomainNameRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DomainName> {
        return self.client.execute(operation: "CreateDomainName", path: "/domainnames", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds a new Model resource to an existing RestApi resource.
    public func createModel(_ input: CreateModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Model> {
        return self.client.execute(operation: "CreateModel", path: "/restapis/{restApiId}/models", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a RequestValidator of a given RestApi.
    public func createRequestValidator(_ input: CreateRequestValidatorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RequestValidator> {
        return self.client.execute(operation: "CreateRequestValidator", path: "/restapis/{restApiId}/requestvalidators", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a Resource resource.
    public func createResource(_ input: CreateResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Resource> {
        return self.client.execute(operation: "CreateResource", path: "/restapis/{restApiId}/resources/{parentId}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new RestApi resource.
    public func createRestApi(_ input: CreateRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RestApi> {
        return self.client.execute(operation: "CreateRestApi", path: "/restapis", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new Stage resource that references a pre-existing Deployment for the API.
    public func createStage(_ input: CreateStageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Stage> {
        return self.client.execute(operation: "CreateStage", path: "/restapis/{restApiId}/stages", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a usage plan with the throttle and quota limits, as well as the associated API stages, specified in the payload.
    public func createUsagePlan(_ input: CreateUsagePlanRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UsagePlan> {
        return self.client.execute(operation: "CreateUsagePlan", path: "/usageplans", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a usage plan key for adding an existing API key to a usage plan.
    public func createUsagePlanKey(_ input: CreateUsagePlanKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UsagePlanKey> {
        return self.client.execute(operation: "CreateUsagePlanKey", path: "/usageplans/{usagePlanId}/keys", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a VPC link, under the caller's account in a selected region, in an asynchronous operation that typically takes 2-4 minutes to complete and become operational. The caller must have permissions to create and update VPC Endpoint services.
    public func createVpcLink(_ input: CreateVpcLinkRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<VpcLink> {
        return self.client.execute(operation: "CreateVpcLink", path: "/vpclinks", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the ApiKey resource.
    @discardableResult public func deleteApiKey(_ input: DeleteApiKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteApiKey", path: "/apikeys/{apiKey}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an existing Authorizer resource.
    @discardableResult public func deleteAuthorizer(_ input: DeleteAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteAuthorizer", path: "/restapis/{restApiId}/authorizers/{authorizerId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the BasePathMapping resource.
    @discardableResult public func deleteBasePathMapping(_ input: DeleteBasePathMappingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteBasePathMapping", path: "/domainnames/{domainName}/basepathmappings/{basePath}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the ClientCertificate resource.
    @discardableResult public func deleteClientCertificate(_ input: DeleteClientCertificateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteClientCertificate", path: "/clientcertificates/{clientCertificateId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a Deployment resource. Deleting a deployment will only succeed if there are no Stage resources associated with it.
    @discardableResult public func deleteDeployment(_ input: DeleteDeploymentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteDeployment", path: "/restapis/{restApiId}/deployments/{deploymentId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a documentation part
    @discardableResult public func deleteDocumentationPart(_ input: DeleteDocumentationPartRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteDocumentationPart", path: "/restapis/{restApiId}/documentation/parts/{documentationPartId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a documentation version.
    @discardableResult public func deleteDocumentationVersion(_ input: DeleteDocumentationVersionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteDocumentationVersion", path: "/restapis/{restApiId}/documentation/versions/{documentationVersion}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the DomainName resource.
    @discardableResult public func deleteDomainName(_ input: DeleteDomainNameRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteDomainName", path: "/domainnames/{domainName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Clears any customization of a GatewayResponse of a specified response type on the given RestApi and resets it with the default settings.
    @discardableResult public func deleteGatewayResponse(_ input: DeleteGatewayResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteGatewayResponse", path: "/restapis/{restApiId}/gatewayresponses/{responseType}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a delete integration.
    @discardableResult public func deleteIntegration(_ input: DeleteIntegrationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteIntegration", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a delete integration response.
    @discardableResult public func deleteIntegrationResponse(_ input: DeleteIntegrationResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteIntegrationResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an existing Method resource.
    @discardableResult public func deleteMethod(_ input: DeleteMethodRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteMethod", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an existing MethodResponse resource.
    @discardableResult public func deleteMethodResponse(_ input: DeleteMethodResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteMethodResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a model.
    @discardableResult public func deleteModel(_ input: DeleteModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteModel", path: "/restapis/{restApiId}/models/{modelName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a RequestValidator of a given RestApi.
    @discardableResult public func deleteRequestValidator(_ input: DeleteRequestValidatorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteRequestValidator", path: "/restapis/{restApiId}/requestvalidators/{requestValidatorId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a Resource resource.
    @discardableResult public func deleteResource(_ input: DeleteResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteResource", path: "/restapis/{restApiId}/resources/{resourceId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the specified API.
    @discardableResult public func deleteRestApi(_ input: DeleteRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteRestApi", path: "/restapis/{restApiId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a Stage resource.
    @discardableResult public func deleteStage(_ input: DeleteStageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteStage", path: "/restapis/{restApiId}/stages/{stageName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a usage plan of a given plan Id.
    @discardableResult public func deleteUsagePlan(_ input: DeleteUsagePlanRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteUsagePlan", path: "/usageplans/{usagePlanId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a usage plan key  and remove the underlying API key from the associated usage plan.
    @discardableResult public func deleteUsagePlanKey(_ input: DeleteUsagePlanKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteUsagePlanKey", path: "/usageplans/{usagePlanId}/keys/{keyId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an existing VpcLink of a specified identifier.
    @discardableResult public func deleteVpcLink(_ input: DeleteVpcLinkRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteVpcLink", path: "/vpclinks/{vpcLinkId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Flushes all authorizer cache entries on a stage.
    @discardableResult public func flushStageAuthorizersCache(_ input: FlushStageAuthorizersCacheRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "FlushStageAuthorizersCache", path: "/restapis/{restApiId}/stages/{stageName}/cache/authorizers", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Flushes a stage's cache.
    @discardableResult public func flushStageCache(_ input: FlushStageCacheRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "FlushStageCache", path: "/restapis/{restApiId}/stages/{stageName}/cache/data", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Generates a ClientCertificate resource.
    public func generateClientCertificate(_ input: GenerateClientCertificateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ClientCertificate> {
        return self.client.execute(operation: "GenerateClientCertificate", path: "/clientcertificates", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about the current Account resource.
    public func getAccount(_ input: GetAccountRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Account> {
        return self.client.execute(operation: "GetAccount", path: "/account", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about the current ApiKey resource.
    public func getApiKey(_ input: GetApiKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ApiKey> {
        return self.client.execute(operation: "GetApiKey", path: "/apikeys/{apiKey}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about the current ApiKeys resource.
    public func getApiKeys(_ input: GetApiKeysRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ApiKeys> {
        return self.client.execute(operation: "GetApiKeys", path: "/apikeys", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe an existing Authorizer resource.
    public func getAuthorizer(_ input: GetAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Authorizer> {
        return self.client.execute(operation: "GetAuthorizer", path: "/restapis/{restApiId}/authorizers/{authorizerId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe an existing Authorizers resource.
    public func getAuthorizers(_ input: GetAuthorizersRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Authorizers> {
        return self.client.execute(operation: "GetAuthorizers", path: "/restapis/{restApiId}/authorizers", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe a BasePathMapping resource.
    public func getBasePathMapping(_ input: GetBasePathMappingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BasePathMapping> {
        return self.client.execute(operation: "GetBasePathMapping", path: "/domainnames/{domainName}/basepathmappings/{basePath}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a collection of BasePathMapping resources.
    public func getBasePathMappings(_ input: GetBasePathMappingsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BasePathMappings> {
        return self.client.execute(operation: "GetBasePathMappings", path: "/domainnames/{domainName}/basepathmappings", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about the current ClientCertificate resource.
    public func getClientCertificate(_ input: GetClientCertificateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ClientCertificate> {
        return self.client.execute(operation: "GetClientCertificate", path: "/clientcertificates/{clientCertificateId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a collection of ClientCertificate resources.
    public func getClientCertificates(_ input: GetClientCertificatesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ClientCertificates> {
        return self.client.execute(operation: "GetClientCertificates", path: "/clientcertificates", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a Deployment resource.
    public func getDeployment(_ input: GetDeploymentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Deployment> {
        return self.client.execute(operation: "GetDeployment", path: "/restapis/{restApiId}/deployments/{deploymentId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a Deployments collection.
    public func getDeployments(_ input: GetDeploymentsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Deployments> {
        return self.client.execute(operation: "GetDeployments", path: "/restapis/{restApiId}/deployments", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a documentation part.
    public func getDocumentationPart(_ input: GetDocumentationPartRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DocumentationPart> {
        return self.client.execute(operation: "GetDocumentationPart", path: "/restapis/{restApiId}/documentation/parts/{documentationPartId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets documentation parts.
    public func getDocumentationParts(_ input: GetDocumentationPartsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DocumentationParts> {
        return self.client.execute(operation: "GetDocumentationParts", path: "/restapis/{restApiId}/documentation/parts", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a documentation version.
    public func getDocumentationVersion(_ input: GetDocumentationVersionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DocumentationVersion> {
        return self.client.execute(operation: "GetDocumentationVersion", path: "/restapis/{restApiId}/documentation/versions/{documentationVersion}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets documentation versions.
    public func getDocumentationVersions(_ input: GetDocumentationVersionsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DocumentationVersions> {
        return self.client.execute(operation: "GetDocumentationVersions", path: "/restapis/{restApiId}/documentation/versions", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a domain name that is contained in a simpler, more intuitive URL that can be called.
    public func getDomainName(_ input: GetDomainNameRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DomainName> {
        return self.client.execute(operation: "GetDomainName", path: "/domainnames/{domainName}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a collection of DomainName resources.
    public func getDomainNames(_ input: GetDomainNamesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DomainNames> {
        return self.client.execute(operation: "GetDomainNames", path: "/domainnames", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Exports a deployed version of a RestApi in a specified format.
    public func getExport(_ input: GetExportRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ExportResponse> {
        return self.client.execute(operation: "GetExport", path: "/restapis/{restApiId}/stages/{stageName}/exports/{exportType}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a GatewayResponse of a specified response type on the given RestApi.
    public func getGatewayResponse(_ input: GetGatewayResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GatewayResponse> {
        return self.client.execute(operation: "GetGatewayResponse", path: "/restapis/{restApiId}/gatewayresponses/{responseType}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the GatewayResponses collection on the given RestApi. If an API developer has not added any definitions for gateway responses, the result will be the API Gateway-generated default GatewayResponses collection for the supported response types.
    public func getGatewayResponses(_ input: GetGatewayResponsesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GatewayResponses> {
        return self.client.execute(operation: "GetGatewayResponses", path: "/restapis/{restApiId}/gatewayresponses", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get the integration settings.
    public func getIntegration(_ input: GetIntegrationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Integration> {
        return self.client.execute(operation: "GetIntegration", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a get integration response.
    public func getIntegrationResponse(_ input: GetIntegrationResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<IntegrationResponse> {
        return self.client.execute(operation: "GetIntegrationResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe an existing Method resource.
    public func getMethod(_ input: GetMethodRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Method> {
        return self.client.execute(operation: "GetMethod", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes a MethodResponse resource.
    public func getMethodResponse(_ input: GetMethodResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<MethodResponse> {
        return self.client.execute(operation: "GetMethodResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes an existing model defined for a RestApi resource.
    public func getModel(_ input: GetModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Model> {
        return self.client.execute(operation: "GetModel", path: "/restapis/{restApiId}/models/{modelName}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Generates a sample mapping template that can be used to transform a payload into the structure of a model.
    public func getModelTemplate(_ input: GetModelTemplateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Template> {
        return self.client.execute(operation: "GetModelTemplate", path: "/restapis/{restApiId}/models/{modelName}/default_template", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes existing Models defined for a RestApi resource.
    public func getModels(_ input: GetModelsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Models> {
        return self.client.execute(operation: "GetModels", path: "/restapis/{restApiId}/models", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a RequestValidator of a given RestApi.
    public func getRequestValidator(_ input: GetRequestValidatorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RequestValidator> {
        return self.client.execute(operation: "GetRequestValidator", path: "/restapis/{restApiId}/requestvalidators/{requestValidatorId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the RequestValidators collection of a given RestApi.
    public func getRequestValidators(_ input: GetRequestValidatorsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RequestValidators> {
        return self.client.execute(operation: "GetRequestValidators", path: "/restapis/{restApiId}/requestvalidators", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists information about a resource.
    public func getResource(_ input: GetResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Resource> {
        return self.client.execute(operation: "GetResource", path: "/restapis/{restApiId}/resources/{resourceId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists information about a collection of Resource resources.
    public func getResources(_ input: GetResourcesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Resources> {
        return self.client.execute(operation: "GetResources", path: "/restapis/{restApiId}/resources", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the RestApi resource in the collection.
    public func getRestApi(_ input: GetRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RestApi> {
        return self.client.execute(operation: "GetRestApi", path: "/restapis/{restApiId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the RestApis resources for your collection.
    public func getRestApis(_ input: GetRestApisRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RestApis> {
        return self.client.execute(operation: "GetRestApis", path: "/restapis", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Generates a client SDK for a RestApi and Stage.
    public func getSdk(_ input: GetSdkRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SdkResponse> {
        return self.client.execute(operation: "GetSdk", path: "/restapis/{restApiId}/stages/{stageName}/sdks/{sdkType}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets an SDK type.
    public func getSdkType(_ input: GetSdkTypeRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SdkType> {
        return self.client.execute(operation: "GetSdkType", path: "/sdktypes/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets SDK types
    public func getSdkTypes(_ input: GetSdkTypesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SdkTypes> {
        return self.client.execute(operation: "GetSdkTypes", path: "/sdktypes", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a Stage resource.
    public func getStage(_ input: GetStageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Stage> {
        return self.client.execute(operation: "GetStage", path: "/restapis/{restApiId}/stages/{stageName}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about one or more Stage resources.
    public func getStages(_ input: GetStagesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Stages> {
        return self.client.execute(operation: "GetStages", path: "/restapis/{restApiId}/stages", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the Tags collection for a given resource.
    public func getTags(_ input: GetTagsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Tags> {
        return self.client.execute(operation: "GetTags", path: "/tags/{resourceArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the usage data of a usage plan in a specified time interval.
    public func getUsage(_ input: GetUsageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Usage> {
        return self.client.execute(operation: "GetUsage", path: "/usageplans/{usagePlanId}/usage", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a usage plan of a given plan identifier.
    public func getUsagePlan(_ input: GetUsagePlanRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UsagePlan> {
        return self.client.execute(operation: "GetUsagePlan", path: "/usageplans/{usagePlanId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a usage plan key of a given key identifier.
    public func getUsagePlanKey(_ input: GetUsagePlanKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UsagePlanKey> {
        return self.client.execute(operation: "GetUsagePlanKey", path: "/usageplans/{usagePlanId}/keys/{keyId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets all the usage plan keys representing the API keys added to a specified usage plan.
    public func getUsagePlanKeys(_ input: GetUsagePlanKeysRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UsagePlanKeys> {
        return self.client.execute(operation: "GetUsagePlanKeys", path: "/usageplans/{usagePlanId}/keys", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets all the usage plans of the caller's account.
    public func getUsagePlans(_ input: GetUsagePlansRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UsagePlans> {
        return self.client.execute(operation: "GetUsagePlans", path: "/usageplans", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a specified VPC link under the caller's account in a region.
    public func getVpcLink(_ input: GetVpcLinkRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<VpcLink> {
        return self.client.execute(operation: "GetVpcLink", path: "/vpclinks/{vpcLinkId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the VpcLinks collection under the caller's account in a selected region.
    public func getVpcLinks(_ input: GetVpcLinksRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<VpcLinks> {
        return self.client.execute(operation: "GetVpcLinks", path: "/vpclinks", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Import API keys from an external source, such as a CSV-formatted file.
    public func importApiKeys(_ input: ImportApiKeysRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ApiKeyIds> {
        return self.client.execute(operation: "ImportApiKeys", path: "/apikeys?mode=import", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Imports documentation parts
    public func importDocumentationParts(_ input: ImportDocumentationPartsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DocumentationPartIds> {
        return self.client.execute(operation: "ImportDocumentationParts", path: "/restapis/{restApiId}/documentation/parts", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// A feature of the API Gateway control service for creating a new API from an external API definition file.
    public func importRestApi(_ input: ImportRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RestApi> {
        return self.client.execute(operation: "ImportRestApi", path: "/restapis?mode=import", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a customization of a GatewayResponse of a specified response type and status code on the given RestApi.
    public func putGatewayResponse(_ input: PutGatewayResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GatewayResponse> {
        return self.client.execute(operation: "PutGatewayResponse", path: "/restapis/{restApiId}/gatewayresponses/{responseType}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Sets up a method's integration.
    public func putIntegration(_ input: PutIntegrationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Integration> {
        return self.client.execute(operation: "PutIntegration", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a put integration.
    public func putIntegrationResponse(_ input: PutIntegrationResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<IntegrationResponse> {
        return self.client.execute(operation: "PutIntegrationResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Add a method to an existing Resource resource.
    public func putMethod(_ input: PutMethodRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Method> {
        return self.client.execute(operation: "PutMethod", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds a MethodResponse to an existing Method resource.
    public func putMethodResponse(_ input: PutMethodResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<MethodResponse> {
        return self.client.execute(operation: "PutMethodResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// A feature of the API Gateway control service for updating an existing API with an input of external API definitions. The update can take the form of merging the supplied definition into the existing API or overwriting the existing API.
    public func putRestApi(_ input: PutRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RestApi> {
        return self.client.execute(operation: "PutRestApi", path: "/restapis/{restApiId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds or updates a tag on a given resource.
    @discardableResult public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "TagResource", path: "/tags/{resourceArn}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Simulate the execution of an Authorizer in your RestApi with headers, parameters, and an incoming request body.
    public func testInvokeAuthorizer(_ input: TestInvokeAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TestInvokeAuthorizerResponse> {
        return self.client.execute(operation: "TestInvokeAuthorizer", path: "/restapis/{restApiId}/authorizers/{authorizerId}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Simulate the invocation of a Method in your RestApi with headers, parameters, and an incoming request body.
    public func testInvokeMethod(_ input: TestInvokeMethodRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TestInvokeMethodResponse> {
        return self.client.execute(operation: "TestInvokeMethod", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes a tag from a given resource.
    @discardableResult public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "UntagResource", path: "/tags/{resourceArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about the current Account resource.
    public func updateAccount(_ input: UpdateAccountRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Account> {
        return self.client.execute(operation: "UpdateAccount", path: "/account", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about an ApiKey resource.
    public func updateApiKey(_ input: UpdateApiKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ApiKey> {
        return self.client.execute(operation: "UpdateApiKey", path: "/apikeys/{apiKey}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an existing Authorizer resource.
    public func updateAuthorizer(_ input: UpdateAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Authorizer> {
        return self.client.execute(operation: "UpdateAuthorizer", path: "/restapis/{restApiId}/authorizers/{authorizerId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about the BasePathMapping resource.
    public func updateBasePathMapping(_ input: UpdateBasePathMappingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BasePathMapping> {
        return self.client.execute(operation: "UpdateBasePathMapping", path: "/domainnames/{domainName}/basepathmappings/{basePath}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about an ClientCertificate resource.
    public func updateClientCertificate(_ input: UpdateClientCertificateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ClientCertificate> {
        return self.client.execute(operation: "UpdateClientCertificate", path: "/clientcertificates/{clientCertificateId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about a Deployment resource.
    public func updateDeployment(_ input: UpdateDeploymentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Deployment> {
        return self.client.execute(operation: "UpdateDeployment", path: "/restapis/{restApiId}/deployments/{deploymentId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a documentation part.
    public func updateDocumentationPart(_ input: UpdateDocumentationPartRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DocumentationPart> {
        return self.client.execute(operation: "UpdateDocumentationPart", path: "/restapis/{restApiId}/documentation/parts/{documentationPartId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a documentation version.
    public func updateDocumentationVersion(_ input: UpdateDocumentationVersionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DocumentationVersion> {
        return self.client.execute(operation: "UpdateDocumentationVersion", path: "/restapis/{restApiId}/documentation/versions/{documentationVersion}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about the DomainName resource.
    public func updateDomainName(_ input: UpdateDomainNameRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DomainName> {
        return self.client.execute(operation: "UpdateDomainName", path: "/domainnames/{domainName}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a GatewayResponse of a specified response type on the given RestApi.
    public func updateGatewayResponse(_ input: UpdateGatewayResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GatewayResponse> {
        return self.client.execute(operation: "UpdateGatewayResponse", path: "/restapis/{restApiId}/gatewayresponses/{responseType}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents an update integration.
    public func updateIntegration(_ input: UpdateIntegrationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Integration> {
        return self.client.execute(operation: "UpdateIntegration", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents an update integration response.
    public func updateIntegrationResponse(_ input: UpdateIntegrationResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<IntegrationResponse> {
        return self.client.execute(operation: "UpdateIntegrationResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an existing Method resource.
    public func updateMethod(_ input: UpdateMethodRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Method> {
        return self.client.execute(operation: "UpdateMethod", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an existing MethodResponse resource.
    public func updateMethodResponse(_ input: UpdateMethodResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<MethodResponse> {
        return self.client.execute(operation: "UpdateMethodResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about a model.
    public func updateModel(_ input: UpdateModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Model> {
        return self.client.execute(operation: "UpdateModel", path: "/restapis/{restApiId}/models/{modelName}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a RequestValidator of a given RestApi.
    public func updateRequestValidator(_ input: UpdateRequestValidatorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RequestValidator> {
        return self.client.execute(operation: "UpdateRequestValidator", path: "/restapis/{restApiId}/requestvalidators/{requestValidatorId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about a Resource resource.
    public func updateResource(_ input: UpdateResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Resource> {
        return self.client.execute(operation: "UpdateResource", path: "/restapis/{restApiId}/resources/{resourceId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about the specified API.
    public func updateRestApi(_ input: UpdateRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RestApi> {
        return self.client.execute(operation: "UpdateRestApi", path: "/restapis/{restApiId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about a Stage resource.
    public func updateStage(_ input: UpdateStageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Stage> {
        return self.client.execute(operation: "UpdateStage", path: "/restapis/{restApiId}/stages/{stageName}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Grants a temporary extension to the remaining quota of a usage plan associated with a specified API key.
    public func updateUsage(_ input: UpdateUsageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Usage> {
        return self.client.execute(operation: "UpdateUsage", path: "/usageplans/{usagePlanId}/keys/{keyId}/usage", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a usage plan of a given plan Id.
    public func updateUsagePlan(_ input: UpdateUsagePlanRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UsagePlan> {
        return self.client.execute(operation: "UpdateUsagePlan", path: "/usageplans/{usagePlanId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an existing VpcLink of a specified identifier.
    public func updateVpcLink(_ input: UpdateVpcLinkRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<VpcLink> {
        return self.client.execute(operation: "UpdateVpcLink", path: "/vpclinks/{vpcLinkId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension APIGateway {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: APIGateway, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension APIGateway {
    ///  Gets information about the current ApiKeys resource.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getApiKeysPaginator<Result>(
        _ input: GetApiKeysRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ApiKeys, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getApiKeys,
            inputKey: \GetApiKeysRequest.position,
            outputKey: \ApiKeys.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getApiKeysPaginator(
        _ input: GetApiKeysRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ApiKeys, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getApiKeys,
            inputKey: \GetApiKeysRequest.position,
            outputKey: \ApiKeys.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Represents a collection of BasePathMapping resources.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getBasePathMappingsPaginator<Result>(
        _ input: GetBasePathMappingsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, BasePathMappings, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getBasePathMappings,
            inputKey: \GetBasePathMappingsRequest.position,
            outputKey: \BasePathMappings.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getBasePathMappingsPaginator(
        _ input: GetBasePathMappingsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (BasePathMappings, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getBasePathMappings,
            inputKey: \GetBasePathMappingsRequest.position,
            outputKey: \BasePathMappings.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets a collection of ClientCertificate resources.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getClientCertificatesPaginator<Result>(
        _ input: GetClientCertificatesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ClientCertificates, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getClientCertificates,
            inputKey: \GetClientCertificatesRequest.position,
            outputKey: \ClientCertificates.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getClientCertificatesPaginator(
        _ input: GetClientCertificatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ClientCertificates, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getClientCertificates,
            inputKey: \GetClientCertificatesRequest.position,
            outputKey: \ClientCertificates.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about a Deployments collection.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getDeploymentsPaginator<Result>(
        _ input: GetDeploymentsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, Deployments, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getDeployments,
            inputKey: \GetDeploymentsRequest.position,
            outputKey: \Deployments.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getDeploymentsPaginator(
        _ input: GetDeploymentsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Deployments, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getDeployments,
            inputKey: \GetDeploymentsRequest.position,
            outputKey: \Deployments.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Represents a collection of DomainName resources.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getDomainNamesPaginator<Result>(
        _ input: GetDomainNamesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DomainNames, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getDomainNames,
            inputKey: \GetDomainNamesRequest.position,
            outputKey: \DomainNames.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getDomainNamesPaginator(
        _ input: GetDomainNamesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DomainNames, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getDomainNames,
            inputKey: \GetDomainNamesRequest.position,
            outputKey: \DomainNames.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes existing Models defined for a RestApi resource.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getModelsPaginator<Result>(
        _ input: GetModelsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, Models, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getModels,
            inputKey: \GetModelsRequest.position,
            outputKey: \Models.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getModelsPaginator(
        _ input: GetModelsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Models, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getModels,
            inputKey: \GetModelsRequest.position,
            outputKey: \Models.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists information about a collection of Resource resources.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getResourcesPaginator<Result>(
        _ input: GetResourcesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, Resources, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getResources,
            inputKey: \GetResourcesRequest.position,
            outputKey: \Resources.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getResourcesPaginator(
        _ input: GetResourcesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Resources, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getResources,
            inputKey: \GetResourcesRequest.position,
            outputKey: \Resources.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the RestApis resources for your collection.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getRestApisPaginator<Result>(
        _ input: GetRestApisRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, RestApis, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getRestApis,
            inputKey: \GetRestApisRequest.position,
            outputKey: \RestApis.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getRestApisPaginator(
        _ input: GetRestApisRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (RestApis, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getRestApis,
            inputKey: \GetRestApisRequest.position,
            outputKey: \RestApis.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets the usage data of a usage plan in a specified time interval.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getUsagePaginator<Result>(
        _ input: GetUsageRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, Usage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getUsage,
            inputKey: \GetUsageRequest.position,
            outputKey: \Usage.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getUsagePaginator(
        _ input: GetUsageRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Usage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getUsage,
            inputKey: \GetUsageRequest.position,
            outputKey: \Usage.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets all the usage plan keys representing the API keys added to a specified usage plan.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getUsagePlanKeysPaginator<Result>(
        _ input: GetUsagePlanKeysRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, UsagePlanKeys, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getUsagePlanKeys,
            inputKey: \GetUsagePlanKeysRequest.position,
            outputKey: \UsagePlanKeys.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getUsagePlanKeysPaginator(
        _ input: GetUsagePlanKeysRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (UsagePlanKeys, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getUsagePlanKeys,
            inputKey: \GetUsagePlanKeysRequest.position,
            outputKey: \UsagePlanKeys.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets all the usage plans of the caller's account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getUsagePlansPaginator<Result>(
        _ input: GetUsagePlansRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, UsagePlans, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getUsagePlans,
            inputKey: \GetUsagePlansRequest.position,
            outputKey: \UsagePlans.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getUsagePlansPaginator(
        _ input: GetUsagePlansRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (UsagePlans, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getUsagePlans,
            inputKey: \GetUsagePlansRequest.position,
            outputKey: \UsagePlans.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets the VpcLinks collection under the caller's account in a selected region.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getVpcLinksPaginator<Result>(
        _ input: GetVpcLinksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, VpcLinks, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.getVpcLinks,
            inputKey: \GetVpcLinksRequest.position,
            outputKey: \VpcLinks.position,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getVpcLinksPaginator(
        _ input: GetVpcLinksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (VpcLinks, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.getVpcLinks,
            inputKey: \GetVpcLinksRequest.position,
            outputKey: \VpcLinks.position,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension APIGateway.GetApiKeysRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetApiKeysRequest {
        return .init(
            customerId: self.customerId,
            includeValues: self.includeValues,
            limit: self.limit,
            nameQuery: self.nameQuery,
            position: token
        )
    }
}

extension APIGateway.GetBasePathMappingsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetBasePathMappingsRequest {
        return .init(
            domainName: self.domainName,
            limit: self.limit,
            position: token
        )
    }
}

extension APIGateway.GetClientCertificatesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetClientCertificatesRequest {
        return .init(
            limit: self.limit,
            position: token
        )
    }
}

extension APIGateway.GetDeploymentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetDeploymentsRequest {
        return .init(
            limit: self.limit,
            position: token,
            restApiId: self.restApiId
        )
    }
}

extension APIGateway.GetDomainNamesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetDomainNamesRequest {
        return .init(
            limit: self.limit,
            position: token
        )
    }
}

extension APIGateway.GetModelsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetModelsRequest {
        return .init(
            limit: self.limit,
            position: token,
            restApiId: self.restApiId
        )
    }
}

extension APIGateway.GetResourcesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetResourcesRequest {
        return .init(
            embed: self.embed,
            limit: self.limit,
            position: token,
            restApiId: self.restApiId
        )
    }
}

extension APIGateway.GetRestApisRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetRestApisRequest {
        return .init(
            limit: self.limit,
            position: token
        )
    }
}

extension APIGateway.GetUsagePlanKeysRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetUsagePlanKeysRequest {
        return .init(
            limit: self.limit,
            nameQuery: self.nameQuery,
            position: token,
            usagePlanId: self.usagePlanId
        )
    }
}

extension APIGateway.GetUsagePlansRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetUsagePlansRequest {
        return .init(
            keyId: self.keyId,
            limit: self.limit,
            position: token
        )
    }
}

extension APIGateway.GetUsageRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetUsageRequest {
        return .init(
            endDate: self.endDate,
            keyId: self.keyId,
            limit: self.limit,
            position: token,
            startDate: self.startDate,
            usagePlanId: self.usagePlanId
        )
    }
}

extension APIGateway.GetVpcLinksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> APIGateway.GetVpcLinksRequest {
        return .init(
            limit: self.limit,
            position: token
        )
    }
}
