//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if compiler(>=5.5.2) && canImport(_Concurrency)

import SotoCore

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension APIGateway {
    // MARK: Async API Calls

    /// Create an ApiKey resource.
    public func createApiKey(_ input: CreateApiKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ApiKey {
        return try await self.client.execute(operation: "CreateApiKey", path: "/apikeys", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds a new Authorizer resource to an existing RestApi resource.
    public func createAuthorizer(_ input: CreateAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Authorizer {
        return try await self.client.execute(operation: "CreateAuthorizer", path: "/restapis/{restApiId}/authorizers", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new BasePathMapping resource.
    public func createBasePathMapping(_ input: CreateBasePathMappingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> BasePathMapping {
        return try await self.client.execute(operation: "CreateBasePathMapping", path: "/domainnames/{domainName}/basepathmappings", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a Deployment resource, which makes a specified RestApi callable over the internet.
    public func createDeployment(_ input: CreateDeploymentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Deployment {
        return try await self.client.execute(operation: "CreateDeployment", path: "/restapis/{restApiId}/deployments", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a documentation part.
    public func createDocumentationPart(_ input: CreateDocumentationPartRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DocumentationPart {
        return try await self.client.execute(operation: "CreateDocumentationPart", path: "/restapis/{restApiId}/documentation/parts", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a documentation version
    public func createDocumentationVersion(_ input: CreateDocumentationVersionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DocumentationVersion {
        return try await self.client.execute(operation: "CreateDocumentationVersion", path: "/restapis/{restApiId}/documentation/versions", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new domain name.
    public func createDomainName(_ input: CreateDomainNameRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DomainName {
        return try await self.client.execute(operation: "CreateDomainName", path: "/domainnames", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds a new Model resource to an existing RestApi resource.
    public func createModel(_ input: CreateModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Model {
        return try await self.client.execute(operation: "CreateModel", path: "/restapis/{restApiId}/models", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a RequestValidator of a given RestApi.
    public func createRequestValidator(_ input: CreateRequestValidatorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> RequestValidator {
        return try await self.client.execute(operation: "CreateRequestValidator", path: "/restapis/{restApiId}/requestvalidators", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a Resource resource.
    public func createResource(_ input: CreateResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Resource {
        return try await self.client.execute(operation: "CreateResource", path: "/restapis/{restApiId}/resources/{parentId}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new RestApi resource.
    public func createRestApi(_ input: CreateRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> RestApi {
        return try await self.client.execute(operation: "CreateRestApi", path: "/restapis", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new Stage resource that references a pre-existing Deployment for the API.
    public func createStage(_ input: CreateStageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Stage {
        return try await self.client.execute(operation: "CreateStage", path: "/restapis/{restApiId}/stages", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a usage plan with the throttle and quota limits, as well as the associated API stages, specified in the payload.
    public func createUsagePlan(_ input: CreateUsagePlanRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UsagePlan {
        return try await self.client.execute(operation: "CreateUsagePlan", path: "/usageplans", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a usage plan key for adding an existing API key to a usage plan.
    public func createUsagePlanKey(_ input: CreateUsagePlanKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UsagePlanKey {
        return try await self.client.execute(operation: "CreateUsagePlanKey", path: "/usageplans/{usagePlanId}/keys", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a VPC link, under the caller's account in a selected region, in an asynchronous operation that typically takes 2-4 minutes to complete and become operational. The caller must have permissions to create and update VPC Endpoint services.
    public func createVpcLink(_ input: CreateVpcLinkRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> VpcLink {
        return try await self.client.execute(operation: "CreateVpcLink", path: "/vpclinks", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the ApiKey resource.
    public func deleteApiKey(_ input: DeleteApiKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteApiKey", path: "/apikeys/{apiKey}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an existing Authorizer resource.
    public func deleteAuthorizer(_ input: DeleteAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteAuthorizer", path: "/restapis/{restApiId}/authorizers/{authorizerId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the BasePathMapping resource.
    public func deleteBasePathMapping(_ input: DeleteBasePathMappingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteBasePathMapping", path: "/domainnames/{domainName}/basepathmappings/{basePath}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the ClientCertificate resource.
    public func deleteClientCertificate(_ input: DeleteClientCertificateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteClientCertificate", path: "/clientcertificates/{clientCertificateId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a Deployment resource. Deleting a deployment will only succeed if there are no Stage resources associated with it.
    public func deleteDeployment(_ input: DeleteDeploymentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteDeployment", path: "/restapis/{restApiId}/deployments/{deploymentId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a documentation part
    public func deleteDocumentationPart(_ input: DeleteDocumentationPartRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteDocumentationPart", path: "/restapis/{restApiId}/documentation/parts/{documentationPartId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a documentation version.
    public func deleteDocumentationVersion(_ input: DeleteDocumentationVersionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteDocumentationVersion", path: "/restapis/{restApiId}/documentation/versions/{documentationVersion}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the DomainName resource.
    public func deleteDomainName(_ input: DeleteDomainNameRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteDomainName", path: "/domainnames/{domainName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Clears any customization of a GatewayResponse of a specified response type on the given RestApi and resets it with the default settings.
    public func deleteGatewayResponse(_ input: DeleteGatewayResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteGatewayResponse", path: "/restapis/{restApiId}/gatewayresponses/{responseType}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a delete integration.
    public func deleteIntegration(_ input: DeleteIntegrationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteIntegration", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a delete integration response.
    public func deleteIntegrationResponse(_ input: DeleteIntegrationResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteIntegrationResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an existing Method resource.
    public func deleteMethod(_ input: DeleteMethodRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteMethod", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an existing MethodResponse resource.
    public func deleteMethodResponse(_ input: DeleteMethodResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteMethodResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a model.
    public func deleteModel(_ input: DeleteModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteModel", path: "/restapis/{restApiId}/models/{modelName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a RequestValidator of a given RestApi.
    public func deleteRequestValidator(_ input: DeleteRequestValidatorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteRequestValidator", path: "/restapis/{restApiId}/requestvalidators/{requestValidatorId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a Resource resource.
    public func deleteResource(_ input: DeleteResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteResource", path: "/restapis/{restApiId}/resources/{resourceId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes the specified API.
    public func deleteRestApi(_ input: DeleteRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteRestApi", path: "/restapis/{restApiId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a Stage resource.
    public func deleteStage(_ input: DeleteStageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteStage", path: "/restapis/{restApiId}/stages/{stageName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a usage plan of a given plan Id.
    public func deleteUsagePlan(_ input: DeleteUsagePlanRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteUsagePlan", path: "/usageplans/{usagePlanId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a usage plan key  and remove the underlying API key from the associated usage plan.
    public func deleteUsagePlanKey(_ input: DeleteUsagePlanKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteUsagePlanKey", path: "/usageplans/{usagePlanId}/keys/{keyId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an existing VpcLink of a specified identifier.
    public func deleteVpcLink(_ input: DeleteVpcLinkRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "DeleteVpcLink", path: "/vpclinks/{vpcLinkId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Flushes all authorizer cache entries on a stage.
    public func flushStageAuthorizersCache(_ input: FlushStageAuthorizersCacheRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "FlushStageAuthorizersCache", path: "/restapis/{restApiId}/stages/{stageName}/cache/authorizers", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Flushes a stage's cache.
    public func flushStageCache(_ input: FlushStageCacheRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "FlushStageCache", path: "/restapis/{restApiId}/stages/{stageName}/cache/data", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Generates a ClientCertificate resource.
    public func generateClientCertificate(_ input: GenerateClientCertificateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ClientCertificate {
        return try await self.client.execute(operation: "GenerateClientCertificate", path: "/clientcertificates", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about the current Account resource.
    public func getAccount(_ input: GetAccountRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Account {
        return try await self.client.execute(operation: "GetAccount", path: "/account", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about the current ApiKey resource.
    public func getApiKey(_ input: GetApiKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ApiKey {
        return try await self.client.execute(operation: "GetApiKey", path: "/apikeys/{apiKey}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about the current ApiKeys resource.
    public func getApiKeys(_ input: GetApiKeysRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ApiKeys {
        return try await self.client.execute(operation: "GetApiKeys", path: "/apikeys", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe an existing Authorizer resource.
    public func getAuthorizer(_ input: GetAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Authorizer {
        return try await self.client.execute(operation: "GetAuthorizer", path: "/restapis/{restApiId}/authorizers/{authorizerId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe an existing Authorizers resource.
    public func getAuthorizers(_ input: GetAuthorizersRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Authorizers {
        return try await self.client.execute(operation: "GetAuthorizers", path: "/restapis/{restApiId}/authorizers", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe a BasePathMapping resource.
    public func getBasePathMapping(_ input: GetBasePathMappingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> BasePathMapping {
        return try await self.client.execute(operation: "GetBasePathMapping", path: "/domainnames/{domainName}/basepathmappings/{basePath}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a collection of BasePathMapping resources.
    public func getBasePathMappings(_ input: GetBasePathMappingsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> BasePathMappings {
        return try await self.client.execute(operation: "GetBasePathMappings", path: "/domainnames/{domainName}/basepathmappings", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about the current ClientCertificate resource.
    public func getClientCertificate(_ input: GetClientCertificateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ClientCertificate {
        return try await self.client.execute(operation: "GetClientCertificate", path: "/clientcertificates/{clientCertificateId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a collection of ClientCertificate resources.
    public func getClientCertificates(_ input: GetClientCertificatesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ClientCertificates {
        return try await self.client.execute(operation: "GetClientCertificates", path: "/clientcertificates", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a Deployment resource.
    public func getDeployment(_ input: GetDeploymentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Deployment {
        return try await self.client.execute(operation: "GetDeployment", path: "/restapis/{restApiId}/deployments/{deploymentId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a Deployments collection.
    public func getDeployments(_ input: GetDeploymentsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Deployments {
        return try await self.client.execute(operation: "GetDeployments", path: "/restapis/{restApiId}/deployments", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a documentation part.
    public func getDocumentationPart(_ input: GetDocumentationPartRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DocumentationPart {
        return try await self.client.execute(operation: "GetDocumentationPart", path: "/restapis/{restApiId}/documentation/parts/{documentationPartId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets documentation parts.
    public func getDocumentationParts(_ input: GetDocumentationPartsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DocumentationParts {
        return try await self.client.execute(operation: "GetDocumentationParts", path: "/restapis/{restApiId}/documentation/parts", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a documentation version.
    public func getDocumentationVersion(_ input: GetDocumentationVersionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DocumentationVersion {
        return try await self.client.execute(operation: "GetDocumentationVersion", path: "/restapis/{restApiId}/documentation/versions/{documentationVersion}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets documentation versions.
    public func getDocumentationVersions(_ input: GetDocumentationVersionsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DocumentationVersions {
        return try await self.client.execute(operation: "GetDocumentationVersions", path: "/restapis/{restApiId}/documentation/versions", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a domain name that is contained in a simpler, more intuitive URL that can be called.
    public func getDomainName(_ input: GetDomainNameRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DomainName {
        return try await self.client.execute(operation: "GetDomainName", path: "/domainnames/{domainName}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a collection of DomainName resources.
    public func getDomainNames(_ input: GetDomainNamesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DomainNames {
        return try await self.client.execute(operation: "GetDomainNames", path: "/domainnames", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Exports a deployed version of a RestApi in a specified format.
    public func getExport(_ input: GetExportRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ExportResponse {
        return try await self.client.execute(operation: "GetExport", path: "/restapis/{restApiId}/stages/{stageName}/exports/{exportType}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a GatewayResponse of a specified response type on the given RestApi.
    public func getGatewayResponse(_ input: GetGatewayResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GatewayResponse {
        return try await self.client.execute(operation: "GetGatewayResponse", path: "/restapis/{restApiId}/gatewayresponses/{responseType}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the GatewayResponses collection on the given RestApi. If an API developer has not added any definitions for gateway responses, the result will be the API Gateway-generated default GatewayResponses collection for the supported response types.
    public func getGatewayResponses(_ input: GetGatewayResponsesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GatewayResponses {
        return try await self.client.execute(operation: "GetGatewayResponses", path: "/restapis/{restApiId}/gatewayresponses", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get the integration settings.
    public func getIntegration(_ input: GetIntegrationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Integration {
        return try await self.client.execute(operation: "GetIntegration", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a get integration response.
    public func getIntegrationResponse(_ input: GetIntegrationResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> IntegrationResponse {
        return try await self.client.execute(operation: "GetIntegrationResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe an existing Method resource.
    public func getMethod(_ input: GetMethodRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Method {
        return try await self.client.execute(operation: "GetMethod", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes a MethodResponse resource.
    public func getMethodResponse(_ input: GetMethodResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> MethodResponse {
        return try await self.client.execute(operation: "GetMethodResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes an existing model defined for a RestApi resource.
    public func getModel(_ input: GetModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Model {
        return try await self.client.execute(operation: "GetModel", path: "/restapis/{restApiId}/models/{modelName}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Generates a sample mapping template that can be used to transform a payload into the structure of a model.
    public func getModelTemplate(_ input: GetModelTemplateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Template {
        return try await self.client.execute(operation: "GetModelTemplate", path: "/restapis/{restApiId}/models/{modelName}/default_template", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes existing Models defined for a RestApi resource.
    public func getModels(_ input: GetModelsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Models {
        return try await self.client.execute(operation: "GetModels", path: "/restapis/{restApiId}/models", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a RequestValidator of a given RestApi.
    public func getRequestValidator(_ input: GetRequestValidatorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> RequestValidator {
        return try await self.client.execute(operation: "GetRequestValidator", path: "/restapis/{restApiId}/requestvalidators/{requestValidatorId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the RequestValidators collection of a given RestApi.
    public func getRequestValidators(_ input: GetRequestValidatorsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> RequestValidators {
        return try await self.client.execute(operation: "GetRequestValidators", path: "/restapis/{restApiId}/requestvalidators", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists information about a resource.
    public func getResource(_ input: GetResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Resource {
        return try await self.client.execute(operation: "GetResource", path: "/restapis/{restApiId}/resources/{resourceId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists information about a collection of Resource resources.
    public func getResources(_ input: GetResourcesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Resources {
        return try await self.client.execute(operation: "GetResources", path: "/restapis/{restApiId}/resources", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the RestApi resource in the collection.
    public func getRestApi(_ input: GetRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> RestApi {
        return try await self.client.execute(operation: "GetRestApi", path: "/restapis/{restApiId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the RestApis resources for your collection.
    public func getRestApis(_ input: GetRestApisRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> RestApis {
        return try await self.client.execute(operation: "GetRestApis", path: "/restapis", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Generates a client SDK for a RestApi and Stage.
    public func getSdk(_ input: GetSdkRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> SdkResponse {
        return try await self.client.execute(operation: "GetSdk", path: "/restapis/{restApiId}/stages/{stageName}/sdks/{sdkType}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets an SDK type.
    public func getSdkType(_ input: GetSdkTypeRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> SdkType {
        return try await self.client.execute(operation: "GetSdkType", path: "/sdktypes/{id}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets SDK types
    public func getSdkTypes(_ input: GetSdkTypesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> SdkTypes {
        return try await self.client.execute(operation: "GetSdkTypes", path: "/sdktypes", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a Stage resource.
    public func getStage(_ input: GetStageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Stage {
        return try await self.client.execute(operation: "GetStage", path: "/restapis/{restApiId}/stages/{stageName}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about one or more Stage resources.
    public func getStages(_ input: GetStagesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Stages {
        return try await self.client.execute(operation: "GetStages", path: "/restapis/{restApiId}/stages", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the Tags collection for a given resource.
    public func getTags(_ input: GetTagsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Tags {
        return try await self.client.execute(operation: "GetTags", path: "/tags/{resourceArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the usage data of a usage plan in a specified time interval.
    public func getUsage(_ input: GetUsageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Usage {
        return try await self.client.execute(operation: "GetUsage", path: "/usageplans/{usagePlanId}/usage", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a usage plan of a given plan identifier.
    public func getUsagePlan(_ input: GetUsagePlanRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UsagePlan {
        return try await self.client.execute(operation: "GetUsagePlan", path: "/usageplans/{usagePlanId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a usage plan key of a given key identifier.
    public func getUsagePlanKey(_ input: GetUsagePlanKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UsagePlanKey {
        return try await self.client.execute(operation: "GetUsagePlanKey", path: "/usageplans/{usagePlanId}/keys/{keyId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets all the usage plan keys representing the API keys added to a specified usage plan.
    public func getUsagePlanKeys(_ input: GetUsagePlanKeysRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UsagePlanKeys {
        return try await self.client.execute(operation: "GetUsagePlanKeys", path: "/usageplans/{usagePlanId}/keys", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets all the usage plans of the caller's account.
    public func getUsagePlans(_ input: GetUsagePlansRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UsagePlans {
        return try await self.client.execute(operation: "GetUsagePlans", path: "/usageplans", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets a specified VPC link under the caller's account in a region.
    public func getVpcLink(_ input: GetVpcLinkRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> VpcLink {
        return try await self.client.execute(operation: "GetVpcLink", path: "/vpclinks/{vpcLinkId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets the VpcLinks collection under the caller's account in a selected region.
    public func getVpcLinks(_ input: GetVpcLinksRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> VpcLinks {
        return try await self.client.execute(operation: "GetVpcLinks", path: "/vpclinks", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Import API keys from an external source, such as a CSV-formatted file.
    public func importApiKeys(_ input: ImportApiKeysRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ApiKeyIds {
        return try await self.client.execute(operation: "ImportApiKeys", path: "/apikeys?mode=import", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Imports documentation parts
    public func importDocumentationParts(_ input: ImportDocumentationPartsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DocumentationPartIds {
        return try await self.client.execute(operation: "ImportDocumentationParts", path: "/restapis/{restApiId}/documentation/parts", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// A feature of the API Gateway control service for creating a new API from an external API definition file.
    public func importRestApi(_ input: ImportRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> RestApi {
        return try await self.client.execute(operation: "ImportRestApi", path: "/restapis?mode=import", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a customization of a GatewayResponse of a specified response type and status code on the given RestApi.
    public func putGatewayResponse(_ input: PutGatewayResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GatewayResponse {
        return try await self.client.execute(operation: "PutGatewayResponse", path: "/restapis/{restApiId}/gatewayresponses/{responseType}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Sets up a method's integration.
    public func putIntegration(_ input: PutIntegrationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Integration {
        return try await self.client.execute(operation: "PutIntegration", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents a put integration.
    public func putIntegrationResponse(_ input: PutIntegrationResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> IntegrationResponse {
        return try await self.client.execute(operation: "PutIntegrationResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Add a method to an existing Resource resource.
    public func putMethod(_ input: PutMethodRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Method {
        return try await self.client.execute(operation: "PutMethod", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds a MethodResponse to an existing Method resource.
    public func putMethodResponse(_ input: PutMethodResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> MethodResponse {
        return try await self.client.execute(operation: "PutMethodResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// A feature of the API Gateway control service for updating an existing API with an input of external API definitions. The update can take the form of merging the supplied definition into the existing API or overwriting the existing API.
    public func putRestApi(_ input: PutRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> RestApi {
        return try await self.client.execute(operation: "PutRestApi", path: "/restapis/{restApiId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds or updates a tag on a given resource.
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "TagResource", path: "/tags/{resourceArn}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Simulate the execution of an Authorizer in your RestApi with headers, parameters, and an incoming request body.
    public func testInvokeAuthorizer(_ input: TestInvokeAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> TestInvokeAuthorizerResponse {
        return try await self.client.execute(operation: "TestInvokeAuthorizer", path: "/restapis/{restApiId}/authorizers/{authorizerId}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Simulate the invocation of a Method in your RestApi with headers, parameters, and an incoming request body.
    public func testInvokeMethod(_ input: TestInvokeMethodRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> TestInvokeMethodResponse {
        return try await self.client.execute(operation: "TestInvokeMethod", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes a tag from a given resource.
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws {
        return try await self.client.execute(operation: "UntagResource", path: "/tags/{resourceArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about the current Account resource.
    public func updateAccount(_ input: UpdateAccountRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Account {
        return try await self.client.execute(operation: "UpdateAccount", path: "/account", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about an ApiKey resource.
    public func updateApiKey(_ input: UpdateApiKeyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ApiKey {
        return try await self.client.execute(operation: "UpdateApiKey", path: "/apikeys/{apiKey}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an existing Authorizer resource.
    public func updateAuthorizer(_ input: UpdateAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Authorizer {
        return try await self.client.execute(operation: "UpdateAuthorizer", path: "/restapis/{restApiId}/authorizers/{authorizerId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about the BasePathMapping resource.
    public func updateBasePathMapping(_ input: UpdateBasePathMappingRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> BasePathMapping {
        return try await self.client.execute(operation: "UpdateBasePathMapping", path: "/domainnames/{domainName}/basepathmappings/{basePath}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about an ClientCertificate resource.
    public func updateClientCertificate(_ input: UpdateClientCertificateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ClientCertificate {
        return try await self.client.execute(operation: "UpdateClientCertificate", path: "/clientcertificates/{clientCertificateId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about a Deployment resource.
    public func updateDeployment(_ input: UpdateDeploymentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Deployment {
        return try await self.client.execute(operation: "UpdateDeployment", path: "/restapis/{restApiId}/deployments/{deploymentId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a documentation part.
    public func updateDocumentationPart(_ input: UpdateDocumentationPartRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DocumentationPart {
        return try await self.client.execute(operation: "UpdateDocumentationPart", path: "/restapis/{restApiId}/documentation/parts/{documentationPartId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a documentation version.
    public func updateDocumentationVersion(_ input: UpdateDocumentationVersionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DocumentationVersion {
        return try await self.client.execute(operation: "UpdateDocumentationVersion", path: "/restapis/{restApiId}/documentation/versions/{documentationVersion}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about the DomainName resource.
    public func updateDomainName(_ input: UpdateDomainNameRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DomainName {
        return try await self.client.execute(operation: "UpdateDomainName", path: "/domainnames/{domainName}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a GatewayResponse of a specified response type on the given RestApi.
    public func updateGatewayResponse(_ input: UpdateGatewayResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GatewayResponse {
        return try await self.client.execute(operation: "UpdateGatewayResponse", path: "/restapis/{restApiId}/gatewayresponses/{responseType}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents an update integration.
    public func updateIntegration(_ input: UpdateIntegrationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Integration {
        return try await self.client.execute(operation: "UpdateIntegration", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Represents an update integration response.
    public func updateIntegrationResponse(_ input: UpdateIntegrationResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> IntegrationResponse {
        return try await self.client.execute(operation: "UpdateIntegrationResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an existing Method resource.
    public func updateMethod(_ input: UpdateMethodRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Method {
        return try await self.client.execute(operation: "UpdateMethod", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an existing MethodResponse resource.
    public func updateMethodResponse(_ input: UpdateMethodResponseRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> MethodResponse {
        return try await self.client.execute(operation: "UpdateMethodResponse", path: "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about a model.
    public func updateModel(_ input: UpdateModelRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Model {
        return try await self.client.execute(operation: "UpdateModel", path: "/restapis/{restApiId}/models/{modelName}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a RequestValidator of a given RestApi.
    public func updateRequestValidator(_ input: UpdateRequestValidatorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> RequestValidator {
        return try await self.client.execute(operation: "UpdateRequestValidator", path: "/restapis/{restApiId}/requestvalidators/{requestValidatorId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about a Resource resource.
    public func updateResource(_ input: UpdateResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Resource {
        return try await self.client.execute(operation: "UpdateResource", path: "/restapis/{restApiId}/resources/{resourceId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about the specified API.
    public func updateRestApi(_ input: UpdateRestApiRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> RestApi {
        return try await self.client.execute(operation: "UpdateRestApi", path: "/restapis/{restApiId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Changes information about a Stage resource.
    public func updateStage(_ input: UpdateStageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Stage {
        return try await self.client.execute(operation: "UpdateStage", path: "/restapis/{restApiId}/stages/{stageName}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Grants a temporary extension to the remaining quota of a usage plan associated with a specified API key.
    public func updateUsage(_ input: UpdateUsageRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> Usage {
        return try await self.client.execute(operation: "UpdateUsage", path: "/usageplans/{usagePlanId}/keys/{keyId}/usage", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a usage plan of a given plan Id.
    public func updateUsagePlan(_ input: UpdateUsagePlanRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UsagePlan {
        return try await self.client.execute(operation: "UpdateUsagePlan", path: "/usageplans/{usagePlanId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an existing VpcLink of a specified identifier.
    public func updateVpcLink(_ input: UpdateVpcLinkRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> VpcLink {
        return try await self.client.execute(operation: "UpdateVpcLink", path: "/vpclinks/{vpcLinkId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension APIGateway {
    ///  Gets information about the current ApiKeys resource.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getApiKeysPaginator(
        _ input: GetApiKeysRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetApiKeysRequest, ApiKeys> {
        return .init(
            input: input,
            command: self.getApiKeys,
            inputKey: \GetApiKeysRequest.position,
            outputKey: \ApiKeys.position,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Represents a collection of BasePathMapping resources.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getBasePathMappingsPaginator(
        _ input: GetBasePathMappingsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetBasePathMappingsRequest, BasePathMappings> {
        return .init(
            input: input,
            command: self.getBasePathMappings,
            inputKey: \GetBasePathMappingsRequest.position,
            outputKey: \BasePathMappings.position,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Gets a collection of ClientCertificate resources.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getClientCertificatesPaginator(
        _ input: GetClientCertificatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetClientCertificatesRequest, ClientCertificates> {
        return .init(
            input: input,
            command: self.getClientCertificates,
            inputKey: \GetClientCertificatesRequest.position,
            outputKey: \ClientCertificates.position,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Gets information about a Deployments collection.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getDeploymentsPaginator(
        _ input: GetDeploymentsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetDeploymentsRequest, Deployments> {
        return .init(
            input: input,
            command: self.getDeployments,
            inputKey: \GetDeploymentsRequest.position,
            outputKey: \Deployments.position,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Represents a collection of DomainName resources.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getDomainNamesPaginator(
        _ input: GetDomainNamesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetDomainNamesRequest, DomainNames> {
        return .init(
            input: input,
            command: self.getDomainNames,
            inputKey: \GetDomainNamesRequest.position,
            outputKey: \DomainNames.position,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Describes existing Models defined for a RestApi resource.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getModelsPaginator(
        _ input: GetModelsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetModelsRequest, Models> {
        return .init(
            input: input,
            command: self.getModels,
            inputKey: \GetModelsRequest.position,
            outputKey: \Models.position,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Lists information about a collection of Resource resources.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getResourcesPaginator(
        _ input: GetResourcesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetResourcesRequest, Resources> {
        return .init(
            input: input,
            command: self.getResources,
            inputKey: \GetResourcesRequest.position,
            outputKey: \Resources.position,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Lists the RestApis resources for your collection.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getRestApisPaginator(
        _ input: GetRestApisRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetRestApisRequest, RestApis> {
        return .init(
            input: input,
            command: self.getRestApis,
            inputKey: \GetRestApisRequest.position,
            outputKey: \RestApis.position,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Gets the usage data of a usage plan in a specified time interval.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getUsagePaginator(
        _ input: GetUsageRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetUsageRequest, Usage> {
        return .init(
            input: input,
            command: self.getUsage,
            inputKey: \GetUsageRequest.position,
            outputKey: \Usage.position,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Gets all the usage plan keys representing the API keys added to a specified usage plan.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getUsagePlanKeysPaginator(
        _ input: GetUsagePlanKeysRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetUsagePlanKeysRequest, UsagePlanKeys> {
        return .init(
            input: input,
            command: self.getUsagePlanKeys,
            inputKey: \GetUsagePlanKeysRequest.position,
            outputKey: \UsagePlanKeys.position,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Gets all the usage plans of the caller's account.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getUsagePlansPaginator(
        _ input: GetUsagePlansRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetUsagePlansRequest, UsagePlans> {
        return .init(
            input: input,
            command: self.getUsagePlans,
            inputKey: \GetUsagePlansRequest.position,
            outputKey: \UsagePlans.position,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Gets the VpcLinks collection under the caller's account in a selected region.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getVpcLinksPaginator(
        _ input: GetVpcLinksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetVpcLinksRequest, VpcLinks> {
        return .init(
            input: input,
            command: self.getVpcLinks,
            inputKey: \GetVpcLinksRequest.position,
            outputKey: \VpcLinks.position,
            logger: logger,
            on: eventLoop
        )
    }
}

#endif // compiler(>=5.5.2) && canImport(_Concurrency)
