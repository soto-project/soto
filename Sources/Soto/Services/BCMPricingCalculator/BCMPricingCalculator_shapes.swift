//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BCMPricingCalculator {
    // MARK: Enums

    public enum BatchCreateBillScenarioCommitmentModificationErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conflict = "CONFLICT"
        case internalServerError = "INTERNAL_SERVER_ERROR"
        case invalidAccount = "INVALID_ACCOUNT"
        public var description: String { return self.rawValue }
    }

    public enum BatchCreateBillScenarioUsageModificationErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case badRequest = "BAD_REQUEST"
        case conflict = "CONFLICT"
        case internalServerError = "INTERNAL_SERVER_ERROR"
        case notFound = "NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum BatchCreateWorkloadEstimateUsageCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case badRequest = "BAD_REQUEST"
        case conflict = "CONFLICT"
        case internalServerError = "INTERNAL_SERVER_ERROR"
        case notFound = "NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum BatchDeleteBillScenarioCommitmentModificationErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case badRequest = "BAD_REQUEST"
        case conflict = "CONFLICT"
        case internalServerError = "INTERNAL_SERVER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum BatchDeleteBillScenarioUsageModificationErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case badRequest = "BAD_REQUEST"
        case conflict = "CONFLICT"
        case internalServerError = "INTERNAL_SERVER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum BatchUpdateBillScenarioCommitmentModificationErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case badRequest = "BAD_REQUEST"
        case conflict = "CONFLICT"
        case internalServerError = "INTERNAL_SERVER_ERROR"
        case notFound = "NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum BatchUpdateBillScenarioUsageModificationErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case badRequest = "BAD_REQUEST"
        case conflict = "CONFLICT"
        case internalServerError = "INTERNAL_SERVER_ERROR"
        case notFound = "NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum BillEstimateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum BillScenarioStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case locked = "LOCKED"
        case ready = "READY"
        case stale = "STALE"
        public var description: String { return self.rawValue }
    }

    public enum CurrencyCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case usd = "USD"
        public var description: String { return self.rawValue }
    }

    public enum ListBillEstimateLineItemsFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lineItemType = "LINE_ITEM_TYPE"
        case location = "LOCATION"
        case operation = "OPERATION"
        case serviceCode = "SERVICE_CODE"
        case usageAccountId = "USAGE_ACCOUNT_ID"
        case usageType = "USAGE_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum ListBillEstimatesFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum ListBillScenariosFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum ListUsageFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case historicalLocation = "HISTORICAL_LOCATION"
        case historicalOperation = "HISTORICAL_OPERATION"
        case historicalServiceCode = "HISTORICAL_SERVICE_CODE"
        case historicalUsageAccountId = "HISTORICAL_USAGE_ACCOUNT_ID"
        case historicalUsageType = "HISTORICAL_USAGE_TYPE"
        case location = "LOCATION"
        case operation = "OPERATION"
        case serviceCode = "SERVICE_CODE"
        case usageAccountId = "USAGE_ACCOUNT_ID"
        case usageGroup = "USAGE_GROUP"
        case usageType = "USAGE_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum ListWorkloadEstimatesFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum MatchOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case equals = "EQUALS"
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    public enum PurchaseAgreementType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case reservedInstance = "RESERVED_INSTANCE"
        case savingsPlans = "SAVINGS_PLANS"
        public var description: String { return self.rawValue }
    }

    public enum RateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case afterDiscounts = "AFTER_DISCOUNTS"
        case beforeDiscounts = "BEFORE_DISCOUNTS"
        public var description: String { return self.rawValue }
    }

    public enum WorkloadEstimateCostStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case invalid = "INVALID"
        case stale = "STALE"
        case valid = "VALID"
        public var description: String { return self.rawValue }
    }

    public enum WorkloadEstimateRateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case afterDiscounts = "AFTER_DISCOUNTS"
        case beforeDiscounts = "BEFORE_DISCOUNTS"
        public var description: String { return self.rawValue }
    }

    public enum WorkloadEstimateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionNeeded = "ACTION_NEEDED"
        case invalid = "INVALID"
        case updating = "UPDATING"
        case valid = "VALID"
        public var description: String { return self.rawValue }
    }

    public enum WorkloadEstimateUpdateUsageErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case badRequest = "BAD_REQUEST"
        case conflict = "CONFLICT"
        case internalServerError = "INTERNAL_SERVER_ERROR"
        case notFound = "NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum BillScenarioCommitmentModificationAction: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  Action to add a Reserved Instance to the scenario.
        case addReservedInstanceAction(AddReservedInstanceAction)
        ///  Action to add a Savings Plan to the scenario.
        case addSavingsPlanAction(AddSavingsPlanAction)
        ///  Action to remove a Reserved Instance from the scenario.
        case negateReservedInstanceAction(NegateReservedInstanceAction)
        ///  Action to remove a Savings Plan from the scenario.
        case negateSavingsPlanAction(NegateSavingsPlanAction)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .addReservedInstanceAction:
                let value = try container.decode(AddReservedInstanceAction.self, forKey: .addReservedInstanceAction)
                self = .addReservedInstanceAction(value)
            case .addSavingsPlanAction:
                let value = try container.decode(AddSavingsPlanAction.self, forKey: .addSavingsPlanAction)
                self = .addSavingsPlanAction(value)
            case .negateReservedInstanceAction:
                let value = try container.decode(NegateReservedInstanceAction.self, forKey: .negateReservedInstanceAction)
                self = .negateReservedInstanceAction(value)
            case .negateSavingsPlanAction:
                let value = try container.decode(NegateSavingsPlanAction.self, forKey: .negateSavingsPlanAction)
                self = .negateSavingsPlanAction(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .addReservedInstanceAction(let value):
                try container.encode(value, forKey: .addReservedInstanceAction)
            case .addSavingsPlanAction(let value):
                try container.encode(value, forKey: .addSavingsPlanAction)
            case .negateReservedInstanceAction(let value):
                try container.encode(value, forKey: .negateReservedInstanceAction)
            case .negateSavingsPlanAction(let value):
                try container.encode(value, forKey: .negateSavingsPlanAction)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .addReservedInstanceAction(let value):
                try value.validate(name: "\(name).addReservedInstanceAction")
            case .addSavingsPlanAction(let value):
                try value.validate(name: "\(name).addSavingsPlanAction")
            case .negateReservedInstanceAction(let value):
                try value.validate(name: "\(name).negateReservedInstanceAction")
            case .negateSavingsPlanAction(let value):
                try value.validate(name: "\(name).negateSavingsPlanAction")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case addReservedInstanceAction = "addReservedInstanceAction"
            case addSavingsPlanAction = "addSavingsPlanAction"
            case negateReservedInstanceAction = "negateReservedInstanceAction"
            case negateSavingsPlanAction = "negateSavingsPlanAction"
        }
    }

    // MARK: Shapes

    public struct AddReservedInstanceAction: AWSEncodableShape & AWSDecodableShape {
        ///  The number of instances to add for this Reserved Instance offering.
        public let instanceCount: Int?
        ///  The ID of the Reserved Instance offering to add. For more information, see   DescribeReservedInstancesOfferings.
        public let reservedInstancesOfferingId: String?

        @inlinable
        public init(instanceCount: Int? = nil, reservedInstancesOfferingId: String? = nil) {
            self.instanceCount = instanceCount
            self.reservedInstancesOfferingId = reservedInstancesOfferingId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, min: 1)
            try self.validate(self.reservedInstancesOfferingId, name: "reservedInstancesOfferingId", parent: name, max: 36)
            try self.validate(self.reservedInstancesOfferingId, name: "reservedInstancesOfferingId", parent: name, min: 36)
            try self.validate(self.reservedInstancesOfferingId, name: "reservedInstancesOfferingId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "instanceCount"
            case reservedInstancesOfferingId = "reservedInstancesOfferingId"
        }
    }

    public struct AddSavingsPlanAction: AWSEncodableShape & AWSDecodableShape {
        ///  The hourly commitment, in the same currency of the savingsPlanOfferingId.  This is a value between 0.001 and 1 million. You cannot specify more than five digits after the decimal point.
        public let commitment: Double?
        ///  The ID of the Savings Plan offering to add. For more information, see   DescribeSavingsPlansOfferings.
        public let savingsPlanOfferingId: String?

        @inlinable
        public init(commitment: Double? = nil, savingsPlanOfferingId: String? = nil) {
            self.commitment = commitment
            self.savingsPlanOfferingId = savingsPlanOfferingId
        }

        public func validate(name: String) throws {
            try self.validate(self.commitment, name: "commitment", parent: name, max: 1000000.0)
            try self.validate(self.commitment, name: "commitment", parent: name, min: 0.001)
            try self.validate(self.savingsPlanOfferingId, name: "savingsPlanOfferingId", parent: name, max: 36)
            try self.validate(self.savingsPlanOfferingId, name: "savingsPlanOfferingId", parent: name, min: 36)
            try self.validate(self.savingsPlanOfferingId, name: "savingsPlanOfferingId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case commitment = "commitment"
            case savingsPlanOfferingId = "savingsPlanOfferingId"
        }
    }

    public struct BatchCreateBillScenarioCommitmentModificationEntry: AWSEncodableShape {
        ///  The specific commitment action to be taken (e.g., adding a Reserved Instance or Savings Plan).
        public let commitmentAction: BillScenarioCommitmentModificationAction
        ///  An optional group identifier for the commitment modification.
        public let group: String?
        ///  A unique identifier for this entry in the batch operation. This can be any valid string.  This key is useful to identify errors associated with any commitment entry as any error is  returned with this key.
        public let key: String
        ///  The Amazon Web Services account ID to which this commitment will be applied to.
        public let usageAccountId: String

        @inlinable
        public init(commitmentAction: BillScenarioCommitmentModificationAction, group: String? = nil, key: String, usageAccountId: String) {
            self.commitmentAction = commitmentAction
            self.group = group
            self.key = key
            self.usageAccountId = usageAccountId
        }

        public func validate(name: String) throws {
            try self.commitmentAction.validate(name: "\(name).commitmentAction")
            try self.validate(self.group, name: "group", parent: name, max: 30)
            try self.validate(self.group, name: "group", parent: name, pattern: "^[a-zA-Z0-9-]*$")
            try self.validate(self.key, name: "key", parent: name, max: 10)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, max: 12)
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, min: 12)
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case commitmentAction = "commitmentAction"
            case group = "group"
            case key = "key"
            case usageAccountId = "usageAccountId"
        }
    }

    public struct BatchCreateBillScenarioCommitmentModificationError: AWSDecodableShape {
        ///  The error code associated with the failed operation.
        public let errorCode: BatchCreateBillScenarioCommitmentModificationErrorCode?
        ///  A descriptive message for the error that occurred.
        public let errorMessage: String?
        ///  The key of the entry that caused the error.
        public let key: String?

        @inlinable
        public init(errorCode: BatchCreateBillScenarioCommitmentModificationErrorCode? = nil, errorMessage: String? = nil, key: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case key = "key"
        }
    }

    public struct BatchCreateBillScenarioCommitmentModificationItem: AWSDecodableShape {
        ///  The specific commitment action that was taken.
        public let commitmentAction: BillScenarioCommitmentModificationAction?
        ///  The group identifier for the created commitment modification.
        public let group: String?
        ///  The unique identifier assigned to the created commitment modification.
        public let id: String?
        ///  The key of the successfully created entry. This can be any valid string. This key is useful to  identify errors associated with any commitment entry as any error is returned with this key.
        public let key: String?
        ///  The Amazon Web Services account ID associated with the created commitment modification.
        public let usageAccountId: String?

        @inlinable
        public init(commitmentAction: BillScenarioCommitmentModificationAction? = nil, group: String? = nil, id: String? = nil, key: String? = nil, usageAccountId: String? = nil) {
            self.commitmentAction = commitmentAction
            self.group = group
            self.id = id
            self.key = key
            self.usageAccountId = usageAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case commitmentAction = "commitmentAction"
            case group = "group"
            case id = "id"
            case key = "key"
            case usageAccountId = "usageAccountId"
        }
    }

    public struct BatchCreateBillScenarioCommitmentModificationRequest: AWSEncodableShape {
        ///  The ID of the Bill Scenario for which you want to create the modeled commitment.
        public let billScenarioId: String
        ///  A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        ///  List of commitments that you want to model in the Bill Scenario.
        public let commitmentModifications: [BatchCreateBillScenarioCommitmentModificationEntry]

        @inlinable
        public init(billScenarioId: String, clientToken: String? = BatchCreateBillScenarioCommitmentModificationRequest.idempotencyToken(), commitmentModifications: [BatchCreateBillScenarioCommitmentModificationEntry]) {
            self.billScenarioId = billScenarioId
            self.clientToken = clientToken
            self.commitmentModifications = commitmentModifications
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.billScenarioId, forKey: .billScenarioId)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encode(self.commitmentModifications, forKey: .commitmentModifications)
        }

        public func validate(name: String) throws {
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, max: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, min: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\u0021-\\u007E]+$")
            try self.commitmentModifications.forEach {
                try $0.validate(name: "\(name).commitmentModifications[]")
            }
            try self.validate(self.commitmentModifications, name: "commitmentModifications", parent: name, max: 25)
            try self.validate(self.commitmentModifications, name: "commitmentModifications", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billScenarioId = "billScenarioId"
            case commitmentModifications = "commitmentModifications"
        }
    }

    public struct BatchCreateBillScenarioCommitmentModificationResponse: AWSDecodableShape {
        ///  Returns the list of errors reason and the commitment item keys that cannot be created in the Bill Scenario.
        public let errors: [BatchCreateBillScenarioCommitmentModificationError]?
        ///  Returns the list of successful commitment line items that were created for the Bill Scenario.
        public let items: [BatchCreateBillScenarioCommitmentModificationItem]?

        @inlinable
        public init(errors: [BatchCreateBillScenarioCommitmentModificationError]? = nil, items: [BatchCreateBillScenarioCommitmentModificationItem]? = nil) {
            self.errors = errors
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case items = "items"
        }
    }

    public struct BatchCreateBillScenarioUsageModificationEntry: AWSEncodableShape {
        ///  The amount of usage you want to create for the service use you are modeling.
        public let amounts: [UsageAmount]?
        ///  The Availability Zone that this usage line uses.
        public let availabilityZone: String?
        ///  An optional group identifier for the usage modification.
        public let group: String?
        ///  Historical usage data associated with this modification, if available.
        public let historicalUsage: HistoricalUsageEntity?
        ///  A unique identifier for this entry in the batch operation. This can be any valid string. This key is useful to identify errors  associated with any usage entry as any error is returned with this key.
        public let key: String
        ///  The specific operation associated with this usage modification. Describes the specific Amazon Web Services operation that this usage line models.  For example, RunInstances indicates the operation of an Amazon EC2 instance.
        public let operation: String
        ///  The Amazon Web Services service code for this usage modification. This identifies the specific Amazon Web Services service to the customer as  a unique short abbreviation. For example, AmazonEC2  and AWSKMS.
        public let serviceCode: String
        ///  The Amazon Web Services account ID to which this usage will be applied to.
        public let usageAccountId: String
        ///  Describes the usage details of the usage line item.
        public let usageType: String

        @inlinable
        public init(amounts: [UsageAmount]? = nil, availabilityZone: String? = nil, group: String? = nil, historicalUsage: HistoricalUsageEntity? = nil, key: String, operation: String, serviceCode: String, usageAccountId: String, usageType: String) {
            self.amounts = amounts
            self.availabilityZone = availabilityZone
            self.group = group
            self.historicalUsage = historicalUsage
            self.key = key
            self.operation = operation
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, max: 32)
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "^[-a-zA-Z0-9\\.\\-_:, \\/()]*$")
            try self.validate(self.group, name: "group", parent: name, max: 30)
            try self.validate(self.group, name: "group", parent: name, pattern: "^[a-zA-Z0-9-]*$")
            try self.historicalUsage?.validate(name: "\(name).historicalUsage")
            try self.validate(self.key, name: "key", parent: name, max: 10)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.operation, name: "operation", parent: name, max: 32)
            try self.validate(self.operation, name: "operation", parent: name, pattern: "^[-a-zA-Z0-9\\.\\-_:, \\/()]*$")
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, max: 32)
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, pattern: "^[-a-zA-Z0-9\\.\\-_:, \\/()]*$")
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, max: 12)
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, min: 12)
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.usageType, name: "usageType", parent: name, max: 128)
            try self.validate(self.usageType, name: "usageType", parent: name, pattern: "^[-a-zA-Z0-9\\.\\-_:, \\/()]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case amounts = "amounts"
            case availabilityZone = "availabilityZone"
            case group = "group"
            case historicalUsage = "historicalUsage"
            case key = "key"
            case operation = "operation"
            case serviceCode = "serviceCode"
            case usageAccountId = "usageAccountId"
            case usageType = "usageType"
        }
    }

    public struct BatchCreateBillScenarioUsageModificationError: AWSDecodableShape {
        ///  The error code associated with the failed operation.
        public let errorCode: BatchCreateBillScenarioUsageModificationErrorCode?
        ///  A descriptive message for the error that occurred.
        public let errorMessage: String?
        ///  The key of the entry that caused the error.
        public let key: String?

        @inlinable
        public init(errorCode: BatchCreateBillScenarioUsageModificationErrorCode? = nil, errorMessage: String? = nil, key: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case key = "key"
        }
    }

    public struct BatchCreateBillScenarioUsageModificationItem: AWSDecodableShape {
        ///  The availability zone associated with this usage modification, if applicable.
        public let availabilityZone: String?
        ///  The group identifier for the created usage modification.
        public let group: String?
        ///  Historical usage data associated with this modification, if available.
        public let historicalUsage: HistoricalUsageEntity?
        ///  The unique identifier assigned to the created usage modification.
        public let id: String?
        ///  The key of the successfully created entry.
        public let key: String?
        ///  The location associated with this usage modification.
        public let location: String?
        ///  The specific operation associated with this usage modification.
        public let operation: String
        ///  The modified usage quantities.
        public let quantities: [UsageQuantity]?
        ///  The Amazon Web Services service code for this usage modification.
        public let serviceCode: String
        ///  The Amazon Web Services account ID associated with the created usage modification.
        public let usageAccountId: String?
        ///  The type of usage that was modified.
        public let usageType: String

        @inlinable
        public init(availabilityZone: String? = nil, group: String? = nil, historicalUsage: HistoricalUsageEntity? = nil, id: String? = nil, key: String? = nil, location: String? = nil, operation: String, quantities: [UsageQuantity]? = nil, serviceCode: String, usageAccountId: String? = nil, usageType: String) {
            self.availabilityZone = availabilityZone
            self.group = group
            self.historicalUsage = historicalUsage
            self.id = id
            self.key = key
            self.location = location
            self.operation = operation
            self.quantities = quantities
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case group = "group"
            case historicalUsage = "historicalUsage"
            case id = "id"
            case key = "key"
            case location = "location"
            case operation = "operation"
            case quantities = "quantities"
            case serviceCode = "serviceCode"
            case usageAccountId = "usageAccountId"
            case usageType = "usageType"
        }
    }

    public struct BatchCreateBillScenarioUsageModificationRequest: AWSEncodableShape {
        ///  The ID of the Bill Scenario for which you want to create the modeled usage.
        public let billScenarioId: String
        ///  A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        ///  List of usage that you want to model in the Bill Scenario.
        public let usageModifications: [BatchCreateBillScenarioUsageModificationEntry]

        @inlinable
        public init(billScenarioId: String, clientToken: String? = BatchCreateBillScenarioUsageModificationRequest.idempotencyToken(), usageModifications: [BatchCreateBillScenarioUsageModificationEntry]) {
            self.billScenarioId = billScenarioId
            self.clientToken = clientToken
            self.usageModifications = usageModifications
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.billScenarioId, forKey: .billScenarioId)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encode(self.usageModifications, forKey: .usageModifications)
        }

        public func validate(name: String) throws {
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, max: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, min: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\u0021-\\u007E]+$")
            try self.usageModifications.forEach {
                try $0.validate(name: "\(name).usageModifications[]")
            }
            try self.validate(self.usageModifications, name: "usageModifications", parent: name, max: 25)
            try self.validate(self.usageModifications, name: "usageModifications", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billScenarioId = "billScenarioId"
            case usageModifications = "usageModifications"
        }
    }

    public struct BatchCreateBillScenarioUsageModificationResponse: AWSDecodableShape {
        ///  Returns the list of errors reason and the usage item keys that cannot be created in the Bill Scenario.
        public let errors: [BatchCreateBillScenarioUsageModificationError]?
        ///  Returns the list of successful usage line items that were created for the Bill Scenario.
        public let items: [BatchCreateBillScenarioUsageModificationItem]?

        @inlinable
        public init(errors: [BatchCreateBillScenarioUsageModificationError]? = nil, items: [BatchCreateBillScenarioUsageModificationItem]? = nil) {
            self.errors = errors
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case items = "items"
        }
    }

    public struct BatchCreateWorkloadEstimateUsageEntry: AWSEncodableShape {
        ///  The estimated usage amount.
        public let amount: Double
        ///  An optional group identifier for the usage estimate.
        public let group: String?
        ///  Historical usage data associated with this estimate, if available.
        public let historicalUsage: HistoricalUsageEntity?
        ///  A unique identifier for this entry in the batch operation.
        public let key: String
        ///  The specific operation associated with this usage estimate.
        public let operation: String
        ///  The Amazon Web Services service code for this usage estimate.
        public let serviceCode: String
        ///  The Amazon Web Services account ID associated with this usage estimate.
        public let usageAccountId: String
        ///  The type of usage being estimated.
        public let usageType: String

        @inlinable
        public init(amount: Double, group: String? = nil, historicalUsage: HistoricalUsageEntity? = nil, key: String, operation: String, serviceCode: String, usageAccountId: String, usageType: String) {
            self.amount = amount
            self.group = group
            self.historicalUsage = historicalUsage
            self.key = key
            self.operation = operation
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }

        public func validate(name: String) throws {
            try self.validate(self.group, name: "group", parent: name, max: 30)
            try self.validate(self.group, name: "group", parent: name, pattern: "^[a-zA-Z0-9-]*$")
            try self.historicalUsage?.validate(name: "\(name).historicalUsage")
            try self.validate(self.key, name: "key", parent: name, max: 10)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.operation, name: "operation", parent: name, max: 32)
            try self.validate(self.operation, name: "operation", parent: name, pattern: "^[-a-zA-Z0-9\\.\\-_:, \\/()]*$")
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, max: 32)
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, pattern: "^[-a-zA-Z0-9\\.\\-_:, \\/()]*$")
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, max: 12)
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, min: 12)
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.usageType, name: "usageType", parent: name, max: 128)
            try self.validate(self.usageType, name: "usageType", parent: name, pattern: "^[-a-zA-Z0-9\\.\\-_:, \\/()]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case group = "group"
            case historicalUsage = "historicalUsage"
            case key = "key"
            case operation = "operation"
            case serviceCode = "serviceCode"
            case usageAccountId = "usageAccountId"
            case usageType = "usageType"
        }
    }

    public struct BatchCreateWorkloadEstimateUsageError: AWSDecodableShape {
        ///  The error code associated with the failed operation.
        public let errorCode: BatchCreateWorkloadEstimateUsageCode?
        ///  A descriptive message for the error that occurred.
        public let errorMessage: String?
        ///  The key of the entry that caused the error.
        public let key: String?

        @inlinable
        public init(errorCode: BatchCreateWorkloadEstimateUsageCode? = nil, errorMessage: String? = nil, key: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case key = "key"
        }
    }

    public struct BatchCreateWorkloadEstimateUsageItem: AWSDecodableShape {
        ///  The estimated cost associated with this usage.
        public let cost: Double?
        ///  The currency of the estimated cost.
        public let currency: CurrencyCode?
        ///  The group identifier for the created usage estimate.
        public let group: String?
        ///  Historical usage data associated with this estimate, if available.
        public let historicalUsage: HistoricalUsageEntity?
        ///  The unique identifier assigned to the created usage estimate.
        public let id: String?
        ///  The key of the successfully created entry.
        public let key: String?
        ///  The location associated with this usage estimate.
        public let location: String?
        ///  The specific operation associated with this usage estimate.
        public let operation: String
        ///  The estimated usage quantity.
        public let quantity: WorkloadEstimateUsageQuantity?
        ///  The Amazon Web Services service code for this usage estimate.
        public let serviceCode: String
        ///  The current status of the created usage estimate.
        public let status: WorkloadEstimateCostStatus?
        ///  The Amazon Web Services account ID associated with the created usage estimate.
        public let usageAccountId: String?
        ///  The type of usage that was estimated.
        public let usageType: String

        @inlinable
        public init(cost: Double? = nil, currency: CurrencyCode? = nil, group: String? = nil, historicalUsage: HistoricalUsageEntity? = nil, id: String? = nil, key: String? = nil, location: String? = nil, operation: String, quantity: WorkloadEstimateUsageQuantity? = nil, serviceCode: String, status: WorkloadEstimateCostStatus? = nil, usageAccountId: String? = nil, usageType: String) {
            self.cost = cost
            self.currency = currency
            self.group = group
            self.historicalUsage = historicalUsage
            self.id = id
            self.key = key
            self.location = location
            self.operation = operation
            self.quantity = quantity
            self.serviceCode = serviceCode
            self.status = status
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case cost = "cost"
            case currency = "currency"
            case group = "group"
            case historicalUsage = "historicalUsage"
            case id = "id"
            case key = "key"
            case location = "location"
            case operation = "operation"
            case quantity = "quantity"
            case serviceCode = "serviceCode"
            case status = "status"
            case usageAccountId = "usageAccountId"
            case usageType = "usageType"
        }
    }

    public struct BatchCreateWorkloadEstimateUsageRequest: AWSEncodableShape {
        ///  A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        ///  List of usage that you want to model in the Workload estimate.
        public let usage: [BatchCreateWorkloadEstimateUsageEntry]
        ///  The ID of the Workload estimate for which you want to create the modeled usage.
        public let workloadEstimateId: String

        @inlinable
        public init(clientToken: String? = BatchCreateWorkloadEstimateUsageRequest.idempotencyToken(), usage: [BatchCreateWorkloadEstimateUsageEntry], workloadEstimateId: String) {
            self.clientToken = clientToken
            self.usage = usage
            self.workloadEstimateId = workloadEstimateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encode(self.usage, forKey: .usage)
            try container.encode(self.workloadEstimateId, forKey: .workloadEstimateId)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\u0021-\\u007E]+$")
            try self.usage.forEach {
                try $0.validate(name: "\(name).usage[]")
            }
            try self.validate(self.usage, name: "usage", parent: name, max: 25)
            try self.validate(self.usage, name: "usage", parent: name, min: 1)
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, max: 36)
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, min: 36)
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case usage = "usage"
            case workloadEstimateId = "workloadEstimateId"
        }
    }

    public struct BatchCreateWorkloadEstimateUsageResponse: AWSDecodableShape {
        ///  Returns the list of errors reason and the usage item keys that cannot be created in the Workload estimate.
        public let errors: [BatchCreateWorkloadEstimateUsageError]?
        ///  Returns the list of successful usage line items that were created for the Workload estimate.
        public let items: [BatchCreateWorkloadEstimateUsageItem]?

        @inlinable
        public init(errors: [BatchCreateWorkloadEstimateUsageError]? = nil, items: [BatchCreateWorkloadEstimateUsageItem]? = nil) {
            self.errors = errors
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case items = "items"
        }
    }

    public struct BatchDeleteBillScenarioCommitmentModificationError: AWSDecodableShape {
        ///  The code associated with the error.
        public let errorCode: BatchDeleteBillScenarioCommitmentModificationErrorCode?
        ///  The message that describes the error.
        public let errorMessage: String?
        ///  The ID of the error.
        public let id: String?

        @inlinable
        public init(errorCode: BatchDeleteBillScenarioCommitmentModificationErrorCode? = nil, errorMessage: String? = nil, id: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case id = "id"
        }
    }

    public struct BatchDeleteBillScenarioCommitmentModificationRequest: AWSEncodableShape {
        ///  The ID of the Bill Scenario for which you want to delete the modeled commitment.
        public let billScenarioId: String
        ///  List of commitments that you want to delete from the Bill Scenario.
        public let ids: [String]

        @inlinable
        public init(billScenarioId: String, ids: [String]) {
            self.billScenarioId = billScenarioId
            self.ids = ids
        }

        public func validate(name: String) throws {
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, max: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, min: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.ids.forEach {
                try validate($0, name: "ids[]", parent: name, max: 36)
                try validate($0, name: "ids[]", parent: name, min: 36)
                try validate($0, name: "ids[]", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            }
            try self.validate(self.ids, name: "ids", parent: name, max: 25)
            try self.validate(self.ids, name: "ids", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billScenarioId = "billScenarioId"
            case ids = "ids"
        }
    }

    public struct BatchDeleteBillScenarioCommitmentModificationResponse: AWSDecodableShape {
        ///  Returns the list of errors reason and the commitment item keys that cannot be deleted from the Bill Scenario.
        public let errors: [BatchDeleteBillScenarioCommitmentModificationError]?

        @inlinable
        public init(errors: [BatchDeleteBillScenarioCommitmentModificationError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchDeleteBillScenarioUsageModificationError: AWSDecodableShape {
        ///  The code associated with the error.
        public let errorCode: BatchDeleteBillScenarioUsageModificationErrorCode?
        ///  The message that describes the error.
        public let errorMessage: String?
        ///  The ID of the error.
        public let id: String?

        @inlinable
        public init(errorCode: BatchDeleteBillScenarioUsageModificationErrorCode? = nil, errorMessage: String? = nil, id: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case id = "id"
        }
    }

    public struct BatchDeleteBillScenarioUsageModificationRequest: AWSEncodableShape {
        ///  The ID of the Bill Scenario for which you want to delete the modeled usage.
        public let billScenarioId: String
        ///  List of usage that you want to delete from the Bill Scenario.
        public let ids: [String]

        @inlinable
        public init(billScenarioId: String, ids: [String]) {
            self.billScenarioId = billScenarioId
            self.ids = ids
        }

        public func validate(name: String) throws {
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, max: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, min: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.ids.forEach {
                try validate($0, name: "ids[]", parent: name, max: 36)
                try validate($0, name: "ids[]", parent: name, min: 36)
                try validate($0, name: "ids[]", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            }
            try self.validate(self.ids, name: "ids", parent: name, max: 25)
            try self.validate(self.ids, name: "ids", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billScenarioId = "billScenarioId"
            case ids = "ids"
        }
    }

    public struct BatchDeleteBillScenarioUsageModificationResponse: AWSDecodableShape {
        ///  Returns the list of errors reason and the usage item keys that cannot be deleted from the Bill Scenario.
        public let errors: [BatchDeleteBillScenarioUsageModificationError]?

        @inlinable
        public init(errors: [BatchDeleteBillScenarioUsageModificationError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchDeleteWorkloadEstimateUsageError: AWSDecodableShape {
        ///  The code associated with the error.
        public let errorCode: WorkloadEstimateUpdateUsageErrorCode?
        ///  The message that describes the error.
        public let errorMessage: String?
        ///  The ID of the error.
        public let id: String?

        @inlinable
        public init(errorCode: WorkloadEstimateUpdateUsageErrorCode? = nil, errorMessage: String? = nil, id: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case id = "id"
        }
    }

    public struct BatchDeleteWorkloadEstimateUsageRequest: AWSEncodableShape {
        ///  List of usage that you want to delete from the Workload estimate.
        public let ids: [String]
        ///  The ID of the Workload estimate for which you want to delete the modeled usage.
        public let workloadEstimateId: String

        @inlinable
        public init(ids: [String], workloadEstimateId: String) {
            self.ids = ids
            self.workloadEstimateId = workloadEstimateId
        }

        public func validate(name: String) throws {
            try self.ids.forEach {
                try validate($0, name: "ids[]", parent: name, max: 36)
                try validate($0, name: "ids[]", parent: name, min: 36)
                try validate($0, name: "ids[]", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            }
            try self.validate(self.ids, name: "ids", parent: name, max: 25)
            try self.validate(self.ids, name: "ids", parent: name, min: 1)
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, max: 36)
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, min: 36)
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case ids = "ids"
            case workloadEstimateId = "workloadEstimateId"
        }
    }

    public struct BatchDeleteWorkloadEstimateUsageResponse: AWSDecodableShape {
        ///  Returns the list of errors reason and the usage item keys that cannot be deleted from the Workload estimate.
        public let errors: [BatchDeleteWorkloadEstimateUsageError]?

        @inlinable
        public init(errors: [BatchDeleteWorkloadEstimateUsageError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchUpdateBillScenarioCommitmentModificationEntry: AWSEncodableShape {
        ///  The updated group identifier for the commitment modification.
        public let group: String?
        ///  The unique identifier of the commitment modification to update.
        public let id: String

        @inlinable
        public init(group: String? = nil, id: String) {
            self.group = group
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.group, name: "group", parent: name, max: 30)
            try self.validate(self.group, name: "group", parent: name, pattern: "^[a-zA-Z0-9-]*$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case id = "id"
        }
    }

    public struct BatchUpdateBillScenarioCommitmentModificationError: AWSDecodableShape {
        ///  The code associated with the error.
        public let errorCode: BatchUpdateBillScenarioCommitmentModificationErrorCode?
        ///  The message that describes the error.
        public let errorMessage: String?
        ///  The ID of the error.
        public let id: String?

        @inlinable
        public init(errorCode: BatchUpdateBillScenarioCommitmentModificationErrorCode? = nil, errorMessage: String? = nil, id: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case id = "id"
        }
    }

    public struct BatchUpdateBillScenarioCommitmentModificationRequest: AWSEncodableShape {
        ///  The ID of the Bill Scenario for which you want to modify the commitment group of a modeled commitment.
        public let billScenarioId: String
        ///  List of commitments that you want to update in a Bill Scenario.
        public let commitmentModifications: [BatchUpdateBillScenarioCommitmentModificationEntry]

        @inlinable
        public init(billScenarioId: String, commitmentModifications: [BatchUpdateBillScenarioCommitmentModificationEntry]) {
            self.billScenarioId = billScenarioId
            self.commitmentModifications = commitmentModifications
        }

        public func validate(name: String) throws {
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, max: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, min: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.commitmentModifications.forEach {
                try $0.validate(name: "\(name).commitmentModifications[]")
            }
            try self.validate(self.commitmentModifications, name: "commitmentModifications", parent: name, max: 25)
            try self.validate(self.commitmentModifications, name: "commitmentModifications", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billScenarioId = "billScenarioId"
            case commitmentModifications = "commitmentModifications"
        }
    }

    public struct BatchUpdateBillScenarioCommitmentModificationResponse: AWSDecodableShape {
        ///  Returns the list of error reasons and commitment line item IDs that could not be updated for the Bill Scenario.
        public let errors: [BatchUpdateBillScenarioCommitmentModificationError]?
        ///  Returns the list of successful commitment line items that were updated for a Bill Scenario.
        public let items: [BillScenarioCommitmentModificationItem]?

        @inlinable
        public init(errors: [BatchUpdateBillScenarioCommitmentModificationError]? = nil, items: [BillScenarioCommitmentModificationItem]? = nil) {
            self.errors = errors
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case items = "items"
        }
    }

    public struct BatchUpdateBillScenarioUsageModificationEntry: AWSEncodableShape {
        ///  The updated usage amounts for the modification.
        public let amounts: [UsageAmount]?
        ///  The updated group identifier for the usage modification.
        public let group: String?
        ///  The unique identifier of the usage modification to update.
        public let id: String

        @inlinable
        public init(amounts: [UsageAmount]? = nil, group: String? = nil, id: String) {
            self.amounts = amounts
            self.group = group
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.group, name: "group", parent: name, max: 30)
            try self.validate(self.group, name: "group", parent: name, pattern: "^[a-zA-Z0-9-]*$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case amounts = "amounts"
            case group = "group"
            case id = "id"
        }
    }

    public struct BatchUpdateBillScenarioUsageModificationError: AWSDecodableShape {
        ///  The code associated with the error.
        public let errorCode: BatchUpdateBillScenarioUsageModificationErrorCode?
        ///  The message that describes the error.
        public let errorMessage: String?
        ///  The ID of the error.
        public let id: String?

        @inlinable
        public init(errorCode: BatchUpdateBillScenarioUsageModificationErrorCode? = nil, errorMessage: String? = nil, id: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case id = "id"
        }
    }

    public struct BatchUpdateBillScenarioUsageModificationRequest: AWSEncodableShape {
        ///  The ID of the Bill Scenario for which you want to modify the usage lines.
        public let billScenarioId: String
        ///  List of usage lines that you want to update in a Bill Scenario identified by the usage ID.
        public let usageModifications: [BatchUpdateBillScenarioUsageModificationEntry]

        @inlinable
        public init(billScenarioId: String, usageModifications: [BatchUpdateBillScenarioUsageModificationEntry]) {
            self.billScenarioId = billScenarioId
            self.usageModifications = usageModifications
        }

        public func validate(name: String) throws {
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, max: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, min: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.usageModifications.forEach {
                try $0.validate(name: "\(name).usageModifications[]")
            }
            try self.validate(self.usageModifications, name: "usageModifications", parent: name, max: 25)
            try self.validate(self.usageModifications, name: "usageModifications", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case billScenarioId = "billScenarioId"
            case usageModifications = "usageModifications"
        }
    }

    public struct BatchUpdateBillScenarioUsageModificationResponse: AWSDecodableShape {
        ///  Returns the list of error reasons and usage line item IDs that could not be updated for the Bill Scenario.
        public let errors: [BatchUpdateBillScenarioUsageModificationError]?
        ///  Returns the list of successful usage line items that were updated for a Bill Scenario.
        public let items: [BillScenarioUsageModificationItem]?

        @inlinable
        public init(errors: [BatchUpdateBillScenarioUsageModificationError]? = nil, items: [BillScenarioUsageModificationItem]? = nil) {
            self.errors = errors
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case items = "items"
        }
    }

    public struct BatchUpdateWorkloadEstimateUsageEntry: AWSEncodableShape {
        ///  The updated estimated usage amount.
        public let amount: Double?
        ///  The updated group identifier for the usage estimate.
        public let group: String?
        ///  The unique identifier of the usage estimate to update.
        public let id: String

        @inlinable
        public init(amount: Double? = nil, group: String? = nil, id: String) {
            self.amount = amount
            self.group = group
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.group, name: "group", parent: name, max: 30)
            try self.validate(self.group, name: "group", parent: name, pattern: "^[a-zA-Z0-9-]*$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case group = "group"
            case id = "id"
        }
    }

    public struct BatchUpdateWorkloadEstimateUsageError: AWSDecodableShape {
        ///  The code associated with the error.
        public let errorCode: WorkloadEstimateUpdateUsageErrorCode?
        ///  The message that describes the error.
        public let errorMessage: String?
        ///  The ID of the error.
        public let id: String?

        @inlinable
        public init(errorCode: WorkloadEstimateUpdateUsageErrorCode? = nil, errorMessage: String? = nil, id: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case id = "id"
        }
    }

    public struct BatchUpdateWorkloadEstimateUsageRequest: AWSEncodableShape {
        ///  List of usage line amounts and usage group that you want to update in a Workload estimate identified by the usage ID.
        public let usage: [BatchUpdateWorkloadEstimateUsageEntry]
        ///  The ID of the Workload estimate for which you want to modify the usage lines.
        public let workloadEstimateId: String

        @inlinable
        public init(usage: [BatchUpdateWorkloadEstimateUsageEntry], workloadEstimateId: String) {
            self.usage = usage
            self.workloadEstimateId = workloadEstimateId
        }

        public func validate(name: String) throws {
            try self.usage.forEach {
                try $0.validate(name: "\(name).usage[]")
            }
            try self.validate(self.usage, name: "usage", parent: name, max: 25)
            try self.validate(self.usage, name: "usage", parent: name, min: 1)
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, max: 36)
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, min: 36)
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case usage = "usage"
            case workloadEstimateId = "workloadEstimateId"
        }
    }

    public struct BatchUpdateWorkloadEstimateUsageResponse: AWSDecodableShape {
        ///  Returns the list of error reasons and usage line item IDs that could not be updated for the Workload estimate.
        public let errors: [BatchUpdateWorkloadEstimateUsageError]?
        ///  Returns the list of successful usage line items that were updated for a Workload estimate.
        public let items: [WorkloadEstimateUsageItem]?

        @inlinable
        public init(errors: [BatchUpdateWorkloadEstimateUsageError]? = nil, items: [WorkloadEstimateUsageItem]? = nil) {
            self.errors = errors
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case items = "items"
        }
    }

    public struct BillEstimateCommitmentSummary: AWSDecodableShape {
        ///  The unique identifier of the commitment.
        public let id: String?
        ///  The monthly payment amount for this commitment, if applicable.
        public let monthlyPayment: CostAmount?
        ///  The identifier of the specific offering associated with this commitment.
        public let offeringId: String?
        ///  The payment option chosen for this commitment (e.g., All Upfront, Partial Upfront, No Upfront).
        public let paymentOption: String?
        ///  The type of purchase agreement (e.g., Reserved Instance, Savings Plan).
        public let purchaseAgreementType: PurchaseAgreementType?
        ///  The Amazon Web Services region associated with this commitment.
        public let region: String?
        ///  The length of the commitment term.
        public let termLength: String?
        ///  The upfront payment amount for this commitment, if applicable.
        public let upfrontPayment: CostAmount?
        ///  The Amazon Web Services account ID associated with this commitment.
        public let usageAccountId: String?

        @inlinable
        public init(id: String? = nil, monthlyPayment: CostAmount? = nil, offeringId: String? = nil, paymentOption: String? = nil, purchaseAgreementType: PurchaseAgreementType? = nil, region: String? = nil, termLength: String? = nil, upfrontPayment: CostAmount? = nil, usageAccountId: String? = nil) {
            self.id = id
            self.monthlyPayment = monthlyPayment
            self.offeringId = offeringId
            self.paymentOption = paymentOption
            self.purchaseAgreementType = purchaseAgreementType
            self.region = region
            self.termLength = termLength
            self.upfrontPayment = upfrontPayment
            self.usageAccountId = usageAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case monthlyPayment = "monthlyPayment"
            case offeringId = "offeringId"
            case paymentOption = "paymentOption"
            case purchaseAgreementType = "purchaseAgreementType"
            case region = "region"
            case termLength = "termLength"
            case upfrontPayment = "upfrontPayment"
            case usageAccountId = "usageAccountId"
        }
    }

    public struct BillEstimateCostSummary: AWSDecodableShape {
        ///  A breakdown of cost differences by Amazon Web Services service.
        public let serviceCostDifferences: [String: CostDifference]?
        ///  The total difference in cost between the estimated and historical costs.
        public let totalCostDifference: CostDifference?

        @inlinable
        public init(serviceCostDifferences: [String: CostDifference]? = nil, totalCostDifference: CostDifference? = nil) {
            self.serviceCostDifferences = serviceCostDifferences
            self.totalCostDifference = totalCostDifference
        }

        private enum CodingKeys: String, CodingKey {
            case serviceCostDifferences = "serviceCostDifferences"
            case totalCostDifference = "totalCostDifference"
        }
    }

    public struct BillEstimateInputCommitmentModificationSummary: AWSDecodableShape {
        ///  The specific commitment action taken in this modification.
        public let commitmentAction: BillScenarioCommitmentModificationAction?
        ///  The group identifier for the commitment modification.
        public let group: String?
        ///  The unique identifier of the commitment modification.
        public let id: String?
        ///  The Amazon Web Services account ID associated with this commitment modification.
        public let usageAccountId: String?

        @inlinable
        public init(commitmentAction: BillScenarioCommitmentModificationAction? = nil, group: String? = nil, id: String? = nil, usageAccountId: String? = nil) {
            self.commitmentAction = commitmentAction
            self.group = group
            self.id = id
            self.usageAccountId = usageAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case commitmentAction = "commitmentAction"
            case group = "group"
            case id = "id"
            case usageAccountId = "usageAccountId"
        }
    }

    public struct BillEstimateInputUsageModificationSummary: AWSDecodableShape {
        ///  The availability zone associated with this usage modification, if applicable.
        public let availabilityZone: String?
        ///  The group identifier for the usage modification.
        public let group: String?
        ///  Historical usage data associated with this modification, if available.
        public let historicalUsage: HistoricalUsageEntity?
        ///  The unique identifier of the usage modification.
        public let id: String?
        ///  The location associated with this usage modification.
        public let location: String?
        ///  The specific operation associated with this usage modification.
        public let operation: String
        ///  The modified usage quantities.
        public let quantities: [UsageQuantity]?
        ///  The Amazon Web Services service code for this usage modification.
        public let serviceCode: String
        ///  The Amazon Web Services account ID associated with this usage modification.
        public let usageAccountId: String?
        ///  The type of usage being modified.
        public let usageType: String

        @inlinable
        public init(availabilityZone: String? = nil, group: String? = nil, historicalUsage: HistoricalUsageEntity? = nil, id: String? = nil, location: String? = nil, operation: String, quantities: [UsageQuantity]? = nil, serviceCode: String, usageAccountId: String? = nil, usageType: String) {
            self.availabilityZone = availabilityZone
            self.group = group
            self.historicalUsage = historicalUsage
            self.id = id
            self.location = location
            self.operation = operation
            self.quantities = quantities
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case group = "group"
            case historicalUsage = "historicalUsage"
            case id = "id"
            case location = "location"
            case operation = "operation"
            case quantities = "quantities"
            case serviceCode = "serviceCode"
            case usageAccountId = "usageAccountId"
            case usageType = "usageType"
        }
    }

    public struct BillEstimateLineItemSummary: AWSDecodableShape {
        ///  The availability zone associated with this line item, if applicable.
        public let availabilityZone: String?
        ///  The estimated cost for this line item.
        public let estimatedCost: CostAmount?
        ///  The estimated usage quantity for this line item.
        public let estimatedUsageQuantity: UsageQuantityResult?
        ///  The historical cost for this line item.
        public let historicalCost: CostAmount?
        ///  The historical usage quantity for this line item.
        public let historicalUsageQuantity: UsageQuantityResult?
        ///  The unique identifier of this line item.
        public let id: String?
        ///  The line item identifier from the original bill.
        public let lineItemId: String?
        ///  The type of this line item (e.g., Usage, Tax, Credit).
        public let lineItemType: String?
        ///  The location associated with this line item.
        public let location: String?
        ///  The specific operation associated with this line item.
        public let operation: String
        ///  The Amazon Web Services account ID of the payer for this line item.
        public let payerAccountId: String?
        ///  The Amazon Resource Names (ARNs) of any Savings Plans applied to this line item.
        public let savingsPlanArns: [String]?
        ///  The Amazon Web Services service code associated with this line item.
        public let serviceCode: String
        ///  The Amazon Web Services account ID associated with the usage for this line item.
        public let usageAccountId: String?
        ///  The type of usage for this line item.
        public let usageType: String

        @inlinable
        public init(availabilityZone: String? = nil, estimatedCost: CostAmount? = nil, estimatedUsageQuantity: UsageQuantityResult? = nil, historicalCost: CostAmount? = nil, historicalUsageQuantity: UsageQuantityResult? = nil, id: String? = nil, lineItemId: String? = nil, lineItemType: String? = nil, location: String? = nil, operation: String, payerAccountId: String? = nil, savingsPlanArns: [String]? = nil, serviceCode: String, usageAccountId: String? = nil, usageType: String) {
            self.availabilityZone = availabilityZone
            self.estimatedCost = estimatedCost
            self.estimatedUsageQuantity = estimatedUsageQuantity
            self.historicalCost = historicalCost
            self.historicalUsageQuantity = historicalUsageQuantity
            self.id = id
            self.lineItemId = lineItemId
            self.lineItemType = lineItemType
            self.location = location
            self.operation = operation
            self.payerAccountId = payerAccountId
            self.savingsPlanArns = savingsPlanArns
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case estimatedCost = "estimatedCost"
            case estimatedUsageQuantity = "estimatedUsageQuantity"
            case historicalCost = "historicalCost"
            case historicalUsageQuantity = "historicalUsageQuantity"
            case id = "id"
            case lineItemId = "lineItemId"
            case lineItemType = "lineItemType"
            case location = "location"
            case operation = "operation"
            case payerAccountId = "payerAccountId"
            case savingsPlanArns = "savingsPlanArns"
            case serviceCode = "serviceCode"
            case usageAccountId = "usageAccountId"
            case usageType = "usageType"
        }
    }

    public struct BillEstimateSummary: AWSDecodableShape {
        ///  The time period covered by the bill estimate.
        public let billInterval: BillInterval?
        ///  The timestamp when the bill estimate was created.
        public let createdAt: Date?
        ///  The timestamp when the bill estimate will expire.
        public let expiresAt: Date?
        ///  The unique identifier of the bill estimate.
        public let id: String
        ///  The name of the bill estimate.
        public let name: String?
        ///  The current status of the bill estimate.
        public let status: BillEstimateStatus?

        @inlinable
        public init(billInterval: BillInterval? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, id: String, name: String? = nil, status: BillEstimateStatus? = nil) {
            self.billInterval = billInterval
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case billInterval = "billInterval"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct BillInterval: AWSEncodableShape & AWSDecodableShape {
        ///  The end date and time of the interval.
        public let end: Date?
        ///  The start date and time of the interval.
        public let start: Date?

        @inlinable
        public init(end: Date? = nil, start: Date? = nil) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "end"
            case start = "start"
        }
    }

    public struct BillScenarioCommitmentModificationItem: AWSDecodableShape {
        ///  The specific commitment action taken in this modification.
        public let commitmentAction: BillScenarioCommitmentModificationAction?
        ///  The group identifier for the commitment modification.
        public let group: String?
        ///  The unique identifier of the commitment modification.
        public let id: String?
        ///  The Amazon Web Services account ID associated with this commitment modification.
        public let usageAccountId: String?

        @inlinable
        public init(commitmentAction: BillScenarioCommitmentModificationAction? = nil, group: String? = nil, id: String? = nil, usageAccountId: String? = nil) {
            self.commitmentAction = commitmentAction
            self.group = group
            self.id = id
            self.usageAccountId = usageAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case commitmentAction = "commitmentAction"
            case group = "group"
            case id = "id"
            case usageAccountId = "usageAccountId"
        }
    }

    public struct BillScenarioSummary: AWSDecodableShape {
        ///  The time period covered by the bill scenario.
        public let billInterval: BillInterval?
        ///  The timestamp when the bill scenario was created.
        public let createdAt: Date?
        ///  The timestamp when the bill scenario will expire.
        public let expiresAt: Date?
        ///  An error message if the bill scenario creation or processing failed.
        public let failureMessage: String?
        ///  The unique identifier of the bill scenario.
        public let id: String
        ///  The name of the bill scenario.
        public let name: String?
        ///  The current status of the bill scenario.
        public let status: BillScenarioStatus?

        @inlinable
        public init(billInterval: BillInterval? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, failureMessage: String? = nil, id: String, name: String? = nil, status: BillScenarioStatus? = nil) {
            self.billInterval = billInterval
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case billInterval = "billInterval"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct BillScenarioUsageModificationItem: AWSDecodableShape {
        ///  The availability zone associated with this usage modification, if applicable.
        public let availabilityZone: String?
        ///  The group identifier for the usage modification.
        public let group: String?
        ///  Historical usage data associated with this modification, if available.
        public let historicalUsage: HistoricalUsageEntity?
        ///  The unique identifier of the usage modification.
        public let id: String?
        ///  The location associated with this usage modification.
        public let location: String?
        ///  The specific operation associated with this usage modification.
        public let operation: String
        ///  The modified usage quantities.
        public let quantities: [UsageQuantity]?
        ///  The Amazon Web Services service code for this usage modification.
        public let serviceCode: String
        ///  The Amazon Web Services account ID associated with this usage modification.
        public let usageAccountId: String?
        ///  The type of usage being modified.
        public let usageType: String

        @inlinable
        public init(availabilityZone: String? = nil, group: String? = nil, historicalUsage: HistoricalUsageEntity? = nil, id: String? = nil, location: String? = nil, operation: String, quantities: [UsageQuantity]? = nil, serviceCode: String, usageAccountId: String? = nil, usageType: String) {
            self.availabilityZone = availabilityZone
            self.group = group
            self.historicalUsage = historicalUsage
            self.id = id
            self.location = location
            self.operation = operation
            self.quantities = quantities
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case group = "group"
            case historicalUsage = "historicalUsage"
            case id = "id"
            case location = "location"
            case operation = "operation"
            case quantities = "quantities"
            case serviceCode = "serviceCode"
            case usageAccountId = "usageAccountId"
            case usageType = "usageType"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        ///  The identifier of the resource that was not found.
        public let resourceId: String
        ///  The type of the resource that was not found.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CostAmount: AWSDecodableShape {
        ///  The numeric value of the cost.
        public let amount: Double?
        ///  The currency code for the cost amount.
        public let currency: CurrencyCode?

        @inlinable
        public init(amount: Double? = nil, currency: CurrencyCode? = nil) {
            self.amount = amount
            self.currency = currency
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case currency = "currency"
        }
    }

    public struct CostDifference: AWSDecodableShape {
        ///  The estimated cost amount.
        public let estimatedCost: CostAmount?
        ///  The historical cost amount.
        public let historicalCost: CostAmount?

        @inlinable
        public init(estimatedCost: CostAmount? = nil, historicalCost: CostAmount? = nil) {
            self.estimatedCost = estimatedCost
            self.historicalCost = historicalCost
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedCost = "estimatedCost"
            case historicalCost = "historicalCost"
        }
    }

    public struct CreateBillEstimateRequest: AWSEncodableShape {
        ///  The ID of the Bill Scenario for which you want to create a Bill estimate.
        public let billScenarioId: String
        ///  A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        ///  The name of the Bill estimate that will be created. Names must be unique for an account.
        public let name: String
        ///  An optional list of tags to associate with the specified BillEstimate. You can use resource tags to control access to your  BillEstimate using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:    Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource.  The remaining are reserved for Amazon Web Services.    The maximum length of a key is 128 characters.   The maximum length of a value is 256 characters.   Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-.   Keys and values are case sensitive.   Keys and values are trimmed for any leading or trailing whitespaces.   Don't use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services.
        public let tags: [String: String]?

        @inlinable
        public init(billScenarioId: String, clientToken: String? = CreateBillEstimateRequest.idempotencyToken(), name: String, tags: [String: String]? = nil) {
            self.billScenarioId = billScenarioId
            self.clientToken = clientToken
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.billScenarioId, forKey: .billScenarioId)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, max: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, min: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\u0021-\\u007E]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[\\w\\s:+=@/-]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\w\\s:+=@/-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case billScenarioId = "billScenarioId"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateBillEstimateResponse: AWSDecodableShape {
        ///  The bill month start and end  timestamp that was used to create the Bill estimate. This is set to the last complete anniversary bill month start and end timestamp.
        public let billInterval: BillInterval?
        ///  Returns summary-level cost information once a Bill estimate is  successfully generated. This summary includes: 1) the total cost difference, showing the pre-tax cost change for the consolidated  billing family between the completed anniversary bill and the estimated bill, and 2) total cost differences per service, detailing  the pre-tax cost of each service, comparing the completed anniversary bill to the estimated bill on a per-service basis.
        public let costSummary: BillEstimateCostSummary?
        ///  The timestamp of when the Bill estimate create process  was started (not when it successfully completed or failed).
        public let createdAt: Date?
        ///  The timestamp of when the Bill estimate will  expire. A Bill estimate becomes inaccessible after expiration.
        public let expiresAt: Date?
        ///  This attribute provides the reason if a Bill estimate result generation fails.
        public let failureMessage: String?
        ///  The unique identifier of your newly created Bill estimate.
        public let id: String
        ///  The name of your newly created Bill estimate.
        public let name: String?
        ///  The status of your newly created Bill estimate. Bill estimate creation can take anywhere between 8 to 12 hours.  The status will allow you to identify when the Bill estimate is complete or has failed.
        public let status: BillEstimateStatus?

        @inlinable
        public init(billInterval: BillInterval? = nil, costSummary: BillEstimateCostSummary? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, failureMessage: String? = nil, id: String, name: String? = nil, status: BillEstimateStatus? = nil) {
            self.billInterval = billInterval
            self.costSummary = costSummary
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case billInterval = "billInterval"
            case costSummary = "costSummary"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateBillScenarioRequest: AWSEncodableShape {
        ///  A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        ///  A descriptive name for the bill scenario.
        public let name: String
        ///  The tags to apply to the bill scenario.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateBillScenarioRequest.idempotencyToken(), name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\u0021-\\u007E]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[\\w\\s:+=@/-]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\w\\s:+=@/-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateBillScenarioResponse: AWSDecodableShape {
        ///  The time period covered by the bill scenario.
        public let billInterval: BillInterval?
        ///  The timestamp when the bill scenario was created.
        public let createdAt: Date?
        ///  The timestamp when the bill scenario will expire.
        public let expiresAt: Date?
        ///  An error message if the bill scenario creation failed.
        public let failureMessage: String?
        ///  The unique identifier for the created bill scenario.
        public let id: String
        ///  The name of the created bill scenario.
        public let name: String?
        ///  The current status of the bill scenario.
        public let status: BillScenarioStatus?

        @inlinable
        public init(billInterval: BillInterval? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, failureMessage: String? = nil, id: String, name: String? = nil, status: BillScenarioStatus? = nil) {
            self.billInterval = billInterval
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case billInterval = "billInterval"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateWorkloadEstimateRequest: AWSEncodableShape {
        ///  A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        ///  A descriptive name for the workload estimate.
        public let name: String
        ///  The type of pricing rates to use for the estimate.
        public let rateType: WorkloadEstimateRateType?
        ///  The tags to apply to the workload estimate.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateWorkloadEstimateRequest.idempotencyToken(), name: String, rateType: WorkloadEstimateRateType? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.name = name
            self.rateType = rateType
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.rateType, forKey: .rateType)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\u0021-\\u007E]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[\\w\\s:+=@/-]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\w\\s:+=@/-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case rateType = "rateType"
            case tags = "tags"
        }
    }

    public struct CreateWorkloadEstimateResponse: AWSDecodableShape {
        ///  The currency of the estimated cost.
        public let costCurrency: CurrencyCode?
        ///  The timestamp when the workload estimate was created.
        public let createdAt: Date?
        ///  The timestamp when the workload estimate will expire.
        public let expiresAt: Date?
        ///  An error message if the workload estimate creation failed.
        public let failureMessage: String?
        ///  The unique identifier for the created workload estimate.
        public let id: String
        ///  The name of the created workload estimate.
        public let name: String?
        ///  The timestamp of the pricing rates used for the estimate.
        public let rateTimestamp: Date?
        ///  The type of pricing rates used for the estimate.
        public let rateType: WorkloadEstimateRateType?
        ///  The current status of the workload estimate.
        public let status: WorkloadEstimateStatus?
        ///  The total estimated cost for the workload.
        public let totalCost: Double?

        @inlinable
        public init(costCurrency: CurrencyCode? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, failureMessage: String? = nil, id: String, name: String? = nil, rateTimestamp: Date? = nil, rateType: WorkloadEstimateRateType? = nil, status: WorkloadEstimateStatus? = nil, totalCost: Double? = nil) {
            self.costCurrency = costCurrency
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.rateTimestamp = rateTimestamp
            self.rateType = rateType
            self.status = status
            self.totalCost = totalCost
        }

        private enum CodingKeys: String, CodingKey {
            case costCurrency = "costCurrency"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case rateTimestamp = "rateTimestamp"
            case rateType = "rateType"
            case status = "status"
            case totalCost = "totalCost"
        }
    }

    public struct DeleteBillEstimateRequest: AWSEncodableShape {
        ///  The unique identifier of the bill estimate to delete.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct DeleteBillEstimateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteBillScenarioRequest: AWSEncodableShape {
        ///  The unique identifier of the bill scenario to delete.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct DeleteBillScenarioResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWorkloadEstimateRequest: AWSEncodableShape {
        ///  The unique identifier of the workload estimate to delete.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct DeleteWorkloadEstimateResponse: AWSDecodableShape {
        public init() {}
    }

    public final class Expression: AWSEncodableShape & AWSDecodableShape {
        ///  A list of expressions to be combined with AND logic.
        public let and: [Expression]?
        ///  Filters based on cost categories.
        public let costCategories: ExpressionFilter?
        ///  Filters based on dimensions (e.g., service, operation).
        public let dimensions: ExpressionFilter?
        ///  An expression to be negated.
        public let not: Expression?
        ///  A list of expressions to be combined with OR logic.
        public let or: [Expression]?
        ///  Filters based on resource tags.
        public let tags: ExpressionFilter?

        @inlinable
        public init(and: [Expression]? = nil, costCategories: ExpressionFilter? = nil, dimensions: ExpressionFilter? = nil, not: Expression? = nil, or: [Expression]? = nil, tags: ExpressionFilter? = nil) {
            self.and = and
            self.costCategories = costCategories
            self.dimensions = dimensions
            self.not = not
            self.or = or
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case and = "and"
            case costCategories = "costCategories"
            case dimensions = "dimensions"
            case not = "not"
            case or = "or"
            case tags = "tags"
        }
    }

    public struct ExpressionFilter: AWSEncodableShape & AWSDecodableShape {
        ///  The key or attribute to filter on.
        public let key: String?
        ///  The match options for the filter (e.g., equals, contains).
        public let matchOptions: [String]?
        ///  The values to match against.
        public let values: [String]?

        @inlinable
        public init(key: String? = nil, matchOptions: [String]? = nil, values: [String]? = nil) {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case matchOptions = "matchOptions"
            case values = "values"
        }
    }

    public struct FilterTimestamp: AWSEncodableShape {
        ///  Include results after this timestamp.
        public let afterTimestamp: Date?
        ///  Include results before this timestamp.
        public let beforeTimestamp: Date?

        @inlinable
        public init(afterTimestamp: Date? = nil, beforeTimestamp: Date? = nil) {
            self.afterTimestamp = afterTimestamp
            self.beforeTimestamp = beforeTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case afterTimestamp = "afterTimestamp"
            case beforeTimestamp = "beforeTimestamp"
        }
    }

    public struct GetBillEstimateRequest: AWSEncodableShape {
        ///  The unique identifier of the bill estimate to retrieve.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct GetBillEstimateResponse: AWSDecodableShape {
        ///  The time period covered by the bill estimate.
        public let billInterval: BillInterval?
        ///  A summary of the estimated costs.
        public let costSummary: BillEstimateCostSummary?
        ///  The timestamp when the bill estimate was created.
        public let createdAt: Date?
        ///  The timestamp when the bill estimate will expire.
        public let expiresAt: Date?
        ///  An error message if the bill estimate retrieval failed.
        public let failureMessage: String?
        ///  The unique identifier of the retrieved bill estimate.
        public let id: String
        ///  The name of the retrieved bill estimate.
        public let name: String?
        ///  The current status of the bill estimate.
        public let status: BillEstimateStatus?

        @inlinable
        public init(billInterval: BillInterval? = nil, costSummary: BillEstimateCostSummary? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, failureMessage: String? = nil, id: String, name: String? = nil, status: BillEstimateStatus? = nil) {
            self.billInterval = billInterval
            self.costSummary = costSummary
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case billInterval = "billInterval"
            case costSummary = "costSummary"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetBillScenarioRequest: AWSEncodableShape {
        ///  The unique identifier of the bill scenario to retrieve.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct GetBillScenarioResponse: AWSDecodableShape {
        ///  The time period covered by the bill scenario.
        public let billInterval: BillInterval?
        ///  The timestamp when the bill scenario was created.
        public let createdAt: Date?
        ///  The timestamp when the bill scenario will expire.
        public let expiresAt: Date?
        ///  An error message if the bill scenario retrieval failed.
        public let failureMessage: String?
        ///  The unique identifier of the retrieved bill scenario.
        public let id: String
        ///  The name of the retrieved bill scenario.
        public let name: String?
        ///  The current status of the bill scenario.
        public let status: BillScenarioStatus?

        @inlinable
        public init(billInterval: BillInterval? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, failureMessage: String? = nil, id: String, name: String? = nil, status: BillScenarioStatus? = nil) {
            self.billInterval = billInterval
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case billInterval = "billInterval"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetPreferencesRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetPreferencesResponse: AWSDecodableShape {
        ///  The preferred rate types for the management account.
        public let managementAccountRateTypeSelections: [RateType]?
        ///  The preferred rate types for member accounts.
        public let memberAccountRateTypeSelections: [RateType]?
        ///  The preferred rate types for a standalone account.
        public let standaloneAccountRateTypeSelections: [RateType]?

        @inlinable
        public init(managementAccountRateTypeSelections: [RateType]? = nil, memberAccountRateTypeSelections: [RateType]? = nil, standaloneAccountRateTypeSelections: [RateType]? = nil) {
            self.managementAccountRateTypeSelections = managementAccountRateTypeSelections
            self.memberAccountRateTypeSelections = memberAccountRateTypeSelections
            self.standaloneAccountRateTypeSelections = standaloneAccountRateTypeSelections
        }

        private enum CodingKeys: String, CodingKey {
            case managementAccountRateTypeSelections = "managementAccountRateTypeSelections"
            case memberAccountRateTypeSelections = "memberAccountRateTypeSelections"
            case standaloneAccountRateTypeSelections = "standaloneAccountRateTypeSelections"
        }
    }

    public struct GetWorkloadEstimateRequest: AWSEncodableShape {
        ///  The unique identifier of the workload estimate to retrieve.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct GetWorkloadEstimateResponse: AWSDecodableShape {
        ///  The currency of the estimated cost.
        public let costCurrency: CurrencyCode?
        ///  The timestamp when the workload estimate was created.
        public let createdAt: Date?
        ///  The timestamp when the workload estimate will expire.
        public let expiresAt: Date?
        ///  An error message if the workload estimate retrieval failed.
        public let failureMessage: String?
        ///  The unique identifier of the retrieved workload estimate.
        public let id: String
        ///  The name of the retrieved workload estimate.
        public let name: String?
        ///  The timestamp of the pricing rates used for the estimate.
        public let rateTimestamp: Date?
        ///  The type of pricing rates used for the estimate.
        public let rateType: WorkloadEstimateRateType?
        ///  The current status of the workload estimate.
        public let status: WorkloadEstimateStatus?
        ///  The total estimated cost for the workload.
        public let totalCost: Double?

        @inlinable
        public init(costCurrency: CurrencyCode? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, failureMessage: String? = nil, id: String, name: String? = nil, rateTimestamp: Date? = nil, rateType: WorkloadEstimateRateType? = nil, status: WorkloadEstimateStatus? = nil, totalCost: Double? = nil) {
            self.costCurrency = costCurrency
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.rateTimestamp = rateTimestamp
            self.rateType = rateType
            self.status = status
            self.totalCost = totalCost
        }

        private enum CodingKeys: String, CodingKey {
            case costCurrency = "costCurrency"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case rateTimestamp = "rateTimestamp"
            case rateType = "rateType"
            case status = "status"
            case totalCost = "totalCost"
        }
    }

    public struct HistoricalUsageEntity: AWSEncodableShape & AWSDecodableShape {
        ///  The time interval for the historical usage data.
        public let billInterval: BillInterval
        ///  An optional filter expression to apply to the historical usage data.
        public let filterExpression: Expression
        ///  The location associated with the usage.
        public let location: String?
        ///  The specific operation associated with the usage.
        public let operation: String
        ///  The Amazon Web Services service code associated with the usage.
        public let serviceCode: String
        ///  The Amazon Web Services account ID associated with the usage.
        public let usageAccountId: String
        ///  The type of usage.
        public let usageType: String

        @inlinable
        public init(billInterval: BillInterval, filterExpression: Expression, location: String? = nil, operation: String, serviceCode: String, usageAccountId: String, usageType: String) {
            self.billInterval = billInterval
            self.filterExpression = filterExpression
            self.location = location
            self.operation = operation
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }

        public func validate(name: String) throws {
            try self.validate(self.operation, name: "operation", parent: name, max: 32)
            try self.validate(self.operation, name: "operation", parent: name, pattern: "^[-a-zA-Z0-9\\.\\-_:, \\/()]*$")
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, max: 32)
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, pattern: "^[-a-zA-Z0-9\\.\\-_:, \\/()]*$")
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, max: 12)
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, min: 12)
            try self.validate(self.usageAccountId, name: "usageAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.usageType, name: "usageType", parent: name, max: 128)
            try self.validate(self.usageType, name: "usageType", parent: name, pattern: "^[-a-zA-Z0-9\\.\\-_:, \\/()]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case billInterval = "billInterval"
            case filterExpression = "filterExpression"
            case location = "location"
            case operation = "operation"
            case serviceCode = "serviceCode"
            case usageAccountId = "usageAccountId"
            case usageType = "usageType"
        }
    }

    public struct ListBillEstimateCommitmentsRequest: AWSEncodableShape {
        ///  The unique identifier of the bill estimate to list commitments for.
        public let billEstimateId: String
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(billEstimateId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.billEstimateId = billEstimateId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, max: 36)
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, min: 36)
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case billEstimateId = "billEstimateId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillEstimateCommitmentsResponse: AWSDecodableShape {
        ///  The list of commitments associated with the bill estimate.
        public let items: [BillEstimateCommitmentSummary]?
        ///  A token to retrieve the next page of results, if any.
        public let nextToken: String?

        @inlinable
        public init(items: [BillEstimateCommitmentSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillEstimateInputCommitmentModificationsRequest: AWSEncodableShape {
        ///  The unique identifier of the bill estimate to list input commitment modifications for.
        public let billEstimateId: String
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(billEstimateId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.billEstimateId = billEstimateId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, max: 36)
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, min: 36)
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case billEstimateId = "billEstimateId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillEstimateInputCommitmentModificationsResponse: AWSDecodableShape {
        ///  The list of input commitment modifications associated with the bill estimate.
        public let items: [BillEstimateInputCommitmentModificationSummary]?
        ///  A token to retrieve the next page of results, if any.
        public let nextToken: String?

        @inlinable
        public init(items: [BillEstimateInputCommitmentModificationSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillEstimateInputUsageModificationsRequest: AWSEncodableShape {
        ///  The unique identifier of the bill estimate to list input usage modifications for.
        public let billEstimateId: String
        ///  Filters to apply to the list of input usage modifications.
        public let filters: [ListUsageFilter]?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(billEstimateId: String, filters: [ListUsageFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.billEstimateId = billEstimateId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, max: 36)
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, min: 36)
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case billEstimateId = "billEstimateId"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillEstimateInputUsageModificationsResponse: AWSDecodableShape {
        ///  The list of input usage modifications associated with the bill estimate.
        public let items: [BillEstimateInputUsageModificationSummary]?
        ///  A token to retrieve the next page of results, if any.
        public let nextToken: String?

        @inlinable
        public init(items: [BillEstimateInputUsageModificationSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillEstimateLineItemsFilter: AWSEncodableShape {
        ///  The match option for the filter (e.g., equals, contains).
        public let matchOption: MatchOption?
        ///  The name of the filter attribute.
        public let name: ListBillEstimateLineItemsFilterName
        ///  The values to filter by.
        public let values: [String]

        @inlinable
        public init(matchOption: MatchOption? = nil, name: ListBillEstimateLineItemsFilterName, values: [String]) {
            self.matchOption = matchOption
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case matchOption = "matchOption"
            case name = "name"
            case values = "values"
        }
    }

    public struct ListBillEstimateLineItemsRequest: AWSEncodableShape {
        ///  The unique identifier of the bill estimate to list line items for.
        public let billEstimateId: String
        ///  Filters to apply to the list of line items.
        public let filters: [ListBillEstimateLineItemsFilter]?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(billEstimateId: String, filters: [ListBillEstimateLineItemsFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.billEstimateId = billEstimateId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, max: 36)
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, min: 36)
            try self.validate(self.billEstimateId, name: "billEstimateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case billEstimateId = "billEstimateId"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillEstimateLineItemsResponse: AWSDecodableShape {
        ///  The list of line items associated with the bill estimate.
        public let items: [BillEstimateLineItemSummary]?
        ///  A token to retrieve the next page of results, if any.
        public let nextToken: String?

        @inlinable
        public init(items: [BillEstimateLineItemSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillEstimatesFilter: AWSEncodableShape {
        ///  The match option for the filter (e.g., equals, contains).
        public let matchOption: MatchOption?
        ///  The name of the filter attribute.
        public let name: ListBillEstimatesFilterName
        ///  The values to filter by.
        public let values: [String]

        @inlinable
        public init(matchOption: MatchOption? = nil, name: ListBillEstimatesFilterName, values: [String]) {
            self.matchOption = matchOption
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case matchOption = "matchOption"
            case name = "name"
            case values = "values"
        }
    }

    public struct ListBillEstimatesRequest: AWSEncodableShape {
        ///  Filter bill estimates based on the creation date.
        public let createdAtFilter: FilterTimestamp?
        ///  Filter bill estimates based on the expiration date.
        public let expiresAtFilter: FilterTimestamp?
        ///  Filters to apply to the list of bill estimates.
        public let filters: [ListBillEstimatesFilter]?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(createdAtFilter: FilterTimestamp? = nil, expiresAtFilter: FilterTimestamp? = nil, filters: [ListBillEstimatesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.createdAtFilter = createdAtFilter
            self.expiresAtFilter = expiresAtFilter
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAtFilter = "createdAtFilter"
            case expiresAtFilter = "expiresAtFilter"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillEstimatesResponse: AWSDecodableShape {
        ///  The list of bill estimates for the account.
        public let items: [BillEstimateSummary]?
        ///  A token to retrieve the next page of results, if any.
        public let nextToken: String?

        @inlinable
        public init(items: [BillEstimateSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillScenarioCommitmentModificationsRequest: AWSEncodableShape {
        ///  The unique identifier of the bill scenario to list commitment modifications for.
        public let billScenarioId: String
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(billScenarioId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.billScenarioId = billScenarioId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, max: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, min: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case billScenarioId = "billScenarioId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillScenarioCommitmentModificationsResponse: AWSDecodableShape {
        ///  The list of commitment modifications associated with the bill scenario.
        public let items: [BillScenarioCommitmentModificationItem]?
        ///  A token to retrieve the next page of results, if any.
        public let nextToken: String?

        @inlinable
        public init(items: [BillScenarioCommitmentModificationItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillScenarioUsageModificationsRequest: AWSEncodableShape {
        ///  The unique identifier of the bill scenario to list usage modifications for.
        public let billScenarioId: String
        ///  Filters to apply to the list of usage modifications.
        public let filters: [ListUsageFilter]?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(billScenarioId: String, filters: [ListUsageFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.billScenarioId = billScenarioId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, max: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, min: 36)
            try self.validate(self.billScenarioId, name: "billScenarioId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case billScenarioId = "billScenarioId"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillScenarioUsageModificationsResponse: AWSDecodableShape {
        ///  The list of usage modifications associated with the bill scenario.
        public let items: [BillScenarioUsageModificationItem]?
        ///  A token to retrieve the next page of results, if any.
        public let nextToken: String?

        @inlinable
        public init(items: [BillScenarioUsageModificationItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillScenariosFilter: AWSEncodableShape {
        ///  The match option for the filter (e.g., equals, contains).
        public let matchOption: MatchOption?
        ///  The name of the filter attribute.
        public let name: ListBillScenariosFilterName
        ///  The values to filter by.
        public let values: [String]

        @inlinable
        public init(matchOption: MatchOption? = nil, name: ListBillScenariosFilterName, values: [String]) {
            self.matchOption = matchOption
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case matchOption = "matchOption"
            case name = "name"
            case values = "values"
        }
    }

    public struct ListBillScenariosRequest: AWSEncodableShape {
        ///  Filter bill scenarios based on the creation date.
        public let createdAtFilter: FilterTimestamp?
        ///  Filter bill scenarios based on the expiration date.
        public let expiresAtFilter: FilterTimestamp?
        ///  Filters to apply to the list of bill scenarios.
        public let filters: [ListBillScenariosFilter]?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(createdAtFilter: FilterTimestamp? = nil, expiresAtFilter: FilterTimestamp? = nil, filters: [ListBillScenariosFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.createdAtFilter = createdAtFilter
            self.expiresAtFilter = expiresAtFilter
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAtFilter = "createdAtFilter"
            case expiresAtFilter = "expiresAtFilter"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBillScenariosResponse: AWSDecodableShape {
        ///  The list of bill scenarios for the account.
        public let items: [BillScenarioSummary]?
        ///  A token to retrieve the next page of results, if any.
        public let nextToken: String?

        @inlinable
        public init(items: [BillScenarioSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource to list tags for.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[-a-z0-9]*:bcm-pricing-calculator:[-a-z0-9]*:[0-9]{12}:[-a-z0-9/:_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  The list of tags associated with the specified resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListUsageFilter: AWSEncodableShape {
        ///  The match option for the filter (e.g., equals, contains).
        public let matchOption: MatchOption?
        ///  The name of the filter attribute.
        public let name: ListUsageFilterName
        ///  The values to filter by.
        public let values: [String]

        @inlinable
        public init(matchOption: MatchOption? = nil, name: ListUsageFilterName, values: [String]) {
            self.matchOption = matchOption
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case matchOption = "matchOption"
            case name = "name"
            case values = "values"
        }
    }

    public struct ListWorkloadEstimateUsageRequest: AWSEncodableShape {
        ///  Filters to apply to the list of usage items.
        public let filters: [ListUsageFilter]?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  A token to retrieve the next page of results.
        public let nextToken: String?
        ///  The unique identifier of the workload estimate to list usage for.
        public let workloadEstimateId: String

        @inlinable
        public init(filters: [ListUsageFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, workloadEstimateId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workloadEstimateId = workloadEstimateId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, max: 36)
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, min: 36)
            try self.validate(self.workloadEstimateId, name: "workloadEstimateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case workloadEstimateId = "workloadEstimateId"
        }
    }

    public struct ListWorkloadEstimateUsageResponse: AWSDecodableShape {
        ///  The list of usage items associated with the workload estimate.
        public let items: [WorkloadEstimateUsageItem]?
        ///  A token to retrieve the next page of results, if any.
        public let nextToken: String?

        @inlinable
        public init(items: [WorkloadEstimateUsageItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorkloadEstimatesFilter: AWSEncodableShape {
        ///  The match option for the filter (e.g., equals, contains).
        public let matchOption: MatchOption?
        ///  The name of the filter attribute.
        public let name: ListWorkloadEstimatesFilterName
        ///  The values to filter by.
        public let values: [String]

        @inlinable
        public init(matchOption: MatchOption? = nil, name: ListWorkloadEstimatesFilterName, values: [String]) {
            self.matchOption = matchOption
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case matchOption = "matchOption"
            case name = "name"
            case values = "values"
        }
    }

    public struct ListWorkloadEstimatesRequest: AWSEncodableShape {
        ///  Filter workload estimates based on the creation date.
        public let createdAtFilter: FilterTimestamp?
        ///  Filter workload estimates based on the expiration date.
        public let expiresAtFilter: FilterTimestamp?
        ///  Filters to apply to the list of workload estimates.
        public let filters: [ListWorkloadEstimatesFilter]?
        ///  The maximum number of results to return per page.
        public let maxResults: Int?
        ///  A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(createdAtFilter: FilterTimestamp? = nil, expiresAtFilter: FilterTimestamp? = nil, filters: [ListWorkloadEstimatesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.createdAtFilter = createdAtFilter
            self.expiresAtFilter = expiresAtFilter
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAtFilter = "createdAtFilter"
            case expiresAtFilter = "expiresAtFilter"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorkloadEstimatesResponse: AWSDecodableShape {
        ///  The list of workload estimates for the account.
        public let items: [WorkloadEstimateSummary]?
        ///  A token to retrieve the next page of results, if any.
        public let nextToken: String?

        @inlinable
        public init(items: [WorkloadEstimateSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct NegateReservedInstanceAction: AWSEncodableShape & AWSDecodableShape {
        ///  The ID of the Reserved Instance to remove.
        public let reservedInstancesId: String?

        @inlinable
        public init(reservedInstancesId: String? = nil) {
            self.reservedInstancesId = reservedInstancesId
        }

        public func validate(name: String) throws {
            try self.validate(self.reservedInstancesId, name: "reservedInstancesId", parent: name, max: 36)
            try self.validate(self.reservedInstancesId, name: "reservedInstancesId", parent: name, min: 36)
            try self.validate(self.reservedInstancesId, name: "reservedInstancesId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case reservedInstancesId = "reservedInstancesId"
        }
    }

    public struct NegateSavingsPlanAction: AWSEncodableShape & AWSDecodableShape {
        ///  The ID of the Savings Plan to remove.
        public let savingsPlanId: String?

        @inlinable
        public init(savingsPlanId: String? = nil) {
            self.savingsPlanId = savingsPlanId
        }

        public func validate(name: String) throws {
            try self.validate(self.savingsPlanId, name: "savingsPlanId", parent: name, max: 36)
            try self.validate(self.savingsPlanId, name: "savingsPlanId", parent: name, min: 36)
            try self.validate(self.savingsPlanId, name: "savingsPlanId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case savingsPlanId = "savingsPlanId"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        ///  The identifier of the resource that was not found.
        public let resourceId: String
        ///  The type of the resource that was not found.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        ///  The quota code that was exceeded.
        public let quotaCode: String?
        ///  The identifier of the resource that exceeded quota.
        public let resourceId: String
        ///  The type of the resource that exceeded quota.
        public let resourceType: String
        ///  The service code that exceeded quota.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, resourceId: String, resourceType: String, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource to add tags to.
        public let arn: String
        ///  The tags to add to the resource.
        public let tags: [String: String]

        @inlinable
        public init(arn: String, tags: [String: String]) {
            self.arn = arn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[-a-z0-9]*:bcm-pricing-calculator:[-a-z0-9]*:[0-9]{12}:[-a-z0-9/:_]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[\\w\\s:+=@/-]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\w\\s:+=@/-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource to remove tags from.
        public let arn: String
        ///  The keys of the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(arn: String, tagKeys: [String]) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[-a-z0-9]*:bcm-pricing-calculator:[-a-z0-9]*:[0-9]{12}:[-a-z0-9/:_]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[\\w\\s:+=@/-]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateBillEstimateRequest: AWSEncodableShape {
        ///  The new expiration date for the bill estimate.
        public let expiresAt: Date?
        ///  The unique identifier of the bill estimate to update.
        public let identifier: String
        ///  The new name for the bill estimate.
        public let name: String?

        @inlinable
        public init(expiresAt: Date? = nil, identifier: String, name: String? = nil) {
            self.expiresAt = expiresAt
            self.identifier = identifier
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case expiresAt = "expiresAt"
            case identifier = "identifier"
            case name = "name"
        }
    }

    public struct UpdateBillEstimateResponse: AWSDecodableShape {
        ///  The time period covered by the updated bill estimate.
        public let billInterval: BillInterval?
        ///  A summary of the updated estimated costs.
        public let costSummary: BillEstimateCostSummary?
        ///  The timestamp when the bill estimate was originally created.
        public let createdAt: Date?
        ///  The updated expiration timestamp for the bill estimate.
        public let expiresAt: Date?
        ///  An error message if the bill estimate update failed.
        public let failureMessage: String?
        ///  The unique identifier of the updated bill estimate.
        public let id: String
        ///  The updated name of the bill estimate.
        public let name: String?
        ///  The current status of the updated bill estimate.
        public let status: BillEstimateStatus?

        @inlinable
        public init(billInterval: BillInterval? = nil, costSummary: BillEstimateCostSummary? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, failureMessage: String? = nil, id: String, name: String? = nil, status: BillEstimateStatus? = nil) {
            self.billInterval = billInterval
            self.costSummary = costSummary
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case billInterval = "billInterval"
            case costSummary = "costSummary"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct UpdateBillScenarioRequest: AWSEncodableShape {
        ///  The new expiration date for the bill scenario.
        public let expiresAt: Date?
        ///  The unique identifier of the bill scenario to update.
        public let identifier: String
        ///  The new name for the bill scenario.
        public let name: String?

        @inlinable
        public init(expiresAt: Date? = nil, identifier: String, name: String? = nil) {
            self.expiresAt = expiresAt
            self.identifier = identifier
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case expiresAt = "expiresAt"
            case identifier = "identifier"
            case name = "name"
        }
    }

    public struct UpdateBillScenarioResponse: AWSDecodableShape {
        ///  The time period covered by the updated bill scenario.
        public let billInterval: BillInterval?
        ///  The timestamp when the bill scenario was originally created.
        public let createdAt: Date?
        ///  The updated expiration timestamp for the bill scenario.
        public let expiresAt: Date?
        ///  An error message if the bill scenario update failed.
        public let failureMessage: String?
        ///  The unique identifier of the updated bill scenario.
        public let id: String
        ///  The updated name of the bill scenario.
        public let name: String?
        ///  The current status of the updated bill scenario.
        public let status: BillScenarioStatus?

        @inlinable
        public init(billInterval: BillInterval? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, failureMessage: String? = nil, id: String, name: String? = nil, status: BillScenarioStatus? = nil) {
            self.billInterval = billInterval
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case billInterval = "billInterval"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct UpdatePreferencesRequest: AWSEncodableShape {
        ///  The updated preferred rate types for the management account.
        public let managementAccountRateTypeSelections: [RateType]?
        ///  The updated preferred rate types for member accounts.
        public let memberAccountRateTypeSelections: [RateType]?
        ///  The updated preferred rate types for a standalone account.
        public let standaloneAccountRateTypeSelections: [RateType]?

        @inlinable
        public init(managementAccountRateTypeSelections: [RateType]? = nil, memberAccountRateTypeSelections: [RateType]? = nil, standaloneAccountRateTypeSelections: [RateType]? = nil) {
            self.managementAccountRateTypeSelections = managementAccountRateTypeSelections
            self.memberAccountRateTypeSelections = memberAccountRateTypeSelections
            self.standaloneAccountRateTypeSelections = standaloneAccountRateTypeSelections
        }

        public func validate(name: String) throws {
            try self.validate(self.managementAccountRateTypeSelections, name: "managementAccountRateTypeSelections", parent: name, max: 2)
            try self.validate(self.managementAccountRateTypeSelections, name: "managementAccountRateTypeSelections", parent: name, min: 1)
            try self.validate(self.memberAccountRateTypeSelections, name: "memberAccountRateTypeSelections", parent: name, max: 2)
            try self.validate(self.memberAccountRateTypeSelections, name: "memberAccountRateTypeSelections", parent: name, min: 1)
            try self.validate(self.standaloneAccountRateTypeSelections, name: "standaloneAccountRateTypeSelections", parent: name, max: 2)
            try self.validate(self.standaloneAccountRateTypeSelections, name: "standaloneAccountRateTypeSelections", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case managementAccountRateTypeSelections = "managementAccountRateTypeSelections"
            case memberAccountRateTypeSelections = "memberAccountRateTypeSelections"
            case standaloneAccountRateTypeSelections = "standaloneAccountRateTypeSelections"
        }
    }

    public struct UpdatePreferencesResponse: AWSDecodableShape {
        ///  The updated preferred rate types for the management account.
        public let managementAccountRateTypeSelections: [RateType]?
        ///  The updated preferred rate types for member accounts.
        public let memberAccountRateTypeSelections: [RateType]?
        ///  The updated preferred rate types for a standalone account.
        public let standaloneAccountRateTypeSelections: [RateType]?

        @inlinable
        public init(managementAccountRateTypeSelections: [RateType]? = nil, memberAccountRateTypeSelections: [RateType]? = nil, standaloneAccountRateTypeSelections: [RateType]? = nil) {
            self.managementAccountRateTypeSelections = managementAccountRateTypeSelections
            self.memberAccountRateTypeSelections = memberAccountRateTypeSelections
            self.standaloneAccountRateTypeSelections = standaloneAccountRateTypeSelections
        }

        private enum CodingKeys: String, CodingKey {
            case managementAccountRateTypeSelections = "managementAccountRateTypeSelections"
            case memberAccountRateTypeSelections = "memberAccountRateTypeSelections"
            case standaloneAccountRateTypeSelections = "standaloneAccountRateTypeSelections"
        }
    }

    public struct UpdateWorkloadEstimateRequest: AWSEncodableShape {
        ///  The new expiration date for the workload estimate.
        public let expiresAt: Date?
        ///  The unique identifier of the workload estimate to update.
        public let identifier: String
        ///  The new name for the workload estimate.
        public let name: String?

        @inlinable
        public init(expiresAt: Date? = nil, identifier: String, name: String? = nil) {
            self.expiresAt = expiresAt
            self.identifier = identifier
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 36)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case expiresAt = "expiresAt"
            case identifier = "identifier"
            case name = "name"
        }
    }

    public struct UpdateWorkloadEstimateResponse: AWSDecodableShape {
        ///  The currency of the updated estimated cost.
        public let costCurrency: CurrencyCode?
        ///  The timestamp when the workload estimate was originally created.
        public let createdAt: Date?
        ///  The updated expiration timestamp for the workload estimate.
        public let expiresAt: Date?
        ///  An error message if the workload estimate update failed.
        public let failureMessage: String?
        ///  The unique identifier of the updated workload estimate.
        public let id: String
        ///  The updated name of the workload estimate.
        public let name: String?
        ///  The timestamp of the pricing rates used for the updated estimate.
        public let rateTimestamp: Date?
        ///  The type of pricing rates used for the updated estimate.
        public let rateType: WorkloadEstimateRateType?
        ///  The current status of the updated workload estimate.
        public let status: WorkloadEstimateStatus?
        ///  The updated total estimated cost for the workload.
        public let totalCost: Double?

        @inlinable
        public init(costCurrency: CurrencyCode? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, failureMessage: String? = nil, id: String, name: String? = nil, rateTimestamp: Date? = nil, rateType: WorkloadEstimateRateType? = nil, status: WorkloadEstimateStatus? = nil, totalCost: Double? = nil) {
            self.costCurrency = costCurrency
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.rateTimestamp = rateTimestamp
            self.rateType = rateType
            self.status = status
            self.totalCost = totalCost
        }

        private enum CodingKeys: String, CodingKey {
            case costCurrency = "costCurrency"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case rateTimestamp = "rateTimestamp"
            case rateType = "rateType"
            case status = "status"
            case totalCost = "totalCost"
        }
    }

    public struct UsageAmount: AWSEncodableShape {
        ///  The usage amount for the period.
        public let amount: Double
        ///  The start hour of the usage period.
        public let startHour: Date

        @inlinable
        public init(amount: Double, startHour: Date) {
            self.amount = amount
            self.startHour = startHour
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case startHour = "startHour"
        }
    }

    public struct UsageQuantity: AWSDecodableShape {
        ///  The numeric value of the usage quantity.
        public let amount: Double?
        ///  The start hour of the usage period.
        public let startHour: Date?
        ///  The unit of measurement for the usage quantity.
        public let unit: String?

        @inlinable
        public init(amount: Double? = nil, startHour: Date? = nil, unit: String? = nil) {
            self.amount = amount
            self.startHour = startHour
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case startHour = "startHour"
            case unit = "unit"
        }
    }

    public struct UsageQuantityResult: AWSDecodableShape {
        ///  The numeric value of the usage quantity result.
        public let amount: Double?
        ///  The unit of measurement for the usage quantity result.
        public let unit: String?

        @inlinable
        public init(amount: Double? = nil, unit: String? = nil) {
            self.amount = amount
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case unit = "unit"
        }
    }

    public struct WorkloadEstimateSummary: AWSDecodableShape {
        ///  The currency of the estimated cost.
        public let costCurrency: CurrencyCode?
        ///  The timestamp when the workload estimate was created.
        public let createdAt: Date?
        ///  The timestamp when the workload estimate will expire.
        public let expiresAt: Date?
        ///  An error message if the workload estimate creation or processing failed.
        public let failureMessage: String?
        ///  The unique identifier of the workload estimate.
        public let id: String
        ///  The name of the workload estimate.
        public let name: String?
        ///  The timestamp of the pricing rates used for the estimate.
        public let rateTimestamp: Date?
        ///  The type of pricing rates used for the estimate.
        public let rateType: WorkloadEstimateRateType?
        ///  The current status of the workload estimate.
        public let status: WorkloadEstimateStatus?
        ///  The total estimated cost for the workload.
        public let totalCost: Double?

        @inlinable
        public init(costCurrency: CurrencyCode? = nil, createdAt: Date? = nil, expiresAt: Date? = nil, failureMessage: String? = nil, id: String, name: String? = nil, rateTimestamp: Date? = nil, rateType: WorkloadEstimateRateType? = nil, status: WorkloadEstimateStatus? = nil, totalCost: Double? = nil) {
            self.costCurrency = costCurrency
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.rateTimestamp = rateTimestamp
            self.rateType = rateType
            self.status = status
            self.totalCost = totalCost
        }

        private enum CodingKeys: String, CodingKey {
            case costCurrency = "costCurrency"
            case createdAt = "createdAt"
            case expiresAt = "expiresAt"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case rateTimestamp = "rateTimestamp"
            case rateType = "rateType"
            case status = "status"
            case totalCost = "totalCost"
        }
    }

    public struct WorkloadEstimateUsageItem: AWSDecodableShape {
        ///  The estimated cost for this usage item.
        public let cost: Double?
        ///  The currency of the estimated cost.
        public let currency: CurrencyCode?
        ///  The group identifier for this usage item.
        public let group: String?
        ///  Historical usage data associated with this item, if available.
        public let historicalUsage: HistoricalUsageEntity?
        ///  The unique identifier of this usage item.
        public let id: String?
        ///  The location associated with this usage item.
        public let location: String?
        ///  The specific operation associated with this usage item.
        public let operation: String
        ///  The estimated usage quantity for this item.
        public let quantity: WorkloadEstimateUsageQuantity?
        ///  The Amazon Web Services service code associated with this usage item.
        public let serviceCode: String
        ///  The current status of this usage item.
        public let status: WorkloadEstimateCostStatus?
        ///  The Amazon Web Services account ID associated with this usage item.
        public let usageAccountId: String?
        ///  The type of usage for this item.
        public let usageType: String

        @inlinable
        public init(cost: Double? = nil, currency: CurrencyCode? = nil, group: String? = nil, historicalUsage: HistoricalUsageEntity? = nil, id: String? = nil, location: String? = nil, operation: String, quantity: WorkloadEstimateUsageQuantity? = nil, serviceCode: String, status: WorkloadEstimateCostStatus? = nil, usageAccountId: String? = nil, usageType: String) {
            self.cost = cost
            self.currency = currency
            self.group = group
            self.historicalUsage = historicalUsage
            self.id = id
            self.location = location
            self.operation = operation
            self.quantity = quantity
            self.serviceCode = serviceCode
            self.status = status
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case cost = "cost"
            case currency = "currency"
            case group = "group"
            case historicalUsage = "historicalUsage"
            case id = "id"
            case location = "location"
            case operation = "operation"
            case quantity = "quantity"
            case serviceCode = "serviceCode"
            case status = "status"
            case usageAccountId = "usageAccountId"
            case usageType = "usageType"
        }
    }

    public struct WorkloadEstimateUsageQuantity: AWSDecodableShape {
        ///  The numeric value of the usage quantity.
        public let amount: Double?
        ///  The unit of measurement for the usage quantity.
        public let unit: String?

        @inlinable
        public init(amount: Double? = nil, unit: String? = nil) {
            self.amount = amount
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case unit = "unit"
        }
    }
}

// MARK: - Errors

/// Error enum for BCMPricingCalculator
public struct BCMPricingCalculatorErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case dataUnavailableException = "DataUnavailableException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BCMPricingCalculator
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  The request could not be processed because of conflict in the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    ///  The requested data is currently unavailable.
    public static var dataUnavailableException: Self { .init(.dataUnavailableException) }
    ///  An internal error has occurred. Retry your request, but if the problem persists, contact Amazon Web Services support.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  The request would cause you to exceed your service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    ///  The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  The input provided fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension BCMPricingCalculatorErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": BCMPricingCalculator.ConflictException.self,
        "ResourceNotFoundException": BCMPricingCalculator.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": BCMPricingCalculator.ServiceQuotaExceededException.self
    ]
}

extension BCMPricingCalculatorErrorType: Equatable {
    public static func == (lhs: BCMPricingCalculatorErrorType, rhs: BCMPricingCalculatorErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BCMPricingCalculatorErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
