//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS BCMPricingCalculator service.
///
///  You can use the Pricing Calculator API to programmatically create estimates for your planned cloud use. You can model usage and commitments such as Savings Plans and  Reserved Instances, and generate estimated costs using your discounts and benefit sharing preferences.  The Pricing Calculator API provides the following endpoint:    https://bcm-pricing-calculator.us-east-1.api.aws
public struct BCMPricingCalculator: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the BCMPricingCalculator client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "AWSBCMPricingCalculator",
            serviceName: "BCMPricingCalculator",
            serviceIdentifier: "bcm-pricing-calculator",
            serviceProtocol: .json(version: "1.0"),
            apiVersion: "2024-06-19",
            endpoint: endpoint,
            errorType: BCMPricingCalculatorErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    ///  Create Compute Savings Plans, EC2 Instance Savings Plans, or EC2 Reserved Instances commitments that you want to model in a Bill Scenario.   The BatchCreateBillScenarioCommitmentModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:CreateBillScenarioCommitmentModification in your policies.
    @Sendable
    @inlinable
    public func batchCreateBillScenarioCommitmentModification(_ input: BatchCreateBillScenarioCommitmentModificationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchCreateBillScenarioCommitmentModificationResponse {
        try await self.client.execute(
            operation: "BatchCreateBillScenarioCommitmentModification", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Create Compute Savings Plans, EC2 Instance Savings Plans, or EC2 Reserved Instances commitments that you want to model in a Bill Scenario.   The BatchCreateBillScenarioCommitmentModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:CreateBillScenarioCommitmentModification in your policies.
    ///
    /// Parameters:
    ///   - billScenarioId:  The ID of the Bill Scenario for which you want to create the modeled commitment.
    ///   - clientToken:  A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    ///   - commitmentModifications:  List of commitments that you want to model in the Bill Scenario.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchCreateBillScenarioCommitmentModification(
        billScenarioId: String,
        clientToken: String? = BatchCreateBillScenarioCommitmentModificationRequest.idempotencyToken(),
        commitmentModifications: [BatchCreateBillScenarioCommitmentModificationEntry],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchCreateBillScenarioCommitmentModificationResponse {
        let input = BatchCreateBillScenarioCommitmentModificationRequest(
            billScenarioId: billScenarioId, 
            clientToken: clientToken, 
            commitmentModifications: commitmentModifications
        )
        return try await self.batchCreateBillScenarioCommitmentModification(input, logger: logger)
    }

    ///  Create Amazon Web Services service usage that you want to model in a Bill Scenario.   The BatchCreateBillScenarioUsageModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:CreateBillScenarioUsageModification in your policies.
    @Sendable
    @inlinable
    public func batchCreateBillScenarioUsageModification(_ input: BatchCreateBillScenarioUsageModificationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchCreateBillScenarioUsageModificationResponse {
        try await self.client.execute(
            operation: "BatchCreateBillScenarioUsageModification", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Create Amazon Web Services service usage that you want to model in a Bill Scenario.   The BatchCreateBillScenarioUsageModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:CreateBillScenarioUsageModification in your policies.
    ///
    /// Parameters:
    ///   - billScenarioId:  The ID of the Bill Scenario for which you want to create the modeled usage.
    ///   - clientToken:  A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    ///   - usageModifications:  List of usage that you want to model in the Bill Scenario.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchCreateBillScenarioUsageModification(
        billScenarioId: String,
        clientToken: String? = BatchCreateBillScenarioUsageModificationRequest.idempotencyToken(),
        usageModifications: [BatchCreateBillScenarioUsageModificationEntry],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchCreateBillScenarioUsageModificationResponse {
        let input = BatchCreateBillScenarioUsageModificationRequest(
            billScenarioId: billScenarioId, 
            clientToken: clientToken, 
            usageModifications: usageModifications
        )
        return try await self.batchCreateBillScenarioUsageModification(input, logger: logger)
    }

    ///  Create Amazon Web Services service usage that you want to model in a Workload Estimate.   The BatchCreateWorkloadEstimateUsage operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:CreateWorkloadEstimateUsage in your policies.
    @Sendable
    @inlinable
    public func batchCreateWorkloadEstimateUsage(_ input: BatchCreateWorkloadEstimateUsageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchCreateWorkloadEstimateUsageResponse {
        try await self.client.execute(
            operation: "BatchCreateWorkloadEstimateUsage", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Create Amazon Web Services service usage that you want to model in a Workload Estimate.   The BatchCreateWorkloadEstimateUsage operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:CreateWorkloadEstimateUsage in your policies.
    ///
    /// Parameters:
    ///   - clientToken:  A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    ///   - usage:  List of usage that you want to model in the Workload estimate.
    ///   - workloadEstimateId:  The ID of the Workload estimate for which you want to create the modeled usage.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchCreateWorkloadEstimateUsage(
        clientToken: String? = BatchCreateWorkloadEstimateUsageRequest.idempotencyToken(),
        usage: [BatchCreateWorkloadEstimateUsageEntry],
        workloadEstimateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchCreateWorkloadEstimateUsageResponse {
        let input = BatchCreateWorkloadEstimateUsageRequest(
            clientToken: clientToken, 
            usage: usage, 
            workloadEstimateId: workloadEstimateId
        )
        return try await self.batchCreateWorkloadEstimateUsage(input, logger: logger)
    }

    ///  Delete commitment that you have created in a Bill Scenario. You can only delete a commitment that you had  added and cannot model deletion (or removal) of a existing commitment. If you want model deletion of an existing  commitment, see the negate  BillScenarioCommitmentModificationAction of   BatchCreateBillScenarioCommitmentModification operation.   The BatchDeleteBillScenarioCommitmentModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:DeleteBillScenarioCommitmentModification in your policies.
    @Sendable
    @inlinable
    public func batchDeleteBillScenarioCommitmentModification(_ input: BatchDeleteBillScenarioCommitmentModificationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteBillScenarioCommitmentModificationResponse {
        try await self.client.execute(
            operation: "BatchDeleteBillScenarioCommitmentModification", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Delete commitment that you have created in a Bill Scenario. You can only delete a commitment that you had  added and cannot model deletion (or removal) of a existing commitment. If you want model deletion of an existing  commitment, see the negate  BillScenarioCommitmentModificationAction of   BatchCreateBillScenarioCommitmentModification operation.   The BatchDeleteBillScenarioCommitmentModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:DeleteBillScenarioCommitmentModification in your policies.
    ///
    /// Parameters:
    ///   - billScenarioId:  The ID of the Bill Scenario for which you want to delete the modeled commitment.
    ///   - ids:  List of commitments that you want to delete from the Bill Scenario.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteBillScenarioCommitmentModification(
        billScenarioId: String,
        ids: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteBillScenarioCommitmentModificationResponse {
        let input = BatchDeleteBillScenarioCommitmentModificationRequest(
            billScenarioId: billScenarioId, 
            ids: ids
        )
        return try await self.batchDeleteBillScenarioCommitmentModification(input, logger: logger)
    }

    ///  Delete usage that you have created in a Bill Scenario. You can only delete usage that you had added and cannot model  deletion (or removal) of a existing usage. If you want model removal of an existing usage, see   BatchUpdateBillScenarioUsageModification.   The BatchDeleteBillScenarioUsageModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:DeleteBillScenarioUsageModification in your policies.
    @Sendable
    @inlinable
    public func batchDeleteBillScenarioUsageModification(_ input: BatchDeleteBillScenarioUsageModificationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteBillScenarioUsageModificationResponse {
        try await self.client.execute(
            operation: "BatchDeleteBillScenarioUsageModification", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Delete usage that you have created in a Bill Scenario. You can only delete usage that you had added and cannot model  deletion (or removal) of a existing usage. If you want model removal of an existing usage, see   BatchUpdateBillScenarioUsageModification.   The BatchDeleteBillScenarioUsageModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:DeleteBillScenarioUsageModification in your policies.
    ///
    /// Parameters:
    ///   - billScenarioId:  The ID of the Bill Scenario for which you want to delete the modeled usage.
    ///   - ids:  List of usage that you want to delete from the Bill Scenario.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteBillScenarioUsageModification(
        billScenarioId: String,
        ids: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteBillScenarioUsageModificationResponse {
        let input = BatchDeleteBillScenarioUsageModificationRequest(
            billScenarioId: billScenarioId, 
            ids: ids
        )
        return try await self.batchDeleteBillScenarioUsageModification(input, logger: logger)
    }

    ///  Delete usage that you have created in a Workload estimate. You can only delete usage that you had added and cannot model deletion  (or removal) of a existing usage. If you want model removal of an existing usage, see   BatchUpdateWorkloadEstimateUsage.   The BatchDeleteWorkloadEstimateUsage operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:DeleteWorkloadEstimateUsage in your policies.
    @Sendable
    @inlinable
    public func batchDeleteWorkloadEstimateUsage(_ input: BatchDeleteWorkloadEstimateUsageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteWorkloadEstimateUsageResponse {
        try await self.client.execute(
            operation: "BatchDeleteWorkloadEstimateUsage", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Delete usage that you have created in a Workload estimate. You can only delete usage that you had added and cannot model deletion  (or removal) of a existing usage. If you want model removal of an existing usage, see   BatchUpdateWorkloadEstimateUsage.   The BatchDeleteWorkloadEstimateUsage operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:DeleteWorkloadEstimateUsage in your policies.
    ///
    /// Parameters:
    ///   - ids:  List of usage that you want to delete from the Workload estimate.
    ///   - workloadEstimateId:  The ID of the Workload estimate for which you want to delete the modeled usage.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteWorkloadEstimateUsage(
        ids: [String],
        workloadEstimateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteWorkloadEstimateUsageResponse {
        let input = BatchDeleteWorkloadEstimateUsageRequest(
            ids: ids, 
            workloadEstimateId: workloadEstimateId
        )
        return try await self.batchDeleteWorkloadEstimateUsage(input, logger: logger)
    }

    ///  Update a newly added or existing commitment. You can update the commitment group based on a commitment ID and a Bill scenario ID.   The BatchUpdateBillScenarioCommitmentModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:UpdateBillScenarioCommitmentModification in your policies.
    @Sendable
    @inlinable
    public func batchUpdateBillScenarioCommitmentModification(_ input: BatchUpdateBillScenarioCommitmentModificationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdateBillScenarioCommitmentModificationResponse {
        try await self.client.execute(
            operation: "BatchUpdateBillScenarioCommitmentModification", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Update a newly added or existing commitment. You can update the commitment group based on a commitment ID and a Bill scenario ID.   The BatchUpdateBillScenarioCommitmentModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:UpdateBillScenarioCommitmentModification in your policies.
    ///
    /// Parameters:
    ///   - billScenarioId:  The ID of the Bill Scenario for which you want to modify the commitment group of a modeled commitment.
    ///   - commitmentModifications:  List of commitments that you want to update in a Bill Scenario.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchUpdateBillScenarioCommitmentModification(
        billScenarioId: String,
        commitmentModifications: [BatchUpdateBillScenarioCommitmentModificationEntry],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchUpdateBillScenarioCommitmentModificationResponse {
        let input = BatchUpdateBillScenarioCommitmentModificationRequest(
            billScenarioId: billScenarioId, 
            commitmentModifications: commitmentModifications
        )
        return try await self.batchUpdateBillScenarioCommitmentModification(input, logger: logger)
    }

    ///  Update a newly added or existing usage lines. You can update the usage amounts, usage hour, and usage group based on a usage ID and a Bill scenario ID.   The BatchUpdateBillScenarioUsageModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:UpdateBillScenarioUsageModification in your policies.
    @Sendable
    @inlinable
    public func batchUpdateBillScenarioUsageModification(_ input: BatchUpdateBillScenarioUsageModificationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdateBillScenarioUsageModificationResponse {
        try await self.client.execute(
            operation: "BatchUpdateBillScenarioUsageModification", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Update a newly added or existing usage lines. You can update the usage amounts, usage hour, and usage group based on a usage ID and a Bill scenario ID.   The BatchUpdateBillScenarioUsageModification operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:UpdateBillScenarioUsageModification in your policies.
    ///
    /// Parameters:
    ///   - billScenarioId:  The ID of the Bill Scenario for which you want to modify the usage lines.
    ///   - usageModifications:  List of usage lines that you want to update in a Bill Scenario identified by the usage ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchUpdateBillScenarioUsageModification(
        billScenarioId: String,
        usageModifications: [BatchUpdateBillScenarioUsageModificationEntry],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchUpdateBillScenarioUsageModificationResponse {
        let input = BatchUpdateBillScenarioUsageModificationRequest(
            billScenarioId: billScenarioId, 
            usageModifications: usageModifications
        )
        return try await self.batchUpdateBillScenarioUsageModification(input, logger: logger)
    }

    ///  Update a newly added or existing usage lines. You can update the usage amounts and usage group based on a usage ID and a Workload estimate ID.   The BatchUpdateWorkloadEstimateUsage operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:UpdateWorkloadEstimateUsage in your policies.
    @Sendable
    @inlinable
    public func batchUpdateWorkloadEstimateUsage(_ input: BatchUpdateWorkloadEstimateUsageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdateWorkloadEstimateUsageResponse {
        try await self.client.execute(
            operation: "BatchUpdateWorkloadEstimateUsage", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Update a newly added or existing usage lines. You can update the usage amounts and usage group based on a usage ID and a Workload estimate ID.   The BatchUpdateWorkloadEstimateUsage operation doesn't have its own IAM permission. To authorize this operation for Amazon Web Services principals,  include the permission bcm-pricing-calculator:UpdateWorkloadEstimateUsage in your policies.
    ///
    /// Parameters:
    ///   - usage:  List of usage line amounts and usage group that you want to update in a Workload estimate identified by the usage ID.
    ///   - workloadEstimateId:  The ID of the Workload estimate for which you want to modify the usage lines.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchUpdateWorkloadEstimateUsage(
        usage: [BatchUpdateWorkloadEstimateUsageEntry],
        workloadEstimateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchUpdateWorkloadEstimateUsageResponse {
        let input = BatchUpdateWorkloadEstimateUsageRequest(
            usage: usage, 
            workloadEstimateId: workloadEstimateId
        )
        return try await self.batchUpdateWorkloadEstimateUsage(input, logger: logger)
    }

    ///  Create a Bill estimate from a Bill scenario. In the Bill scenario you can model usage addition, usage changes, and usage removal. You can also model commitment addition and commitment removal. After all changes in a Bill scenario is made satisfactorily, you can call this API with a Bill scenario ID to generate the Bill estimate. Bill estimate calculates the pre-tax cost for your consolidated billing family, incorporating all modeled usage and commitments alongside existing usage and commitments from your most recent completed anniversary bill, with any applicable discounts applied.
    @Sendable
    @inlinable
    public func createBillEstimate(_ input: CreateBillEstimateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBillEstimateResponse {
        try await self.client.execute(
            operation: "CreateBillEstimate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Create a Bill estimate from a Bill scenario. In the Bill scenario you can model usage addition, usage changes, and usage removal. You can also model commitment addition and commitment removal. After all changes in a Bill scenario is made satisfactorily, you can call this API with a Bill scenario ID to generate the Bill estimate. Bill estimate calculates the pre-tax cost for your consolidated billing family, incorporating all modeled usage and commitments alongside existing usage and commitments from your most recent completed anniversary bill, with any applicable discounts applied.
    ///
    /// Parameters:
    ///   - billScenarioId:  The ID of the Bill Scenario for which you want to create a Bill estimate.
    ///   - clientToken:  A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    ///   - name:  The name of the Bill estimate that will be created. Names must be unique for an account.
    ///   - tags:  An optional list of tags to associate with the specified BillEstimate. You can use resource tags to control access to your  BillEstimate using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:    Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource.  The remaining are reserved for Amazon Web Services.    The maximum length of a key is 128 characters.   The maximum length of a value is 256 characters.   Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-.   Keys and values are case sensitive.   Keys and values are trimmed for any leading or trailing whitespaces.   Don't use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBillEstimate(
        billScenarioId: String,
        clientToken: String? = CreateBillEstimateRequest.idempotencyToken(),
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBillEstimateResponse {
        let input = CreateBillEstimateRequest(
            billScenarioId: billScenarioId, 
            clientToken: clientToken, 
            name: name, 
            tags: tags
        )
        return try await self.createBillEstimate(input, logger: logger)
    }

    ///  Creates a new bill scenario to model potential changes to Amazon Web Services usage and costs.
    @Sendable
    @inlinable
    public func createBillScenario(_ input: CreateBillScenarioRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBillScenarioResponse {
        try await self.client.execute(
            operation: "CreateBillScenario", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a new bill scenario to model potential changes to Amazon Web Services usage and costs.
    ///
    /// Parameters:
    ///   - clientToken:  A unique, case-sensitive identifier to ensure idempotency of the request.
    ///   - name:  A descriptive name for the bill scenario.
    ///   - tags:  The tags to apply to the bill scenario.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBillScenario(
        clientToken: String? = CreateBillScenarioRequest.idempotencyToken(),
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBillScenarioResponse {
        let input = CreateBillScenarioRequest(
            clientToken: clientToken, 
            name: name, 
            tags: tags
        )
        return try await self.createBillScenario(input, logger: logger)
    }

    ///  Creates a new workload estimate to model costs for a specific workload.
    @Sendable
    @inlinable
    public func createWorkloadEstimate(_ input: CreateWorkloadEstimateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkloadEstimateResponse {
        try await self.client.execute(
            operation: "CreateWorkloadEstimate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a new workload estimate to model costs for a specific workload.
    ///
    /// Parameters:
    ///   - clientToken:  A unique, case-sensitive identifier to ensure idempotency of the request.
    ///   - name:  A descriptive name for the workload estimate.
    ///   - rateType:  The type of pricing rates to use for the estimate.
    ///   - tags:  The tags to apply to the workload estimate.
    ///   - logger: Logger use during operation
    @inlinable
    public func createWorkloadEstimate(
        clientToken: String? = CreateWorkloadEstimateRequest.idempotencyToken(),
        name: String,
        rateType: WorkloadEstimateRateType? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateWorkloadEstimateResponse {
        let input = CreateWorkloadEstimateRequest(
            clientToken: clientToken, 
            name: name, 
            rateType: rateType, 
            tags: tags
        )
        return try await self.createWorkloadEstimate(input, logger: logger)
    }

    ///  Deletes an existing bill estimate.
    @Sendable
    @inlinable
    public func deleteBillEstimate(_ input: DeleteBillEstimateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBillEstimateResponse {
        try await self.client.execute(
            operation: "DeleteBillEstimate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes an existing bill estimate.
    ///
    /// Parameters:
    ///   - identifier:  The unique identifier of the bill estimate to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteBillEstimate(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteBillEstimateResponse {
        let input = DeleteBillEstimateRequest(
            identifier: identifier
        )
        return try await self.deleteBillEstimate(input, logger: logger)
    }

    ///  Deletes an existing bill scenario.
    @Sendable
    @inlinable
    public func deleteBillScenario(_ input: DeleteBillScenarioRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBillScenarioResponse {
        try await self.client.execute(
            operation: "DeleteBillScenario", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes an existing bill scenario.
    ///
    /// Parameters:
    ///   - identifier:  The unique identifier of the bill scenario to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteBillScenario(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteBillScenarioResponse {
        let input = DeleteBillScenarioRequest(
            identifier: identifier
        )
        return try await self.deleteBillScenario(input, logger: logger)
    }

    ///  Deletes an existing workload estimate.
    @Sendable
    @inlinable
    public func deleteWorkloadEstimate(_ input: DeleteWorkloadEstimateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteWorkloadEstimateResponse {
        try await self.client.execute(
            operation: "DeleteWorkloadEstimate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes an existing workload estimate.
    ///
    /// Parameters:
    ///   - identifier:  The unique identifier of the workload estimate to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteWorkloadEstimate(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteWorkloadEstimateResponse {
        let input = DeleteWorkloadEstimateRequest(
            identifier: identifier
        )
        return try await self.deleteWorkloadEstimate(input, logger: logger)
    }

    ///  Retrieves details of a specific bill estimate.
    @Sendable
    @inlinable
    public func getBillEstimate(_ input: GetBillEstimateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBillEstimateResponse {
        try await self.client.execute(
            operation: "GetBillEstimate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves details of a specific bill estimate.
    ///
    /// Parameters:
    ///   - identifier:  The unique identifier of the bill estimate to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBillEstimate(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBillEstimateResponse {
        let input = GetBillEstimateRequest(
            identifier: identifier
        )
        return try await self.getBillEstimate(input, logger: logger)
    }

    ///  Retrieves details of a specific bill scenario.
    @Sendable
    @inlinable
    public func getBillScenario(_ input: GetBillScenarioRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBillScenarioResponse {
        try await self.client.execute(
            operation: "GetBillScenario", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves details of a specific bill scenario.
    ///
    /// Parameters:
    ///   - identifier:  The unique identifier of the bill scenario to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBillScenario(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBillScenarioResponse {
        let input = GetBillScenarioRequest(
            identifier: identifier
        )
        return try await self.getBillScenario(input, logger: logger)
    }

    ///  Retrieves the current preferences for Pricing Calculator.
    @Sendable
    @inlinable
    public func getPreferences(_ input: GetPreferencesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPreferencesResponse {
        try await self.client.execute(
            operation: "GetPreferences", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves the current preferences for Pricing Calculator.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getPreferences(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPreferencesResponse {
        let input = GetPreferencesRequest(
        )
        return try await self.getPreferences(input, logger: logger)
    }

    ///  Retrieves details of a specific workload estimate.
    @Sendable
    @inlinable
    public func getWorkloadEstimate(_ input: GetWorkloadEstimateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkloadEstimateResponse {
        try await self.client.execute(
            operation: "GetWorkloadEstimate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves details of a specific workload estimate.
    ///
    /// Parameters:
    ///   - identifier:  The unique identifier of the workload estimate to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkloadEstimate(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkloadEstimateResponse {
        let input = GetWorkloadEstimateRequest(
            identifier: identifier
        )
        return try await self.getWorkloadEstimate(input, logger: logger)
    }

    ///  Lists the commitments associated with a bill estimate.
    @Sendable
    @inlinable
    public func listBillEstimateCommitments(_ input: ListBillEstimateCommitmentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBillEstimateCommitmentsResponse {
        try await self.client.execute(
            operation: "ListBillEstimateCommitments", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists the commitments associated with a bill estimate.
    ///
    /// Parameters:
    ///   - billEstimateId:  The unique identifier of the bill estimate to list commitments for.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - nextToken:  A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBillEstimateCommitments(
        billEstimateId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBillEstimateCommitmentsResponse {
        let input = ListBillEstimateCommitmentsRequest(
            billEstimateId: billEstimateId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listBillEstimateCommitments(input, logger: logger)
    }

    ///  Lists the input commitment modifications associated with a bill estimate.
    @Sendable
    @inlinable
    public func listBillEstimateInputCommitmentModifications(_ input: ListBillEstimateInputCommitmentModificationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBillEstimateInputCommitmentModificationsResponse {
        try await self.client.execute(
            operation: "ListBillEstimateInputCommitmentModifications", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists the input commitment modifications associated with a bill estimate.
    ///
    /// Parameters:
    ///   - billEstimateId:  The unique identifier of the bill estimate to list input commitment modifications for.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - nextToken:  A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBillEstimateInputCommitmentModifications(
        billEstimateId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBillEstimateInputCommitmentModificationsResponse {
        let input = ListBillEstimateInputCommitmentModificationsRequest(
            billEstimateId: billEstimateId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listBillEstimateInputCommitmentModifications(input, logger: logger)
    }

    ///  Lists the input usage modifications associated with a bill estimate.
    @Sendable
    @inlinable
    public func listBillEstimateInputUsageModifications(_ input: ListBillEstimateInputUsageModificationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBillEstimateInputUsageModificationsResponse {
        try await self.client.execute(
            operation: "ListBillEstimateInputUsageModifications", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists the input usage modifications associated with a bill estimate.
    ///
    /// Parameters:
    ///   - billEstimateId:  The unique identifier of the bill estimate to list input usage modifications for.
    ///   - filters:  Filters to apply to the list of input usage modifications.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - nextToken:  A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBillEstimateInputUsageModifications(
        billEstimateId: String,
        filters: [ListUsageFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBillEstimateInputUsageModificationsResponse {
        let input = ListBillEstimateInputUsageModificationsRequest(
            billEstimateId: billEstimateId, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listBillEstimateInputUsageModifications(input, logger: logger)
    }

    ///  Lists the line items associated with a bill estimate.
    @Sendable
    @inlinable
    public func listBillEstimateLineItems(_ input: ListBillEstimateLineItemsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBillEstimateLineItemsResponse {
        try await self.client.execute(
            operation: "ListBillEstimateLineItems", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists the line items associated with a bill estimate.
    ///
    /// Parameters:
    ///   - billEstimateId:  The unique identifier of the bill estimate to list line items for.
    ///   - filters:  Filters to apply to the list of line items.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - nextToken:  A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBillEstimateLineItems(
        billEstimateId: String,
        filters: [ListBillEstimateLineItemsFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBillEstimateLineItemsResponse {
        let input = ListBillEstimateLineItemsRequest(
            billEstimateId: billEstimateId, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listBillEstimateLineItems(input, logger: logger)
    }

    ///  Lists all bill estimates for the account.
    @Sendable
    @inlinable
    public func listBillEstimates(_ input: ListBillEstimatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBillEstimatesResponse {
        try await self.client.execute(
            operation: "ListBillEstimates", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists all bill estimates for the account.
    ///
    /// Parameters:
    ///   - createdAtFilter:  Filter bill estimates based on the creation date.
    ///   - expiresAtFilter:  Filter bill estimates based on the expiration date.
    ///   - filters:  Filters to apply to the list of bill estimates.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - nextToken:  A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBillEstimates(
        createdAtFilter: FilterTimestamp? = nil,
        expiresAtFilter: FilterTimestamp? = nil,
        filters: [ListBillEstimatesFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBillEstimatesResponse {
        let input = ListBillEstimatesRequest(
            createdAtFilter: createdAtFilter, 
            expiresAtFilter: expiresAtFilter, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listBillEstimates(input, logger: logger)
    }

    ///  Lists the commitment modifications associated with a bill scenario.
    @Sendable
    @inlinable
    public func listBillScenarioCommitmentModifications(_ input: ListBillScenarioCommitmentModificationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBillScenarioCommitmentModificationsResponse {
        try await self.client.execute(
            operation: "ListBillScenarioCommitmentModifications", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists the commitment modifications associated with a bill scenario.
    ///
    /// Parameters:
    ///   - billScenarioId:  The unique identifier of the bill scenario to list commitment modifications for.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - nextToken:  A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBillScenarioCommitmentModifications(
        billScenarioId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBillScenarioCommitmentModificationsResponse {
        let input = ListBillScenarioCommitmentModificationsRequest(
            billScenarioId: billScenarioId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listBillScenarioCommitmentModifications(input, logger: logger)
    }

    ///  Lists the usage modifications associated with a bill scenario.
    @Sendable
    @inlinable
    public func listBillScenarioUsageModifications(_ input: ListBillScenarioUsageModificationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBillScenarioUsageModificationsResponse {
        try await self.client.execute(
            operation: "ListBillScenarioUsageModifications", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists the usage modifications associated with a bill scenario.
    ///
    /// Parameters:
    ///   - billScenarioId:  The unique identifier of the bill scenario to list usage modifications for.
    ///   - filters:  Filters to apply to the list of usage modifications.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - nextToken:  A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBillScenarioUsageModifications(
        billScenarioId: String,
        filters: [ListUsageFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBillScenarioUsageModificationsResponse {
        let input = ListBillScenarioUsageModificationsRequest(
            billScenarioId: billScenarioId, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listBillScenarioUsageModifications(input, logger: logger)
    }

    ///  Lists all bill scenarios for the account.
    @Sendable
    @inlinable
    public func listBillScenarios(_ input: ListBillScenariosRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBillScenariosResponse {
        try await self.client.execute(
            operation: "ListBillScenarios", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists all bill scenarios for the account.
    ///
    /// Parameters:
    ///   - createdAtFilter:  Filter bill scenarios based on the creation date.
    ///   - expiresAtFilter:  Filter bill scenarios based on the expiration date.
    ///   - filters:  Filters to apply to the list of bill scenarios.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - nextToken:  A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBillScenarios(
        createdAtFilter: FilterTimestamp? = nil,
        expiresAtFilter: FilterTimestamp? = nil,
        filters: [ListBillScenariosFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBillScenariosResponse {
        let input = ListBillScenariosRequest(
            createdAtFilter: createdAtFilter, 
            expiresAtFilter: expiresAtFilter, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listBillScenarios(input, logger: logger)
    }

    ///  Lists all tags associated with a specified resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists all tags associated with a specified resource.
    ///
    /// Parameters:
    ///   - arn:  The Amazon Resource Name (ARN) of the resource to list tags for.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            arn: arn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    ///  Lists the usage associated with a workload estimate.
    @Sendable
    @inlinable
    public func listWorkloadEstimateUsage(_ input: ListWorkloadEstimateUsageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkloadEstimateUsageResponse {
        try await self.client.execute(
            operation: "ListWorkloadEstimateUsage", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists the usage associated with a workload estimate.
    ///
    /// Parameters:
    ///   - filters:  Filters to apply to the list of usage items.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - nextToken:  A token to retrieve the next page of results.
    ///   - workloadEstimateId:  The unique identifier of the workload estimate to list usage for.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkloadEstimateUsage(
        filters: [ListUsageFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workloadEstimateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkloadEstimateUsageResponse {
        let input = ListWorkloadEstimateUsageRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            workloadEstimateId: workloadEstimateId
        )
        return try await self.listWorkloadEstimateUsage(input, logger: logger)
    }

    ///  Lists all workload estimates for the account.
    @Sendable
    @inlinable
    public func listWorkloadEstimates(_ input: ListWorkloadEstimatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkloadEstimatesResponse {
        try await self.client.execute(
            operation: "ListWorkloadEstimates", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists all workload estimates for the account.
    ///
    /// Parameters:
    ///   - createdAtFilter:  Filter workload estimates based on the creation date.
    ///   - expiresAtFilter:  Filter workload estimates based on the expiration date.
    ///   - filters:  Filters to apply to the list of workload estimates.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - nextToken:  A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkloadEstimates(
        createdAtFilter: FilterTimestamp? = nil,
        expiresAtFilter: FilterTimestamp? = nil,
        filters: [ListWorkloadEstimatesFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkloadEstimatesResponse {
        let input = ListWorkloadEstimatesRequest(
            createdAtFilter: createdAtFilter, 
            expiresAtFilter: expiresAtFilter, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listWorkloadEstimates(input, logger: logger)
    }

    ///  Adds one or more tags to a specified resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Adds one or more tags to a specified resource.
    ///
    /// Parameters:
    ///   - arn:  The Amazon Resource Name (ARN) of the resource to add tags to.
    ///   - tags:  The tags to add to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        arn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            arn: arn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    ///  Removes one or more tags from a specified resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Removes one or more tags from a specified resource.
    ///
    /// Parameters:
    ///   - arn:  The Amazon Resource Name (ARN) of the resource to remove tags from.
    ///   - tagKeys:  The keys of the tags to remove from the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        arn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            arn: arn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    ///  Updates an existing bill estimate.
    @Sendable
    @inlinable
    public func updateBillEstimate(_ input: UpdateBillEstimateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBillEstimateResponse {
        try await self.client.execute(
            operation: "UpdateBillEstimate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates an existing bill estimate.
    ///
    /// Parameters:
    ///   - expiresAt:  The new expiration date for the bill estimate.
    ///   - identifier:  The unique identifier of the bill estimate to update.
    ///   - name:  The new name for the bill estimate.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBillEstimate(
        expiresAt: Date? = nil,
        identifier: String,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBillEstimateResponse {
        let input = UpdateBillEstimateRequest(
            expiresAt: expiresAt, 
            identifier: identifier, 
            name: name
        )
        return try await self.updateBillEstimate(input, logger: logger)
    }

    ///  Updates an existing bill scenario.
    @Sendable
    @inlinable
    public func updateBillScenario(_ input: UpdateBillScenarioRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBillScenarioResponse {
        try await self.client.execute(
            operation: "UpdateBillScenario", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates an existing bill scenario.
    ///
    /// Parameters:
    ///   - expiresAt:  The new expiration date for the bill scenario.
    ///   - identifier:  The unique identifier of the bill scenario to update.
    ///   - name:  The new name for the bill scenario.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBillScenario(
        expiresAt: Date? = nil,
        identifier: String,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBillScenarioResponse {
        let input = UpdateBillScenarioRequest(
            expiresAt: expiresAt, 
            identifier: identifier, 
            name: name
        )
        return try await self.updateBillScenario(input, logger: logger)
    }

    ///  Updates the preferences for Pricing Calculator.
    @Sendable
    @inlinable
    public func updatePreferences(_ input: UpdatePreferencesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePreferencesResponse {
        try await self.client.execute(
            operation: "UpdatePreferences", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates the preferences for Pricing Calculator.
    ///
    /// Parameters:
    ///   - managementAccountRateTypeSelections:  The updated preferred rate types for the management account.
    ///   - memberAccountRateTypeSelections:  The updated preferred rate types for member accounts.
    ///   - standaloneAccountRateTypeSelections:  The updated preferred rate types for a standalone account.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePreferences(
        managementAccountRateTypeSelections: [RateType]? = nil,
        memberAccountRateTypeSelections: [RateType]? = nil,
        standaloneAccountRateTypeSelections: [RateType]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePreferencesResponse {
        let input = UpdatePreferencesRequest(
            managementAccountRateTypeSelections: managementAccountRateTypeSelections, 
            memberAccountRateTypeSelections: memberAccountRateTypeSelections, 
            standaloneAccountRateTypeSelections: standaloneAccountRateTypeSelections
        )
        return try await self.updatePreferences(input, logger: logger)
    }

    ///  Updates an existing workload estimate.
    @Sendable
    @inlinable
    public func updateWorkloadEstimate(_ input: UpdateWorkloadEstimateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateWorkloadEstimateResponse {
        try await self.client.execute(
            operation: "UpdateWorkloadEstimate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates an existing workload estimate.
    ///
    /// Parameters:
    ///   - expiresAt:  The new expiration date for the workload estimate.
    ///   - identifier:  The unique identifier of the workload estimate to update.
    ///   - name:  The new name for the workload estimate.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateWorkloadEstimate(
        expiresAt: Date? = nil,
        identifier: String,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateWorkloadEstimateResponse {
        let input = UpdateWorkloadEstimateRequest(
            expiresAt: expiresAt, 
            identifier: identifier, 
            name: name
        )
        return try await self.updateWorkloadEstimate(input, logger: logger)
    }
}

extension BCMPricingCalculator {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: BCMPricingCalculator, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension BCMPricingCalculator {
    /// Return PaginatorSequence for operation ``listBillEstimateCommitments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillEstimateCommitmentsPaginator(
        _ input: ListBillEstimateCommitmentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBillEstimateCommitmentsRequest, ListBillEstimateCommitmentsResponse> {
        return .init(
            input: input,
            command: self.listBillEstimateCommitments,
            inputKey: \ListBillEstimateCommitmentsRequest.nextToken,
            outputKey: \ListBillEstimateCommitmentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBillEstimateCommitments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - billEstimateId:  The unique identifier of the bill estimate to list commitments for.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillEstimateCommitmentsPaginator(
        billEstimateId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBillEstimateCommitmentsRequest, ListBillEstimateCommitmentsResponse> {
        let input = ListBillEstimateCommitmentsRequest(
            billEstimateId: billEstimateId, 
            maxResults: maxResults
        )
        return self.listBillEstimateCommitmentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBillEstimateInputCommitmentModifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillEstimateInputCommitmentModificationsPaginator(
        _ input: ListBillEstimateInputCommitmentModificationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBillEstimateInputCommitmentModificationsRequest, ListBillEstimateInputCommitmentModificationsResponse> {
        return .init(
            input: input,
            command: self.listBillEstimateInputCommitmentModifications,
            inputKey: \ListBillEstimateInputCommitmentModificationsRequest.nextToken,
            outputKey: \ListBillEstimateInputCommitmentModificationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBillEstimateInputCommitmentModifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - billEstimateId:  The unique identifier of the bill estimate to list input commitment modifications for.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillEstimateInputCommitmentModificationsPaginator(
        billEstimateId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBillEstimateInputCommitmentModificationsRequest, ListBillEstimateInputCommitmentModificationsResponse> {
        let input = ListBillEstimateInputCommitmentModificationsRequest(
            billEstimateId: billEstimateId, 
            maxResults: maxResults
        )
        return self.listBillEstimateInputCommitmentModificationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBillEstimateInputUsageModifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillEstimateInputUsageModificationsPaginator(
        _ input: ListBillEstimateInputUsageModificationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBillEstimateInputUsageModificationsRequest, ListBillEstimateInputUsageModificationsResponse> {
        return .init(
            input: input,
            command: self.listBillEstimateInputUsageModifications,
            inputKey: \ListBillEstimateInputUsageModificationsRequest.nextToken,
            outputKey: \ListBillEstimateInputUsageModificationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBillEstimateInputUsageModifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - billEstimateId:  The unique identifier of the bill estimate to list input usage modifications for.
    ///   - filters:  Filters to apply to the list of input usage modifications.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillEstimateInputUsageModificationsPaginator(
        billEstimateId: String,
        filters: [ListUsageFilter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBillEstimateInputUsageModificationsRequest, ListBillEstimateInputUsageModificationsResponse> {
        let input = ListBillEstimateInputUsageModificationsRequest(
            billEstimateId: billEstimateId, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.listBillEstimateInputUsageModificationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBillEstimateLineItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillEstimateLineItemsPaginator(
        _ input: ListBillEstimateLineItemsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBillEstimateLineItemsRequest, ListBillEstimateLineItemsResponse> {
        return .init(
            input: input,
            command: self.listBillEstimateLineItems,
            inputKey: \ListBillEstimateLineItemsRequest.nextToken,
            outputKey: \ListBillEstimateLineItemsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBillEstimateLineItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - billEstimateId:  The unique identifier of the bill estimate to list line items for.
    ///   - filters:  Filters to apply to the list of line items.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillEstimateLineItemsPaginator(
        billEstimateId: String,
        filters: [ListBillEstimateLineItemsFilter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBillEstimateLineItemsRequest, ListBillEstimateLineItemsResponse> {
        let input = ListBillEstimateLineItemsRequest(
            billEstimateId: billEstimateId, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.listBillEstimateLineItemsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBillEstimates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillEstimatesPaginator(
        _ input: ListBillEstimatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBillEstimatesRequest, ListBillEstimatesResponse> {
        return .init(
            input: input,
            command: self.listBillEstimates,
            inputKey: \ListBillEstimatesRequest.nextToken,
            outputKey: \ListBillEstimatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBillEstimates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - createdAtFilter:  Filter bill estimates based on the creation date.
    ///   - expiresAtFilter:  Filter bill estimates based on the expiration date.
    ///   - filters:  Filters to apply to the list of bill estimates.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillEstimatesPaginator(
        createdAtFilter: FilterTimestamp? = nil,
        expiresAtFilter: FilterTimestamp? = nil,
        filters: [ListBillEstimatesFilter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBillEstimatesRequest, ListBillEstimatesResponse> {
        let input = ListBillEstimatesRequest(
            createdAtFilter: createdAtFilter, 
            expiresAtFilter: expiresAtFilter, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.listBillEstimatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBillScenarioCommitmentModifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillScenarioCommitmentModificationsPaginator(
        _ input: ListBillScenarioCommitmentModificationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBillScenarioCommitmentModificationsRequest, ListBillScenarioCommitmentModificationsResponse> {
        return .init(
            input: input,
            command: self.listBillScenarioCommitmentModifications,
            inputKey: \ListBillScenarioCommitmentModificationsRequest.nextToken,
            outputKey: \ListBillScenarioCommitmentModificationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBillScenarioCommitmentModifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - billScenarioId:  The unique identifier of the bill scenario to list commitment modifications for.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillScenarioCommitmentModificationsPaginator(
        billScenarioId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBillScenarioCommitmentModificationsRequest, ListBillScenarioCommitmentModificationsResponse> {
        let input = ListBillScenarioCommitmentModificationsRequest(
            billScenarioId: billScenarioId, 
            maxResults: maxResults
        )
        return self.listBillScenarioCommitmentModificationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBillScenarioUsageModifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillScenarioUsageModificationsPaginator(
        _ input: ListBillScenarioUsageModificationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBillScenarioUsageModificationsRequest, ListBillScenarioUsageModificationsResponse> {
        return .init(
            input: input,
            command: self.listBillScenarioUsageModifications,
            inputKey: \ListBillScenarioUsageModificationsRequest.nextToken,
            outputKey: \ListBillScenarioUsageModificationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBillScenarioUsageModifications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - billScenarioId:  The unique identifier of the bill scenario to list usage modifications for.
    ///   - filters:  Filters to apply to the list of usage modifications.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillScenarioUsageModificationsPaginator(
        billScenarioId: String,
        filters: [ListUsageFilter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBillScenarioUsageModificationsRequest, ListBillScenarioUsageModificationsResponse> {
        let input = ListBillScenarioUsageModificationsRequest(
            billScenarioId: billScenarioId, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.listBillScenarioUsageModificationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBillScenarios(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillScenariosPaginator(
        _ input: ListBillScenariosRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBillScenariosRequest, ListBillScenariosResponse> {
        return .init(
            input: input,
            command: self.listBillScenarios,
            inputKey: \ListBillScenariosRequest.nextToken,
            outputKey: \ListBillScenariosResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBillScenarios(_:logger:)``.
    ///
    /// - Parameters:
    ///   - createdAtFilter:  Filter bill scenarios based on the creation date.
    ///   - expiresAtFilter:  Filter bill scenarios based on the expiration date.
    ///   - filters:  Filters to apply to the list of bill scenarios.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillScenariosPaginator(
        createdAtFilter: FilterTimestamp? = nil,
        expiresAtFilter: FilterTimestamp? = nil,
        filters: [ListBillScenariosFilter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBillScenariosRequest, ListBillScenariosResponse> {
        let input = ListBillScenariosRequest(
            createdAtFilter: createdAtFilter, 
            expiresAtFilter: expiresAtFilter, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.listBillScenariosPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkloadEstimateUsage(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadEstimateUsagePaginator(
        _ input: ListWorkloadEstimateUsageRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkloadEstimateUsageRequest, ListWorkloadEstimateUsageResponse> {
        return .init(
            input: input,
            command: self.listWorkloadEstimateUsage,
            inputKey: \ListWorkloadEstimateUsageRequest.nextToken,
            outputKey: \ListWorkloadEstimateUsageResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkloadEstimateUsage(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters:  Filters to apply to the list of usage items.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - workloadEstimateId:  The unique identifier of the workload estimate to list usage for.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadEstimateUsagePaginator(
        filters: [ListUsageFilter]? = nil,
        maxResults: Int? = nil,
        workloadEstimateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkloadEstimateUsageRequest, ListWorkloadEstimateUsageResponse> {
        let input = ListWorkloadEstimateUsageRequest(
            filters: filters, 
            maxResults: maxResults, 
            workloadEstimateId: workloadEstimateId
        )
        return self.listWorkloadEstimateUsagePaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkloadEstimates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadEstimatesPaginator(
        _ input: ListWorkloadEstimatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkloadEstimatesRequest, ListWorkloadEstimatesResponse> {
        return .init(
            input: input,
            command: self.listWorkloadEstimates,
            inputKey: \ListWorkloadEstimatesRequest.nextToken,
            outputKey: \ListWorkloadEstimatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkloadEstimates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - createdAtFilter:  Filter workload estimates based on the creation date.
    ///   - expiresAtFilter:  Filter workload estimates based on the expiration date.
    ///   - filters:  Filters to apply to the list of workload estimates.
    ///   - maxResults:  The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadEstimatesPaginator(
        createdAtFilter: FilterTimestamp? = nil,
        expiresAtFilter: FilterTimestamp? = nil,
        filters: [ListWorkloadEstimatesFilter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkloadEstimatesRequest, ListWorkloadEstimatesResponse> {
        let input = ListWorkloadEstimatesRequest(
            createdAtFilter: createdAtFilter, 
            expiresAtFilter: expiresAtFilter, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.listWorkloadEstimatesPaginator(input, logger: logger)
    }
}

extension BCMPricingCalculator.ListBillEstimateCommitmentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BCMPricingCalculator.ListBillEstimateCommitmentsRequest {
        return .init(
            billEstimateId: self.billEstimateId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BCMPricingCalculator.ListBillEstimateInputCommitmentModificationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BCMPricingCalculator.ListBillEstimateInputCommitmentModificationsRequest {
        return .init(
            billEstimateId: self.billEstimateId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BCMPricingCalculator.ListBillEstimateInputUsageModificationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BCMPricingCalculator.ListBillEstimateInputUsageModificationsRequest {
        return .init(
            billEstimateId: self.billEstimateId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BCMPricingCalculator.ListBillEstimateLineItemsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BCMPricingCalculator.ListBillEstimateLineItemsRequest {
        return .init(
            billEstimateId: self.billEstimateId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BCMPricingCalculator.ListBillEstimatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BCMPricingCalculator.ListBillEstimatesRequest {
        return .init(
            createdAtFilter: self.createdAtFilter,
            expiresAtFilter: self.expiresAtFilter,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BCMPricingCalculator.ListBillScenarioCommitmentModificationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BCMPricingCalculator.ListBillScenarioCommitmentModificationsRequest {
        return .init(
            billScenarioId: self.billScenarioId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BCMPricingCalculator.ListBillScenarioUsageModificationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BCMPricingCalculator.ListBillScenarioUsageModificationsRequest {
        return .init(
            billScenarioId: self.billScenarioId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BCMPricingCalculator.ListBillScenariosRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BCMPricingCalculator.ListBillScenariosRequest {
        return .init(
            createdAtFilter: self.createdAtFilter,
            expiresAtFilter: self.expiresAtFilter,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BCMPricingCalculator.ListWorkloadEstimateUsageRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BCMPricingCalculator.ListWorkloadEstimateUsageRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            workloadEstimateId: self.workloadEstimateId
        )
    }
}

extension BCMPricingCalculator.ListWorkloadEstimatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BCMPricingCalculator.ListWorkloadEstimatesRequest {
        return .init(
            createdAtFilter: self.createdAtFilter,
            expiresAtFilter: self.expiresAtFilter,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
