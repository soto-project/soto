//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension LocationService {
    // MARK: Enums

    public enum BatchItemErrorCode: String, CustomStringConvertible, Codable {
        case accessdeniederror = "AccessDeniedError"
        case conflicterror = "ConflictError"
        case internalservererror = "InternalServerError"
        case resourcenotfounderror = "ResourceNotFoundError"
        case throttlingerror = "ThrottlingError"
        case validationerror = "ValidationError"
        public var description: String { return self.rawValue }
    }

    public enum DimensionUnit: String, CustomStringConvertible, Codable {
        case feet = "Feet"
        case meters = "Meters"
        public var description: String { return self.rawValue }
    }

    public enum DistanceUnit: String, CustomStringConvertible, Codable {
        case kilometers = "Kilometers"
        case miles = "Miles"
        public var description: String { return self.rawValue }
    }

    public enum IntendedUse: String, CustomStringConvertible, Codable {
        case singleuse = "SingleUse"
        case storage = "Storage"
        public var description: String { return self.rawValue }
    }

    public enum PricingPlan: String, CustomStringConvertible, Codable {
        case mobileassetmanagement = "MobileAssetManagement"
        case mobileassettracking = "MobileAssetTracking"
        case requestbasedusage = "RequestBasedUsage"
        public var description: String { return self.rawValue }
    }

    public enum TravelMode: String, CustomStringConvertible, Codable {
        case car = "Car"
        case truck = "Truck"
        case walking = "Walking"
        public var description: String { return self.rawValue }
    }

    public enum VehicleWeightUnit: String, CustomStringConvertible, Codable {
        case kilograms = "Kilograms"
        case pounds = "Pounds"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateTrackerConsumerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker resource. Used when you need to specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
        public let consumerArn: String
        /// The name of the tracker resource to be associated with a geofence collection.
        public let trackerName: String

        public init(consumerArn: String, trackerName: String) {
            self.consumerArn = consumerArn
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, max: 1600)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, min: 0)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case consumerArn = "ConsumerArn"
        }
    }

    public struct AssociateTrackerConsumerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct BatchDeleteDevicePositionHistoryError: AWSDecodableShape {
        /// The ID of the device for this position.
        public let deviceId: String
        public let error: BatchItemError

        public init(deviceId: String, error: BatchItemError) {
            self.deviceId = deviceId
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
        }
    }

    public struct BatchDeleteDevicePositionHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// Devices whose position history you want to delete.   For example, for two devices: “DeviceIds” : [DeviceId1,DeviceId2]
        public let deviceIds: [String]
        /// The name of the tracker resource to delete the device position history from.
        public let trackerName: String

        public init(deviceIds: [String], trackerName: String) {
            self.deviceIds = deviceIds
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.deviceIds.forEach {
                try validate($0, name: "deviceIds[]", parent: name, max: 100)
                try validate($0, name: "deviceIds[]", parent: name, min: 1)
                try validate($0, name: "deviceIds[]", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            }
            try self.validate(self.deviceIds, name: "deviceIds", parent: name, max: 100)
            try self.validate(self.deviceIds, name: "deviceIds", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceIds = "DeviceIds"
        }
    }

    public struct BatchDeleteDevicePositionHistoryResponse: AWSDecodableShape {
        /// Contains error details for each device history that failed to delete.
        public let errors: [BatchDeleteDevicePositionHistoryError]

        public init(errors: [BatchDeleteDevicePositionHistoryError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteGeofenceError: AWSDecodableShape {
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// The geofence associated with the error message.
        public let geofenceId: String

        public init(error: BatchItemError, geofenceId: String) {
            self.error = error
            self.geofenceId = geofenceId
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case geofenceId = "GeofenceId"
        }
    }

    public struct BatchDeleteGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The geofence collection storing the geofences to be deleted.
        public let collectionName: String
        /// The batch of geofences to be deleted.
        public let geofenceIds: [String]

        public init(collectionName: String, geofenceIds: [String]) {
            self.collectionName = collectionName
            self.geofenceIds = geofenceIds
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.geofenceIds.forEach {
                try validate($0, name: "geofenceIds[]", parent: name, max: 100)
                try validate($0, name: "geofenceIds[]", parent: name, min: 1)
                try validate($0, name: "geofenceIds[]", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            }
            try self.validate(self.geofenceIds, name: "geofenceIds", parent: name, max: 10)
            try self.validate(self.geofenceIds, name: "geofenceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case geofenceIds = "GeofenceIds"
        }
    }

    public struct BatchDeleteGeofenceResponse: AWSDecodableShape {
        /// Contains error details for each geofence that failed to delete.
        public let errors: [BatchDeleteGeofenceError]

        public init(errors: [BatchDeleteGeofenceError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchEvaluateGeofencesError: AWSDecodableShape {
        /// The device associated with the position evaluation error.
        public let deviceId: String
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// Specifies a timestamp for when the error occurred in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String, error: BatchItemError, sampleTime: Date) {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
            case sampleTime = "SampleTime"
        }
    }

    public struct BatchEvaluateGeofencesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The geofence collection used in evaluating the position of devices against its geofences.
        public let collectionName: String
        /// Contains device details for each device to be evaluated against the given geofence collection.
        public let devicePositionUpdates: [DevicePositionUpdate]

        public init(collectionName: String, devicePositionUpdates: [DevicePositionUpdate]) {
            self.collectionName = collectionName
            self.devicePositionUpdates = devicePositionUpdates
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.devicePositionUpdates.forEach {
                try $0.validate(name: "\(name).devicePositionUpdates[]")
            }
            try self.validate(self.devicePositionUpdates, name: "devicePositionUpdates", parent: name, max: 10)
            try self.validate(self.devicePositionUpdates, name: "devicePositionUpdates", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositionUpdates = "DevicePositionUpdates"
        }
    }

    public struct BatchEvaluateGeofencesResponse: AWSDecodableShape {
        /// Contains error details for each device that failed to evaluate its position against the given geofence collection.
        public let errors: [BatchEvaluateGeofencesError]

        public init(errors: [BatchEvaluateGeofencesError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchGetDevicePositionError: AWSDecodableShape {
        /// The ID of the device that didn't return a position.
        public let deviceId: String
        /// Contains details related to the error code.
        public let error: BatchItemError

        public init(deviceId: String, error: BatchItemError) {
            self.deviceId = deviceId
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
        }
    }

    public struct BatchGetDevicePositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// Devices whose position you want to retrieve.   For example, for two devices: device-ids=DeviceId1&amp;device-ids=DeviceId2
        public let deviceIds: [String]
        /// The tracker resource retrieving the device position.
        public let trackerName: String

        public init(deviceIds: [String], trackerName: String) {
            self.deviceIds = deviceIds
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.deviceIds.forEach {
                try validate($0, name: "deviceIds[]", parent: name, max: 100)
                try validate($0, name: "deviceIds[]", parent: name, min: 1)
                try validate($0, name: "deviceIds[]", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            }
            try self.validate(self.deviceIds, name: "deviceIds", parent: name, max: 10)
            try self.validate(self.deviceIds, name: "deviceIds", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceIds = "DeviceIds"
        }
    }

    public struct BatchGetDevicePositionResponse: AWSDecodableShape {
        /// Contains device position details such as the device ID, position, and timestamps for when the position was received and sampled.
        public let devicePositions: [DevicePosition]
        /// Contains error details for each device that failed to send its position to the tracker resource.
        public let errors: [BatchGetDevicePositionError]

        public init(devicePositions: [DevicePosition], errors: [BatchGetDevicePositionError]) {
            self.devicePositions = devicePositions
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositions = "DevicePositions"
            case errors = "Errors"
        }
    }

    public struct BatchItemError: AWSDecodableShape {
        /// The error code associated with the batch request error.
        public let code: BatchItemErrorCode?
        /// A message with the reason for the batch request error.
        public let message: String?

        public init(code: BatchItemErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct BatchPutGeofenceError: AWSDecodableShape {
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// The geofence associated with the error message.
        public let geofenceId: String

        public init(error: BatchItemError, geofenceId: String) {
            self.error = error
            self.geofenceId = geofenceId
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case geofenceId = "GeofenceId"
        }
    }

    public struct BatchPutGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The geofence collection storing the geofences.
        public let collectionName: String
        /// The batch of geofences to be stored in a geofence collection.
        public let entries: [BatchPutGeofenceRequestEntry]

        public init(collectionName: String, entries: [BatchPutGeofenceRequestEntry]) {
            self.collectionName = collectionName
            self.entries = entries
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.entries, name: "entries", parent: name, max: 10)
            try self.validate(self.entries, name: "entries", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
        }
    }

    public struct BatchPutGeofenceRequestEntry: AWSEncodableShape {
        /// The identifier for the geofence to be stored in a given geofence collection.
        public let geofenceId: String
        /// Contains the polygon details to specify the position of the geofence.  Each geofence polygon can have a maximum of 1,000 vertices.
        public let geometry: GeofenceGeometry

        public init(geofenceId: String, geometry: GeofenceGeometry) {
            self.geofenceId = geofenceId
            self.geometry = geometry
        }

        public func validate(name: String) throws {
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case geofenceId = "GeofenceId"
            case geometry = "Geometry"
        }
    }

    public struct BatchPutGeofenceResponse: AWSDecodableShape {
        /// Contains additional error details for each geofence that failed to be stored in a geofence collection.
        public let errors: [BatchPutGeofenceError]
        /// Contains each geofence that was successfully stored in a geofence collection.
        public let successes: [BatchPutGeofenceSuccess]

        public init(errors: [BatchPutGeofenceError], successes: [BatchPutGeofenceSuccess]) {
            self.errors = errors
            self.successes = successes
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case successes = "Successes"
        }
    }

    public struct BatchPutGeofenceSuccess: AWSDecodableShape {
        /// The timestamp for when the geofence was stored in a geofence collection in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence successfully stored in a geofence collection.
        public let geofenceId: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case updateTime = "UpdateTime"
        }
    }

    public struct BatchUpdateDevicePositionError: AWSDecodableShape {
        /// The device associated with the failed location update.
        public let deviceId: String
        /// Contains details related to the error code such as the error code and error message.
        public let error: BatchItemError
        /// The timestamp at which the device position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String, error: BatchItemError, sampleTime: Date) {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
            case sampleTime = "SampleTime"
        }
    }

    public struct BatchUpdateDevicePositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The name of the tracker resource to update.
        public let trackerName: String
        /// Contains the position update details for each device.
        public let updates: [DevicePositionUpdate]

        public init(trackerName: String, updates: [DevicePositionUpdate]) {
            self.trackerName = trackerName
            self.updates = updates
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
            try self.updates.forEach {
                try $0.validate(name: "\(name).updates[]")
            }
            try self.validate(self.updates, name: "updates", parent: name, max: 10)
            try self.validate(self.updates, name: "updates", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case updates = "Updates"
        }
    }

    public struct BatchUpdateDevicePositionResponse: AWSDecodableShape {
        /// Contains error details for each device that failed to update its position.
        public let errors: [BatchUpdateDevicePositionError]

        public init(errors: [BatchUpdateDevicePositionError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct CalculateRouteCarModeOptions: AWSEncodableShape {
        /// Avoids ferries when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidFerries: Bool?
        /// Avoids tolls when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidTolls: Bool?

        public init(avoidFerries: Bool? = nil, avoidTolls: Bool? = nil) {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
        }

        private enum CodingKeys: String, CodingKey {
            case avoidFerries = "AvoidFerries"
            case avoidTolls = "AvoidTolls"
        }
    }

    public struct CalculateRouteRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "calculatorName", location: .uri(locationName: "CalculatorName"))
        ]

        /// The name of the route calculator resource that you want to use to calculate a route.
        public let calculatorName: String
        /// Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
        public let carModeOptions: CalculateRouteCarModeOptions?
        /// Sets the time of departure as the current time. Uses the current time to calculate a route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route. Default Value: false  Valid Values: false | true
        public let departNow: Bool?
        /// The start position for the route. Defined in WGS 84 format: [longitude, latitude].   For example, [-123.115, 49.285]     If you specify a departure that's not located on a road, Amazon Location moves the position to the nearest road.  Valid Values: [-180 to 180,-90 to 90]
        public let departurePosition: [Double]
        /// Specifies the desired time of departure. Uses the given time to calculate a route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.  Setting a departure time in the past returns a 400 ValidationException error.    In ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
        @OptionalCustomCoding<ISO8601DateCoder>
        public var departureTime: Date?
        /// The finish position for the route. Defined in WGS 84 format: [longitude, latitude].    For example, [-122.339, 47.615]     If you specify a destination that's not located on a road, Amazon Location moves the position to the nearest road.   Valid Values: [-180 to 180,-90 to 90]
        public let destinationPosition: [Double]
        /// Set the unit system to specify the distance. Default Value: Kilometers
        public let distanceUnit: DistanceUnit?
        /// Set to include the geometry details in the result for each path between a pair of positions. Default Value: false  Valid Values: false | true
        public let includeLegGeometry: Bool?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. The TravelMode you specify determines how you specify route preferences:    If traveling by Car use the CarModeOptions parameter.   If traveling by Truck use the TruckModeOptions parameter.   Default Value: Car
        public let travelMode: TravelMode?
        /// Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
        public let truckModeOptions: CalculateRouteTruckModeOptions?
        /// Specifies an ordered list of up to 23 intermediate positions to include along a route between the departure position and destination position.    For example, from the DeparturePosition [-123.115, 49.285], the route follows the order that the waypoint positions are given [[-122.757, 49.0021],[-122.349, 47.620]]     If you specify a waypoint position that's not located on a road, Amazon Location moves the position to the nearest road.  Specifying more than 23 waypoints returns a 400 ValidationException error.  Valid Values: [-180 to 180,-90 to 90]
        public let waypointPositions: [[Double]]?

        public init(calculatorName: String, carModeOptions: CalculateRouteCarModeOptions? = nil, departNow: Bool? = nil, departurePosition: [Double], departureTime: Date? = nil, destinationPosition: [Double], distanceUnit: DistanceUnit? = nil, includeLegGeometry: Bool? = nil, travelMode: TravelMode? = nil, truckModeOptions: CalculateRouteTruckModeOptions? = nil, waypointPositions: [[Double]]? = nil) {
            self.calculatorName = calculatorName
            self.carModeOptions = carModeOptions
            self.departNow = departNow
            self.departurePosition = departurePosition
            self.departureTime = departureTime
            self.destinationPosition = destinationPosition
            self.distanceUnit = distanceUnit
            self.includeLegGeometry = includeLegGeometry
            self.travelMode = travelMode
            self.truckModeOptions = truckModeOptions
            self.waypointPositions = waypointPositions
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.departurePosition, name: "departurePosition", parent: name, max: 2)
            try self.validate(self.departurePosition, name: "departurePosition", parent: name, min: 2)
            try self.validate(self.destinationPosition, name: "destinationPosition", parent: name, max: 2)
            try self.validate(self.destinationPosition, name: "destinationPosition", parent: name, min: 2)
            try self.truckModeOptions?.validate(name: "\(name).truckModeOptions")
            try self.waypointPositions?.forEach {
                try validate($0, name: "waypointPositions[]", parent: name, max: 2)
                try validate($0, name: "waypointPositions[]", parent: name, min: 2)
            }
            try self.validate(self.waypointPositions, name: "waypointPositions", parent: name, max: 23)
            try self.validate(self.waypointPositions, name: "waypointPositions", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case carModeOptions = "CarModeOptions"
            case departNow = "DepartNow"
            case departurePosition = "DeparturePosition"
            case departureTime = "DepartureTime"
            case destinationPosition = "DestinationPosition"
            case distanceUnit = "DistanceUnit"
            case includeLegGeometry = "IncludeLegGeometry"
            case travelMode = "TravelMode"
            case truckModeOptions = "TruckModeOptions"
            case waypointPositions = "WaypointPositions"
        }
    }

    public struct CalculateRouteResponse: AWSDecodableShape {
        /// Contains details about each path between a pair of positions included along a route such as: StartPosition, EndPosition, Distance, DurationSeconds, Geometry, and Steps. The number of legs returned corresponds to one fewer than the total number of positions in the request.  For example, a route with a departure position and destination position returns one leg with the positions snapped to a nearby road:   The StartPosition is the departure position.   The EndPosition is the destination position.   A route with a waypoint between the departure and destination position returns two legs with the positions snapped to a nearby road:   Leg 1: The StartPosition is the departure position . The EndPosition is the waypoint positon.   Leg 2: The StartPosition is the waypoint position. The EndPosition is the destination position.
        public let legs: [Leg]
        /// Contains information about the whole route, such as: RouteBBox, DataSource, Distance, DistanceUnit, and DurationSeconds.
        public let summary: CalculateRouteSummary

        public init(legs: [Leg], summary: CalculateRouteSummary) {
            self.legs = legs
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case legs = "Legs"
            case summary = "Summary"
        }
    }

    public struct CalculateRouteSummary: AWSDecodableShape {
        /// The data provider of traffic and road network data used to calculate the route. Indicates one of the available providers:    Esri     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The total distance covered by the route. The sum of the distance travelled between every stop on the route.  The route distance can't be greater than 250 km. If the route exceeds 250 km, the response returns a 400 RoutesValidationException error.
        public let distance: Double
        /// The unit of measurement for the distance.
        public let distanceUnit: DistanceUnit
        /// The total travel time for the route measured in seconds. The sum of the travel time between every stop on the route.
        public let durationSeconds: Double
        /// Specifies a geographical box surrounding a route. Used to zoom into a route when displaying it in a map. For example, [min x, min y, max x, max y]. The first 2 bbox parameters describe the lower southwest corner:    The first bbox position is the X coordinate or longitude of the lower southwest corner.    The second bbox position is the Y coordinate or latitude of the lower southwest corner.    The next 2 bbox parameters describe the upper northeast corner:    The third bbox position is the X coordinate, or longitude of the upper northeast corner.    The fourth bbox position is the Y coordinate, or longitude of the upper northeast corner.
        public let routeBBox: [Double]

        public init(dataSource: String, distance: Double, distanceUnit: DistanceUnit, durationSeconds: Double, routeBBox: [Double]) {
            self.dataSource = dataSource
            self.distance = distance
            self.distanceUnit = distanceUnit
            self.durationSeconds = durationSeconds
            self.routeBBox = routeBBox
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case distance = "Distance"
            case distanceUnit = "DistanceUnit"
            case durationSeconds = "DurationSeconds"
            case routeBBox = "RouteBBox"
        }
    }

    public struct CalculateRouteTruckModeOptions: AWSEncodableShape {
        /// Avoids ferries when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidFerries: Bool?
        /// Avoids ferries when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidTolls: Bool?
        /// Specifies the truck's dimension specifications including length, height, width, and unit of measurement. Used to avoid roads that can't support the truck's dimensions.
        public let dimensions: TruckDimensions?
        /// Specifies the truck's weight specifications including total weight and unit of measurement. Used to avoid roads that can't support the truck's weight.
        public let weight: TruckWeight?

        public init(avoidFerries: Bool? = nil, avoidTolls: Bool? = nil, dimensions: TruckDimensions? = nil, weight: TruckWeight? = nil) {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
            self.dimensions = dimensions
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.dimensions?.validate(name: "\(name).dimensions")
            try self.weight?.validate(name: "\(name).weight")
        }

        private enum CodingKeys: String, CodingKey {
            case avoidFerries = "AvoidFerries"
            case avoidTolls = "AvoidTolls"
            case dimensions = "Dimensions"
            case weight = "Weight"
        }
    }

    public struct CreateGeofenceCollectionRequest: AWSEncodableShape {
        /// A custom name for the geofence collection. Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).    Must be a unique geofence collection name.   No spaces allowed. For example, ExampleGeofenceCollection.
        public let collectionName: String
        /// An optional description for the geofence collection.
        public let description: String?
        /// A key identifier for an AWS KMS customer managed key. Enter a key ID, key ARN, alias name, or alias ARN.
        public let kmsKeyId: String?
        /// Specifies the pricing plan for the geofence collection. For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// Specifies the data provider for the geofence collection.   Required value for the following pricing plans: MobileAssetTracking | MobileAssetManagement    For more information about Data Providers, and Pricing plans, see the Amazon Location Service product page.  Amazon Location Service only uses PricingPlanDataSource to calculate billing for your geofence collection. Your data won't be shared with the data provider, and will remain in your AWS account or Region unless you move it.  Valid Values: Esri | Here
        public let pricingPlanDataSource: String?
        /// Applies one or more tags to the geofence collection. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
        public let tags: [String: String]?

        public init(collectionName: String, description: String? = nil, kmsKeyId: String? = nil, pricingPlan: PricingPlan, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil) {
            self.collectionName = collectionName
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "CollectionName"
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
        }
    }

    public struct CreateGeofenceCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all AWS.    Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
        public let collectionArn: String
        /// The name for the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date

        public init(collectionArn: String, collectionName: String, createTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.createTime = createTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
        }
    }

    public struct CreateMapRequest: AWSEncodableShape {
        /// Specifies the map style selected from an available data provider.
        public let configuration: MapConfiguration
        /// An optional description for the map resource.
        public let description: String?
        /// The name for the map resource. Requirements:   Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).    Must be a unique map resource name.    No spaces allowed. For example, ExampleMap.
        public let mapName: String
        /// Specifies the pricing plan for your map resource. For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// Applies one or more tags to the map resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
        public let tags: [String: String]?

        public init(configuration: MapConfiguration, description: String? = nil, mapName: String, pricingPlan: PricingPlan, tags: [String: String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case description = "Description"
            case mapName = "MapName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
        }
    }

    public struct CreateMapResponse: AWSDecodableShape {
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:maps/ExampleMap
        public let mapArn: String
        /// The name of the map resource.
        public let mapName: String

        public init(createTime: Date, mapArn: String, mapName: String) {
            self.createTime = createTime
            self.mapArn = mapArn
            self.mapName = mapName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case mapArn = "MapArn"
            case mapName = "MapName"
        }
    }

    public struct CreatePlaceIndexRequest: AWSEncodableShape {
        /// Specifies the data provider of geospatial data.  This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error.  Valid values include:    Esri – For additional information about Esri's coverage in your region of interest, see Esri details on geocoding coverage.    Here – For additional information about HERE Technologies's coverage in your region of interest, see HERE details on goecoding coverage.  Place index resources using HERE Technologies as a data provider can't store results for locations in Japan. For more information, see the AWS Service Terms for Amazon Location Service.    For additional information , see Data providers on the Amazon Location Service Developer Guide.
        public let dataSource: String
        /// Specifies the data storage option requesting Places.
        public let dataSourceConfiguration: DataSourceConfiguration?
        /// The optional description for the place index resource.
        public let description: String?
        /// The name of the place index resource.  Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).   Must be a unique place index resource name.   No spaces allowed. For example, ExamplePlaceIndex.
        public let indexName: String
        /// Specifies the pricing plan for your place index resource. For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// Applies one or more tags to the place index resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
        public let tags: [String: String]?

        public init(dataSource: String, dataSourceConfiguration: DataSourceConfiguration? = nil, description: String? = nil, indexName: String, pricingPlan: PricingPlan, tags: [String: String]? = nil) {
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case dataSourceConfiguration = "DataSourceConfiguration"
            case description = "Description"
            case indexName = "IndexName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
        }
    }

    public struct CreatePlaceIndexResponse: AWSDecodableShape {
        /// The timestamp for when the place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across AWS.    Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
        public let indexArn: String
        /// The name for the place index resource.
        public let indexName: String

        public init(createTime: Date, indexArn: String, indexName: String) {
            self.createTime = createTime
            self.indexArn = indexArn
            self.indexName = indexName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case indexArn = "IndexArn"
            case indexName = "IndexName"
        }
    }

    public struct CreateRouteCalculatorRequest: AWSEncodableShape {
        /// The name of the route calculator resource.  Requirements:   Can use alphanumeric characters (A–Z, a–z, 0–9) , hyphens (-), periods (.), and underscores (_).   Must be a unique Route calculator resource name.   No spaces allowed. For example, ExampleRouteCalculator.
        public let calculatorName: String
        /// Specifies the data provider of traffic and road network data.  This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error.  Valid values include:    Esri – For additional information about Esri's coverage in your region of interest, see Esri details on street networks and traffic coverage.    Here – For additional information about HERE Technologies's coverage in your region of interest, see HERE car routing coverage and HERE truck routing coverage.   For additional information , see Data providers on the Amazon Location Service Developer Guide.
        public let dataSource: String
        /// The optional description for the route calculator resource.
        public let description: String?
        /// Specifies the pricing plan for your route calculator resource. For additional details and restrictions on each pricing plan option, see Amazon Location Service pricing.
        public let pricingPlan: PricingPlan
        /// Applies one or more tags to the route calculator resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.   For example: { "tag1" : "value1", "tag2" : "value2"}   Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
        public let tags: [String: String]?

        public init(calculatorName: String, dataSource: String, description: String? = nil, pricingPlan: PricingPlan, tags: [String: String]? = nil) {
            self.calculatorName = calculatorName
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorName = "CalculatorName"
            case dataSource = "DataSource"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
        }
    }

    public struct CreateRouteCalculatorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the route calculator resource. Use the ARN when you specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
        public let calculatorArn: String
        /// The name of the route calculator resource.    For example, ExampleRouteCalculator.
        public let calculatorName: String
        /// The timestamp when the route calculator resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date

        public init(calculatorArn: String, calculatorName: String, createTime: Date) {
            self.calculatorArn = calculatorArn
            self.calculatorName = calculatorName
            self.createTime = createTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorArn = "CalculatorArn"
            case calculatorName = "CalculatorName"
            case createTime = "CreateTime"
        }
    }

    public struct CreateTrackerRequest: AWSEncodableShape {
        /// An optional description for the tracker resource.
        public let description: String?
        /// A key identifier for an AWS KMS customer managed key. Enter a key ID, key ARN, alias name, or alias ARN.
        public let kmsKeyId: String?
        /// Specifies the pricing plan for the tracker resource. For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// Specifies the data provider for the tracker resource.   Required value for the following pricing plans: MobileAssetTracking | MobileAssetManagement    For more information about Data Providers, and Pricing plans, see the Amazon Location Service product page.  Amazon Location Service only uses PricingPlanDataSource to calculate billing for your tracker resource. Your data will not be shared with the data provider, and will remain in your AWS account or Region unless you move it.  Valid Values: Esri | Here
        public let pricingPlanDataSource: String?
        /// Applies one or more tags to the tracker resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.
        public let tags: [String: String]?
        /// The name for the tracker resource. Requirements:   Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).   Must be a unique tracker resource name.   No spaces allowed. For example, ExampleTracker.
        public let trackerName: String

        public init(description: String? = nil, kmsKeyId: String? = nil, pricingPlan: PricingPlan, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil, trackerName: String) {
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
            case trackerName = "TrackerName"
        }
    }

    public struct CreateTrackerResponse: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
        public let trackerArn: String
        /// The name of the tracker resource.
        public let trackerName: String

        public init(createTime: Date, trackerArn: String, trackerName: String) {
            self.createTime = createTime
            self.trackerArn = trackerArn
            self.trackerName = trackerName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case trackerArn = "TrackerArn"
            case trackerName = "TrackerName"
        }
    }

    public struct DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how the results of an operation will be stored by the caller.  Valid values include:    SingleUse specifies that the results won't be stored.     Storage specifies that the result can be cached or stored in a database.   Default value: SingleUse
        public let intendedUse: IntendedUse?

        public init(intendedUse: IntendedUse? = nil) {
            self.intendedUse = intendedUse
        }

        private enum CodingKeys: String, CodingKey {
            case intendedUse = "IntendedUse"
        }
    }

    public struct DeleteGeofenceCollectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The name of the geofence collection to be deleted.
        public let collectionName: String

        public init(collectionName: String) {
            self.collectionName = collectionName
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGeofenceCollectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMapRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName"))
        ]

        /// The name of the map resource to be deleted.
        public let mapName: String

        public init(mapName: String) {
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMapResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePlaceIndexRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri(locationName: "IndexName"))
        ]

        /// The name of the place index resource to be deleted.
        public let indexName: String

        public init(indexName: String) {
            self.indexName = indexName
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePlaceIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRouteCalculatorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "calculatorName", location: .uri(locationName: "CalculatorName"))
        ]

        /// The name of the route calculator resource to be deleted.
        public let calculatorName: String

        public init(calculatorName: String) {
            self.calculatorName = calculatorName
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRouteCalculatorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTrackerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The name of the tracker resource to be deleted.
        public let trackerName: String

        public init(trackerName: String) {
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTrackerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeGeofenceCollectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The name of the geofence collection.
        public let collectionName: String

        public init(collectionName: String) {
            self.collectionName = collectionName
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGeofenceCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all AWS.    Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
        public let collectionArn: String
        /// The name of the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The optional description for the geofence collection.
        public let description: String
        /// A key identifier for an AWS KMS customer managed key assigned to the Amazon Location resource
        public let kmsKeyId: String?
        /// The pricing plan selected for the specified geofence collection. For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// The specified data provider for the geofence collection.
        public let pricingPlanDataSource: String?
        /// Displays the key, value pairs of tags associated with this resource.
        public let tags: [String: String]?
        /// The timestamp for when the geofence collection was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(collectionArn: String, collectionName: String, createTime: Date, description: String, kmsKeyId: String? = nil, pricingPlan: PricingPlan, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeMapRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName"))
        ]

        /// The name of the map resource.
        public let mapName: String

        public init(mapName: String) {
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeMapResponse: AWSDecodableShape {
        /// Specifies the map tile style selected from a partner data provider.
        public let configuration: MapConfiguration
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// Specifies the data provider for the associated map tiles.
        public let dataSource: String
        /// The optional description for the map resource.
        public let description: String
        /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:maps/ExampleMap
        public let mapArn: String
        /// The map style selected from an available provider.
        public let mapName: String
        /// The pricing plan selected for the specified map resource.  &lt;p&gt;For additional details and restrictions on each pricing plan option, see the &lt;a href=&quot;https://aws.amazon.com/location/pricing/&quot;&gt;Amazon Location Service pricing page&lt;/a&gt;.&lt;/p&gt;
        public let pricingPlan: PricingPlan
        /// Tags associated with the map resource.
        public let tags: [String: String]?
        /// The timestamp for when the map resource was last update in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(configuration: MapConfiguration, createTime: Date, dataSource: String, description: String, mapArn: String, mapName: String, pricingPlan: PricingPlan, tags: [String: String]? = nil, updateTime: Date) {
            self.configuration = configuration
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapArn = mapArn
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case mapArn = "MapArn"
            case mapName = "MapName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribePlaceIndexRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri(locationName: "IndexName"))
        ]

        /// The name of the place index resource.
        public let indexName: String

        public init(indexName: String) {
            self.indexName = indexName
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePlaceIndexResponse: AWSDecodableShape {
        /// The timestamp for when the place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of geospatial data. Indicates one of the available providers:    Esri     Here    For additional details on data providers, see the Amazon Location Service data providers page.
        public let dataSource: String
        /// The specified data storage option for requesting Places.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// The optional description for the place index resource.
        public let description: String
        /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across AWS.    Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
        public let indexArn: String
        /// The name of the place index resource being described.
        public let indexName: String
        /// The pricing plan selected for the specified place index resource. For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// Tags associated with place index resource.
        public let tags: [String: String]?
        /// The timestamp for when the place index resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, dataSource: String, dataSourceConfiguration: DataSourceConfiguration, description: String, indexArn: String, indexName: String, pricingPlan: PricingPlan, tags: [String: String]? = nil, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexArn = indexArn
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case dataSourceConfiguration = "DataSourceConfiguration"
            case description = "Description"
            case indexArn = "IndexArn"
            case indexName = "IndexName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeRouteCalculatorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "calculatorName", location: .uri(locationName: "CalculatorName"))
        ]

        /// The name of the route calculator resource.
        public let calculatorName: String

        public init(calculatorName: String) {
            self.calculatorName = calculatorName
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRouteCalculatorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the Route calculator resource. Use the ARN when you specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
        public let calculatorArn: String
        /// The name of the route calculator resource being described.
        public let calculatorName: String
        /// The timestamp when the route calculator resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of traffic and road network data. Indicates one of the available providers:    Esri     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The optional description of the route calculator resource.
        public let description: String
        /// The pricing plan selected for the specified route calculator resource. For additional details and restrictions on each pricing plan option, see Amazon Location Service pricing.
        public let pricingPlan: PricingPlan
        /// Tags associated with route calculator resource.
        public let tags: [String: String]?
        /// The timestamp when the route calculator resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(calculatorArn: String, calculatorName: String, createTime: Date, dataSource: String, description: String, pricingPlan: PricingPlan, tags: [String: String]? = nil, updateTime: Date) {
            self.calculatorArn = calculatorArn
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorArn = "CalculatorArn"
            case calculatorName = "CalculatorName"
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeTrackerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The name of the tracker resource.
        public let trackerName: String

        public init(trackerName: String) {
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTrackerResponse: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The optional description for the tracker resource.
        public let description: String
        /// A key identifier for an AWS KMS customer managed key assigned to the Amazon Location resource.
        public let kmsKeyId: String?
        /// The pricing plan selected for the specified tracker resource. For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// The specified data provider for the tracker resource.
        public let pricingPlanDataSource: String?
        /// The tags associated with the tracker resource.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
        public let trackerArn: String
        /// The name of the tracker resource.
        public let trackerName: String
        /// The timestamp for when the tracker resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, description: String, kmsKeyId: String? = nil, pricingPlan: PricingPlan, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil, trackerArn: String, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
            self.trackerArn = trackerArn
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
            case trackerArn = "TrackerArn"
            case trackerName = "TrackerName"
            case updateTime = "UpdateTime"
        }
    }

    public struct DevicePosition: AWSDecodableShape {
        /// The device whose position you retrieved.
        public let deviceId: String?
        /// The last known device position.
        public let position: [Double]
        /// The timestamp for when the tracker resource received the device position in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var receivedTime: Date
        /// The timestamp at which the device's position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String? = nil, position: [Double], receivedTime: Date, sampleTime: Date) {
            self.deviceId = deviceId
            self.position = position
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case position = "Position"
            case receivedTime = "ReceivedTime"
            case sampleTime = "SampleTime"
        }
    }

    public struct DevicePositionUpdate: AWSEncodableShape {
        /// The device associated to the position update.
        public let deviceId: String
        /// The latest device position defined in WGS 84 format: [X or longitude, Y or latitude].
        public let position: [Double]
        /// The timestamp at which the device's position was determined. Uses ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String, position: [Double], sampleTime: Date) {
            self.deviceId = deviceId
            self.position = position
            self.sampleTime = sampleTime
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case position = "Position"
            case sampleTime = "SampleTime"
        }
    }

    public struct DisassociateTrackerConsumerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "consumerArn", location: .uri(locationName: "ConsumerArn")),
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The Amazon Resource Name (ARN) for the geofence collection to be disassociated from the tracker resource. Used when you need to specify a resource across all AWS.    Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
        public let consumerArn: String
        /// The name of the tracker resource to be dissociated from the consumer.
        public let trackerName: String

        public init(consumerArn: String, trackerName: String) {
            self.consumerArn = consumerArn
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, max: 1600)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, min: 0)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateTrackerConsumerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GeofenceGeometry: AWSEncodableShape & AWSDecodableShape {
        /// An array of 1 or more linear rings. A linear ring is an array of 4 or more vertices, where the first and last vertex are the same to form a closed boundary. Each vertex is a 2-dimensional point of the form: [longitude, latitude].  The first linear ring is an outer ring, describing the polygon's boundary. Subsequent linear rings may be inner or outer rings to describe holes and islands. Outer rings must list their vertices in counter-clockwise order around the ring's center, where the left side is the polygon's exterior. Inner rings must list their vertices in clockwise order, where the left side is the polygon's interior.
        public let polygon: [[[Double]]]?

        public init(polygon: [[[Double]]]? = nil) {
            self.polygon = polygon
        }

        public func validate(name: String) throws {
            try self.polygon?.forEach {
                try validate($0, name: "polygon[]", parent: name, min: 4)
            }
            try self.validate(self.polygon, name: "polygon", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case polygon = "Polygon"
        }
    }

    public struct GetDevicePositionHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "deviceId", location: .uri(locationName: "DeviceId")),
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The device whose position history you want to retrieve.
        public let deviceId: String
        /// Specify the end time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be the time that the request is made. Requirement:   The time specified for EndTimeExclusive must be after the time for StartTimeInclusive.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTimeExclusive: Date?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?
        /// Specify the start time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be 24 hours prior to the time that the request is made. Requirement:   The time specified for StartTimeInclusive must be before EndTimeExclusive.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTimeInclusive: Date?
        /// The tracker resource receiving the request for the device position history.
        public let trackerName: String

        public init(deviceId: String, endTimeExclusive: Date? = nil, nextToken: String? = nil, startTimeInclusive: Date? = nil, trackerName: String) {
            self.deviceId = deviceId
            self.endTimeExclusive = endTimeExclusive
            self.nextToken = nextToken
            self.startTimeInclusive = startTimeInclusive
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeExclusive = "EndTimeExclusive"
            case nextToken = "NextToken"
            case startTimeInclusive = "StartTimeInclusive"
        }
    }

    public struct GetDevicePositionHistoryResponse: AWSDecodableShape {
        /// Contains the position history details for the requested device.
        public let devicePositions: [DevicePosition]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(devicePositions: [DevicePosition], nextToken: String? = nil) {
            self.devicePositions = devicePositions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositions = "DevicePositions"
            case nextToken = "NextToken"
        }
    }

    public struct GetDevicePositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "deviceId", location: .uri(locationName: "DeviceId")),
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The device whose position you want to retrieve.
        public let deviceId: String
        /// The tracker resource receiving the position update.
        public let trackerName: String

        public init(deviceId: String, trackerName: String) {
            self.deviceId = deviceId
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDevicePositionResponse: AWSDecodableShape {
        /// The device whose position you retrieved.
        public let deviceId: String?
        /// The last known device position.
        public let position: [Double]
        /// The timestamp for when the tracker resource received the device position in  ISO 8601  format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var receivedTime: Date
        /// The timestamp at which the device's position was determined. Uses  ISO 8601  format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String? = nil, position: [Double], receivedTime: Date, sampleTime: Date) {
            self.deviceId = deviceId
            self.position = position
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case position = "Position"
            case receivedTime = "ReceivedTime"
            case sampleTime = "SampleTime"
        }
    }

    public struct GetGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName")),
            AWSMemberEncoding(label: "geofenceId", location: .uri(locationName: "GeofenceId"))
        ]

        /// The geofence collection storing the target geofence.
        public let collectionName: String
        /// The geofence you're retrieving details for.
        public let geofenceId: String

        public init(collectionName: String, geofenceId: String) {
            self.collectionName = collectionName
            self.geofenceId = geofenceId
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGeofenceResponse: AWSDecodableShape {
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier.
        public let geofenceId: String
        /// Contains the geofence geometry details describing a polygon.
        public let geometry: GeofenceGeometry
        /// Identifies the state of the geofence. A geofence will hold one of the following states:    ACTIVE — The geofence has been indexed by the system.     PENDING — The geofence is being processed by the system.    FAILED — The geofence failed to be indexed by the system.    DELETED — The geofence has been deleted from the system index.    DELETING — The geofence is being deleted from the system index.
        public let status: String
        /// The timestamp for when the geofence collection was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, geometry: GeofenceGeometry, status: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case geometry = "Geometry"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct GetMapGlyphsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "fontStack", location: .uri(locationName: "FontStack")),
            AWSMemberEncoding(label: "fontUnicodeRange", location: .uri(locationName: "FontUnicodeRange")),
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName"))
        ]

        /// A comma-separated list of fonts to load glyphs from in order of preference. For example, Noto Sans Regular, Arial Unicode. Valid fonts for Esri styles:    VectorEsriDarkGrayCanvas – Ubuntu Medium Italic | Ubuntu Medium | Ubuntu Italic | Ubuntu Regular | Ubuntu Bold    VectorEsriLightGrayCanvas – Ubuntu Italic | Ubuntu Regular | Ubuntu Light | Ubuntu Bold    VectorEsriTopographic – Noto Sans Italic | Noto Sans Regular | Noto Sans Bold | Noto Serif Regular | Roboto Condensed Light Italic    VectorEsriStreets – Arial Regular | Arial Italic | Arial Bold    VectorEsriNavigation – Arial Regular | Arial Italic | Arial Bold    Valid fonts for HERE Technologies styles:     VectorHereBerlin – Fira GO Regular | Fira GO Bold
        public let fontStack: String
        /// A Unicode range of characters to download glyphs for. Each response will contain 256 characters. For example, 0–255 includes all characters from range U+0000 to 00FF. Must be aligned to multiples of 256.
        public let fontUnicodeRange: String
        /// The map resource associated with the glyph ﬁle.
        public let mapName: String

        public init(fontStack: String, fontUnicodeRange: String, mapName: String) {
            self.fontStack = fontStack
            self.fontUnicodeRange = fontUnicodeRange
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.fontUnicodeRange, name: "fontUnicodeRange", parent: name, pattern: "^[0-9]+-[0-9]+\\.pbf$")
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapGlyphsResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body(locationName: "Blob")),
            AWSMemberEncoding(label: "contentType", location: .header(locationName: "Content-Type"))
        ]

        /// The blob's content type.
        public let blob: AWSPayload?
        /// The map glyph content type. For example, application/octet-stream.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct GetMapSpritesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "fileName", location: .uri(locationName: "FileName")),
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName"))
        ]

        /// The name of the sprite ﬁle. Use the following ﬁle names for the sprite sheet:    sprites.png     sprites@2x.png for high pixel density displays   For the JSON document contain image offsets. Use the following ﬁle names:    sprites.json     sprites@2x.json for high pixel density displays
        public let fileName: String
        /// The map resource associated with the sprite ﬁle.
        public let mapName: String

        public init(fileName: String, mapName: String) {
            self.fileName = fileName
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.fileName, name: "fileName", parent: name, pattern: "^sprites(@2x)?\\.(png|json)$")
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapSpritesResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body(locationName: "Blob")),
            AWSMemberEncoding(label: "contentType", location: .header(locationName: "Content-Type"))
        ]

        /// Contains the body of the sprite sheet or JSON offset ﬁle.
        public let blob: AWSPayload?
        /// The content type of the sprite sheet and offsets. For example, the sprite sheet content type is image/png, and the sprite offset JSON document is application/json.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct GetMapStyleDescriptorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName"))
        ]

        /// The map resource to retrieve the style descriptor from.
        public let mapName: String

        public init(mapName: String) {
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapStyleDescriptorResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body(locationName: "Blob")),
            AWSMemberEncoding(label: "contentType", location: .header(locationName: "Content-Type"))
        ]

        /// Contains the body of the style descriptor.
        public let blob: AWSPayload?
        /// The style descriptor's content type. For example, application/json.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct GetMapTileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName")),
            AWSMemberEncoding(label: "x", location: .uri(locationName: "X")),
            AWSMemberEncoding(label: "y", location: .uri(locationName: "Y")),
            AWSMemberEncoding(label: "z", location: .uri(locationName: "Z"))
        ]

        /// The map resource to retrieve the map tiles from.
        public let mapName: String
        /// The X axis value for the map tile.
        public let x: String
        /// The Y axis value for the map tile.
        public let y: String
        /// The zoom value for the map tile.
        public let z: String

        public init(mapName: String, x: String, y: String, z: String) {
            self.mapName = mapName
            self.x = x
            self.y = y
            self.z = z
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.x, name: "x", parent: name, pattern: "\\d+")
            try self.validate(self.y, name: "y", parent: name, pattern: "\\d+")
            try self.validate(self.z, name: "z", parent: name, pattern: "\\d+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapTileResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body(locationName: "Blob")),
            AWSMemberEncoding(label: "contentType", location: .header(locationName: "Content-Type"))
        ]

        /// Contains Mapbox Vector Tile (MVT) data.
        public let blob: AWSPayload?
        /// The map tile's content type. For example, application/vnd.mapbox-vector-tile.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct Leg: AWSDecodableShape {
        /// The distance between the leg's StartPosition and EndPosition along a calculated route.    The default measurement is Kilometers unless the request specifies a DistanceUnit of Miles.
        public let distance: Double
        /// The estimated travel time between the leg's StartPosition and EndPosition. The travel mode and departure time that you specify in the request determines the calculated time.
        public let durationSeconds: Double
        /// The terminating position of the leg. Follows the format [longitude,latitude].  If the EndPosition isn't located on a road, it's snapped to a nearby road.
        public let endPosition: [Double]
        /// Contains the calculated route's path as a linestring geometry.
        public let geometry: LegGeometry?
        /// The starting position of the leg. Follows the format [longitude,latitude].  If the StartPosition isn't located on a road, it's snapped to a nearby road.
        public let startPosition: [Double]
        /// Contains a list of steps, which represent subsections of a leg. Each step provides instructions for how to move to the next step in the leg such as the step's start position, end position, travel distance, travel duration, and geometry offset.
        public let steps: [Step]

        public init(distance: Double, durationSeconds: Double, endPosition: [Double], geometry: LegGeometry? = nil, startPosition: [Double], steps: [Step]) {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometry = geometry
            self.startPosition = startPosition
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case durationSeconds = "DurationSeconds"
            case endPosition = "EndPosition"
            case geometry = "Geometry"
            case startPosition = "StartPosition"
            case steps = "Steps"
        }
    }

    public struct LegGeometry: AWSDecodableShape {
        /// An ordered list of positions used to plot a route on a map.  The first position is closest to the start position for the leg, and the last position is the closest to the end position for the leg.   For example, [[-123.117, 49.284],[-123.115, 49.285],[-123.115, 49.285]]
        public let lineString: [[Double]]?

        public init(lineString: [[Double]]? = nil) {
            self.lineString = lineString
        }

        private enum CodingKeys: String, CodingKey {
            case lineString = "LineString"
        }
    }

    public struct ListDevicePositionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// An optional limit for the number of entries returned in a single call. Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?
        /// The tracker resource containing the requested devices.
        public let trackerName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, trackerName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevicePositionsResponse: AWSDecodableShape {
        /// Contains details about each device's last known position. These details includes the device ID, the time when the position was sampled on the device, the time that the service received the update, and the most recent coordinates.
        public let entries: [ListDevicePositionsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListDevicePositionsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevicePositionsResponseEntry: AWSDecodableShape {
        /// The ID of the device for this position.
        public let deviceId: String
        /// The last known device position. Empty if no positions currently stored.
        public let position: [Double]
        /// The timestamp at which the device position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String, position: [Double], sampleTime: Date) {
            self.deviceId = deviceId
            self.position = position
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case position = "Position"
            case sampleTime = "SampleTime"
        }
    }

    public struct ListGeofenceCollectionsRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofenceCollectionsResponse: AWSDecodableShape {
        /// Lists the geofence collections that exist in your AWS account.
        public let entries: [ListGeofenceCollectionsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListGeofenceCollectionsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofenceCollectionsResponseEntry: AWSDecodableShape {
        /// The name of the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The description for the geofence collection
        public let description: String
        /// The pricing plan for the specified geofence collection. For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// The specified data provider for the geofence collection.
        public let pricingPlanDataSource: String?
        /// Specifies a timestamp for when the resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(collectionName: String, createTime: Date, description: String, pricingPlan: PricingPlan, pricingPlanDataSource: String? = nil, updateTime: Date) {
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListGeofenceResponseEntry: AWSDecodableShape {
        /// The timestamp for when the geofence was stored in a geofence collection in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier.
        public let geofenceId: String
        /// Contains the geofence geometry details describing a polygon.
        public let geometry: GeofenceGeometry
        /// Identifies the state of the geofence. A geofence will hold one of the following states:    ACTIVE — The geofence has been indexed by the system.     PENDING — The geofence is being processed by the system.    FAILED — The geofence failed to be indexed by the system.    DELETED — The geofence has been deleted from the system index.    DELETING — The geofence is being deleted from the system index.
        public let status: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, geometry: GeofenceGeometry, status: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case geometry = "Geometry"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListGeofencesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The name of the geofence collection storing the list of geofences.
        public let collectionName: String
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        public init(collectionName: String, nextToken: String? = nil) {
            self.collectionName = collectionName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofencesResponse: AWSDecodableShape {
        /// Contains a list of geofences stored in the geofence collection.
        public let entries: [ListGeofenceResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListGeofenceResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListMapsRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListMapsResponse: AWSDecodableShape {
        /// Contains a list of maps in your AWS account
        public let entries: [ListMapsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListMapsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListMapsResponseEntry: AWSDecodableShape {
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// Specifies the data provider for the associated map tiles.
        public let dataSource: String
        /// The description for the map resource.
        public let description: String
        /// The name of the associated map resource.
        public let mapName: String
        /// The pricing plan for the specified map resource. For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// The timestamp for when the map resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, dataSource: String, description: String, mapName: String, pricingPlan: PricingPlan, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case mapName = "MapName"
            case pricingPlan = "PricingPlan"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListPlaceIndexesRequest: AWSEncodableShape {
        /// An optional limit for the maximum number of results returned in a single call. Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPlaceIndexesResponse: AWSDecodableShape {
        /// Lists the place index resources that exist in your AWS account
        public let entries: [ListPlaceIndexesResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListPlaceIndexesResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListPlaceIndexesResponseEntry: AWSDecodableShape {
        /// The timestamp for when the place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of geospatial data. Indicates one of the available providers:    Esri     Here    For additional details on data providers, see the Amazon Location Service data providers page.
        public let dataSource: String
        /// The optional description for the place index resource.
        public let description: String
        /// The name of the place index resource.
        public let indexName: String
        /// The pricing plan for the specified place index resource. For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// The timestamp for when the place index resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, dataSource: String, description: String, indexName: String, pricingPlan: PricingPlan, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case indexName = "IndexName"
            case pricingPlan = "PricingPlan"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListRouteCalculatorsRequest: AWSEncodableShape {
        /// An optional maximum number of results returned in a single call. Default Value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default Value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListRouteCalculatorsResponse: AWSDecodableShape {
        /// Lists the route calculator resources that exist in your AWS account
        public let entries: [ListRouteCalculatorsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a subsequent request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListRouteCalculatorsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListRouteCalculatorsResponseEntry: AWSDecodableShape {
        /// The name of the route calculator resource.
        public let calculatorName: String
        /// The timestamp when the route calculator resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of traffic and road network data. Indicates one of the available providers:    Esri     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The optional description of the route calculator resource.
        public let description: String
        /// The pricing plan for the specified route calculator resource. For additional details and restrictions on each pricing plan option, see Amazon Location Service pricing.
        public let pricingPlan: PricingPlan
        /// The timestamp when the route calculator resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(calculatorName: String, createTime: Date, dataSource: String, description: String, pricingPlan: PricingPlan, updateTime: Date) {
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorName = "CalculatorName"
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.   Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 0)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Tags that have been applied to the specified resource. Tags are mapped from the tag key to the tag value: "TagKey" : "TagValue".   Format example: {"tag1" : "value1", "tag2" : "value2"}
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListTrackerConsumersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?
        /// The tracker resource whose associated geofence collections you want to list.
        public let trackerName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, trackerName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackerConsumersResponse: AWSDecodableShape {
        /// Contains the list of geofence collection ARNs associated to the tracker resource.
        public let consumerArns: [String]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(consumerArns: [String], nextToken: String? = nil) {
            self.consumerArns = consumerArns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case consumerArns = "ConsumerArns"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersResponse: AWSDecodableShape {
        /// Contains tracker resources in your AWS account. Details include tracker name, description and timestamps for when the tracker was created and last updated.
        public let entries: [ListTrackersResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListTrackersResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersResponseEntry: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The description for the tracker resource.
        public let description: String
        /// The pricing plan for the specified tracker resource. For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// The specified data provider for the tracker resource.
        public let pricingPlanDataSource: String?
        /// The name of the tracker resource.
        public let trackerName: String
        /// The timestamp at which the device's position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, description: String, pricingPlan: PricingPlan, pricingPlanDataSource: String? = nil, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case trackerName = "TrackerName"
            case updateTime = "UpdateTime"
        }
    }

    public struct MapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the map style selected from an available data provider. For additional information on each map style and to preview each map style, see Esri map styles and HERE map styles. Valid Esri styles:     VectorEsriDarkGrayCanvas – The Esri Dark Gray Canvas map style. A vector basemap with a dark gray, neutral background with minimal colors, labels, and features that's designed to draw attention to your thematic content.     RasterEsriImagery – The Esri Imagery map style. A raster basemap that provides one meter or better satellite and aerial imagery in many parts of the world and lower resolution satellite imagery worldwide.     VectorEsriLightGrayCanvas – The Esri Light Gray Canvas map style, which provides a detailed vector basemap with a light gray, neutral background style with minimal colors, labels, and features that's designed to draw attention to your thematic content.     VectorEsriTopographic – The Esri Light map style, which provides a detailed vector basemap with a classic Esri map style.    VectorEsriStreets – The Esri World Streets map style, which provides a detailed vector basemap for the world symbolized with a classic Esri street map style. The vector tile layer is similar in content and style to the World Street Map raster map.    VectorEsriNavigation – The Esri World Navigation map style, which provides a detailed basemap for the world symbolized with a custom navigation map style that's designed for use during the day in mobile devices.   Valid HERE Technologies styles:     VectorHereBerlin – The HERE Berlin map style is a high contrast detailed base map of the world that blends 3D and 2D rendering.  When using HERE as your data provider, and selecting the Style VectorHereBerlin, you may not use HERE Technologies maps for Asset Management. See the AWS Service Terms for Amazon Location Service.
        public let style: String

        public init(style: String) {
            self.style = style
        }

        public func validate(name: String) throws {
            try self.validate(self.style, name: "style", parent: name, max: 100)
            try self.validate(self.style, name: "style", parent: name, min: 1)
            try self.validate(self.style, name: "style", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case style = "Style"
        }
    }

    public struct Place: AWSDecodableShape {
        /// The numerical portion of an address, such as a building number.
        public let addressNumber: String?
        /// A country/region specified using ISO 3166 3-digit country/region code. For example, CAN.
        public let country: String?
        public let geometry: PlaceGeometry
        /// The full name and address of the point of interest such as a city, region, or country. For example, 123 Any Street, Any Town, USA.
        public let label: String?
        /// A name for a local area, such as a city or town name. For example, Toronto.
        public let municipality: String?
        /// The name of a community district. For example, Downtown.
        public let neighborhood: String?
        /// A group of numbers and letters in a country-specific format, which accompanies the address for the purpose of identifying a location.
        public let postalCode: String?
        /// A name for an area or geographical division, such as a province or state name. For example, British Columbia.
        public let region: String?
        /// The name for a street or a road to identify a location. For example, Main Street.
        public let street: String?
        /// A country, or an area that's part of a larger region . For example, Metro Vancouver.
        public let subRegion: String?

        public init(addressNumber: String? = nil, country: String? = nil, geometry: PlaceGeometry, label: String? = nil, municipality: String? = nil, neighborhood: String? = nil, postalCode: String? = nil, region: String? = nil, street: String? = nil, subRegion: String? = nil) {
            self.addressNumber = addressNumber
            self.country = country
            self.geometry = geometry
            self.label = label
            self.municipality = municipality
            self.neighborhood = neighborhood
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subRegion = subRegion
        }

        private enum CodingKeys: String, CodingKey {
            case addressNumber = "AddressNumber"
            case country = "Country"
            case geometry = "Geometry"
            case label = "Label"
            case municipality = "Municipality"
            case neighborhood = "Neighborhood"
            case postalCode = "PostalCode"
            case region = "Region"
            case street = "Street"
            case subRegion = "SubRegion"
        }
    }

    public struct PlaceGeometry: AWSDecodableShape {
        /// A single point geometry specifies a location for a Place using WGS 84 coordinates:    x — Specifies the x coordinate or longitude.     y — Specifies the y coordinate or latitude.
        public let point: [Double]?

        public init(point: [Double]? = nil) {
            self.point = point
        }

        private enum CodingKeys: String, CodingKey {
            case point = "Point"
        }
    }

    public struct PutGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName")),
            AWSMemberEncoding(label: "geofenceId", location: .uri(locationName: "GeofenceId"))
        ]

        /// The geofence collection to store the geofence in.
        public let collectionName: String
        /// An identifier for the geofence. For example, ExampleGeofence-1.
        public let geofenceId: String
        /// Contains the polygon details to specify the position of the geofence.  Each geofence polygon can have a maximum of 1,000 vertices.
        public let geometry: GeofenceGeometry

        public init(collectionName: String, geofenceId: String, geometry: GeofenceGeometry) {
            self.collectionName = collectionName
            self.geofenceId = geofenceId
            self.geometry = geometry
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case geometry = "Geometry"
        }
    }

    public struct PutGeofenceResponse: AWSDecodableShape {
        /// The timestamp for when the geofence was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier entered in the request.
        public let geofenceId: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case updateTime = "UpdateTime"
        }
    }

    public struct SearchForPositionResult: AWSDecodableShape {
        /// Contains details about the relevant point of interest.
        public let place: Place

        public init(place: Place) {
            self.place = place
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
        }
    }

    public struct SearchForTextResult: AWSDecodableShape {
        /// Contains details about the relevant point of interest.
        public let place: Place

        public init(place: Place) {
            self.place = place
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
        }
    }

    public struct SearchPlaceIndexForPositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri(locationName: "IndexName"))
        ]

        /// The name of the place index resource you want to use for the search.
        public let indexName: String
        /// An optional paramer. The maximum number of results returned per request.  Default value: 50
        public let maxResults: Int?
        /// Specifies a coordinate for the query defined by a longitude, and latitude.   The first position is the X coordinate, or longitude.   The second position is the Y coordinate, or latitude.    For example, position=xLongitude&amp;position=yLatitude .
        public let position: [Double]

        public init(indexName: String, maxResults: Int? = nil, position: [Double]) {
            self.indexName = indexName
            self.maxResults = maxResults
            self.position = position
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case position = "Position"
        }
    }

    public struct SearchPlaceIndexForPositionResponse: AWSDecodableShape {
        /// Returns a list of Places closest to the specified position. Each result contains additional information about the Places returned.
        public let results: [SearchForPositionResult]
        /// Contains a summary of the request.
        public let summary: SearchPlaceIndexForPositionSummary

        public init(results: [SearchForPositionResult], summary: SearchPlaceIndexForPositionSummary) {
            self.results = results
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
            case summary = "Summary"
        }
    }

    public struct SearchPlaceIndexForPositionSummary: AWSDecodableShape {
        /// The data provider of geospatial data. Indicates one of the available providers:   Esri   HERE   For additional details on data providers, see the Amazon Location Service data providers page.
        public let dataSource: String
        /// An optional parameter. The maximum number of results returned per request.  Default value: 50
        public let maxResults: Int?
        /// The position given in the reverse geocoding request.
        public let position: [Double]

        public init(dataSource: String, maxResults: Int? = nil, position: [Double]) {
            self.dataSource = dataSource
            self.maxResults = maxResults
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case maxResults = "MaxResults"
            case position = "Position"
        }
    }

    public struct SearchPlaceIndexForTextRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri(locationName: "IndexName"))
        ]

        /// Searches for results closest to the given position. An optional parameter defined by longitude, and latitude.   The first bias position is the X coordinate, or longitude.   The second bias position is the Y coordinate, or latitude.    For example, bias=xLongitude&amp;bias=yLatitude.
        public let biasPosition: [Double]?
        /// Filters the results by returning only Places within the provided bounding box. An optional parameter. The first 2 bbox parameters describe the lower southwest corner:   The first bbox position is the X coordinate or longitude of the lower southwest corner.   The second bbox position is the Y coordinate or latitude of the lower southwest corner.   For example, bbox=xLongitudeSW&amp;bbox=yLatitudeSW. The next bbox parameters describe the upper northeast corner:   The third bbox position is the X coordinate, or longitude of the upper northeast corner.   The fourth bbox position is the Y coordinate, or longitude of the upper northeast corner.   For example, bbox=xLongitudeNE&amp;bbox=yLatitudeNE
        public let filterBBox: [Double]?
        /// Limits the search to the given a list of countries/regions. An optional parameter.   Use the ISO 3166 3-digit country code. For example, Australia uses three upper-case characters: AUS.
        public let filterCountries: [String]?
        /// The name of the place index resource you want to use for the search.
        public let indexName: String
        /// An optional parameter. The maximum number of results returned per request.  The default: 50
        public let maxResults: Int?
        /// The address, name, city, or region to be used in the search. In free-form text format. For example, 123 Any Street.
        public let text: String

        public init(biasPosition: [Double]? = nil, filterBBox: [Double]? = nil, filterCountries: [String]? = nil, indexName: String, maxResults: Int? = nil, text: String) {
            self.biasPosition = biasPosition
            self.filterBBox = filterBBox
            self.filterCountries = filterCountries
            self.indexName = indexName
            self.maxResults = maxResults
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, max: 2)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, min: 2)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, max: 4)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, min: 4)
            try self.filterCountries?.forEach {
                try validate($0, name: "filterCountries[]", parent: name, pattern: "^[A-Z]{3}$")
            }
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, max: 100)
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.text, name: "text", parent: name, max: 200)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case filterBBox = "FilterBBox"
            case filterCountries = "FilterCountries"
            case maxResults = "MaxResults"
            case text = "Text"
        }
    }

    public struct SearchPlaceIndexForTextResponse: AWSDecodableShape {
        /// A list of Places closest to the specified position. Each result contains additional information about the specific point of interest.
        public let results: [SearchForTextResult]
        /// Contains a summary of the request. Contains the BiasPosition, DataSource, FilterBBox, FilterCountries, MaxResults, ResultBBox, and Text.
        public let summary: SearchPlaceIndexForTextSummary

        public init(results: [SearchForTextResult], summary: SearchPlaceIndexForTextSummary) {
            self.results = results
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
            case summary = "Summary"
        }
    }

    public struct SearchPlaceIndexForTextSummary: AWSDecodableShape {
        /// Contains the coordinates for the bias position entered in the geocoding request.
        public let biasPosition: [Double]?
        /// The data provider of geospatial data. Indicates one of the available providers:   Esri   HERE   For additional details on data providers, see the Amazon Location Service data providers page.
        public let dataSource: String
        /// Contains the coordinates for the optional bounding box coordinated entered in the geocoding request.
        public let filterBBox: [Double]?
        /// Contains the country filter entered in the geocoding request.
        public let filterCountries: [String]?
        /// Contains the maximum number of results indicated for the request.
        public let maxResults: Int?
        /// A bounding box that contains the search results within the specified area indicated by FilterBBox. A subset of bounding box specified using FilterBBox.
        public let resultBBox: [Double]?
        /// The address, name, city or region to be used in the geocoding request. In free-form text format. For example, Vancouver.
        public let text: String

        public init(biasPosition: [Double]? = nil, dataSource: String, filterBBox: [Double]? = nil, filterCountries: [String]? = nil, maxResults: Int? = nil, resultBBox: [Double]? = nil, text: String) {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCountries = filterCountries
            self.maxResults = maxResults
            self.resultBBox = resultBBox
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case dataSource = "DataSource"
            case filterBBox = "FilterBBox"
            case filterCountries = "FilterCountries"
            case maxResults = "MaxResults"
            case resultBBox = "ResultBBox"
            case text = "Text"
        }
    }

    public struct Step: AWSDecodableShape {
        /// The travel distance between the step's StartPosition and EndPosition.
        public let distance: Double
        /// The estimated travel time, in seconds, from the step's StartPosition to the EndPosition. . The travel mode and departure time that you specify in the request determines the calculated time.
        public let durationSeconds: Double
        /// The end position of a step. If the position the last step in the leg, this position is the same as the end position of the leg.
        public let endPosition: [Double]
        /// Represents the start position, or index, in a sequence of steps within the leg's line string geometry. For example, the index of the first step in a leg geometry is 0.  Included in the response for queries that set IncludeLegGeometry to True.
        public let geometryOffset: Int?
        /// The starting position of a step. If the position is the first step in the leg, this position is the same as the start position of the leg.
        public let startPosition: [Double]

        public init(distance: Double, durationSeconds: Double, endPosition: [Double], geometryOffset: Int? = nil, startPosition: [Double]) {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometryOffset = geometryOffset
            self.startPosition = startPosition
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case durationSeconds = "DurationSeconds"
            case endPosition = "EndPosition"
            case geometryOffset = "GeometryOffset"
            case startPosition = "StartPosition"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource whose tags you want to update.   Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
        public let resourceArn: String
        /// Tags that have been applied to the specified resource. Tags are mapped from the tag key to the tag value: "TagKey" : "TagValue".   Format example: {"tag1" : "value1", "tag2" : "value2"}
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 0)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TruckDimensions: AWSEncodableShape {
        /// The height of the truck.   For example, 4.5.
        public let height: Double?
        /// The length of the truck.   For example, 15.5.
        public let length: Double?
        ///  Specifies the unit of measurement for the truck dimensions. Default Value: Meters
        public let unit: DimensionUnit?
        /// The width of the truck.   For example, 4.5.
        public let width: Double?

        public init(height: Double? = nil, length: Double? = nil, unit: DimensionUnit? = nil, width: Double? = nil) {
            self.height = height
            self.length = length
            self.unit = unit
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.height, name: "height", parent: name, min: 0)
            try self.validate(self.length, name: "length", parent: name, min: 0)
            try self.validate(self.width, name: "width", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case height = "Height"
            case length = "Length"
            case unit = "Unit"
            case width = "Width"
        }
    }

    public struct TruckWeight: AWSEncodableShape {
        /// The total weight of the truck.    For example, 3500.
        public let total: Double?
        /// The unit of measurement to use for the truck weight. Default Value: Kilograms
        public let unit: VehicleWeightUnit?

        public init(total: Double? = nil, unit: VehicleWeightUnit? = nil) {
            self.total = total
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.total, name: "total", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case total = "Total"
            case unit = "Unit"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource from which you want to remove tags.   Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
        public let resourceArn: String
        /// The list of tag keys to remove from the specified resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 0)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGeofenceCollectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The name of the geofence collection to update.
        public let collectionName: String
        /// Updates the description for the geofence collection.
        public let description: String?
        /// Updates the pricing plan for the geofence collection. For more information about each pricing plan option restrictions, see Amazon Location Service pricing.
        public let pricingPlan: PricingPlan?
        /// Updates the data provider for the geofence collection.  A required value for the following pricing plans: MobileAssetTracking| MobileAssetManagement  For more information about data providers and pricing plans, see the Amazon Location Service product page.  This can only be updated when updating the PricingPlan in the same request. Amazon Location Service uses PricingPlanDataSource to calculate billing for your geofence collection. Your data won't be shared with the data provider, and will remain in your AWS account and Region unless you move it.
        public let pricingPlanDataSource: String?

        public init(collectionName: String, description: String? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil) {
            self.collectionName = collectionName
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
        }
    }

    public struct UpdateGeofenceCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated geofence collection. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
        public let collectionArn: String
        /// The name of the updated geofence collection.
        public let collectionName: String
        /// The time when the geofence collection was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(collectionArn: String, collectionName: String, updateTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case collectionName = "CollectionName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdateMapRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName"))
        ]

        /// Updates the description for the map resource.
        public let description: String?
        /// The name of the map resource to update.
        public let mapName: String
        /// Updates the pricing plan for the map resource. For more information about each pricing plan option restrictions, see Amazon Location Service pricing.
        public let pricingPlan: PricingPlan?

        public init(description: String? = nil, mapName: String, pricingPlan: PricingPlan? = nil) {
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct UpdateMapResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated map resource. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:maps/ExampleMap
        public let mapArn: String
        /// The name of the updated map resource.
        public let mapName: String
        /// The timestamp for when the map resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(mapArn: String, mapName: String, updateTime: Date) {
            self.mapArn = mapArn
            self.mapName = mapName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case mapArn = "MapArn"
            case mapName = "MapName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdatePlaceIndexRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri(locationName: "IndexName"))
        ]

        /// Updates the data storage option for the place index resource.
        public let dataSourceConfiguration: DataSourceConfiguration?
        /// Updates the description for the place index resource.
        public let description: String?
        /// The name of the place index resource to update.
        public let indexName: String
        /// Updates the pricing plan for the place index resource. For more information about each pricing plan option restrictions, see Amazon Location Service pricing.
        public let pricingPlan: PricingPlan?

        public init(dataSourceConfiguration: DataSourceConfiguration? = nil, description: String? = nil, indexName: String, pricingPlan: PricingPlan? = nil) {
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceConfiguration = "DataSourceConfiguration"
            case description = "Description"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct UpdatePlaceIndexResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the upated place index resource. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:place- index/ExamplePlaceIndex
        public let indexArn: String
        /// The name of the updated place index resource.
        public let indexName: String
        /// The timestamp for when the place index resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(indexArn: String, indexName: String, updateTime: Date) {
            self.indexArn = indexArn
            self.indexName = indexName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case indexArn = "IndexArn"
            case indexName = "IndexName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdateRouteCalculatorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "calculatorName", location: .uri(locationName: "CalculatorName"))
        ]

        /// The name of the route calculator resource to update.
        public let calculatorName: String
        /// Updates the description for the route calculator resource.
        public let description: String?
        /// Updates the pricing plan for the route calculator resource. For more information about each pricing plan option restrictions, see Amazon Location Service pricing.
        public let pricingPlan: PricingPlan?

        public init(calculatorName: String, description: String? = nil, pricingPlan: PricingPlan? = nil) {
            self.calculatorName = calculatorName
            self.description = description
            self.pricingPlan = pricingPlan
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct UpdateRouteCalculatorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated route calculator resource. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:route- calculator/ExampleCalculator
        public let calculatorArn: String
        /// The name of the updated route calculator resource.
        public let calculatorName: String
        /// The timestamp for when the route calculator was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(calculatorArn: String, calculatorName: String, updateTime: Date) {
            self.calculatorArn = calculatorArn
            self.calculatorName = calculatorName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorArn = "CalculatorArn"
            case calculatorName = "CalculatorName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdateTrackerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// Updates the description for the tracker resource.
        public let description: String?
        /// Updates the pricing plan for the tracker resource. For more information about each pricing plan option restrictions, see Amazon Location Service pricing.
        public let pricingPlan: PricingPlan?
        /// Updates the data provider for the tracker resource.  A required value for the following pricing plans: MobileAssetTracking| MobileAssetManagement  For more information about data providers and pricing plans, see the Amazon Location Service product page  This can only be updated when updating the PricingPlan in the same request. Amazon Location Service uses PricingPlanDataSource to calculate billing for your tracker resource. Your data won't be shared with the data provider, and will remain in your AWS account and Region unless you move it.
        public let pricingPlanDataSource: String?
        /// The name of the tracker resource to update.
        public let trackerName: String

        public init(description: String? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, trackerName: String) {
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
        }
    }

    public struct UpdateTrackerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated tracker resource. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
        public let trackerArn: String
        /// The name of the updated tracker resource.
        public let trackerName: String
        /// The timestamp for when the tracker resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(trackerArn: String, trackerName: String, updateTime: Date) {
            self.trackerArn = trackerArn
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case trackerArn = "TrackerArn"
            case trackerName = "TrackerName"
            case updateTime = "UpdateTime"
        }
    }
}
