//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension LookoutMetrics {
    // MARK: Enums

    public enum AggregationFunction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avg = "AVG"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum AlertStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum AlertType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lambda = "LAMBDA"
        case sns = "SNS"
        public var description: String { return self.rawValue }
    }

    public enum AnomalyDetectionTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case failedToSchedule = "FAILED_TO_SCHEDULE"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum AnomalyDetectorFailureType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activationFailure = "ACTIVATION_FAILURE"
        case backTestActivationFailure = "BACK_TEST_ACTIVATION_FAILURE"
        case deactivationFailure = "DEACTIVATION_FAILURE"
        case deletionFailure = "DELETION_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum AnomalyDetectorStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case backTestActivating = "BACK_TEST_ACTIVATING"
        case backTestActive = "BACK_TEST_ACTIVE"
        case backTestComplete = "BACK_TEST_COMPLETE"
        case deactivated = "DEACTIVATED"
        case deactivating = "DEACTIVATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case inactive = "INACTIVE"
        case learning = "LEARNING"
        public var description: String { return self.rawValue }
    }

    public enum CSVFileCompression: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum Confidence: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum DataQualityMetricType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case backtestInferenceDataEndTimeStamp = "BACKTEST_INFERENCE_DATA_END_TIME_STAMP"
        case backtestInferenceDataStartTimeStamp = "BACKTEST_INFERENCE_DATA_START_TIME_STAMP"
        case backtestTrainingDataEndTimeStamp = "BACKTEST_TRAINING_DATA_END_TIME_STAMP"
        case backtestTrainingDataStartTimeStamp = "BACKTEST_TRAINING_DATA_START_TIME_STAMP"
        case columnCompleteness = "COLUMN_COMPLETENESS"
        case dimensionUniqueness = "DIMENSION_UNIQUENESS"
        case invalidRowsCompliance = "INVALID_ROWS_COMPLIANCE"
        case rowsPartialCompliance = "ROWS_PARTIAL_COMPLIANCE"
        case rowsProcessed = "ROWS_PROCESSED"
        case timeSeriesCount = "TIME_SERIES_COUNT"
        public var description: String { return self.rawValue }
    }

    public enum FilterOperation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum Frequency: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case p1d = "P1D"
        case pt10m = "PT10M"
        case pt1h = "PT1H"
        case pt5m = "PT5M"
        public var description: String { return self.rawValue }
    }

    public enum JsonFileCompression: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum RelationshipType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case causeOfInputAnomalyGroup = "CAUSE_OF_INPUT_ANOMALY_GROUP"
        case effectOfInputAnomalyGroup = "EFFECT_OF_INPUT_ANOMALY_GROUP"
        public var description: String { return self.rawValue }
    }

    public enum SnsFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case longText = "LONG_TEXT"
        case shortText = "SHORT_TEXT"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CANNOT_PARSE"
        case fieldValidationFailed = "FIELD_VALIDATION_FAILED"
        case other = "OTHER"
        case unknownOperation = "UNKNOWN_OPERATION"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// A configuration for an AWS Lambda channel.
        public let lambdaConfiguration: LambdaConfiguration?
        /// A configuration for an Amazon SNS channel.
        public let snsConfiguration: SNSConfiguration?

        @inlinable
        public init(lambdaConfiguration: LambdaConfiguration? = nil, snsConfiguration: SNSConfiguration? = nil) {
            self.lambdaConfiguration = lambdaConfiguration
            self.snsConfiguration = snsConfiguration
        }

        public func validate(name: String) throws {
            try self.lambdaConfiguration?.validate(name: "\(name).lambdaConfiguration")
            try self.snsConfiguration?.validate(name: "\(name).snsConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaConfiguration = "LambdaConfiguration"
            case snsConfiguration = "SNSConfiguration"
        }
    }

    public struct ActivateAnomalyDetectorRequest: AWSEncodableShape {
        /// The ARN of the anomaly detector.
        public let anomalyDetectorArn: String

        @inlinable
        public init(anomalyDetectorArn: String) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct ActivateAnomalyDetectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Alert: AWSDecodableShape {
        /// Action that will be triggered when there is an alert.
        public let action: Action?
        /// The ARN of the alert.
        public let alertArn: String?
        /// A description of the alert.
        public let alertDescription: String?
        /// The configuration of the alert filters, containing MetricList and DimensionFilter.
        public let alertFilters: AlertFilters?
        /// The name of the alert.
        public let alertName: String?
        /// The minimum severity for an anomaly to trigger the alert.
        public let alertSensitivityThreshold: Int?
        /// The status of the alert.
        public let alertStatus: AlertStatus?
        /// The type of the alert.
        public let alertType: AlertType?
        /// The ARN of the detector to which the alert is attached.
        public let anomalyDetectorArn: String?
        /// The time at which the alert was created.
        public let creationTime: Date?
        /// The time at which the alert was last modified.
        public let lastModificationTime: Date?

        @inlinable
        public init(action: Action? = nil, alertArn: String? = nil, alertDescription: String? = nil, alertFilters: AlertFilters? = nil, alertName: String? = nil, alertSensitivityThreshold: Int? = nil, alertStatus: AlertStatus? = nil, alertType: AlertType? = nil, anomalyDetectorArn: String? = nil, creationTime: Date? = nil, lastModificationTime: Date? = nil) {
            self.action = action
            self.alertArn = alertArn
            self.alertDescription = alertDescription
            self.alertFilters = alertFilters
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.alertStatus = alertStatus
            self.alertType = alertType
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case alertArn = "AlertArn"
            case alertDescription = "AlertDescription"
            case alertFilters = "AlertFilters"
            case alertName = "AlertName"
            case alertSensitivityThreshold = "AlertSensitivityThreshold"
            case alertStatus = "AlertStatus"
            case alertType = "AlertType"
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case creationTime = "CreationTime"
            case lastModificationTime = "LastModificationTime"
        }
    }

    public struct AlertFilters: AWSEncodableShape & AWSDecodableShape {
        /// The list of DimensionFilter objects that are used for dimension-based filtering.
        public let dimensionFilterList: [DimensionFilter]?
        /// The list of measures that you want to get alerts for.
        public let metricList: [String]?

        @inlinable
        public init(dimensionFilterList: [DimensionFilter]? = nil, metricList: [String]? = nil) {
            self.dimensionFilterList = dimensionFilterList
            self.metricList = metricList
        }

        public func validate(name: String) throws {
            try self.dimensionFilterList?.forEach {
                try $0.validate(name: "\(name).dimensionFilterList[]")
            }
            try self.validate(self.dimensionFilterList, name: "dimensionFilterList", parent: name, max: 5)
            try self.validate(self.dimensionFilterList, name: "dimensionFilterList", parent: name, min: 1)
            try self.metricList?.forEach {
                try validate($0, name: "metricList[]", parent: name, max: 256)
                try validate($0, name: "metricList[]", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            }
            try self.validate(self.metricList, name: "metricList", parent: name, max: 5)
            try self.validate(self.metricList, name: "metricList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionFilterList = "DimensionFilterList"
            case metricList = "MetricList"
        }
    }

    public struct AlertSummary: AWSDecodableShape {
        /// The ARN of the alert.
        public let alertArn: String?
        /// The name of the alert.
        public let alertName: String?
        /// The minimum severity for an anomaly to trigger the alert.
        public let alertSensitivityThreshold: Int?
        /// The status of the alert.
        public let alertStatus: AlertStatus?
        /// The type of the alert.
        public let alertType: AlertType?
        /// The ARN of the detector to which the alert is attached.
        public let anomalyDetectorArn: String?
        /// The time at which the alert was created.
        public let creationTime: Date?
        /// The time at which the alert was last modified.
        public let lastModificationTime: Date?
        /// The alert's tags.
        public let tags: [String: String]?

        @inlinable
        public init(alertArn: String? = nil, alertName: String? = nil, alertSensitivityThreshold: Int? = nil, alertStatus: AlertStatus? = nil, alertType: AlertType? = nil, anomalyDetectorArn: String? = nil, creationTime: Date? = nil, lastModificationTime: Date? = nil, tags: [String: String]? = nil) {
            self.alertArn = alertArn
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.alertStatus = alertStatus
            self.alertType = alertType
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case alertArn = "AlertArn"
            case alertName = "AlertName"
            case alertSensitivityThreshold = "AlertSensitivityThreshold"
            case alertStatus = "AlertStatus"
            case alertType = "AlertType"
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case creationTime = "CreationTime"
            case lastModificationTime = "LastModificationTime"
            case tags = "Tags"
        }
    }

    public struct AnomalyDetectorConfig: AWSEncodableShape {
        /// The frequency at which the detector analyzes its source data.
        public let anomalyDetectorFrequency: Frequency?

        @inlinable
        public init(anomalyDetectorFrequency: Frequency? = nil) {
            self.anomalyDetectorFrequency = anomalyDetectorFrequency
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorFrequency = "AnomalyDetectorFrequency"
        }
    }

    public struct AnomalyDetectorConfigSummary: AWSDecodableShape {
        /// The interval at which the detector analyzes its source data.
        public let anomalyDetectorFrequency: Frequency?

        @inlinable
        public init(anomalyDetectorFrequency: Frequency? = nil) {
            self.anomalyDetectorFrequency = anomalyDetectorFrequency
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorFrequency = "AnomalyDetectorFrequency"
        }
    }

    public struct AnomalyDetectorDataQualityMetric: AWSDecodableShape {
        /// An array of DataQualityMetricList objects. Each object in the array contains information about a data quality metric.
        public let metricSetDataQualityMetricList: [MetricSetDataQualityMetric]?
        /// The start time for the data quality metrics collection.
        public let startTimestamp: Date?

        @inlinable
        public init(metricSetDataQualityMetricList: [MetricSetDataQualityMetric]? = nil, startTimestamp: Date? = nil) {
            self.metricSetDataQualityMetricList = metricSetDataQualityMetricList
            self.startTimestamp = startTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case metricSetDataQualityMetricList = "MetricSetDataQualityMetricList"
            case startTimestamp = "StartTimestamp"
        }
    }

    public struct AnomalyDetectorSummary: AWSDecodableShape {
        /// The ARN of the detector.
        public let anomalyDetectorArn: String?
        /// A description of the detector.
        public let anomalyDetectorDescription: String?
        /// The name of the detector.
        public let anomalyDetectorName: String?
        /// The time at which the detector was created.
        public let creationTime: Date?
        /// The time at which the detector was last modified.
        public let lastModificationTime: Date?
        /// The status of detector.
        public let status: AnomalyDetectorStatus?
        /// The detector's tags.
        public let tags: [String: String]?

        @inlinable
        public init(anomalyDetectorArn: String? = nil, anomalyDetectorDescription: String? = nil, anomalyDetectorName: String? = nil, creationTime: Date? = nil, lastModificationTime: Date? = nil, status: AnomalyDetectorStatus? = nil, tags: [String: String]? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyDetectorDescription = anomalyDetectorDescription
            self.anomalyDetectorName = anomalyDetectorName
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyDetectorDescription = "AnomalyDetectorDescription"
            case anomalyDetectorName = "AnomalyDetectorName"
            case creationTime = "CreationTime"
            case lastModificationTime = "LastModificationTime"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct AnomalyGroup: AWSDecodableShape {
        /// The ID of the anomaly group.
        public let anomalyGroupId: String?
        /// The severity score of the group.
        public let anomalyGroupScore: Double?
        /// The end time for the group.
        public let endTime: String?
        /// A list of measures affected by the anomaly.
        public let metricLevelImpactList: [MetricLevelImpact]?
        /// The name of the primary affected measure for the group.
        public let primaryMetricName: String?
        /// The start time for the group.
        public let startTime: String?

        @inlinable
        public init(anomalyGroupId: String? = nil, anomalyGroupScore: Double? = nil, endTime: String? = nil, metricLevelImpactList: [MetricLevelImpact]? = nil, primaryMetricName: String? = nil, startTime: String? = nil) {
            self.anomalyGroupId = anomalyGroupId
            self.anomalyGroupScore = anomalyGroupScore
            self.endTime = endTime
            self.metricLevelImpactList = metricLevelImpactList
            self.primaryMetricName = primaryMetricName
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupId = "AnomalyGroupId"
            case anomalyGroupScore = "AnomalyGroupScore"
            case endTime = "EndTime"
            case metricLevelImpactList = "MetricLevelImpactList"
            case primaryMetricName = "PrimaryMetricName"
            case startTime = "StartTime"
        }
    }

    public struct AnomalyGroupStatistics: AWSDecodableShape {
        /// The start of the time range that was searched.
        public let evaluationStartDate: String?
        /// Statistics for individual metrics within the group.
        public let itemizedMetricStatsList: [ItemizedMetricStats]?
        /// The number of groups found.
        public let totalCount: Int?

        @inlinable
        public init(evaluationStartDate: String? = nil, itemizedMetricStatsList: [ItemizedMetricStats]? = nil, totalCount: Int? = nil) {
            self.evaluationStartDate = evaluationStartDate
            self.itemizedMetricStatsList = itemizedMetricStatsList
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationStartDate = "EvaluationStartDate"
            case itemizedMetricStatsList = "ItemizedMetricStatsList"
            case totalCount = "TotalCount"
        }
    }

    public struct AnomalyGroupSummary: AWSDecodableShape {
        /// The ID of the anomaly group.
        public let anomalyGroupId: String?
        /// The severity score of the group.
        public let anomalyGroupScore: Double?
        /// The end time for the group.
        public let endTime: String?
        /// The name of the primary affected measure for the group.
        public let primaryMetricName: String?
        /// The start time for the group.
        public let startTime: String?

        @inlinable
        public init(anomalyGroupId: String? = nil, anomalyGroupScore: Double? = nil, endTime: String? = nil, primaryMetricName: String? = nil, startTime: String? = nil) {
            self.anomalyGroupId = anomalyGroupId
            self.anomalyGroupScore = anomalyGroupScore
            self.endTime = endTime
            self.primaryMetricName = primaryMetricName
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupId = "AnomalyGroupId"
            case anomalyGroupScore = "AnomalyGroupScore"
            case endTime = "EndTime"
            case primaryMetricName = "PrimaryMetricName"
            case startTime = "StartTime"
        }
    }

    public struct AnomalyGroupTimeSeries: AWSEncodableShape {
        /// The ID of the anomaly group.
        public let anomalyGroupId: String
        /// The ID of the metric.
        public let timeSeriesId: String?

        @inlinable
        public init(anomalyGroupId: String, timeSeriesId: String? = nil) {
            self.anomalyGroupId = anomalyGroupId
            self.timeSeriesId = timeSeriesId
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, max: 63)
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, pattern: "^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$")
            try self.validate(self.timeSeriesId, name: "timeSeriesId", parent: name, max: 520)
            try self.validate(self.timeSeriesId, name: "timeSeriesId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupId = "AnomalyGroupId"
            case timeSeriesId = "TimeSeriesId"
        }
    }

    public struct AnomalyGroupTimeSeriesFeedback: AWSEncodableShape {
        /// The ID of the anomaly group.
        public let anomalyGroupId: String
        /// Feedback on whether the metric is a legitimate anomaly.
        public let isAnomaly: Bool
        /// The ID of the metric.
        public let timeSeriesId: String

        @inlinable
        public init(anomalyGroupId: String, isAnomaly: Bool, timeSeriesId: String) {
            self.anomalyGroupId = anomalyGroupId
            self.isAnomaly = isAnomaly
            self.timeSeriesId = timeSeriesId
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, max: 63)
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, pattern: "^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$")
            try self.validate(self.timeSeriesId, name: "timeSeriesId", parent: name, max: 520)
            try self.validate(self.timeSeriesId, name: "timeSeriesId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupId = "AnomalyGroupId"
            case isAnomaly = "IsAnomaly"
            case timeSeriesId = "TimeSeriesId"
        }
    }

    public struct AppFlowConfig: AWSEncodableShape & AWSDecodableShape {
        ///  name of the flow.
        public let flowName: String?
        /// An IAM role that gives Amazon Lookout for Metrics permission to access the flow.
        public let roleArn: String?

        @inlinable
        public init(flowName: String? = nil, roleArn: String? = nil) {
            self.flowName = flowName
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName = "FlowName"
            case roleArn = "RoleArn"
        }
    }

    public struct AthenaSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// Settings for backtest mode.
        public let backTestConfiguration: BackTestConfiguration?
        /// The database's name.
        public let databaseName: String?
        /// The database's data catalog.
        public let dataCatalog: String?
        /// An IAM role that gives Amazon Lookout for Metrics permission to access the data.
        public let roleArn: String?
        /// The database's results path.
        public let s3ResultsPath: String?
        /// The database's table name.
        public let tableName: String?
        /// The database's work group name.
        public let workGroupName: String?

        @inlinable
        public init(backTestConfiguration: BackTestConfiguration? = nil, databaseName: String? = nil, dataCatalog: String? = nil, roleArn: String? = nil, s3ResultsPath: String? = nil, tableName: String? = nil, workGroupName: String? = nil) {
            self.backTestConfiguration = backTestConfiguration
            self.databaseName = databaseName
            self.dataCatalog = dataCatalog
            self.roleArn = roleArn
            self.s3ResultsPath = s3ResultsPath
            self.tableName = tableName
            self.workGroupName = workGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_]+$")
            try self.validate(self.dataCatalog, name: "dataCatalog", parent: name, max: 256)
            try self.validate(self.dataCatalog, name: "dataCatalog", parent: name, min: 1)
            try self.validate(self.dataCatalog, name: "dataCatalog", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.s3ResultsPath, name: "s3ResultsPath", parent: name, max: 1024)
            try self.validate(self.s3ResultsPath, name: "s3ResultsPath", parent: name, pattern: "^s3://[a-z0-9].+$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 128)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z0-9_]+$")
            try self.validate(self.workGroupName, name: "workGroupName", parent: name, max: 128)
            try self.validate(self.workGroupName, name: "workGroupName", parent: name, min: 1)
            try self.validate(self.workGroupName, name: "workGroupName", parent: name, pattern: "^[a-zA-Z0-9._-]{1,128}$")
        }

        private enum CodingKeys: String, CodingKey {
            case backTestConfiguration = "BackTestConfiguration"
            case databaseName = "DatabaseName"
            case dataCatalog = "DataCatalog"
            case roleArn = "RoleArn"
            case s3ResultsPath = "S3ResultsPath"
            case tableName = "TableName"
            case workGroupName = "WorkGroupName"
        }
    }

    public struct AttributeValue: AWSDecodableShape {
        /// A binary value.
        public let b: String?
        /// A list of binary values.
        public let bs: [String]?
        /// A number.
        public let n: String?
        /// A list of numbers.
        public let ns: [String]?
        /// A string.
        public let s: String?
        /// A list of strings.
        public let ss: [String]?

        @inlinable
        public init(b: String? = nil, bs: [String]? = nil, n: String? = nil, ns: [String]? = nil, s: String? = nil, ss: [String]? = nil) {
            self.b = b
            self.bs = bs
            self.n = n
            self.ns = ns
            self.s = s
            self.ss = ss
        }

        private enum CodingKeys: String, CodingKey {
            case b = "B"
            case bs = "BS"
            case n = "N"
            case ns = "NS"
            case s = "S"
            case ss = "SS"
        }
    }

    public struct AutoDetectionMetricSource: AWSEncodableShape {
        /// The source's source config.
        public let s3SourceConfig: AutoDetectionS3SourceConfig?

        @inlinable
        public init(s3SourceConfig: AutoDetectionS3SourceConfig? = nil) {
            self.s3SourceConfig = s3SourceConfig
        }

        public func validate(name: String) throws {
            try self.s3SourceConfig?.validate(name: "\(name).s3SourceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case s3SourceConfig = "S3SourceConfig"
        }
    }

    public struct AutoDetectionS3SourceConfig: AWSEncodableShape {
        /// The config's historical data path list.
        public let historicalDataPathList: [String]?
        /// The config's templated path list.
        public let templatedPathList: [String]?

        @inlinable
        public init(historicalDataPathList: [String]? = nil, templatedPathList: [String]? = nil) {
            self.historicalDataPathList = historicalDataPathList
            self.templatedPathList = templatedPathList
        }

        public func validate(name: String) throws {
            try self.historicalDataPathList?.forEach {
                try validate($0, name: "historicalDataPathList[]", parent: name, max: 1024)
                try validate($0, name: "historicalDataPathList[]", parent: name, pattern: "^s3://[a-z0-9].+$")
            }
            try self.validate(self.historicalDataPathList, name: "historicalDataPathList", parent: name, max: 1)
            try self.validate(self.historicalDataPathList, name: "historicalDataPathList", parent: name, min: 1)
            try self.templatedPathList?.forEach {
                try validate($0, name: "templatedPathList[]", parent: name, max: 1024)
                try validate($0, name: "templatedPathList[]", parent: name, pattern: "^s3://[a-zA-Z0-9_\\-\\/ {}=]+$")
            }
            try self.validate(self.templatedPathList, name: "templatedPathList", parent: name, max: 1)
            try self.validate(self.templatedPathList, name: "templatedPathList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case historicalDataPathList = "HistoricalDataPathList"
            case templatedPathList = "TemplatedPathList"
        }
    }

    public struct BackTestAnomalyDetectorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String

        @inlinable
        public init(anomalyDetectorArn: String) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct BackTestAnomalyDetectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct BackTestConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Run a backtest instead of monitoring new data.
        public let runBackTestMode: Bool

        @inlinable
        public init(runBackTestMode: Bool) {
            self.runBackTestMode = runBackTestMode
        }

        private enum CodingKeys: String, CodingKey {
            case runBackTestMode = "RunBackTestMode"
        }
    }

    public struct CloudWatchConfig: AWSEncodableShape & AWSDecodableShape {
        /// Settings for backtest mode.
        public let backTestConfiguration: BackTestConfiguration?
        /// An IAM role that gives Amazon Lookout for Metrics permission to access data in Amazon CloudWatch.
        public let roleArn: String?

        @inlinable
        public init(backTestConfiguration: BackTestConfiguration? = nil, roleArn: String? = nil) {
            self.backTestConfiguration = backTestConfiguration
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case backTestConfiguration = "BackTestConfiguration"
            case roleArn = "RoleArn"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The ID of the resource.
        public let resourceId: String?
        /// The type of the resource.
        public let resourceType: String?

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ContributionMatrix: AWSDecodableShape {
        /// A list of contributing dimensions.
        public let dimensionContributionList: [DimensionContribution]?

        @inlinable
        public init(dimensionContributionList: [DimensionContribution]? = nil) {
            self.dimensionContributionList = dimensionContributionList
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionContributionList = "DimensionContributionList"
        }
    }

    public struct CreateAlertRequest: AWSEncodableShape {
        /// Action that will be triggered when there is an alert.
        public let action: Action
        /// A description of the alert.
        public let alertDescription: String?
        /// The configuration of the alert filters, containing MetricList and DimensionFilterList.
        public let alertFilters: AlertFilters?
        /// The name of the alert.
        public let alertName: String
        /// An integer from 0 to 100 specifying the alert sensitivity threshold.
        public let alertSensitivityThreshold: Int?
        /// The ARN of the detector to which the alert is attached.
        public let anomalyDetectorArn: String
        /// A list of tags to apply to the alert.
        public let tags: [String: String]?

        @inlinable
        public init(action: Action, alertDescription: String? = nil, alertFilters: AlertFilters? = nil, alertName: String, alertSensitivityThreshold: Int? = nil, anomalyDetectorArn: String, tags: [String: String]? = nil) {
            self.action = action
            self.alertDescription = alertDescription
            self.alertFilters = alertFilters
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.anomalyDetectorArn = anomalyDetectorArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.validate(self.alertDescription, name: "alertDescription", parent: name, max: 256)
            try self.validate(self.alertDescription, name: "alertDescription", parent: name, pattern: "\\S")
            try self.alertFilters?.validate(name: "\(name).alertFilters")
            try self.validate(self.alertName, name: "alertName", parent: name, max: 63)
            try self.validate(self.alertName, name: "alertName", parent: name, min: 1)
            try self.validate(self.alertName, name: "alertName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.alertSensitivityThreshold, name: "alertSensitivityThreshold", parent: name, max: 100)
            try self.validate(self.alertSensitivityThreshold, name: "alertSensitivityThreshold", parent: name, min: 0)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case alertDescription = "AlertDescription"
            case alertFilters = "AlertFilters"
            case alertName = "AlertName"
            case alertSensitivityThreshold = "AlertSensitivityThreshold"
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case tags = "Tags"
        }
    }

    public struct CreateAlertResponse: AWSDecodableShape {
        /// The ARN of the alert.
        public let alertArn: String?

        @inlinable
        public init(alertArn: String? = nil) {
            self.alertArn = alertArn
        }

        private enum CodingKeys: String, CodingKey {
            case alertArn = "AlertArn"
        }
    }

    public struct CreateAnomalyDetectorRequest: AWSEncodableShape {
        /// Contains information about the configuration of the anomaly detector.
        public let anomalyDetectorConfig: AnomalyDetectorConfig
        /// A description of the detector.
        public let anomalyDetectorDescription: String?
        /// The name of the detector.
        public let anomalyDetectorName: String
        /// The ARN of the KMS key to use to encrypt your data.
        public let kmsKeyArn: String?
        /// A list of tags to apply to the anomaly detector.
        public let tags: [String: String]?

        @inlinable
        public init(anomalyDetectorConfig: AnomalyDetectorConfig, anomalyDetectorDescription: String? = nil, anomalyDetectorName: String, kmsKeyArn: String? = nil, tags: [String: String]? = nil) {
            self.anomalyDetectorConfig = anomalyDetectorConfig
            self.anomalyDetectorDescription = anomalyDetectorDescription
            self.anomalyDetectorName = anomalyDetectorName
            self.kmsKeyArn = kmsKeyArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, max: 256)
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, min: 1)
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, pattern: "\\S")
            try self.validate(self.anomalyDetectorName, name: "anomalyDetectorName", parent: name, max: 63)
            try self.validate(self.anomalyDetectorName, name: "anomalyDetectorName", parent: name, min: 1)
            try self.validate(self.anomalyDetectorName, name: "anomalyDetectorName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws.*:kms:.*:[0-9]{12}:key/[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorConfig = "AnomalyDetectorConfig"
            case anomalyDetectorDescription = "AnomalyDetectorDescription"
            case anomalyDetectorName = "AnomalyDetectorName"
            case kmsKeyArn = "KmsKeyArn"
            case tags = "Tags"
        }
    }

    public struct CreateAnomalyDetectorResponse: AWSDecodableShape {
        /// The ARN of the detector.
        public let anomalyDetectorArn: String?

        @inlinable
        public init(anomalyDetectorArn: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct CreateMetricSetRequest: AWSEncodableShape {
        /// The ARN of the anomaly detector that will use the dataset.
        public let anomalyDetectorArn: String
        /// A list of filters that specify which data is kept for anomaly detection.
        public let dimensionFilterList: [MetricSetDimensionFilter]?
        /// A list of the fields you want to treat as dimensions.
        public let dimensionList: [String]?
        /// A list of metrics that the dataset will contain.
        public let metricList: [Metric]
        /// A description of the dataset you are creating.
        public let metricSetDescription: String?
        /// The frequency with which the source data will be analyzed for anomalies.
        public let metricSetFrequency: Frequency?
        /// The name of the dataset.
        public let metricSetName: String
        /// Contains information about how the source data should be interpreted.
        public let metricSource: MetricSource
        /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3, Redshift, Athena and datasources.
        public let offset: Int?
        /// A list of tags to apply to the dataset.
        public let tags: [String: String]?
        /// Contains information about the column used for tracking time in your source data.
        public let timestampColumn: TimestampColumn?
        /// The time zone in which your source data was recorded.
        public let timezone: String?

        @inlinable
        public init(anomalyDetectorArn: String, dimensionFilterList: [MetricSetDimensionFilter]? = nil, dimensionList: [String]? = nil, metricList: [Metric], metricSetDescription: String? = nil, metricSetFrequency: Frequency? = nil, metricSetName: String, metricSource: MetricSource, offset: Int? = nil, tags: [String: String]? = nil, timestampColumn: TimestampColumn? = nil, timezone: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.dimensionFilterList = dimensionFilterList
            self.dimensionList = dimensionList
            self.metricList = metricList
            self.metricSetDescription = metricSetDescription
            self.metricSetFrequency = metricSetFrequency
            self.metricSetName = metricSetName
            self.metricSource = metricSource
            self.offset = offset
            self.tags = tags
            self.timestampColumn = timestampColumn
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.dimensionFilterList?.forEach {
                try $0.validate(name: "\(name).dimensionFilterList[]")
            }
            try self.dimensionList?.forEach {
                try validate($0, name: "dimensionList[]", parent: name, max: 63)
                try validate($0, name: "dimensionList[]", parent: name, min: 1)
                try validate($0, name: "dimensionList[]", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            }
            try self.validate(self.dimensionList, name: "dimensionList", parent: name, min: 1)
            try self.metricList.forEach {
                try $0.validate(name: "\(name).metricList[]")
            }
            try self.validate(self.metricList, name: "metricList", parent: name, min: 1)
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, max: 256)
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, min: 1)
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, pattern: "\\S")
            try self.validate(self.metricSetName, name: "metricSetName", parent: name, max: 63)
            try self.validate(self.metricSetName, name: "metricSetName", parent: name, min: 1)
            try self.validate(self.metricSetName, name: "metricSetName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.metricSource.validate(name: "\(name).metricSource")
            try self.validate(self.offset, name: "offset", parent: name, max: 432000)
            try self.validate(self.offset, name: "offset", parent: name, min: 0)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.timestampColumn?.validate(name: "\(name).timestampColumn")
            try self.validate(self.timezone, name: "timezone", parent: name, max: 60)
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case dimensionFilterList = "DimensionFilterList"
            case dimensionList = "DimensionList"
            case metricList = "MetricList"
            case metricSetDescription = "MetricSetDescription"
            case metricSetFrequency = "MetricSetFrequency"
            case metricSetName = "MetricSetName"
            case metricSource = "MetricSource"
            case offset = "Offset"
            case tags = "Tags"
            case timestampColumn = "TimestampColumn"
            case timezone = "Timezone"
        }
    }

    public struct CreateMetricSetResponse: AWSDecodableShape {
        /// The ARN of the dataset.
        public let metricSetArn: String?

        @inlinable
        public init(metricSetArn: String? = nil) {
            self.metricSetArn = metricSetArn
        }

        private enum CodingKeys: String, CodingKey {
            case metricSetArn = "MetricSetArn"
        }
    }

    public struct CsvFormatDescriptor: AWSEncodableShape & AWSDecodableShape {
        /// The character set in which the source CSV file is written.
        public let charset: String?
        /// Whether or not the source CSV file contains a header.
        public let containsHeader: Bool?
        /// The character used to delimit the source CSV file.
        public let delimiter: String?
        /// The level of compression of the source CSV file.
        public let fileCompression: CSVFileCompression?
        /// A list of the source CSV file's headers, if any.
        public let headerList: [String]?
        /// The character used as a quote character.
        public let quoteSymbol: String?

        @inlinable
        public init(charset: String? = nil, containsHeader: Bool? = nil, delimiter: String? = nil, fileCompression: CSVFileCompression? = nil, headerList: [String]? = nil, quoteSymbol: String? = nil) {
            self.charset = charset
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.fileCompression = fileCompression
            self.headerList = headerList
            self.quoteSymbol = quoteSymbol
        }

        public func validate(name: String) throws {
            try self.validate(self.charset, name: "charset", parent: name, max: 63)
            try self.validate(self.charset, name: "charset", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, pattern: "^[^\\r\\n]$")
            try self.headerList?.forEach {
                try validate($0, name: "headerList[]", parent: name, max: 63)
                try validate($0, name: "headerList[]", parent: name, min: 1)
                try validate($0, name: "headerList[]", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            }
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, max: 1)
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, pattern: "^[^\\r\\n]|^$")
        }

        private enum CodingKeys: String, CodingKey {
            case charset = "Charset"
            case containsHeader = "ContainsHeader"
            case delimiter = "Delimiter"
            case fileCompression = "FileCompression"
            case headerList = "HeaderList"
            case quoteSymbol = "QuoteSymbol"
        }
    }

    public struct DataQualityMetric: AWSDecodableShape {
        /// A description of the data quality metric.
        public let metricDescription: String?
        /// The name of the data quality metric.
        public let metricType: DataQualityMetricType?
        /// The value of the data quality metric.
        public let metricValue: Double?
        /// The column that is being monitored.
        public let relatedColumnName: String?

        @inlinable
        public init(metricDescription: String? = nil, metricType: DataQualityMetricType? = nil, metricValue: Double? = nil, relatedColumnName: String? = nil) {
            self.metricDescription = metricDescription
            self.metricType = metricType
            self.metricValue = metricValue
            self.relatedColumnName = relatedColumnName
        }

        private enum CodingKeys: String, CodingKey {
            case metricDescription = "MetricDescription"
            case metricType = "MetricType"
            case metricValue = "MetricValue"
            case relatedColumnName = "RelatedColumnName"
        }
    }

    public struct DeactivateAnomalyDetectorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String

        @inlinable
        public init(anomalyDetectorArn: String) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct DeactivateAnomalyDetectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAlertRequest: AWSEncodableShape {
        /// The ARN of the alert to delete.
        public let alertArn: String

        @inlinable
        public init(alertArn: String) {
            self.alertArn = alertArn
        }

        public func validate(name: String) throws {
            try self.validate(self.alertArn, name: "alertArn", parent: name, max: 256)
            try self.validate(self.alertArn, name: "alertArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alertArn = "AlertArn"
        }
    }

    public struct DeleteAlertResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAnomalyDetectorRequest: AWSEncodableShape {
        /// The ARN of the detector to delete.
        public let anomalyDetectorArn: String

        @inlinable
        public init(anomalyDetectorArn: String) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct DeleteAnomalyDetectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeAlertRequest: AWSEncodableShape {
        /// The ARN of the alert to describe.
        public let alertArn: String

        @inlinable
        public init(alertArn: String) {
            self.alertArn = alertArn
        }

        public func validate(name: String) throws {
            try self.validate(self.alertArn, name: "alertArn", parent: name, max: 256)
            try self.validate(self.alertArn, name: "alertArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alertArn = "AlertArn"
        }
    }

    public struct DescribeAlertResponse: AWSDecodableShape {
        /// Contains information about an alert.
        public let alert: Alert?

        @inlinable
        public init(alert: Alert? = nil) {
            self.alert = alert
        }

        private enum CodingKeys: String, CodingKey {
            case alert = "Alert"
        }
    }

    public struct DescribeAnomalyDetectionExecutionsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The timestamp of the anomaly detection job.
        public let timestamp: String?

        @inlinable
        public init(anomalyDetectorArn: String, maxResults: Int? = nil, nextToken: String? = nil, timestamp: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.timestamp = timestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
            try self.validate(self.timestamp, name: "timestamp", parent: name, max: 60)
            try self.validate(self.timestamp, name: "timestamp", parent: name, pattern: "^([12]\\d{3})-(1[0-2]|0[1-9])-(0[1-9]|[12]\\d|3[01])T([01]\\d|2[0-3]):([0-5]\\d):([0-5]\\d)(Z|(\\+|\\-)(0\\d|1[0-2]):([0-5]\\d)(\\[[[:alnum:]\\/\\_]+\\])?)$")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case timestamp = "Timestamp"
        }
    }

    public struct DescribeAnomalyDetectionExecutionsResponse: AWSDecodableShape {
        /// A list of detection jobs.
        public let executionList: [ExecutionStatus]?
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(executionList: [ExecutionStatus]? = nil, nextToken: String? = nil) {
            self.executionList = executionList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case executionList = "ExecutionList"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAnomalyDetectorRequest: AWSEncodableShape {
        /// The ARN of the detector to describe.
        public let anomalyDetectorArn: String

        @inlinable
        public init(anomalyDetectorArn: String) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct DescribeAnomalyDetectorResponse: AWSDecodableShape {
        /// The ARN of the detector.
        public let anomalyDetectorArn: String?
        /// Contains information about the detector's configuration.
        public let anomalyDetectorConfig: AnomalyDetectorConfigSummary?
        /// A description of the detector.
        public let anomalyDetectorDescription: String?
        /// The name of the detector.
        public let anomalyDetectorName: String?
        /// The time at which the detector was created.
        public let creationTime: Date?
        /// The reason that the detector failed.
        public let failureReason: String?
        /// The process that caused the detector to fail.
        public let failureType: AnomalyDetectorFailureType?
        /// The ARN of the KMS key to use to encrypt your data.
        public let kmsKeyArn: String?
        /// The time at which the detector was last modified.
        public let lastModificationTime: Date?
        /// The status of the detector.
        public let status: AnomalyDetectorStatus?

        @inlinable
        public init(anomalyDetectorArn: String? = nil, anomalyDetectorConfig: AnomalyDetectorConfigSummary? = nil, anomalyDetectorDescription: String? = nil, anomalyDetectorName: String? = nil, creationTime: Date? = nil, failureReason: String? = nil, failureType: AnomalyDetectorFailureType? = nil, kmsKeyArn: String? = nil, lastModificationTime: Date? = nil, status: AnomalyDetectorStatus? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyDetectorConfig = anomalyDetectorConfig
            self.anomalyDetectorDescription = anomalyDetectorDescription
            self.anomalyDetectorName = anomalyDetectorName
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.failureType = failureType
            self.kmsKeyArn = kmsKeyArn
            self.lastModificationTime = lastModificationTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyDetectorConfig = "AnomalyDetectorConfig"
            case anomalyDetectorDescription = "AnomalyDetectorDescription"
            case anomalyDetectorName = "AnomalyDetectorName"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case failureType = "FailureType"
            case kmsKeyArn = "KmsKeyArn"
            case lastModificationTime = "LastModificationTime"
            case status = "Status"
        }
    }

    public struct DescribeMetricSetRequest: AWSEncodableShape {
        /// The ARN of the dataset.
        public let metricSetArn: String

        @inlinable
        public init(metricSetArn: String) {
            self.metricSetArn = metricSetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.metricSetArn, name: "metricSetArn", parent: name, max: 256)
            try self.validate(self.metricSetArn, name: "metricSetArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case metricSetArn = "MetricSetArn"
        }
    }

    public struct DescribeMetricSetResponse: AWSDecodableShape {
        /// The ARN of the detector that contains the dataset.
        public let anomalyDetectorArn: String?
        /// The time at which the dataset was created.
        public let creationTime: Date?
        /// The dimensions and their values that were used to filter the dataset.
        public let dimensionFilterList: [MetricSetDimensionFilter]?
        /// A list of the dimensions chosen for analysis.
        public let dimensionList: [String]?
        /// The time at which the dataset was last modified.
        public let lastModificationTime: Date?
        /// A list of the metrics defined by the dataset.
        public let metricList: [Metric]?
        /// The ARN of the dataset.
        public let metricSetArn: String?
        /// The dataset's description.
        public let metricSetDescription: String?
        /// The interval at which the data will be analyzed for anomalies.
        public let metricSetFrequency: Frequency?
        /// The name of the dataset.
        public let metricSetName: String?
        /// Contains information about the dataset's source data.
        public let metricSource: MetricSource?
        /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3, Redshift, Athena and datasources.
        public let offset: Int?
        /// Contains information about the column used for tracking time in your source data.
        public let timestampColumn: TimestampColumn?
        /// The time zone in which the dataset's data was recorded.
        public let timezone: String?

        @inlinable
        public init(anomalyDetectorArn: String? = nil, creationTime: Date? = nil, dimensionFilterList: [MetricSetDimensionFilter]? = nil, dimensionList: [String]? = nil, lastModificationTime: Date? = nil, metricList: [Metric]? = nil, metricSetArn: String? = nil, metricSetDescription: String? = nil, metricSetFrequency: Frequency? = nil, metricSetName: String? = nil, metricSource: MetricSource? = nil, offset: Int? = nil, timestampColumn: TimestampColumn? = nil, timezone: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.dimensionFilterList = dimensionFilterList
            self.dimensionList = dimensionList
            self.lastModificationTime = lastModificationTime
            self.metricList = metricList
            self.metricSetArn = metricSetArn
            self.metricSetDescription = metricSetDescription
            self.metricSetFrequency = metricSetFrequency
            self.metricSetName = metricSetName
            self.metricSource = metricSource
            self.offset = offset
            self.timestampColumn = timestampColumn
            self.timezone = timezone
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case creationTime = "CreationTime"
            case dimensionFilterList = "DimensionFilterList"
            case dimensionList = "DimensionList"
            case lastModificationTime = "LastModificationTime"
            case metricList = "MetricList"
            case metricSetArn = "MetricSetArn"
            case metricSetDescription = "MetricSetDescription"
            case metricSetFrequency = "MetricSetFrequency"
            case metricSetName = "MetricSetName"
            case metricSource = "MetricSource"
            case offset = "Offset"
            case timestampColumn = "TimestampColumn"
            case timezone = "Timezone"
        }
    }

    public struct DetectMetricSetConfigRequest: AWSEncodableShape {
        /// An anomaly detector ARN.
        public let anomalyDetectorArn: String
        /// A data source.
        public let autoDetectionMetricSource: AutoDetectionMetricSource

        @inlinable
        public init(anomalyDetectorArn: String, autoDetectionMetricSource: AutoDetectionMetricSource) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.autoDetectionMetricSource = autoDetectionMetricSource
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.autoDetectionMetricSource.validate(name: "\(name).autoDetectionMetricSource")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case autoDetectionMetricSource = "AutoDetectionMetricSource"
        }
    }

    public struct DetectMetricSetConfigResponse: AWSDecodableShape {
        /// The inferred dataset configuration for the datasource.
        public let detectedMetricSetConfig: DetectedMetricSetConfig?

        @inlinable
        public init(detectedMetricSetConfig: DetectedMetricSetConfig? = nil) {
            self.detectedMetricSetConfig = detectedMetricSetConfig
        }

        private enum CodingKeys: String, CodingKey {
            case detectedMetricSetConfig = "DetectedMetricSetConfig"
        }
    }

    public struct DetectedCsvFormatDescriptor: AWSDecodableShape {
        /// The format's charset.
        public let charset: DetectedField?
        /// Whether the format includes a header.
        public let containsHeader: DetectedField?
        /// The format's delimiter.
        public let delimiter: DetectedField?
        /// The format's file compression.
        public let fileCompression: DetectedField?
        /// The format's header list.
        public let headerList: DetectedField?
        /// The format's quote symbol.
        public let quoteSymbol: DetectedField?

        @inlinable
        public init(charset: DetectedField? = nil, containsHeader: DetectedField? = nil, delimiter: DetectedField? = nil, fileCompression: DetectedField? = nil, headerList: DetectedField? = nil, quoteSymbol: DetectedField? = nil) {
            self.charset = charset
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.fileCompression = fileCompression
            self.headerList = headerList
            self.quoteSymbol = quoteSymbol
        }

        private enum CodingKeys: String, CodingKey {
            case charset = "Charset"
            case containsHeader = "ContainsHeader"
            case delimiter = "Delimiter"
            case fileCompression = "FileCompression"
            case headerList = "HeaderList"
            case quoteSymbol = "QuoteSymbol"
        }
    }

    public struct DetectedField: AWSDecodableShape {
        /// The field's confidence.
        public let confidence: Confidence?
        /// The field's message.
        public let message: String?
        /// The field's value.
        public let value: AttributeValue?

        @inlinable
        public init(confidence: Confidence? = nil, message: String? = nil, value: AttributeValue? = nil) {
            self.confidence = confidence
            self.message = message
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case message = "Message"
            case value = "Value"
        }
    }

    public struct DetectedFileFormatDescriptor: AWSDecodableShape {
        /// Details about a CSV format.
        public let csvFormatDescriptor: DetectedCsvFormatDescriptor?
        /// Details about a JSON format.
        public let jsonFormatDescriptor: DetectedJsonFormatDescriptor?

        @inlinable
        public init(csvFormatDescriptor: DetectedCsvFormatDescriptor? = nil, jsonFormatDescriptor: DetectedJsonFormatDescriptor? = nil) {
            self.csvFormatDescriptor = csvFormatDescriptor
            self.jsonFormatDescriptor = jsonFormatDescriptor
        }

        private enum CodingKeys: String, CodingKey {
            case csvFormatDescriptor = "CsvFormatDescriptor"
            case jsonFormatDescriptor = "JsonFormatDescriptor"
        }
    }

    public struct DetectedJsonFormatDescriptor: AWSDecodableShape {
        /// The format's character set.
        public let charset: DetectedField?
        /// The format's file compression.
        public let fileCompression: DetectedField?

        @inlinable
        public init(charset: DetectedField? = nil, fileCompression: DetectedField? = nil) {
            self.charset = charset
            self.fileCompression = fileCompression
        }

        private enum CodingKeys: String, CodingKey {
            case charset = "Charset"
            case fileCompression = "FileCompression"
        }
    }

    public struct DetectedMetricSetConfig: AWSDecodableShape {
        /// The dataset's interval.
        public let metricSetFrequency: DetectedField?
        /// The dataset's data source.
        public let metricSource: DetectedMetricSource?
        /// The dataset's offset.
        public let offset: DetectedField?

        @inlinable
        public init(metricSetFrequency: DetectedField? = nil, metricSource: DetectedMetricSource? = nil, offset: DetectedField? = nil) {
            self.metricSetFrequency = metricSetFrequency
            self.metricSource = metricSource
            self.offset = offset
        }

        private enum CodingKeys: String, CodingKey {
            case metricSetFrequency = "MetricSetFrequency"
            case metricSource = "MetricSource"
            case offset = "Offset"
        }
    }

    public struct DetectedMetricSource: AWSDecodableShape {
        /// The data source's source configuration.
        public let s3SourceConfig: DetectedS3SourceConfig?

        @inlinable
        public init(s3SourceConfig: DetectedS3SourceConfig? = nil) {
            self.s3SourceConfig = s3SourceConfig
        }

        private enum CodingKeys: String, CodingKey {
            case s3SourceConfig = "S3SourceConfig"
        }
    }

    public struct DetectedS3SourceConfig: AWSDecodableShape {
        /// The source's file format descriptor.
        public let fileFormatDescriptor: DetectedFileFormatDescriptor?

        @inlinable
        public init(fileFormatDescriptor: DetectedFileFormatDescriptor? = nil) {
            self.fileFormatDescriptor = fileFormatDescriptor
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormatDescriptor = "FileFormatDescriptor"
        }
    }

    public struct DimensionContribution: AWSDecodableShape {
        /// The name of the dimension.
        public let dimensionName: String?
        /// A list of dimension values that contributed to the anomaly.
        public let dimensionValueContributionList: [DimensionValueContribution]?

        @inlinable
        public init(dimensionName: String? = nil, dimensionValueContributionList: [DimensionValueContribution]? = nil) {
            self.dimensionName = dimensionName
            self.dimensionValueContributionList = dimensionValueContributionList
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionName = "DimensionName"
            case dimensionValueContributionList = "DimensionValueContributionList"
        }
    }

    public struct DimensionFilter: AWSEncodableShape & AWSDecodableShape {
        /// The name of the dimension to filter on.
        public let dimensionName: String?
        /// The list of values for the dimension specified in DimensionName that you want to filter on.
        public let dimensionValueList: [String]?

        @inlinable
        public init(dimensionName: String? = nil, dimensionValueList: [String]? = nil) {
            self.dimensionName = dimensionName
            self.dimensionValueList = dimensionValueList
        }

        public func validate(name: String) throws {
            try self.validate(self.dimensionName, name: "dimensionName", parent: name, max: 63)
            try self.validate(self.dimensionName, name: "dimensionName", parent: name, min: 1)
            try self.validate(self.dimensionName, name: "dimensionName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.dimensionValueList, name: "dimensionValueList", parent: name, max: 10)
            try self.validate(self.dimensionValueList, name: "dimensionValueList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionName = "DimensionName"
            case dimensionValueList = "DimensionValueList"
        }
    }

    public struct DimensionNameValue: AWSDecodableShape {
        /// The name of the dimension.
        public let dimensionName: String
        /// The value of the dimension.
        public let dimensionValue: String

        @inlinable
        public init(dimensionName: String, dimensionValue: String) {
            self.dimensionName = dimensionName
            self.dimensionValue = dimensionValue
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionName = "DimensionName"
            case dimensionValue = "DimensionValue"
        }
    }

    public struct DimensionValueContribution: AWSDecodableShape {
        /// The severity score of the value.
        public let contributionScore: Double?
        /// The value of the dimension.
        public let dimensionValue: String?

        @inlinable
        public init(contributionScore: Double? = nil, dimensionValue: String? = nil) {
            self.contributionScore = contributionScore
            self.dimensionValue = dimensionValue
        }

        private enum CodingKeys: String, CodingKey {
            case contributionScore = "ContributionScore"
            case dimensionValue = "DimensionValue"
        }
    }

    public struct ExecutionStatus: AWSDecodableShape {
        /// The reason that the run failed, if applicable.
        public let failureReason: String?
        /// The run's status.
        public let status: AnomalyDetectionTaskStatus?
        /// The run's timestamp.
        public let timestamp: String?

        @inlinable
        public init(failureReason: String? = nil, status: AnomalyDetectionTaskStatus? = nil, timestamp: String? = nil) {
            self.failureReason = failureReason
            self.status = status
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "FailureReason"
            case status = "Status"
            case timestamp = "Timestamp"
        }
    }

    public struct FileFormatDescriptor: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about how a source CSV data file should be analyzed.
        public let csvFormatDescriptor: CsvFormatDescriptor?
        /// Contains information about how a source JSON data file should be analyzed.
        public let jsonFormatDescriptor: JsonFormatDescriptor?

        @inlinable
        public init(csvFormatDescriptor: CsvFormatDescriptor? = nil, jsonFormatDescriptor: JsonFormatDescriptor? = nil) {
            self.csvFormatDescriptor = csvFormatDescriptor
            self.jsonFormatDescriptor = jsonFormatDescriptor
        }

        public func validate(name: String) throws {
            try self.csvFormatDescriptor?.validate(name: "\(name).csvFormatDescriptor")
            try self.jsonFormatDescriptor?.validate(name: "\(name).jsonFormatDescriptor")
        }

        private enum CodingKeys: String, CodingKey {
            case csvFormatDescriptor = "CsvFormatDescriptor"
            case jsonFormatDescriptor = "JsonFormatDescriptor"
        }
    }

    public struct Filter: AWSEncodableShape & AWSDecodableShape {
        /// The value that you want to include in the filter.
        public let dimensionValue: String?
        /// The condition to apply.
        public let filterOperation: FilterOperation?

        @inlinable
        public init(dimensionValue: String? = nil, filterOperation: FilterOperation? = nil) {
            self.dimensionValue = dimensionValue
            self.filterOperation = filterOperation
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionValue = "DimensionValue"
            case filterOperation = "FilterOperation"
        }
    }

    public struct GetAnomalyGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// The ID of the anomaly group.
        public let anomalyGroupId: String

        @inlinable
        public init(anomalyDetectorArn: String, anomalyGroupId: String) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyGroupId = anomalyGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, max: 63)
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, pattern: "^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyGroupId = "AnomalyGroupId"
        }
    }

    public struct GetAnomalyGroupResponse: AWSDecodableShape {
        /// Details about the anomaly group.
        public let anomalyGroup: AnomalyGroup?

        @inlinable
        public init(anomalyGroup: AnomalyGroup? = nil) {
            self.anomalyGroup = anomalyGroup
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroup = "AnomalyGroup"
        }
    }

    public struct GetDataQualityMetricsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector that you want to investigate.
        public let anomalyDetectorArn: String
        /// The Amazon Resource Name (ARN) of a specific data quality metric set.
        public let metricSetArn: String?

        @inlinable
        public init(anomalyDetectorArn: String, metricSetArn: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.metricSetArn = metricSetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.metricSetArn, name: "metricSetArn", parent: name, max: 256)
            try self.validate(self.metricSetArn, name: "metricSetArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case metricSetArn = "MetricSetArn"
        }
    }

    public struct GetDataQualityMetricsResponse: AWSDecodableShape {
        /// A list of the data quality metrics for the AnomalyDetectorArn that you requested.
        public let anomalyDetectorDataQualityMetricList: [AnomalyDetectorDataQualityMetric]?

        @inlinable
        public init(anomalyDetectorDataQualityMetricList: [AnomalyDetectorDataQualityMetric]? = nil) {
            self.anomalyDetectorDataQualityMetricList = anomalyDetectorDataQualityMetricList
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorDataQualityMetricList = "AnomalyDetectorDataQualityMetricList"
        }
    }

    public struct GetFeedbackRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// The anomalous metric and group ID.
        public let anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeries
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(anomalyDetectorArn: String, anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeries, maxResults: Int? = nil, nextToken: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.anomalyGroupTimeSeriesFeedback.validate(name: "\(name).anomalyGroupTimeSeriesFeedback")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetFeedbackResponse: AWSDecodableShape {
        /// Feedback for an anomalous metric.
        public let anomalyGroupTimeSeriesFeedback: [TimeSeriesFeedback]?
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(anomalyGroupTimeSeriesFeedback: [TimeSeriesFeedback]? = nil, nextToken: String? = nil) {
            self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
            case nextToken = "NextToken"
        }
    }

    public struct GetSampleDataRequest: AWSEncodableShape {
        /// A datasource bucket in Amazon S3.
        public let s3SourceConfig: SampleDataS3SourceConfig?

        @inlinable
        public init(s3SourceConfig: SampleDataS3SourceConfig? = nil) {
            self.s3SourceConfig = s3SourceConfig
        }

        public func validate(name: String) throws {
            try self.s3SourceConfig?.validate(name: "\(name).s3SourceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case s3SourceConfig = "S3SourceConfig"
        }
    }

    public struct GetSampleDataResponse: AWSDecodableShape {
        /// A list of header labels for the records.
        public let headerValues: [String]?
        /// A list of records.
        public let sampleRows: [[String]]?

        @inlinable
        public init(headerValues: [String]? = nil, sampleRows: [[String]]? = nil) {
            self.headerValues = headerValues
            self.sampleRows = sampleRows
        }

        private enum CodingKeys: String, CodingKey {
            case headerValues = "HeaderValues"
            case sampleRows = "SampleRows"
        }
    }

    public struct InterMetricImpactDetails: AWSDecodableShape {
        /// The ID of the anomaly group.
        public let anomalyGroupId: String?
        /// For potential causes (CAUSE_OF_INPUT_ANOMALY_GROUP), the percentage contribution the measure has in causing the anomalies.
        public let contributionPercentage: Double?
        /// The name of the measure.
        public let metricName: String?
        /// Whether a measure is a potential cause of the anomaly group (CAUSE_OF_INPUT_ANOMALY_GROUP), or whether the measure is impacted by the anomaly group (EFFECT_OF_INPUT_ANOMALY_GROUP).
        public let relationshipType: RelationshipType?

        @inlinable
        public init(anomalyGroupId: String? = nil, contributionPercentage: Double? = nil, metricName: String? = nil, relationshipType: RelationshipType? = nil) {
            self.anomalyGroupId = anomalyGroupId
            self.contributionPercentage = contributionPercentage
            self.metricName = metricName
            self.relationshipType = relationshipType
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupId = "AnomalyGroupId"
            case contributionPercentage = "ContributionPercentage"
            case metricName = "MetricName"
            case relationshipType = "RelationshipType"
        }
    }

    public struct ItemizedMetricStats: AWSDecodableShape {
        /// The name of the measure.
        public let metricName: String?
        /// The number of times that the measure appears.
        public let occurrenceCount: Int?

        @inlinable
        public init(metricName: String? = nil, occurrenceCount: Int? = nil) {
            self.metricName = metricName
            self.occurrenceCount = occurrenceCount
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case occurrenceCount = "OccurrenceCount"
        }
    }

    public struct JsonFormatDescriptor: AWSEncodableShape & AWSDecodableShape {
        /// The character set in which the source JSON file is written.
        public let charset: String?
        /// The level of compression of the source CSV file.
        public let fileCompression: JsonFileCompression?

        @inlinable
        public init(charset: String? = nil, fileCompression: JsonFileCompression? = nil) {
            self.charset = charset
            self.fileCompression = fileCompression
        }

        public func validate(name: String) throws {
            try self.validate(self.charset, name: "charset", parent: name, max: 63)
            try self.validate(self.charset, name: "charset", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case charset = "Charset"
            case fileCompression = "FileCompression"
        }
    }

    public struct LambdaConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function.
        public let lambdaArn: String
        /// The ARN of an IAM role that has permission to invoke the Lambda function.
        public let roleArn: String

        @inlinable
        public init(lambdaArn: String, roleArn: String) {
            self.lambdaArn = lambdaArn
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 256)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaArn = "LambdaArn"
            case roleArn = "RoleArn"
        }
    }

    public struct ListAlertsRequest: AWSEncodableShape {
        /// The ARN of the alert's detector.
        public let anomalyDetectorArn: String?
        /// The maximum number of results that will be displayed by the request.
        public let maxResults: Int?
        /// If the result of the previous request is truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        @inlinable
        public init(anomalyDetectorArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListAlertsResponse: AWSDecodableShape {
        /// Contains information about an alert.
        public let alertSummaryList: [AlertSummary]?
        /// If the response is truncated, the service returns this token. To retrieve the next set of results, use this token in the next request.
        public let nextToken: String?

        @inlinable
        public init(alertSummaryList: [AlertSummary]? = nil, nextToken: String? = nil) {
            self.alertSummaryList = alertSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case alertSummaryList = "AlertSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalyDetectorsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalyDetectorsResponse: AWSDecodableShape {
        /// A list of anomaly detectors in the account in the current region.
        public let anomalyDetectorSummaryList: [AnomalyDetectorSummary]?
        /// If the response is truncated, the service returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        @inlinable
        public init(anomalyDetectorSummaryList: [AnomalyDetectorSummary]? = nil, nextToken: String? = nil) {
            self.anomalyDetectorSummaryList = anomalyDetectorSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorSummaryList = "AnomalyDetectorSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalyGroupRelatedMetricsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// The ID of the anomaly group.
        public let anomalyGroupId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// Filter for potential causes (CAUSE_OF_INPUT_ANOMALY_GROUP) or downstream effects (EFFECT_OF_INPUT_ANOMALY_GROUP) of the anomaly group.
        public let relationshipTypeFilter: RelationshipType?

        @inlinable
        public init(anomalyDetectorArn: String, anomalyGroupId: String, maxResults: Int? = nil, nextToken: String? = nil, relationshipTypeFilter: RelationshipType? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyGroupId = anomalyGroupId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.relationshipTypeFilter = relationshipTypeFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, max: 63)
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, pattern: "^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyGroupId = "AnomalyGroupId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case relationshipTypeFilter = "RelationshipTypeFilter"
        }
    }

    public struct ListAnomalyGroupRelatedMetricsResponse: AWSDecodableShape {
        /// Aggregated details about the measures contributing to the anomaly group, and the measures potentially impacted by the anomaly group.
        public let interMetricImpactList: [InterMetricImpactDetails]?
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(interMetricImpactList: [InterMetricImpactDetails]? = nil, nextToken: String? = nil) {
            self.interMetricImpactList = interMetricImpactList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case interMetricImpactList = "InterMetricImpactList"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalyGroupSummariesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The minimum severity score for inclusion in the output.
        public let sensitivityThreshold: Int

        @inlinable
        public init(anomalyDetectorArn: String, maxResults: Int? = nil, nextToken: String? = nil, sensitivityThreshold: Int = 0) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sensitivityThreshold = sensitivityThreshold
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
            try self.validate(self.sensitivityThreshold, name: "sensitivityThreshold", parent: name, max: 100)
            try self.validate(self.sensitivityThreshold, name: "sensitivityThreshold", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sensitivityThreshold = "SensitivityThreshold"
        }
    }

    public struct ListAnomalyGroupSummariesResponse: AWSDecodableShape {
        /// Aggregated details about the anomaly groups.
        public let anomalyGroupStatistics: AnomalyGroupStatistics?
        /// A list of anomaly group summaries.
        public let anomalyGroupSummaryList: [AnomalyGroupSummary]?
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(anomalyGroupStatistics: AnomalyGroupStatistics? = nil, anomalyGroupSummaryList: [AnomalyGroupSummary]? = nil, nextToken: String? = nil) {
            self.anomalyGroupStatistics = anomalyGroupStatistics
            self.anomalyGroupSummaryList = anomalyGroupSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupStatistics = "AnomalyGroupStatistics"
            case anomalyGroupSummaryList = "AnomalyGroupSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalyGroupTimeSeriesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// The ID of the anomaly group.
        public let anomalyGroupId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The name of the measure field.
        public let metricName: String
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(anomalyDetectorArn: String, anomalyGroupId: String, maxResults: Int? = nil, metricName: String, nextToken: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyGroupId = anomalyGroupId
            self.maxResults = maxResults
            self.metricName = metricName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, max: 63)
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, pattern: "^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.metricName, name: "metricName", parent: name, max: 256)
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyGroupId = "AnomalyGroupId"
            case maxResults = "MaxResults"
            case metricName = "MetricName"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalyGroupTimeSeriesResponse: AWSDecodableShape {
        /// The ID of the anomaly group.
        public let anomalyGroupId: String?
        /// The name of the measure field.
        public let metricName: String?
        /// The pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of anomalous metrics.
        public let timeSeriesList: [TimeSeries]?
        /// Timestamps for the anomalous metrics.
        public let timestampList: [String]?

        @inlinable
        public init(anomalyGroupId: String? = nil, metricName: String? = nil, nextToken: String? = nil, timeSeriesList: [TimeSeries]? = nil, timestampList: [String]? = nil) {
            self.anomalyGroupId = anomalyGroupId
            self.metricName = metricName
            self.nextToken = nextToken
            self.timeSeriesList = timeSeriesList
            self.timestampList = timestampList
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupId = "AnomalyGroupId"
            case metricName = "MetricName"
            case nextToken = "NextToken"
            case timeSeriesList = "TimeSeriesList"
            case timestampList = "TimestampList"
        }
    }

    public struct ListMetricSetsRequest: AWSEncodableShape {
        /// The ARN of the anomaly detector containing the metrics sets to list.
        public let anomalyDetectorArn: String?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        @inlinable
        public init(anomalyDetectorArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListMetricSetsResponse: AWSDecodableShape {
        /// A list of the datasets in the AWS Region, with configuration details for each.
        public let metricSetSummaryList: [MetricSetSummary]?
        /// If the response is truncated, the list call returns this token. To retrieve the next set of results, use the token in the next list request.
        public let nextToken: String?

        @inlinable
        public init(metricSetSummaryList: [MetricSetSummary]? = nil, nextToken: String? = nil) {
            self.metricSetSummaryList = metricSetSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case metricSetSummaryList = "MetricSetSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The resource's Amazon Resource Name (ARN).
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The resource's tags.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct Metric: AWSEncodableShape & AWSDecodableShape {
        /// The function with which the metric is calculated.
        public let aggregationFunction: AggregationFunction
        /// The name of the metric.
        public let metricName: String
        /// The namespace for the metric.
        public let namespace: String?

        @inlinable
        public init(aggregationFunction: AggregationFunction, metricName: String, namespace: String? = nil) {
            self.aggregationFunction = aggregationFunction
            self.metricName = metricName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, max: 63)
            try self.validate(self.metricName, name: "metricName", parent: name, min: 1)
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[^:]")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case metricName = "MetricName"
            case namespace = "Namespace"
        }
    }

    public struct MetricLevelImpact: AWSDecodableShape {
        /// Details about the dimensions that contributed to the anomaly.
        public let contributionMatrix: ContributionMatrix?
        /// The name of the measure.
        public let metricName: String?
        /// The number of anomalous metrics for the measure.
        public let numTimeSeries: Int?

        @inlinable
        public init(contributionMatrix: ContributionMatrix? = nil, metricName: String? = nil, numTimeSeries: Int? = nil) {
            self.contributionMatrix = contributionMatrix
            self.metricName = metricName
            self.numTimeSeries = numTimeSeries
        }

        private enum CodingKeys: String, CodingKey {
            case contributionMatrix = "ContributionMatrix"
            case metricName = "MetricName"
            case numTimeSeries = "NumTimeSeries"
        }
    }

    public struct MetricSetDataQualityMetric: AWSDecodableShape {
        /// The array of data quality metrics contained in the data quality metric set.
        public let dataQualityMetricList: [DataQualityMetric]?
        /// The Amazon Resource Name (ARN) of the data quality metric array.
        public let metricSetArn: String?

        @inlinable
        public init(dataQualityMetricList: [DataQualityMetric]? = nil, metricSetArn: String? = nil) {
            self.dataQualityMetricList = dataQualityMetricList
            self.metricSetArn = metricSetArn
        }

        private enum CodingKeys: String, CodingKey {
            case dataQualityMetricList = "DataQualityMetricList"
            case metricSetArn = "MetricSetArn"
        }
    }

    public struct MetricSetDimensionFilter: AWSEncodableShape & AWSDecodableShape {
        /// The list of filters that you are applying.
        public let filterList: [Filter]?
        /// The dimension that you want to filter on.
        public let name: String?

        @inlinable
        public init(filterList: [Filter]? = nil, name: String? = nil) {
            self.filterList = filterList
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.filterList, name: "filterList", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterList = "FilterList"
            case name = "Name"
        }
    }

    public struct MetricSetSummary: AWSDecodableShape {
        /// The ARN of the detector to which the dataset belongs.
        public let anomalyDetectorArn: String?
        /// The time at which the dataset was created.
        public let creationTime: Date?
        /// The time at which the dataset was last modified.
        public let lastModificationTime: Date?
        /// The ARN of the dataset.
        public let metricSetArn: String?
        /// The description of the dataset.
        public let metricSetDescription: String?
        /// The name of the dataset.
        public let metricSetName: String?
        /// The dataset's tags.
        public let tags: [String: String]?

        @inlinable
        public init(anomalyDetectorArn: String? = nil, creationTime: Date? = nil, lastModificationTime: Date? = nil, metricSetArn: String? = nil, metricSetDescription: String? = nil, metricSetName: String? = nil, tags: [String: String]? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.metricSetArn = metricSetArn
            self.metricSetDescription = metricSetDescription
            self.metricSetName = metricSetName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case creationTime = "CreationTime"
            case lastModificationTime = "LastModificationTime"
            case metricSetArn = "MetricSetArn"
            case metricSetDescription = "MetricSetDescription"
            case metricSetName = "MetricSetName"
            case tags = "Tags"
        }
    }

    public struct MetricSource: AWSEncodableShape & AWSDecodableShape {
        /// Details about an AppFlow datasource.
        public let appFlowConfig: AppFlowConfig?
        /// Details about an Amazon Athena datasource.
        public let athenaSourceConfig: AthenaSourceConfig?
        /// Details about an Amazon CloudWatch monitoring datasource.
        public let cloudWatchConfig: CloudWatchConfig?
        /// Details about an Amazon Relational Database Service (RDS) datasource.
        public let rdsSourceConfig: RDSSourceConfig?
        /// Details about an Amazon Redshift database datasource.
        public let redshiftSourceConfig: RedshiftSourceConfig?
        public let s3SourceConfig: S3SourceConfig?

        @inlinable
        public init(appFlowConfig: AppFlowConfig? = nil, athenaSourceConfig: AthenaSourceConfig? = nil, cloudWatchConfig: CloudWatchConfig? = nil, rdsSourceConfig: RDSSourceConfig? = nil, redshiftSourceConfig: RedshiftSourceConfig? = nil, s3SourceConfig: S3SourceConfig? = nil) {
            self.appFlowConfig = appFlowConfig
            self.athenaSourceConfig = athenaSourceConfig
            self.cloudWatchConfig = cloudWatchConfig
            self.rdsSourceConfig = rdsSourceConfig
            self.redshiftSourceConfig = redshiftSourceConfig
            self.s3SourceConfig = s3SourceConfig
        }

        public func validate(name: String) throws {
            try self.appFlowConfig?.validate(name: "\(name).appFlowConfig")
            try self.athenaSourceConfig?.validate(name: "\(name).athenaSourceConfig")
            try self.cloudWatchConfig?.validate(name: "\(name).cloudWatchConfig")
            try self.rdsSourceConfig?.validate(name: "\(name).rdsSourceConfig")
            try self.redshiftSourceConfig?.validate(name: "\(name).redshiftSourceConfig")
            try self.s3SourceConfig?.validate(name: "\(name).s3SourceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case appFlowConfig = "AppFlowConfig"
            case athenaSourceConfig = "AthenaSourceConfig"
            case cloudWatchConfig = "CloudWatchConfig"
            case rdsSourceConfig = "RDSSourceConfig"
            case redshiftSourceConfig = "RedshiftSourceConfig"
            case s3SourceConfig = "S3SourceConfig"
        }
    }

    public struct PutFeedbackRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// Feedback for an anomalous metric.
        public let anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeriesFeedback

        @inlinable
        public init(anomalyDetectorArn: String, anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeriesFeedback) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.anomalyGroupTimeSeriesFeedback.validate(name: "\(name).anomalyGroupTimeSeriesFeedback")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
        }
    }

    public struct PutFeedbackResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RDSSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The host name of the database.
        public let databaseHost: String?
        /// The name of the RDS database.
        public let databaseName: String?
        /// The port number where the database can be accessed.
        public let databasePort: Int?
        /// A string identifying the database instance.
        public let dbInstanceIdentifier: String?
        /// The Amazon Resource Name (ARN) of the role.
        public let roleArn: String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager role.
        public let secretManagerArn: String?
        /// The name of the table in the database.
        public let tableName: String?
        /// An object containing information about the Amazon Virtual Private Cloud (VPC) configuration.
        public let vpcConfiguration: VpcConfiguration?

        @inlinable
        public init(databaseHost: String? = nil, databaseName: String? = nil, databasePort: Int? = nil, dbInstanceIdentifier: String? = nil, roleArn: String? = nil, secretManagerArn: String? = nil, tableName: String? = nil, vpcConfiguration: VpcConfiguration? = nil) {
            self.databaseHost = databaseHost
            self.databaseName = databaseName
            self.databasePort = databasePort
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.roleArn = roleArn
            self.secretManagerArn = secretManagerArn
            self.tableName = tableName
            self.vpcConfiguration = vpcConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, max: 253)
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, min: 1)
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, pattern: "\\S")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 64)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            try self.validate(self.databasePort, name: "databasePort", parent: name, max: 65535)
            try self.validate(self.databasePort, name: "databasePort", parent: name, min: 1)
            try self.validate(self.dbInstanceIdentifier, name: "dbInstanceIdentifier", parent: name, max: 63)
            try self.validate(self.dbInstanceIdentifier, name: "dbInstanceIdentifier", parent: name, min: 1)
            try self.validate(self.dbInstanceIdentifier, name: "dbInstanceIdentifier", parent: name, pattern: "^[a-zA-Z](?!.*--)(?!.*-$)[0-9a-zA-Z\\-]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.secretManagerArn, name: "secretManagerArn", parent: name, max: 256)
            try self.validate(self.secretManagerArn, name: "secretManagerArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:secret:AmazonLookoutMetrics-.+$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 100)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_.]*$")
            try self.vpcConfiguration?.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseHost = "DatabaseHost"
            case databaseName = "DatabaseName"
            case databasePort = "DatabasePort"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case roleArn = "RoleArn"
            case secretManagerArn = "SecretManagerArn"
            case tableName = "TableName"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct RedshiftSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// A string identifying the Redshift cluster.
        public let clusterIdentifier: String?
        /// The name of the database host.
        public let databaseHost: String?
        /// The Redshift database name.
        public let databaseName: String?
        /// The port number where the database can be accessed.
        public let databasePort: Int?
        /// The Amazon Resource Name (ARN) of the role providing access to the database.
        public let roleArn: String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager role.
        public let secretManagerArn: String?
        /// The table name of the Redshift database.
        public let tableName: String?
        /// Contains information about the Amazon Virtual Private Cloud (VPC) configuration.
        public let vpcConfiguration: VpcConfiguration?

        @inlinable
        public init(clusterIdentifier: String? = nil, databaseHost: String? = nil, databaseName: String? = nil, databasePort: Int? = nil, roleArn: String? = nil, secretManagerArn: String? = nil, tableName: String? = nil, vpcConfiguration: VpcConfiguration? = nil) {
            self.clusterIdentifier = clusterIdentifier
            self.databaseHost = databaseHost
            self.databaseName = databaseName
            self.databasePort = databasePort
            self.roleArn = roleArn
            self.secretManagerArn = secretManagerArn
            self.tableName = tableName
            self.vpcConfiguration = vpcConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, max: 63)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, min: 1)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^[a-z](?!.*--)(?!.*-$)[0-9a-z\\-]*$")
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, max: 253)
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, min: 1)
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, pattern: "\\S")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 100)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            try self.validate(self.databasePort, name: "databasePort", parent: name, max: 65535)
            try self.validate(self.databasePort, name: "databasePort", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.secretManagerArn, name: "secretManagerArn", parent: name, max: 256)
            try self.validate(self.secretManagerArn, name: "secretManagerArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:secret:AmazonLookoutMetrics-.+$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 100)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_.]*$")
            try self.vpcConfiguration?.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterIdentifier = "ClusterIdentifier"
            case databaseHost = "DatabaseHost"
            case databaseName = "DatabaseName"
            case databasePort = "DatabasePort"
            case roleArn = "RoleArn"
            case secretManagerArn = "SecretManagerArn"
            case tableName = "TableName"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The ID of the resource.
        public let resourceId: String?
        /// The type of the resource.
        public let resourceType: String?

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct S3SourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about a source file's formatting.
        public let fileFormatDescriptor: FileFormatDescriptor?
        /// A list of paths to the historical data files.
        public let historicalDataPathList: [String]?
        /// The ARN of an IAM role that has read and write access permissions to the source S3 bucket.
        public let roleArn: String?
        /// A list of templated paths to the source files.
        public let templatedPathList: [String]?

        @inlinable
        public init(fileFormatDescriptor: FileFormatDescriptor? = nil, historicalDataPathList: [String]? = nil, roleArn: String? = nil, templatedPathList: [String]? = nil) {
            self.fileFormatDescriptor = fileFormatDescriptor
            self.historicalDataPathList = historicalDataPathList
            self.roleArn = roleArn
            self.templatedPathList = templatedPathList
        }

        public func validate(name: String) throws {
            try self.fileFormatDescriptor?.validate(name: "\(name).fileFormatDescriptor")
            try self.historicalDataPathList?.forEach {
                try validate($0, name: "historicalDataPathList[]", parent: name, max: 1024)
                try validate($0, name: "historicalDataPathList[]", parent: name, pattern: "^s3://[a-z0-9].+$")
            }
            try self.validate(self.historicalDataPathList, name: "historicalDataPathList", parent: name, max: 1)
            try self.validate(self.historicalDataPathList, name: "historicalDataPathList", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.templatedPathList?.forEach {
                try validate($0, name: "templatedPathList[]", parent: name, max: 1024)
                try validate($0, name: "templatedPathList[]", parent: name, pattern: "^s3://[a-zA-Z0-9_\\-\\/ {}=]+$")
            }
            try self.validate(self.templatedPathList, name: "templatedPathList", parent: name, max: 1)
            try self.validate(self.templatedPathList, name: "templatedPathList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormatDescriptor = "FileFormatDescriptor"
            case historicalDataPathList = "HistoricalDataPathList"
            case roleArn = "RoleArn"
            case templatedPathList = "TemplatedPathList"
        }
    }

    public struct SNSConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role that has access to the target SNS topic.
        public let roleArn: String
        /// The format of the SNS topic.    JSON  Send JSON alerts with an anomaly ID and a link to the anomaly detail page. This is the default.    LONG_TEXT  Send human-readable alerts with information about the impacted timeseries and a link to the anomaly detail page. We recommend this for email.    SHORT_TEXT  Send human-readable alerts with a link to the anomaly detail page. We recommend this for SMS.
        public let snsFormat: SnsFormat?
        /// The ARN of the target SNS topic.
        public let snsTopicArn: String

        @inlinable
        public init(roleArn: String, snsFormat: SnsFormat? = nil, snsTopicArn: String) {
            self.roleArn = roleArn
            self.snsFormat = snsFormat
            self.snsTopicArn = snsTopicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, max: 256)
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case snsFormat = "SnsFormat"
            case snsTopicArn = "SnsTopicArn"
        }
    }

    public struct SampleDataS3SourceConfig: AWSEncodableShape {
        public let fileFormatDescriptor: FileFormatDescriptor
        /// An array of strings containing the historical set of data paths.
        public let historicalDataPathList: [String]?
        /// The Amazon Resource Name (ARN) of the role.
        public let roleArn: String
        /// An array of strings containing the list of templated paths.
        public let templatedPathList: [String]?

        @inlinable
        public init(fileFormatDescriptor: FileFormatDescriptor, historicalDataPathList: [String]? = nil, roleArn: String, templatedPathList: [String]? = nil) {
            self.fileFormatDescriptor = fileFormatDescriptor
            self.historicalDataPathList = historicalDataPathList
            self.roleArn = roleArn
            self.templatedPathList = templatedPathList
        }

        public func validate(name: String) throws {
            try self.fileFormatDescriptor.validate(name: "\(name).fileFormatDescriptor")
            try self.historicalDataPathList?.forEach {
                try validate($0, name: "historicalDataPathList[]", parent: name, max: 1024)
                try validate($0, name: "historicalDataPathList[]", parent: name, pattern: "^s3://[a-z0-9].+$")
            }
            try self.validate(self.historicalDataPathList, name: "historicalDataPathList", parent: name, max: 1)
            try self.validate(self.historicalDataPathList, name: "historicalDataPathList", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.templatedPathList?.forEach {
                try validate($0, name: "templatedPathList[]", parent: name, max: 1024)
                try validate($0, name: "templatedPathList[]", parent: name, pattern: "^s3://[a-zA-Z0-9_\\-\\/ {}=]+$")
            }
            try self.validate(self.templatedPathList, name: "templatedPathList", parent: name, max: 1)
            try self.validate(self.templatedPathList, name: "templatedPathList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormatDescriptor = "FileFormatDescriptor"
            case historicalDataPathList = "HistoricalDataPathList"
            case roleArn = "RoleArn"
            case templatedPathList = "TemplatedPathList"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The quota code.
        public let quotaCode: String?
        /// The ID of the resource.
        public let resourceId: String?
        /// The type of the resource.
        public let resourceType: String?
        /// The service code.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, resourceId: String? = nil, resourceType: String? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case quotaCode = "QuotaCode"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
            case serviceCode = "ServiceCode"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource's Amazon Resource Name (ARN).
        public let resourceArn: String
        /// Tags to apply to the resource. Tag keys and values can contain letters, numbers, spaces, and the following symbols: _.:/=+@-
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimeSeries: AWSDecodableShape {
        /// The dimensions of the metric.
        public let dimensionList: [DimensionNameValue]
        /// The values for the metric.
        public let metricValueList: [Double]
        /// The ID of the metric.
        public let timeSeriesId: String

        @inlinable
        public init(dimensionList: [DimensionNameValue], metricValueList: [Double], timeSeriesId: String) {
            self.dimensionList = dimensionList
            self.metricValueList = metricValueList
            self.timeSeriesId = timeSeriesId
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionList = "DimensionList"
            case metricValueList = "MetricValueList"
            case timeSeriesId = "TimeSeriesId"
        }
    }

    public struct TimeSeriesFeedback: AWSDecodableShape {
        /// Feedback on whether the metric is a legitimate anomaly.
        public let isAnomaly: Bool?
        /// The ID of the metric.
        public let timeSeriesId: String?

        @inlinable
        public init(isAnomaly: Bool? = nil, timeSeriesId: String? = nil) {
            self.isAnomaly = isAnomaly
            self.timeSeriesId = timeSeriesId
        }

        private enum CodingKeys: String, CodingKey {
            case isAnomaly = "IsAnomaly"
            case timeSeriesId = "TimeSeriesId"
        }
    }

    public struct TimestampColumn: AWSEncodableShape & AWSDecodableShape {
        /// The format of the timestamp column.
        public let columnFormat: String?
        /// The name of the timestamp column.
        public let columnName: String?

        @inlinable
        public init(columnFormat: String? = nil, columnName: String? = nil) {
            self.columnFormat = columnFormat
            self.columnName = columnName
        }

        public func validate(name: String) throws {
            try self.validate(self.columnFormat, name: "columnFormat", parent: name, max: 63)
            try self.validate(self.columnFormat, name: "columnFormat", parent: name, pattern: "\\S")
            try self.validate(self.columnName, name: "columnName", parent: name, max: 63)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case columnFormat = "ColumnFormat"
            case columnName = "ColumnName"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The resource's Amazon Resource Name (ARN).
        public let resourceArn: String
        /// Keys to remove from the resource's tags.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAlertRequest: AWSEncodableShape {
        /// Action that will be triggered when there is an alert.
        public let action: Action?
        /// The ARN of the alert to update.
        public let alertArn: String
        /// A description of the alert.
        public let alertDescription: String?
        /// The configuration of the alert filters, containing MetricList and DimensionFilterList.
        public let alertFilters: AlertFilters?
        /// An integer from 0 to 100 specifying the alert sensitivity threshold.
        public let alertSensitivityThreshold: Int?

        @inlinable
        public init(action: Action? = nil, alertArn: String, alertDescription: String? = nil, alertFilters: AlertFilters? = nil, alertSensitivityThreshold: Int? = nil) {
            self.action = action
            self.alertArn = alertArn
            self.alertDescription = alertDescription
            self.alertFilters = alertFilters
            self.alertSensitivityThreshold = alertSensitivityThreshold
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.validate(self.alertArn, name: "alertArn", parent: name, max: 256)
            try self.validate(self.alertArn, name: "alertArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.alertDescription, name: "alertDescription", parent: name, max: 256)
            try self.validate(self.alertDescription, name: "alertDescription", parent: name, pattern: "\\S")
            try self.alertFilters?.validate(name: "\(name).alertFilters")
            try self.validate(self.alertSensitivityThreshold, name: "alertSensitivityThreshold", parent: name, max: 100)
            try self.validate(self.alertSensitivityThreshold, name: "alertSensitivityThreshold", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case alertArn = "AlertArn"
            case alertDescription = "AlertDescription"
            case alertFilters = "AlertFilters"
            case alertSensitivityThreshold = "AlertSensitivityThreshold"
        }
    }

    public struct UpdateAlertResponse: AWSDecodableShape {
        /// The ARN of the updated alert.
        public let alertArn: String?

        @inlinable
        public init(alertArn: String? = nil) {
            self.alertArn = alertArn
        }

        private enum CodingKeys: String, CodingKey {
            case alertArn = "AlertArn"
        }
    }

    public struct UpdateAnomalyDetectorRequest: AWSEncodableShape {
        /// The ARN of the detector to update.
        public let anomalyDetectorArn: String
        /// Contains information about the configuration to which the detector will be updated.
        public let anomalyDetectorConfig: AnomalyDetectorConfig?
        /// The updated detector description.
        public let anomalyDetectorDescription: String?
        /// The Amazon Resource Name (ARN) of an AWS KMS encryption key.
        public let kmsKeyArn: String?

        @inlinable
        public init(anomalyDetectorArn: String, anomalyDetectorConfig: AnomalyDetectorConfig? = nil, anomalyDetectorDescription: String? = nil, kmsKeyArn: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyDetectorConfig = anomalyDetectorConfig
            self.anomalyDetectorDescription = anomalyDetectorDescription
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, max: 256)
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, min: 1)
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws.*:kms:.*:[0-9]{12}:key/[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyDetectorConfig = "AnomalyDetectorConfig"
            case anomalyDetectorDescription = "AnomalyDetectorDescription"
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public struct UpdateAnomalyDetectorResponse: AWSDecodableShape {
        /// The ARN of the updated detector.
        public let anomalyDetectorArn: String?

        @inlinable
        public init(anomalyDetectorArn: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct UpdateMetricSetRequest: AWSEncodableShape {
        /// Describes a list of filters for choosing specific dimensions and specific values. Each filter consists of the dimension and one of its values that you want to include. When multiple dimensions or values are specified, the dimensions are joined with an AND operation and the values are joined with an OR operation.
        public let dimensionFilterList: [MetricSetDimensionFilter]?
        /// The dimension list.
        public let dimensionList: [String]?
        /// The metric list.
        public let metricList: [Metric]?
        /// The ARN of the dataset to update.
        public let metricSetArn: String
        /// The dataset's description.
        public let metricSetDescription: String?
        /// The dataset's interval.
        public let metricSetFrequency: Frequency?
        public let metricSource: MetricSource?
        /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3, Redshift, Athena and datasources.
        public let offset: Int?
        /// The timestamp column.
        public let timestampColumn: TimestampColumn?

        @inlinable
        public init(dimensionFilterList: [MetricSetDimensionFilter]? = nil, dimensionList: [String]? = nil, metricList: [Metric]? = nil, metricSetArn: String, metricSetDescription: String? = nil, metricSetFrequency: Frequency? = nil, metricSource: MetricSource? = nil, offset: Int? = nil, timestampColumn: TimestampColumn? = nil) {
            self.dimensionFilterList = dimensionFilterList
            self.dimensionList = dimensionList
            self.metricList = metricList
            self.metricSetArn = metricSetArn
            self.metricSetDescription = metricSetDescription
            self.metricSetFrequency = metricSetFrequency
            self.metricSource = metricSource
            self.offset = offset
            self.timestampColumn = timestampColumn
        }

        public func validate(name: String) throws {
            try self.dimensionFilterList?.forEach {
                try $0.validate(name: "\(name).dimensionFilterList[]")
            }
            try self.dimensionList?.forEach {
                try validate($0, name: "dimensionList[]", parent: name, max: 63)
                try validate($0, name: "dimensionList[]", parent: name, min: 1)
                try validate($0, name: "dimensionList[]", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            }
            try self.validate(self.dimensionList, name: "dimensionList", parent: name, min: 1)
            try self.metricList?.forEach {
                try $0.validate(name: "\(name).metricList[]")
            }
            try self.validate(self.metricList, name: "metricList", parent: name, min: 1)
            try self.validate(self.metricSetArn, name: "metricSetArn", parent: name, max: 256)
            try self.validate(self.metricSetArn, name: "metricSetArn", parent: name, pattern: "^arn:([a-z\\d-]+):.*:.*:.*:.+$")
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, max: 256)
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, min: 1)
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, pattern: "\\S")
            try self.metricSource?.validate(name: "\(name).metricSource")
            try self.validate(self.offset, name: "offset", parent: name, max: 432000)
            try self.validate(self.offset, name: "offset", parent: name, min: 0)
            try self.timestampColumn?.validate(name: "\(name).timestampColumn")
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionFilterList = "DimensionFilterList"
            case dimensionList = "DimensionList"
            case metricList = "MetricList"
            case metricSetArn = "MetricSetArn"
            case metricSetDescription = "MetricSetDescription"
            case metricSetFrequency = "MetricSetFrequency"
            case metricSource = "MetricSource"
            case offset = "Offset"
            case timestampColumn = "TimestampColumn"
        }
    }

    public struct UpdateMetricSetResponse: AWSDecodableShape {
        /// The ARN of the dataset.
        public let metricSetArn: String?

        @inlinable
        public init(metricSetArn: String? = nil) {
            self.metricSetArn = metricSetArn
        }

        private enum CodingKeys: String, CodingKey {
            case metricSetArn = "MetricSetArn"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// Fields that failed validation.
        public let fields: [ValidationExceptionField]?
        public let message: String
        /// The reason that validation failed.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(fields: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason? = nil) {
            self.fields = fields
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The message with more information about the validation exception.
        public let message: String
        /// The name of the field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case name = "Name"
        }
    }

    public struct VpcConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An array of strings containing the list of security groups.
        public let securityGroupIdList: [String]
        /// An array of strings containing the Amazon VPC subnet IDs (e.g., subnet-0bb1c79de3EXAMPLE.
        public let subnetIdList: [String]

        @inlinable
        public init(securityGroupIdList: [String], subnetIdList: [String]) {
            self.securityGroupIdList = securityGroupIdList
            self.subnetIdList = subnetIdList
        }

        public func validate(name: String) throws {
            try self.securityGroupIdList.forEach {
                try validate($0, name: "securityGroupIdList[]", parent: name, max: 255)
                try validate($0, name: "securityGroupIdList[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIdList[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.subnetIdList.forEach {
                try validate($0, name: "subnetIdList[]", parent: name, max: 255)
                try validate($0, name: "subnetIdList[]", parent: name, pattern: "^[\\-0-9a-zA-Z]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIdList = "SecurityGroupIdList"
            case subnetIdList = "SubnetIdList"
        }
    }
}

// MARK: - Errors

/// Error enum for LookoutMetrics
public struct LookoutMetricsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case tooManyRequestsException = "TooManyRequestsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize LookoutMetrics
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient permissions to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There was a conflict processing the request. Try your request again.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request processing has failed because of an unknown error, exception, or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource cannot be found. Check the ARN of the resource and try again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request exceeded the service's quotas. Check the service quotas and try again.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to too many requests being submitted at the same time.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// The input fails to satisfy the constraints specified by the AWS service. Check your input values and try again.
    public static var validationException: Self { .init(.validationException) }
}

extension LookoutMetricsErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": LookoutMetrics.ConflictException.self,
        "ResourceNotFoundException": LookoutMetrics.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": LookoutMetrics.ServiceQuotaExceededException.self,
        "ValidationException": LookoutMetrics.ValidationException.self
    ]
}

extension LookoutMetricsErrorType: Equatable {
    public static func == (lhs: LookoutMetricsErrorType, rhs: LookoutMetricsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension LookoutMetricsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
