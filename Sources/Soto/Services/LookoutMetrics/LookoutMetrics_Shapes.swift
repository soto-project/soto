//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension LookoutMetrics {
    // MARK: Enums

    public enum AggregationFunction: String, CustomStringConvertible, Codable {
        case avg = "AVG"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum AlertStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum AlertType: String, CustomStringConvertible, Codable {
        case lambda = "LAMBDA"
        case sns = "SNS"
        public var description: String { return self.rawValue }
    }

    public enum AnomalyDetectionTaskStatus: String, CustomStringConvertible, Codable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case failedToSchedule = "FAILED_TO_SCHEDULE"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum AnomalyDetectorStatus: String, CustomStringConvertible, Codable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case backTestActivating = "BACK_TEST_ACTIVATING"
        case backTestActive = "BACK_TEST_ACTIVE"
        case backTestComplete = "BACK_TEST_COMPLETE"
        case deleting = "DELETING"
        case failed = "FAILED"
        case inactive = "INACTIVE"
        case learning = "LEARNING"
        public var description: String { return self.rawValue }
    }

    public enum CSVFileCompression: String, CustomStringConvertible, Codable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum Frequency: String, CustomStringConvertible, Codable {
        case p1d = "P1D"
        case pt10m = "PT10M"
        case pt1h = "PT1H"
        case pt5m = "PT5M"
        public var description: String { return self.rawValue }
    }

    public enum JsonFileCompression: String, CustomStringConvertible, Codable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// A configuration for an AWS Lambda channel.
        public let lambdaConfiguration: LambdaConfiguration?
        /// A configuration for an Amazon SNS channel.
        public let sNSConfiguration: SNSConfiguration?

        public init(lambdaConfiguration: LambdaConfiguration? = nil, sNSConfiguration: SNSConfiguration? = nil) {
            self.lambdaConfiguration = lambdaConfiguration
            self.sNSConfiguration = sNSConfiguration
        }

        public func validate(name: String) throws {
            try self.lambdaConfiguration?.validate(name: "\(name).lambdaConfiguration")
            try self.sNSConfiguration?.validate(name: "\(name).sNSConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaConfiguration = "LambdaConfiguration"
            case sNSConfiguration = "SNSConfiguration"
        }
    }

    public struct ActivateAnomalyDetectorRequest: AWSEncodableShape {
        /// The ARN of the anomaly detector.
        public let anomalyDetectorArn: String

        public init(anomalyDetectorArn: String) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct ActivateAnomalyDetectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Alert: AWSDecodableShape {
        /// Action that will be triggered when there is an alert.
        public let action: Action?
        /// The ARN of the alert.
        public let alertArn: String?
        /// A description of the alert.
        public let alertDescription: String?
        /// The name of the alert.
        public let alertName: String?
        /// The minimum severity for an anomaly to trigger the alert.
        public let alertSensitivityThreshold: Int?
        /// The status of the alert.
        public let alertStatus: AlertStatus?
        /// The type of the alert.
        public let alertType: AlertType?
        /// The ARN of the detector to which the alert is attached.
        public let anomalyDetectorArn: String?
        /// The time at which the alert was created.
        public let creationTime: Date?
        /// The time at which the alert was last modified.
        public let lastModificationTime: Date?

        public init(action: Action? = nil, alertArn: String? = nil, alertDescription: String? = nil, alertName: String? = nil, alertSensitivityThreshold: Int? = nil, alertStatus: AlertStatus? = nil, alertType: AlertType? = nil, anomalyDetectorArn: String? = nil, creationTime: Date? = nil, lastModificationTime: Date? = nil) {
            self.action = action
            self.alertArn = alertArn
            self.alertDescription = alertDescription
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.alertStatus = alertStatus
            self.alertType = alertType
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case alertArn = "AlertArn"
            case alertDescription = "AlertDescription"
            case alertName = "AlertName"
            case alertSensitivityThreshold = "AlertSensitivityThreshold"
            case alertStatus = "AlertStatus"
            case alertType = "AlertType"
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case creationTime = "CreationTime"
            case lastModificationTime = "LastModificationTime"
        }
    }

    public struct AlertSummary: AWSDecodableShape {
        /// The ARN of the alert.
        public let alertArn: String?
        /// The name of the alert.
        public let alertName: String?
        /// The minimum severity for an anomaly to trigger the alert.
        public let alertSensitivityThreshold: Int?
        /// The status of the alert.
        public let alertStatus: AlertStatus?
        /// The type of the alert.
        public let alertType: AlertType?
        /// The ARN of the detector to which the alert is attached.
        public let anomalyDetectorArn: String?
        /// The time at which the alert was created.
        public let creationTime: Date?
        /// The time at which the alert was last modified.
        public let lastModificationTime: Date?
        /// The alert's tags.
        public let tags: [String: String]?

        public init(alertArn: String? = nil, alertName: String? = nil, alertSensitivityThreshold: Int? = nil, alertStatus: AlertStatus? = nil, alertType: AlertType? = nil, anomalyDetectorArn: String? = nil, creationTime: Date? = nil, lastModificationTime: Date? = nil, tags: [String: String]? = nil) {
            self.alertArn = alertArn
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.alertStatus = alertStatus
            self.alertType = alertType
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case alertArn = "AlertArn"
            case alertName = "AlertName"
            case alertSensitivityThreshold = "AlertSensitivityThreshold"
            case alertStatus = "AlertStatus"
            case alertType = "AlertType"
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case creationTime = "CreationTime"
            case lastModificationTime = "LastModificationTime"
            case tags = "Tags"
        }
    }

    public struct AnomalyDetectorConfig: AWSEncodableShape {
        /// The frequency at which the detector analyzes its source data.
        public let anomalyDetectorFrequency: Frequency?

        public init(anomalyDetectorFrequency: Frequency? = nil) {
            self.anomalyDetectorFrequency = anomalyDetectorFrequency
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorFrequency = "AnomalyDetectorFrequency"
        }
    }

    public struct AnomalyDetectorConfigSummary: AWSDecodableShape {
        /// The interval at which the detector analyzes its source data.
        public let anomalyDetectorFrequency: Frequency?

        public init(anomalyDetectorFrequency: Frequency? = nil) {
            self.anomalyDetectorFrequency = anomalyDetectorFrequency
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorFrequency = "AnomalyDetectorFrequency"
        }
    }

    public struct AnomalyDetectorSummary: AWSDecodableShape {
        /// The ARN of the detector.
        public let anomalyDetectorArn: String?
        /// A description of the detector.
        public let anomalyDetectorDescription: String?
        /// The name of the detector.
        public let anomalyDetectorName: String?
        /// The time at which the detector was created.
        public let creationTime: Date?
        /// The time at which the detector was last modified.
        public let lastModificationTime: Date?
        /// The status of detector.
        public let status: AnomalyDetectorStatus?
        /// The detector's tags.
        public let tags: [String: String]?

        public init(anomalyDetectorArn: String? = nil, anomalyDetectorDescription: String? = nil, anomalyDetectorName: String? = nil, creationTime: Date? = nil, lastModificationTime: Date? = nil, status: AnomalyDetectorStatus? = nil, tags: [String: String]? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyDetectorDescription = anomalyDetectorDescription
            self.anomalyDetectorName = anomalyDetectorName
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyDetectorDescription = "AnomalyDetectorDescription"
            case anomalyDetectorName = "AnomalyDetectorName"
            case creationTime = "CreationTime"
            case lastModificationTime = "LastModificationTime"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct AnomalyGroup: AWSDecodableShape {
        /// The ID of the anomaly group.
        public let anomalyGroupId: String?
        /// The severity score of the group.
        public let anomalyGroupScore: Double?
        /// The end time for the group.
        public let endTime: String?
        /// A list of measures affected by the anomaly.
        public let metricLevelImpactList: [MetricLevelImpact]?
        /// The name of the primary affected measure for the group.
        public let primaryMetricName: String?
        /// The start time for the group.
        public let startTime: String?

        public init(anomalyGroupId: String? = nil, anomalyGroupScore: Double? = nil, endTime: String? = nil, metricLevelImpactList: [MetricLevelImpact]? = nil, primaryMetricName: String? = nil, startTime: String? = nil) {
            self.anomalyGroupId = anomalyGroupId
            self.anomalyGroupScore = anomalyGroupScore
            self.endTime = endTime
            self.metricLevelImpactList = metricLevelImpactList
            self.primaryMetricName = primaryMetricName
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupId = "AnomalyGroupId"
            case anomalyGroupScore = "AnomalyGroupScore"
            case endTime = "EndTime"
            case metricLevelImpactList = "MetricLevelImpactList"
            case primaryMetricName = "PrimaryMetricName"
            case startTime = "StartTime"
        }
    }

    public struct AnomalyGroupStatistics: AWSDecodableShape {
        /// The start of the time range that was searched.
        public let evaluationStartDate: String?
        /// Statistics for individual metrics within the group.
        public let itemizedMetricStatsList: [ItemizedMetricStats]?
        /// The number of groups found.
        public let totalCount: Int?

        public init(evaluationStartDate: String? = nil, itemizedMetricStatsList: [ItemizedMetricStats]? = nil, totalCount: Int? = nil) {
            self.evaluationStartDate = evaluationStartDate
            self.itemizedMetricStatsList = itemizedMetricStatsList
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationStartDate = "EvaluationStartDate"
            case itemizedMetricStatsList = "ItemizedMetricStatsList"
            case totalCount = "TotalCount"
        }
    }

    public struct AnomalyGroupSummary: AWSDecodableShape {
        /// The ID of the anomaly group.
        public let anomalyGroupId: String?
        /// The severity score of the group.
        public let anomalyGroupScore: Double?
        /// The end time for the group.
        public let endTime: String?
        /// The name of the primary affected measure for the group.
        public let primaryMetricName: String?
        /// The start time for the group.
        public let startTime: String?

        public init(anomalyGroupId: String? = nil, anomalyGroupScore: Double? = nil, endTime: String? = nil, primaryMetricName: String? = nil, startTime: String? = nil) {
            self.anomalyGroupId = anomalyGroupId
            self.anomalyGroupScore = anomalyGroupScore
            self.endTime = endTime
            self.primaryMetricName = primaryMetricName
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupId = "AnomalyGroupId"
            case anomalyGroupScore = "AnomalyGroupScore"
            case endTime = "EndTime"
            case primaryMetricName = "PrimaryMetricName"
            case startTime = "StartTime"
        }
    }

    public struct AnomalyGroupTimeSeries: AWSEncodableShape {
        /// The ID of the anomaly group.
        public let anomalyGroupId: String
        /// The ID of the metric.
        public let timeSeriesId: String?

        public init(anomalyGroupId: String, timeSeriesId: String? = nil) {
            self.anomalyGroupId = anomalyGroupId
            self.timeSeriesId = timeSeriesId
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, max: 63)
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, pattern: "[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}")
            try self.validate(self.timeSeriesId, name: "timeSeriesId", parent: name, max: 520)
            try self.validate(self.timeSeriesId, name: "timeSeriesId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupId = "AnomalyGroupId"
            case timeSeriesId = "TimeSeriesId"
        }
    }

    public struct AnomalyGroupTimeSeriesFeedback: AWSEncodableShape {
        /// The ID of the anomaly group.
        public let anomalyGroupId: String
        /// Feedback on whether the metric is a legitimate anomaly.
        public let isAnomaly: Bool
        /// The ID of the metric.
        public let timeSeriesId: String

        public init(anomalyGroupId: String, isAnomaly: Bool, timeSeriesId: String) {
            self.anomalyGroupId = anomalyGroupId
            self.isAnomaly = isAnomaly
            self.timeSeriesId = timeSeriesId
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, max: 63)
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, pattern: "[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}")
            try self.validate(self.timeSeriesId, name: "timeSeriesId", parent: name, max: 520)
            try self.validate(self.timeSeriesId, name: "timeSeriesId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupId = "AnomalyGroupId"
            case isAnomaly = "IsAnomaly"
            case timeSeriesId = "TimeSeriesId"
        }
    }

    public struct AppFlowConfig: AWSEncodableShape & AWSDecodableShape {
        ///  name of the flow.
        public let flowName: String
        /// An IAM role that gives Amazon Lookout for Metrics permission to access the flow.
        public let roleArn: String

        public init(flowName: String, roleArn: String) {
            self.flowName = flowName
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName = "FlowName"
            case roleArn = "RoleArn"
        }
    }

    public struct BackTestAnomalyDetectorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String

        public init(anomalyDetectorArn: String) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct BackTestAnomalyDetectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CloudWatchConfig: AWSEncodableShape & AWSDecodableShape {
        /// An IAM role that gives Amazon Lookout for Metrics permission to access data in Amazon CloudWatch.
        public let roleArn: String

        public init(roleArn: String) {
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
        }
    }

    public struct ContributionMatrix: AWSDecodableShape {
        /// A list of contributing dimensions.
        public let dimensionContributionList: [DimensionContribution]?

        public init(dimensionContributionList: [DimensionContribution]? = nil) {
            self.dimensionContributionList = dimensionContributionList
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionContributionList = "DimensionContributionList"
        }
    }

    public struct CreateAlertRequest: AWSEncodableShape {
        /// Action that will be triggered when there is an alert.
        public let action: Action
        /// A description of the alert.
        public let alertDescription: String?
        /// The name of the alert.
        public let alertName: String
        /// An integer from 0 to 100 specifying the alert sensitivity threshold.
        public let alertSensitivityThreshold: Int
        /// The ARN of the detector to which the alert is attached.
        public let anomalyDetectorArn: String
        /// A list of tags to apply to the alert.
        public let tags: [String: String]?

        public init(action: Action, alertDescription: String? = nil, alertName: String, alertSensitivityThreshold: Int, anomalyDetectorArn: String, tags: [String: String]? = nil) {
            self.action = action
            self.alertDescription = alertDescription
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.anomalyDetectorArn = anomalyDetectorArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.validate(self.alertDescription, name: "alertDescription", parent: name, max: 256)
            try self.validate(self.alertDescription, name: "alertDescription", parent: name, pattern: ".*\\S.*")
            try self.validate(self.alertName, name: "alertName", parent: name, max: 63)
            try self.validate(self.alertName, name: "alertName", parent: name, min: 1)
            try self.validate(self.alertName, name: "alertName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.validate(self.alertSensitivityThreshold, name: "alertSensitivityThreshold", parent: name, max: 100)
            try self.validate(self.alertSensitivityThreshold, name: "alertSensitivityThreshold", parent: name, min: 0)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case alertDescription = "AlertDescription"
            case alertName = "AlertName"
            case alertSensitivityThreshold = "AlertSensitivityThreshold"
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case tags = "Tags"
        }
    }

    public struct CreateAlertResponse: AWSDecodableShape {
        /// The ARN of the alert.
        public let alertArn: String?

        public init(alertArn: String? = nil) {
            self.alertArn = alertArn
        }

        private enum CodingKeys: String, CodingKey {
            case alertArn = "AlertArn"
        }
    }

    public struct CreateAnomalyDetectorRequest: AWSEncodableShape {
        /// Contains information about the configuration of the anomaly detector.
        public let anomalyDetectorConfig: AnomalyDetectorConfig
        /// A description of the detector.
        public let anomalyDetectorDescription: String?
        /// The name of the detector.
        public let anomalyDetectorName: String
        /// The ARN of the KMS key to use to encrypt your data.
        public let kmsKeyArn: String?
        /// A list of tags to apply to the anomaly detector.
        public let tags: [String: String]?

        public init(anomalyDetectorConfig: AnomalyDetectorConfig, anomalyDetectorDescription: String? = nil, anomalyDetectorName: String, kmsKeyArn: String? = nil, tags: [String: String]? = nil) {
            self.anomalyDetectorConfig = anomalyDetectorConfig
            self.anomalyDetectorDescription = anomalyDetectorDescription
            self.anomalyDetectorName = anomalyDetectorName
            self.kmsKeyArn = kmsKeyArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, max: 256)
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, min: 1)
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, pattern: ".*\\S.*")
            try self.validate(self.anomalyDetectorName, name: "anomalyDetectorName", parent: name, max: 63)
            try self.validate(self.anomalyDetectorName, name: "anomalyDetectorName", parent: name, min: 1)
            try self.validate(self.anomalyDetectorName, name: "anomalyDetectorName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "arn:aws.*:kms:.*:[0-9]{12}:key/[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorConfig = "AnomalyDetectorConfig"
            case anomalyDetectorDescription = "AnomalyDetectorDescription"
            case anomalyDetectorName = "AnomalyDetectorName"
            case kmsKeyArn = "KmsKeyArn"
            case tags = "Tags"
        }
    }

    public struct CreateAnomalyDetectorResponse: AWSDecodableShape {
        /// The ARN of the detector.
        public let anomalyDetectorArn: String?

        public init(anomalyDetectorArn: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct CreateMetricSetRequest: AWSEncodableShape {
        /// The ARN of the anomaly detector that will use the dataset.
        public let anomalyDetectorArn: String
        /// A list of the fields you want to treat as dimensions.
        public let dimensionList: [String]?
        /// A list of metrics that the dataset will contain.
        public let metricList: [Metric]
        /// A description of the dataset you are creating.
        public let metricSetDescription: String?
        /// The frequency with which the source data will be analyzed for anomalies.
        public let metricSetFrequency: Frequency?
        /// The name of the dataset.
        public let metricSetName: String
        /// Contains information about how the source data should be interpreted.
        public let metricSource: MetricSource
        /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3 and Redshift datasources.
        public let offset: Int?
        /// A list of tags to apply to the dataset.
        public let tags: [String: String]?
        /// Contains information about the column used for tracking time in your source data.
        public let timestampColumn: TimestampColumn?
        /// The time zone in which your source data was recorded.
        public let timezone: String?

        public init(anomalyDetectorArn: String, dimensionList: [String]? = nil, metricList: [Metric], metricSetDescription: String? = nil, metricSetFrequency: Frequency? = nil, metricSetName: String, metricSource: MetricSource, offset: Int? = nil, tags: [String: String]? = nil, timestampColumn: TimestampColumn? = nil, timezone: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.dimensionList = dimensionList
            self.metricList = metricList
            self.metricSetDescription = metricSetDescription
            self.metricSetFrequency = metricSetFrequency
            self.metricSetName = metricSetName
            self.metricSource = metricSource
            self.offset = offset
            self.tags = tags
            self.timestampColumn = timestampColumn
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.dimensionList?.forEach {
                try validate($0, name: "dimensionList[]", parent: name, max: 63)
                try validate($0, name: "dimensionList[]", parent: name, min: 1)
                try validate($0, name: "dimensionList[]", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            }
            try self.validate(self.dimensionList, name: "dimensionList", parent: name, min: 1)
            try self.metricList.forEach {
                try $0.validate(name: "\(name).metricList[]")
            }
            try self.validate(self.metricList, name: "metricList", parent: name, min: 1)
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, max: 256)
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, min: 1)
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, pattern: ".*\\S.*")
            try self.validate(self.metricSetName, name: "metricSetName", parent: name, max: 63)
            try self.validate(self.metricSetName, name: "metricSetName", parent: name, min: 1)
            try self.validate(self.metricSetName, name: "metricSetName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.metricSource.validate(name: "\(name).metricSource")
            try self.validate(self.offset, name: "offset", parent: name, max: 432_000)
            try self.validate(self.offset, name: "offset", parent: name, min: 0)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.timestampColumn?.validate(name: "\(name).timestampColumn")
            try self.validate(self.timezone, name: "timezone", parent: name, max: 60)
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case dimensionList = "DimensionList"
            case metricList = "MetricList"
            case metricSetDescription = "MetricSetDescription"
            case metricSetFrequency = "MetricSetFrequency"
            case metricSetName = "MetricSetName"
            case metricSource = "MetricSource"
            case offset = "Offset"
            case tags = "Tags"
            case timestampColumn = "TimestampColumn"
            case timezone = "Timezone"
        }
    }

    public struct CreateMetricSetResponse: AWSDecodableShape {
        /// The ARN of the dataset.
        public let metricSetArn: String?

        public init(metricSetArn: String? = nil) {
            self.metricSetArn = metricSetArn
        }

        private enum CodingKeys: String, CodingKey {
            case metricSetArn = "MetricSetArn"
        }
    }

    public struct CsvFormatDescriptor: AWSEncodableShape & AWSDecodableShape {
        /// The character set in which the source CSV file is written.
        public let charset: String?
        /// Whether or not the source CSV file contains a header.
        public let containsHeader: Bool?
        /// The character used to delimit the source CSV file.
        public let delimiter: String?
        /// The level of compression of the source CSV file.
        public let fileCompression: CSVFileCompression?
        /// A list of the source CSV file's headers, if any.
        public let headerList: [String]?
        /// The character used as a quote character.
        public let quoteSymbol: String?

        public init(charset: String? = nil, containsHeader: Bool? = nil, delimiter: String? = nil, fileCompression: CSVFileCompression? = nil, headerList: [String]? = nil, quoteSymbol: String? = nil) {
            self.charset = charset
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.fileCompression = fileCompression
            self.headerList = headerList
            self.quoteSymbol = quoteSymbol
        }

        public func validate(name: String) throws {
            try self.validate(self.charset, name: "charset", parent: name, max: 63)
            try self.validate(self.charset, name: "charset", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, pattern: "[^\\r\\n]")
            try self.headerList?.forEach {
                try validate($0, name: "headerList[]", parent: name, max: 63)
                try validate($0, name: "headerList[]", parent: name, min: 1)
                try validate($0, name: "headerList[]", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            }
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, max: 1)
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, pattern: "[^\\r\\n]|^$")
        }

        private enum CodingKeys: String, CodingKey {
            case charset = "Charset"
            case containsHeader = "ContainsHeader"
            case delimiter = "Delimiter"
            case fileCompression = "FileCompression"
            case headerList = "HeaderList"
            case quoteSymbol = "QuoteSymbol"
        }
    }

    public struct DeleteAlertRequest: AWSEncodableShape {
        /// The ARN of the alert to delete.
        public let alertArn: String

        public init(alertArn: String) {
            self.alertArn = alertArn
        }

        public func validate(name: String) throws {
            try self.validate(self.alertArn, name: "alertArn", parent: name, max: 256)
            try self.validate(self.alertArn, name: "alertArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case alertArn = "AlertArn"
        }
    }

    public struct DeleteAlertResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAnomalyDetectorRequest: AWSEncodableShape {
        /// The ARN of the detector to delete.
        public let anomalyDetectorArn: String

        public init(anomalyDetectorArn: String) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct DeleteAnomalyDetectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeAlertRequest: AWSEncodableShape {
        /// The ARN of the alert to describe.
        public let alertArn: String

        public init(alertArn: String) {
            self.alertArn = alertArn
        }

        public func validate(name: String) throws {
            try self.validate(self.alertArn, name: "alertArn", parent: name, max: 256)
            try self.validate(self.alertArn, name: "alertArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case alertArn = "AlertArn"
        }
    }

    public struct DescribeAlertResponse: AWSDecodableShape {
        /// Contains information about an alert.
        public let alert: Alert?

        public init(alert: Alert? = nil) {
            self.alert = alert
        }

        private enum CodingKeys: String, CodingKey {
            case alert = "Alert"
        }
    }

    public struct DescribeAnomalyDetectionExecutionsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The timestamp of the anomaly detection job.
        public let timestamp: String?

        public init(anomalyDetectorArn: String, maxResults: Int? = nil, nextToken: String? = nil, timestamp: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.timestamp = timestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
            try self.validate(self.timestamp, name: "timestamp", parent: name, max: 60)
            try self.validate(self.timestamp, name: "timestamp", parent: name, pattern: "^([12]\\d{3})-(1[0-2]|0[1-9])-(0[1-9]|[12]\\d|3[01])T([01]\\d|2[0-3]):([0-5]\\d):([0-5]\\d)(Z|(\\+|\\-)(0\\d|1[0-2]):([0-5]\\d)(\\[[[:alnum:]\\/\\_]+\\])?)$")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case timestamp = "Timestamp"
        }
    }

    public struct DescribeAnomalyDetectionExecutionsResponse: AWSDecodableShape {
        /// A list of detection jobs.
        public let executionList: [ExecutionStatus]?
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        public init(executionList: [ExecutionStatus]? = nil, nextToken: String? = nil) {
            self.executionList = executionList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case executionList = "ExecutionList"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAnomalyDetectorRequest: AWSEncodableShape {
        /// The ARN of the detector to describe.
        public let anomalyDetectorArn: String

        public init(anomalyDetectorArn: String) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct DescribeAnomalyDetectorResponse: AWSDecodableShape {
        /// The ARN of the detector.
        public let anomalyDetectorArn: String?
        /// Contains information about the detector's configuration.
        public let anomalyDetectorConfig: AnomalyDetectorConfigSummary?
        /// A description of the detector.
        public let anomalyDetectorDescription: String?
        /// The name of the detector.
        public let anomalyDetectorName: String?
        /// The time at which the detector was created.
        public let creationTime: Date?
        /// The reason that the detector failed, if any.
        public let failureReason: String?
        /// The ARN of the KMS key to use to encrypt your data.
        public let kmsKeyArn: String?
        /// The time at which the detector was last modified.
        public let lastModificationTime: Date?
        /// The status of the detector.
        public let status: AnomalyDetectorStatus?

        public init(anomalyDetectorArn: String? = nil, anomalyDetectorConfig: AnomalyDetectorConfigSummary? = nil, anomalyDetectorDescription: String? = nil, anomalyDetectorName: String? = nil, creationTime: Date? = nil, failureReason: String? = nil, kmsKeyArn: String? = nil, lastModificationTime: Date? = nil, status: AnomalyDetectorStatus? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyDetectorConfig = anomalyDetectorConfig
            self.anomalyDetectorDescription = anomalyDetectorDescription
            self.anomalyDetectorName = anomalyDetectorName
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.kmsKeyArn = kmsKeyArn
            self.lastModificationTime = lastModificationTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyDetectorConfig = "AnomalyDetectorConfig"
            case anomalyDetectorDescription = "AnomalyDetectorDescription"
            case anomalyDetectorName = "AnomalyDetectorName"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case kmsKeyArn = "KmsKeyArn"
            case lastModificationTime = "LastModificationTime"
            case status = "Status"
        }
    }

    public struct DescribeMetricSetRequest: AWSEncodableShape {
        /// The ARN of the dataset.
        public let metricSetArn: String

        public init(metricSetArn: String) {
            self.metricSetArn = metricSetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.metricSetArn, name: "metricSetArn", parent: name, max: 256)
            try self.validate(self.metricSetArn, name: "metricSetArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case metricSetArn = "MetricSetArn"
        }
    }

    public struct DescribeMetricSetResponse: AWSDecodableShape {
        /// The ARN of the detector that contains the dataset.
        public let anomalyDetectorArn: String?
        /// The time at which the dataset was created.
        public let creationTime: Date?
        /// A list of the dimensions chosen for analysis.
        public let dimensionList: [String]?
        /// The time at which the dataset was last modified.
        public let lastModificationTime: Date?
        /// A list of the metrics defined by the dataset.
        public let metricList: [Metric]?
        /// The ARN of the dataset.
        public let metricSetArn: String?
        /// The dataset's description.
        public let metricSetDescription: String?
        /// The interval at which the data will be analyzed for anomalies.
        public let metricSetFrequency: Frequency?
        /// The name of the dataset.
        public let metricSetName: String?
        /// Contains information about the dataset's source data.
        public let metricSource: MetricSource?
        /// The offset in seconds. Only supported for S3 and Redshift datasources.
        public let offset: Int?
        /// Contains information about the column used for tracking time in your source data.
        public let timestampColumn: TimestampColumn?
        /// The time zone in which the dataset's data was recorded.
        public let timezone: String?

        public init(anomalyDetectorArn: String? = nil, creationTime: Date? = nil, dimensionList: [String]? = nil, lastModificationTime: Date? = nil, metricList: [Metric]? = nil, metricSetArn: String? = nil, metricSetDescription: String? = nil, metricSetFrequency: Frequency? = nil, metricSetName: String? = nil, metricSource: MetricSource? = nil, offset: Int? = nil, timestampColumn: TimestampColumn? = nil, timezone: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.dimensionList = dimensionList
            self.lastModificationTime = lastModificationTime
            self.metricList = metricList
            self.metricSetArn = metricSetArn
            self.metricSetDescription = metricSetDescription
            self.metricSetFrequency = metricSetFrequency
            self.metricSetName = metricSetName
            self.metricSource = metricSource
            self.offset = offset
            self.timestampColumn = timestampColumn
            self.timezone = timezone
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case creationTime = "CreationTime"
            case dimensionList = "DimensionList"
            case lastModificationTime = "LastModificationTime"
            case metricList = "MetricList"
            case metricSetArn = "MetricSetArn"
            case metricSetDescription = "MetricSetDescription"
            case metricSetFrequency = "MetricSetFrequency"
            case metricSetName = "MetricSetName"
            case metricSource = "MetricSource"
            case offset = "Offset"
            case timestampColumn = "TimestampColumn"
            case timezone = "Timezone"
        }
    }

    public struct DimensionContribution: AWSDecodableShape {
        /// The name of the dimension.
        public let dimensionName: String?
        /// A list of dimension values that contributed to the anomaly.
        public let dimensionValueContributionList: [DimensionValueContribution]?

        public init(dimensionName: String? = nil, dimensionValueContributionList: [DimensionValueContribution]? = nil) {
            self.dimensionName = dimensionName
            self.dimensionValueContributionList = dimensionValueContributionList
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionName = "DimensionName"
            case dimensionValueContributionList = "DimensionValueContributionList"
        }
    }

    public struct DimensionNameValue: AWSDecodableShape {
        /// The name of the dimension.
        public let dimensionName: String
        /// The value of the dimension.
        public let dimensionValue: String

        public init(dimensionName: String, dimensionValue: String) {
            self.dimensionName = dimensionName
            self.dimensionValue = dimensionValue
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionName = "DimensionName"
            case dimensionValue = "DimensionValue"
        }
    }

    public struct DimensionValueContribution: AWSDecodableShape {
        /// The severity score of the value.
        public let contributionScore: Double?
        /// The value of the dimension.
        public let dimensionValue: String?

        public init(contributionScore: Double? = nil, dimensionValue: String? = nil) {
            self.contributionScore = contributionScore
            self.dimensionValue = dimensionValue
        }

        private enum CodingKeys: String, CodingKey {
            case contributionScore = "ContributionScore"
            case dimensionValue = "DimensionValue"
        }
    }

    public struct ExecutionStatus: AWSDecodableShape {
        /// The reason that the run failed, if applicable.
        public let failureReason: String?
        /// The run's status.
        public let status: AnomalyDetectionTaskStatus?
        /// The run's timestamp.
        public let timestamp: String?

        public init(failureReason: String? = nil, status: AnomalyDetectionTaskStatus? = nil, timestamp: String? = nil) {
            self.failureReason = failureReason
            self.status = status
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "FailureReason"
            case status = "Status"
            case timestamp = "Timestamp"
        }
    }

    public struct FileFormatDescriptor: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about how a source CSV data file should be analyzed.
        public let csvFormatDescriptor: CsvFormatDescriptor?
        /// Contains information about how a source JSON data file should be analyzed.
        public let jsonFormatDescriptor: JsonFormatDescriptor?

        public init(csvFormatDescriptor: CsvFormatDescriptor? = nil, jsonFormatDescriptor: JsonFormatDescriptor? = nil) {
            self.csvFormatDescriptor = csvFormatDescriptor
            self.jsonFormatDescriptor = jsonFormatDescriptor
        }

        public func validate(name: String) throws {
            try self.csvFormatDescriptor?.validate(name: "\(name).csvFormatDescriptor")
            try self.jsonFormatDescriptor?.validate(name: "\(name).jsonFormatDescriptor")
        }

        private enum CodingKeys: String, CodingKey {
            case csvFormatDescriptor = "CsvFormatDescriptor"
            case jsonFormatDescriptor = "JsonFormatDescriptor"
        }
    }

    public struct GetAnomalyGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// The ID of the anomaly group.
        public let anomalyGroupId: String

        public init(anomalyDetectorArn: String, anomalyGroupId: String) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyGroupId = anomalyGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, max: 63)
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, pattern: "[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyGroupId = "AnomalyGroupId"
        }
    }

    public struct GetAnomalyGroupResponse: AWSDecodableShape {
        /// Details about the anomaly group.
        public let anomalyGroup: AnomalyGroup?

        public init(anomalyGroup: AnomalyGroup? = nil) {
            self.anomalyGroup = anomalyGroup
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroup = "AnomalyGroup"
        }
    }

    public struct GetFeedbackRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// The anomalous metric and group ID.
        public let anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeries
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(anomalyDetectorArn: String, anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeries, maxResults: Int? = nil, nextToken: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.anomalyGroupTimeSeriesFeedback.validate(name: "\(name).anomalyGroupTimeSeriesFeedback")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetFeedbackResponse: AWSDecodableShape {
        /// Feedback for an anomalous metric.
        public let anomalyGroupTimeSeriesFeedback: [TimeSeriesFeedback]?
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        public init(anomalyGroupTimeSeriesFeedback: [TimeSeriesFeedback]? = nil, nextToken: String? = nil) {
            self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
            case nextToken = "NextToken"
        }
    }

    public struct GetSampleDataRequest: AWSEncodableShape {
        /// A datasource bucket in Amazon S3.
        public let s3SourceConfig: SampleDataS3SourceConfig?

        public init(s3SourceConfig: SampleDataS3SourceConfig? = nil) {
            self.s3SourceConfig = s3SourceConfig
        }

        public func validate(name: String) throws {
            try self.s3SourceConfig?.validate(name: "\(name).s3SourceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case s3SourceConfig = "S3SourceConfig"
        }
    }

    public struct GetSampleDataResponse: AWSDecodableShape {
        /// A list of header labels for the records.
        public let headerValues: [String]?
        /// A list of records.
        public let sampleRows: [[String]]?

        public init(headerValues: [String]? = nil, sampleRows: [[String]]? = nil) {
            self.headerValues = headerValues
            self.sampleRows = sampleRows
        }

        private enum CodingKeys: String, CodingKey {
            case headerValues = "HeaderValues"
            case sampleRows = "SampleRows"
        }
    }

    public struct ItemizedMetricStats: AWSDecodableShape {
        /// The name of the measure.
        public let metricName: String?
        /// The number of times that the measure appears.
        public let occurrenceCount: Int?

        public init(metricName: String? = nil, occurrenceCount: Int? = nil) {
            self.metricName = metricName
            self.occurrenceCount = occurrenceCount
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case occurrenceCount = "OccurrenceCount"
        }
    }

    public struct JsonFormatDescriptor: AWSEncodableShape & AWSDecodableShape {
        /// The character set in which the source JSON file is written.
        public let charset: String?
        /// The level of compression of the source CSV file.
        public let fileCompression: JsonFileCompression?

        public init(charset: String? = nil, fileCompression: JsonFileCompression? = nil) {
            self.charset = charset
            self.fileCompression = fileCompression
        }

        public func validate(name: String) throws {
            try self.validate(self.charset, name: "charset", parent: name, max: 63)
            try self.validate(self.charset, name: "charset", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case charset = "Charset"
            case fileCompression = "FileCompression"
        }
    }

    public struct LambdaConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function.
        public let lambdaArn: String
        /// The ARN of an IAM role that has permission to invoke the Lambda function.
        public let roleArn: String

        public init(lambdaArn: String, roleArn: String) {
            self.lambdaArn = lambdaArn
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 256)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaArn = "LambdaArn"
            case roleArn = "RoleArn"
        }
    }

    public struct ListAlertsRequest: AWSEncodableShape {
        /// The ARN of the alert's detector.
        public let anomalyDetectorArn: String?
        /// The maximum number of results that will be displayed by the request.
        public let maxResults: Int?
        /// If the result of the previous request is truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(anomalyDetectorArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListAlertsResponse: AWSDecodableShape {
        /// Contains information about an alert.
        public let alertSummaryList: [AlertSummary]?
        /// If the response is truncated, the service returns this token. To retrieve the next set of results, use this token in the next request.
        public let nextToken: String?

        public init(alertSummaryList: [AlertSummary]? = nil, nextToken: String? = nil) {
            self.alertSummaryList = alertSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case alertSummaryList = "AlertSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalyDetectorsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalyDetectorsResponse: AWSDecodableShape {
        /// A list of anomaly detectors in the account in the current region.
        public let anomalyDetectorSummaryList: [AnomalyDetectorSummary]?
        /// If the response is truncated, the service returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(anomalyDetectorSummaryList: [AnomalyDetectorSummary]? = nil, nextToken: String? = nil) {
            self.anomalyDetectorSummaryList = anomalyDetectorSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorSummaryList = "AnomalyDetectorSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalyGroupSummariesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The minimum severity score for inclusion in the output.
        public let sensitivityThreshold: Int

        public init(anomalyDetectorArn: String, maxResults: Int? = nil, nextToken: String? = nil, sensitivityThreshold: Int) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sensitivityThreshold = sensitivityThreshold
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
            try self.validate(self.sensitivityThreshold, name: "sensitivityThreshold", parent: name, max: 100)
            try self.validate(self.sensitivityThreshold, name: "sensitivityThreshold", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sensitivityThreshold = "SensitivityThreshold"
        }
    }

    public struct ListAnomalyGroupSummariesResponse: AWSDecodableShape {
        /// Aggregated details about the anomaly groups.
        public let anomalyGroupStatistics: AnomalyGroupStatistics?
        /// A list of anomaly group summaries.
        public let anomalyGroupSummaryList: [AnomalyGroupSummary]?
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        public init(anomalyGroupStatistics: AnomalyGroupStatistics? = nil, anomalyGroupSummaryList: [AnomalyGroupSummary]? = nil, nextToken: String? = nil) {
            self.anomalyGroupStatistics = anomalyGroupStatistics
            self.anomalyGroupSummaryList = anomalyGroupSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupStatistics = "AnomalyGroupStatistics"
            case anomalyGroupSummaryList = "AnomalyGroupSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalyGroupTimeSeriesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// The ID of the anomaly group.
        public let anomalyGroupId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The name of the measure field.
        public let metricName: String
        /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(anomalyDetectorArn: String, anomalyGroupId: String, maxResults: Int? = nil, metricName: String, nextToken: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyGroupId = anomalyGroupId
            self.maxResults = maxResults
            self.metricName = metricName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, max: 63)
            try self.validate(self.anomalyGroupId, name: "anomalyGroupId", parent: name, pattern: "[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.metricName, name: "metricName", parent: name, max: 256)
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyGroupId = "AnomalyGroupId"
            case maxResults = "MaxResults"
            case metricName = "MetricName"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalyGroupTimeSeriesResponse: AWSDecodableShape {
        /// The ID of the anomaly group.
        public let anomalyGroupId: String?
        /// The name of the measure field.
        public let metricName: String?
        /// The pagination token that's included if more results are available.
        public let nextToken: String?
        /// A list of anomalous metrics.
        public let timeSeriesList: [TimeSeries]?
        /// Timestamps for the anomalous metrics.
        public let timestampList: [String]?

        public init(anomalyGroupId: String? = nil, metricName: String? = nil, nextToken: String? = nil, timeSeriesList: [TimeSeries]? = nil, timestampList: [String]? = nil) {
            self.anomalyGroupId = anomalyGroupId
            self.metricName = metricName
            self.nextToken = nextToken
            self.timeSeriesList = timeSeriesList
            self.timestampList = timestampList
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyGroupId = "AnomalyGroupId"
            case metricName = "MetricName"
            case nextToken = "NextToken"
            case timeSeriesList = "TimeSeriesList"
            case timestampList = "TimestampList"
        }
    }

    public struct ListMetricSetsRequest: AWSEncodableShape {
        /// The ARN of the anomaly detector containing the metrics sets to list.
        public let anomalyDetectorArn: String?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(anomalyDetectorArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListMetricSetsResponse: AWSDecodableShape {
        /// A list of the datasets in the AWS Region, with configuration details for each.
        public let metricSetSummaryList: [MetricSetSummary]?
        /// If the response is truncated, the list call returns this token. To retrieve the next set of results, use the token in the next list request.
        public let nextToken: String?

        public init(metricSetSummaryList: [MetricSetSummary]? = nil, nextToken: String? = nil) {
            self.metricSetSummaryList = metricSetSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case metricSetSummaryList = "MetricSetSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The resource's Amazon Resource Name (ARN).
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The resource's tags.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct Metric: AWSEncodableShape & AWSDecodableShape {
        /// The function with which the metric is calculated.
        public let aggregationFunction: AggregationFunction
        /// The name of the metric.
        public let metricName: String
        /// The namespace for the metric.
        public let namespace: String?

        public init(aggregationFunction: AggregationFunction, metricName: String, namespace: String? = nil) {
            self.aggregationFunction = aggregationFunction
            self.metricName = metricName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, max: 63)
            try self.validate(self.metricName, name: "metricName", parent: name, min: 1)
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^:].*")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case metricName = "MetricName"
            case namespace = "Namespace"
        }
    }

    public struct MetricLevelImpact: AWSDecodableShape {
        /// Details about the dimensions that contributed to the anomaly.
        public let contributionMatrix: ContributionMatrix?
        /// The name of the measure.
        public let metricName: String?
        /// The number of anomalous metrics for the measure.
        public let numTimeSeries: Int?

        public init(contributionMatrix: ContributionMatrix? = nil, metricName: String? = nil, numTimeSeries: Int? = nil) {
            self.contributionMatrix = contributionMatrix
            self.metricName = metricName
            self.numTimeSeries = numTimeSeries
        }

        private enum CodingKeys: String, CodingKey {
            case contributionMatrix = "ContributionMatrix"
            case metricName = "MetricName"
            case numTimeSeries = "NumTimeSeries"
        }
    }

    public struct MetricSetSummary: AWSDecodableShape {
        /// The ARN of the detector to which the dataset belongs.
        public let anomalyDetectorArn: String?
        /// The time at which the dataset was created.
        public let creationTime: Date?
        /// The time at which the dataset was last modified.
        public let lastModificationTime: Date?
        /// The ARN of the dataset.
        public let metricSetArn: String?
        /// The description of the dataset.
        public let metricSetDescription: String?
        /// The name of the dataset.
        public let metricSetName: String?
        /// The dataset's tags.
        public let tags: [String: String]?

        public init(anomalyDetectorArn: String? = nil, creationTime: Date? = nil, lastModificationTime: Date? = nil, metricSetArn: String? = nil, metricSetDescription: String? = nil, metricSetName: String? = nil, tags: [String: String]? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.metricSetArn = metricSetArn
            self.metricSetDescription = metricSetDescription
            self.metricSetName = metricSetName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case creationTime = "CreationTime"
            case lastModificationTime = "LastModificationTime"
            case metricSetArn = "MetricSetArn"
            case metricSetDescription = "MetricSetDescription"
            case metricSetName = "MetricSetName"
            case tags = "Tags"
        }
    }

    public struct MetricSource: AWSEncodableShape & AWSDecodableShape {
        /// An object containing information about the AppFlow configuration.
        public let appFlowConfig: AppFlowConfig?
        /// An object containing information about the Amazon CloudWatch monitoring configuration.
        public let cloudWatchConfig: CloudWatchConfig?
        /// An object containing information about the Amazon Relational Database Service (RDS) configuration.
        public let rDSSourceConfig: RDSSourceConfig?
        /// An object containing information about the Amazon Redshift database configuration.
        public let redshiftSourceConfig: RedshiftSourceConfig?
        public let s3SourceConfig: S3SourceConfig?

        public init(appFlowConfig: AppFlowConfig? = nil, cloudWatchConfig: CloudWatchConfig? = nil, rDSSourceConfig: RDSSourceConfig? = nil, redshiftSourceConfig: RedshiftSourceConfig? = nil, s3SourceConfig: S3SourceConfig? = nil) {
            self.appFlowConfig = appFlowConfig
            self.cloudWatchConfig = cloudWatchConfig
            self.rDSSourceConfig = rDSSourceConfig
            self.redshiftSourceConfig = redshiftSourceConfig
            self.s3SourceConfig = s3SourceConfig
        }

        public func validate(name: String) throws {
            try self.appFlowConfig?.validate(name: "\(name).appFlowConfig")
            try self.cloudWatchConfig?.validate(name: "\(name).cloudWatchConfig")
            try self.rDSSourceConfig?.validate(name: "\(name).rDSSourceConfig")
            try self.redshiftSourceConfig?.validate(name: "\(name).redshiftSourceConfig")
            try self.s3SourceConfig?.validate(name: "\(name).s3SourceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case appFlowConfig = "AppFlowConfig"
            case cloudWatchConfig = "CloudWatchConfig"
            case rDSSourceConfig = "RDSSourceConfig"
            case redshiftSourceConfig = "RedshiftSourceConfig"
            case s3SourceConfig = "S3SourceConfig"
        }
    }

    public struct PutFeedbackRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the anomaly detector.
        public let anomalyDetectorArn: String
        /// Feedback for an anomalous metric.
        public let anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeriesFeedback

        public init(anomalyDetectorArn: String, anomalyGroupTimeSeriesFeedback: AnomalyGroupTimeSeriesFeedback) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.anomalyGroupTimeSeriesFeedback.validate(name: "\(name).anomalyGroupTimeSeriesFeedback")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
        }
    }

    public struct PutFeedbackResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RDSSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The host name of the database.
        public let databaseHost: String
        /// The name of the RDS database.
        public let databaseName: String
        /// The port number where the database can be accessed.
        public let databasePort: Int
        /// A string identifying the database instance.
        public let dBInstanceIdentifier: String
        /// The Amazon Resource Name (ARN) of the role.
        public let roleArn: String
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager role.
        public let secretManagerArn: String
        /// The name of the table in the database.
        public let tableName: String
        /// An object containing information about the Amazon Virtual Private Cloud (VPC) configuration.
        public let vpcConfiguration: VpcConfiguration

        public init(databaseHost: String, databaseName: String, databasePort: Int, dBInstanceIdentifier: String, roleArn: String, secretManagerArn: String, tableName: String, vpcConfiguration: VpcConfiguration) {
            self.databaseHost = databaseHost
            self.databaseName = databaseName
            self.databasePort = databasePort
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.roleArn = roleArn
            self.secretManagerArn = secretManagerArn
            self.tableName = tableName
            self.vpcConfiguration = vpcConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, max: 253)
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, min: 1)
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, pattern: ".*\\S.*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 64)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[a-zA-Z0-9_.]+")
            try self.validate(self.databasePort, name: "databasePort", parent: name, max: 65535)
            try self.validate(self.databasePort, name: "databasePort", parent: name, min: 1)
            try self.validate(self.dBInstanceIdentifier, name: "dBInstanceIdentifier", parent: name, max: 63)
            try self.validate(self.dBInstanceIdentifier, name: "dBInstanceIdentifier", parent: name, min: 1)
            try self.validate(self.dBInstanceIdentifier, name: "dBInstanceIdentifier", parent: name, pattern: "^[a-zA-Z](?!.*--)(?!.*-$)[0-9a-zA-Z\\-]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.secretManagerArn, name: "secretManagerArn", parent: name, max: 256)
            try self.validate(self.secretManagerArn, name: "secretManagerArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:secret:AmazonLookoutMetrics-.+")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 100)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_.]*$")
            try self.vpcConfiguration.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseHost = "DatabaseHost"
            case databaseName = "DatabaseName"
            case databasePort = "DatabasePort"
            case dBInstanceIdentifier = "DBInstanceIdentifier"
            case roleArn = "RoleArn"
            case secretManagerArn = "SecretManagerArn"
            case tableName = "TableName"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct RedshiftSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// A string identifying the Redshift cluster.
        public let clusterIdentifier: String
        /// The name of the database host.
        public let databaseHost: String
        /// The Redshift database name.
        public let databaseName: String
        /// The port number where the database can be accessed.
        public let databasePort: Int
        /// The Amazon Resource Name (ARN) of the role providing access to the database.
        public let roleArn: String
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager role.
        public let secretManagerArn: String
        /// The table name of the Redshift database.
        public let tableName: String
        /// Contains information about the Amazon Virtual Private Cloud (VPC) configuration.
        public let vpcConfiguration: VpcConfiguration

        public init(clusterIdentifier: String, databaseHost: String, databaseName: String, databasePort: Int, roleArn: String, secretManagerArn: String, tableName: String, vpcConfiguration: VpcConfiguration) {
            self.clusterIdentifier = clusterIdentifier
            self.databaseHost = databaseHost
            self.databaseName = databaseName
            self.databasePort = databasePort
            self.roleArn = roleArn
            self.secretManagerArn = secretManagerArn
            self.tableName = tableName
            self.vpcConfiguration = vpcConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, max: 63)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, min: 1)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^[a-z](?!.*--)(?!.*-$)[0-9a-z\\-]*$")
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, max: 253)
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, min: 1)
            try self.validate(self.databaseHost, name: "databaseHost", parent: name, pattern: ".*\\S.*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 100)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[a-zA-Z0-9_.]+")
            try self.validate(self.databasePort, name: "databasePort", parent: name, max: 65535)
            try self.validate(self.databasePort, name: "databasePort", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.secretManagerArn, name: "secretManagerArn", parent: name, max: 256)
            try self.validate(self.secretManagerArn, name: "secretManagerArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:secret:AmazonLookoutMetrics-.+")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 100)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_.]*$")
            try self.vpcConfiguration.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterIdentifier = "ClusterIdentifier"
            case databaseHost = "DatabaseHost"
            case databaseName = "DatabaseName"
            case databasePort = "DatabasePort"
            case roleArn = "RoleArn"
            case secretManagerArn = "SecretManagerArn"
            case tableName = "TableName"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct S3SourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about a source file's formatting.
        public let fileFormatDescriptor: FileFormatDescriptor?
        /// A list of paths to the historical data files.
        public let historicalDataPathList: [String]?
        /// The ARN of an IAM role that has read and write access permissions to the source S3 bucket.
        public let roleArn: String
        /// A list of templated paths to the source files.
        public let templatedPathList: [String]?

        public init(fileFormatDescriptor: FileFormatDescriptor? = nil, historicalDataPathList: [String]? = nil, roleArn: String, templatedPathList: [String]? = nil) {
            self.fileFormatDescriptor = fileFormatDescriptor
            self.historicalDataPathList = historicalDataPathList
            self.roleArn = roleArn
            self.templatedPathList = templatedPathList
        }

        public func validate(name: String) throws {
            try self.fileFormatDescriptor?.validate(name: "\(name).fileFormatDescriptor")
            try self.historicalDataPathList?.forEach {
                try validate($0, name: "historicalDataPathList[]", parent: name, max: 1024)
                try validate($0, name: "historicalDataPathList[]", parent: name, pattern: "^s3://[a-z0-9].+$")
            }
            try self.validate(self.historicalDataPathList, name: "historicalDataPathList", parent: name, max: 1)
            try self.validate(self.historicalDataPathList, name: "historicalDataPathList", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.templatedPathList?.forEach {
                try validate($0, name: "templatedPathList[]", parent: name, max: 1024)
                try validate($0, name: "templatedPathList[]", parent: name, pattern: "^s3://[a-zA-Z0-9_\\-\\/ {}=]+$")
            }
            try self.validate(self.templatedPathList, name: "templatedPathList", parent: name, max: 1)
            try self.validate(self.templatedPathList, name: "templatedPathList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormatDescriptor = "FileFormatDescriptor"
            case historicalDataPathList = "HistoricalDataPathList"
            case roleArn = "RoleArn"
            case templatedPathList = "TemplatedPathList"
        }
    }

    public struct SNSConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role that has access to the target SNS topic.
        public let roleArn: String
        /// The ARN of the target SNS topic.
        public let snsTopicArn: String

        public init(roleArn: String, snsTopicArn: String) {
            self.roleArn = roleArn
            self.snsTopicArn = snsTopicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, max: 256)
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case snsTopicArn = "SnsTopicArn"
        }
    }

    public struct SampleDataS3SourceConfig: AWSEncodableShape {
        public let fileFormatDescriptor: FileFormatDescriptor
        /// An array of strings containing the historical set of data paths.
        public let historicalDataPathList: [String]?
        /// The Amazon Resource Name (ARN) of the role.
        public let roleArn: String
        /// An array of strings containing the list of templated paths.
        public let templatedPathList: [String]?

        public init(fileFormatDescriptor: FileFormatDescriptor, historicalDataPathList: [String]? = nil, roleArn: String, templatedPathList: [String]? = nil) {
            self.fileFormatDescriptor = fileFormatDescriptor
            self.historicalDataPathList = historicalDataPathList
            self.roleArn = roleArn
            self.templatedPathList = templatedPathList
        }

        public func validate(name: String) throws {
            try self.fileFormatDescriptor.validate(name: "\(name).fileFormatDescriptor")
            try self.historicalDataPathList?.forEach {
                try validate($0, name: "historicalDataPathList[]", parent: name, max: 1024)
                try validate($0, name: "historicalDataPathList[]", parent: name, pattern: "^s3://[a-z0-9].+$")
            }
            try self.validate(self.historicalDataPathList, name: "historicalDataPathList", parent: name, max: 1)
            try self.validate(self.historicalDataPathList, name: "historicalDataPathList", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.templatedPathList?.forEach {
                try validate($0, name: "templatedPathList[]", parent: name, max: 1024)
                try validate($0, name: "templatedPathList[]", parent: name, pattern: "^s3://[a-zA-Z0-9_\\-\\/ {}=]+$")
            }
            try self.validate(self.templatedPathList, name: "templatedPathList", parent: name, max: 1)
            try self.validate(self.templatedPathList, name: "templatedPathList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormatDescriptor = "FileFormatDescriptor"
            case historicalDataPathList = "HistoricalDataPathList"
            case roleArn = "RoleArn"
            case templatedPathList = "TemplatedPathList"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The resource's Amazon Resource Name (ARN).
        public let resourceArn: String
        /// Tags to apply to the resource. Tag keys and values can contain letters, numbers, spaces, and the following symbols: _.:/=+@-
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimeSeries: AWSDecodableShape {
        /// The dimensions of the metric.
        public let dimensionList: [DimensionNameValue]
        /// The values for the metric.
        public let metricValueList: [Double]
        /// The ID of the metric.
        public let timeSeriesId: String

        public init(dimensionList: [DimensionNameValue], metricValueList: [Double], timeSeriesId: String) {
            self.dimensionList = dimensionList
            self.metricValueList = metricValueList
            self.timeSeriesId = timeSeriesId
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionList = "DimensionList"
            case metricValueList = "MetricValueList"
            case timeSeriesId = "TimeSeriesId"
        }
    }

    public struct TimeSeriesFeedback: AWSDecodableShape {
        /// Feedback on whether the metric is a legitimate anomaly.
        public let isAnomaly: Bool?
        /// The ID of the metric.
        public let timeSeriesId: String?

        public init(isAnomaly: Bool? = nil, timeSeriesId: String? = nil) {
            self.isAnomaly = isAnomaly
            self.timeSeriesId = timeSeriesId
        }

        private enum CodingKeys: String, CodingKey {
            case isAnomaly = "IsAnomaly"
            case timeSeriesId = "TimeSeriesId"
        }
    }

    public struct TimestampColumn: AWSEncodableShape & AWSDecodableShape {
        /// The format of the timestamp column.
        public let columnFormat: String?
        /// The name of the timestamp column.
        public let columnName: String?

        public init(columnFormat: String? = nil, columnName: String? = nil) {
            self.columnFormat = columnFormat
            self.columnName = columnName
        }

        public func validate(name: String) throws {
            try self.validate(self.columnFormat, name: "columnFormat", parent: name, max: 63)
            try self.validate(self.columnFormat, name: "columnFormat", parent: name, pattern: ".*\\S.*")
            try self.validate(self.columnName, name: "columnName", parent: name, max: 63)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case columnFormat = "ColumnFormat"
            case columnName = "ColumnName"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The resource's Amazon Resource Name (ARN).
        public let resourceArn: String
        /// Keys to remove from the resource's tags.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAnomalyDetectorRequest: AWSEncodableShape {
        /// The ARN of the detector to update.
        public let anomalyDetectorArn: String
        /// Contains information about the configuration to which the detector will be updated.
        public let anomalyDetectorConfig: AnomalyDetectorConfig?
        /// The updated detector description.
        public let anomalyDetectorDescription: String?
        /// The Amazon Resource Name (ARN) of an AWS KMS encryption key.
        public let kmsKeyArn: String?

        public init(anomalyDetectorArn: String, anomalyDetectorConfig: AnomalyDetectorConfig? = nil, anomalyDetectorDescription: String? = nil, kmsKeyArn: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyDetectorConfig = anomalyDetectorConfig
            self.anomalyDetectorDescription = anomalyDetectorDescription
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, max: 256)
            try self.validate(self.anomalyDetectorArn, name: "anomalyDetectorArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, max: 256)
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, min: 1)
            try self.validate(self.anomalyDetectorDescription, name: "anomalyDetectorDescription", parent: name, pattern: ".*\\S.*")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "arn:aws.*:kms:.*:[0-9]{12}:key/[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
            case anomalyDetectorConfig = "AnomalyDetectorConfig"
            case anomalyDetectorDescription = "AnomalyDetectorDescription"
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public struct UpdateAnomalyDetectorResponse: AWSDecodableShape {
        /// The ARN of the updated detector.
        public let anomalyDetectorArn: String?

        public init(anomalyDetectorArn: String? = nil) {
            self.anomalyDetectorArn = anomalyDetectorArn
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyDetectorArn = "AnomalyDetectorArn"
        }
    }

    public struct UpdateMetricSetRequest: AWSEncodableShape {
        /// The dimension list.
        public let dimensionList: [String]?
        /// The metric list.
        public let metricList: [Metric]?
        /// The ARN of the dataset to update.
        public let metricSetArn: String
        /// The dataset's description.
        public let metricSetDescription: String?
        /// The dataset's interval.
        public let metricSetFrequency: Frequency?
        public let metricSource: MetricSource?
        /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3 and Redshift datasources.
        public let offset: Int?
        /// The timestamp column.
        public let timestampColumn: TimestampColumn?

        public init(dimensionList: [String]? = nil, metricList: [Metric]? = nil, metricSetArn: String, metricSetDescription: String? = nil, metricSetFrequency: Frequency? = nil, metricSource: MetricSource? = nil, offset: Int? = nil, timestampColumn: TimestampColumn? = nil) {
            self.dimensionList = dimensionList
            self.metricList = metricList
            self.metricSetArn = metricSetArn
            self.metricSetDescription = metricSetDescription
            self.metricSetFrequency = metricSetFrequency
            self.metricSource = metricSource
            self.offset = offset
            self.timestampColumn = timestampColumn
        }

        public func validate(name: String) throws {
            try self.dimensionList?.forEach {
                try validate($0, name: "dimensionList[]", parent: name, max: 63)
                try validate($0, name: "dimensionList[]", parent: name, min: 1)
                try validate($0, name: "dimensionList[]", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            }
            try self.validate(self.dimensionList, name: "dimensionList", parent: name, min: 1)
            try self.metricList?.forEach {
                try $0.validate(name: "\(name).metricList[]")
            }
            try self.validate(self.metricList, name: "metricList", parent: name, min: 1)
            try self.validate(self.metricSetArn, name: "metricSetArn", parent: name, max: 256)
            try self.validate(self.metricSetArn, name: "metricSetArn", parent: name, pattern: "arn:([a-z\\d-]+):.*:.*:.*:.+")
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, max: 256)
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, min: 1)
            try self.validate(self.metricSetDescription, name: "metricSetDescription", parent: name, pattern: ".*\\S.*")
            try self.metricSource?.validate(name: "\(name).metricSource")
            try self.validate(self.offset, name: "offset", parent: name, max: 432_000)
            try self.validate(self.offset, name: "offset", parent: name, min: 0)
            try self.timestampColumn?.validate(name: "\(name).timestampColumn")
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionList = "DimensionList"
            case metricList = "MetricList"
            case metricSetArn = "MetricSetArn"
            case metricSetDescription = "MetricSetDescription"
            case metricSetFrequency = "MetricSetFrequency"
            case metricSource = "MetricSource"
            case offset = "Offset"
            case timestampColumn = "TimestampColumn"
        }
    }

    public struct UpdateMetricSetResponse: AWSDecodableShape {
        /// The ARN of the dataset.
        public let metricSetArn: String?

        public init(metricSetArn: String? = nil) {
            self.metricSetArn = metricSetArn
        }

        private enum CodingKeys: String, CodingKey {
            case metricSetArn = "MetricSetArn"
        }
    }

    public struct VpcConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An array of strings containing the list of security groups.
        public let securityGroupIdList: [String]
        /// An array of strings containing the Amazon VPC subnet IDs (e.g., subnet-0bb1c79de3EXAMPLE.
        public let subnetIdList: [String]

        public init(securityGroupIdList: [String], subnetIdList: [String]) {
            self.securityGroupIdList = securityGroupIdList
            self.subnetIdList = subnetIdList
        }

        public func validate(name: String) throws {
            try self.securityGroupIdList.forEach {
                try validate($0, name: "securityGroupIdList[]", parent: name, max: 255)
                try validate($0, name: "securityGroupIdList[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIdList[]", parent: name, pattern: "[-0-9a-zA-Z]+")
            }
            try self.subnetIdList.forEach {
                try validate($0, name: "subnetIdList[]", parent: name, max: 255)
                try validate($0, name: "subnetIdList[]", parent: name, pattern: "[\\-0-9a-zA-Z]+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIdList = "SecurityGroupIdList"
            case subnetIdList = "SubnetIdList"
        }
    }
}
