//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension DevOpsGuru {
    // MARK: Enums

    public enum AnomalySeverity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum AnomalyStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case closed = "CLOSED"
        case ongoing = "ONGOING"
        public var description: String { return self.rawValue }
    }

    public enum AnomalyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case causal = "CAUSAL"
        case contextual = "CONTEXTUAL"
        public var description: String { return self.rawValue }
    }

    public enum CloudWatchMetricDataStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "Complete"
        case internalError = "InternalError"
        case partialData = "PartialData"
        public var description: String { return self.rawValue }
    }

    public enum CloudWatchMetricsStat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case average = "Average"
        case maximum = "Maximum"
        case minimum = "Minimum"
        case p50 = "p50"
        case p90 = "p90"
        case p99 = "p99"
        case sampleCount = "SampleCount"
        case sum = "Sum"
        public var description: String { return self.rawValue }
    }

    public enum CostEstimationServiceResourceState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum CostEstimationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case ongoing = "ONGOING"
        public var description: String { return self.rawValue }
    }

    public enum EventClass: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configChange = "CONFIG_CHANGE"
        case deployment = "DEPLOYMENT"
        case infrastructure = "INFRASTRUCTURE"
        case schemaChange = "SCHEMA_CHANGE"
        case securityChange = "SECURITY_CHANGE"
        public var description: String { return self.rawValue }
    }

    public enum EventDataSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsCloudTrail = "AWS_CLOUD_TRAIL"
        case awsCodeDeploy = "AWS_CODE_DEPLOY"
        public var description: String { return self.rawValue }
    }

    public enum EventSourceOptInStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum InsightFeedbackOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alertTooSensitive = "ALERT_TOO_SENSITIVE"
        case dataIncorrect = "DATA_INCORRECT"
        case dataNoisyAnomaly = "DATA_NOISY_ANOMALY"
        case recommendationUseful = "RECOMMENDATION_USEFUL"
        case validCollection = "VALID_COLLECTION"
        public var description: String { return self.rawValue }
    }

    public enum InsightSeverity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum InsightStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case closed = "CLOSED"
        case ongoing = "ONGOING"
        public var description: String { return self.rawValue }
    }

    public enum InsightType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case proactive = "PROACTIVE"
        case reactive = "REACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum Locale: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deDe = "DE_DE"
        case enGb = "EN_GB"
        case enUs = "EN_US"
        case esEs = "ES_ES"
        case frFr = "FR_FR"
        case itIt = "IT_IT"
        case jaJp = "JA_JP"
        case koKr = "KO_KR"
        case ptBr = "PT_BR"
        case zhCn = "ZH_CN"
        case zhTw = "ZH_TW"
        public var description: String { return self.rawValue }
    }

    public enum LogAnomalyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blockFormat = "BLOCK_FORMAT"
        case format = "FORMAT"
        case httpCode = "HTTP_CODE"
        case keyword = "KEYWORD"
        case keywordToken = "KEYWORD_TOKEN"
        case newFieldName = "NEW_FIELD_NAME"
        case numericalNan = "NUMERICAL_NAN"
        case numericalPoint = "NUMERICAL_POINT"
        public var description: String { return self.rawValue }
    }

    public enum NotificationMessageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case closedInsight = "CLOSED_INSIGHT"
        case newAssociation = "NEW_ASSOCIATION"
        case newInsight = "NEW_INSIGHT"
        case newRecommendation = "NEW_RECOMMENDATION"
        case severityUpgraded = "SEVERITY_UPGRADED"
        public var description: String { return self.rawValue }
    }

    public enum OptInStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationResourceCollectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsAccount = "AWS_ACCOUNT"
        case awsCloudFormation = "AWS_CLOUD_FORMATION"
        case awsService = "AWS_SERVICE"
        case awsTags = "AWS_TAGS"
        public var description: String { return self.rawValue }
    }

    public enum ResourceCollectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsCloudFormation = "AWS_CLOUD_FORMATION"
        case awsService = "AWS_SERVICE"
        case awsTags = "AWS_TAGS"
        public var description: String { return self.rawValue }
    }

    public enum ResourcePermission: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fullPermission = "FULL_PERMISSION"
        case missingPermission = "MISSING_PERMISSION"
        public var description: String { return self.rawValue }
    }

    public enum ResourceTypeFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudfrontDistribution = "CLOUDFRONT_DISTRIBUTION"
        case dynamodbTable = "DYNAMODB_TABLE"
        case ec2NatGateway = "EC2_NAT_GATEWAY"
        case ecsCluster = "ECS_CLUSTER"
        case ecsService = "ECS_SERVICE"
        case eksCluster = "EKS_CLUSTER"
        case elasticBeanstalkEnvironment = "ELASTIC_BEANSTALK_ENVIRONMENT"
        case elasticLoadBalancerLoadBalancer = "ELASTIC_LOAD_BALANCER_LOAD_BALANCER"
        case elasticLoadBalancingV2LoadBalancer = "ELASTIC_LOAD_BALANCING_V2_LOAD_BALANCER"
        case elasticLoadBalancingV2TargetGroup = "ELASTIC_LOAD_BALANCING_V2_TARGET_GROUP"
        case elasticacheCacheCluster = "ELASTICACHE_CACHE_CLUSTER"
        case elasticsearchDomain = "ELASTICSEARCH_DOMAIN"
        case kinesisStream = "KINESIS_STREAM"
        case lambdaFunction = "LAMBDA_FUNCTION"
        case logGroups = "LOG_GROUPS"
        case openSearchServiceDomain = "OPEN_SEARCH_SERVICE_DOMAIN"
        case rdsDbCluster = "RDS_DB_CLUSTER"
        case rdsDbInstance = "RDS_DB_INSTANCE"
        case redshiftCluster = "REDSHIFT_CLUSTER"
        case route53HealthCheck = "ROUTE53_HEALTH_CHECK"
        case route53HostedZone = "ROUTE53_HOSTED_ZONE"
        case s3Bucket = "S3_BUCKET"
        case sagemakerEndpoint = "SAGEMAKER_ENDPOINT"
        case snsTopic = "SNS_TOPIC"
        case sqsQueue = "SQS_QUEUE"
        case stepFunctionsActivity = "STEP_FUNCTIONS_ACTIVITY"
        case stepFunctionsStateMachine = "STEP_FUNCTIONS_STATE_MACHINE"
        public var description: String { return self.rawValue }
    }

    public enum ServerSideEncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsOwnedKmsKey = "AWS_OWNED_KMS_KEY"
        case customerManagedKey = "CUSTOMER_MANAGED_KEY"
        public var description: String { return self.rawValue }
    }

    public enum ServiceName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case apiGateway = "API_GATEWAY"
        case applicationElb = "APPLICATION_ELB"
        case autoScalingGroup = "AUTO_SCALING_GROUP"
        case cloudFront = "CLOUD_FRONT"
        case dynamoDb = "DYNAMO_DB"
        case ec2 = "EC2"
        case ecs = "ECS"
        case eks = "EKS"
        case elastiCache = "ELASTI_CACHE"
        case elasticBeanstalk = "ELASTIC_BEANSTALK"
        case elb = "ELB"
        case es = "ES"
        case kinesis = "KINESIS"
        case lambda = "LAMBDA"
        case natGateway = "NAT_GATEWAY"
        case networkElb = "NETWORK_ELB"
        case rds = "RDS"
        case redshift = "REDSHIFT"
        case route53 = "ROUTE_53"
        case s3 = "S3"
        case sageMaker = "SAGE_MAKER"
        case sns = "SNS"
        case sqs = "SQS"
        case stepFunctions = "STEP_FUNCTIONS"
        case swf = "SWF"
        public var description: String { return self.rawValue }
    }

    public enum UpdateResourceCollectionAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case add = "ADD"
        case remove = "REMOVE"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CANNOT_PARSE"
        case fieldValidationFailed = "FIELD_VALIDATION_FAILED"
        case invalidParameterCombination = "INVALID_PARAMETER_COMBINATION"
        case other = "OTHER"
        case parameterInconsistentWithServiceState = "PARAMETER_INCONSISTENT_WITH_SERVICE_STATE"
        case unknownOperation = "UNKNOWN_OPERATION"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountHealth: AWSDecodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountId: String?
        ///  Information about the health of the Amazon Web Services resources in your account, including the
        /// 			number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
        ///
        public let insight: AccountInsightHealth?

        @inlinable
        public init(accountId: String? = nil, insight: AccountInsightHealth? = nil) {
            self.accountId = accountId
            self.insight = insight
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case insight = "Insight"
        }
    }

    public struct AccountInsightHealth: AWSDecodableShape {
        /// An integer that specifies the number of open proactive insights in your Amazon Web Services
        /// 			account.
        public let openProactiveInsights: Int?
        /// An integer that specifies the number of open reactive insights in your Amazon Web Services
        /// 			account.
        public let openReactiveInsights: Int?

        @inlinable
        public init(openProactiveInsights: Int? = nil, openReactiveInsights: Int? = nil) {
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case openProactiveInsights = "OpenProactiveInsights"
            case openReactiveInsights = "OpenReactiveInsights"
        }
    }

    public struct AddNotificationChannelRequest: AWSEncodableShape {
        ///  A NotificationChannelConfig object that specifies what type of
        /// 			notification channel to add. The one  	supported notification channel is Amazon Simple Notification Service (Amazon SNS).
        public let config: NotificationChannelConfig

        @inlinable
        public init(config: NotificationChannelConfig) {
            self.config = config
        }

        public func validate(name: String) throws {
            try self.config.validate(name: "\(name).config")
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
        }
    }

    public struct AddNotificationChannelResponse: AWSDecodableShape {
        ///  The ID of the added notification channel.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct AmazonCodeGuruProfilerIntegration: AWSEncodableShape & AWSDecodableShape {
        /// The status of the CodeGuru Profiler integration. Specifies if DevOps Guru is enabled to
        /// 			consume recommendations that are generated from Amazon CodeGuru Profiler.
        public let status: EventSourceOptInStatus?

        @inlinable
        public init(status: EventSourceOptInStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct AnomalousLogGroup: AWSDecodableShape {
        /// 			The time the anomalous log events stopped.
        ///
        public let impactEndTime: Date?
        /// 			The time the anomalous log events began. The impact start time indicates the time of the first log anomaly event that occurs.
        ///
        public let impactStartTime: Date?
        /// 			The log anomalies in the log group. Each log anomaly displayed represents a cluster of similar anomalous log events.
        ///
        public let logAnomalyShowcases: [LogAnomalyShowcase]?
        /// 			The name of the CloudWatch log group.
        ///
        public let logGroupName: String?
        /// 			The number of log lines that were scanned for anomalous log events.
        ///
        public let numberOfLogLinesScanned: Int?

        @inlinable
        public init(impactEndTime: Date? = nil, impactStartTime: Date? = nil, logAnomalyShowcases: [LogAnomalyShowcase]? = nil, logGroupName: String? = nil, numberOfLogLinesScanned: Int? = nil) {
            self.impactEndTime = impactEndTime
            self.impactStartTime = impactStartTime
            self.logAnomalyShowcases = logAnomalyShowcases
            self.logGroupName = logGroupName
            self.numberOfLogLinesScanned = numberOfLogLinesScanned
        }

        private enum CodingKeys: String, CodingKey {
            case impactEndTime = "ImpactEndTime"
            case impactStartTime = "ImpactStartTime"
            case logAnomalyShowcases = "LogAnomalyShowcases"
            case logGroupName = "LogGroupName"
            case numberOfLogLinesScanned = "NumberOfLogLinesScanned"
        }
    }

    public struct AnomalyReportedTimeRange: AWSDecodableShape {
        ///  The time when an anomaly is closed.
        public let closeTime: Date?
        ///  The time when an anomaly is opened.
        public let openTime: Date

        @inlinable
        public init(closeTime: Date? = nil, openTime: Date) {
            self.closeTime = closeTime
            self.openTime = openTime
        }

        private enum CodingKeys: String, CodingKey {
            case closeTime = "CloseTime"
            case openTime = "OpenTime"
        }
    }

    public struct AnomalyResource: AWSDecodableShape {
        /// The name of the Amazon Web Services resource.
        public let name: String?
        /// The type of the Amazon Web Services resource.
        public let type: String?

        @inlinable
        public init(name: String? = nil, type: String? = nil) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct AnomalySourceDetails: AWSDecodableShape {
        /// An array of CloudWatchMetricsDetail objects that contain information
        /// 			about analyzed CloudWatch metrics that show anomalous behavior.
        public let cloudWatchMetrics: [CloudWatchMetricsDetail]?
        /// An array of PerformanceInsightsMetricsDetail objects that contain
        /// 			information about analyzed Performance Insights metrics that show anomalous behavior.
        public let performanceInsightsMetrics: [PerformanceInsightsMetricsDetail]?

        @inlinable
        public init(cloudWatchMetrics: [CloudWatchMetricsDetail]? = nil, performanceInsightsMetrics: [PerformanceInsightsMetricsDetail]? = nil) {
            self.cloudWatchMetrics = cloudWatchMetrics
            self.performanceInsightsMetrics = performanceInsightsMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchMetrics = "CloudWatchMetrics"
            case performanceInsightsMetrics = "PerformanceInsightsMetrics"
        }
    }

    public struct AnomalySourceMetadata: AWSDecodableShape {
        /// The source of the anomaly.
        public let source: String?
        /// The name of the anomaly's resource.
        public let sourceResourceName: String?
        /// The anomaly's resource type.
        public let sourceResourceType: String?

        @inlinable
        public init(source: String? = nil, sourceResourceName: String? = nil, sourceResourceType: String? = nil) {
            self.source = source
            self.sourceResourceName = sourceResourceName
            self.sourceResourceType = sourceResourceType
        }

        private enum CodingKeys: String, CodingKey {
            case source = "Source"
            case sourceResourceName = "SourceResourceName"
            case sourceResourceType = "SourceResourceType"
        }
    }

    public struct AnomalyTimeRange: AWSDecodableShape {
        ///  The time when the anomalous behavior ended.
        public let endTime: Date?
        ///  The time when the anomalous behavior started.
        public let startTime: Date

        @inlinable
        public init(endTime: Date? = nil, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct CloudFormationCollection: AWSEncodableShape & AWSDecodableShape {
        ///  An array of CloudFormation stack names.
        public let stackNames: [String]?

        @inlinable
        public init(stackNames: [String]? = nil) {
            self.stackNames = stackNames
        }

        public func validate(name: String) throws {
            try self.stackNames?.forEach {
                try validate($0, name: "stackNames[]", parent: name, max: 128)
                try validate($0, name: "stackNames[]", parent: name, min: 1)
                try validate($0, name: "stackNames[]", parent: name, pattern: "^[a-zA-Z*]+[a-zA-Z0-9-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case stackNames = "StackNames"
        }
    }

    public struct CloudFormationCollectionFilter: AWSDecodableShape {
        ///  An array of CloudFormation stack names.
        public let stackNames: [String]?

        @inlinable
        public init(stackNames: [String]? = nil) {
            self.stackNames = stackNames
        }

        private enum CodingKeys: String, CodingKey {
            case stackNames = "StackNames"
        }
    }

    public struct CloudFormationCostEstimationResourceCollectionFilter: AWSEncodableShape & AWSDecodableShape {
        /// An array of CloudFormation stack names. Its size is fixed at 1 item.
        public let stackNames: [String]?

        @inlinable
        public init(stackNames: [String]? = nil) {
            self.stackNames = stackNames
        }

        public func validate(name: String) throws {
            try self.stackNames?.forEach {
                try validate($0, name: "stackNames[]", parent: name, max: 128)
                try validate($0, name: "stackNames[]", parent: name, min: 1)
                try validate($0, name: "stackNames[]", parent: name, pattern: "^[a-zA-Z*]+[a-zA-Z0-9-]*$")
            }
            try self.validate(self.stackNames, name: "stackNames", parent: name, max: 1)
            try self.validate(self.stackNames, name: "stackNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stackNames = "StackNames"
        }
    }

    public struct CloudFormationHealth: AWSDecodableShape {
        /// 			Number of resources that DevOps Guru is monitoring in your account that are specified by an Amazon Web Services CloudFormation stack.
        ///
        public let analyzedResourceCount: Int64?
        ///  Information about the health of the Amazon Web Services resources in your account that are
        /// 			specified by an Amazon Web Services CloudFormation stack, including the number of open proactive, open reactive
        /// 			insights, and the Mean Time to Recover (MTTR) of closed insights.
        public let insight: InsightHealth?
        ///  The name of the CloudFormation stack.
        public let stackName: String?

        @inlinable
        public init(analyzedResourceCount: Int64? = nil, insight: InsightHealth? = nil, stackName: String? = nil) {
            self.analyzedResourceCount = analyzedResourceCount
            self.insight = insight
            self.stackName = stackName
        }

        private enum CodingKeys: String, CodingKey {
            case analyzedResourceCount = "AnalyzedResourceCount"
            case insight = "Insight"
            case stackName = "StackName"
        }
    }

    public struct CloudWatchMetricsDataSummary: AWSDecodableShape {
        /// This is an enum of the status showing whether the metric value pair list has partial
        /// 			or complete data, or if there was an error.
        public let statusCode: CloudWatchMetricDataStatusCode?
        /// This is a list of Amazon CloudWatch metric values at given timestamp.
        public let timestampMetricValuePairList: [TimestampMetricValuePair]?

        @inlinable
        public init(statusCode: CloudWatchMetricDataStatusCode? = nil, timestampMetricValuePairList: [TimestampMetricValuePair]? = nil) {
            self.statusCode = statusCode
            self.timestampMetricValuePairList = timestampMetricValuePairList
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "StatusCode"
            case timestampMetricValuePairList = "TimestampMetricValuePairList"
        }
    }

    public struct CloudWatchMetricsDetail: AWSDecodableShape {
        ///  An array of CloudWatch dimensions associated with
        public let dimensions: [CloudWatchMetricsDimension]?
        /// This object returns anomaly metric data.
        public let metricDataSummary: CloudWatchMetricsDataSummary?
        ///  The name of the CloudWatch metric.
        public let metricName: String?
        ///  The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.
        ///
        public let namespace: String?
        ///  The length of time associated with the CloudWatch metric in number of seconds.
        public let period: Int?
        ///  The type of statistic associated with the CloudWatch metric. For more information, see
        /// 				Statistics in the Amazon CloudWatch User Guide.
        public let stat: CloudWatchMetricsStat?
        ///  The unit of measure used for the CloudWatch metric. For example, Bytes,
        /// 				Seconds, Count, and Percent.
        public let unit: String?

        @inlinable
        public init(dimensions: [CloudWatchMetricsDimension]? = nil, metricDataSummary: CloudWatchMetricsDataSummary? = nil, metricName: String? = nil, namespace: String? = nil, period: Int? = nil, stat: CloudWatchMetricsStat? = nil, unit: String? = nil) {
            self.dimensions = dimensions
            self.metricDataSummary = metricDataSummary
            self.metricName = metricName
            self.namespace = namespace
            self.period = period
            self.stat = stat
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case metricDataSummary = "MetricDataSummary"
            case metricName = "MetricName"
            case namespace = "Namespace"
            case period = "Period"
            case stat = "Stat"
            case unit = "Unit"
        }
    }

    public struct CloudWatchMetricsDimension: AWSDecodableShape {
        ///  The name of the CloudWatch dimension.
        public let name: String?
        ///  The value of the CloudWatch dimension.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        ///  The ID of the Amazon Web Services resource in which a conflict occurred.
        public let resourceId: String
        ///  The type of the Amazon Web Services resource in which a conflict occurred.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct CostEstimationResourceCollectionFilter: AWSEncodableShape & AWSDecodableShape {
        /// An object that specifies the CloudFormation stack that defines the Amazon Web Services resources
        /// 			used to create a monthly estimate for DevOps Guru.
        public let cloudFormation: CloudFormationCostEstimationResourceCollectionFilter?
        /// The Amazon Web Services tags used to filter the resource collection that is used for a cost
        /// 			estimate. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support 		tagging, so you can assign the same tag to resources from different services to indicate 		that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB 		table resource that you assign to an Lambda function. For more information about 		using tags, see the Tagging 			best practices whitepaper.  Each Amazon Web Services tag has two parts.    A tag key (for example, CostCenter, 				Environment, Project, or Secret). Tag 				keys are case-sensitive.   An optional field known as a tag value (for example, 				111122223333, Production, or a team 				name). Omitting the tag value is the same as using an empty 				string. Like tag keys, tag values are 				case-sensitive.   Together these are known as key-value pairs.  The string used for a key in a tag that you use to define your resource coverage must begin with the
        /// 			prefix Devops-guru-. The tag key might be
        /// 			DevOps-Guru-deployment-application or
        /// 			devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive.
        /// 			 For example, DevOps Guru works with a
        /// 			key named devops-guru-rds and a key named
        /// 			DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your
        /// 			application might be Devops-Guru-production-application/RDS or
        /// 			Devops-Guru-production-application/containers.
        public let tags: [TagCostEstimationResourceCollectionFilter]?

        @inlinable
        public init(cloudFormation: CloudFormationCostEstimationResourceCollectionFilter? = nil, tags: [TagCostEstimationResourceCollectionFilter]? = nil) {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.cloudFormation?.validate(name: "\(name).cloudFormation")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "CloudFormation"
            case tags = "Tags"
        }
    }

    public struct CostEstimationTimeRange: AWSDecodableShape {
        /// The end time of the cost estimation.
        public let endTime: Date?
        /// The start time of the cost estimation.
        public let startTime: Date?

        @inlinable
        public init(endTime: Date? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct DeleteInsightRequest: AWSEncodableShape {
        /// The ID of the insight.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\w-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInsightResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeAccountHealthRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeAccountHealthResponse: AWSDecodableShape {
        /// 			Number of resources that DevOps Guru is monitoring in your Amazon Web Services account.
        ///
        public let analyzedResourceCount: Int64?
        ///  An integer that specifies the number of metrics that have been analyzed in your Amazon Web Services
        /// 			account.
        public let metricsAnalyzed: Int
        ///  An integer that specifies the number of open proactive insights in your Amazon Web Services
        /// 			account.
        public let openProactiveInsights: Int
        ///  An integer that specifies the number of open reactive insights in your Amazon Web Services account.
        ///
        public let openReactiveInsights: Int
        /// The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in
        /// 			the last hour.
        public let resourceHours: Int64

        @inlinable
        public init(analyzedResourceCount: Int64? = nil, metricsAnalyzed: Int, openProactiveInsights: Int, openReactiveInsights: Int, resourceHours: Int64) {
            self.analyzedResourceCount = analyzedResourceCount
            self.metricsAnalyzed = metricsAnalyzed
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
            self.resourceHours = resourceHours
        }

        private enum CodingKeys: String, CodingKey {
            case analyzedResourceCount = "AnalyzedResourceCount"
            case metricsAnalyzed = "MetricsAnalyzed"
            case openProactiveInsights = "OpenProactiveInsights"
            case openReactiveInsights = "OpenReactiveInsights"
            case resourceHours = "ResourceHours"
        }
    }

    public struct DescribeAccountOverviewRequest: AWSEncodableShape {
        ///  The start of the time range passed in. The start time granularity is at the day
        /// 			level. The floor of the start time is used. Returned information occurred after this
        /// 			day.
        public let fromTime: Date
        ///  The end of the time range passed in. The start time granularity is at the day level.
        /// 			The floor of the start time is used. Returned information occurred before this day. If
        /// 			this is not specified, then the current day is used.
        public let toTime: Date?

        @inlinable
        public init(fromTime: Date, toTime: Date? = nil) {
            self.fromTime = fromTime
            self.toTime = toTime
        }

        private enum CodingKeys: String, CodingKey {
            case fromTime = "FromTime"
            case toTime = "ToTime"
        }
    }

    public struct DescribeAccountOverviewResponse: AWSDecodableShape {
        ///  The Mean Time to Recover (MTTR) for all closed insights that were created during the time range passed in.
        ///
        public let meanTimeToRecoverInMilliseconds: Int64
        ///  An integer that specifies the number of open proactive insights in your Amazon Web Services account
        /// 			that were created during the time range passed in.
        public let proactiveInsights: Int
        ///  An integer that specifies the number of open reactive insights in your Amazon Web Services account
        /// 			that were created during the time range passed in.
        public let reactiveInsights: Int

        @inlinable
        public init(meanTimeToRecoverInMilliseconds: Int64, proactiveInsights: Int, reactiveInsights: Int) {
            self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
            self.proactiveInsights = proactiveInsights
            self.reactiveInsights = reactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case meanTimeToRecoverInMilliseconds = "MeanTimeToRecoverInMilliseconds"
            case proactiveInsights = "ProactiveInsights"
            case reactiveInsights = "ReactiveInsights"
        }
    }

    public struct DescribeAnomalyRequest: AWSEncodableShape {
        /// The ID of the member account.
        public let accountId: String?
        ///  The ID of the anomaly.
        public let id: String

        @inlinable
        public init(accountId: String? = nil, id: String) {
            self.accountId = accountId
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountId, key: "AccountId")
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\w~.-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAnomalyResponse: AWSDecodableShape {
        ///  A ProactiveAnomaly object that represents the requested anomaly.
        public let proactiveAnomaly: ProactiveAnomaly?
        ///  A ReactiveAnomaly object that represents the requested anomaly.
        public let reactiveAnomaly: ReactiveAnomaly?

        @inlinable
        public init(proactiveAnomaly: ProactiveAnomaly? = nil, reactiveAnomaly: ReactiveAnomaly? = nil) {
            self.proactiveAnomaly = proactiveAnomaly
            self.reactiveAnomaly = reactiveAnomaly
        }

        private enum CodingKeys: String, CodingKey {
            case proactiveAnomaly = "ProactiveAnomaly"
            case reactiveAnomaly = "ReactiveAnomaly"
        }
    }

    public struct DescribeEventSourcesConfigRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeEventSourcesConfigResponse: AWSDecodableShape {
        /// Lists the event sources in the configuration.
        public let eventSources: EventSourcesConfig?

        @inlinable
        public init(eventSources: EventSourcesConfig? = nil) {
            self.eventSources = eventSources
        }

        private enum CodingKeys: String, CodingKey {
            case eventSources = "EventSources"
        }
    }

    public struct DescribeFeedbackRequest: AWSEncodableShape {
        ///  The ID of the insight for which the feedback was provided.
        public let insightId: String?

        @inlinable
        public init(insightId: String? = nil) {
            self.insightId = insightId
        }

        public func validate(name: String) throws {
            try self.validate(self.insightId, name: "insightId", parent: name, max: 100)
            try self.validate(self.insightId, name: "insightId", parent: name, min: 1)
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[\\w-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case insightId = "InsightId"
        }
    }

    public struct DescribeFeedbackResponse: AWSDecodableShape {
        public let insightFeedback: InsightFeedback?

        @inlinable
        public init(insightFeedback: InsightFeedback? = nil) {
            self.insightFeedback = insightFeedback
        }

        private enum CodingKeys: String, CodingKey {
            case insightFeedback = "InsightFeedback"
        }
    }

    public struct DescribeInsightRequest: AWSEncodableShape {
        /// The ID of the member account in the organization.
        public let accountId: String?
        ///  The ID of the insight.
        public let id: String

        @inlinable
        public init(accountId: String? = nil, id: String) {
            self.accountId = accountId
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountId, key: "AccountId")
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\w-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeInsightResponse: AWSDecodableShape {
        ///  A ProactiveInsight object that represents the requested insight.
        public let proactiveInsight: ProactiveInsight?
        ///  A ReactiveInsight object that represents the requested insight.
        public let reactiveInsight: ReactiveInsight?

        @inlinable
        public init(proactiveInsight: ProactiveInsight? = nil, reactiveInsight: ReactiveInsight? = nil) {
            self.proactiveInsight = proactiveInsight
            self.reactiveInsight = reactiveInsight
        }

        private enum CodingKeys: String, CodingKey {
            case proactiveInsight = "ProactiveInsight"
            case reactiveInsight = "ReactiveInsight"
        }
    }

    public struct DescribeOrganizationHealthRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountIds: [String]?
        /// The ID of the organizational unit.
        public let organizationalUnitIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil, organizationalUnitIds: [String]? = nil) {
            self.accountIds = accountIds
            self.organizationalUnitIds = organizationalUnitIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 5)
            try self.organizationalUnitIds?.forEach {
                try validate($0, name: "organizationalUnitIds[]", parent: name, max: 68)
                try validate($0, name: "organizationalUnitIds[]", parent: name, pattern: "^ou-[0-9a-z]{4,32}-[a-z0-9]{8,32}$")
            }
            try self.validate(self.organizationalUnitIds, name: "organizationalUnitIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case organizationalUnitIds = "OrganizationalUnitIds"
        }
    }

    public struct DescribeOrganizationHealthResponse: AWSDecodableShape {
        /// An integer that specifies the number of metrics that have been analyzed in your
        /// 			organization.
        public let metricsAnalyzed: Int
        /// An integer that specifies the number of open proactive insights in your Amazon Web Services
        /// 			account.
        public let openProactiveInsights: Int
        /// An integer that specifies the number of open reactive insights in your Amazon Web Services
        /// 			account.
        public let openReactiveInsights: Int
        /// The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in
        /// 			the last hour.
        public let resourceHours: Int64

        @inlinable
        public init(metricsAnalyzed: Int, openProactiveInsights: Int, openReactiveInsights: Int, resourceHours: Int64) {
            self.metricsAnalyzed = metricsAnalyzed
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
            self.resourceHours = resourceHours
        }

        private enum CodingKeys: String, CodingKey {
            case metricsAnalyzed = "MetricsAnalyzed"
            case openProactiveInsights = "OpenProactiveInsights"
            case openReactiveInsights = "OpenReactiveInsights"
            case resourceHours = "ResourceHours"
        }
    }

    public struct DescribeOrganizationOverviewRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountIds: [String]?
        ///  The start of the time range passed in. The start time granularity is at the day
        /// 			level. The floor of the start time is used. Returned information occurred after this
        /// 			day.
        public let fromTime: Date
        /// The ID of the organizational unit.
        public let organizationalUnitIds: [String]?
        ///  The end of the time range passed in. The start time granularity is at the day level.
        /// 			The floor of the start time is used. Returned information occurred before this day. If
        /// 			this is not specified, then the current day is used.
        public let toTime: Date?

        @inlinable
        public init(accountIds: [String]? = nil, fromTime: Date, organizationalUnitIds: [String]? = nil, toTime: Date? = nil) {
            self.accountIds = accountIds
            self.fromTime = fromTime
            self.organizationalUnitIds = organizationalUnitIds
            self.toTime = toTime
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 5)
            try self.organizationalUnitIds?.forEach {
                try validate($0, name: "organizationalUnitIds[]", parent: name, max: 68)
                try validate($0, name: "organizationalUnitIds[]", parent: name, pattern: "^ou-[0-9a-z]{4,32}-[a-z0-9]{8,32}$")
            }
            try self.validate(self.organizationalUnitIds, name: "organizationalUnitIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case fromTime = "FromTime"
            case organizationalUnitIds = "OrganizationalUnitIds"
            case toTime = "ToTime"
        }
    }

    public struct DescribeOrganizationOverviewResponse: AWSDecodableShape {
        /// An integer that specifies the number of open proactive insights in your Amazon Web Services
        /// 			account.
        public let proactiveInsights: Int
        /// An integer that specifies the number of open reactive insights in your Amazon Web Services
        /// 			account.
        public let reactiveInsights: Int

        @inlinable
        public init(proactiveInsights: Int, reactiveInsights: Int) {
            self.proactiveInsights = proactiveInsights
            self.reactiveInsights = reactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case proactiveInsights = "ProactiveInsights"
            case reactiveInsights = "ReactiveInsights"
        }
    }

    public struct DescribeOrganizationResourceCollectionHealthRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountIds: [String]?
        /// The maximum number of results to return with a single call.
        /// 	To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The ID of the organizational unit.
        public let organizationalUnitIds: [String]?
        ///  An Amazon Web Services resource collection type. This type specifies how analyzed Amazon Web Services resources
        /// 			are defined. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and  Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze  	the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public let organizationResourceCollectionType: OrganizationResourceCollectionType

        @inlinable
        public init(accountIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationalUnitIds: [String]? = nil, organizationResourceCollectionType: OrganizationResourceCollectionType) {
            self.accountIds = accountIds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationalUnitIds = organizationalUnitIds
            self.organizationResourceCollectionType = organizationResourceCollectionType
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.organizationalUnitIds?.forEach {
                try validate($0, name: "organizationalUnitIds[]", parent: name, max: 68)
                try validate($0, name: "organizationalUnitIds[]", parent: name, pattern: "^ou-[0-9a-z]{4,32}-[a-z0-9]{8,32}$")
            }
            try self.validate(self.organizationalUnitIds, name: "organizationalUnitIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationalUnitIds = "OrganizationalUnitIds"
            case organizationResourceCollectionType = "OrganizationResourceCollectionType"
        }
    }

    public struct DescribeOrganizationResourceCollectionHealthResponse: AWSDecodableShape {
        /// The name of the organization's account.
        public let account: [AccountHealth]?
        /// The returned CloudFormationHealthOverview object that contains an
        /// 				InsightHealthOverview object with the requested system health
        /// 			information.
        public let cloudFormation: [CloudFormationHealth]?
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// An array of ServiceHealth objects that describes the health of the Amazon Web Services
        /// 			services associated with the resources in the collection.
        public let service: [ServiceHealth]?
        /// Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support 		tagging, so you can assign the same tag to resources from different services to indicate 		that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB 		table resource that you assign to an Lambda function. For more information about 		using tags, see the Tagging 			best practices whitepaper.  Each Amazon Web Services tag has two parts.    A tag key (for example, CostCenter, 				Environment, Project, or Secret). Tag 				keys are case-sensitive.   An optional field known as a tag value (for example, 				111122223333, Production, or a team 				name). Omitting the tag value is the same as using an empty 				string. Like tag keys, tag values are 				case-sensitive.   Together these are known as key-value pairs.  The string used for a key in a tag that you use to define your resource coverage must begin with the
        /// 			prefix Devops-guru-. The tag key might be
        /// 			DevOps-Guru-deployment-application or
        /// 			devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive.
        /// 			 For example, DevOps Guru works with a
        /// 			key named devops-guru-rds and a key named
        /// 			DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your
        /// 			application might be Devops-Guru-production-application/RDS or
        /// 			Devops-Guru-production-application/containers.
        public let tags: [TagHealth]?

        @inlinable
        public init(account: [AccountHealth]? = nil, cloudFormation: [CloudFormationHealth]? = nil, nextToken: String? = nil, service: [ServiceHealth]? = nil, tags: [TagHealth]? = nil) {
            self.account = account
            self.cloudFormation = cloudFormation
            self.nextToken = nextToken
            self.service = service
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case account = "Account"
            case cloudFormation = "CloudFormation"
            case nextToken = "NextToken"
            case service = "Service"
            case tags = "Tags"
        }
    }

    public struct DescribeResourceCollectionHealthRequest: AWSEncodableShape {
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        ///  An Amazon Web Services resource collection type. This type specifies how analyzed Amazon Web Services resources
        /// 			are defined. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and  Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze  	the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public let resourceCollectionType: ResourceCollectionType

        @inlinable
        public init(nextToken: String? = nil, resourceCollectionType: ResourceCollectionType) {
            self.nextToken = nextToken
            self.resourceCollectionType = resourceCollectionType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.resourceCollectionType, key: "ResourceCollectionType")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeResourceCollectionHealthResponse: AWSDecodableShape {
        ///  The returned CloudFormationHealthOverview object that contains an
        /// 				InsightHealthOverview object with the requested system health
        /// 			information.
        public let cloudFormation: [CloudFormationHealth]?
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// An array of ServiceHealth objects that describes the health of the Amazon Web Services
        /// 			services associated with the resources in the collection.
        public let service: [ServiceHealth]?
        /// The Amazon Web Services tags that are used by resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support 		tagging, so you can assign the same tag to resources from different services to indicate 		that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB 		table resource that you assign to an Lambda function. For more information about 		using tags, see the Tagging 			best practices whitepaper.  Each Amazon Web Services tag has two parts.    A tag key (for example, CostCenter, 				Environment, Project, or Secret). Tag 				keys are case-sensitive.   An optional field known as a tag value (for example, 				111122223333, Production, or a team 				name). Omitting the tag value is the same as using an empty 				string. Like tag keys, tag values are 				case-sensitive.   Together these are known as key-value pairs.  The string used for a key in a tag that you use to define your resource coverage must begin with the
        /// 			prefix Devops-guru-. The tag key might be
        /// 			DevOps-Guru-deployment-application or
        /// 			devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive.
        /// 			 For example, DevOps Guru works with a
        /// 			key named devops-guru-rds and a key named
        /// 			DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your
        /// 			application might be Devops-Guru-production-application/RDS or
        /// 			Devops-Guru-production-application/containers.
        public let tags: [TagHealth]?

        @inlinable
        public init(cloudFormation: [CloudFormationHealth]? = nil, nextToken: String? = nil, service: [ServiceHealth]? = nil, tags: [TagHealth]? = nil) {
            self.cloudFormation = cloudFormation
            self.nextToken = nextToken
            self.service = service
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "CloudFormation"
            case nextToken = "NextToken"
            case service = "Service"
            case tags = "Tags"
        }
    }

    public struct DescribeServiceIntegrationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeServiceIntegrationResponse: AWSDecodableShape {
        public let serviceIntegration: ServiceIntegrationConfig?

        @inlinable
        public init(serviceIntegration: ServiceIntegrationConfig? = nil) {
            self.serviceIntegration = serviceIntegration
        }

        private enum CodingKeys: String, CodingKey {
            case serviceIntegration = "ServiceIntegration"
        }
    }

    public struct EndTimeRange: AWSEncodableShape {
        ///  The earliest end time in the time range.
        public let fromTime: Date?
        ///  The latest end time in the time range.
        public let toTime: Date?

        @inlinable
        public init(fromTime: Date? = nil, toTime: Date? = nil) {
            self.fromTime = fromTime
            self.toTime = toTime
        }

        private enum CodingKeys: String, CodingKey {
            case fromTime = "FromTime"
            case toTime = "ToTime"
        }
    }

    public struct Event: AWSDecodableShape {
        ///  The source, AWS_CLOUD_TRAIL or AWS_CODE_DEPLOY, where DevOps Guru
        /// 			analysis found the event.
        public let dataSource: EventDataSource?
        ///  The class of the event. The class specifies what the event is related to, such as an
        /// 			infrastructure change, a deployment, or a schema change.
        public let eventClass: EventClass?
        ///  The Amazon Web Services source that emitted the event.
        public let eventSource: String?
        ///  The ID of the event.
        public let id: String?
        ///  The name of the event.
        public let name: String?
        public let resourceCollection: ResourceCollection?
        ///  An EventResource object that contains information about the resource
        /// 			that emitted the event.
        public let resources: [EventResource]?
        ///  A Timestamp that specifies the time the event occurred.
        public let time: Date?

        @inlinable
        public init(dataSource: EventDataSource? = nil, eventClass: EventClass? = nil, eventSource: String? = nil, id: String? = nil, name: String? = nil, resourceCollection: ResourceCollection? = nil, resources: [EventResource]? = nil, time: Date? = nil) {
            self.dataSource = dataSource
            self.eventClass = eventClass
            self.eventSource = eventSource
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.resources = resources
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case eventClass = "EventClass"
            case eventSource = "EventSource"
            case id = "Id"
            case name = "Name"
            case resourceCollection = "ResourceCollection"
            case resources = "Resources"
            case time = "Time"
        }
    }

    public struct EventResource: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the resource that emitted an event.
        public let arn: String?
        ///  The name of the resource that emitted an event.
        public let name: String?
        ///  The type of resource that emitted an event.
        public let type: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil, type: String? = nil) {
            self.arn = arn
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct EventSourcesConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about whether DevOps Guru is configured to consume recommendations which
        /// 			are generated from AWS CodeGuru Profiler.
        public let amazonCodeGuruProfiler: AmazonCodeGuruProfilerIntegration?

        @inlinable
        public init(amazonCodeGuruProfiler: AmazonCodeGuruProfilerIntegration? = nil) {
            self.amazonCodeGuruProfiler = amazonCodeGuruProfiler
        }

        private enum CodingKeys: String, CodingKey {
            case amazonCodeGuruProfiler = "AmazonCodeGuruProfiler"
        }
    }

    public struct EventTimeRange: AWSEncodableShape {
        ///  The time when the event started.
        public let fromTime: Date
        ///  The time when the event ended.
        public let toTime: Date

        @inlinable
        public init(fromTime: Date, toTime: Date) {
            self.fromTime = fromTime
            self.toTime = toTime
        }

        private enum CodingKeys: String, CodingKey {
            case fromTime = "FromTime"
            case toTime = "ToTime"
        }
    }

    public struct GetCostEstimationRequest: AWSEncodableShape {
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        @inlinable
        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCostEstimationResponse: AWSDecodableShape {
        /// An array of ResourceCost objects that each contains details about the
        /// 			monthly cost estimate to analyze one of your Amazon Web Services resources.
        public let costs: [ServiceResourceCost]?
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The collection of the Amazon Web Services resources used to create your monthly DevOps Guru cost
        /// 			estimate.
        public let resourceCollection: CostEstimationResourceCollectionFilter?
        /// The status of creating this cost estimate. If it's still in progress, the status
        /// 				ONGOING is returned. If it is finished, the status
        /// 				COMPLETED is returned.
        public let status: CostEstimationStatus?
        /// The start and end time of the cost estimation.
        public let timeRange: CostEstimationTimeRange?
        /// The estimated monthly cost to analyze the Amazon Web Services resources. This value is the sum of
        /// 			the estimated costs to analyze each resource in the Costs object in this
        /// 			response.
        public let totalCost: Double?

        @inlinable
        public init(costs: [ServiceResourceCost]? = nil, nextToken: String? = nil, resourceCollection: CostEstimationResourceCollectionFilter? = nil, status: CostEstimationStatus? = nil, timeRange: CostEstimationTimeRange? = nil, totalCost: Double? = nil) {
            self.costs = costs
            self.nextToken = nextToken
            self.resourceCollection = resourceCollection
            self.status = status
            self.timeRange = timeRange
            self.totalCost = totalCost
        }

        private enum CodingKeys: String, CodingKey {
            case costs = "Costs"
            case nextToken = "NextToken"
            case resourceCollection = "ResourceCollection"
            case status = "Status"
            case timeRange = "TimeRange"
            case totalCost = "TotalCost"
        }
    }

    public struct GetResourceCollectionRequest: AWSEncodableShape {
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        ///  The type of Amazon Web Services resource collections to return. The one valid value is
        /// 				CLOUD_FORMATION for Amazon Web Services CloudFormation stacks.
        public let resourceCollectionType: ResourceCollectionType

        @inlinable
        public init(nextToken: String? = nil, resourceCollectionType: ResourceCollectionType) {
            self.nextToken = nextToken
            self.resourceCollectionType = resourceCollectionType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.resourceCollectionType, key: "ResourceCollectionType")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourceCollectionResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        ///  The requested list of Amazon Web Services resource collections.
        /// 			The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and  Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze  	the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public let resourceCollection: ResourceCollectionFilter?

        @inlinable
        public init(nextToken: String? = nil, resourceCollection: ResourceCollectionFilter? = nil) {
            self.nextToken = nextToken
            self.resourceCollection = resourceCollection
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourceCollection = "ResourceCollection"
        }
    }

    public struct InsightFeedback: AWSEncodableShape & AWSDecodableShape {
        ///  The feedback provided by the customer.
        public let feedback: InsightFeedbackOption?
        ///  The insight feedback ID.
        public let id: String?

        @inlinable
        public init(feedback: InsightFeedbackOption? = nil, id: String? = nil) {
            self.feedback = feedback
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\w-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case feedback = "Feedback"
            case id = "Id"
        }
    }

    public struct InsightHealth: AWSDecodableShape {
        ///  The Meant Time to Recover (MTTR) for the insight.
        public let meanTimeToRecoverInMilliseconds: Int64?
        ///  The number of open proactive insights.
        public let openProactiveInsights: Int?
        ///  The number of open reactive insights.
        public let openReactiveInsights: Int?

        @inlinable
        public init(meanTimeToRecoverInMilliseconds: Int64? = nil, openProactiveInsights: Int? = nil, openReactiveInsights: Int? = nil) {
            self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case meanTimeToRecoverInMilliseconds = "MeanTimeToRecoverInMilliseconds"
            case openProactiveInsights = "OpenProactiveInsights"
            case openReactiveInsights = "OpenReactiveInsights"
        }
    }

    public struct InsightTimeRange: AWSDecodableShape {
        ///  The time when the behavior described in an insight ended.
        public let endTime: Date?
        ///  The time when the behavior described in an insight started.
        public let startTime: Date

        @inlinable
        public init(endTime: Date? = nil, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        ///  The number of seconds after which the action that caused the internal server
        /// 			exception can be retried.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct KMSServerSideEncryptionIntegration: AWSDecodableShape {
        /// 			Describes the specified KMS key.
        /// 		 To specify a KMS key, use its key ID, key ARN,
        /// 			alias name, or alias ARN. When using an alias name,
        /// 			prefix it with "alias/". If you specify a predefined Amazon Web Services alias
        /// 			(an Amazon Web Services alias with no key ID), Amazon Web Services KMS associates the alias with an
        /// 			Amazon Web Services managed key and returns its KeyId and Arn in the response.
        /// 			To specify a KMS key in a different Amazon Web Services account, you must use the key ARN or alias ARN. For example:  Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab Alias name: alias/ExampleAlias Alias ARN: arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias
        public let kmsKeyId: String?
        /// 			Specifies if DevOps Guru is enabled for customer managed keys.
        ///
        public let optInStatus: OptInStatus?
        /// 			The type of KMS key used. Customer managed keys are the KMS keys that you create. Amazon Web Services owned keys are keys that are owned and managed by DevOps Guru.
        ///
        public let type: ServerSideEncryptionType?

        @inlinable
        public init(kmsKeyId: String? = nil, optInStatus: OptInStatus? = nil, type: ServerSideEncryptionType? = nil) {
            self.kmsKeyId = kmsKeyId
            self.optInStatus = optInStatus
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KMSKeyId"
            case optInStatus = "OptInStatus"
            case type = "Type"
        }
    }

    public struct KMSServerSideEncryptionIntegrationConfig: AWSEncodableShape {
        /// 				Describes the specified KMS key. To specify a KMS key, use its key ID, key ARN,
        /// 				alias name, or alias ARN. When using an alias name,
        /// 				prefix it with "alias/". If you specify a predefined Amazon Web Services alias
        /// 				(an Amazon Web Services alias with no key ID), Amazon Web Services KMS associates the alias with an
        /// 				Amazon Web Services managed key and returns its KeyId and Arn in the response.
        /// 				To specify a KMS key in a different Amazon Web Services account, you must use the key ARN or alias ARN. For example:  Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab Alias name: alias/ExampleAlias Alias ARN: arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias
        public let kmsKeyId: String?
        /// 			Specifies if DevOps Guru is enabled for KMS integration.
        ///
        public let optInStatus: OptInStatus?
        /// 			The type of KMS key used. Customer managed keys are the KMS keys that you create. Amazon Web Services owned keys are keys that are owned and managed by DevOps Guru.
        ///
        public let type: ServerSideEncryptionType?

        @inlinable
        public init(kmsKeyId: String? = nil, optInStatus: OptInStatus? = nil, type: ServerSideEncryptionType? = nil) {
            self.kmsKeyId = kmsKeyId
            self.optInStatus = optInStatus
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KMSKeyId"
            case optInStatus = "OptInStatus"
            case type = "Type"
        }
    }

    public struct ListAnomaliesForInsightFilters: AWSEncodableShape {
        public let serviceCollection: ServiceCollection?

        @inlinable
        public init(serviceCollection: ServiceCollection? = nil) {
            self.serviceCollection = serviceCollection
        }

        private enum CodingKeys: String, CodingKey {
            case serviceCollection = "ServiceCollection"
        }
    }

    public struct ListAnomaliesForInsightRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountId: String?
        /// 			Specifies one or more service names that are used to list anomalies.
        ///
        public let filters: ListAnomaliesForInsightFilters?
        ///  The ID of the insight. The returned anomalies belong to this insight.
        public let insightId: String
        /// The maximum number of results to return with a single call.
        /// 	To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        ///  A time range used to specify when the requested anomalies started. All returned
        /// 			anomalies started during this time range.
        public let startTimeRange: StartTimeRange?

        @inlinable
        public init(accountId: String? = nil, filters: ListAnomaliesForInsightFilters? = nil, insightId: String, maxResults: Int? = nil, nextToken: String? = nil, startTimeRange: StartTimeRange? = nil) {
            self.accountId = accountId
            self.filters = filters
            self.insightId = insightId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTimeRange = startTimeRange
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountId, forKey: .accountId)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            request.encodePath(self.insightId, key: "InsightId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.startTimeRange, forKey: .startTimeRange)
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.insightId, name: "insightId", parent: name, max: 100)
            try self.validate(self.insightId, name: "insightId", parent: name, min: 1)
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[\\w-]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTimeRange = "StartTimeRange"
        }
    }

    public struct ListAnomaliesForInsightResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        ///  An array of ProactiveAnomalySummary objects that represent the requested
        /// 			anomalies
        public let proactiveAnomalies: [ProactiveAnomalySummary]?
        ///  An array of ReactiveAnomalySummary objects that represent the requested
        /// 			anomalies
        public let reactiveAnomalies: [ReactiveAnomalySummary]?

        @inlinable
        public init(nextToken: String? = nil, proactiveAnomalies: [ProactiveAnomalySummary]? = nil, reactiveAnomalies: [ReactiveAnomalySummary]? = nil) {
            self.nextToken = nextToken
            self.proactiveAnomalies = proactiveAnomalies
            self.reactiveAnomalies = reactiveAnomalies
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proactiveAnomalies = "ProactiveAnomalies"
            case reactiveAnomalies = "ReactiveAnomalies"
        }
    }

    public struct ListAnomalousLogGroupsRequest: AWSEncodableShape {
        /// 			The ID of the insight containing the log groups.
        ///
        public let insightId: String
        /// The maximum number of results to return with a single call.
        /// 	To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        @inlinable
        public init(insightId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.insightId = insightId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.insightId, name: "insightId", parent: name, max: 100)
            try self.validate(self.insightId, name: "insightId", parent: name, min: 1)
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[\\w-]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case insightId = "InsightId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnomalousLogGroupsResponse: AWSDecodableShape {
        /// 			The list of Amazon CloudWatch log groups that are related to an insight.
        ///
        public let anomalousLogGroups: [AnomalousLogGroup]
        /// 			The ID of the insight containing the log groups.
        ///
        public let insightId: String
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        @inlinable
        public init(anomalousLogGroups: [AnomalousLogGroup], insightId: String, nextToken: String? = nil) {
            self.anomalousLogGroups = anomalousLogGroups
            self.insightId = insightId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case anomalousLogGroups = "AnomalousLogGroups"
            case insightId = "InsightId"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventsFilters: AWSEncodableShape {
        ///  The source, AWS_CLOUD_TRAIL or AWS_CODE_DEPLOY, of the
        /// 			events you want returned.
        public let dataSource: EventDataSource?
        ///  The class of the events you want to filter for, such as an infrastructure change, a
        /// 			deployment, or a schema change.
        public let eventClass: EventClass?
        ///  The Amazon Web Services source that emitted the events you want to filter for.
        public let eventSource: String?
        ///  A time range during which you want the filtered events to have occurred.
        public let eventTimeRange: EventTimeRange?
        ///  An ID of an insight that is related to the events you want to filter for.
        public let insightId: String?
        public let resourceCollection: ResourceCollection?

        @inlinable
        public init(dataSource: EventDataSource? = nil, eventClass: EventClass? = nil, eventSource: String? = nil, eventTimeRange: EventTimeRange? = nil, insightId: String? = nil, resourceCollection: ResourceCollection? = nil) {
            self.dataSource = dataSource
            self.eventClass = eventClass
            self.eventSource = eventSource
            self.eventTimeRange = eventTimeRange
            self.insightId = insightId
            self.resourceCollection = resourceCollection
        }

        public func validate(name: String) throws {
            try self.validate(self.eventSource, name: "eventSource", parent: name, max: 50)
            try self.validate(self.eventSource, name: "eventSource", parent: name, min: 10)
            try self.validate(self.eventSource, name: "eventSource", parent: name, pattern: "^[a-z]+[a-z0-9]*\\.amazonaws\\.com|aws\\.events$")
            try self.validate(self.insightId, name: "insightId", parent: name, max: 100)
            try self.validate(self.insightId, name: "insightId", parent: name, min: 1)
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[\\w-]*$")
            try self.resourceCollection?.validate(name: "\(name).resourceCollection")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case eventClass = "EventClass"
            case eventSource = "EventSource"
            case eventTimeRange = "EventTimeRange"
            case insightId = "InsightId"
            case resourceCollection = "ResourceCollection"
        }
    }

    public struct ListEventsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountId: String?
        ///  A ListEventsFilters object used to specify which events to return.
        ///
        public let filters: ListEventsFilters
        /// The maximum number of results to return with a single call.
        /// 	To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        @inlinable
        public init(accountId: String? = nil, filters: ListEventsFilters, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountId = accountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.filters.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventsResponse: AWSDecodableShape {
        ///  A list of the requested events.
        public let events: [Event]
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        @inlinable
        public init(events: [Event], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case nextToken = "NextToken"
        }
    }

    public struct ListInsightsAnyStatusFilter: AWSEncodableShape {
        ///  A time range used to specify when the behavior of the filtered insights started.
        ///
        public let startTimeRange: StartTimeRange
        ///  Use to filter for either REACTIVE or PROACTIVE insights.
        ///
        public let type: InsightType

        @inlinable
        public init(startTimeRange: StartTimeRange, type: InsightType) {
            self.startTimeRange = startTimeRange
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case startTimeRange = "StartTimeRange"
            case type = "Type"
        }
    }

    public struct ListInsightsClosedStatusFilter: AWSEncodableShape {
        ///  A time range used to specify when the behavior of the filtered insights ended.
        ///
        public let endTimeRange: EndTimeRange
        ///  Use to filter for either REACTIVE or PROACTIVE insights.
        ///
        public let type: InsightType

        @inlinable
        public init(endTimeRange: EndTimeRange, type: InsightType) {
            self.endTimeRange = endTimeRange
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeRange = "EndTimeRange"
            case type = "Type"
        }
    }

    public struct ListInsightsOngoingStatusFilter: AWSEncodableShape {
        ///  Use to filter for either REACTIVE or PROACTIVE insights.
        ///
        public let type: InsightType

        @inlinable
        public init(type: InsightType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct ListInsightsRequest: AWSEncodableShape {
        /// The maximum number of results to return with a single call.
        /// 	To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        ///  A filter used to filter the returned insights by their status. You can specify one
        /// 			status filter.
        public let statusFilter: ListInsightsStatusFilter

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, statusFilter: ListInsightsStatusFilter) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.statusFilter = statusFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case statusFilter = "StatusFilter"
        }
    }

    public struct ListInsightsResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        ///  The returned list of proactive insights.
        public let proactiveInsights: [ProactiveInsightSummary]?
        ///  The returned list of reactive insights.
        public let reactiveInsights: [ReactiveInsightSummary]?

        @inlinable
        public init(nextToken: String? = nil, proactiveInsights: [ProactiveInsightSummary]? = nil, reactiveInsights: [ReactiveInsightSummary]? = nil) {
            self.nextToken = nextToken
            self.proactiveInsights = proactiveInsights
            self.reactiveInsights = reactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proactiveInsights = "ProactiveInsights"
            case reactiveInsights = "ReactiveInsights"
        }
    }

    public struct ListInsightsStatusFilter: AWSEncodableShape {
        ///  A ListInsightsAnyStatusFilter that specifies insights of any status that
        /// 			are either REACTIVE or PROACTIVE.
        public let any: ListInsightsAnyStatusFilter?
        ///  A ListInsightsClosedStatusFilter that specifies closed insights that are
        /// 			either REACTIVE or PROACTIVE.
        public let closed: ListInsightsClosedStatusFilter?
        ///  A ListInsightsAnyStatusFilter that specifies ongoing insights that are
        /// 			either REACTIVE or PROACTIVE.
        public let ongoing: ListInsightsOngoingStatusFilter?

        @inlinable
        public init(any: ListInsightsAnyStatusFilter? = nil, closed: ListInsightsClosedStatusFilter? = nil, ongoing: ListInsightsOngoingStatusFilter? = nil) {
            self.any = any
            self.closed = closed
            self.ongoing = ongoing
        }

        private enum CodingKeys: String, CodingKey {
            case any = "Any"
            case closed = "Closed"
            case ongoing = "Ongoing"
        }
    }

    public struct ListMonitoredResourcesFilters: AWSEncodableShape {
        /// 			The permission status of a resource.
        ///
        public let resourcePermission: ResourcePermission
        /// 			The type of resource that you wish to retrieve, such as log groups.
        ///
        public let resourceTypeFilters: [ResourceTypeFilter]

        @inlinable
        public init(resourcePermission: ResourcePermission, resourceTypeFilters: [ResourceTypeFilter]) {
            self.resourcePermission = resourcePermission
            self.resourceTypeFilters = resourceTypeFilters
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePermission = "ResourcePermission"
            case resourceTypeFilters = "ResourceTypeFilters"
        }
    }

    public struct ListMonitoredResourcesRequest: AWSEncodableShape {
        /// 			Filters to determine which monitored resources you want to retrieve. You can filter by resource type or resource permission status.
        ///
        public let filters: ListMonitoredResourcesFilters?
        /// The maximum number of results to return with a single call.
        /// 	To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        @inlinable
        public init(filters: ListMonitoredResourcesFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListMonitoredResourcesResponse: AWSDecodableShape {
        /// 			Information about the resource that is being monitored, including the name of the resource, the type of resource, and whether or not permission is given to DevOps Guru to access that resource.
        ///
        public let monitoredResourceIdentifiers: [MonitoredResourceIdentifier]
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        @inlinable
        public init(monitoredResourceIdentifiers: [MonitoredResourceIdentifier], nextToken: String? = nil) {
            self.monitoredResourceIdentifiers = monitoredResourceIdentifiers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case monitoredResourceIdentifiers = "MonitoredResourceIdentifiers"
            case nextToken = "NextToken"
        }
    }

    public struct ListNotificationChannelsRequest: AWSEncodableShape {
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        @inlinable
        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct ListNotificationChannelsResponse: AWSDecodableShape {
        ///  An array that contains the requested notification channels.
        public let channels: [NotificationChannel]?
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        @inlinable
        public init(channels: [NotificationChannel]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case nextToken = "NextToken"
        }
    }

    public struct ListOrganizationInsightsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountIds: [String]?
        /// The maximum number of results to return with a single call.
        /// 	To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The ID of the organizational unit.
        public let organizationalUnitIds: [String]?
        public let statusFilter: ListInsightsStatusFilter

        @inlinable
        public init(accountIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationalUnitIds: [String]? = nil, statusFilter: ListInsightsStatusFilter) {
            self.accountIds = accountIds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationalUnitIds = organizationalUnitIds
            self.statusFilter = statusFilter
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.organizationalUnitIds?.forEach {
                try validate($0, name: "organizationalUnitIds[]", parent: name, max: 68)
                try validate($0, name: "organizationalUnitIds[]", parent: name, pattern: "^ou-[0-9a-z]{4,32}-[a-z0-9]{8,32}$")
            }
            try self.validate(self.organizationalUnitIds, name: "organizationalUnitIds", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case organizationalUnitIds = "OrganizationalUnitIds"
            case statusFilter = "StatusFilter"
        }
    }

    public struct ListOrganizationInsightsResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// An integer that specifies the number of open proactive insights in your Amazon Web Services
        /// 			account.
        public let proactiveInsights: [ProactiveOrganizationInsightSummary]?
        /// An integer that specifies the number of open reactive insights in your Amazon Web Services
        /// 			account.
        public let reactiveInsights: [ReactiveOrganizationInsightSummary]?

        @inlinable
        public init(nextToken: String? = nil, proactiveInsights: [ProactiveOrganizationInsightSummary]? = nil, reactiveInsights: [ReactiveOrganizationInsightSummary]? = nil) {
            self.nextToken = nextToken
            self.proactiveInsights = proactiveInsights
            self.reactiveInsights = reactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proactiveInsights = "ProactiveInsights"
            case reactiveInsights = "ReactiveInsights"
        }
    }

    public struct ListRecommendationsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountId: String?
        ///  The ID of the requested insight.
        public let insightId: String
        /// A locale that specifies the language to use for recommendations.
        public let locale: Locale?
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        @inlinable
        public init(accountId: String? = nil, insightId: String, locale: Locale? = nil, nextToken: String? = nil) {
            self.accountId = accountId
            self.insightId = insightId
            self.locale = locale
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.insightId, name: "insightId", parent: name, max: 100)
            try self.validate(self.insightId, name: "insightId", parent: name, min: 1)
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[\\w-]*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case insightId = "InsightId"
            case locale = "Locale"
            case nextToken = "NextToken"
        }
    }

    public struct ListRecommendationsResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        ///  An array of the requested recommendations.
        public let recommendations: [Recommendation]?

        @inlinable
        public init(nextToken: String? = nil, recommendations: [Recommendation]? = nil) {
            self.nextToken = nextToken
            self.recommendations = recommendations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recommendations = "Recommendations"
        }
    }

    public struct LogAnomalyClass: AWSDecodableShape {
        /// 			The explanation for why the log event is considered an anomaly.
        ///
        public let explanation: String?
        /// 			The token where the anomaly was detected. This may refer to an exception or another location, or it may be blank for log anomalies such as format anomalies.
        ///
        public let logAnomalyToken: String?
        /// 			The type of log anomaly that has been detected.
        ///
        public let logAnomalyType: LogAnomalyType?
        /// 			The ID of the log event.
        ///
        public let logEventId: String?
        /// 			The time of the first occurrence of the anomalous log event.
        ///
        public let logEventTimestamp: Date?
        /// 			The name of the Amazon CloudWatch log stream that the anomalous log event belongs to. A log stream is a sequence of log events that share the same source.
        ///
        public let logStreamName: String?
        /// 			The number of log lines where this anomalous log event occurs.
        ///
        public let numberOfLogLinesOccurrences: Int?

        @inlinable
        public init(explanation: String? = nil, logAnomalyToken: String? = nil, logAnomalyType: LogAnomalyType? = nil, logEventId: String? = nil, logEventTimestamp: Date? = nil, logStreamName: String? = nil, numberOfLogLinesOccurrences: Int? = nil) {
            self.explanation = explanation
            self.logAnomalyToken = logAnomalyToken
            self.logAnomalyType = logAnomalyType
            self.logEventId = logEventId
            self.logEventTimestamp = logEventTimestamp
            self.logStreamName = logStreamName
            self.numberOfLogLinesOccurrences = numberOfLogLinesOccurrences
        }

        private enum CodingKeys: String, CodingKey {
            case explanation = "Explanation"
            case logAnomalyToken = "LogAnomalyToken"
            case logAnomalyType = "LogAnomalyType"
            case logEventId = "LogEventId"
            case logEventTimestamp = "LogEventTimestamp"
            case logStreamName = "LogStreamName"
            case numberOfLogLinesOccurrences = "NumberOfLogLinesOccurrences"
        }
    }

    public struct LogAnomalyShowcase: AWSDecodableShape {
        /// 			A list of anomalous log events that may be related.
        ///
        public let logAnomalyClasses: [LogAnomalyClass]?

        @inlinable
        public init(logAnomalyClasses: [LogAnomalyClass]? = nil) {
            self.logAnomalyClasses = logAnomalyClasses
        }

        private enum CodingKeys: String, CodingKey {
            case logAnomalyClasses = "LogAnomalyClasses"
        }
    }

    public struct LogsAnomalyDetectionIntegration: AWSDecodableShape {
        /// Specifies if DevOps Guru is configured to perform log anomaly detection on CloudWatch log groups.
        public let optInStatus: OptInStatus?

        @inlinable
        public init(optInStatus: OptInStatus? = nil) {
            self.optInStatus = optInStatus
        }

        private enum CodingKeys: String, CodingKey {
            case optInStatus = "OptInStatus"
        }
    }

    public struct LogsAnomalyDetectionIntegrationConfig: AWSEncodableShape {
        /// Specifies if DevOps Guru is configured to perform log anomaly detection on CloudWatch log groups.
        public let optInStatus: OptInStatus?

        @inlinable
        public init(optInStatus: OptInStatus? = nil) {
            self.optInStatus = optInStatus
        }

        private enum CodingKeys: String, CodingKey {
            case optInStatus = "OptInStatus"
        }
    }

    public struct MonitoredResourceIdentifier: AWSDecodableShape {
        /// 			The time at which DevOps Guru last updated this resource.
        ///
        public let lastUpdated: Date?
        /// 			The name of the resource being monitored.
        ///
        public let monitoredResourceName: String?
        public let resourceCollection: ResourceCollection?
        /// 			The permission status of a resource.
        ///
        public let resourcePermission: ResourcePermission?
        /// 			The type of resource being monitored.
        ///
        public let type: String?

        @inlinable
        public init(lastUpdated: Date? = nil, monitoredResourceName: String? = nil, resourceCollection: ResourceCollection? = nil, resourcePermission: ResourcePermission? = nil, type: String? = nil) {
            self.lastUpdated = lastUpdated
            self.monitoredResourceName = monitoredResourceName
            self.resourceCollection = resourceCollection
            self.resourcePermission = resourcePermission
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case lastUpdated = "LastUpdated"
            case monitoredResourceName = "MonitoredResourceName"
            case resourceCollection = "ResourceCollection"
            case resourcePermission = "ResourcePermission"
            case type = "Type"
        }
    }

    public struct NotificationChannel: AWSDecodableShape {
        ///  A NotificationChannelConfig object that contains information about
        /// 			configured notification channels.
        public let config: NotificationChannelConfig?
        ///  The ID of a notification channel.
        public let id: String?

        @inlinable
        public init(config: NotificationChannelConfig? = nil, id: String? = nil) {
            self.config = config
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case id = "Id"
        }
    }

    public struct NotificationChannelConfig: AWSEncodableShape & AWSDecodableShape {
        /// 			The filter configurations for the Amazon SNS notification topic you use with DevOps Guru.
        /// 			If you do not provide filter configurations, the default configurations are to receive notifications for all message types of High or Medium severity.
        ///
        public let filters: NotificationFilterConfig?
        ///  Information about a notification channel configured in DevOps Guru to send notifications
        /// 			when insights are created.  If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission
        /// 				to send it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account. DevOps Guru only supports standard SNS topics.
        /// 				For more information, see Permissions
        /// 				for Amazon SNS topics. If you use an Amazon SNS topic that is encrypted by an Amazon Web Services Key Management Service customer-managed key (CMK), then you must add permissions
        /// 				to the CMK. For more information, see Permissions for
        /// 				Amazon Web Services KMSencrypted Amazon SNS topics.
        public let sns: SnsChannelConfig

        @inlinable
        public init(filters: NotificationFilterConfig? = nil, sns: SnsChannelConfig) {
            self.filters = filters
            self.sns = sns
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.sns.validate(name: "\(name).sns")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case sns = "Sns"
        }
    }

    public struct NotificationFilterConfig: AWSEncodableShape & AWSDecodableShape {
        /// 			The events that you want to receive notifications for. For example, you can choose to receive notifications only when the severity level is upgraded or a new insight is created.
        ///
        public let messageTypes: [NotificationMessageType]?
        /// 			The severity levels that you want to receive notifications for. For example, you can choose to receive notifications only for insights with HIGH and MEDIUM severity levels.
        /// 			For more information, see Understanding insight severities.
        ///
        public let severities: [InsightSeverity]?

        @inlinable
        public init(messageTypes: [NotificationMessageType]? = nil, severities: [InsightSeverity]? = nil) {
            self.messageTypes = messageTypes
            self.severities = severities
        }

        public func validate(name: String) throws {
            try self.validate(self.messageTypes, name: "messageTypes", parent: name, max: 5)
            try self.validate(self.severities, name: "severities", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case messageTypes = "MessageTypes"
            case severities = "Severities"
        }
    }

    public struct OpsCenterIntegration: AWSDecodableShape {
        ///  Specifies if DevOps Guru is enabled to create an Amazon Web Services Systems Manager OpsItem for each created
        /// 			insight.
        public let optInStatus: OptInStatus?

        @inlinable
        public init(optInStatus: OptInStatus? = nil) {
            self.optInStatus = optInStatus
        }

        private enum CodingKeys: String, CodingKey {
            case optInStatus = "OptInStatus"
        }
    }

    public struct OpsCenterIntegrationConfig: AWSEncodableShape {
        ///  Specifies if DevOps Guru is enabled to create an Amazon Web Services Systems Manager OpsItem for each created
        /// 			insight.
        public let optInStatus: OptInStatus?

        @inlinable
        public init(optInStatus: OptInStatus? = nil) {
            self.optInStatus = optInStatus
        }

        private enum CodingKeys: String, CodingKey {
            case optInStatus = "OptInStatus"
        }
    }

    public struct PerformanceInsightsMetricDimensionGroup: AWSDecodableShape {
        /// A list of specific dimensions from a dimension group. If this parameter is not
        /// 			present, then it signifies that all of the dimensions in the group were requested or are
        /// 			present in the response. Valid values for elements in the Dimensions array are:    db.application.name - The name of the application that is connected
        /// 					to the database (only Aurora PostgreSQL and RDS PostgreSQL)    db.host.id - The host ID of the connected client (all
        /// 					engines)    db.host.name - The host name of the connected client (all
        /// 					engines)    db.name - The name of the database to which the client is connected
        /// 					(only Aurora PostgreSQL, Amazon RDS PostgreSQL, Aurora MySQL, Amazon RDS MySQL, and MariaDB)    db.session_type.name - The type of the current session (only Aurora
        /// 					PostgreSQL and RDS PostgreSQL)    db.sql.id - The SQL ID generated by Performance Insights (all engines)    db.sql.db_id - The SQL ID generated by the database (all
        /// 					engines)    db.sql.statement - The SQL text that is being executed (all
        /// 					engines)    db.sql.tokenized_id     db.sql_tokenized.id - The SQL digest ID generated by Performance Insights (all
        /// 					engines)    db.sql_tokenized.db_id - SQL digest ID generated by the database
        /// 					(all engines)    db.sql_tokenized.statement - The SQL digest text (all
        /// 					engines)    db.user.id - The ID of the user logged in to the database (all
        /// 					engines)    db.user.name - The name of the user logged in to the database (all
        /// 					engines)    db.wait_event.name - The event for which the backend is waiting
        /// 					(all engines)    db.wait_event.type - The type of event for which the backend is
        /// 					waiting (all engines)    db.wait_event_type.name - The name of the event type for which the
        /// 					backend is waiting (all engines)
        public let dimensions: [String]?
        /// The name of the dimension group. Its valid values are:    db - The name of the database to which the client is connected
        /// 					(only Aurora PostgreSQL, Amazon RDS PostgreSQL, Aurora MySQL, Amazon RDS MySQL, and MariaDB)    db.application - The name of the application that is connected to
        /// 					the database (only Aurora PostgreSQL and RDS PostgreSQL)    db.host - The host name of the connected client (all
        /// 					engines)    db.session_type - The type of the current session (only Aurora PostgreSQL
        /// 					and RDS PostgreSQL)    db.sql - The SQL that is currently executing (all engines)    db.sql_tokenized - The SQL digest (all engines)    db.wait_event - The event for which the database backend is waiting
        /// 					(all engines)    db.wait_event_type - The type of event for which the database
        /// 					backend is waiting (all engines)    db.user - The user logged in to the database (all engines)
        public let group: String?
        /// The maximum number of items to fetch for this dimension group.
        public let limit: Int?

        @inlinable
        public init(dimensions: [String]? = nil, group: String? = nil, limit: Int? = nil) {
            self.dimensions = dimensions
            self.group = group
            self.limit = limit
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case group = "Group"
            case limit = "Limit"
        }
    }

    public struct PerformanceInsightsMetricQuery: AWSDecodableShape {
        /// One or more filters to apply to a Performance Insights GetResourceMetrics API query.
        /// 			Restrictions:   Any number of filters by the same dimension, as specified in the
        /// 						GroupBy parameter.   A single filter for any other dimension in this dimension group.
        public let filter: [String: String]?
        /// The specification for how to aggregate the data points from a Performance Insights
        /// 				GetResourceMetrics API query. The Performance Insights query returns all of the
        /// 			dimensions within that group, unless you provide the names of specific dimensions within
        /// 			that group. You can also request that Performance Insights return a limited number of values for a
        /// 			dimension.
        public let groupBy: PerformanceInsightsMetricDimensionGroup?
        /// The name of the meteric used used when querying an Performance Insights
        /// 				GetResourceMetrics API for anomaly metrics. Valid values for Metric are:    db.load.avg - a scaled representation of the number of active sessions for the
        /// 					database engine.    db.sampledload.avg - the raw number of active sessions for the database
        /// 					engine.   If the number of active sessions is less than an internal Performance Insights threshold,
        /// 				db.load.avg and db.sampledload.avg are the same value. If
        /// 			the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with
        /// 				db.load.avg showing the scaled values, db.sampledload.avg
        /// 			showing the raw values, and db.sampledload.avg less than
        /// 				db.load.avg. For most use cases, you can query db.load.avg
        /// 			only.
        public let metric: String?

        @inlinable
        public init(filter: [String: String]? = nil, groupBy: PerformanceInsightsMetricDimensionGroup? = nil, metric: String? = nil) {
            self.filter = filter
            self.groupBy = groupBy
            self.metric = metric
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case groupBy = "GroupBy"
            case metric = "Metric"
        }
    }

    public struct PerformanceInsightsMetricsDetail: AWSDecodableShape {
        /// The name used for a specific Performance Insights metric.
        public let metricDisplayName: String?
        /// A single query to be processed for the metric. For more information, see  PerformanceInsightsMetricQuery .
        public let metricQuery: PerformanceInsightsMetricQuery?
        ///  For more information, see  PerformanceInsightsReferenceData .
        public let referenceData: [PerformanceInsightsReferenceData]?
        /// The metric statistics during the anomalous period detected by DevOps Guru;
        public let statsAtAnomaly: [PerformanceInsightsStat]?
        /// Typical metric statistics that are not considered anomalous. When DevOps Guru analyzes
        /// 			metrics, it compares them to StatsAtBaseline to help determine if they are
        /// 			anomalous.
        public let statsAtBaseline: [PerformanceInsightsStat]?
        /// The unit of measure for a metric. For example, a session or a process.
        public let unit: String?

        @inlinable
        public init(metricDisplayName: String? = nil, metricQuery: PerformanceInsightsMetricQuery? = nil, referenceData: [PerformanceInsightsReferenceData]? = nil, statsAtAnomaly: [PerformanceInsightsStat]? = nil, statsAtBaseline: [PerformanceInsightsStat]? = nil, unit: String? = nil) {
            self.metricDisplayName = metricDisplayName
            self.metricQuery = metricQuery
            self.referenceData = referenceData
            self.statsAtAnomaly = statsAtAnomaly
            self.statsAtBaseline = statsAtBaseline
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case metricDisplayName = "MetricDisplayName"
            case metricQuery = "MetricQuery"
            case referenceData = "ReferenceData"
            case statsAtAnomaly = "StatsAtAnomaly"
            case statsAtBaseline = "StatsAtBaseline"
            case unit = "Unit"
        }
    }

    public struct PerformanceInsightsReferenceComparisonValues: AWSDecodableShape {
        /// A metric that DevOps Guru compares to actual metric values. This reference metric is used to
        /// 			determine if an actual metric should be considered anomalous.
        public let referenceMetric: PerformanceInsightsReferenceMetric?
        /// A scalar value DevOps Guru for a metric that DevOps Guru compares to actual metric values. This
        /// 			reference value is used to determine if an actual metric value should be considered
        /// 			anomalous.
        public let referenceScalar: PerformanceInsightsReferenceScalar?

        @inlinable
        public init(referenceMetric: PerformanceInsightsReferenceMetric? = nil, referenceScalar: PerformanceInsightsReferenceScalar? = nil) {
            self.referenceMetric = referenceMetric
            self.referenceScalar = referenceScalar
        }

        private enum CodingKeys: String, CodingKey {
            case referenceMetric = "ReferenceMetric"
            case referenceScalar = "ReferenceScalar"
        }
    }

    public struct PerformanceInsightsReferenceData: AWSDecodableShape {
        /// The specific reference values used to evaluate the Performance Insights. For more information, see
        /// 					 PerformanceInsightsReferenceComparisonValues .
        public let comparisonValues: PerformanceInsightsReferenceComparisonValues?
        /// The name of the reference data.
        public let name: String?

        @inlinable
        public init(comparisonValues: PerformanceInsightsReferenceComparisonValues? = nil, name: String? = nil) {
            self.comparisonValues = comparisonValues
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonValues = "ComparisonValues"
            case name = "Name"
        }
    }

    public struct PerformanceInsightsReferenceMetric: AWSDecodableShape {
        /// A query to be processed on the metric.
        public let metricQuery: PerformanceInsightsMetricQuery?

        @inlinable
        public init(metricQuery: PerformanceInsightsMetricQuery? = nil) {
            self.metricQuery = metricQuery
        }

        private enum CodingKeys: String, CodingKey {
            case metricQuery = "MetricQuery"
        }
    }

    public struct PerformanceInsightsReferenceScalar: AWSDecodableShape {
        /// The reference value.
        public let value: Double?

        @inlinable
        public init(value: Double? = nil) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct PerformanceInsightsStat: AWSDecodableShape {
        /// The statistic type.
        public let type: String?
        /// The value of the statistic.
        public let value: Double?

        @inlinable
        public init(type: String? = nil, value: Double? = nil) {
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct PredictionTimeRange: AWSDecodableShape {
        ///  The time when the behavior in a proactive insight is expected to end.
        public let endTime: Date?
        ///  The time range during which a metric limit is expected to be exceeded. This applies
        /// 			to proactive insights only.
        public let startTime: Date

        @inlinable
        public init(endTime: Date? = nil, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct ProactiveAnomaly: AWSDecodableShape {
        /// 			An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        ///
        public let anomalyReportedTimeRange: AnomalyReportedTimeRange?
        /// Information about a resource in which DevOps Guru detected anomalous behavior.
        public let anomalyResources: [AnomalyResource]?
        public let anomalyTimeRange: AnomalyTimeRange?
        ///  The ID of the insight that contains this anomaly. An insight is composed of related
        /// 			anomalies.
        public let associatedInsightId: String?
        /// 			A description of the proactive anomaly.
        ///
        public let description: String?
        ///  The ID of a proactive anomaly.
        public let id: String?
        ///  A threshold that was exceeded by behavior in analyzed resources. Exceeding this
        /// 			threshold is related to the anomalous behavior that generated this anomaly.
        public let limit: Double?
        public let predictionTimeRange: PredictionTimeRange?
        public let resourceCollection: ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate
        /// 	an insight determine that insight's severity. For more information, see
        /// 	Understanding
        /// 	insight severities in the Amazon DevOps Guru User Guide.
        public let severity: AnomalySeverity?
        ///  Details about the source of the analyzed operational data that triggered the anomaly.
        /// 			The one supported source is Amazon CloudWatch metrics.
        public let sourceDetails: AnomalySourceDetails?
        /// The metadata for the anomaly.
        public let sourceMetadata: AnomalySourceMetadata?
        ///  The status of a proactive anomaly.
        public let status: AnomalyStatus?
        ///  The time of the anomaly's most recent update.
        public let updateTime: Date?

        @inlinable
        public init(anomalyReportedTimeRange: AnomalyReportedTimeRange? = nil, anomalyResources: [AnomalyResource]? = nil, anomalyTimeRange: AnomalyTimeRange? = nil, associatedInsightId: String? = nil, description: String? = nil, id: String? = nil, limit: Double? = nil, predictionTimeRange: PredictionTimeRange? = nil, resourceCollection: ResourceCollection? = nil, severity: AnomalySeverity? = nil, sourceDetails: AnomalySourceDetails? = nil, sourceMetadata: AnomalySourceMetadata? = nil, status: AnomalyStatus? = nil, updateTime: Date? = nil) {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.description = description
            self.id = id
            self.limit = limit
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.sourceMetadata = sourceMetadata
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
            case anomalyResources = "AnomalyResources"
            case anomalyTimeRange = "AnomalyTimeRange"
            case associatedInsightId = "AssociatedInsightId"
            case description = "Description"
            case id = "Id"
            case limit = "Limit"
            case predictionTimeRange = "PredictionTimeRange"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case sourceDetails = "SourceDetails"
            case sourceMetadata = "SourceMetadata"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct ProactiveAnomalySummary: AWSDecodableShape {
        /// 			An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        ///
        public let anomalyReportedTimeRange: AnomalyReportedTimeRange?
        /// Information about a resource in which DevOps Guru detected anomalous behavior.
        public let anomalyResources: [AnomalyResource]?
        public let anomalyTimeRange: AnomalyTimeRange?
        ///  The ID of the insight that contains this anomaly. An insight is composed of related
        /// 			anomalies.
        public let associatedInsightId: String?
        /// 			A description of the proactive anomaly.
        ///
        public let description: String?
        /// The ID of the anomaly.
        public let id: String?
        ///  A threshold that was exceeded by behavior in analyzed resources. Exceeding this
        /// 			threshold is related to the anomalous behavior that generated this anomaly.
        public let limit: Double?
        public let predictionTimeRange: PredictionTimeRange?
        public let resourceCollection: ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate
        /// 	an insight determine that insight's severity. For more information, see
        /// 	Understanding
        /// 	insight severities in the Amazon DevOps Guru User Guide.
        public let severity: AnomalySeverity?
        ///  Details about the source of the analyzed operational data that triggered the anomaly.
        /// 			The one supported source is Amazon CloudWatch metrics.
        public let sourceDetails: AnomalySourceDetails?
        /// The metadata of the source which detects proactive anomalies.
        public let sourceMetadata: AnomalySourceMetadata?
        /// The status of the anomaly.
        public let status: AnomalyStatus?
        ///  The time of the anomaly's most recent update.
        public let updateTime: Date?

        @inlinable
        public init(anomalyReportedTimeRange: AnomalyReportedTimeRange? = nil, anomalyResources: [AnomalyResource]? = nil, anomalyTimeRange: AnomalyTimeRange? = nil, associatedInsightId: String? = nil, description: String? = nil, id: String? = nil, limit: Double? = nil, predictionTimeRange: PredictionTimeRange? = nil, resourceCollection: ResourceCollection? = nil, severity: AnomalySeverity? = nil, sourceDetails: AnomalySourceDetails? = nil, sourceMetadata: AnomalySourceMetadata? = nil, status: AnomalyStatus? = nil, updateTime: Date? = nil) {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.description = description
            self.id = id
            self.limit = limit
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.sourceMetadata = sourceMetadata
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
            case anomalyResources = "AnomalyResources"
            case anomalyTimeRange = "AnomalyTimeRange"
            case associatedInsightId = "AssociatedInsightId"
            case description = "Description"
            case id = "Id"
            case limit = "Limit"
            case predictionTimeRange = "PredictionTimeRange"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case sourceDetails = "SourceDetails"
            case sourceMetadata = "SourceMetadata"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct ProactiveInsight: AWSDecodableShape {
        /// Describes the proactive insight.
        public let description: String?
        /// The ID of the proactive insight.
        public let id: String?
        public let insightTimeRange: InsightTimeRange?
        /// The name of the proactive insight.
        public let name: String?
        public let predictionTimeRange: PredictionTimeRange?
        public let resourceCollection: ResourceCollection?
        /// The severity of the insight. For more information, see
        /// 	Understanding
        /// 	insight severities in the Amazon DevOps Guru User Guide.
        public let severity: InsightSeverity?
        ///  The ID of the Amazon Web Services System Manager OpsItem created for this insight. You must enable
        /// 			the creation of OpstItems insights before they are created for each insight.
        public let ssmOpsItemId: String?
        /// The status of the proactive insight.
        public let status: InsightStatus?

        @inlinable
        public init(description: String? = nil, id: String? = nil, insightTimeRange: InsightTimeRange? = nil, name: String? = nil, predictionTimeRange: PredictionTimeRange? = nil, resourceCollection: ResourceCollection? = nil, severity: InsightSeverity? = nil, ssmOpsItemId: String? = nil, status: InsightStatus? = nil) {
            self.description = description
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.ssmOpsItemId = ssmOpsItemId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case id = "Id"
            case insightTimeRange = "InsightTimeRange"
            case name = "Name"
            case predictionTimeRange = "PredictionTimeRange"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case ssmOpsItemId = "SsmOpsItemId"
            case status = "Status"
        }
    }

    public struct ProactiveInsightSummary: AWSDecodableShape {
        /// The Amazon Resource Names (ARNs)
        /// 	of the Amazon Web Services resources that generated this insight.
        public let associatedResourceArns: [String]?
        /// The ID of the proactive insight.
        public let id: String?
        public let insightTimeRange: InsightTimeRange?
        /// The name of the proactive insight.
        public let name: String?
        public let predictionTimeRange: PredictionTimeRange?
        public let resourceCollection: ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public let serviceCollection: ServiceCollection?
        /// The severity of the insight. For more information, see
        /// 	Understanding
        /// 	insight severities in the Amazon DevOps Guru User Guide.
        public let severity: InsightSeverity?
        /// The status of the proactive insight.
        public let status: InsightStatus?

        @inlinable
        public init(associatedResourceArns: [String]? = nil, id: String? = nil, insightTimeRange: InsightTimeRange? = nil, name: String? = nil, predictionTimeRange: PredictionTimeRange? = nil, resourceCollection: ResourceCollection? = nil, serviceCollection: ServiceCollection? = nil, severity: InsightSeverity? = nil, status: InsightStatus? = nil) {
            self.associatedResourceArns = associatedResourceArns
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case associatedResourceArns = "AssociatedResourceArns"
            case id = "Id"
            case insightTimeRange = "InsightTimeRange"
            case name = "Name"
            case predictionTimeRange = "PredictionTimeRange"
            case resourceCollection = "ResourceCollection"
            case serviceCollection = "ServiceCollection"
            case severity = "Severity"
            case status = "Status"
        }
    }

    public struct ProactiveOrganizationInsightSummary: AWSDecodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountId: String?
        /// The ID of the insight summary.
        public let id: String?
        public let insightTimeRange: InsightTimeRange?
        /// The name of the insight summary.
        public let name: String?
        /// The ID of the organizational unit.
        public let organizationalUnitId: String?
        public let predictionTimeRange: PredictionTimeRange?
        public let resourceCollection: ResourceCollection?
        public let serviceCollection: ServiceCollection?
        ///  An array of severity values used to search for insights.
        /// 			For more information, see
        /// 	Understanding
        /// 	insight severities in the Amazon DevOps Guru User Guide.
        public let severity: InsightSeverity?
        ///  An array of status values used to search for insights.
        public let status: InsightStatus?

        @inlinable
        public init(accountId: String? = nil, id: String? = nil, insightTimeRange: InsightTimeRange? = nil, name: String? = nil, organizationalUnitId: String? = nil, predictionTimeRange: PredictionTimeRange? = nil, resourceCollection: ResourceCollection? = nil, serviceCollection: ServiceCollection? = nil, severity: InsightSeverity? = nil, status: InsightStatus? = nil) {
            self.accountId = accountId
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.organizationalUnitId = organizationalUnitId
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case id = "Id"
            case insightTimeRange = "InsightTimeRange"
            case name = "Name"
            case organizationalUnitId = "OrganizationalUnitId"
            case predictionTimeRange = "PredictionTimeRange"
            case resourceCollection = "ResourceCollection"
            case serviceCollection = "ServiceCollection"
            case severity = "Severity"
            case status = "Status"
        }
    }

    public struct PutFeedbackRequest: AWSEncodableShape {
        ///  The feedback from customers is about the recommendations in this insight.
        public let insightFeedback: InsightFeedback?

        @inlinable
        public init(insightFeedback: InsightFeedback? = nil) {
            self.insightFeedback = insightFeedback
        }

        public func validate(name: String) throws {
            try self.insightFeedback?.validate(name: "\(name).insightFeedback")
        }

        private enum CodingKeys: String, CodingKey {
            case insightFeedback = "InsightFeedback"
        }
    }

    public struct PutFeedbackResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ReactiveAnomaly: AWSDecodableShape {
        /// 			An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        ///
        public let anomalyReportedTimeRange: AnomalyReportedTimeRange?
        /// The Amazon Web Services resources in which anomalous behavior was detected by DevOps Guru.
        public let anomalyResources: [AnomalyResource]?
        public let anomalyTimeRange: AnomalyTimeRange?
        ///  The ID of the insight that contains this anomaly. An insight is composed of related
        /// 			anomalies.
        public let associatedInsightId: String?
        /// The ID of the causal anomaly that is associated with this  reactive anomaly. The ID of a `CAUSAL` anomaly is always `NULL`.
        public let causalAnomalyId: String?
        /// A description of the reactive anomaly.
        public let description: String?
        /// The ID of the reactive anomaly.
        public let id: String?
        /// The name of the reactive anomaly.
        public let name: String?
        public let resourceCollection: ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate
        /// 	an insight determine that insight's severity. For more information, see
        /// 	Understanding
        /// 	insight severities in the Amazon DevOps Guru User Guide.
        public let severity: AnomalySeverity?
        ///  Details about the source of the analyzed operational data that triggered the anomaly.
        /// 			The one supported source is Amazon CloudWatch metrics.
        public let sourceDetails: AnomalySourceDetails?
        ///  The status of the anomaly.
        public let status: AnomalyStatus?
        /// The type of the reactive anomaly. It can be one of the following types.    CAUSAL - the anomaly can cause a new insight.    CONTEXTUAL - the anomaly contains additional information about an insight or its causal anomaly.
        public let type: AnomalyType?

        @inlinable
        public init(anomalyReportedTimeRange: AnomalyReportedTimeRange? = nil, anomalyResources: [AnomalyResource]? = nil, anomalyTimeRange: AnomalyTimeRange? = nil, associatedInsightId: String? = nil, causalAnomalyId: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, resourceCollection: ResourceCollection? = nil, severity: AnomalySeverity? = nil, sourceDetails: AnomalySourceDetails? = nil, status: AnomalyStatus? = nil, type: AnomalyType? = nil) {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.causalAnomalyId = causalAnomalyId
            self.description = description
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
            case anomalyResources = "AnomalyResources"
            case anomalyTimeRange = "AnomalyTimeRange"
            case associatedInsightId = "AssociatedInsightId"
            case causalAnomalyId = "CausalAnomalyId"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case sourceDetails = "SourceDetails"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct ReactiveAnomalySummary: AWSDecodableShape {
        /// 			An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        ///
        public let anomalyReportedTimeRange: AnomalyReportedTimeRange?
        /// The Amazon Web Services resources in which anomalous behavior was detected by DevOps Guru.
        public let anomalyResources: [AnomalyResource]?
        public let anomalyTimeRange: AnomalyTimeRange?
        ///  The ID of the insight that contains this anomaly. An insight is composed of related
        /// 			anomalies.
        public let associatedInsightId: String?
        /// The ID of the causal anomaly that is associated with this  reactive anomaly. The ID of a `CAUSAL` anomaly is always `NULL`.
        public let causalAnomalyId: String?
        /// A description of the reactive anomaly.
        public let description: String?
        ///  The ID of the reactive anomaly.
        public let id: String?
        /// The name of the reactive anomaly.
        public let name: String?
        public let resourceCollection: ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate
        /// 	an insight determine that insight's severity. For more information, see
        /// 	Understanding
        /// 	insight severities in the Amazon DevOps Guru User Guide.
        public let severity: AnomalySeverity?
        ///  Details about the source of the analyzed operational data that triggered the anomaly.
        /// 			The one supported source is Amazon CloudWatch metrics.
        public let sourceDetails: AnomalySourceDetails?
        ///  The status of the reactive anomaly.
        public let status: AnomalyStatus?
        /// The type of the reactive anomaly. It can be one of the following types.    CAUSAL - the anomaly can cause a new insight.    CONTEXTUAL - the anomaly contains additional information about an insight or its causal anomaly.
        public let type: AnomalyType?

        @inlinable
        public init(anomalyReportedTimeRange: AnomalyReportedTimeRange? = nil, anomalyResources: [AnomalyResource]? = nil, anomalyTimeRange: AnomalyTimeRange? = nil, associatedInsightId: String? = nil, causalAnomalyId: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, resourceCollection: ResourceCollection? = nil, severity: AnomalySeverity? = nil, sourceDetails: AnomalySourceDetails? = nil, status: AnomalyStatus? = nil, type: AnomalyType? = nil) {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.causalAnomalyId = causalAnomalyId
            self.description = description
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
            case anomalyResources = "AnomalyResources"
            case anomalyTimeRange = "AnomalyTimeRange"
            case associatedInsightId = "AssociatedInsightId"
            case causalAnomalyId = "CausalAnomalyId"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case sourceDetails = "SourceDetails"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct ReactiveInsight: AWSDecodableShape {
        /// Describes the reactive insight.
        public let description: String?
        ///  The ID of a reactive insight.
        public let id: String?
        public let insightTimeRange: InsightTimeRange?
        ///  The name of a reactive insight.
        public let name: String?
        public let resourceCollection: ResourceCollection?
        /// The severity of the insight. For more information, see
        /// 	Understanding
        /// 	insight severities in the Amazon DevOps Guru User Guide.
        public let severity: InsightSeverity?
        ///  The ID of the Amazon Web Services System Manager OpsItem created for this insight. You must enable
        /// 			the creation of OpstItems insights before they are created for each insight.
        public let ssmOpsItemId: String?
        ///  The status of a reactive insight.
        public let status: InsightStatus?

        @inlinable
        public init(description: String? = nil, id: String? = nil, insightTimeRange: InsightTimeRange? = nil, name: String? = nil, resourceCollection: ResourceCollection? = nil, severity: InsightSeverity? = nil, ssmOpsItemId: String? = nil, status: InsightStatus? = nil) {
            self.description = description
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.ssmOpsItemId = ssmOpsItemId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case id = "Id"
            case insightTimeRange = "InsightTimeRange"
            case name = "Name"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case ssmOpsItemId = "SsmOpsItemId"
            case status = "Status"
        }
    }

    public struct ReactiveInsightSummary: AWSDecodableShape {
        /// The Amazon Resource Names (ARNs)
        /// 	of the Amazon Web Services resources that generated this insight.
        public let associatedResourceArns: [String]?
        ///  The ID of a reactive summary.
        public let id: String?
        public let insightTimeRange: InsightTimeRange?
        ///  The name of a reactive insight.
        public let name: String?
        public let resourceCollection: ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public let serviceCollection: ServiceCollection?
        /// The severity of the insight. For more information, see
        /// 	Understanding
        /// 	insight severities in the Amazon DevOps Guru User Guide.
        public let severity: InsightSeverity?
        ///  The status of a reactive insight.
        public let status: InsightStatus?

        @inlinable
        public init(associatedResourceArns: [String]? = nil, id: String? = nil, insightTimeRange: InsightTimeRange? = nil, name: String? = nil, resourceCollection: ResourceCollection? = nil, serviceCollection: ServiceCollection? = nil, severity: InsightSeverity? = nil, status: InsightStatus? = nil) {
            self.associatedResourceArns = associatedResourceArns
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case associatedResourceArns = "AssociatedResourceArns"
            case id = "Id"
            case insightTimeRange = "InsightTimeRange"
            case name = "Name"
            case resourceCollection = "ResourceCollection"
            case serviceCollection = "ServiceCollection"
            case severity = "Severity"
            case status = "Status"
        }
    }

    public struct ReactiveOrganizationInsightSummary: AWSDecodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountId: String?
        /// The ID of the insight summary.
        public let id: String?
        public let insightTimeRange: InsightTimeRange?
        /// The name of the insight summary.
        public let name: String?
        /// The ID of the organizational unit.
        public let organizationalUnitId: String?
        public let resourceCollection: ResourceCollection?
        public let serviceCollection: ServiceCollection?
        ///  An array of severity values used to search for insights.
        /// 			For more information, see
        /// 	Understanding
        /// 	insight severities in the Amazon DevOps Guru User Guide.
        public let severity: InsightSeverity?
        ///  An array of status values used to search for insights.
        public let status: InsightStatus?

        @inlinable
        public init(accountId: String? = nil, id: String? = nil, insightTimeRange: InsightTimeRange? = nil, name: String? = nil, organizationalUnitId: String? = nil, resourceCollection: ResourceCollection? = nil, serviceCollection: ServiceCollection? = nil, severity: InsightSeverity? = nil, status: InsightStatus? = nil) {
            self.accountId = accountId
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.organizationalUnitId = organizationalUnitId
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case id = "Id"
            case insightTimeRange = "InsightTimeRange"
            case name = "Name"
            case organizationalUnitId = "OrganizationalUnitId"
            case resourceCollection = "ResourceCollection"
            case serviceCollection = "ServiceCollection"
            case severity = "Severity"
            case status = "Status"
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// The category type of the recommendation.
        public let category: String?
        ///  A description of the problem.
        public let description: String?
        ///  A hyperlink to information to help you address the problem.
        public let link: String?
        ///  The name of the recommendation.
        public let name: String?
        ///  The reason DevOps Guru flagged the anomalous behavior as a problem.
        public let reason: String?
        ///  Anomalies that are related to the problem. Use these Anomalies to learn more about
        /// 			what's happening and to help address the issue.
        public let relatedAnomalies: [RecommendationRelatedAnomaly]?
        ///  Events that are related to the problem. Use these events to learn more about what's
        /// 			happening and to help address the issue.
        public let relatedEvents: [RecommendationRelatedEvent]?

        @inlinable
        public init(category: String? = nil, description: String? = nil, link: String? = nil, name: String? = nil, reason: String? = nil, relatedAnomalies: [RecommendationRelatedAnomaly]? = nil, relatedEvents: [RecommendationRelatedEvent]? = nil) {
            self.category = category
            self.description = description
            self.link = link
            self.name = name
            self.reason = reason
            self.relatedAnomalies = relatedAnomalies
            self.relatedEvents = relatedEvents
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case description = "Description"
            case link = "Link"
            case name = "Name"
            case reason = "Reason"
            case relatedAnomalies = "RelatedAnomalies"
            case relatedEvents = "RelatedEvents"
        }
    }

    public struct RecommendationRelatedAnomaly: AWSDecodableShape {
        /// The ID of an anomaly that generated the insight with this recommendation.
        public let anomalyId: String?
        ///  An array of objects that represent resources in which DevOps Guru detected anomalous
        /// 			behavior. Each object contains the name and type of the resource.
        public let resources: [RecommendationRelatedAnomalyResource]?
        ///  Information about where the anomalous behavior related the recommendation was found.
        /// 			For example, details in Amazon CloudWatch metrics.
        public let sourceDetails: [RecommendationRelatedAnomalySourceDetail]?

        @inlinable
        public init(anomalyId: String? = nil, resources: [RecommendationRelatedAnomalyResource]? = nil, sourceDetails: [RecommendationRelatedAnomalySourceDetail]? = nil) {
            self.anomalyId = anomalyId
            self.resources = resources
            self.sourceDetails = sourceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyId = "AnomalyId"
            case resources = "Resources"
            case sourceDetails = "SourceDetails"
        }
    }

    public struct RecommendationRelatedAnomalyResource: AWSDecodableShape {
        ///  The name of the resource.
        public let name: String?
        ///  The type of the resource. Resource types take the same form that is used by Amazon Web Services CloudFormation
        /// 			resource type identifiers, service-provider::service-name::data-type-name.
        /// 			For example, AWS::RDS::DBCluster. For more information, see Amazon Web Services
        /// 				resource and property types reference in the Amazon Web Services CloudFormation User
        /// 				Guide.
        public let type: String?

        @inlinable
        public init(name: String? = nil, type: String? = nil) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct RecommendationRelatedAnomalySourceDetail: AWSDecodableShape {
        ///  An array of CloudWatchMetricsDetail objects that contains information
        /// 			about the analyzed metrics that displayed anomalous behavior.
        public let cloudWatchMetrics: [RecommendationRelatedCloudWatchMetricsSourceDetail]?

        @inlinable
        public init(cloudWatchMetrics: [RecommendationRelatedCloudWatchMetricsSourceDetail]? = nil) {
            self.cloudWatchMetrics = cloudWatchMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchMetrics = "CloudWatchMetrics"
        }
    }

    public struct RecommendationRelatedCloudWatchMetricsSourceDetail: AWSDecodableShape {
        /// The name of the CloudWatch metric.
        public let metricName: String?
        /// The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.
        public let namespace: String?

        @inlinable
        public init(metricName: String? = nil, namespace: String? = nil) {
            self.metricName = metricName
            self.namespace = namespace
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case namespace = "Namespace"
        }
    }

    public struct RecommendationRelatedEvent: AWSDecodableShape {
        ///  The name of the event. This corresponds to the Name field in an
        /// 				Event object.
        public let name: String?
        ///  A ResourceCollection object that contains arrays of the names of Amazon Web Services
        /// 			CloudFormation stacks. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public let resources: [RecommendationRelatedEventResource]?

        @inlinable
        public init(name: String? = nil, resources: [RecommendationRelatedEventResource]? = nil) {
            self.name = name
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case resources = "Resources"
        }
    }

    public struct RecommendationRelatedEventResource: AWSDecodableShape {
        ///  The name of the resource that emitted the event. This corresponds to the
        /// 				Name field in an EventResource object.
        public let name: String?
        ///  The type of the resource that emitted the event. This corresponds to the
        /// 				Type field in an EventResource object.
        public let type: String?

        @inlinable
        public init(name: String? = nil, type: String? = nil) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct RemoveNotificationChannelRequest: AWSEncodableShape {
        ///  The ID of the notification channel to be removed.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveNotificationChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ResourceCollection: AWSEncodableShape & AWSDecodableShape {
        ///  An array of the names of Amazon Web Services CloudFormation stacks. The stacks define Amazon Web Services resources that
        /// 			DevOps Guru analyzes. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public let cloudFormation: CloudFormationCollection?
        /// The Amazon Web Services tags that are used by resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support 		tagging, so you can assign the same tag to resources from different services to indicate 		that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB 		table resource that you assign to an Lambda function. For more information about 		using tags, see the Tagging 			best practices whitepaper.  Each Amazon Web Services tag has two parts.    A tag key (for example, CostCenter, 				Environment, Project, or Secret). Tag 				keys are case-sensitive.   An optional field known as a tag value (for example, 				111122223333, Production, or a team 				name). Omitting the tag value is the same as using an empty 				string. Like tag keys, tag values are 				case-sensitive.   Together these are known as key-value pairs.  The string used for a key in a tag that you use to define your resource coverage must begin with the
        /// 			prefix Devops-guru-. The tag key might be
        /// 			DevOps-Guru-deployment-application or
        /// 			devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive.
        /// 			 For example, DevOps Guru works with a
        /// 			key named devops-guru-rds and a key named
        /// 			DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your
        /// 			application might be Devops-Guru-production-application/RDS or
        /// 			Devops-Guru-production-application/containers.
        public let tags: [TagCollection]?

        @inlinable
        public init(cloudFormation: CloudFormationCollection? = nil, tags: [TagCollection]? = nil) {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.cloudFormation?.validate(name: "\(name).cloudFormation")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "CloudFormation"
            case tags = "Tags"
        }
    }

    public struct ResourceCollectionFilter: AWSDecodableShape {
        ///  Information about Amazon Web Services CloudFormation stacks. You can use up to 500
        /// 			stacks to specify which Amazon Web Services resources in your account to analyze. For more
        /// 			information, see Stacks in the
        /// 				Amazon Web Services CloudFormation User Guide.
        public let cloudFormation: CloudFormationCollectionFilter?
        /// The Amazon Web Services tags used to filter the resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support 		tagging, so you can assign the same tag to resources from different services to indicate 		that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB 		table resource that you assign to an Lambda function. For more information about 		using tags, see the Tagging 			best practices whitepaper.  Each Amazon Web Services tag has two parts.    A tag key (for example, CostCenter, 				Environment, Project, or Secret). Tag 				keys are case-sensitive.   An optional field known as a tag value (for example, 				111122223333, Production, or a team 				name). Omitting the tag value is the same as using an empty 				string. Like tag keys, tag values are 				case-sensitive.   Together these are known as key-value pairs.  The string used for a key in a tag that you use to define your resource coverage must begin with the
        /// 			prefix Devops-guru-. The tag key might be
        /// 			DevOps-Guru-deployment-application or
        /// 			devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive.
        /// 			 For example, DevOps Guru works with a
        /// 			key named devops-guru-rds and a key named
        /// 			DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your
        /// 			application might be Devops-Guru-production-application/RDS or
        /// 			Devops-Guru-production-application/containers.
        public let tags: [TagCollectionFilter]?

        @inlinable
        public init(cloudFormation: CloudFormationCollectionFilter? = nil, tags: [TagCollectionFilter]? = nil) {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "CloudFormation"
            case tags = "Tags"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        ///  The ID of the Amazon Web Services resource that could not be found.
        public let resourceId: String
        ///  The type of the Amazon Web Services resource that could not be found.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct SearchInsightsFilters: AWSEncodableShape {
        public let resourceCollection: ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public let serviceCollection: ServiceCollection?
        ///  An array of severity values used to search for insights.
        public let severities: [InsightSeverity]?
        ///  An array of status values used to search for insights.
        public let statuses: [InsightStatus]?

        @inlinable
        public init(resourceCollection: ResourceCollection? = nil, serviceCollection: ServiceCollection? = nil, severities: [InsightSeverity]? = nil, statuses: [InsightStatus]? = nil) {
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severities = severities
            self.statuses = statuses
        }

        public func validate(name: String) throws {
            try self.resourceCollection?.validate(name: "\(name).resourceCollection")
            try self.validate(self.severities, name: "severities", parent: name, max: 3)
            try self.validate(self.statuses, name: "statuses", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceCollection = "ResourceCollection"
            case serviceCollection = "ServiceCollection"
            case severities = "Severities"
            case statuses = "Statuses"
        }
    }

    public struct SearchInsightsRequest: AWSEncodableShape {
        ///  A SearchInsightsFilters object that is used to set the severity and
        /// 			status filters on your insight search.
        public let filters: SearchInsightsFilters?
        /// The maximum number of results to return with a single call.
        /// 	To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        ///  The start of the time range passed in. Returned insights occurred after this time.
        ///
        public let startTimeRange: StartTimeRange
        ///  The type of insights you are searching for (REACTIVE or
        /// 				PROACTIVE).
        public let type: InsightType

        @inlinable
        public init(filters: SearchInsightsFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, startTimeRange: StartTimeRange, type: InsightType) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTimeRange = startTimeRange
            self.type = type
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTimeRange = "StartTimeRange"
            case type = "Type"
        }
    }

    public struct SearchInsightsResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        ///  The returned proactive insights.
        public let proactiveInsights: [ProactiveInsightSummary]?
        ///  The returned reactive insights.
        public let reactiveInsights: [ReactiveInsightSummary]?

        @inlinable
        public init(nextToken: String? = nil, proactiveInsights: [ProactiveInsightSummary]? = nil, reactiveInsights: [ReactiveInsightSummary]? = nil) {
            self.nextToken = nextToken
            self.proactiveInsights = proactiveInsights
            self.reactiveInsights = reactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proactiveInsights = "ProactiveInsights"
            case reactiveInsights = "ReactiveInsights"
        }
    }

    public struct SearchOrganizationInsightsFilters: AWSEncodableShape {
        public let resourceCollection: ResourceCollection?
        public let serviceCollection: ServiceCollection?
        ///  An array of severity values used to search for insights.
        public let severities: [InsightSeverity]?
        ///  An array of status values used to search for insights.
        public let statuses: [InsightStatus]?

        @inlinable
        public init(resourceCollection: ResourceCollection? = nil, serviceCollection: ServiceCollection? = nil, severities: [InsightSeverity]? = nil, statuses: [InsightStatus]? = nil) {
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severities = severities
            self.statuses = statuses
        }

        public func validate(name: String) throws {
            try self.resourceCollection?.validate(name: "\(name).resourceCollection")
            try self.validate(self.severities, name: "severities", parent: name, max: 3)
            try self.validate(self.statuses, name: "statuses", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceCollection = "ResourceCollection"
            case serviceCollection = "ServiceCollection"
            case severities = "Severities"
            case statuses = "Statuses"
        }
    }

    public struct SearchOrganizationInsightsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountIds: [String]
        ///  A SearchOrganizationInsightsFilters object that is used to set the
        /// 			severity and status filters on your insight search.
        public let filters: SearchOrganizationInsightsFilters?
        /// The maximum number of results to return with a single call.
        /// 	To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve  the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        public let startTimeRange: StartTimeRange
        ///  The type of insights you are searching for (REACTIVE or
        /// 				PROACTIVE).
        public let type: InsightType

        @inlinable
        public init(accountIds: [String], filters: SearchOrganizationInsightsFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, startTimeRange: StartTimeRange, type: InsightType) {
            self.accountIds = accountIds
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTimeRange = startTimeRange
            self.type = type
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 1)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTimeRange = "StartTimeRange"
            case type = "Type"
        }
    }

    public struct SearchOrganizationInsightsResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve  the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// An integer that specifies the number of open proactive insights in your Amazon Web Services
        /// 			account.
        public let proactiveInsights: [ProactiveInsightSummary]?
        /// An integer that specifies the number of open reactive insights in your Amazon Web Services
        /// 			account.
        public let reactiveInsights: [ReactiveInsightSummary]?

        @inlinable
        public init(nextToken: String? = nil, proactiveInsights: [ProactiveInsightSummary]? = nil, reactiveInsights: [ReactiveInsightSummary]? = nil) {
            self.nextToken = nextToken
            self.proactiveInsights = proactiveInsights
            self.reactiveInsights = reactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proactiveInsights = "ProactiveInsights"
            case reactiveInsights = "ReactiveInsights"
        }
    }

    public struct ServiceCollection: AWSEncodableShape & AWSDecodableShape {
        /// An array of strings that each specifies the name of an Amazon Web Services service.
        public let serviceNames: [ServiceName]?

        @inlinable
        public init(serviceNames: [ServiceName]? = nil) {
            self.serviceNames = serviceNames
        }

        private enum CodingKeys: String, CodingKey {
            case serviceNames = "ServiceNames"
        }
    }

    public struct ServiceHealth: AWSDecodableShape {
        /// 			Number of resources that DevOps Guru is monitoring in an analyzed Amazon Web Services service.
        ///
        public let analyzedResourceCount: Int64?
        /// Represents the health of an Amazon Web Services service. This is a ServiceInsightHealth
        /// 			that contains the number of open proactive and reactive insights for this
        /// 			service.
        public let insight: ServiceInsightHealth?
        /// The name of the Amazon Web Services service.
        public let serviceName: ServiceName?

        @inlinable
        public init(analyzedResourceCount: Int64? = nil, insight: ServiceInsightHealth? = nil, serviceName: ServiceName? = nil) {
            self.analyzedResourceCount = analyzedResourceCount
            self.insight = insight
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case analyzedResourceCount = "AnalyzedResourceCount"
            case insight = "Insight"
            case serviceName = "ServiceName"
        }
    }

    public struct ServiceInsightHealth: AWSDecodableShape {
        /// The number of open proactive insights in the Amazon Web Services service
        public let openProactiveInsights: Int?
        /// The number of open reactive insights in the Amazon Web Services service
        public let openReactiveInsights: Int?

        @inlinable
        public init(openProactiveInsights: Int? = nil, openReactiveInsights: Int? = nil) {
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case openProactiveInsights = "OpenProactiveInsights"
            case openReactiveInsights = "OpenReactiveInsights"
        }
    }

    public struct ServiceIntegrationConfig: AWSDecodableShape {
        /// 			Information about whether DevOps Guru is configured to encrypt server-side data using KMS.
        ///
        public let kmsServerSideEncryption: KMSServerSideEncryptionIntegration?
        /// 			Information about whether DevOps Guru is configured to perform log anomaly detection on Amazon CloudWatch log groups.
        ///
        public let logsAnomalyDetection: LogsAnomalyDetectionIntegration?
        ///  Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager
        /// 			OpsCenter for each created insight.
        public let opsCenter: OpsCenterIntegration?

        @inlinable
        public init(kmsServerSideEncryption: KMSServerSideEncryptionIntegration? = nil, logsAnomalyDetection: LogsAnomalyDetectionIntegration? = nil, opsCenter: OpsCenterIntegration? = nil) {
            self.kmsServerSideEncryption = kmsServerSideEncryption
            self.logsAnomalyDetection = logsAnomalyDetection
            self.opsCenter = opsCenter
        }

        private enum CodingKeys: String, CodingKey {
            case kmsServerSideEncryption = "KMSServerSideEncryption"
            case logsAnomalyDetection = "LogsAnomalyDetection"
            case opsCenter = "OpsCenter"
        }
    }

    public struct ServiceResourceCost: AWSDecodableShape {
        /// The total estimated monthly cost to analyze the active resources for this
        /// 			resource.
        public let cost: Double?
        /// The number of active resources analyzed for this service to create a monthly cost
        /// 			estimate.
        public let count: Int?
        /// The state of the resource. The resource is ACTIVE if it produces metrics,
        /// 			events, or logs within an hour, otherwise it is INACTIVE. You pay for the
        /// 			number of active Amazon Web Services resource hours analyzed for each resource. Inactive resources are
        /// 			not charged.
        public let state: CostEstimationServiceResourceState?
        /// The type of the Amazon Web Services resource.
        public let type: String?
        /// The price per hour to analyze the resources in the service.
        /// 			For more information,
        /// 			see Estimate your
        /// 			Amazon DevOps Guru costs and
        /// 			Amazon DevOps Guru pricing.
        public let unitCost: Double?

        @inlinable
        public init(cost: Double? = nil, count: Int? = nil, state: CostEstimationServiceResourceState? = nil, type: String? = nil, unitCost: Double? = nil) {
            self.cost = cost
            self.count = count
            self.state = state
            self.type = type
            self.unitCost = unitCost
        }

        private enum CodingKeys: String, CodingKey {
            case cost = "Cost"
            case count = "Count"
            case state = "State"
            case type = "Type"
            case unitCost = "UnitCost"
        }
    }

    public struct SnsChannelConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic.
        public let topicArn: String?

        @inlinable
        public init(topicArn: String? = nil) {
            self.topicArn = topicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.topicArn, name: "topicArn", parent: name, max: 1024)
            try self.validate(self.topicArn, name: "topicArn", parent: name, min: 36)
            try self.validate(self.topicArn, name: "topicArn", parent: name, pattern: "^arn:aws[a-z0-9-]*:sns:[a-z0-9-]+:\\d{12}:[^:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case topicArn = "TopicArn"
        }
    }

    public struct StartCostEstimationRequest: AWSEncodableShape {
        /// The idempotency token used to identify each cost estimate request.
        public let clientToken: String?
        /// The collection of Amazon Web Services resources used to create a monthly DevOps Guru cost estimate.
        public let resourceCollection: CostEstimationResourceCollectionFilter

        @inlinable
        public init(clientToken: String? = StartCostEstimationRequest.idempotencyToken(), resourceCollection: CostEstimationResourceCollectionFilter) {
            self.clientToken = clientToken
            self.resourceCollection = resourceCollection
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9]+[a-zA-Z0-9-]*$")
            try self.resourceCollection.validate(name: "\(name).resourceCollection")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case resourceCollection = "ResourceCollection"
        }
    }

    public struct StartCostEstimationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartTimeRange: AWSEncodableShape {
        ///  The start time of the time range.
        public let fromTime: Date?
        ///  The end time of the time range.
        public let toTime: Date?

        @inlinable
        public init(fromTime: Date? = nil, toTime: Date? = nil) {
            self.fromTime = fromTime
            self.toTime = toTime
        }

        private enum CodingKeys: String, CodingKey {
            case fromTime = "FromTime"
            case toTime = "ToTime"
        }
    }

    public struct TagCollection: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that  	DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make  up your DevOps Guru application and analysis boundary.  The string used for a key in a tag that you use to define your resource coverage must begin with the
        /// 			prefix Devops-guru-. The tag key might be
        /// 			DevOps-Guru-deployment-application or
        /// 			devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive.
        /// 			 For example, DevOps Guru works with a
        /// 			key named devops-guru-rds and a key named
        /// 			DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your
        /// 			application might be Devops-Guru-production-application/RDS or
        /// 			Devops-Guru-production-application/containers.
        public let appBoundaryKey: String
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with
        /// 					the tag key (for example, 111122223333, Production, or a team 				name). The key and value are the tag's key pair.  				Omitting the tag value is the same as using an empty 				string. Like tag keys, tag values are 				case-sensitive. You can specify a maximum of 256 characters for a tag value.
        public let tagValues: [String]

        @inlinable
        public init(appBoundaryKey: String, tagValues: [String]) {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }

        public func validate(name: String) throws {
            try self.validate(self.appBoundaryKey, name: "appBoundaryKey", parent: name, max: 128)
            try self.validate(self.appBoundaryKey, name: "appBoundaryKey", parent: name, min: 1)
            try self.validate(self.appBoundaryKey, name: "appBoundaryKey", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.tagValues.forEach {
                try validate($0, name: "tagValues[]", parent: name, max: 256)
                try validate($0, name: "tagValues[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*|\\*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case appBoundaryKey = "AppBoundaryKey"
            case tagValues = "TagValues"
        }
    }

    public struct TagCollectionFilter: AWSDecodableShape {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that  	DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make  up your DevOps Guru application and analysis boundary.  The string used for a key in a tag that you use to define your resource coverage must begin with the
        /// 			prefix Devops-guru-. The tag key might be
        /// 			DevOps-Guru-deployment-application or
        /// 			devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive.
        /// 			 For example, DevOps Guru works with a
        /// 			key named devops-guru-rds and a key named
        /// 			DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your
        /// 			application might be Devops-Guru-production-application/RDS or
        /// 			Devops-Guru-production-application/containers.
        public let appBoundaryKey: String
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with
        /// 					the tag key (for example, 111122223333, Production, or a team 				name). The key and value are the tag's key pair.  				Omitting the tag value is the same as using an empty 				string. Like tag keys, tag values are 				case-sensitive. You can specify a maximum of 256 characters for a tag value.
        public let tagValues: [String]

        @inlinable
        public init(appBoundaryKey: String, tagValues: [String]) {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }

        private enum CodingKeys: String, CodingKey {
            case appBoundaryKey = "AppBoundaryKey"
            case tagValues = "TagValues"
        }
    }

    public struct TagCostEstimationResourceCollectionFilter: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that  	DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make  up your DevOps Guru application and analysis boundary.  The string used for a key in a tag that you use to define your resource coverage must begin with the
        /// 			prefix Devops-guru-. The tag key might be
        /// 			DevOps-Guru-deployment-application or
        /// 			devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive.
        /// 			 For example, DevOps Guru works with a
        /// 			key named devops-guru-rds and a key named
        /// 			DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your
        /// 			application might be Devops-Guru-production-application/RDS or
        /// 			Devops-Guru-production-application/containers.
        public let appBoundaryKey: String
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with
        /// 					the tag key (for example, 111122223333, Production, or a team 				name). The key and value are the tag's key pair.  				Omitting the tag value is the same as using an empty 				string. Like tag keys, tag values are 				case-sensitive. You can specify a maximum of 256 characters for a tag value.
        public let tagValues: [String]

        @inlinable
        public init(appBoundaryKey: String, tagValues: [String]) {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }

        public func validate(name: String) throws {
            try self.validate(self.appBoundaryKey, name: "appBoundaryKey", parent: name, max: 128)
            try self.validate(self.appBoundaryKey, name: "appBoundaryKey", parent: name, min: 1)
            try self.validate(self.appBoundaryKey, name: "appBoundaryKey", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.tagValues.forEach {
                try validate($0, name: "tagValues[]", parent: name, max: 256)
                try validate($0, name: "tagValues[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*|\\*)$")
            }
            try self.validate(self.tagValues, name: "tagValues", parent: name, max: 1)
            try self.validate(self.tagValues, name: "tagValues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appBoundaryKey = "AppBoundaryKey"
            case tagValues = "TagValues"
        }
    }

    public struct TagHealth: AWSDecodableShape {
        /// 			Number of resources that DevOps Guru is monitoring in your account that are specified by an Amazon Web Services tag.
        ///
        public let analyzedResourceCount: Int64?
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that  	DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make  up your DevOps Guru application and analysis boundary.  The string used for a key in a tag that you use to define your resource coverage must begin with the
        /// 			prefix Devops-guru-. The tag key might be
        /// 			DevOps-Guru-deployment-application or
        /// 			devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive.
        /// 			 For example, DevOps Guru works with a
        /// 			key named devops-guru-rds and a key named
        /// 			DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your
        /// 			application might be Devops-Guru-production-application/RDS or
        /// 			Devops-Guru-production-application/containers.
        public let appBoundaryKey: String?
        /// Information about the health of the Amazon Web Services resources in your account that are specified
        /// 			by an Amazon Web Services tag, including the number of open proactive, open reactive insights, and the
        /// 			Mean Time to Recover (MTTR) of closed insights.
        public let insight: InsightHealth?
        /// The value in an Amazon Web Services tag. The tag's value is an optional field used to associate a string with
        /// 					the tag key (for example, 111122223333, Production, or a team 				name). The key and value are the tag's key pair.  				Omitting the tag value is the same as using an empty 				string. Like tag keys, tag values are 				case-sensitive. You can specify a maximum of 256 characters for a tag value.
        public let tagValue: String?

        @inlinable
        public init(analyzedResourceCount: Int64? = nil, appBoundaryKey: String? = nil, insight: InsightHealth? = nil, tagValue: String? = nil) {
            self.analyzedResourceCount = analyzedResourceCount
            self.appBoundaryKey = appBoundaryKey
            self.insight = insight
            self.tagValue = tagValue
        }

        private enum CodingKeys: String, CodingKey {
            case analyzedResourceCount = "AnalyzedResourceCount"
            case appBoundaryKey = "AppBoundaryKey"
            case insight = "Insight"
            case tagValue = "TagValue"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        ///  The code of the quota that was exceeded, causing the throttling exception.
        public let quotaCode: String?
        ///  The number of seconds after which the action that caused the throttling exception can
        /// 			be retried.
        public let retryAfterSeconds: Int?
        ///  The code of the service that caused the throttling exception.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case quotaCode = "QuotaCode"
            case serviceCode = "ServiceCode"
        }
    }

    public struct TimestampMetricValuePair: AWSDecodableShape {
        /// Value of the anomalous metric data point at respective Timestamp.
        public let metricValue: Double?
        /// A Timestamp that specifies the time the event occurred.
        public let timestamp: Date?

        @inlinable
        public init(metricValue: Double? = nil, timestamp: Date? = nil) {
            self.metricValue = metricValue
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case metricValue = "MetricValue"
            case timestamp = "Timestamp"
        }
    }

    public struct UpdateCloudFormationCollectionFilter: AWSEncodableShape {
        ///  An array of the names of the Amazon Web Services CloudFormation stacks to update. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        ///
        public let stackNames: [String]?

        @inlinable
        public init(stackNames: [String]? = nil) {
            self.stackNames = stackNames
        }

        public func validate(name: String) throws {
            try self.stackNames?.forEach {
                try validate($0, name: "stackNames[]", parent: name, max: 128)
                try validate($0, name: "stackNames[]", parent: name, min: 1)
                try validate($0, name: "stackNames[]", parent: name, pattern: "^[a-zA-Z*]+[a-zA-Z0-9-]*$")
            }
            try self.validate(self.stackNames, name: "stackNames", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case stackNames = "StackNames"
        }
    }

    public struct UpdateEventSourcesConfigRequest: AWSEncodableShape {
        /// Configuration information about the integration of DevOps Guru as the Consumer via
        /// 			EventBridge with another AWS Service.
        public let eventSources: EventSourcesConfig?

        @inlinable
        public init(eventSources: EventSourcesConfig? = nil) {
            self.eventSources = eventSources
        }

        private enum CodingKeys: String, CodingKey {
            case eventSources = "EventSources"
        }
    }

    public struct UpdateEventSourcesConfigResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateResourceCollectionFilter: AWSEncodableShape {
        ///  A collection of Amazon Web Services CloudFormation stacks. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public let cloudFormation: UpdateCloudFormationCollectionFilter?
        /// The updated Amazon Web Services tags used to filter the resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support 		tagging, so you can assign the same tag to resources from different services to indicate 		that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB 		table resource that you assign to an Lambda function. For more information about 		using tags, see the Tagging 			best practices whitepaper.  Each Amazon Web Services tag has two parts.    A tag key (for example, CostCenter, 				Environment, Project, or Secret). Tag 				keys are case-sensitive.   An optional field known as a tag value (for example, 				111122223333, Production, or a team 				name). Omitting the tag value is the same as using an empty 				string. Like tag keys, tag values are 				case-sensitive.   Together these are known as key-value pairs.  The string used for a key in a tag that you use to define your resource coverage must begin with the
        /// 			prefix Devops-guru-. The tag key might be
        /// 			DevOps-Guru-deployment-application or
        /// 			devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive.
        /// 			 For example, DevOps Guru works with a
        /// 			key named devops-guru-rds and a key named
        /// 			DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your
        /// 			application might be Devops-Guru-production-application/RDS or
        /// 			Devops-Guru-production-application/containers.
        public let tags: [UpdateTagCollectionFilter]?

        @inlinable
        public init(cloudFormation: UpdateCloudFormationCollectionFilter? = nil, tags: [UpdateTagCollectionFilter]? = nil) {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.cloudFormation?.validate(name: "\(name).cloudFormation")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "CloudFormation"
            case tags = "Tags"
        }
    }

    public struct UpdateResourceCollectionRequest: AWSEncodableShape {
        ///  Specifies if the resource collection in the request is added or deleted to the
        /// 			resource collection.
        public let action: UpdateResourceCollectionAction
        public let resourceCollection: UpdateResourceCollectionFilter

        @inlinable
        public init(action: UpdateResourceCollectionAction, resourceCollection: UpdateResourceCollectionFilter) {
            self.action = action
            self.resourceCollection = resourceCollection
        }

        public func validate(name: String) throws {
            try self.resourceCollection.validate(name: "\(name).resourceCollection")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case resourceCollection = "ResourceCollection"
        }
    }

    public struct UpdateResourceCollectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateServiceIntegrationConfig: AWSEncodableShape {
        /// 			Information about whether DevOps Guru is configured to encrypt server-side data using KMS.
        ///
        public let kmsServerSideEncryption: KMSServerSideEncryptionIntegrationConfig?
        /// 			Information about whether DevOps Guru is configured to perform log anomaly detection on Amazon CloudWatch log groups.
        ///
        public let logsAnomalyDetection: LogsAnomalyDetectionIntegrationConfig?
        public let opsCenter: OpsCenterIntegrationConfig?

        @inlinable
        public init(kmsServerSideEncryption: KMSServerSideEncryptionIntegrationConfig? = nil, logsAnomalyDetection: LogsAnomalyDetectionIntegrationConfig? = nil, opsCenter: OpsCenterIntegrationConfig? = nil) {
            self.kmsServerSideEncryption = kmsServerSideEncryption
            self.logsAnomalyDetection = logsAnomalyDetection
            self.opsCenter = opsCenter
        }

        public func validate(name: String) throws {
            try self.kmsServerSideEncryption?.validate(name: "\(name).kmsServerSideEncryption")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsServerSideEncryption = "KMSServerSideEncryption"
            case logsAnomalyDetection = "LogsAnomalyDetection"
            case opsCenter = "OpsCenter"
        }
    }

    public struct UpdateServiceIntegrationRequest: AWSEncodableShape {
        ///  An IntegratedServiceConfig object used to specify the integrated service
        /// 			you want to update, and whether you want to update it to enabled or disabled.
        public let serviceIntegration: UpdateServiceIntegrationConfig

        @inlinable
        public init(serviceIntegration: UpdateServiceIntegrationConfig) {
            self.serviceIntegration = serviceIntegration
        }

        public func validate(name: String) throws {
            try self.serviceIntegration.validate(name: "\(name).serviceIntegration")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceIntegration = "ServiceIntegration"
        }
    }

    public struct UpdateServiceIntegrationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTagCollectionFilter: AWSEncodableShape {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that  	DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make  up your DevOps Guru application and analysis boundary.  The string used for a key in a tag that you use to define your resource coverage must begin with the
        /// 			prefix Devops-guru-. The tag key might be
        /// 			DevOps-Guru-deployment-application or
        /// 			devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive.
        /// 			 For example, DevOps Guru works with a
        /// 			key named devops-guru-rds and a key named
        /// 			DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your
        /// 			application might be Devops-Guru-production-application/RDS or
        /// 			Devops-Guru-production-application/containers.
        public let appBoundaryKey: String
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with
        /// 					the tag key (for example, 111122223333, Production, or a team 				name). The key and value are the tag's key pair.  				Omitting the tag value is the same as using an empty 				string. Like tag keys, tag values are 				case-sensitive. You can specify a maximum of 256 characters for a tag value.
        public let tagValues: [String]

        @inlinable
        public init(appBoundaryKey: String, tagValues: [String]) {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }

        public func validate(name: String) throws {
            try self.validate(self.appBoundaryKey, name: "appBoundaryKey", parent: name, max: 128)
            try self.validate(self.appBoundaryKey, name: "appBoundaryKey", parent: name, min: 1)
            try self.validate(self.appBoundaryKey, name: "appBoundaryKey", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.tagValues.forEach {
                try validate($0, name: "tagValues[]", parent: name, max: 256)
                try validate($0, name: "tagValues[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*|\\*)$")
            }
            try self.validate(self.tagValues, name: "tagValues", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case appBoundaryKey = "AppBoundaryKey"
            case tagValues = "TagValues"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let fields: [ValidationExceptionField]?
        ///  A message that describes the validation exception.
        public let message: String
        ///  The reason the validation exception was thrown.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(fields: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason? = nil) {
            self.fields = fields
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        ///  The message associated with the validation exception with information to help
        /// 			determine its cause.
        public let message: String
        ///  The name of the field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case name = "Name"
        }
    }
}

// MARK: - Errors

/// Error enum for DevOpsGuru
public struct DevOpsGuruErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize DevOpsGuru
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  You don't have permissions to perform the requested operation. The user or role that
    /// 			is making the request must have at least one IAM permissions policy attached that grants
    /// 			the required permissions. For more information, see Access Management in the
    /// 				IAM User Guide.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  An exception that is thrown when a conflict occurs.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal failure in an Amazon service occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// A requested resource could not be found
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request contains a value that exceeds a maximum quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to a request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  Contains information about data passed in to a field during a request that is not
    /// 			valid.
    public static var validationException: Self { .init(.validationException) }
}

extension DevOpsGuruErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": DevOpsGuru.ConflictException.self,
        "InternalServerException": DevOpsGuru.InternalServerException.self,
        "ResourceNotFoundException": DevOpsGuru.ResourceNotFoundException.self,
        "ThrottlingException": DevOpsGuru.ThrottlingException.self,
        "ValidationException": DevOpsGuru.ValidationException.self
    ]
}

extension DevOpsGuruErrorType: Equatable {
    public static func == (lhs: DevOpsGuruErrorType, rhs: DevOpsGuruErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension DevOpsGuruErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
