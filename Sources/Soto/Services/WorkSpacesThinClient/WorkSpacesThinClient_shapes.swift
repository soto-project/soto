//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension WorkSpacesThinClient {
    // MARK: Enums

    public enum ApplyTimeOf: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case device = "DEVICE"
        case utc = "UTC"
        public var description: String { return self.rawValue }
    }

    public enum DayOfWeek: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum DesktopType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case appstream = "appstream"
        case workspaces = "workspaces"
        case workspacesWeb = "workspaces-web"
        public var description: String { return self.rawValue }
    }

    public enum DeviceSoftwareSetComplianceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case compliant = "COMPLIANT"
        case none = "NONE"
        case notCompliant = "NOT_COMPLIANT"
        public var description: String { return self.rawValue }
    }

    public enum DeviceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case archived = "ARCHIVED"
        case deregistered = "DEREGISTERED"
        case deregistering = "DEREGISTERING"
        case registered = "REGISTERED"
        public var description: String { return self.rawValue }
    }

    public enum EnvironmentSoftwareSetComplianceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case compliant = "COMPLIANT"
        case noRegisteredDevices = "NO_REGISTERED_DEVICES"
        case notCompliant = "NOT_COMPLIANT"
        public var description: String { return self.rawValue }
    }

    public enum MaintenanceWindowType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum SoftwareSetUpdateMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case useDesired = "USE_DESIRED"
        case useLatest = "USE_LATEST"
        public var description: String { return self.rawValue }
    }

    public enum SoftwareSetUpdateSchedule: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case applyImmediately = "APPLY_IMMEDIATELY"
        case useMaintenanceWindow = "USE_MAINTENANCE_WINDOW"
        public var description: String { return self.rawValue }
    }

    public enum SoftwareSetUpdateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case inProgress = "IN_PROGRESS"
        case upToDate = "UP_TO_DATE"
        public var description: String { return self.rawValue }
    }

    public enum SoftwareSetValidationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notValidated = "NOT_VALIDATED"
        case validated = "VALIDATED"
        public var description: String { return self.rawValue }
    }

    public enum TargetDeviceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case archived = "ARCHIVED"
        case deregistered = "DEREGISTERED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateEnvironmentRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// The ID of the software set to apply.
        public let desiredSoftwareSetId: String?
        /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
        public let desktopArn: String
        /// The URL for the identity provider login (only for environments that use AppStream 2.0).
        public let desktopEndpoint: String?
        /// The Amazon Resource Name (ARN) of the Key Management Service key to use to encrypt the environment.
        public let kmsKeyArn: String?
        /// A specification for a time window to apply software updates.
        public let maintenanceWindow: MaintenanceWindow?
        /// The name for the environment.
        public let name: String?
        /// An option to define which software updates to apply.
        public let softwareSetUpdateMode: SoftwareSetUpdateMode?
        /// An option to define if software updates should be applied within a maintenance window.
        public let softwareSetUpdateSchedule: SoftwareSetUpdateSchedule?
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateEnvironmentRequest.idempotencyToken(), desiredSoftwareSetId: String? = nil, desktopArn: String, desktopEndpoint: String? = nil, kmsKeyArn: String? = nil, maintenanceWindow: MaintenanceWindow? = nil, name: String? = nil, softwareSetUpdateMode: SoftwareSetUpdateMode? = nil, softwareSetUpdateSchedule: SoftwareSetUpdateSchedule? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.desktopArn = desktopArn
            self.desktopEndpoint = desktopEndpoint
            self.kmsKeyArn = kmsKeyArn
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.softwareSetUpdateMode = softwareSetUpdateMode
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.desiredSoftwareSetId, name: "desiredSoftwareSetId", parent: name, pattern: "^[0-9]{1,9}$")
            try self.validate(self.desktopArn, name: "desktopArn", parent: name, max: 2048)
            try self.validate(self.desktopArn, name: "desktopArn", parent: name, min: 20)
            try self.validate(self.desktopArn, name: "desktopArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[0-9]{0,12}:[a-zA-Z0-9\\-\\/\\._]+$")
            try self.validate(self.desktopEndpoint, name: "desktopEndpoint", parent: name, max: 1024)
            try self.validate(self.desktopEndpoint, name: "desktopEndpoint", parent: name, min: 1)
            try self.validate(self.desktopEndpoint, name: "desktopEndpoint", parent: name, pattern: "^(https:\\/\\/)[a-z0-9]+([\\-\\.]{1}[a-z0-9]+)*\\.[a-z]{2,32}(:[0-9]{1,5})?(\\/.*)?$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:kms:[a-zA-Z0-9\\-]*:[0-9]{0,12}:key\\/[a-zA-Z0-9-]+$")
            try self.maintenanceWindow?.validate(name: "\(name).maintenanceWindow")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9\\p{IsAlphabetic}+:,.@'\" -][0-9\\p{IsAlphabetic}+=:,.@'\" -]{0,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case desiredSoftwareSetId = "desiredSoftwareSetId"
            case desktopArn = "desktopArn"
            case desktopEndpoint = "desktopEndpoint"
            case kmsKeyArn = "kmsKeyArn"
            case maintenanceWindow = "maintenanceWindow"
            case name = "name"
            case softwareSetUpdateMode = "softwareSetUpdateMode"
            case softwareSetUpdateSchedule = "softwareSetUpdateSchedule"
            case tags = "tags"
        }
    }

    public struct CreateEnvironmentResponse: AWSDecodableShape {
        /// Describes an environment.
        public let environment: EnvironmentSummary?

        public init(environment: EnvironmentSummary? = nil) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct DeleteDeviceRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// The ID of the device to delete.
        public let id: String

        public init(clientToken: String? = DeleteDeviceRequest.idempotencyToken(), id: String) {
            self.clientToken = clientToken
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9]{24}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDeviceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEnvironmentRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// The ID of the environment to delete.
        public let id: String

        public init(clientToken: String? = DeleteEnvironmentRequest.idempotencyToken(), id: String) {
            self.clientToken = clientToken
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-z0-9]{9}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEnvironmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeregisterDeviceRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// The ID of the device to deregister.
        public let id: String
        /// The desired new status for the device.
        public let targetDeviceStatus: TargetDeviceStatus?

        public init(clientToken: String? = DeregisterDeviceRequest.idempotencyToken(), id: String, targetDeviceStatus: TargetDeviceStatus? = nil) {
            self.clientToken = clientToken
            self.id = id
            self.targetDeviceStatus = targetDeviceStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.id, key: "id")
            try container.encodeIfPresent(self.targetDeviceStatus, forKey: .targetDeviceStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9]{24}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case targetDeviceStatus = "targetDeviceStatus"
        }
    }

    public struct DeregisterDeviceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Device: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the device.
        public let arn: String?
        /// The timestamp of when the device was created.
        public let createdAt: Date?
        /// The ID of the software set currently installed on the device.
        public let currentSoftwareSetId: String?
        /// The version of the software set currently installed on the device.
        public let currentSoftwareSetVersion: String?
        /// The ID of the software set which the device has been set to.
        public let desiredSoftwareSetId: String?
        /// The ID of the environment the device is associated with.
        public let environmentId: String?
        /// The ID of the device.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the Key Management Service key used to encrypt the device.
        public let kmsKeyArn: String?
        /// The timestamp of the most recent session on the device.
        public let lastConnectedAt: Date?
        /// The timestamp of the most recent check-in of the device.
        public let lastPostureAt: Date?
        /// The model number of the device.
        public let model: String?
        /// The name of the device.
        public let name: String?
        /// The ID of the software set that is pending to be installed on the device.
        public let pendingSoftwareSetId: String?
        /// The version of the software set that is pending to be installed on the device.
        public let pendingSoftwareSetVersion: String?
        /// The hardware serial number of the device.
        public let serialNumber: String?
        /// Describes if the software currently installed on the device is a supported version.
        public let softwareSetComplianceStatus: DeviceSoftwareSetComplianceStatus?
        /// An option to define if software updates should be applied within a maintenance window.
        public let softwareSetUpdateSchedule: SoftwareSetUpdateSchedule?
        /// Describes if the device has a supported version of software installed.
        public let softwareSetUpdateStatus: SoftwareSetUpdateStatus?
        /// The status of the device.
        public let status: DeviceStatus?
        /// The tag keys and optional values for the resource.
        public let tags: EmbeddedTag?
        /// The timestamp of when the device was updated.
        public let updatedAt: Date?

        public init(arn: String? = nil, createdAt: Date? = nil, currentSoftwareSetId: String? = nil, currentSoftwareSetVersion: String? = nil, desiredSoftwareSetId: String? = nil, environmentId: String? = nil, id: String? = nil, kmsKeyArn: String? = nil, lastConnectedAt: Date? = nil, lastPostureAt: Date? = nil, model: String? = nil, name: String? = nil, pendingSoftwareSetId: String? = nil, pendingSoftwareSetVersion: String? = nil, serialNumber: String? = nil, softwareSetComplianceStatus: DeviceSoftwareSetComplianceStatus? = nil, softwareSetUpdateSchedule: SoftwareSetUpdateSchedule? = nil, softwareSetUpdateStatus: SoftwareSetUpdateStatus? = nil, status: DeviceStatus? = nil, tags: EmbeddedTag? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.currentSoftwareSetId = currentSoftwareSetId
            self.currentSoftwareSetVersion = currentSoftwareSetVersion
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.environmentId = environmentId
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastConnectedAt = lastConnectedAt
            self.lastPostureAt = lastPostureAt
            self.model = model
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.pendingSoftwareSetVersion = pendingSoftwareSetVersion
            self.serialNumber = serialNumber
            self.softwareSetComplianceStatus = softwareSetComplianceStatus
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.softwareSetUpdateStatus = softwareSetUpdateStatus
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case currentSoftwareSetId = "currentSoftwareSetId"
            case currentSoftwareSetVersion = "currentSoftwareSetVersion"
            case desiredSoftwareSetId = "desiredSoftwareSetId"
            case environmentId = "environmentId"
            case id = "id"
            case kmsKeyArn = "kmsKeyArn"
            case lastConnectedAt = "lastConnectedAt"
            case lastPostureAt = "lastPostureAt"
            case model = "model"
            case name = "name"
            case pendingSoftwareSetId = "pendingSoftwareSetId"
            case pendingSoftwareSetVersion = "pendingSoftwareSetVersion"
            case serialNumber = "serialNumber"
            case softwareSetComplianceStatus = "softwareSetComplianceStatus"
            case softwareSetUpdateSchedule = "softwareSetUpdateSchedule"
            case softwareSetUpdateStatus = "softwareSetUpdateStatus"
            case status = "status"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeviceSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the device.
        public let arn: String?
        /// The timestamp of when the device was created.
        public let createdAt: Date?
        /// The ID of the software set currently installed on the device.
        public let currentSoftwareSetId: String?
        /// The ID of the software set which the device has been set to.
        public let desiredSoftwareSetId: String?
        /// The ID of the environment the device is associated with.
        public let environmentId: String?
        /// The ID of the device.
        public let id: String?
        /// The timestamp of the most recent session on the device.
        public let lastConnectedAt: Date?
        /// The timestamp of the most recent check-in of the device.
        public let lastPostureAt: Date?
        /// The model number of the device.
        public let model: String?
        /// The name of the device.
        public let name: String?
        /// The ID of the software set that is pending to be installed on the device.
        public let pendingSoftwareSetId: String?
        /// The hardware serial number of the device.
        public let serialNumber: String?
        /// An option to define if software updates should be applied within a maintenance window.
        public let softwareSetUpdateSchedule: SoftwareSetUpdateSchedule?
        /// The status of the device.
        public let status: DeviceStatus?
        /// The tag keys and optional values for the resource.
        public let tags: EmbeddedTag?
        /// The timestamp of when the device was updated.
        public let updatedAt: Date?

        public init(arn: String? = nil, createdAt: Date? = nil, currentSoftwareSetId: String? = nil, desiredSoftwareSetId: String? = nil, environmentId: String? = nil, id: String? = nil, lastConnectedAt: Date? = nil, lastPostureAt: Date? = nil, model: String? = nil, name: String? = nil, pendingSoftwareSetId: String? = nil, serialNumber: String? = nil, softwareSetUpdateSchedule: SoftwareSetUpdateSchedule? = nil, status: DeviceStatus? = nil, tags: EmbeddedTag? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.currentSoftwareSetId = currentSoftwareSetId
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.environmentId = environmentId
            self.id = id
            self.lastConnectedAt = lastConnectedAt
            self.lastPostureAt = lastPostureAt
            self.model = model
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.serialNumber = serialNumber
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case currentSoftwareSetId = "currentSoftwareSetId"
            case desiredSoftwareSetId = "desiredSoftwareSetId"
            case environmentId = "environmentId"
            case id = "id"
            case lastConnectedAt = "lastConnectedAt"
            case lastPostureAt = "lastPostureAt"
            case model = "model"
            case name = "name"
            case pendingSoftwareSetId = "pendingSoftwareSetId"
            case serialNumber = "serialNumber"
            case softwareSetUpdateSchedule = "softwareSetUpdateSchedule"
            case status = "status"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct EmbeddedTag: AWSDecodableShape {
        /// The internal ID of a resource to tag.
        public let internalId: String?
        /// The Amazon Resource Name (ARN) of a resource to tag.
        public let resourceArn: String?

        public init(internalId: String? = nil, resourceArn: String? = nil) {
            self.internalId = internalId
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case internalId = "internalId"
            case resourceArn = "resourceArn"
        }
    }

    public struct Environment: AWSDecodableShape {
        /// The activation code to register a device to the environment.
        public let activationCode: String?
        /// The Amazon Resource Name (ARN) of the environment.
        public let arn: String?
        /// The timestamp of when the environment was created.
        public let createdAt: Date?
        /// The ID of the software set to apply.
        public let desiredSoftwareSetId: String?
        /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
        public let desktopArn: String?
        /// The URL for the identity provider login (only for environments that use AppStream 2.0).
        public let desktopEndpoint: String?
        /// The type of streaming desktop for the environment.
        public let desktopType: DesktopType?
        /// The ID of the environment.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the Key Management Service key used to encrypt the environment.
        public let kmsKeyArn: String?
        /// A specification for a time window to apply software updates.
        public let maintenanceWindow: MaintenanceWindow?
        /// The name of the environment.
        public let name: String?
        /// The ID of the software set that is pending to be installed.
        public let pendingSoftwareSetId: String?
        /// The version of the software set that is pending to be installed.
        public let pendingSoftwareSetVersion: String?
        /// The number of devices registered to the environment.
        public let registeredDevicesCount: Int?
        /// Describes if the software currently installed on all devices in the environment is a supported version.
        public let softwareSetComplianceStatus: EnvironmentSoftwareSetComplianceStatus?
        /// An option to define which software updates to apply.
        public let softwareSetUpdateMode: SoftwareSetUpdateMode?
        /// An option to define if software updates should be applied within a maintenance window.
        public let softwareSetUpdateSchedule: SoftwareSetUpdateSchedule?
        /// The tag keys and optional values for the resource.
        public let tags: EmbeddedTag?
        /// The timestamp of when the device was updated.
        public let updatedAt: Date?

        public init(activationCode: String? = nil, arn: String? = nil, createdAt: Date? = nil, desiredSoftwareSetId: String? = nil, desktopArn: String? = nil, desktopEndpoint: String? = nil, desktopType: DesktopType? = nil, id: String? = nil, kmsKeyArn: String? = nil, maintenanceWindow: MaintenanceWindow? = nil, name: String? = nil, pendingSoftwareSetId: String? = nil, pendingSoftwareSetVersion: String? = nil, registeredDevicesCount: Int? = nil, softwareSetComplianceStatus: EnvironmentSoftwareSetComplianceStatus? = nil, softwareSetUpdateMode: SoftwareSetUpdateMode? = nil, softwareSetUpdateSchedule: SoftwareSetUpdateSchedule? = nil, tags: EmbeddedTag? = nil, updatedAt: Date? = nil) {
            self.activationCode = activationCode
            self.arn = arn
            self.createdAt = createdAt
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.desktopArn = desktopArn
            self.desktopEndpoint = desktopEndpoint
            self.desktopType = desktopType
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.pendingSoftwareSetVersion = pendingSoftwareSetVersion
            self.registeredDevicesCount = registeredDevicesCount
            self.softwareSetComplianceStatus = softwareSetComplianceStatus
            self.softwareSetUpdateMode = softwareSetUpdateMode
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case activationCode = "activationCode"
            case arn = "arn"
            case createdAt = "createdAt"
            case desiredSoftwareSetId = "desiredSoftwareSetId"
            case desktopArn = "desktopArn"
            case desktopEndpoint = "desktopEndpoint"
            case desktopType = "desktopType"
            case id = "id"
            case kmsKeyArn = "kmsKeyArn"
            case maintenanceWindow = "maintenanceWindow"
            case name = "name"
            case pendingSoftwareSetId = "pendingSoftwareSetId"
            case pendingSoftwareSetVersion = "pendingSoftwareSetVersion"
            case registeredDevicesCount = "registeredDevicesCount"
            case softwareSetComplianceStatus = "softwareSetComplianceStatus"
            case softwareSetUpdateMode = "softwareSetUpdateMode"
            case softwareSetUpdateSchedule = "softwareSetUpdateSchedule"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct EnvironmentSummary: AWSDecodableShape {
        /// The activation code to register a device to the environment.
        public let activationCode: String?
        /// The Amazon Resource Name (ARN) of the environment.
        public let arn: String?
        /// The timestamp of when the environment was created.
        public let createdAt: Date?
        /// The ID of the software set to apply.
        public let desiredSoftwareSetId: String?
        /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
        public let desktopArn: String?
        /// The URL for the identity provider login (only for environments that use AppStream 2.0).
        public let desktopEndpoint: String?
        /// The type of streaming desktop for the environment.
        public let desktopType: DesktopType?
        /// The ID of the environment.
        public let id: String?
        /// A specification for a time window to apply software updates.
        public let maintenanceWindow: MaintenanceWindow?
        /// The name of the environment.
        public let name: String?
        /// The ID of the software set that is pending to be installed.
        public let pendingSoftwareSetId: String?
        /// An option to define which software updates to apply.
        public let softwareSetUpdateMode: SoftwareSetUpdateMode?
        /// An option to define if software updates should be applied within a maintenance window.
        public let softwareSetUpdateSchedule: SoftwareSetUpdateSchedule?
        /// The tag keys and optional values for the resource.
        public let tags: EmbeddedTag?
        /// The timestamp of when the device was updated.
        public let updatedAt: Date?

        public init(activationCode: String? = nil, arn: String? = nil, createdAt: Date? = nil, desiredSoftwareSetId: String? = nil, desktopArn: String? = nil, desktopEndpoint: String? = nil, desktopType: DesktopType? = nil, id: String? = nil, maintenanceWindow: MaintenanceWindow? = nil, name: String? = nil, pendingSoftwareSetId: String? = nil, softwareSetUpdateMode: SoftwareSetUpdateMode? = nil, softwareSetUpdateSchedule: SoftwareSetUpdateSchedule? = nil, tags: EmbeddedTag? = nil, updatedAt: Date? = nil) {
            self.activationCode = activationCode
            self.arn = arn
            self.createdAt = createdAt
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.desktopArn = desktopArn
            self.desktopEndpoint = desktopEndpoint
            self.desktopType = desktopType
            self.id = id
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.softwareSetUpdateMode = softwareSetUpdateMode
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case activationCode = "activationCode"
            case arn = "arn"
            case createdAt = "createdAt"
            case desiredSoftwareSetId = "desiredSoftwareSetId"
            case desktopArn = "desktopArn"
            case desktopEndpoint = "desktopEndpoint"
            case desktopType = "desktopType"
            case id = "id"
            case maintenanceWindow = "maintenanceWindow"
            case name = "name"
            case pendingSoftwareSetId = "pendingSoftwareSetId"
            case softwareSetUpdateMode = "softwareSetUpdateMode"
            case softwareSetUpdateSchedule = "softwareSetUpdateSchedule"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetDeviceRequest: AWSEncodableShape {
        /// The ID of the device for which to return information.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9]{24}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeviceResponse: AWSDecodableShape {
        /// Describes an device.
        public let device: Device?

        public init(device: Device? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device = "device"
        }
    }

    public struct GetEnvironmentRequest: AWSEncodableShape {
        /// The ID of the environment for which to return information.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-z0-9]{9}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentResponse: AWSDecodableShape {
        /// Describes an environment.
        public let environment: Environment?

        public init(environment: Environment? = nil) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct GetSoftwareSetRequest: AWSEncodableShape {
        /// The ID of the software set for which to return information.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]{1,9}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSoftwareSetResponse: AWSDecodableShape {
        /// Describes a software set.
        public let softwareSet: SoftwareSet?

        public init(softwareSet: SoftwareSet? = nil) {
            self.softwareSet = softwareSet
        }

        private enum CodingKeys: String, CodingKey {
            case softwareSet = "softwareSet"
        }
    }

    public struct ListDevicesRequest: AWSEncodableShape {
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDevicesResponse: AWSDecodableShape {
        /// Describes devices.
        public let devices: [DeviceSummary]?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(devices: [DeviceSummary]? = nil, nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "devices"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentsRequest: AWSEncodableShape {
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentsResponse: AWSDecodableShape {
        /// Describes environments.
        public let environments: [EnvironmentSummary]?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(environments: [EnvironmentSummary]? = nil, nextToken: String? = nil) {
            self.environments = environments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case environments = "environments"
            case nextToken = "nextToken"
        }
    }

    public struct ListSoftwareSetsRequest: AWSEncodableShape {
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSoftwareSetsResponse: AWSDecodableShape {
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?
        /// Describes software sets.
        public let softwareSets: [SoftwareSetSummary]?

        public init(nextToken: String? = nil, softwareSets: [SoftwareSetSummary]? = nil) {
            self.nextToken = nextToken
            self.softwareSets = softwareSets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case softwareSets = "softwareSets"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MaintenanceWindow: AWSEncodableShape & AWSDecodableShape {
        /// The option to set the maintenance window during the device local time or Universal Coordinated Time (UTC).
        public let applyTimeOf: ApplyTimeOf?
        /// The days of the week during which the maintenance window is open.
        public let daysOfTheWeek: [DayOfWeek]?
        /// The hour for the maintenance window end (00-23).
        public let endTimeHour: Int?
        /// The minutes for the maintenance window end (00-59).
        public let endTimeMinute: Int?
        /// The hour for the maintenance window start (00-23).
        public let startTimeHour: Int?
        /// The minutes past the hour for the maintenance window start (00-59).
        public let startTimeMinute: Int?
        /// An option to select the default or custom maintenance window.
        public let type: MaintenanceWindowType?

        public init(applyTimeOf: ApplyTimeOf? = nil, daysOfTheWeek: [DayOfWeek]? = nil, endTimeHour: Int? = nil, endTimeMinute: Int? = nil, startTimeHour: Int? = nil, startTimeMinute: Int? = nil, type: MaintenanceWindowType? = nil) {
            self.applyTimeOf = applyTimeOf
            self.daysOfTheWeek = daysOfTheWeek
            self.endTimeHour = endTimeHour
            self.endTimeMinute = endTimeMinute
            self.startTimeHour = startTimeHour
            self.startTimeMinute = startTimeMinute
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.daysOfTheWeek, name: "daysOfTheWeek", parent: name, max: 7)
            try self.validate(self.daysOfTheWeek, name: "daysOfTheWeek", parent: name, min: 1)
            try self.validate(self.endTimeHour, name: "endTimeHour", parent: name, max: 23)
            try self.validate(self.endTimeHour, name: "endTimeHour", parent: name, min: 0)
            try self.validate(self.endTimeMinute, name: "endTimeMinute", parent: name, max: 59)
            try self.validate(self.endTimeMinute, name: "endTimeMinute", parent: name, min: 0)
            try self.validate(self.startTimeHour, name: "startTimeHour", parent: name, max: 23)
            try self.validate(self.startTimeHour, name: "startTimeHour", parent: name, min: 0)
            try self.validate(self.startTimeMinute, name: "startTimeMinute", parent: name, max: 59)
            try self.validate(self.startTimeMinute, name: "startTimeMinute", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case applyTimeOf = "applyTimeOf"
            case daysOfTheWeek = "daysOfTheWeek"
            case endTimeHour = "endTimeHour"
            case endTimeMinute = "endTimeMinute"
            case startTimeHour = "startTimeHour"
            case startTimeMinute = "startTimeMinute"
            case type = "type"
        }
    }

    public struct Software: AWSDecodableShape {
        /// The name of the software component.
        public let name: String?
        /// The version of the software component.
        public let version: String?

        public init(name: String? = nil, version: String? = nil) {
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case version = "version"
        }
    }

    public struct SoftwareSet: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the software set.
        public let arn: String?
        /// The ID of the software set.
        public let id: String?
        /// The timestamp of when the software set was released.
        public let releasedAt: Date?
        /// A list of the software components in the software set.
        public let software: [Software]?
        /// The timestamp of the end of support for the software set.
        public let supportedUntil: Date?
        /// An option to define if the software set has been validated.
        public let validationStatus: SoftwareSetValidationStatus?
        /// The version of the software set.
        public let version: String?

        public init(arn: String? = nil, id: String? = nil, releasedAt: Date? = nil, software: [Software]? = nil, supportedUntil: Date? = nil, validationStatus: SoftwareSetValidationStatus? = nil, version: String? = nil) {
            self.arn = arn
            self.id = id
            self.releasedAt = releasedAt
            self.software = software
            self.supportedUntil = supportedUntil
            self.validationStatus = validationStatus
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case releasedAt = "releasedAt"
            case software = "software"
            case supportedUntil = "supportedUntil"
            case validationStatus = "validationStatus"
            case version = "version"
        }
    }

    public struct SoftwareSetSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the software set.
        public let arn: String?
        /// The ID of the software set.
        public let id: String?
        /// The timestamp of when the software set was released.
        public let releasedAt: Date?
        /// The timestamp of the end of support for the software set.
        public let supportedUntil: Date?
        /// An option to define if the software set has been validated.
        public let validationStatus: SoftwareSetValidationStatus?
        /// The version of the software set.
        public let version: String?

        public init(arn: String? = nil, id: String? = nil, releasedAt: Date? = nil, supportedUntil: Date? = nil, validationStatus: SoftwareSetValidationStatus? = nil, version: String? = nil) {
            self.arn = arn
            self.id = id
            self.releasedAt = releasedAt
            self.supportedUntil = supportedUntil
            self.validationStatus = validationStatus
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case releasedAt = "releasedAt"
            case supportedUntil = "supportedUntil"
            case validationStatus = "validationStatus"
            case version = "version"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        /// The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDeviceRequest: AWSEncodableShape {
        /// The ID of the software set to apply.
        public let desiredSoftwareSetId: String?
        /// The ID of the device to update.
        public let id: String
        /// The name of the device to update.
        public let name: String?
        /// An option to define if software updates should be applied within a maintenance window.
        public let softwareSetUpdateSchedule: SoftwareSetUpdateSchedule?

        public init(desiredSoftwareSetId: String? = nil, id: String, name: String? = nil, softwareSetUpdateSchedule: SoftwareSetUpdateSchedule? = nil) {
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.id = id
            self.name = name
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.desiredSoftwareSetId, forKey: .desiredSoftwareSetId)
            request.encodePath(self.id, key: "id")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.softwareSetUpdateSchedule, forKey: .softwareSetUpdateSchedule)
        }

        public func validate(name: String) throws {
            try self.validate(self.desiredSoftwareSetId, name: "desiredSoftwareSetId", parent: name, pattern: "^[0-9]{1,9}$")
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9]{24}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9\\p{IsAlphabetic}+:,.@'\" -]{1,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case desiredSoftwareSetId = "desiredSoftwareSetId"
            case name = "name"
            case softwareSetUpdateSchedule = "softwareSetUpdateSchedule"
        }
    }

    public struct UpdateDeviceResponse: AWSDecodableShape {
        /// Describes a device.
        public let device: DeviceSummary?

        public init(device: DeviceSummary? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device = "device"
        }
    }

    public struct UpdateEnvironmentRequest: AWSEncodableShape {
        /// The ID of the software set to apply.
        public let desiredSoftwareSetId: String?
        /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
        public let desktopArn: String?
        /// The URL for the identity provider login (only for environments that use AppStream 2.0).
        public let desktopEndpoint: String?
        /// The ID of the environment to update.
        public let id: String
        /// A specification for a time window to apply software updates.
        public let maintenanceWindow: MaintenanceWindow?
        /// The name of the environment to update.
        public let name: String?
        /// An option to define which software updates to apply.
        public let softwareSetUpdateMode: SoftwareSetUpdateMode?
        /// An option to define if software updates should be applied within a maintenance window.
        public let softwareSetUpdateSchedule: SoftwareSetUpdateSchedule?

        public init(desiredSoftwareSetId: String? = nil, desktopArn: String? = nil, desktopEndpoint: String? = nil, id: String, maintenanceWindow: MaintenanceWindow? = nil, name: String? = nil, softwareSetUpdateMode: SoftwareSetUpdateMode? = nil, softwareSetUpdateSchedule: SoftwareSetUpdateSchedule? = nil) {
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.desktopArn = desktopArn
            self.desktopEndpoint = desktopEndpoint
            self.id = id
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.softwareSetUpdateMode = softwareSetUpdateMode
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.desiredSoftwareSetId, forKey: .desiredSoftwareSetId)
            try container.encodeIfPresent(self.desktopArn, forKey: .desktopArn)
            try container.encodeIfPresent(self.desktopEndpoint, forKey: .desktopEndpoint)
            request.encodePath(self.id, key: "id")
            try container.encodeIfPresent(self.maintenanceWindow, forKey: .maintenanceWindow)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.softwareSetUpdateMode, forKey: .softwareSetUpdateMode)
            try container.encodeIfPresent(self.softwareSetUpdateSchedule, forKey: .softwareSetUpdateSchedule)
        }

        public func validate(name: String) throws {
            try self.validate(self.desiredSoftwareSetId, name: "desiredSoftwareSetId", parent: name, pattern: "^[0-9]{0,9}$")
            try self.validate(self.desktopArn, name: "desktopArn", parent: name, max: 2048)
            try self.validate(self.desktopArn, name: "desktopArn", parent: name, min: 20)
            try self.validate(self.desktopArn, name: "desktopArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[0-9]{0,12}:[a-zA-Z0-9\\-\\/\\._]+$")
            try self.validate(self.desktopEndpoint, name: "desktopEndpoint", parent: name, max: 1024)
            try self.validate(self.desktopEndpoint, name: "desktopEndpoint", parent: name, min: 1)
            try self.validate(self.desktopEndpoint, name: "desktopEndpoint", parent: name, pattern: "^(https:\\/\\/)[a-z0-9]+([\\-\\.]{1}[a-z0-9]+)*\\.[a-z]{2,32}(:[0-9]{1,5})?(\\/.*)?$")
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-z0-9]{9}$")
            try self.maintenanceWindow?.validate(name: "\(name).maintenanceWindow")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9\\p{IsAlphabetic}+:,.@'\" -][0-9\\p{IsAlphabetic}+=:,.@'\" -]{0,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case desiredSoftwareSetId = "desiredSoftwareSetId"
            case desktopArn = "desktopArn"
            case desktopEndpoint = "desktopEndpoint"
            case maintenanceWindow = "maintenanceWindow"
            case name = "name"
            case softwareSetUpdateMode = "softwareSetUpdateMode"
            case softwareSetUpdateSchedule = "softwareSetUpdateSchedule"
        }
    }

    public struct UpdateEnvironmentResponse: AWSDecodableShape {
        /// Describes an environment.
        public let environment: EnvironmentSummary?

        public init(environment: EnvironmentSummary? = nil) {
            self.environment = environment
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
        }
    }

    public struct UpdateSoftwareSetRequest: AWSEncodableShape {
        /// The ID of the software set to update.
        public let id: String
        /// An option to define if the software set has been validated.
        public let validationStatus: SoftwareSetValidationStatus

        public init(id: String, validationStatus: SoftwareSetValidationStatus) {
            self.id = id
            self.validationStatus = validationStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
            try container.encode(self.validationStatus, forKey: .validationStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9]{1,9}$")
        }

        private enum CodingKeys: String, CodingKey {
            case validationStatus = "validationStatus"
        }
    }

    public struct UpdateSoftwareSetResponse: AWSDecodableShape {
        public init() {}
    }
}

// MARK: - Errors

/// Error enum for WorkSpacesThinClient
public struct WorkSpacesThinClientErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case internalServiceException = "InternalServiceException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize WorkSpacesThinClient
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
    public static var conflictException: Self { .init(.conflictException) }
    /// The server encountered an internal error and is unable to complete the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request processing failed due to some unknown error, exception, or failure.
    public static var internalServiceException: Self { .init(.internalServiceException) }
    /// The resource specified in the request was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Your request exceeds a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the specified constraints.
    public static var validationException: Self { .init(.validationException) }
}

extension WorkSpacesThinClientErrorType: Equatable {
    public static func == (lhs: WorkSpacesThinClientErrorType, rhs: WorkSpacesThinClientErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension WorkSpacesThinClientErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
