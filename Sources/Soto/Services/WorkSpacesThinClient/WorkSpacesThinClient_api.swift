//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS WorkSpacesThinClient service.
///
/// Amazon WorkSpaces Thin Client is an affordable device built to work with Amazon Web Services End User Computing (EUC) virtual desktops to provide users with a complete cloud desktop solution. WorkSpaces Thin Client is a compact device designed to connect up to two monitors and USB devices like a keyboard, mouse, headset, and webcam. To maximize endpoint security, WorkSpaces Thin Client devices do not allow local data storage or installation of unapproved applications. The WorkSpaces Thin Client device ships preloaded with device management software. You can use these APIs to complete WorkSpaces Thin Client tasks, such as creating environments or viewing devices. For more information about WorkSpaces Thin Client, including the required permissions to use the service, see the Amazon WorkSpaces Thin Client Administrator Guide. For more information about using the Command Line Interface (CLI) to manage your WorkSpaces Thin Client resources, see the WorkSpaces Thin Client section of the CLI Reference.
public struct WorkSpacesThinClient: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the WorkSpacesThinClient client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "WorkSpacesThinClient",
            serviceIdentifier: "thinclient",
            serviceProtocol: .restjson,
            apiVersion: "2023-08-22",
            endpoint: endpoint,
            errorType: WorkSpacesThinClientErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Creates an environment for your thin client devices.
    @Sendable
    @inlinable
    public func createEnvironment(_ input: CreateEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateEnvironmentResponse {
        try await self.client.execute(
            operation: "CreateEnvironment", 
            path: "/environments", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Creates an environment for your thin client devices.
    ///
    /// Parameters:
    ///   - clientToken: Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    ///   - desiredSoftwareSetId: The ID of the software set to apply.
    ///   - desktopArn: The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Secure Browser, or AppStream 2.0.
    ///   - desktopEndpoint: The URL for the identity provider login (only for environments that use AppStream 2.0).
    ///   - deviceCreationTags: A map of the key-value pairs of the tag or tags to assign to the newly created devices for this environment.
    ///   - kmsKeyArn: The Amazon Resource Name (ARN) of the Key Management Service key to use to encrypt the environment.
    ///   - maintenanceWindow: A specification for a time window to apply software updates.
    ///   - name: The name for the environment.
    ///   - softwareSetUpdateMode: An option to define which software updates to apply.
    ///   - softwareSetUpdateSchedule: An option to define if software updates should be applied within a maintenance window.
    ///   - tags: A map of the key-value pairs of the tag or tags to assign to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createEnvironment(
        clientToken: String? = CreateEnvironmentRequest.idempotencyToken(),
        desiredSoftwareSetId: String? = nil,
        desktopArn: String,
        desktopEndpoint: String? = nil,
        deviceCreationTags: [String: String]? = nil,
        kmsKeyArn: String? = nil,
        maintenanceWindow: MaintenanceWindow? = nil,
        name: String? = nil,
        softwareSetUpdateMode: SoftwareSetUpdateMode? = nil,
        softwareSetUpdateSchedule: SoftwareSetUpdateSchedule? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateEnvironmentResponse {
        let input = CreateEnvironmentRequest(
            clientToken: clientToken, 
            desiredSoftwareSetId: desiredSoftwareSetId, 
            desktopArn: desktopArn, 
            desktopEndpoint: desktopEndpoint, 
            deviceCreationTags: deviceCreationTags, 
            kmsKeyArn: kmsKeyArn, 
            maintenanceWindow: maintenanceWindow, 
            name: name, 
            softwareSetUpdateMode: softwareSetUpdateMode, 
            softwareSetUpdateSchedule: softwareSetUpdateSchedule, 
            tags: tags
        )
        return try await self.createEnvironment(input, logger: logger)
    }

    /// Deletes a thin client device.
    @Sendable
    @inlinable
    public func deleteDevice(_ input: DeleteDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDeviceResponse {
        try await self.client.execute(
            operation: "DeleteDevice", 
            path: "/devices/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Deletes a thin client device.
    ///
    /// Parameters:
    ///   - clientToken: Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    ///   - id: The ID of the device to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDevice(
        clientToken: String? = DeleteDeviceRequest.idempotencyToken(),
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDeviceResponse {
        let input = DeleteDeviceRequest(
            clientToken: clientToken, 
            id: id
        )
        return try await self.deleteDevice(input, logger: logger)
    }

    /// Deletes an environment.
    @Sendable
    @inlinable
    public func deleteEnvironment(_ input: DeleteEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteEnvironmentResponse {
        try await self.client.execute(
            operation: "DeleteEnvironment", 
            path: "/environments/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Deletes an environment.
    ///
    /// Parameters:
    ///   - clientToken: Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    ///   - id: The ID of the environment to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteEnvironment(
        clientToken: String? = DeleteEnvironmentRequest.idempotencyToken(),
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteEnvironmentResponse {
        let input = DeleteEnvironmentRequest(
            clientToken: clientToken, 
            id: id
        )
        return try await self.deleteEnvironment(input, logger: logger)
    }

    /// Deregisters a thin client device.
    @Sendable
    @inlinable
    public func deregisterDevice(_ input: DeregisterDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeregisterDeviceResponse {
        try await self.client.execute(
            operation: "DeregisterDevice", 
            path: "/deregister-device/{id}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Deregisters a thin client device.
    ///
    /// Parameters:
    ///   - clientToken: Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    ///   - id: The ID of the device to deregister.
    ///   - targetDeviceStatus: The desired new status for the device.
    ///   - logger: Logger use during operation
    @inlinable
    public func deregisterDevice(
        clientToken: String? = DeregisterDeviceRequest.idempotencyToken(),
        id: String,
        targetDeviceStatus: TargetDeviceStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeregisterDeviceResponse {
        let input = DeregisterDeviceRequest(
            clientToken: clientToken, 
            id: id, 
            targetDeviceStatus: targetDeviceStatus
        )
        return try await self.deregisterDevice(input, logger: logger)
    }

    /// Returns information for a thin client device.
    @Sendable
    @inlinable
    public func getDevice(_ input: GetDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDeviceResponse {
        try await self.client.execute(
            operation: "GetDevice", 
            path: "/devices/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Returns information for a thin client device.
    ///
    /// Parameters:
    ///   - id: The ID of the device for which to return information.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDevice(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDeviceResponse {
        let input = GetDeviceRequest(
            id: id
        )
        return try await self.getDevice(input, logger: logger)
    }

    /// Returns information for an environment.
    @Sendable
    @inlinable
    public func getEnvironment(_ input: GetEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEnvironmentResponse {
        try await self.client.execute(
            operation: "GetEnvironment", 
            path: "/environments/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Returns information for an environment.
    ///
    /// Parameters:
    ///   - id: The ID of the environment for which to return information.
    ///   - logger: Logger use during operation
    @inlinable
    public func getEnvironment(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEnvironmentResponse {
        let input = GetEnvironmentRequest(
            id: id
        )
        return try await self.getEnvironment(input, logger: logger)
    }

    /// Returns information for a software set.
    @Sendable
    @inlinable
    public func getSoftwareSet(_ input: GetSoftwareSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSoftwareSetResponse {
        try await self.client.execute(
            operation: "GetSoftwareSet", 
            path: "/softwaresets/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Returns information for a software set.
    ///
    /// Parameters:
    ///   - id: The ID of the software set for which to return information.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSoftwareSet(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSoftwareSetResponse {
        let input = GetSoftwareSetRequest(
            id: id
        )
        return try await self.getSoftwareSet(input, logger: logger)
    }

    /// Returns a list of thin client devices.
    @Sendable
    @inlinable
    public func listDevices(_ input: ListDevicesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDevicesResponse {
        try await self.client.execute(
            operation: "ListDevices", 
            path: "/devices", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Returns a list of thin client devices.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - nextToken: If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDevices(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDevicesResponse {
        let input = ListDevicesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDevices(input, logger: logger)
    }

    /// Returns a list of environments.
    @Sendable
    @inlinable
    public func listEnvironments(_ input: ListEnvironmentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEnvironmentsResponse {
        try await self.client.execute(
            operation: "ListEnvironments", 
            path: "/environments", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Returns a list of environments.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - nextToken: If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    ///   - logger: Logger use during operation
    @inlinable
    public func listEnvironments(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEnvironmentsResponse {
        let input = ListEnvironmentsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listEnvironments(input, logger: logger)
    }

    /// Returns a list of software sets.
    @Sendable
    @inlinable
    public func listSoftwareSets(_ input: ListSoftwareSetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSoftwareSetsResponse {
        try await self.client.execute(
            operation: "ListSoftwareSets", 
            path: "/softwaresets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Returns a list of software sets.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - nextToken: If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSoftwareSets(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSoftwareSetsResponse {
        let input = ListSoftwareSetsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listSoftwareSets(input, logger: logger)
    }

    /// Returns a list of tags for a resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Returns a list of tags for a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Assigns one or more tags (key-value pairs) to the specified resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Assigns one or more tags (key-value pairs) to the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource that you want to tag.
    ///   - tags: A map of the key-value pairs of the tag or tags to assign to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes a tag or tags from a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Removes a tag or tags from a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource that you want to untag.
    ///   - tagKeys: The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates a thin client device.
    @Sendable
    @inlinable
    public func updateDevice(_ input: UpdateDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDeviceResponse {
        try await self.client.execute(
            operation: "UpdateDevice", 
            path: "/devices/{id}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Updates a thin client device.
    ///
    /// Parameters:
    ///   - desiredSoftwareSetId: The ID of the software set to apply.
    ///   - id: The ID of the device to update.
    ///   - name: The name of the device to update.
    ///   - softwareSetUpdateSchedule: An option to define if software updates should be applied within a maintenance window.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDevice(
        desiredSoftwareSetId: String? = nil,
        id: String,
        name: String? = nil,
        softwareSetUpdateSchedule: SoftwareSetUpdateSchedule? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDeviceResponse {
        let input = UpdateDeviceRequest(
            desiredSoftwareSetId: desiredSoftwareSetId, 
            id: id, 
            name: name, 
            softwareSetUpdateSchedule: softwareSetUpdateSchedule
        )
        return try await self.updateDevice(input, logger: logger)
    }

    /// Updates an environment.
    @Sendable
    @inlinable
    public func updateEnvironment(_ input: UpdateEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateEnvironmentResponse {
        try await self.client.execute(
            operation: "UpdateEnvironment", 
            path: "/environments/{id}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Updates an environment.
    ///
    /// Parameters:
    ///   - desiredSoftwareSetId: The ID of the software set to apply.
    ///   - desktopArn: The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Secure Browser, or AppStream 2.0.
    ///   - desktopEndpoint: The URL for the identity provider login (only for environments that use AppStream 2.0).
    ///   - deviceCreationTags: A map of the key-value pairs of the tag or tags to assign to the newly created devices for this environment.
    ///   - id: The ID of the environment to update.
    ///   - maintenanceWindow: A specification for a time window to apply software updates.
    ///   - name: The name of the environment to update.
    ///   - softwareSetUpdateMode: An option to define which software updates to apply.
    ///   - softwareSetUpdateSchedule: An option to define if software updates should be applied within a maintenance window.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateEnvironment(
        desiredSoftwareSetId: String? = nil,
        desktopArn: String? = nil,
        desktopEndpoint: String? = nil,
        deviceCreationTags: [String: String]? = nil,
        id: String,
        maintenanceWindow: MaintenanceWindow? = nil,
        name: String? = nil,
        softwareSetUpdateMode: SoftwareSetUpdateMode? = nil,
        softwareSetUpdateSchedule: SoftwareSetUpdateSchedule? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateEnvironmentResponse {
        let input = UpdateEnvironmentRequest(
            desiredSoftwareSetId: desiredSoftwareSetId, 
            desktopArn: desktopArn, 
            desktopEndpoint: desktopEndpoint, 
            deviceCreationTags: deviceCreationTags, 
            id: id, 
            maintenanceWindow: maintenanceWindow, 
            name: name, 
            softwareSetUpdateMode: softwareSetUpdateMode, 
            softwareSetUpdateSchedule: softwareSetUpdateSchedule
        )
        return try await self.updateEnvironment(input, logger: logger)
    }

    /// Updates a software set.
    @Sendable
    @inlinable
    public func updateSoftwareSet(_ input: UpdateSoftwareSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSoftwareSetResponse {
        try await self.client.execute(
            operation: "UpdateSoftwareSet", 
            path: "/softwaresets/{id}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "api.", 
            logger: logger
        )
    }
    /// Updates a software set.
    ///
    /// Parameters:
    ///   - id: The ID of the software set to update.
    ///   - validationStatus: An option to define if the software set has been validated.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSoftwareSet(
        id: String,
        validationStatus: SoftwareSetValidationStatus,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSoftwareSetResponse {
        let input = UpdateSoftwareSetRequest(
            id: id, 
            validationStatus: validationStatus
        )
        return try await self.updateSoftwareSet(input, logger: logger)
    }
}

extension WorkSpacesThinClient {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: WorkSpacesThinClient, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension WorkSpacesThinClient {
    /// Return PaginatorSequence for operation ``listDevices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevicesPaginator(
        _ input: ListDevicesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDevicesRequest, ListDevicesResponse> {
        return .init(
            input: input,
            command: self.listDevices,
            inputKey: \ListDevicesRequest.nextToken,
            outputKey: \ListDevicesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDevices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevicesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDevicesRequest, ListDevicesResponse> {
        let input = ListDevicesRequest(
            maxResults: maxResults
        )
        return self.listDevicesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listEnvironments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listEnvironmentsPaginator(
        _ input: ListEnvironmentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListEnvironmentsRequest, ListEnvironmentsResponse> {
        return .init(
            input: input,
            command: self.listEnvironments,
            inputKey: \ListEnvironmentsRequest.nextToken,
            outputKey: \ListEnvironmentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listEnvironments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - logger: Logger used for logging
    @inlinable
    public func listEnvironmentsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListEnvironmentsRequest, ListEnvironmentsResponse> {
        let input = ListEnvironmentsRequest(
            maxResults: maxResults
        )
        return self.listEnvironmentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSoftwareSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSoftwareSetsPaginator(
        _ input: ListSoftwareSetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSoftwareSetsRequest, ListSoftwareSetsResponse> {
        return .init(
            input: input,
            command: self.listSoftwareSets,
            inputKey: \ListSoftwareSetsRequest.nextToken,
            outputKey: \ListSoftwareSetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSoftwareSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSoftwareSetsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSoftwareSetsRequest, ListSoftwareSetsResponse> {
        let input = ListSoftwareSetsRequest(
            maxResults: maxResults
        )
        return self.listSoftwareSetsPaginator(input, logger: logger)
    }
}

extension WorkSpacesThinClient.ListDevicesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WorkSpacesThinClient.ListDevicesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension WorkSpacesThinClient.ListEnvironmentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WorkSpacesThinClient.ListEnvironmentsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension WorkSpacesThinClient.ListSoftwareSetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> WorkSpacesThinClient.ListSoftwareSetsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
