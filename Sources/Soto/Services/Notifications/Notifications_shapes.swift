//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Notifications {
    // MARK: Enums

    public enum AggregationDuration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Aggregate notifications for long periods of time (12 hours)
        case long = "LONG"
        /// Do not aggregate notifications sourced from a notification configuration
        case none = "NONE"
        /// Aggregate notifications for short periods of time (5 mins)
        case short = "SHORT"
        public var description: String { return self.rawValue }
    }

    public enum AggregationEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aggregate = "AGGREGATE"
        case child = "CHILD"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum EventRuleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// EventRule is processing events. Any call can be executed.
        case active = "ACTIVE"
        /// This EventRule is being created. Only GET/LIST calls can be executed.
        case creating = "CREATING"
        /// This EventRule is being deleted. Only GET/LIST calls can be executed.
        case deleting = "DELETING"
        /// EventRule is in a bad state and may not be processing events. Any call can be executed.
        case inactive = "INACTIVE"
        /// This EventRule is being updated. Only GET/LIST calls can be executed.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum EventStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum LocaleCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// German (Germany)
        case deDE = "de_DE"
        /// English (Canada)
        case enCA = "en_CA"
        /// English (United Kingdom)
        case enUK = "en_UK"
        /// English (United States). This is the default locale.
        case enUS = "en_US"
        /// Spanish (Spain)
        case esES = "es_ES"
        /// French (Canada)
        case frCA = "fr_CA"
        /// French (France)
        case frFR = "fr_FR"
        /// Bahasa Indonesian (Indonesia)
        case idID = "id_ID"
        /// Italian (Italy)
        case itIT = "it_IT"
        /// Japanese (Japan)
        case jaJP = "ja_JP"
        /// Korean (Korea)
        case koKR = "ko_KR"
        /// Portuguese (Brazil)
        case ptBR = "pt_BR"
        /// Turkish (Turkey)
        case trTR = "tr_TR"
        /// Chinese (China)
        case zhCN = "zh_CN"
        /// Chinese (Taiwan)
        case zhTW = "zh_TW"
        public var description: String { return self.rawValue }
    }

    public enum MediaElementType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case image = "IMAGE"
        public var description: String { return self.rawValue }
    }

    public enum NotificationConfigurationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// All of the EventRules are in ACTIVE Status. Any call can be executed.
        case active = "ACTIVE"
        /// This NotificationConfiguration is being deleted. Only GET/LIST calls can be executed.
        case deleting = "DELETING"
        /// All of the EventRules are in INACTIVE Status. Any call can be executed.
        case inactive = "INACTIVE"
        /// Some EventRules are in ACTIVE Status and some are INACTIVE. Any call can be executed.
        case partiallyActive = "PARTIALLY_ACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum NotificationHubStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Incoming Notification Events are being replicated to this Notification Hub. A Notification Hub with this status can be deregistered.
        case active = "ACTIVE"
        /// Notification Hub is being deleted. Cannot register a Notification Hub in the same region as one in this status.
        case deregistering = "DEREGISTERING"
        /// Notification Hub is in a failure state. Incoming Notification Events are not being replicated to this Hub.
        case inactive = "INACTIVE"
        /// Notification Hub is initializing. Cannot deregister a Notification Hub in this status.
        case registering = "REGISTERING"
        public var description: String { return self.rawValue }
    }

    public enum NotificationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alert = "ALERT"
        case announcement = "ANNOUNCEMENT"
        case informational = "INFORMATIONAL"
        case warning = "WARNING"
        public var description: String { return self.rawValue }
    }

    public enum SchemaVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case v10 = "v1.0"
        public var description: String { return self.rawValue }
    }

    public enum TextPartType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case localizedText = "LOCALIZED_TEXT"
        case plainText = "PLAIN_TEXT"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateChannelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Channel to associate with the NotificationConfiguration. Supported ARNs include AWS Chatbot, the Console Mobile Application, and notifications-contacts.
        public let arn: String
        /// The ARN of the NotificationConfiguration to associate with the Channel.
        public let notificationConfigurationArn: String

        @inlinable
        public init(arn: String, notificationConfigurationArn: String) {
            self.arn = arn
            self.notificationConfigurationArn = notificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encode(self.notificationConfigurationArn, forKey: .notificationConfigurationArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:(chatbot|consoleapp|notifications-contacts):[a-zA-Z0-9-]*:[0-9]{12}:[a-zA-Z0-9-_.@]+/[a-zA-Z0-9/_.@:-]+$")
            try self.validate(self.notificationConfigurationArn, name: "notificationConfigurationArn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: String, CodingKey {
            case notificationConfigurationArn = "notificationConfigurationArn"
        }
    }

    public struct AssociateChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateEventRuleRequest: AWSEncodableShape {
        /// An additional event pattern used to further filter the events this EventRule receives. For more information, see Amazon EventBridge event patterns in the Amazon EventBridge User Guide.
        public let eventPattern: String?
        /// The event type to match. Must match one of the valid Amazon EventBridge event types. For example, EC2 Instance State-change Notification and AWS CloudWatch Alarm State Change. For more information, see Event delivery from AWS services in the Amazon EventBridge User Guide.
        public let eventType: String
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration associated with this EventRule.
        public let notificationConfigurationArn: String
        /// A list of AWS Regions that send events to this EventRule.
        public let regions: [String]
        /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from AWS services in the Amazon EventBridge User Guide.
        public let source: String

        @inlinable
        public init(eventPattern: String? = nil, eventType: String, notificationConfigurationArn: String, regions: [String], source: String) {
            self.eventPattern = eventPattern
            self.eventType = eventType
            self.notificationConfigurationArn = notificationConfigurationArn
            self.regions = regions
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.eventPattern, name: "eventPattern", parent: name, max: 4096)
            try self.validate(self.eventType, name: "eventType", parent: name, max: 128)
            try self.validate(self.eventType, name: "eventType", parent: name, min: 1)
            try self.validate(self.eventType, name: "eventType", parent: name, pattern: "^([a-zA-Z0-9 \\-\\(\\)])+$")
            try self.validate(self.notificationConfigurationArn, name: "notificationConfigurationArn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
            try self.regions.forEach {
                try validate($0, name: "regions[]", parent: name, max: 25)
                try validate($0, name: "regions[]", parent: name, min: 2)
                try validate($0, name: "regions[]", parent: name, pattern: "^([a-z]{1,2})-([a-z]{1,15}-)+([0-9])$")
            }
            try self.validate(self.regions, name: "regions", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, max: 36)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "^aws.([a-z0-9\\-])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventPattern = "eventPattern"
            case eventType = "eventType"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case regions = "regions"
            case source = "source"
        }
    }

    public struct CreateEventRuleResponse: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String
        /// The ARN of a NotificationConfiguration.
        public let notificationConfigurationArn: String
        /// A list of an EventRule's status by Region. Regions are mapped to EventRuleStatusSummary.
        public let statusSummaryByRegion: [String: EventRuleStatusSummary]

        @inlinable
        public init(arn: String, notificationConfigurationArn: String, statusSummaryByRegion: [String: EventRuleStatusSummary]) {
            self.arn = arn
            self.notificationConfigurationArn = notificationConfigurationArn
            self.statusSummaryByRegion = statusSummaryByRegion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case statusSummaryByRegion = "statusSummaryByRegion"
        }
    }

    public struct CreateNotificationConfigurationRequest: AWSEncodableShape {
        /// The aggregation preference of the NotificationConfiguration.   Values:    LONG    Aggregate notifications for long periods of time (12 hours).      SHORT    Aggregate notifications for short periods of time (5 minutes).      NONE    Don't aggregate notifications. No delay in delivery.
        public let aggregationDuration: AggregationDuration?
        /// The description of the NotificationConfiguration.
        public let description: String
        /// The name of the NotificationConfiguration. Supports RFC 3986's unreserved characters.
        public let name: String
        /// A map of tags assigned to a resource. A tag is a string-to-string map of key-value pairs.
        public let tags: [String: String]?

        @inlinable
        public init(aggregationDuration: AggregationDuration? = nil, description: String, name: String, tags: [String: String]? = nil) {
            self.aggregationDuration = aggregationDuration
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0001-\\u001F\\u007F-\\u009F]*$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_\\-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationDuration = "aggregationDuration"
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateNotificationConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the the resource.
        public let arn: String
        /// The status of this NotificationConfiguration. The status should always be INACTIVE when part of the CreateNotificationConfiguration response.   Values:    ACTIVE    All EventRules are ACTIVE and any call can be run.      PARTIALLY_ACTIVE    Some EventRules are ACTIVE and some are INACTIVE.   Any call can be run.      INACTIVE    All EventRules are INACTIVE and any call can be run.      DELETING    This NotificationConfiguration is being deleted.   Only GET and LIST calls can be run.
        public let status: NotificationConfigurationStatus

        @inlinable
        public init(arn: String, status: NotificationConfigurationStatus) {
            self.arn = arn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case status = "status"
        }
    }

    public struct DeleteEventRuleRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the EventRule to delete.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}/rule/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEventRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteNotificationConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration to delete.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNotificationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeregisterNotificationHubRequest: AWSEncodableShape {
        /// The NotificationHub Region.
        public let notificationHubRegion: String

        @inlinable
        public init(notificationHubRegion: String) {
            self.notificationHubRegion = notificationHubRegion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.notificationHubRegion, key: "notificationHubRegion")
        }

        public func validate(name: String) throws {
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, max: 25)
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, min: 2)
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, pattern: "^([a-z]{1,2})-([a-z]{1,15}-)+([0-9])$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeregisterNotificationHubResponse: AWSDecodableShape {
        /// The NotificationHub Region.
        public let notificationHubRegion: String
        /// NotificationHub status information.
        public let statusSummary: NotificationHubStatusSummary

        @inlinable
        public init(notificationHubRegion: String, statusSummary: NotificationHubStatusSummary) {
            self.notificationHubRegion = notificationHubRegion
            self.statusSummary = statusSummary
        }

        private enum CodingKeys: String, CodingKey {
            case notificationHubRegion = "notificationHubRegion"
            case statusSummary = "statusSummary"
        }
    }

    public struct Dimension: AWSDecodableShape {
        /// The name of the dimension
        public let name: String
        /// The value of the dimension.
        public let value: String

        @inlinable
        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct DisassociateChannelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Channel to disassociate.
        public let arn: String
        /// The ARN of the NotificationConfiguration to disassociate.
        public let notificationConfigurationArn: String

        @inlinable
        public init(arn: String, notificationConfigurationArn: String) {
            self.arn = arn
            self.notificationConfigurationArn = notificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encode(self.notificationConfigurationArn, forKey: .notificationConfigurationArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:(chatbot|consoleapp|notifications-contacts):[a-zA-Z0-9-]*:[0-9]{12}:[a-zA-Z0-9-_.@]+/[a-zA-Z0-9/_.@:-]+$")
            try self.validate(self.notificationConfigurationArn, name: "notificationConfigurationArn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: String, CodingKey {
            case notificationConfigurationArn = "notificationConfigurationArn"
        }
    }

    public struct DisassociateChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EventRuleStatusSummary: AWSDecodableShape {
        /// A human-readable reason for EventRuleStatus.
        public let reason: String
        /// The status of the EventRule.   Values:    ACTIVE    The EventRule can process events.      INACTIVE    The EventRule may be unable to process events.      CREATING    The EventRule is being created. Only GET and LIST calls can be run.      UPDATING    The EventRule is being updated. Only GET and LIST calls can be run.      DELETING    The EventRule is being deleted. Only GET and LIST calls can be run.
        public let status: EventRuleStatus

        @inlinable
        public init(reason: String, status: EventRuleStatus) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct EventRuleStructure: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// The creation time of the resource.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// An additional event pattern used to further filter the events this EventRule receives. For more information, see Amazon EventBridge event patterns in the Amazon EventBridge User Guide.
        public let eventPattern: String
        /// The event type to match. Must match one of the valid Amazon EventBridge event types. For example, EC2 Instance State-change Notification and AWS CloudWatch Alarm State Change. For more information, see Event delivery from AWS services in the Amazon EventBridge User Guide.
        public let eventType: String
        /// A list of Amazon EventBridge Managed Rule ARNs associated with this EventRule.  These are created by AWS User Notifications within your account so your EventRules can function.
        public let managedRules: [String]
        /// The ARN for the NotificationConfiguration associated with this EventRule.
        public let notificationConfigurationArn: String
        /// A list of AWS Regions that send events to this EventRule.
        public let regions: [String]
        /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from AWS services in the Amazon EventBridge User Guide.
        public let source: String
        /// A list of an EventRule's status by Region. Regions are mapped to EventRuleStatusSummary.
        public let statusSummaryByRegion: [String: EventRuleStatusSummary]

        @inlinable
        public init(arn: String, creationTime: Date, eventPattern: String, eventType: String, managedRules: [String], notificationConfigurationArn: String, regions: [String], source: String, statusSummaryByRegion: [String: EventRuleStatusSummary]) {
            self.arn = arn
            self.creationTime = creationTime
            self.eventPattern = eventPattern
            self.eventType = eventType
            self.managedRules = managedRules
            self.notificationConfigurationArn = notificationConfigurationArn
            self.regions = regions
            self.source = source
            self.statusSummaryByRegion = statusSummaryByRegion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case eventPattern = "eventPattern"
            case eventType = "eventType"
            case managedRules = "managedRules"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case regions = "regions"
            case source = "source"
            case statusSummaryByRegion = "statusSummaryByRegion"
        }
    }

    public struct GetEventRuleRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the EventRule to return.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}/rule/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEventRuleResponse: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String
        /// The date when the EventRule was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// An additional event pattern used to further filter the events this EventRule receives. For more information, see Amazon EventBridge event patterns in the Amazon EventBridge User Guide.
        public let eventPattern: String
        /// The event type to match. Must match one of the valid Amazon EventBridge event types. For example, EC2 Instance State-change Notification and AWS CloudWatch Alarm State Change. For more information, see Event delivery from AWS services in the Amazon EventBridge User Guide.
        public let eventType: String
        /// A list of managed rules from EventBridge that are are associated with this EventRule.  These are created by AWS User Notifications within your account so this EventRule functions.
        public let managedRules: [String]
        /// The ARN of a NotificationConfiguration.
        public let notificationConfigurationArn: String
        /// A list of AWS Regions that send events to this EventRule.
        public let regions: [String]
        /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from AWS services in the Amazon EventBridge User Guide.
        public let source: String
        /// A list of an EventRule's status by Region. Regions are mapped to EventRuleStatusSummary.
        public let statusSummaryByRegion: [String: EventRuleStatusSummary]

        @inlinable
        public init(arn: String, creationTime: Date, eventPattern: String, eventType: String, managedRules: [String], notificationConfigurationArn: String, regions: [String], source: String, statusSummaryByRegion: [String: EventRuleStatusSummary]) {
            self.arn = arn
            self.creationTime = creationTime
            self.eventPattern = eventPattern
            self.eventType = eventType
            self.managedRules = managedRules
            self.notificationConfigurationArn = notificationConfigurationArn
            self.regions = regions
            self.source = source
            self.statusSummaryByRegion = statusSummaryByRegion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case eventPattern = "eventPattern"
            case eventType = "eventType"
            case managedRules = "managedRules"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case regions = "regions"
            case source = "source"
            case statusSummaryByRegion = "statusSummaryByRegion"
        }
    }

    public struct GetNotificationConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration to return.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNotificationConfigurationResponse: AWSDecodableShape {
        /// The aggregation preference of the NotificationConfiguration.   Values:    LONG    Aggregate notifications for long periods of time (12 hours).      SHORT    Aggregate notifications for short periods of time (5 minutes).      NONE    Don't aggregate notifications. No delay in delivery.
        public let aggregationDuration: AggregationDuration?
        /// The ARN of the resource.
        public let arn: String
        /// The creation time of the NotificationConfiguration.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of the NotificationConfiguration.
        public let description: String
        /// The name of the NotificationConfiguration.
        public let name: String
        /// The status of this NotificationConfiguration. The status should always be INACTIVE when part of the CreateNotificationConfiguration response.   Values:    ACTIVE    All EventRules are ACTIVE and any call can be run.      PARTIALLY_ACTIVE    Some EventRules are ACTIVE and some are INACTIVE.   Any call can be run.      INACTIVE    All EventRules are INACTIVE and any call can be run.      DELETING    This NotificationConfiguration is being deleted. Only GET and LIST calls can be run.   Only GET and LIST calls can be run.
        public let status: NotificationConfigurationStatus

        @inlinable
        public init(aggregationDuration: AggregationDuration? = nil, arn: String, creationTime: Date, description: String, name: String, status: NotificationConfigurationStatus) {
            self.aggregationDuration = aggregationDuration
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationDuration = "aggregationDuration"
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetNotificationEventRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the NotificationEvent to return.
        public let arn: String
        /// The locale code of the language used for the retrieved NotificationEvent. The default locale is English en_US.
        public let locale: LocaleCode?

        @inlinable
        public init(arn: String, locale: LocaleCode? = nil) {
            self.arn = arn
            self.locale = locale
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            request.encodeQuery(self.locale, key: "locale")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications:[-.a-z0-9]{1,63}:[0-9]{12}:configuration/[a-z0-9]{27}/event/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNotificationEventResponse: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String
        /// The content of the NotificationEvent.
        public let content: NotificationEventSchema
        /// The creation time of the NotificationEvent.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The ARN of the NotificationConfiguration.
        public let notificationConfigurationArn: String

        @inlinable
        public init(arn: String, content: NotificationEventSchema, creationTime: Date, notificationConfigurationArn: String) {
            self.arn = arn
            self.content = content
            self.creationTime = creationTime
            self.notificationConfigurationArn = notificationConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case content = "content"
            case creationTime = "creationTime"
            case notificationConfigurationArn = "notificationConfigurationArn"
        }
    }

    public struct ListChannelsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned in this call. The default value is 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListNotificationEvents call. NextToken uses Base64 encoding.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration.
        public let notificationConfigurationArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, notificationConfigurationArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.notificationConfigurationArn = notificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.notificationConfigurationArn, key: "notificationConfigurationArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
            try self.validate(self.notificationConfigurationArn, name: "notificationConfigurationArn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsResponse: AWSDecodableShape {
        /// A list of Channels.
        public let channels: [String]
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(channels: [String], nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventRulesRequest: AWSEncodableShape {
        /// The maximum number of results to be returned in this call. The default value is 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListEventRules call. Next token uses Base64 encoding.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration.
        public let notificationConfigurationArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, notificationConfigurationArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.notificationConfigurationArn = notificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.notificationConfigurationArn, key: "notificationConfigurationArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
            try self.validate(self.notificationConfigurationArn, name: "notificationConfigurationArn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventRulesResponse: AWSDecodableShape {
        /// A list of EventRules.
        public let eventRules: [EventRuleStructure]
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(eventRules: [EventRuleStructure], nextToken: String? = nil) {
            self.eventRules = eventRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventRules = "eventRules"
            case nextToken = "nextToken"
        }
    }

    public struct ListNotificationConfigurationsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Channel to match.
        public let channelArn: String?
        /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from AWS services in the Amazon EventBridge User Guide.
        public let eventRuleSource: String?
        /// The maximum number of results to be returned in this call. Defaults to 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListEventRules call. Next token uses Base64 encoding.
        public let nextToken: String?
        /// The NotificationConfiguration status to match.   Values:    ACTIVE    All EventRules are ACTIVE and any call can be run.      PARTIALLY_ACTIVE    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.   Any call can be run.      INACTIVE    All EventRules are INACTIVE and any call can be run.      DELETING    This NotificationConfiguration is being deleted.   Only GET and LIST calls can be run.
        public let status: NotificationConfigurationStatus?

        @inlinable
        public init(channelArn: String? = nil, eventRuleSource: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, status: NotificationConfigurationStatus? = nil) {
            self.channelArn = channelArn
            self.eventRuleSource = eventRuleSource
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.channelArn, key: "channelArn")
            request.encodeQuery(self.eventRuleSource, key: "eventRuleSource")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:aws:(chatbot|consoleapp|notifications-contacts):[a-zA-Z0-9-]*:[0-9]{12}:[a-zA-Z0-9-_.@]+/[a-zA-Z0-9/_.@:-]+$")
            try self.validate(self.eventRuleSource, name: "eventRuleSource", parent: name, max: 36)
            try self.validate(self.eventRuleSource, name: "eventRuleSource", parent: name, min: 1)
            try self.validate(self.eventRuleSource, name: "eventRuleSource", parent: name, pattern: "^aws.([a-z0-9\\-])+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationConfigurationsResponse: AWSDecodableShape {
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?
        /// The NotificationConfigurations in the account.
        public let notificationConfigurations: [NotificationConfigurationStructure]

        @inlinable
        public init(nextToken: String? = nil, notificationConfigurations: [NotificationConfigurationStructure]) {
            self.nextToken = nextToken
            self.notificationConfigurations = notificationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case notificationConfigurations = "notificationConfigurations"
        }
    }

    public struct ListNotificationEventsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the aggregatedNotificationEventArn to match.
        public let aggregateNotificationEventArn: String?
        /// Latest time of events to return from this call.
        public let endTime: Date?
        /// Include aggregated child events in the result.
        public let includeChildEvents: Bool?
        /// The locale code of the language used for the retrieved NotificationEvent. The default locale is English (en_US).
        public let locale: LocaleCode?
        /// The maximum number of results to be returned in this call. Defaults to 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListEventRules call. Next token uses Base64 encoding.
        public let nextToken: String?
        /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from AWS services in the Amazon EventBridge User Guide.
        public let source: String?
        /// The earliest time of events to return from this call.
        public let startTime: Date?

        @inlinable
        public init(aggregateNotificationEventArn: String? = nil, endTime: Date? = nil, includeChildEvents: Bool? = nil, locale: LocaleCode? = nil, maxResults: Int? = nil, nextToken: String? = nil, source: String? = nil, startTime: Date? = nil) {
            self.aggregateNotificationEventArn = aggregateNotificationEventArn
            self.endTime = endTime
            self.includeChildEvents = includeChildEvents
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.source = source
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aggregateNotificationEventArn, key: "aggregateNotificationEventArn")
            request.encodeQuery(self.endTime, key: "endTime")
            request.encodeQuery(self.includeChildEvents, key: "includeChildEvents")
            request.encodeQuery(self.locale, key: "locale")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.source, key: "source")
            request.encodeQuery(self.startTime, key: "startTime")
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregateNotificationEventArn, name: "aggregateNotificationEventArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications:[-.a-z0-9]{1,63}:[0-9]{12}:configuration/[a-z0-9]{27}/event/[a-z0-9]{27}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
            try self.validate(self.source, name: "source", parent: name, max: 36)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "^aws.([a-z0-9\\-])+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationEventsResponse: AWSDecodableShape {
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?
        /// The list of notification events.
        public let notificationEvents: [NotificationEventOverview]

        @inlinable
        public init(nextToken: String? = nil, notificationEvents: [NotificationEventOverview]) {
            self.nextToken = nextToken
            self.notificationEvents = notificationEvents
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case notificationEvents = "notificationEvents"
        }
    }

    public struct ListNotificationHubsRequest: AWSEncodableShape {
        /// The maximum number of records to list in a single response.
        public let maxResults: Int?
        /// A pagination token. Set to null to start listing notification hubs from the start.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationHubsResponse: AWSDecodableShape {
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?
        /// The NotificationHubs in the account.
        public let notificationHubs: [NotificationHubOverview]

        @inlinable
        public init(nextToken: String? = nil, notificationHubs: [NotificationHubOverview]) {
            self.nextToken = nextToken
            self.notificationHubs = notificationHubs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case notificationHubs = "notificationHubs"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to list tags.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags for the specified ARN.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MediaElement: AWSDecodableShape {
        /// The caption of the media.
        public let caption: String
        /// The unique ID for the media.
        public let mediaId: String
        /// The type of media.
        public let type: MediaElementType
        /// The url of the media.
        public let url: String

        @inlinable
        public init(caption: String, mediaId: String, type: MediaElementType, url: String) {
            self.caption = caption
            self.mediaId = mediaId
            self.type = type
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case caption = "caption"
            case mediaId = "mediaId"
            case type = "type"
            case url = "url"
        }
    }

    public struct MessageComponents: AWSDecodableShape {
        /// A complete summary with all possible relevant information.
        public let completeDescription: String?
        /// A list of properties in key-value pairs. Pairs are shown in order of importance from most important to least important. Channels may limit the number of dimensions shown to the notification viewer.  Included dimensions, keys, and values are subject to change.
        public let dimensions: [Dimension]?
        /// A sentence long summary. For example, titles or an email subject line.
        public let headline: String?
        /// A paragraph long or multiple sentence summary. For example, AWS Chatbot notifications.
        public let paragraphSummary: String?

        @inlinable
        public init(completeDescription: String? = nil, dimensions: [Dimension]? = nil, headline: String? = nil, paragraphSummary: String? = nil) {
            self.completeDescription = completeDescription
            self.dimensions = dimensions
            self.headline = headline
            self.paragraphSummary = paragraphSummary
        }

        private enum CodingKeys: String, CodingKey {
            case completeDescription = "completeDescription"
            case dimensions = "dimensions"
            case headline = "headline"
            case paragraphSummary = "paragraphSummary"
        }
    }

    public struct MessageComponentsSummary: AWSDecodableShape {
        /// A sentence long summary. For example, titles or an email subject line.
        public let headline: String

        @inlinable
        public init(headline: String) {
            self.headline = headline
        }

        private enum CodingKeys: String, CodingKey {
            case headline = "headline"
        }
    }

    public struct NotificationConfigurationStructure: AWSDecodableShape {
        /// The aggregation preference of the NotificationConfiguration.   Values:    LONG    Aggregate notifications for long periods of time (12 hours).      SHORT    Aggregate notifications for short periods of time (5 minutes).      NONE    Don't aggregate notifications. No delay in delivery.
        public let aggregationDuration: AggregationDuration?
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// The creation time of the resource.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of the NotificationConfiguration.
        public let description: String
        /// The name of the NotificationConfiguration. Supports RFC 3986's unreserved characters.
        public let name: String
        /// The status of this NotificationConfiguration. The status should always be INACTIVE when part of the CreateNotificationConfiguration response.   Values:    ACTIVE    All EventRules are ACTIVE and any call can be run.      PARTIALLY_ACTIVE    Some EventRules are ACTIVE and some are INACTIVE.   Any call can be run.      INACTIVE    All EventRules are INACTIVE and any call can be run.      DELETING    This NotificationConfiguration is being deleted. Only GET and LIST calls can be run.   Only GET and LIST calls can be run.
        public let status: NotificationConfigurationStatus

        @inlinable
        public init(aggregationDuration: AggregationDuration? = nil, arn: String, creationTime: Date, description: String, name: String, status: NotificationConfigurationStatus) {
            self.aggregationDuration = aggregationDuration
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationDuration = "aggregationDuration"
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case name = "name"
            case status = "status"
        }
    }

    public struct NotificationEventOverview: AWSDecodableShape {
        /// The ARN of the aggregatedNotificationEventArn to match.
        public let aggregateNotificationEventArn: String?
        /// The NotificationConfiguration's aggregation type.   Values:    AGGREGATE    The notification event is an aggregate notification. Aggregate notifications summarize grouped events over a specified time period.      CHILD    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.      NONE    The notification isn't aggregated.
        public let aggregationEventType: AggregationEventType?
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// The creation time of the NotificationEvent.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The ARN of the NotificationConfiguration.
        public let notificationConfigurationArn: String
        /// Refers to a NotificationEventSummary object. Similar in structure to content in the GetNotificationEvent response.
        public let notificationEvent: NotificationEventSummary
        /// The account name containing the NotificationHub.
        public let relatedAccount: String

        @inlinable
        public init(aggregateNotificationEventArn: String? = nil, aggregationEventType: AggregationEventType? = nil, arn: String, creationTime: Date, notificationConfigurationArn: String, notificationEvent: NotificationEventSummary, relatedAccount: String) {
            self.aggregateNotificationEventArn = aggregateNotificationEventArn
            self.aggregationEventType = aggregationEventType
            self.arn = arn
            self.creationTime = creationTime
            self.notificationConfigurationArn = notificationConfigurationArn
            self.notificationEvent = notificationEvent
            self.relatedAccount = relatedAccount
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateNotificationEventArn = "aggregateNotificationEventArn"
            case aggregationEventType = "aggregationEventType"
            case arn = "arn"
            case creationTime = "creationTime"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case notificationEvent = "notificationEvent"
            case relatedAccount = "relatedAccount"
        }
    }

    public struct NotificationEventSchema: AWSDecodableShape {
        /// If the value of aggregationEventType is not NONE, this is the  Amazon Resource Event (ARN) of the parent aggregate notification. This is omitted if notification isn't aggregated.
        public let aggregateNotificationEventArn: String?
        /// The NotificationConfiguration's aggregation type.   Values:    AGGREGATE    The notification event is an aggregate notification. Aggregate notifications summarize grouped events over a specified time period.      CHILD    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.      NONE    The notification isn't aggregated.
        public let aggregationEventType: AggregationEventType?
        /// The end time of the event.
        public let endTime: Date?
        /// The assesed nature of the event.   Values:    HEALTHY    All EventRules are ACTIVE and any call can be run.      UNHEALTHY    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.
        public let eventStatus: EventStatus?
        /// The unique identifier for a NotificationEvent.
        public let id: String
        /// A list of media elements.
        public let media: [MediaElement]
        public let messageComponents: MessageComponents
        /// The type of event causing the notification.   Values:    ALERT    A notification about an event where something was triggered, initiated, reopened, deployed, or a threshold was breached.      WARNING    A notification about an event where an issue is about to arise. For example, something is approaching a threshold.      ANNOUNCEMENT    A notification about an important event. For example, a step in a workflow or escalation path or that a workflow was updated.      INFORMATIONAL    A notification about informational messages. For example, recommendations, service announcements, or reminders.
        public let notificationType: NotificationType
        /// The schema version of the Notification Event.
        public let schemaVersion: SchemaVersion
        /// The source event URL.
        public let sourceEventDetailUrl: String?
        /// The detailed URL for the source event.
        public let sourceEventDetailUrlDisplayText: String?
        /// The source event metadata.
        public let sourceEventMetadata: SourceEventMetadata
        /// The notification event start time.
        public let startTime: Date?
        /// A list of text values.
        public let textParts: [String: TextPartValue]

        @inlinable
        public init(aggregateNotificationEventArn: String? = nil, aggregationEventType: AggregationEventType? = nil, endTime: Date? = nil, eventStatus: EventStatus? = nil, id: String, media: [MediaElement], messageComponents: MessageComponents, notificationType: NotificationType, schemaVersion: SchemaVersion, sourceEventDetailUrl: String? = nil, sourceEventDetailUrlDisplayText: String? = nil, sourceEventMetadata: SourceEventMetadata, startTime: Date? = nil, textParts: [String: TextPartValue]) {
            self.aggregateNotificationEventArn = aggregateNotificationEventArn
            self.aggregationEventType = aggregationEventType
            self.endTime = endTime
            self.eventStatus = eventStatus
            self.id = id
            self.media = media
            self.messageComponents = messageComponents
            self.notificationType = notificationType
            self.schemaVersion = schemaVersion
            self.sourceEventDetailUrl = sourceEventDetailUrl
            self.sourceEventDetailUrlDisplayText = sourceEventDetailUrlDisplayText
            self.sourceEventMetadata = sourceEventMetadata
            self.startTime = startTime
            self.textParts = textParts
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateNotificationEventArn = "aggregateNotificationEventArn"
            case aggregationEventType = "aggregationEventType"
            case endTime = "endTime"
            case eventStatus = "eventStatus"
            case id = "id"
            case media = "media"
            case messageComponents = "messageComponents"
            case notificationType = "notificationType"
            case schemaVersion = "schemaVersion"
            case sourceEventDetailUrl = "sourceEventDetailUrl"
            case sourceEventDetailUrlDisplayText = "sourceEventDetailUrlDisplayText"
            case sourceEventMetadata = "sourceEventMetadata"
            case startTime = "startTime"
            case textParts = "textParts"
        }
    }

    public struct NotificationEventSummary: AWSDecodableShape {
        /// The notification event status.   Values:    HEALTHY    All EventRules are ACTIVE and any call can be run.      UNHEALTHY    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.
        public let eventStatus: EventStatus
        /// The message components of a notification event.
        public let messageComponents: MessageComponentsSummary
        /// The type of event causing the notification.   Values:    ALERT    A notification about an event where something was triggered, initiated, reopened, deployed, or a threshold was breached.      WARNING    A notification about an event where an issue is about to arise. For example, something is approaching a threshold.      ANNOUNCEMENT    A notification about an important event. For example, a step in a workflow or escalation path or that a workflow was updated.      INFORMATIONAL    A notification about informational messages. For example, recommendations, service announcements, or reminders.
        public let notificationType: NotificationType
        /// The schema version of the Notification Event.
        public let schemaVersion: SchemaVersion
        /// The source event metadata.
        public let sourceEventMetadata: SourceEventMetadataSummary

        @inlinable
        public init(eventStatus: EventStatus, messageComponents: MessageComponentsSummary, notificationType: NotificationType, schemaVersion: SchemaVersion, sourceEventMetadata: SourceEventMetadataSummary) {
            self.eventStatus = eventStatus
            self.messageComponents = messageComponents
            self.notificationType = notificationType
            self.schemaVersion = schemaVersion
            self.sourceEventMetadata = sourceEventMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case eventStatus = "eventStatus"
            case messageComponents = "messageComponents"
            case notificationType = "notificationType"
            case schemaVersion = "schemaVersion"
            case sourceEventMetadata = "sourceEventMetadata"
        }
    }

    public struct NotificationHubOverview: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The most recent time this NotificationHub had an ACTIVE status.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastActivationTime: Date?
        /// The Region of the resource.
        public let notificationHubRegion: String
        /// The status summary of the resource.
        public let statusSummary: NotificationHubStatusSummary

        @inlinable
        public init(creationTime: Date, lastActivationTime: Date? = nil, notificationHubRegion: String, statusSummary: NotificationHubStatusSummary) {
            self.creationTime = creationTime
            self.lastActivationTime = lastActivationTime
            self.notificationHubRegion = notificationHubRegion
            self.statusSummary = statusSummary
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case lastActivationTime = "lastActivationTime"
            case notificationHubRegion = "notificationHubRegion"
            case statusSummary = "statusSummary"
        }
    }

    public struct NotificationHubStatusSummary: AWSDecodableShape {
        /// An Explanation for the current status.
        public let reason: String
        /// Status information about the NotificationHub.   Values:    ACTIVE    Incoming NotificationEvents are replicated to this NotificationHub.      REGISTERING    The NotificationHub is initializing. A NotificationHub with this status can't be deregistered.      DEREGISTERING    The NotificationHub is being deleted. You can't register additional NotificationHubs in the same Region as a NotificationHub with this status.
        public let status: NotificationHubStatus

        @inlinable
        public init(reason: String, status: NotificationHubStatus) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct RegisterNotificationHubRequest: AWSEncodableShape {
        /// The Region of the NotificationHub.
        public let notificationHubRegion: String

        @inlinable
        public init(notificationHubRegion: String) {
            self.notificationHubRegion = notificationHubRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, max: 25)
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, min: 2)
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, pattern: "^([a-z]{1,2})-([a-z]{1,15}-)+([0-9])$")
        }

        private enum CodingKeys: String, CodingKey {
            case notificationHubRegion = "notificationHubRegion"
        }
    }

    public struct RegisterNotificationHubResponse: AWSDecodableShape {
        /// The date the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The date the resource was last activated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastActivationTime: Date?
        /// The Region of the NotificationHub.
        public let notificationHubRegion: String
        /// NotificationHub status information.
        public let statusSummary: NotificationHubStatusSummary

        @inlinable
        public init(creationTime: Date, lastActivationTime: Date? = nil, notificationHubRegion: String, statusSummary: NotificationHubStatusSummary) {
            self.creationTime = creationTime
            self.lastActivationTime = lastActivationTime
            self.notificationHubRegion = notificationHubRegion
            self.statusSummary = statusSummary
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case lastActivationTime = "lastActivationTime"
            case notificationHubRegion = "notificationHubRegion"
            case statusSummary = "statusSummary"
        }
    }

    public struct Resource: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource. At least one id or ARN is required.
        public let arn: String?
        /// The URL to the resource's detail page. If a detail page URL is unavailable, it is the URL to an informational page that describes the resource's type.
        public let detailUrl: String?
        /// The unique identifier for the resource. At least one id or ARN is required.
        public let id: String?
        /// A map of tags assigned to a resource. A tag is a string-to-string map of key-value pairs.
        public let tags: [String]?

        @inlinable
        public init(arn: String? = nil, detailUrl: String? = nil, id: String? = nil, tags: [String]? = nil) {
            self.arn = arn
            self.detailUrl = detailUrl
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case detailUrl = "detailUrl"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct SourceEventMetadata: AWSDecodableShape {
        /// The date and time the source event occurred. This is based on the Source Event.
        public let eventOccurrenceTime: Date
        /// The Region the event originated from.
        public let eventOriginRegion: String?
        /// The type of event. For example, an AWS CloudWatch state change.
        public let eventType: String
        /// The version of the type of event.
        public let eventTypeVersion: String
        /// The Primary AWS account of Source Event
        public let relatedAccount: String
        /// A list of resources related to this NotificationEvent.
        public let relatedResources: [Resource]
        /// The AWS servvice the event originates from. For example aws.cloudwatch.
        public let source: String
        /// The source event id.
        public let sourceEventId: String

        @inlinable
        public init(eventOccurrenceTime: Date, eventOriginRegion: String? = nil, eventType: String, eventTypeVersion: String, relatedAccount: String, relatedResources: [Resource], source: String, sourceEventId: String) {
            self.eventOccurrenceTime = eventOccurrenceTime
            self.eventOriginRegion = eventOriginRegion
            self.eventType = eventType
            self.eventTypeVersion = eventTypeVersion
            self.relatedAccount = relatedAccount
            self.relatedResources = relatedResources
            self.source = source
            self.sourceEventId = sourceEventId
        }

        private enum CodingKeys: String, CodingKey {
            case eventOccurrenceTime = "eventOccurrenceTime"
            case eventOriginRegion = "eventOriginRegion"
            case eventType = "eventType"
            case eventTypeVersion = "eventTypeVersion"
            case relatedAccount = "relatedAccount"
            case relatedResources = "relatedResources"
            case source = "source"
            case sourceEventId = "sourceEventId"
        }
    }

    public struct SourceEventMetadataSummary: AWSDecodableShape {
        /// The Region where the notification originated. Unavailable for aggregated notifications.
        public let eventOriginRegion: String?
        /// The event type to match. Must match one of the valid Amazon EventBridge event types. For example, EC2 Instance State-change Notification and AWS CloudWatch Alarm State Change. For more information, see Event delivery from AWS services in the Amazon EventBridge User Guide.
        public let eventType: String
        /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from AWS services in the Amazon EventBridge User Guide.
        public let source: String

        @inlinable
        public init(eventOriginRegion: String? = nil, eventType: String, source: String) {
            self.eventOriginRegion = eventOriginRegion
            self.eventType = eventType
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case eventOriginRegion = "eventOriginRegion"
            case eventType = "eventType"
            case source = "source"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to tag a resource.
        public let arn: String
        /// A map of tags assigned to a resource. A tag is a string-to-string map of key-value pairs.
        public let tags: [String: String]

        @inlinable
        public init(arn: String, tags: [String: String]) {
            self.arn = arn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TextPartValue: AWSDecodableShape {
        /// A short single line description of the link. Must be hyperlinked with the URL itself.  Used for text parts with the type URL.
        public let displayText: String?
        /// A map of locales to the text in that locale.
        public let textByLocale: [LocaleCode: String]?
        /// The type of text part. Determines the usage of all other fields and whether or not they're required.
        public let type: TextPartType
        /// The URL itself.
        public let url: String?

        @inlinable
        public init(displayText: String? = nil, textByLocale: [LocaleCode: String]? = nil, type: TextPartType, url: String? = nil) {
            self.displayText = displayText
            self.textByLocale = textByLocale
            self.type = type
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case displayText = "displayText"
            case textByLocale = "textByLocale"
            case type = "type"
            case url = "url"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to untag a resource.
        public let arn: String
        /// The tag keys to use to untag a resource.
        public let tagKeys: [String]

        @inlinable
        public init(arn: String, tagKeys: [String]) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:).{1,128}$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEventRuleRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to update the EventRule.
        public let arn: String
        /// An additional event pattern used to further filter the events this EventRule receives. For more information, see Amazon EventBridge event patterns in the Amazon EventBridge User Guide.
        public let eventPattern: String?
        /// A list of AWS Regions that sends events to this EventRule.
        public let regions: [String]?

        @inlinable
        public init(arn: String, eventPattern: String? = nil, regions: [String]? = nil) {
            self.arn = arn
            self.eventPattern = eventPattern
            self.regions = regions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encodeIfPresent(self.eventPattern, forKey: .eventPattern)
            try container.encodeIfPresent(self.regions, forKey: .regions)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}/rule/[a-z0-9]{27}$")
            try self.validate(self.eventPattern, name: "eventPattern", parent: name, max: 4096)
            try self.regions?.forEach {
                try validate($0, name: "regions[]", parent: name, max: 25)
                try validate($0, name: "regions[]", parent: name, min: 2)
                try validate($0, name: "regions[]", parent: name, pattern: "^([a-z]{1,2})-([a-z]{1,15}-)+([0-9])$")
            }
            try self.validate(self.regions, name: "regions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eventPattern = "eventPattern"
            case regions = "regions"
        }
    }

    public struct UpdateEventRuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) to use to update the EventRule.
        public let arn: String
        /// The ARN of the NotificationConfiguration.
        public let notificationConfigurationArn: String
        /// The status of the action by Region.
        public let statusSummaryByRegion: [String: EventRuleStatusSummary]

        @inlinable
        public init(arn: String, notificationConfigurationArn: String, statusSummaryByRegion: [String: EventRuleStatusSummary]) {
            self.arn = arn
            self.notificationConfigurationArn = notificationConfigurationArn
            self.statusSummaryByRegion = statusSummaryByRegion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case statusSummaryByRegion = "statusSummaryByRegion"
        }
    }

    public struct UpdateNotificationConfigurationRequest: AWSEncodableShape {
        /// The status of this NotificationConfiguration. The status should always be INACTIVE when part of the CreateNotificationConfiguration response.   Values:    ACTIVE    All EventRules are ACTIVE and any call can be run.      PARTIALLY_ACTIVE    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.   Any call can be run.      INACTIVE    All EventRules are INACTIVE and any call can be run.      DELETING    This NotificationConfiguration is being deleted.   Only GET and LIST calls can be run.
        public let aggregationDuration: AggregationDuration?
        /// The Amazon Resource Name (ARN) used to update the NotificationConfiguration.
        public let arn: String
        /// The description of the NotificationConfiguration.
        public let description: String?
        /// The name of the NotificationConfiguration.
        public let name: String?

        @inlinable
        public init(aggregationDuration: AggregationDuration? = nil, arn: String, description: String? = nil, name: String? = nil) {
            self.aggregationDuration = aggregationDuration
            self.arn = arn
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.aggregationDuration, forKey: .aggregationDuration)
            request.encodePath(self.arn, key: "arn")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0001-\\u001F\\u007F-\\u009F]*$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationDuration = "aggregationDuration"
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateNotificationConfigurationResponse: AWSDecodableShape {
        /// The ARN used to update the NotificationConfiguration.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }
}

// MARK: - Errors

/// Error enum for Notifications
public struct NotificationsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Notifications
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Unexpected error during processing of request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This exception is thrown when the notification event fails validation.
    public static var validationException: Self { .init(.validationException) }
}

extension NotificationsErrorType: Equatable {
    public static func == (lhs: NotificationsErrorType, rhs: NotificationsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension NotificationsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
