//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Notifications {
    // MARK: Enums

    public enum AccessStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum AccountContactType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        ///     Alternate Billing Contact managed by AWS Account Management Service.
        case accountAlternateBilling = "ACCOUNT_ALTERNATE_BILLING"
        ///     Alternate Operations Contact managed by AWS Account Management Service.
        case accountAlternateOperations = "ACCOUNT_ALTERNATE_OPERATIONS"
        ///     Alternate Security Contact managed by AWS Account Management Service.
        case accountAlternateSecurity = "ACCOUNT_ALTERNATE_SECURITY"
        ///     Primary Contact managed by AWS Account Management Service.
        case accountPrimary = "ACCOUNT_PRIMARY"
        public var description: String { return self.rawValue }
    }

    public enum AggregationDuration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Aggregate notifications for long periods of time (12 hours)
        case long = "LONG"
        /// Do not aggregate notifications sourced from a notification configuration
        case none = "NONE"
        /// Aggregate notifications for short periods of time (5 mins)
        case short = "SHORT"
        public var description: String { return self.rawValue }
    }

    public enum AggregationEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aggregate = "AGGREGATE"
        case child = "CHILD"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ChannelAssociationOverrideOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        ///     AWS User Notification service users can not associate or disassociate a Channel with a notification configuration.
        case disabled = "DISABLED"
        ///     AWS User Notification service users can associate or disassociate a Channel with a notification configuration.
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ChannelType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        ///     User Notification Service sends notifications to Account Managed contacts.
        case accountContact = "ACCOUNT_CONTACT"
        ///     Chatbot sends notifications to group platforms, like Slack or Chime. Link:https://aws.amazon.com/chatbot/
        case chatbot = "CHATBOT"
        ///     Email sends notifications to email addresses.
        case email = "EMAIL"
        ///     AWS Console Mobile App sends notifications to mobile devices. Link:https://aws.amazon.com/console/mobile/
        case mobile = "MOBILE"
        public var description: String { return self.rawValue }
    }

    public enum EventRuleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// EventRule is processing events. Any call can be executed.
        case active = "ACTIVE"
        /// This EventRule is being created. Only GET/LIST calls can be executed.
        case creating = "CREATING"
        /// This EventRule is being deleted. Only GET/LIST calls can be executed.
        case deleting = "DELETING"
        /// EventRule is in a bad state and may not be processing events. Any call can be executed.
        case inactive = "INACTIVE"
        /// This EventRule is being updated. Only GET/LIST calls can be executed.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum EventStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum LocaleCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// German (Germany)
        case deDE = "de_DE"
        /// English (Canada)
        case enCA = "en_CA"
        /// English (United Kingdom)
        case enUK = "en_UK"
        /// English (United States). This is the default locale.
        case enUS = "en_US"
        /// Spanish (Spain)
        case esES = "es_ES"
        /// French (Canada)
        case frCA = "fr_CA"
        /// French (France)
        case frFR = "fr_FR"
        /// Bahasa Indonesian (Indonesia)
        case idID = "id_ID"
        /// Italian (Italy)
        case itIT = "it_IT"
        /// Japanese (Japan)
        case jaJP = "ja_JP"
        /// Korean (Korea)
        case koKR = "ko_KR"
        /// Portuguese (Brazil)
        case ptBR = "pt_BR"
        /// Turkish (Turkey)
        case trTR = "tr_TR"
        /// Chinese (China)
        case zhCN = "zh_CN"
        /// Chinese (Taiwan)
        case zhTW = "zh_TW"
        public var description: String { return self.rawValue }
    }

    public enum MediaElementType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case image = "IMAGE"
        public var description: String { return self.rawValue }
    }

    public enum NotificationConfigurationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// All of the EventRules are in ACTIVE Status. Any call can be executed.
        case active = "ACTIVE"
        /// This NotificationConfiguration is being deleted. Only GET/LIST calls can be executed.
        case deleting = "DELETING"
        /// All of the EventRules are in INACTIVE Status. Any call can be executed.
        case inactive = "INACTIVE"
        /// Some EventRules are in ACTIVE Status and some are INACTIVE. Any call can be executed.
        case partiallyActive = "PARTIALLY_ACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum NotificationHubStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Incoming Notification Events are being replicated to this Notification Hub. A Notification Hub with this status can be deregistered.
        case active = "ACTIVE"
        /// Notification Hub is being deleted. Cannot register a Notification Hub in the same region as one in this status.
        case deregistering = "DEREGISTERING"
        /// Notification Hub is in a failure state. Incoming Notification Events are not being replicated to this Hub.
        case inactive = "INACTIVE"
        /// Notification Hub is initializing. Cannot deregister a Notification Hub in this status.
        case registering = "REGISTERING"
        public var description: String { return self.rawValue }
    }

    public enum NotificationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alert = "ALERT"
        case announcement = "ANNOUNCEMENT"
        case informational = "INFORMATIONAL"
        case warning = "WARNING"
        public var description: String { return self.rawValue }
    }

    public enum SchemaVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case v10 = "v1.0"
        public var description: String { return self.rawValue }
    }

    public enum TextPartType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case localizedText = "LOCALIZED_TEXT"
        case plainText = "PLAIN_TEXT"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fieldValidationFailed = "fieldValidationFailed"
        case other = "other"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AggregationDetail: AWSDecodableShape {
        /// Properties used to summarize aggregated events.
        public let summarizationDimensions: [SummarizationDimensionDetail]?

        @inlinable
        public init(summarizationDimensions: [SummarizationDimensionDetail]? = nil) {
            self.summarizationDimensions = summarizationDimensions
        }

        private enum CodingKeys: String, CodingKey {
            case summarizationDimensions = "summarizationDimensions"
        }
    }

    public struct AggregationKey: AWSDecodableShape {
        /// Indicates the type of aggregation key.
        public let name: String
        /// Indicates the value associated with the aggregation key name.
        public let value: String

        @inlinable
        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct AggregationSummary: AWSDecodableShape {
        /// List of additional dimensions used to group and summarize data.
        public let additionalSummarizationDimensions: [SummarizationDimensionOverview]?
        /// Indicates the Amazon Web Services accounts in the aggregation key.
        public let aggregatedAccounts: SummarizationDimensionOverview
        /// Indicates the criteria or rules by which notifications have been grouped together.
        public let aggregatedBy: [AggregationKey]
        /// Indicates the collection of organizational units that are involved in the aggregation key.
        public let aggregatedOrganizationalUnits: SummarizationDimensionOverview?
        /// Indicates the Amazon Web Services Regions in the aggregation key.
        public let aggregatedRegions: SummarizationDimensionOverview
        /// Indicates the number of events associated with the aggregation key.
        public let eventCount: Int

        @inlinable
        public init(additionalSummarizationDimensions: [SummarizationDimensionOverview]? = nil, aggregatedAccounts: SummarizationDimensionOverview, aggregatedBy: [AggregationKey], aggregatedOrganizationalUnits: SummarizationDimensionOverview? = nil, aggregatedRegions: SummarizationDimensionOverview, eventCount: Int) {
            self.additionalSummarizationDimensions = additionalSummarizationDimensions
            self.aggregatedAccounts = aggregatedAccounts
            self.aggregatedBy = aggregatedBy
            self.aggregatedOrganizationalUnits = aggregatedOrganizationalUnits
            self.aggregatedRegions = aggregatedRegions
            self.eventCount = eventCount
        }

        private enum CodingKeys: String, CodingKey {
            case additionalSummarizationDimensions = "additionalSummarizationDimensions"
            case aggregatedAccounts = "aggregatedAccounts"
            case aggregatedBy = "aggregatedBy"
            case aggregatedOrganizationalUnits = "aggregatedOrganizationalUnits"
            case aggregatedRegions = "aggregatedRegions"
            case eventCount = "eventCount"
        }
    }

    public struct AssociateChannelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Channel to associate with the NotificationConfiguration. Supported ARNs include Chatbot, the Console Mobile Application, and notifications-contacts.
        public let arn: String
        /// The ARN of the NotificationConfiguration to associate with the Channel.
        public let notificationConfigurationArn: String

        @inlinable
        public init(arn: String, notificationConfigurationArn: String) {
            self.arn = arn
            self.notificationConfigurationArn = notificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encode(self.notificationConfigurationArn, forKey: .notificationConfigurationArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:(chatbot|consoleapp|notifications-contacts):[a-zA-Z0-9-]*:[0-9]{12}:[a-zA-Z0-9-_.@]+/[a-zA-Z0-9/_.@:-]+$")
            try self.validate(self.notificationConfigurationArn, name: "notificationConfigurationArn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: String, CodingKey {
            case notificationConfigurationArn = "notificationConfigurationArn"
        }
    }

    public struct AssociateChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateManagedNotificationAccountContactRequest: AWSEncodableShape {
        /// A unique value of an Account Contact Type to associate with the ManagedNotificationConfiguration.
        public let contactIdentifier: AccountContactType
        /// The Amazon Resource Name (ARN) of the ManagedNotificationConfiguration to associate with the Account Contact.
        public let managedNotificationConfigurationArn: String

        @inlinable
        public init(contactIdentifier: AccountContactType, managedNotificationConfigurationArn: String) {
            self.contactIdentifier = contactIdentifier
            self.managedNotificationConfigurationArn = managedNotificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactIdentifier, key: "contactIdentifier")
            try container.encode(self.managedNotificationConfigurationArn, forKey: .managedNotificationConfigurationArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.managedNotificationConfigurationArn, name: "managedNotificationConfigurationArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications::[0-9]{12}:managed-notification-configuration/category/[a-zA-Z0-9\\-]{3,64}/sub-category/[a-zA-Z0-9\\-]{3,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case managedNotificationConfigurationArn = "managedNotificationConfigurationArn"
        }
    }

    public struct AssociateManagedNotificationAccountContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateManagedNotificationAdditionalChannelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Channel to associate with the ManagedNotificationConfiguration. Supported ARNs include Chatbot, the Console Mobile Application, and email (notifications-contacts).
        public let channelArn: String
        /// The Amazon Resource Name (ARN) of the ManagedNotificationConfiguration to associate with the additional Channel.
        public let managedNotificationConfigurationArn: String

        @inlinable
        public init(channelArn: String, managedNotificationConfigurationArn: String) {
            self.channelArn = channelArn
            self.managedNotificationConfigurationArn = managedNotificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "channelArn")
            try container.encode(self.managedNotificationConfigurationArn, forKey: .managedNotificationConfigurationArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:aws:(chatbot|consoleapp|notifications-contacts):[a-zA-Z0-9-]*:[0-9]{12}:[a-zA-Z0-9-_.@]+/[a-zA-Z0-9/_.@:-]+$")
            try self.validate(self.managedNotificationConfigurationArn, name: "managedNotificationConfigurationArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications::[0-9]{12}:managed-notification-configuration/category/[a-zA-Z0-9\\-]{3,64}/sub-category/[a-zA-Z0-9\\-]{3,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case managedNotificationConfigurationArn = "managedNotificationConfigurationArn"
        }
    }

    public struct AssociateManagedNotificationAdditionalChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The resource ID that prompted the conflict error.
        public let resourceId: String

        @inlinable
        public init(message: String, resourceId: String) {
            self.message = message
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
        }
    }

    public struct CreateEventRuleRequest: AWSEncodableShape {
        /// An additional event pattern used to further filter the events this EventRule receives. For more information, see Amazon EventBridge event patterns in the Amazon EventBridge User Guide.
        public let eventPattern: String?
        /// The event type to match. Must match one of the valid Amazon EventBridge event types. For example, EC2 Instance State-change Notification and Amazon CloudWatch Alarm State Change. For more information, see Event delivery from Amazon Web Services services in the Amazon EventBridge User Guide.
        public let eventType: String
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration associated with this EventRule.
        public let notificationConfigurationArn: String
        /// A list of Amazon Web Services Regions that send events to this EventRule.
        public let regions: [String]
        /// The matched event source. Must match one of the valid EventBridge sources. Only Amazon Web Services service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from Amazon Web Services services in the Amazon EventBridge User Guide.
        public let source: String

        @inlinable
        public init(eventPattern: String? = nil, eventType: String, notificationConfigurationArn: String, regions: [String], source: String) {
            self.eventPattern = eventPattern
            self.eventType = eventType
            self.notificationConfigurationArn = notificationConfigurationArn
            self.regions = regions
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.eventPattern, name: "eventPattern", parent: name, max: 4096)
            try self.validate(self.eventType, name: "eventType", parent: name, max: 128)
            try self.validate(self.eventType, name: "eventType", parent: name, min: 1)
            try self.validate(self.eventType, name: "eventType", parent: name, pattern: "^([a-zA-Z0-9 \\-\\(\\)])+$")
            try self.validate(self.notificationConfigurationArn, name: "notificationConfigurationArn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
            try self.regions.forEach {
                try validate($0, name: "regions[]", parent: name, max: 25)
                try validate($0, name: "regions[]", parent: name, min: 2)
                try validate($0, name: "regions[]", parent: name, pattern: "^([a-z]{1,2})-([a-z]{1,15}-)+([0-9])$")
            }
            try self.validate(self.regions, name: "regions", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, max: 36)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "^aws.([a-z0-9\\-])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventPattern = "eventPattern"
            case eventType = "eventType"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case regions = "regions"
            case source = "source"
        }
    }

    public struct CreateEventRuleResponse: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String
        /// The ARN of a NotificationConfiguration.
        public let notificationConfigurationArn: String
        /// A list of an EventRule's status by Region. Regions are mapped to EventRuleStatusSummary.
        public let statusSummaryByRegion: [String: EventRuleStatusSummary]

        @inlinable
        public init(arn: String, notificationConfigurationArn: String, statusSummaryByRegion: [String: EventRuleStatusSummary]) {
            self.arn = arn
            self.notificationConfigurationArn = notificationConfigurationArn
            self.statusSummaryByRegion = statusSummaryByRegion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case statusSummaryByRegion = "statusSummaryByRegion"
        }
    }

    public struct CreateNotificationConfigurationRequest: AWSEncodableShape {
        /// The aggregation preference of the NotificationConfiguration.   Values:    LONG    Aggregate notifications for long periods of time (12 hours).      SHORT    Aggregate notifications for short periods of time (5 minutes).      NONE    Don't aggregate notifications.
        public let aggregationDuration: AggregationDuration?
        /// The description of the NotificationConfiguration.
        public let description: String
        /// The name of the NotificationConfiguration. Supports RFC 3986's unreserved characters.
        public let name: String
        /// A map of tags assigned to a resource. A tag is a string-to-string map of key-value pairs.
        public let tags: [String: String]?

        @inlinable
        public init(aggregationDuration: AggregationDuration? = nil, description: String, name: String, tags: [String: String]? = nil) {
            self.aggregationDuration = aggregationDuration
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0001-\\u001F\\u007F-\\u009F]*$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_\\-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationDuration = "aggregationDuration"
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateNotificationConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration.
        public let arn: String
        /// The current status of this NotificationConfiguration.
        public let status: NotificationConfigurationStatus

        @inlinable
        public init(arn: String, status: NotificationConfigurationStatus) {
            self.arn = arn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case status = "status"
        }
    }

    public struct DeleteEventRuleRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the EventRule to delete.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}/rule/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEventRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteNotificationConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration to delete.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNotificationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeregisterNotificationHubRequest: AWSEncodableShape {
        /// The NotificationConfiguration Region.
        public let notificationHubRegion: String

        @inlinable
        public init(notificationHubRegion: String) {
            self.notificationHubRegion = notificationHubRegion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.notificationHubRegion, key: "notificationHubRegion")
        }

        public func validate(name: String) throws {
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, max: 25)
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, min: 2)
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, pattern: "^([a-z]{1,2})-([a-z]{1,15}-)+([0-9])$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeregisterNotificationHubResponse: AWSDecodableShape {
        /// The NotificationConfiguration Region.
        public let notificationHubRegion: String
        ///  NotificationConfiguration status information.
        public let statusSummary: NotificationHubStatusSummary

        @inlinable
        public init(notificationHubRegion: String, statusSummary: NotificationHubStatusSummary) {
            self.notificationHubRegion = notificationHubRegion
            self.statusSummary = statusSummary
        }

        private enum CodingKeys: String, CodingKey {
            case notificationHubRegion = "notificationHubRegion"
            case statusSummary = "statusSummary"
        }
    }

    public struct Dimension: AWSDecodableShape {
        /// The name of the dimension
        public let name: String
        /// The value of the dimension.
        public let value: String

        @inlinable
        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct DisableNotificationsAccessForOrganizationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DisableNotificationsAccessForOrganizationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateChannelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Channel to disassociate.
        public let arn: String
        /// The ARN of the NotificationConfiguration to disassociate.
        public let notificationConfigurationArn: String

        @inlinable
        public init(arn: String, notificationConfigurationArn: String) {
            self.arn = arn
            self.notificationConfigurationArn = notificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encode(self.notificationConfigurationArn, forKey: .notificationConfigurationArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:(chatbot|consoleapp|notifications-contacts):[a-zA-Z0-9-]*:[0-9]{12}:[a-zA-Z0-9-_.@]+/[a-zA-Z0-9/_.@:-]+$")
            try self.validate(self.notificationConfigurationArn, name: "notificationConfigurationArn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: String, CodingKey {
            case notificationConfigurationArn = "notificationConfigurationArn"
        }
    }

    public struct DisassociateChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateManagedNotificationAccountContactRequest: AWSEncodableShape {
        /// The unique value of an Account Contact Type to associate with the ManagedNotificationConfiguration.
        public let contactIdentifier: AccountContactType
        /// The Amazon Resource Name (ARN) of the ManagedNotificationConfiguration to associate with the Account Contact.
        public let managedNotificationConfigurationArn: String

        @inlinable
        public init(contactIdentifier: AccountContactType, managedNotificationConfigurationArn: String) {
            self.contactIdentifier = contactIdentifier
            self.managedNotificationConfigurationArn = managedNotificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactIdentifier, key: "contactIdentifier")
            try container.encode(self.managedNotificationConfigurationArn, forKey: .managedNotificationConfigurationArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.managedNotificationConfigurationArn, name: "managedNotificationConfigurationArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications::[0-9]{12}:managed-notification-configuration/category/[a-zA-Z0-9\\-]{3,64}/sub-category/[a-zA-Z0-9\\-]{3,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case managedNotificationConfigurationArn = "managedNotificationConfigurationArn"
        }
    }

    public struct DisassociateManagedNotificationAccountContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateManagedNotificationAdditionalChannelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Channel to associate with the ManagedNotificationConfiguration.
        public let channelArn: String
        /// The Amazon Resource Name (ARN) of the Managed Notification Configuration to associate with the additional Channel.
        public let managedNotificationConfigurationArn: String

        @inlinable
        public init(channelArn: String, managedNotificationConfigurationArn: String) {
            self.channelArn = channelArn
            self.managedNotificationConfigurationArn = managedNotificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "channelArn")
            try container.encode(self.managedNotificationConfigurationArn, forKey: .managedNotificationConfigurationArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:aws:(chatbot|consoleapp|notifications-contacts):[a-zA-Z0-9-]*:[0-9]{12}:[a-zA-Z0-9-_.@]+/[a-zA-Z0-9/_.@:-]+$")
            try self.validate(self.managedNotificationConfigurationArn, name: "managedNotificationConfigurationArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications::[0-9]{12}:managed-notification-configuration/category/[a-zA-Z0-9\\-]{3,64}/sub-category/[a-zA-Z0-9\\-]{3,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case managedNotificationConfigurationArn = "managedNotificationConfigurationArn"
        }
    }

    public struct DisassociateManagedNotificationAdditionalChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EnableNotificationsAccessForOrganizationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct EnableNotificationsAccessForOrganizationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EventRuleStatusSummary: AWSDecodableShape {
        /// A human-readable reason for EventRuleStatus.
        public let reason: String
        /// The status of the EventRule.   Values:    ACTIVE    The EventRule can process events.      INACTIVE    The EventRule may be unable to process events.      CREATING    The EventRule is being created. Only GET and LIST calls can be run.      UPDATING    The EventRule is being updated. Only GET and LIST calls can be run.      DELETING    The EventRule is being deleted. Only GET and LIST calls can be run.
        public let status: EventRuleStatus

        @inlinable
        public init(reason: String, status: EventRuleStatus) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct EventRuleStructure: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the EventRule. CloudFormation stack generates this ARN and then uses this ARN to associate with the NotificationConfiguration.
        public let arn: String
        /// The creation time of the EventRule.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// An additional event pattern used to further filter the events this EventRule receives. For more information, see Amazon EventBridge event patterns in the Amazon EventBridge User Guide.
        public let eventPattern: String
        /// The event type this rule should match with the EventBridge events. It must match with atleast one of the valid EventBridge event types. For example, Amazon EC2 Instance State change Notification and Amazon CloudWatch State Change. For more information, see Event delivery from Amazon Web Services services in the  Amazon EventBridge User Guide.
        public let eventType: String
        /// A list of Amazon EventBridge Managed Rule ARNs associated with this EventRule.  These are created by User Notifications within your account so your EventRules can function.
        public let managedRules: [String]
        /// The ARN for the NotificationConfiguration associated with this EventRule.
        public let notificationConfigurationArn: String
        /// A list of Amazon Web Services Regions that send events to this EventRule.
        public let regions: [String]
        /// The event source this rule should match with the EventBridge event sources. It must match with atleast one of the valid EventBridge event sources. Only Amazon Web Services service sourced events are supported.  For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from Amazon Web Services services in the  Amazon EventBridge User Guide.
        public let source: String
        /// A list of an EventRule's status by Region. Regions are mapped to EventRuleStatusSummary.
        public let statusSummaryByRegion: [String: EventRuleStatusSummary]

        @inlinable
        public init(arn: String, creationTime: Date, eventPattern: String, eventType: String, managedRules: [String], notificationConfigurationArn: String, regions: [String], source: String, statusSummaryByRegion: [String: EventRuleStatusSummary]) {
            self.arn = arn
            self.creationTime = creationTime
            self.eventPattern = eventPattern
            self.eventType = eventType
            self.managedRules = managedRules
            self.notificationConfigurationArn = notificationConfigurationArn
            self.regions = regions
            self.source = source
            self.statusSummaryByRegion = statusSummaryByRegion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case eventPattern = "eventPattern"
            case eventType = "eventType"
            case managedRules = "managedRules"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case regions = "regions"
            case source = "source"
            case statusSummaryByRegion = "statusSummaryByRegion"
        }
    }

    public struct GetEventRuleRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the EventRule to return.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}/rule/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEventRuleResponse: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String
        /// The date when the EventRule was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// An additional event pattern used to further filter the events this EventRule receives. For more information, see Amazon EventBridge event patterns in the Amazon EventBridge User Guide.
        public let eventPattern: String
        /// The event type to match. Must match one of the valid Amazon EventBridge event types. For example, EC2 Instance State-change Notification and Amazon CloudWatch Alarm State Change. For more information, see Event delivery from Amazon Web Services services in the Amazon EventBridge User Guide.
        public let eventType: String
        /// A list of managed rules from EventBridge that are associated with this EventRule.  These are created by User Notifications within your account so this EventRule functions.
        public let managedRules: [String]
        /// The ARN of a NotificationConfiguration.
        public let notificationConfigurationArn: String
        /// A list of Amazon Web Services Regions that send events to this EventRule.
        public let regions: [String]
        /// The matched event source. Must match one of the valid EventBridge sources. Only Amazon Web Services service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from Amazon Web Services services in the Amazon EventBridge User Guide.
        public let source: String
        /// A list of an EventRule's status by Region. Regions are mapped to EventRuleStatusSummary.
        public let statusSummaryByRegion: [String: EventRuleStatusSummary]

        @inlinable
        public init(arn: String, creationTime: Date, eventPattern: String, eventType: String, managedRules: [String], notificationConfigurationArn: String, regions: [String], source: String, statusSummaryByRegion: [String: EventRuleStatusSummary]) {
            self.arn = arn
            self.creationTime = creationTime
            self.eventPattern = eventPattern
            self.eventType = eventType
            self.managedRules = managedRules
            self.notificationConfigurationArn = notificationConfigurationArn
            self.regions = regions
            self.source = source
            self.statusSummaryByRegion = statusSummaryByRegion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case eventPattern = "eventPattern"
            case eventType = "eventType"
            case managedRules = "managedRules"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case regions = "regions"
            case source = "source"
            case statusSummaryByRegion = "statusSummaryByRegion"
        }
    }

    public struct GetManagedNotificationChildEventRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the ManagedNotificationChildEvent to return.
        public let arn: String
        /// The locale code of the language used for the retrieved ManagedNotificationChildEvent. The default locale is English en_US.
        public let locale: LocaleCode?

        @inlinable
        public init(arn: String, locale: LocaleCode? = nil) {
            self.arn = arn
            self.locale = locale
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            request.encodeQuery(self.locale, key: "locale")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications::[0-9]{12}:managed-notification-configuration/category/[a-zA-Z0-9\\-]{3,64}/sub-category/[a-zA-Z0-9\\-]{3,64}/event/[a-z0-9]{27}/child-event/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedNotificationChildEventResponse: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String
        /// The content of the ManagedNotificationChildEvent.
        public let content: ManagedNotificationChildEvent
        /// The creation time of the ManagedNotificationChildEvent.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The Amazon Resource Name (ARN) of the ManagedNotificationConfiguration associated with the ManagedNotificationChildEvent.
        public let managedNotificationConfigurationArn: String

        @inlinable
        public init(arn: String, content: ManagedNotificationChildEvent, creationTime: Date, managedNotificationConfigurationArn: String) {
            self.arn = arn
            self.content = content
            self.creationTime = creationTime
            self.managedNotificationConfigurationArn = managedNotificationConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case content = "content"
            case creationTime = "creationTime"
            case managedNotificationConfigurationArn = "managedNotificationConfigurationArn"
        }
    }

    public struct GetManagedNotificationConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the ManagedNotificationConfiguration to return.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications::[0-9]{12}:managed-notification-configuration/category/[a-zA-Z0-9\\-]{3,64}/sub-category/[a-zA-Z0-9\\-]{3,64}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedNotificationConfigurationResponse: AWSDecodableShape {
        /// The ARN of the ManagedNotificationConfiguration resource.
        public let arn: String
        /// The category of the ManagedNotificationConfiguration.
        public let category: String
        /// The description of the ManagedNotificationConfiguration.
        public let description: String
        /// The name of the ManagedNotificationConfiguration.
        public let name: String
        /// The subCategory of the ManagedNotificationConfiguration.
        public let subCategory: String

        @inlinable
        public init(arn: String, category: String, description: String, name: String, subCategory: String) {
            self.arn = arn
            self.category = category
            self.description = description
            self.name = name
            self.subCategory = subCategory
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case category = "category"
            case description = "description"
            case name = "name"
            case subCategory = "subCategory"
        }
    }

    public struct GetManagedNotificationEventRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the ManagedNotificationEvent to return.
        public let arn: String
        /// The locale code of the language used for the retrieved ManagedNotificationEvent. The default locale is English (en_US).
        public let locale: LocaleCode?

        @inlinable
        public init(arn: String, locale: LocaleCode? = nil) {
            self.arn = arn
            self.locale = locale
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            request.encodeQuery(self.locale, key: "locale")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications::[0-9]{12}:managed-notification-configuration/category/[a-zA-Z0-9\\-]{3,64}/sub-category/[a-zA-Z0-9\\-]{3,64}/event/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedNotificationEventResponse: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String
        /// The content of the ManagedNotificationEvent.
        public let content: ManagedNotificationEvent
        /// The creation time of the ManagedNotificationEvent.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The ARN of the ManagedNotificationConfiguration.
        public let managedNotificationConfigurationArn: String

        @inlinable
        public init(arn: String, content: ManagedNotificationEvent, creationTime: Date, managedNotificationConfigurationArn: String) {
            self.arn = arn
            self.content = content
            self.creationTime = creationTime
            self.managedNotificationConfigurationArn = managedNotificationConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case content = "content"
            case creationTime = "creationTime"
            case managedNotificationConfigurationArn = "managedNotificationConfigurationArn"
        }
    }

    public struct GetNotificationConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration to return.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNotificationConfigurationResponse: AWSDecodableShape {
        /// The aggregation preference of the NotificationConfiguration.   Values:    LONG    Aggregate notifications for long periods of time (12 hours).      SHORT    Aggregate notifications for short periods of time (5 minutes).      NONE    Don't aggregate notifications.
        public let aggregationDuration: AggregationDuration?
        /// The ARN of the resource.
        public let arn: String
        /// The creation time of the NotificationConfiguration.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of the NotificationConfiguration.
        public let description: String
        /// The name of the NotificationConfiguration.
        public let name: String
        /// The status of this NotificationConfiguration.
        public let status: NotificationConfigurationStatus

        @inlinable
        public init(aggregationDuration: AggregationDuration? = nil, arn: String, creationTime: Date, description: String, name: String, status: NotificationConfigurationStatus) {
            self.aggregationDuration = aggregationDuration
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationDuration = "aggregationDuration"
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetNotificationEventRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the NotificationEvent to return.
        public let arn: String
        /// The locale code of the language used for the retrieved NotificationEvent. The default locale is English en_US.
        public let locale: LocaleCode?

        @inlinable
        public init(arn: String, locale: LocaleCode? = nil) {
            self.arn = arn
            self.locale = locale
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            request.encodeQuery(self.locale, key: "locale")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications:[-.a-z0-9]{1,63}:[0-9]{12}:configuration/[a-z0-9]{27}/event/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNotificationEventResponse: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String
        /// The content of the NotificationEvent.
        public let content: NotificationEventSchema
        /// The creation time of the NotificationEvent.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The ARN of the NotificationConfiguration.
        public let notificationConfigurationArn: String

        @inlinable
        public init(arn: String, content: NotificationEventSchema, creationTime: Date, notificationConfigurationArn: String) {
            self.arn = arn
            self.content = content
            self.creationTime = creationTime
            self.notificationConfigurationArn = notificationConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case content = "content"
            case creationTime = "creationTime"
            case notificationConfigurationArn = "notificationConfigurationArn"
        }
    }

    public struct GetNotificationsAccessForOrganizationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetNotificationsAccessForOrganizationResponse: AWSDecodableShape {
        /// The AccessStatus of Service Trust Enablement for User Notifications to Amazon Web Services Organizations.
        public let notificationsAccessForOrganization: NotificationsAccessForOrganization

        @inlinable
        public init(notificationsAccessForOrganization: NotificationsAccessForOrganization) {
            self.notificationsAccessForOrganization = notificationsAccessForOrganization
        }

        private enum CodingKeys: String, CodingKey {
            case notificationsAccessForOrganization = "notificationsAccessForOrganization"
        }
    }

    public struct ListChannelsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned in this call. The default value is 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListNotificationEvents call. NextToken uses Base64 encoding.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration.
        public let notificationConfigurationArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, notificationConfigurationArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.notificationConfigurationArn = notificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.notificationConfigurationArn, key: "notificationConfigurationArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
            try self.validate(self.notificationConfigurationArn, name: "notificationConfigurationArn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsResponse: AWSDecodableShape {
        /// A list of Channels.
        public let channels: [String]
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(channels: [String], nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventRulesRequest: AWSEncodableShape {
        /// The maximum number of results to be returned in this call. The default value is 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListEventRules call. Next token uses Base64 encoding.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration.
        public let notificationConfigurationArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, notificationConfigurationArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.notificationConfigurationArn = notificationConfigurationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.notificationConfigurationArn, key: "notificationConfigurationArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
            try self.validate(self.notificationConfigurationArn, name: "notificationConfigurationArn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventRulesResponse: AWSDecodableShape {
        /// A list of EventRules.
        public let eventRules: [EventRuleStructure]
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(eventRules: [EventRuleStructure], nextToken: String? = nil) {
            self.eventRules = eventRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventRules = "eventRules"
            case nextToken = "nextToken"
        }
    }

    public struct ListManagedNotificationChannelAssociationsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the ManagedNotificationConfiguration to match.
        public let managedNotificationConfigurationArn: String
        /// The maximum number of results to be returned in this call. Defaults to 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListManagedNotificationChannelAssociations call.
        public let nextToken: String?

        @inlinable
        public init(managedNotificationConfigurationArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.managedNotificationConfigurationArn = managedNotificationConfigurationArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.managedNotificationConfigurationArn, key: "managedNotificationConfigurationArn")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedNotificationConfigurationArn, name: "managedNotificationConfigurationArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications::[0-9]{12}:managed-notification-configuration/category/[a-zA-Z0-9\\-]{3,64}/sub-category/[a-zA-Z0-9\\-]{3,64}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListManagedNotificationChannelAssociationsResponse: AWSDecodableShape {
        /// A list that contains the following information about a channel association.
        public let channelAssociations: [ManagedNotificationChannelAssociationSummary]
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(channelAssociations: [ManagedNotificationChannelAssociationSummary], nextToken: String? = nil) {
            self.channelAssociations = channelAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelAssociations = "channelAssociations"
            case nextToken = "nextToken"
        }
    }

    public struct ListManagedNotificationChildEventsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the ManagedNotificationEvent.
        public let aggregateManagedNotificationEventArn: String
        /// Latest time of events to return from this call.
        public let endTime: Date?
        /// The locale code of the language used for the retrieved NotificationEvent. The default locale is English.en_US.
        public let locale: LocaleCode?
        /// The maximum number of results to be returned in this call. Defaults to 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListManagedNotificationChannelAssociations call. Next token uses Base64 encoding.
        public let nextToken: String?
        /// The identifier of the Amazon Web Services Organizations organizational unit (OU) associated with the Managed Notification Child Events.
        public let organizationalUnitId: String?
        /// The Amazon Web Services account ID associated with the Managed Notification Child Events.
        public let relatedAccount: String?
        /// The earliest time of events to return from this call.
        public let startTime: Date?

        @inlinable
        public init(aggregateManagedNotificationEventArn: String, endTime: Date? = nil, locale: LocaleCode? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationalUnitId: String? = nil, relatedAccount: String? = nil, startTime: Date? = nil) {
            self.aggregateManagedNotificationEventArn = aggregateManagedNotificationEventArn
            self.endTime = endTime
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationalUnitId = organizationalUnitId
            self.relatedAccount = relatedAccount
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aggregateManagedNotificationEventArn, key: "aggregateManagedNotificationEventArn")
            request.encodeQuery(self.endTime, key: "endTime")
            request.encodeQuery(self.locale, key: "locale")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.organizationalUnitId, key: "organizationalUnitId")
            request.encodeQuery(self.relatedAccount, key: "relatedAccount")
            request.encodeQuery(self.startTime, key: "startTime")
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregateManagedNotificationEventArn, name: "aggregateManagedNotificationEventArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications::[0-9]{12}:managed-notification-configuration/category/[a-zA-Z0-9\\-]{3,64}/sub-category/[a-zA-Z0-9\\-]{3,64}/event/[a-z0-9]{27}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
            try self.validate(self.organizationalUnitId, name: "organizationalUnitId", parent: name, pattern: "^Root|ou-[0-9a-z]{4,32}-[a-z0-9]{8,32}$")
            try self.validate(self.relatedAccount, name: "relatedAccount", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListManagedNotificationChildEventsResponse: AWSDecodableShape {
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let managedNotificationChildEvents: [ManagedNotificationChildEventOverview]
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(managedNotificationChildEvents: [ManagedNotificationChildEventOverview], nextToken: String? = nil) {
            self.managedNotificationChildEvents = managedNotificationChildEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case managedNotificationChildEvents = "managedNotificationChildEvents"
            case nextToken = "nextToken"
        }
    }

    public struct ListManagedNotificationConfigurationsRequest: AWSEncodableShape {
        /// The identifier or ARN of the notification channel to filter configurations by.
        public let channelIdentifier: String?
        /// The maximum number of results to be returned in this call. Defaults to 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListManagedNotificationChannelAssociations call. Next token uses Base64 encoding.
        public let nextToken: String?

        @inlinable
        public init(channelIdentifier: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelIdentifier = channelIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.channelIdentifier, key: "channelIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelIdentifier, name: "channelIdentifier", parent: name, pattern: "^ACCOUNT_PRIMARY|ACCOUNT_ALTERNATE_BILLING|ACCOUNT_ALTERNATE_OPERATIONS|ACCOUNT_ALTERNATE_SECURITY|arn:aws:(chatbot|consoleapp|notifications-contacts):[a-zA-Z0-9-]*:[0-9]{12}:[a-zA-Z0-9-_.@]+/[a-zA-Z0-9/_.@:-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListManagedNotificationConfigurationsResponse: AWSDecodableShape {
        /// A list of Managed Notification Configurations matching the request criteria.
        public let managedNotificationConfigurations: [ManagedNotificationConfigurationStructure]
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(managedNotificationConfigurations: [ManagedNotificationConfigurationStructure], nextToken: String? = nil) {
            self.managedNotificationConfigurations = managedNotificationConfigurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case managedNotificationConfigurations = "managedNotificationConfigurations"
            case nextToken = "nextToken"
        }
    }

    public struct ListManagedNotificationEventsRequest: AWSEncodableShape {
        /// Latest time of events to return from this call.
        public let endTime: Date?
        /// The locale code of the language used for the retrieved NotificationEvent. The default locale is English (en_US).
        public let locale: LocaleCode?
        /// The maximum number of results to be returned in this call. Defaults to 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListManagedNotificationChannelAssociations call. Next token uses Base64 encoding.
        public let nextToken: String?
        /// The Organizational Unit Id that an Amazon Web Services account belongs to.
        public let organizationalUnitId: String?
        /// The Amazon Web Services account ID associated with the Managed Notification Events.
        public let relatedAccount: String?
        /// The Amazon Web Services service the event originates from. For example aws.cloudwatch.
        public let source: String?
        /// The earliest time of events to return from this call.
        public let startTime: Date?

        @inlinable
        public init(endTime: Date? = nil, locale: LocaleCode? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationalUnitId: String? = nil, relatedAccount: String? = nil, source: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationalUnitId = organizationalUnitId
            self.relatedAccount = relatedAccount
            self.source = source
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.endTime, key: "endTime")
            request.encodeQuery(self.locale, key: "locale")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.organizationalUnitId, key: "organizationalUnitId")
            request.encodeQuery(self.relatedAccount, key: "relatedAccount")
            request.encodeQuery(self.source, key: "source")
            request.encodeQuery(self.startTime, key: "startTime")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
            try self.validate(self.organizationalUnitId, name: "organizationalUnitId", parent: name, pattern: "^Root|ou-[0-9a-z]{4,32}-[a-z0-9]{8,32}$")
            try self.validate(self.relatedAccount, name: "relatedAccount", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.source, name: "source", parent: name, max: 36)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "^aws.([a-z0-9\\-])+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListManagedNotificationEventsResponse: AWSDecodableShape {
        /// A list of Managed Notification Events matching the request criteria.
        public let managedNotificationEvents: [ManagedNotificationEventOverview]
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(managedNotificationEvents: [ManagedNotificationEventOverview], nextToken: String? = nil) {
            self.managedNotificationEvents = managedNotificationEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case managedNotificationEvents = "managedNotificationEvents"
            case nextToken = "nextToken"
        }
    }

    public struct ListNotificationConfigurationsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Channel to match.
        public let channelArn: String?
        /// The matched event source. Must match one of the valid EventBridge sources. Only Amazon Web Services service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from Amazon Web Services services in the Amazon EventBridge User Guide.
        public let eventRuleSource: String?
        /// The maximum number of results to be returned in this call. Defaults to 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListEventRules call. Next token uses Base64 encoding.
        public let nextToken: String?
        /// The NotificationConfiguration status to match.   Values:    ACTIVE    All EventRules are ACTIVE and any call can be run.      PARTIALLY_ACTIVE    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.   Any call can be run.      INACTIVE    All EventRules are INACTIVE and any call can be run.      DELETING    This NotificationConfiguration is being deleted.   Only GET and LIST calls can be run.
        public let status: NotificationConfigurationStatus?

        @inlinable
        public init(channelArn: String? = nil, eventRuleSource: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, status: NotificationConfigurationStatus? = nil) {
            self.channelArn = channelArn
            self.eventRuleSource = eventRuleSource
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.channelArn, key: "channelArn")
            request.encodeQuery(self.eventRuleSource, key: "eventRuleSource")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:aws:(chatbot|consoleapp|notifications-contacts):[a-zA-Z0-9-]*:[0-9]{12}:[a-zA-Z0-9-_.@]+/[a-zA-Z0-9/_.@:-]+$")
            try self.validate(self.eventRuleSource, name: "eventRuleSource", parent: name, max: 36)
            try self.validate(self.eventRuleSource, name: "eventRuleSource", parent: name, min: 1)
            try self.validate(self.eventRuleSource, name: "eventRuleSource", parent: name, pattern: "^aws.([a-z0-9\\-])+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationConfigurationsResponse: AWSDecodableShape {
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?
        /// The NotificationConfigurations in the account.
        public let notificationConfigurations: [NotificationConfigurationStructure]

        @inlinable
        public init(nextToken: String? = nil, notificationConfigurations: [NotificationConfigurationStructure]) {
            self.nextToken = nextToken
            self.notificationConfigurations = notificationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case notificationConfigurations = "notificationConfigurations"
        }
    }

    public struct ListNotificationEventsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the aggregatedNotificationEventArn to match.
        public let aggregateNotificationEventArn: String?
        /// Latest time of events to return from this call.
        public let endTime: Date?
        /// Include aggregated child events in the result.
        public let includeChildEvents: Bool?
        /// The locale code of the language used for the retrieved NotificationEvent. The default locale is English (en_US).
        public let locale: LocaleCode?
        /// The maximum number of results to be returned in this call. Defaults to 20.
        public let maxResults: Int?
        /// The start token for paginated calls. Retrieved from the response of a previous ListEventRules call. Next token uses Base64 encoding.
        public let nextToken: String?
        /// The matched event source. Must match one of the valid EventBridge sources. Only Amazon Web Services service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from Amazon Web Services services in the Amazon EventBridge User Guide.
        public let source: String?
        /// The earliest time of events to return from this call.
        public let startTime: Date?

        @inlinable
        public init(aggregateNotificationEventArn: String? = nil, endTime: Date? = nil, includeChildEvents: Bool? = nil, locale: LocaleCode? = nil, maxResults: Int? = nil, nextToken: String? = nil, source: String? = nil, startTime: Date? = nil) {
            self.aggregateNotificationEventArn = aggregateNotificationEventArn
            self.endTime = endTime
            self.includeChildEvents = includeChildEvents
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.source = source
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aggregateNotificationEventArn, key: "aggregateNotificationEventArn")
            request.encodeQuery(self.endTime, key: "endTime")
            request.encodeQuery(self.includeChildEvents, key: "includeChildEvents")
            request.encodeQuery(self.locale, key: "locale")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.source, key: "source")
            request.encodeQuery(self.startTime, key: "startTime")
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregateNotificationEventArn, name: "aggregateNotificationEventArn", parent: name, pattern: "^arn:[-.a-z0-9]{1,63}:notifications:[-.a-z0-9]{1,63}:[0-9]{12}:configuration/[a-z0-9]{27}/event/[a-z0-9]{27}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
            try self.validate(self.source, name: "source", parent: name, max: 36)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "^aws.([a-z0-9\\-])+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationEventsResponse: AWSDecodableShape {
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?
        /// The list of notification events.
        public let notificationEvents: [NotificationEventOverview]

        @inlinable
        public init(nextToken: String? = nil, notificationEvents: [NotificationEventOverview]) {
            self.nextToken = nextToken
            self.notificationEvents = notificationEvents
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case notificationEvents = "notificationEvents"
        }
    }

    public struct ListNotificationHubsRequest: AWSEncodableShape {
        /// The maximum number of records to list in a single response.
        public let maxResults: Int?
        /// A pagination token. Set to null to start listing notification hubs from the start.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w+-/=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationHubsResponse: AWSDecodableShape {
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?
        /// The NotificationHubs in the account.
        public let notificationHubs: [NotificationHubOverview]

        @inlinable
        public init(nextToken: String? = nil, notificationHubs: [NotificationHubOverview]) {
            self.nextToken = nextToken
            self.notificationHubs = notificationHubs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case notificationHubs = "notificationHubs"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to list tags.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags for the specified ARN.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ManagedNotificationChannelAssociationSummary: AWSDecodableShape {
        /// The unique identifier for the notification channel.
        public let channelIdentifier: String
        /// The type of notification channel used for message delivery.   Values:    ACCOUNT_CONTACT    Delivers notifications to Account Managed contacts through the User Notification Service.      MOBILE    Delivers notifications through the Amazon Web Services Console Mobile Application to mobile devices.      CHATBOT    Delivers notifications through Chatbot to collaboration platforms (Slack, Chime).      EMAIL    Delivers notifications to email addresses.
        public let channelType: ChannelType
        /// Controls whether users can modify channel associations for a notification configuration.   Values:    ENABLED    Users can associate or disassociate channels with the notification configuration.      DISABLED    Users cannot associate or disassociate channels with the notification configuration.
        public let overrideOption: ChannelAssociationOverrideOption?

        @inlinable
        public init(channelIdentifier: String, channelType: ChannelType, overrideOption: ChannelAssociationOverrideOption? = nil) {
            self.channelIdentifier = channelIdentifier
            self.channelType = channelType
            self.overrideOption = overrideOption
        }

        private enum CodingKeys: String, CodingKey {
            case channelIdentifier = "channelIdentifier"
            case channelType = "channelType"
            case overrideOption = "overrideOption"
        }
    }

    public struct ManagedNotificationChildEvent: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the ManagedNotificationEvent that is associated with this Managed Notification Child Event.
        public let aggregateManagedNotificationEventArn: String
        /// Provides detailed information about the dimensions used for event summarization and aggregation.
        public let aggregationDetail: AggregationDetail?
        /// The end time of the event.
        public let endTime: Date?
        /// The assesed nature of the event.   Values:    HEALTHY    All EventRules are ACTIVE.      UNHEALTHY    Some EventRules are ACTIVE and some are INACTIVE.
        public let eventStatus: EventStatus?
        /// The unique identifier for a Managed Notification Child Event.
        public let id: String
        public let messageComponents: MessageComponents
        /// The type of event causing the notification.   Values:    ALERT    A notification about an event where something was triggered, initiated, reopened, deployed, or a threshold was breached.      WARNING    A notification about an event where an issue is about to arise. For example, something is approaching a threshold.      ANNOUNCEMENT    A notification about an important event. For example, a step in a workflow or escalation path or that a workflow was updated.      INFORMATIONAL    A notification about informational messages. For example, recommendations, service announcements, or reminders.
        public let notificationType: NotificationType
        /// The Organizational Unit Id that an Amazon Web Services account belongs to.
        public let organizationalUnitId: String?
        /// The schema version of the Managed Notification Child Event.
        public let schemaVersion: SchemaVersion
        /// The source event URL.
        public let sourceEventDetailUrl: String?
        /// The detailed URL for the source event.
        public let sourceEventDetailUrlDisplayText: String?
        /// The notification event start time.
        public let startTime: Date?
        /// A list of text values.
        public let textParts: [String: TextPartValue]

        @inlinable
        public init(aggregateManagedNotificationEventArn: String, aggregationDetail: AggregationDetail? = nil, endTime: Date? = nil, eventStatus: EventStatus? = nil, id: String, messageComponents: MessageComponents, notificationType: NotificationType, organizationalUnitId: String? = nil, schemaVersion: SchemaVersion, sourceEventDetailUrl: String? = nil, sourceEventDetailUrlDisplayText: String? = nil, startTime: Date? = nil, textParts: [String: TextPartValue]) {
            self.aggregateManagedNotificationEventArn = aggregateManagedNotificationEventArn
            self.aggregationDetail = aggregationDetail
            self.endTime = endTime
            self.eventStatus = eventStatus
            self.id = id
            self.messageComponents = messageComponents
            self.notificationType = notificationType
            self.organizationalUnitId = organizationalUnitId
            self.schemaVersion = schemaVersion
            self.sourceEventDetailUrl = sourceEventDetailUrl
            self.sourceEventDetailUrlDisplayText = sourceEventDetailUrlDisplayText
            self.startTime = startTime
            self.textParts = textParts
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateManagedNotificationEventArn = "aggregateManagedNotificationEventArn"
            case aggregationDetail = "aggregationDetail"
            case endTime = "endTime"
            case eventStatus = "eventStatus"
            case id = "id"
            case messageComponents = "messageComponents"
            case notificationType = "notificationType"
            case organizationalUnitId = "organizationalUnitId"
            case schemaVersion = "schemaVersion"
            case sourceEventDetailUrl = "sourceEventDetailUrl"
            case sourceEventDetailUrlDisplayText = "sourceEventDetailUrlDisplayText"
            case startTime = "startTime"
            case textParts = "textParts"
        }
    }

    public struct ManagedNotificationChildEventOverview: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the ManagedNotificationEvent that is associated with this ManagedNotificationChildEvent.
        public let aggregateManagedNotificationEventArn: String
        /// The Amazon Resource Name (ARN) of the ManagedNotificationChildEvent.
        public let arn: String
        /// The content of the ManagedNotificationChildEvent.
        public let childEvent: ManagedNotificationChildEventSummary
        /// The creation time of the ManagedNotificationChildEvent.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The Amazon Resource Name (ARN) of the ManagedNotificationConfiguration.
        public let managedNotificationConfigurationArn: String
        /// The Organizational Unit Id that an AWS account belongs to.
        public let organizationalUnitId: String?
        /// The account that related to the ManagedNotificationChildEvent.
        public let relatedAccount: String

        @inlinable
        public init(aggregateManagedNotificationEventArn: String, arn: String, childEvent: ManagedNotificationChildEventSummary, creationTime: Date, managedNotificationConfigurationArn: String, organizationalUnitId: String? = nil, relatedAccount: String) {
            self.aggregateManagedNotificationEventArn = aggregateManagedNotificationEventArn
            self.arn = arn
            self.childEvent = childEvent
            self.creationTime = creationTime
            self.managedNotificationConfigurationArn = managedNotificationConfigurationArn
            self.organizationalUnitId = organizationalUnitId
            self.relatedAccount = relatedAccount
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateManagedNotificationEventArn = "aggregateManagedNotificationEventArn"
            case arn = "arn"
            case childEvent = "childEvent"
            case creationTime = "creationTime"
            case managedNotificationConfigurationArn = "managedNotificationConfigurationArn"
            case organizationalUnitId = "organizationalUnitId"
            case relatedAccount = "relatedAccount"
        }
    }

    public struct ManagedNotificationChildEventSummary: AWSDecodableShape {
        /// Provides detailed information about the dimensions used for event summarization and aggregation.
        public let aggregationDetail: AggregationDetail
        /// The perceived nature of the event.   Values:    HEALTHY    All EventRules are ACTIVE and any call can be run.      UNHEALTHY    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.
        public let eventStatus: EventStatus
        public let messageComponents: MessageComponentsSummary
        /// The Type of the event causing this notification.   Values:    ALERT    A notification about an event where something was triggered, initiated, reopened, deployed, or a threshold was breached.      WARNING    A notification about an event where an issue is about to arise. For example, something is approaching a threshold.      ANNOUNCEMENT    A notification about an important event. For example, a step in a workflow or escalation path or that a workflow was updated.      INFORMATIONAL    A notification about informational messages. For example, recommendations, service announcements, or reminders.
        public let notificationType: NotificationType
        /// The schema version of the ManagedNotificationChildEvent.
        public let schemaVersion: SchemaVersion
        /// Contains all event metadata present identically across all NotificationEvents. All fields are present in Source Events via Eventbridge.
        public let sourceEventMetadata: ManagedSourceEventMetadataSummary

        @inlinable
        public init(aggregationDetail: AggregationDetail, eventStatus: EventStatus, messageComponents: MessageComponentsSummary, notificationType: NotificationType, schemaVersion: SchemaVersion, sourceEventMetadata: ManagedSourceEventMetadataSummary) {
            self.aggregationDetail = aggregationDetail
            self.eventStatus = eventStatus
            self.messageComponents = messageComponents
            self.notificationType = notificationType
            self.schemaVersion = schemaVersion
            self.sourceEventMetadata = sourceEventMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationDetail = "aggregationDetail"
            case eventStatus = "eventStatus"
            case messageComponents = "messageComponents"
            case notificationType = "notificationType"
            case schemaVersion = "schemaVersion"
            case sourceEventMetadata = "sourceEventMetadata"
        }
    }

    public struct ManagedNotificationConfigurationStructure: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the ManagedNotificationConfiguration.
        public let arn: String
        /// The description of the ManagedNotificationConfiguration.
        public let description: String
        /// The name of the ManagedNotificationConfiguration.
        public let name: String

        @inlinable
        public init(arn: String, description: String, name: String) {
            self.arn = arn
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case name = "name"
        }
    }

    public struct ManagedNotificationEvent: AWSDecodableShape {
        /// The notifications aggregation type.
        public let aggregationEventType: AggregationEventType?
        public let aggregationSummary: AggregationSummary?
        /// The end time of the notification event.
        public let endTime: Date?
        /// The status of an event.   Values:    HEALTHY    All EventRules are ACTIVE and any call can be run.      UNHEALTHY    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.
        public let eventStatus: EventStatus?
        /// Unique identifier for a ManagedNotificationEvent.
        public let id: String
        public let messageComponents: MessageComponents
        /// The nature of the event causing this notification.   Values:    ALERT    A notification about an event where something was triggered, initiated, reopened, deployed, or a threshold was breached.      WARNING    A notification about an event where an issue is about to arise. For example, something is approaching a threshold.      ANNOUNCEMENT    A notification about an important event. For example, a step in a workflow or escalation path or that a workflow was updated.      INFORMATIONAL    A notification about informational messages. For example, recommendations, service announcements, or reminders.
        public let notificationType: NotificationType
        /// The Organizational Unit Id that an Amazon Web Services account belongs to.
        public let organizationalUnitId: String?
        /// Version of the ManagedNotificationEvent schema.
        public let schemaVersion: SchemaVersion
        /// URL defined by Source Service to be used by notification consumers to get additional information about event.
        public let sourceEventDetailUrl: String?
        /// Text that needs to be hyperlinked with the sourceEventDetailUrl. For example, the description of the sourceEventDetailUrl.
        public let sourceEventDetailUrlDisplayText: String?
        /// The earliest time of events to return from this call.
        public let startTime: Date?
        /// A list of text values.
        public let textParts: [String: TextPartValue]

        @inlinable
        public init(aggregationEventType: AggregationEventType? = nil, aggregationSummary: AggregationSummary? = nil, endTime: Date? = nil, eventStatus: EventStatus? = nil, id: String, messageComponents: MessageComponents, notificationType: NotificationType, organizationalUnitId: String? = nil, schemaVersion: SchemaVersion, sourceEventDetailUrl: String? = nil, sourceEventDetailUrlDisplayText: String? = nil, startTime: Date? = nil, textParts: [String: TextPartValue]) {
            self.aggregationEventType = aggregationEventType
            self.aggregationSummary = aggregationSummary
            self.endTime = endTime
            self.eventStatus = eventStatus
            self.id = id
            self.messageComponents = messageComponents
            self.notificationType = notificationType
            self.organizationalUnitId = organizationalUnitId
            self.schemaVersion = schemaVersion
            self.sourceEventDetailUrl = sourceEventDetailUrl
            self.sourceEventDetailUrlDisplayText = sourceEventDetailUrlDisplayText
            self.startTime = startTime
            self.textParts = textParts
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationEventType = "aggregationEventType"
            case aggregationSummary = "aggregationSummary"
            case endTime = "endTime"
            case eventStatus = "eventStatus"
            case id = "id"
            case messageComponents = "messageComponents"
            case notificationType = "notificationType"
            case organizationalUnitId = "organizationalUnitId"
            case schemaVersion = "schemaVersion"
            case sourceEventDetailUrl = "sourceEventDetailUrl"
            case sourceEventDetailUrlDisplayText = "sourceEventDetailUrlDisplayText"
            case startTime = "startTime"
            case textParts = "textParts"
        }
    }

    public struct ManagedNotificationEventOverview: AWSDecodableShape {
        /// The list of the regions where the aggregated notifications in this NotificationEvent originated.
        public let aggregatedNotificationRegions: [String]?
        /// The notifications aggregation type.   Values:    AGGREGATE    The notification event is an aggregate notification. Aggregate notifications summarize grouped events over a specified time period.      CHILD    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.      NONE    The notification isn't aggregated.
        public let aggregationEventType: AggregationEventType?
        public let aggregationSummary: AggregationSummary?
        /// The Amazon Resource Name (ARN) of the ManagedNotificationEvent.
        public let arn: String
        /// The creation time of the ManagedNotificationEvent.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The Amazon Resource Name (ARN) of the ManagedNotificationConfiguration.
        public let managedNotificationConfigurationArn: String
        public let notificationEvent: ManagedNotificationEventSummary
        /// The Organizational Unit Id that an Amazon Web Services account belongs to.
        public let organizationalUnitId: String?
        /// The account that related to the ManagedNotificationEvent.
        public let relatedAccount: String

        @inlinable
        public init(aggregatedNotificationRegions: [String]? = nil, aggregationEventType: AggregationEventType? = nil, aggregationSummary: AggregationSummary? = nil, arn: String, creationTime: Date, managedNotificationConfigurationArn: String, notificationEvent: ManagedNotificationEventSummary, organizationalUnitId: String? = nil, relatedAccount: String) {
            self.aggregatedNotificationRegions = aggregatedNotificationRegions
            self.aggregationEventType = aggregationEventType
            self.aggregationSummary = aggregationSummary
            self.arn = arn
            self.creationTime = creationTime
            self.managedNotificationConfigurationArn = managedNotificationConfigurationArn
            self.notificationEvent = notificationEvent
            self.organizationalUnitId = organizationalUnitId
            self.relatedAccount = relatedAccount
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedNotificationRegions = "aggregatedNotificationRegions"
            case aggregationEventType = "aggregationEventType"
            case aggregationSummary = "aggregationSummary"
            case arn = "arn"
            case creationTime = "creationTime"
            case managedNotificationConfigurationArn = "managedNotificationConfigurationArn"
            case notificationEvent = "notificationEvent"
            case organizationalUnitId = "organizationalUnitId"
            case relatedAccount = "relatedAccount"
        }
    }

    public struct ManagedNotificationEventSummary: AWSDecodableShape {
        /// The managed notification event status.   Values:    HEALTHY    All EventRules are ACTIVE.      UNHEALTHY    Some EventRules are ACTIVE and some are INACTIVE.
        public let eventStatus: EventStatus
        public let messageComponents: MessageComponentsSummary
        /// The Type of event causing the notification.   Values:    ALERT    A notification about an event where something was triggered, initiated, reopened, deployed, or a threshold was breached.      WARNING    A notification about an event where an issue is about to arise. For example, something is approaching a threshold.      ANNOUNCEMENT    A notification about an important event. For example, a step in a workflow or escalation path or that a workflow was updated.      INFORMATIONAL    A notification about informational messages. For example, recommendations, service announcements, or reminders.
        public let notificationType: NotificationType
        /// The schema version of the ManagedNotificationEvent.
        public let schemaVersion: SchemaVersion
        /// Contains metadata about the event that caused the ManagedNotificationEvent.
        public let sourceEventMetadata: ManagedSourceEventMetadataSummary

        @inlinable
        public init(eventStatus: EventStatus, messageComponents: MessageComponentsSummary, notificationType: NotificationType, schemaVersion: SchemaVersion, sourceEventMetadata: ManagedSourceEventMetadataSummary) {
            self.eventStatus = eventStatus
            self.messageComponents = messageComponents
            self.notificationType = notificationType
            self.schemaVersion = schemaVersion
            self.sourceEventMetadata = sourceEventMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case eventStatus = "eventStatus"
            case messageComponents = "messageComponents"
            case notificationType = "notificationType"
            case schemaVersion = "schemaVersion"
            case sourceEventMetadata = "sourceEventMetadata"
        }
    }

    public struct ManagedSourceEventMetadataSummary: AWSDecodableShape {
        /// The Region where the notification originated.
        public let eventOriginRegion: String?
        /// The event Type of the notification.
        public let eventType: String
        /// The source service of the notification. Must match one of the valid EventBridge sources. Only Amazon Web Services service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from Amazon Web Services services in the Amazon EventBridge User Guide.
        public let source: String

        @inlinable
        public init(eventOriginRegion: String? = nil, eventType: String, source: String) {
            self.eventOriginRegion = eventOriginRegion
            self.eventType = eventType
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case eventOriginRegion = "eventOriginRegion"
            case eventType = "eventType"
            case source = "source"
        }
    }

    public struct MediaElement: AWSDecodableShape {
        /// The caption of the media.
        public let caption: String
        /// The unique ID for the media.
        public let mediaId: String
        /// The type of media.
        public let type: MediaElementType
        /// The URL of the media.
        public let url: String

        @inlinable
        public init(caption: String, mediaId: String, type: MediaElementType, url: String) {
            self.caption = caption
            self.mediaId = mediaId
            self.type = type
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case caption = "caption"
            case mediaId = "mediaId"
            case type = "type"
            case url = "url"
        }
    }

    public struct MessageComponents: AWSDecodableShape {
        /// A complete summary with all possible relevant information.
        public let completeDescription: String?
        /// A list of properties in key-value pairs. Pairs are shown in order of importance from most important to least important. Channels may limit the number of dimensions shown to the notification viewer.  Included dimensions, keys, and values are subject to change.
        public let dimensions: [Dimension]?
        /// A sentence long summary. For example, titles or an email subject line.
        public let headline: String?
        /// A paragraph long or multiple sentence summary. For example, Chatbot notifications.
        public let paragraphSummary: String?

        @inlinable
        public init(completeDescription: String? = nil, dimensions: [Dimension]? = nil, headline: String? = nil, paragraphSummary: String? = nil) {
            self.completeDescription = completeDescription
            self.dimensions = dimensions
            self.headline = headline
            self.paragraphSummary = paragraphSummary
        }

        private enum CodingKeys: String, CodingKey {
            case completeDescription = "completeDescription"
            case dimensions = "dimensions"
            case headline = "headline"
            case paragraphSummary = "paragraphSummary"
        }
    }

    public struct MessageComponentsSummary: AWSDecodableShape {
        /// A sentence long summary. For example, titles or an email subject line.
        public let headline: String

        @inlinable
        public init(headline: String) {
            self.headline = headline
        }

        private enum CodingKeys: String, CodingKey {
            case headline = "headline"
        }
    }

    public struct NotificationConfigurationStructure: AWSDecodableShape {
        /// The aggregation preference of the NotificationConfiguration.   Values:    LONG    Aggregate notifications for long periods of time (12 hours).      SHORT    Aggregate notifications for short periods of time (5 minutes).      NONE    Don't aggregate notifications.
        public let aggregationDuration: AggregationDuration?
        /// The Amazon Resource Name (ARN) of the NotificationConfiguration resource.
        public let arn: String
        /// The creation time of the NotificationConfiguration.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of the NotificationConfiguration.
        public let description: String
        /// The name of the NotificationConfiguration. Supports RFC 3986's unreserved characters.
        public let name: String
        /// The current status of the NotificationConfiguration.
        public let status: NotificationConfigurationStatus

        @inlinable
        public init(aggregationDuration: AggregationDuration? = nil, arn: String, creationTime: Date, description: String, name: String, status: NotificationConfigurationStatus) {
            self.aggregationDuration = aggregationDuration
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationDuration = "aggregationDuration"
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case name = "name"
            case status = "status"
        }
    }

    public struct NotificationEventOverview: AWSDecodableShape {
        /// The ARN of the aggregatedNotificationEventArn to match.
        public let aggregateNotificationEventArn: String?
        /// The NotificationConfiguration's aggregation type.   Values:    AGGREGATE    The notification event is an aggregate notification. Aggregate notifications summarize grouped events over a specified time period.      CHILD    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.      NONE    The notification isn't aggregated.
        public let aggregationEventType: AggregationEventType?
        /// Provides an aggregated summary data for notification events.
        public let aggregationSummary: AggregationSummary?
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// The creation time of the NotificationEvent.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The ARN of the NotificationConfiguration.
        public let notificationConfigurationArn: String
        /// Refers to a NotificationEventSummary object. Similar in structure to content in the GetNotificationEvent response.
        public let notificationEvent: NotificationEventSummary
        /// The account name containing the NotificationHub.
        public let relatedAccount: String

        @inlinable
        public init(aggregateNotificationEventArn: String? = nil, aggregationEventType: AggregationEventType? = nil, aggregationSummary: AggregationSummary? = nil, arn: String, creationTime: Date, notificationConfigurationArn: String, notificationEvent: NotificationEventSummary, relatedAccount: String) {
            self.aggregateNotificationEventArn = aggregateNotificationEventArn
            self.aggregationEventType = aggregationEventType
            self.aggregationSummary = aggregationSummary
            self.arn = arn
            self.creationTime = creationTime
            self.notificationConfigurationArn = notificationConfigurationArn
            self.notificationEvent = notificationEvent
            self.relatedAccount = relatedAccount
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateNotificationEventArn = "aggregateNotificationEventArn"
            case aggregationEventType = "aggregationEventType"
            case aggregationSummary = "aggregationSummary"
            case arn = "arn"
            case creationTime = "creationTime"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case notificationEvent = "notificationEvent"
            case relatedAccount = "relatedAccount"
        }
    }

    public struct NotificationEventSchema: AWSDecodableShape {
        /// If the value of aggregationEventType is not NONE, this is the Amazon Resource Event (ARN) of the parent aggregate notification. This is omitted if notification isn't aggregated.
        public let aggregateNotificationEventArn: String?
        /// The aggregation type of the NotificationConfiguration.   Values:    AGGREGATE    The notification event is an aggregate notification. Aggregate notifications summarize grouped events over a specified time period.      CHILD    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.      NONE    The notification isn't aggregated.
        public let aggregationEventType: AggregationEventType?
        /// Provides additional information about how multiple notifications are grouped.
        public let aggregationSummary: AggregationSummary?
        /// The end time of the event.
        public let endTime: Date?
        /// The assessed nature of the event.   Values:    HEALTHY    All EventRules are ACTIVE and any call can be run.      UNHEALTHY    Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.
        public let eventStatus: EventStatus?
        /// The unique identifier for a NotificationEvent.
        public let id: String
        /// A list of media elements.
        public let media: [MediaElement]
        public let messageComponents: MessageComponents
        /// The type of event causing the notification.   Values:    ALERT    A notification about an event where something was triggered, initiated, reopened, deployed, or a threshold was breached.      WARNING    A notification about an event where an issue is about to arise. For example, something is approaching a threshold.      ANNOUNCEMENT    A notification about an important event. For example, a step in a workflow or escalation path or that a workflow was updated.      INFORMATIONAL    A notification about informational messages. For example, recommendations, service announcements, or reminders.
        public let notificationType: NotificationType
        /// The schema version of the Notification Event.
        public let schemaVersion: SchemaVersion
        /// The source event URL.
        public let sourceEventDetailUrl: String?
        /// The detailed URL for the source event.
        public let sourceEventDetailUrlDisplayText: String?
        /// The source event metadata.
        public let sourceEventMetadata: SourceEventMetadata
        /// The notification event start time.
        public let startTime: Date?
        /// A list of text values.
        public let textParts: [String: TextPartValue]

        @inlinable
        public init(aggregateNotificationEventArn: String? = nil, aggregationEventType: AggregationEventType? = nil, aggregationSummary: AggregationSummary? = nil, endTime: Date? = nil, eventStatus: EventStatus? = nil, id: String, media: [MediaElement], messageComponents: MessageComponents, notificationType: NotificationType, schemaVersion: SchemaVersion, sourceEventDetailUrl: String? = nil, sourceEventDetailUrlDisplayText: String? = nil, sourceEventMetadata: SourceEventMetadata, startTime: Date? = nil, textParts: [String: TextPartValue]) {
            self.aggregateNotificationEventArn = aggregateNotificationEventArn
            self.aggregationEventType = aggregationEventType
            self.aggregationSummary = aggregationSummary
            self.endTime = endTime
            self.eventStatus = eventStatus
            self.id = id
            self.media = media
            self.messageComponents = messageComponents
            self.notificationType = notificationType
            self.schemaVersion = schemaVersion
            self.sourceEventDetailUrl = sourceEventDetailUrl
            self.sourceEventDetailUrlDisplayText = sourceEventDetailUrlDisplayText
            self.sourceEventMetadata = sourceEventMetadata
            self.startTime = startTime
            self.textParts = textParts
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateNotificationEventArn = "aggregateNotificationEventArn"
            case aggregationEventType = "aggregationEventType"
            case aggregationSummary = "aggregationSummary"
            case endTime = "endTime"
            case eventStatus = "eventStatus"
            case id = "id"
            case media = "media"
            case messageComponents = "messageComponents"
            case notificationType = "notificationType"
            case schemaVersion = "schemaVersion"
            case sourceEventDetailUrl = "sourceEventDetailUrl"
            case sourceEventDetailUrlDisplayText = "sourceEventDetailUrlDisplayText"
            case sourceEventMetadata = "sourceEventMetadata"
            case startTime = "startTime"
            case textParts = "textParts"
        }
    }

    public struct NotificationEventSummary: AWSDecodableShape {
        /// Provides additional information about the current status of the NotificationEvent.   Values:    HEALTHY    All EventRules are ACTIVE.      UNHEALTHY    Some EventRules are ACTIVE and some are INACTIVE.
        public let eventStatus: EventStatus
        /// The message components of a notification event.
        public let messageComponents: MessageComponentsSummary
        /// The type of event causing the notification.   Values:    ALERT    A notification about an event where something was triggered, initiated, reopened, deployed, or a threshold was breached.      WARNING    A notification about an event where an issue is about to arise. For example, something is approaching a threshold.      ANNOUNCEMENT    A notification about an important event. For example, a step in a workflow or escalation path or that a workflow was updated.      INFORMATIONAL    A notification about informational messages. For example, recommendations, service announcements, or reminders.
        public let notificationType: NotificationType
        /// The schema version of the Notification Event.
        public let schemaVersion: SchemaVersion
        /// The source event metadata.
        public let sourceEventMetadata: SourceEventMetadataSummary

        @inlinable
        public init(eventStatus: EventStatus, messageComponents: MessageComponentsSummary, notificationType: NotificationType, schemaVersion: SchemaVersion, sourceEventMetadata: SourceEventMetadataSummary) {
            self.eventStatus = eventStatus
            self.messageComponents = messageComponents
            self.notificationType = notificationType
            self.schemaVersion = schemaVersion
            self.sourceEventMetadata = sourceEventMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case eventStatus = "eventStatus"
            case messageComponents = "messageComponents"
            case notificationType = "notificationType"
            case schemaVersion = "schemaVersion"
            case sourceEventMetadata = "sourceEventMetadata"
        }
    }

    public struct NotificationHubOverview: AWSDecodableShape {
        /// The date and time the NotificationHubOverview was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The most recent time this NotificationHub had an ACTIVE status.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastActivationTime: Date?
        /// The Region of the resource.
        public let notificationHubRegion: String
        /// The status summary of the resource.
        public let statusSummary: NotificationHubStatusSummary

        @inlinable
        public init(creationTime: Date, lastActivationTime: Date? = nil, notificationHubRegion: String, statusSummary: NotificationHubStatusSummary) {
            self.creationTime = creationTime
            self.lastActivationTime = lastActivationTime
            self.notificationHubRegion = notificationHubRegion
            self.statusSummary = statusSummary
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case lastActivationTime = "lastActivationTime"
            case notificationHubRegion = "notificationHubRegion"
            case statusSummary = "statusSummary"
        }
    }

    public struct NotificationHubStatusSummary: AWSDecodableShape {
        /// An explanation for the current status.
        public let reason: String
        /// Status information about the NotificationHub.   Values:    ACTIVE    Incoming NotificationEvents are replicated to this NotificationHub.      REGISTERING    The NotificationConfiguration is initializing. A NotificationConfiguration with this status can't be deregistered.      DEREGISTERING    The NotificationConfiguration is being deleted. You can't register additional NotificationHubs in the same Region as a NotificationConfiguration with this status.
        public let status: NotificationHubStatus

        @inlinable
        public init(reason: String, status: NotificationHubStatus) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct NotificationsAccessForOrganization: AWSDecodableShape {
        /// Access Status for the Orgs Service.
        public let accessStatus: AccessStatus

        @inlinable
        public init(accessStatus: AccessStatus) {
            self.accessStatus = accessStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accessStatus = "accessStatus"
        }
    }

    public struct RegisterNotificationHubRequest: AWSEncodableShape {
        /// The Region of the NotificationHub.
        public let notificationHubRegion: String

        @inlinable
        public init(notificationHubRegion: String) {
            self.notificationHubRegion = notificationHubRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, max: 25)
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, min: 2)
            try self.validate(self.notificationHubRegion, name: "notificationHubRegion", parent: name, pattern: "^([a-z]{1,2})-([a-z]{1,15}-)+([0-9])$")
        }

        private enum CodingKeys: String, CodingKey {
            case notificationHubRegion = "notificationHubRegion"
        }
    }

    public struct RegisterNotificationHubResponse: AWSDecodableShape {
        /// The date the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The date the resource was last activated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastActivationTime: Date?
        /// The Region of the NotificationHub.
        public let notificationHubRegion: String
        /// Provides additional information about the current NotificationConfiguration status information.
        public let statusSummary: NotificationHubStatusSummary

        @inlinable
        public init(creationTime: Date, lastActivationTime: Date? = nil, notificationHubRegion: String, statusSummary: NotificationHubStatusSummary) {
            self.creationTime = creationTime
            self.lastActivationTime = lastActivationTime
            self.notificationHubRegion = notificationHubRegion
            self.statusSummary = statusSummary
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case lastActivationTime = "lastActivationTime"
            case notificationHubRegion = "notificationHubRegion"
            case statusSummary = "statusSummary"
        }
    }

    public struct Resource: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource. At least one id or ARN is required.
        public let arn: String?
        /// The URL to the resource's detail page. If a detail page URL is unavailable, it is the URL to an informational page that describes the resource's type.
        public let detailUrl: String?
        /// The unique identifier for the resource. At least one id or ARN is required.
        public let id: String?
        /// A map of tags assigned to a resource. A tag is a string-to-string map of key-value pairs.
        public let tags: [String]?

        @inlinable
        public init(arn: String? = nil, detailUrl: String? = nil, id: String? = nil, tags: [String]? = nil) {
            self.arn = arn
            self.detailUrl = detailUrl
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case detailUrl = "detailUrl"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The ID of the resource that wasn't found.
        public let resourceId: String

        @inlinable
        public init(message: String, resourceId: String) {
            self.message = message
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The code for the service quota in Service Quotas.
        public let quotaCode: String?
        /// The ID of the resource that exceeds the service quota.
        public let resourceId: String?
        /// The type of the resource that exceeds the service quota.
        public let resourceType: String
        /// The code for the service quota exceeded in Service Quotas.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, resourceId: String? = nil, resourceType: String, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct SourceEventMetadata: AWSDecodableShape {
        /// The date and time the source event occurred. This is based on the Source Event.
        public let eventOccurrenceTime: Date
        /// The Region the event originated from.
        public let eventOriginRegion: String?
        /// The type of event. For example, an Amazon CloudWatch state change.
        public let eventType: String
        /// The version of the type of event.
        public let eventTypeVersion: String
        /// The primary Amazon Web Services account of SourceEvent.
        public let relatedAccount: String
        /// A list of resources related to this NotificationEvent.
        public let relatedResources: [Resource]
        /// The Amazon Web Services service the event originates from. For example aws.cloudwatch.
        public let source: String
        /// The source event id.
        public let sourceEventId: String

        @inlinable
        public init(eventOccurrenceTime: Date, eventOriginRegion: String? = nil, eventType: String, eventTypeVersion: String, relatedAccount: String, relatedResources: [Resource], source: String, sourceEventId: String) {
            self.eventOccurrenceTime = eventOccurrenceTime
            self.eventOriginRegion = eventOriginRegion
            self.eventType = eventType
            self.eventTypeVersion = eventTypeVersion
            self.relatedAccount = relatedAccount
            self.relatedResources = relatedResources
            self.source = source
            self.sourceEventId = sourceEventId
        }

        private enum CodingKeys: String, CodingKey {
            case eventOccurrenceTime = "eventOccurrenceTime"
            case eventOriginRegion = "eventOriginRegion"
            case eventType = "eventType"
            case eventTypeVersion = "eventTypeVersion"
            case relatedAccount = "relatedAccount"
            case relatedResources = "relatedResources"
            case source = "source"
            case sourceEventId = "sourceEventId"
        }
    }

    public struct SourceEventMetadataSummary: AWSDecodableShape {
        /// The Region where the notification originated. Unavailable for aggregated notifications.
        public let eventOriginRegion: String?
        /// The event type to match. Must match one of the valid Amazon EventBridge event types. For example, EC2 Instance State-change Notification and Amazon CloudWatch Alarm State Change. For more information, see Event delivery from Amazon Web Services services in the Amazon EventBridge User Guide.
        public let eventType: String
        /// The matched event source. Must match one of the valid EventBridge sources. Only Amazon Web Services service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see Event delivery from Amazon Web Services services in the Amazon EventBridge User Guide.
        public let source: String

        @inlinable
        public init(eventOriginRegion: String? = nil, eventType: String, source: String) {
            self.eventOriginRegion = eventOriginRegion
            self.eventType = eventType
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case eventOriginRegion = "eventOriginRegion"
            case eventType = "eventType"
            case source = "source"
        }
    }

    public struct SummarizationDimensionDetail: AWSDecodableShape {
        /// The name of the SummarizationDimensionDetail.
        public let name: String
        /// Value of the property used to summarize aggregated events.
        public let value: String

        @inlinable
        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct SummarizationDimensionOverview: AWSDecodableShape {
        /// Total number of occurrences for this dimension.
        public let count: Int
        /// Name of the summarization dimension.
        public let name: String
        /// Indicates the sample values found within the dimension.
        public let sampleValues: [String]?

        @inlinable
        public init(count: Int, name: String, sampleValues: [String]? = nil) {
            self.count = count
            self.name = name
            self.sampleValues = sampleValues
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case name = "name"
            case sampleValues = "sampleValues"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to tag a resource.
        public let arn: String
        /// A map of tags assigned to a resource. A tag is a string-to-string map of key-value pairs.
        public let tags: [String: String]

        @inlinable
        public init(arn: String, tags: [String: String]) {
            self.arn = arn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TextPartValue: AWSDecodableShape {
        /// A short single line description of the link. Must be hyper-linked with the URL itself.  Used for text parts with the type URL.
        public let displayText: String?
        /// A map of locales to the text in that locale.
        public let textByLocale: [LocaleCode: String]?
        /// The type of text part. Determines the usage of all other fields and whether or not they're required.
        public let type: TextPartType
        /// The URL itself.
        public let url: String?

        @inlinable
        public init(displayText: String? = nil, textByLocale: [LocaleCode: String]? = nil, type: TextPartType, url: String? = nil) {
            self.displayText = displayText
            self.textByLocale = textByLocale
            self.type = type
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case displayText = "displayText"
            case textByLocale = "textByLocale"
            case type = "type"
            case url = "url"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// Identifies the quota that is being throttled.
        public let quotaCode: String?
        /// The number of seconds a client should wait before retrying the request.
        public let retryAfterSeconds: Int?
        /// Identifies the service being throttled.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to untag a resource.
        public let arn: String
        /// The tag keys to use to untag a resource.
        public let tagKeys: [String]

        @inlinable
        public init(arn: String, tagKeys: [String]) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:).{1,128}$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEventRuleRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to update the EventRule.
        public let arn: String
        /// An additional event pattern used to further filter the events this EventRule receives. For more information, see Amazon EventBridge event patterns in the Amazon EventBridge User Guide.
        public let eventPattern: String?
        /// A list of Amazon Web Services Regions that sends events to this EventRule.
        public let regions: [String]?

        @inlinable
        public init(arn: String, eventPattern: String? = nil, regions: [String]? = nil) {
            self.arn = arn
            self.eventPattern = eventPattern
            self.regions = regions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encodeIfPresent(self.eventPattern, forKey: .eventPattern)
            try container.encodeIfPresent(self.regions, forKey: .regions)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}/rule/[a-z0-9]{27}$")
            try self.validate(self.eventPattern, name: "eventPattern", parent: name, max: 4096)
            try self.regions?.forEach {
                try validate($0, name: "regions[]", parent: name, max: 25)
                try validate($0, name: "regions[]", parent: name, min: 2)
                try validate($0, name: "regions[]", parent: name, pattern: "^([a-z]{1,2})-([a-z]{1,15}-)+([0-9])$")
            }
            try self.validate(self.regions, name: "regions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eventPattern = "eventPattern"
            case regions = "regions"
        }
    }

    public struct UpdateEventRuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) to use to update the EventRule.
        public let arn: String
        /// The ARN of the NotificationConfiguration.
        public let notificationConfigurationArn: String
        /// The status of the action by Region.
        public let statusSummaryByRegion: [String: EventRuleStatusSummary]

        @inlinable
        public init(arn: String, notificationConfigurationArn: String, statusSummaryByRegion: [String: EventRuleStatusSummary]) {
            self.arn = arn
            self.notificationConfigurationArn = notificationConfigurationArn
            self.statusSummaryByRegion = statusSummaryByRegion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case notificationConfigurationArn = "notificationConfigurationArn"
            case statusSummaryByRegion = "statusSummaryByRegion"
        }
    }

    public struct UpdateNotificationConfigurationRequest: AWSEncodableShape {
        /// The aggregation preference of the NotificationConfiguration.   Values:    LONG    Aggregate notifications for long periods of time (12 hours).      SHORT    Aggregate notifications for short periods of time (5 minutes).      NONE    Don't aggregate notifications.
        public let aggregationDuration: AggregationDuration?
        /// The Amazon Resource Name (ARN) used to update the NotificationConfiguration.
        public let arn: String
        /// The description of the NotificationConfiguration.
        public let description: String?
        /// The name of the NotificationConfiguration.
        public let name: String?

        @inlinable
        public init(aggregationDuration: AggregationDuration? = nil, arn: String, description: String? = nil, name: String? = nil) {
            self.aggregationDuration = aggregationDuration
            self.arn = arn
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.aggregationDuration, forKey: .aggregationDuration)
            request.encodePath(self.arn, key: "arn")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:notifications::[0-9]{12}:configuration/[a-z0-9]{27}$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0001-\\u001F\\u007F-\\u009F]*$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationDuration = "aggregationDuration"
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateNotificationConfigurationResponse: AWSDecodableShape {
        /// The ARN used to update the NotificationConfiguration.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The list of input fields that are invalid.
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        /// The reason why your input is considered invalid.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason? = nil) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message with the reason for the validation exception error.
        public let message: String
        /// The field name where the invalid entry was detected.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }
}

// MARK: - Errors

/// Error enum for Notifications
public struct NotificationsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Notifications
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Unexpected error during processing of request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This exception is thrown when the notification event fails validation.
    public static var validationException: Self { .init(.validationException) }
}

extension NotificationsErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": Notifications.ConflictException.self,
        "ResourceNotFoundException": Notifications.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": Notifications.ServiceQuotaExceededException.self,
        "ThrottlingException": Notifications.ThrottlingException.self,
        "ValidationException": Notifications.ValidationException.self
    ]
}

extension NotificationsErrorType: Equatable {
    public static func == (lhs: NotificationsErrorType, rhs: NotificationsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension NotificationsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
