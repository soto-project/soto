//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MediaPackage {
    // MARK: Enums

    public enum AdMarkers: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case daterange = "DATERANGE"
        case none = "NONE"
        case passthrough = "PASSTHROUGH"
        case scte35Enhanced = "SCTE35_ENHANCED"
        public var description: String { return self.rawValue }
    }

    public enum AdTriggersElement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `break` = "BREAK"
        case distributorAdvertisement = "DISTRIBUTOR_ADVERTISEMENT"
        case distributorOverlayPlacementOpportunity = "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
        case distributorPlacementOpportunity = "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
        case providerAdvertisement = "PROVIDER_ADVERTISEMENT"
        case providerOverlayPlacementOpportunity = "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
        case providerPlacementOpportunity = "PROVIDER_PLACEMENT_OPPORTUNITY"
        case spliceInsert = "SPLICE_INSERT"
        public var description: String { return self.rawValue }
    }

    public enum AdsOnDeliveryRestrictions: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case both = "BOTH"
        case none = "NONE"
        case restricted = "RESTRICTED"
        case unrestricted = "UNRESTRICTED"
        public var description: String { return self.rawValue }
    }

    public enum CmafEncryptionMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aesCtr = "AES_CTR"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aes128 = "AES_128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public enum ManifestLayout: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case compact = "COMPACT"
        case drmTopLevelCompact = "DRM_TOP_LEVEL_COMPACT"
        case full = "FULL"
        public var description: String { return self.rawValue }
    }

    public enum Origination: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum PeriodTriggersElement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ads = "ADS"
        public var description: String { return self.rawValue }
    }

    public enum PlaylistType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case event = "EVENT"
        case none = "NONE"
        case vod = "VOD"
        public var description: String { return self.rawValue }
    }

    public enum PresetSpeke20Audio: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case presetAudio1 = "PRESET-AUDIO-1"
        case presetAudio2 = "PRESET-AUDIO-2"
        case presetAudio3 = "PRESET-AUDIO-3"
        case shared = "SHARED"
        case unencrypted = "UNENCRYPTED"
        public var description: String { return self.rawValue }
    }

    public enum PresetSpeke20Video: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case presetVideo1 = "PRESET-VIDEO-1"
        case presetVideo2 = "PRESET-VIDEO-2"
        case presetVideo3 = "PRESET-VIDEO-3"
        case presetVideo4 = "PRESET-VIDEO-4"
        case presetVideo5 = "PRESET-VIDEO-5"
        case presetVideo6 = "PRESET-VIDEO-6"
        case presetVideo7 = "PRESET-VIDEO-7"
        case presetVideo8 = "PRESET-VIDEO-8"
        case shared = "SHARED"
        case unencrypted = "UNENCRYPTED"
        public var description: String { return self.rawValue }
    }

    public enum Profile: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dvbDash2014 = "DVB_DASH_2014"
        case hbbtv15 = "HBBTV_1_5"
        case hybridcast = "HYBRIDCAST"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum SegmentTemplateFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case numberWithDuration = "NUMBER_WITH_DURATION"
        case numberWithTimeline = "NUMBER_WITH_TIMELINE"
        case timeWithTimeline = "TIME_WITH_TIMELINE"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum StreamOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case original = "ORIGINAL"
        case videoBitrateAscending = "VIDEO_BITRATE_ASCENDING"
        case videoBitrateDescending = "VIDEO_BITRATE_DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum UtcTiming: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case httpHead = "HTTP-HEAD"
        case httpIso = "HTTP-ISO"
        case httpXsdate = "HTTP-XSDATE"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Authorization: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the secret in Secrets Manager that your Content Distribution Network (CDN) uses for authorization to access your endpoint.
        public let cdnIdentifierSecret: String?
        /// The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
        public let secretsRoleArn: String?

        public init(cdnIdentifierSecret: String? = nil, secretsRoleArn: String? = nil) {
            self.cdnIdentifierSecret = cdnIdentifierSecret
            self.secretsRoleArn = secretsRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case cdnIdentifierSecret = "cdnIdentifierSecret"
            case secretsRoleArn = "secretsRoleArn"
        }
    }

    public struct Channel: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// The date and time the Channel was created.
        public let createdAt: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case egressAccessLogs = "egressAccessLogs"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case ingressAccessLogs = "ingressAccessLogs"
            case tags = "tags"
        }
    }

    public struct CmafEncryption: AWSEncodableShape & AWSDecodableShape {
        /// An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public let constantInitializationVector: String?
        public let encryptionMethod: CmafEncryptionMethod?
        /// Time (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int?
        public let spekeKeyProvider: SpekeKeyProvider?

        public init(constantInitializationVector: String? = nil, encryptionMethod: CmafEncryptionMethod? = nil, keyRotationIntervalSeconds: Int? = nil, spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector = "constantInitializationVector"
            case encryptionMethod = "encryptionMethod"
            case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct CmafPackage: AWSDecodableShape {
        public let encryption: CmafEncryption?
        /// A list of HLS manifest configurations
        public let hlsManifests: [HlsManifest]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public let segmentPrefix: String?
        public let streamSelection: StreamSelection?

        public init(encryption: CmafEncryption? = nil, hlsManifests: [HlsManifest]? = nil, segmentDurationSeconds: Int? = nil, segmentPrefix: String? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case hlsManifests = "hlsManifests"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case segmentPrefix = "segmentPrefix"
            case streamSelection = "streamSelection"
        }
    }

    public struct CmafPackageCreateOrUpdateParameters: AWSEncodableShape {
        public let encryption: CmafEncryption?
        /// A list of HLS manifest configurations
        public let hlsManifests: [HlsManifestCreateOrUpdateParameters]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public let segmentPrefix: String?
        public let streamSelection: StreamSelection?

        public init(encryption: CmafEncryption? = nil, hlsManifests: [HlsManifestCreateOrUpdateParameters]? = nil, segmentDurationSeconds: Int? = nil, segmentPrefix: String? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case hlsManifests = "hlsManifests"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case segmentPrefix = "segmentPrefix"
            case streamSelection = "streamSelection"
        }
    }

    public struct ConfigureLogsRequest: AWSEncodableShape {
        public let egressAccessLogs: EgressAccessLogs?
        /// The ID of the channel to log subscription.
        public let id: String
        public let ingressAccessLogs: IngressAccessLogs?

        public init(egressAccessLogs: EgressAccessLogs? = nil, id: String, ingressAccessLogs: IngressAccessLogs? = nil) {
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.egressAccessLogs, forKey: .egressAccessLogs)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.ingressAccessLogs, forKey: .ingressAccessLogs)
        }

        private enum CodingKeys: String, CodingKey {
            case egressAccessLogs = "egressAccessLogs"
            case ingressAccessLogs = "ingressAccessLogs"
        }
    }

    public struct ConfigureLogsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// The date and time the Channel was created.
        public let createdAt: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case egressAccessLogs = "egressAccessLogs"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case ingressAccessLogs = "ingressAccessLogs"
            case tags = "tags"
        }
    }

    public struct CreateChannelRequest: AWSEncodableShape {
        /// A short text description of the Channel.
        public let description: String?
        /// The ID of the Channel. The ID must be unique within the region and it
        /// cannot be changed after a Channel is created.
        public let id: String?
        public let tags: [String: String]?

        public init(description: String? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct CreateChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// The date and time the Channel was created.
        public let createdAt: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case egressAccessLogs = "egressAccessLogs"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case ingressAccessLogs = "ingressAccessLogs"
            case tags = "tags"
        }
    }

    public struct CreateHarvestJobRequest: AWSEncodableShape {
        /// The end of the time-window which will be harvested
        public let endTime: String?
        /// The ID of the HarvestJob. The ID must be unique within the region
        /// and it cannot be changed after the HarvestJob is submitted
        public let id: String?
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
        /// This cannot be changed after the HarvestJob is submitted.
        public let originEndpointId: String?
        public let s3Destination: S3Destination?
        /// The start of the time-window which will be harvested
        public let startTime: String?

        public init(endTime: String? = nil, id: String? = nil, originEndpointId: String? = nil, s3Destination: S3Destination? = nil, startTime: String? = nil) {
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case id = "id"
            case originEndpointId = "originEndpointId"
            case s3Destination = "s3Destination"
            case startTime = "startTime"
        }
    }

    public struct CreateHarvestJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
        public let arn: String?
        /// The ID of the Channel that the HarvestJob will harvest from.
        public let channelId: String?
        /// The date and time the HarvestJob was submitted.
        public let createdAt: String?
        /// The end of the time-window which will be harvested.
        public let endTime: String?
        /// The ID of the HarvestJob. The ID must be unique within the region
        /// and it cannot be changed after the HarvestJob is submitted.
        public let id: String?
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
        /// This cannot be changed after the HarvestJob is submitted.
        public let originEndpointId: String?
        public let s3Destination: S3Destination?
        /// The start of the time-window which will be harvested.
        public let startTime: String?
        /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
        /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
        /// include an explanation of why the HarvestJob failed.
        public let status: Status?

        public init(arn: String? = nil, channelId: String? = nil, createdAt: String? = nil, endTime: String? = nil, id: String? = nil, originEndpointId: String? = nil, s3Destination: S3Destination? = nil, startTime: String? = nil, status: Status? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelId = "channelId"
            case createdAt = "createdAt"
            case endTime = "endTime"
            case id = "id"
            case originEndpointId = "originEndpointId"
            case s3Destination = "s3Destination"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct CreateOriginEndpointRequest: AWSEncodableShape {
        public let authorization: Authorization?
        /// The ID of the Channel that the OriginEndpoint will be associated with.
        /// This cannot be changed after the OriginEndpoint is created.
        public let channelId: String?
        public let cmafPackage: CmafPackageCreateOrUpdateParameters?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.  The ID must be unique within the region
        /// and it cannot be changed after the OriginEndpoint is created.
        public let id: String?
        /// A short string that will be used as the filename of the OriginEndpoint URL (defaults to "index").
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackageCreateOrUpdateParameters? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, whitelist: [String]? = nil) {
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case authorization = "authorization"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case whitelist = "whitelist"
        }
    }

    public struct CreateOriginEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public let arn: String?
        public let authorization: Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        /// The date and time the OriginEndpoint was created.
        public let createdAt: String?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.
        public let id: String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, createdAt: String? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.createdAt = createdAt
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorization = "authorization"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case createdAt = "createdAt"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }

    public struct DashEncryption: AWSEncodableShape & AWSDecodableShape {
        /// Time (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int?
        public let spekeKeyProvider: SpekeKeyProvider?

        public init(keyRotationIntervalSeconds: Int? = nil, spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct DashPackage: AWSEncodableShape & AWSDecodableShape {
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let adTriggers: [AdTriggersElement]?
        public let encryption: DashEncryption?
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level. When set to DRM_TOP_LEVEL_COMPACT, content protection elements are placed the MPD level and referenced at the AdaptationSet level.
        public let manifestLayout: ManifestLayout?
        /// Time window (in seconds) contained in each manifest.
        public let manifestWindowSeconds: Int?
        /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
        public let minBufferTimeSeconds: Int?
        /// Minimum duration (in seconds) between potential changes to the Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD).
        public let minUpdatePeriodSeconds: Int?
        /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH)
        /// Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not
        /// be partitioned into more than one period. If the list contains "ADS", new periods will be created where
        /// the Channel source contains SCTE-35 ad markers.
        public let periodTriggers: [PeriodTriggersElement]?
        /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled. When set to "DVB-DASH_2014", DVB-DASH 2014 compliant output is enabled.
        public let profile: Profile?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?
        /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
        public let segmentTemplateFormat: SegmentTemplateFormat?
        public let streamSelection: StreamSelection?
        /// Duration (in seconds) to delay live content before presentation.
        public let suggestedPresentationDelaySeconds: Int?
        /// Determines the type of UTCTiming included in the Media Presentation Description (MPD)
        public let utcTiming: UtcTiming?
        /// Specifies the value attribute of the UTCTiming field when utcTiming is set to HTTP-ISO, HTTP-HEAD or HTTP-XSDATE
        public let utcTimingUri: String?

        public init(adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, adTriggers: [AdTriggersElement]? = nil, encryption: DashEncryption? = nil, includeIframeOnlyStream: Bool? = nil, manifestLayout: ManifestLayout? = nil, manifestWindowSeconds: Int? = nil, minBufferTimeSeconds: Int? = nil, minUpdatePeriodSeconds: Int? = nil, periodTriggers: [PeriodTriggersElement]? = nil, profile: Profile? = nil, segmentDurationSeconds: Int? = nil, segmentTemplateFormat: SegmentTemplateFormat? = nil, streamSelection: StreamSelection? = nil, suggestedPresentationDelaySeconds: Int? = nil, utcTiming: UtcTiming? = nil, utcTimingUri: String? = nil) {
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.adTriggers = adTriggers
            self.encryption = encryption
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestLayout = manifestLayout
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.periodTriggers = periodTriggers
            self.profile = profile
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentTemplateFormat = segmentTemplateFormat
            self.streamSelection = streamSelection
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
            self.utcTiming = utcTiming
            self.utcTimingUri = utcTimingUri
        }

        private enum CodingKeys: String, CodingKey {
            case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
            case adTriggers = "adTriggers"
            case encryption = "encryption"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case manifestLayout = "manifestLayout"
            case manifestWindowSeconds = "manifestWindowSeconds"
            case minBufferTimeSeconds = "minBufferTimeSeconds"
            case minUpdatePeriodSeconds = "minUpdatePeriodSeconds"
            case periodTriggers = "periodTriggers"
            case profile = "profile"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case segmentTemplateFormat = "segmentTemplateFormat"
            case streamSelection = "streamSelection"
            case suggestedPresentationDelaySeconds = "suggestedPresentationDelaySeconds"
            case utcTiming = "utcTiming"
            case utcTimingUri = "utcTimingUri"
        }
    }

    public struct DeleteChannelRequest: AWSEncodableShape {
        /// The ID of the Channel to delete.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOriginEndpointRequest: AWSEncodableShape {
        /// The ID of the OriginEndpoint to delete.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOriginEndpointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeChannelRequest: AWSEncodableShape {
        /// The ID of a Channel.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// The date and time the Channel was created.
        public let createdAt: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case egressAccessLogs = "egressAccessLogs"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case ingressAccessLogs = "ingressAccessLogs"
            case tags = "tags"
        }
    }

    public struct DescribeHarvestJobRequest: AWSEncodableShape {
        /// The ID of the HarvestJob.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeHarvestJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
        public let arn: String?
        /// The ID of the Channel that the HarvestJob will harvest from.
        public let channelId: String?
        /// The date and time the HarvestJob was submitted.
        public let createdAt: String?
        /// The end of the time-window which will be harvested.
        public let endTime: String?
        /// The ID of the HarvestJob. The ID must be unique within the region
        /// and it cannot be changed after the HarvestJob is submitted.
        public let id: String?
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
        /// This cannot be changed after the HarvestJob is submitted.
        public let originEndpointId: String?
        public let s3Destination: S3Destination?
        /// The start of the time-window which will be harvested.
        public let startTime: String?
        /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
        /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
        /// include an explanation of why the HarvestJob failed.
        public let status: Status?

        public init(arn: String? = nil, channelId: String? = nil, createdAt: String? = nil, endTime: String? = nil, id: String? = nil, originEndpointId: String? = nil, s3Destination: S3Destination? = nil, startTime: String? = nil, status: Status? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelId = "channelId"
            case createdAt = "createdAt"
            case endTime = "endTime"
            case id = "id"
            case originEndpointId = "originEndpointId"
            case s3Destination = "s3Destination"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct DescribeOriginEndpointRequest: AWSEncodableShape {
        /// The ID of the OriginEndpoint.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeOriginEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public let arn: String?
        public let authorization: Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        /// The date and time the OriginEndpoint was created.
        public let createdAt: String?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.
        public let id: String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, createdAt: String? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.createdAt = createdAt
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorization = "authorization"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case createdAt = "createdAt"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }

    public struct EgressAccessLogs: AWSEncodableShape & AWSDecodableShape {
        /// Customize the log group name.
        public let logGroupName: String?

        public init(logGroupName: String? = nil) {
            self.logGroupName = logGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName = "logGroupName"
        }
    }

    public struct EncryptionContractConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A collection of audio encryption presets.
        public let presetSpeke20Audio: PresetSpeke20Audio?
        /// A collection of video encryption presets.
        public let presetSpeke20Video: PresetSpeke20Video?

        public init(presetSpeke20Audio: PresetSpeke20Audio? = nil, presetSpeke20Video: PresetSpeke20Video? = nil) {
            self.presetSpeke20Audio = presetSpeke20Audio
            self.presetSpeke20Video = presetSpeke20Video
        }

        private enum CodingKeys: String, CodingKey {
            case presetSpeke20Audio = "presetSpeke20Audio"
            case presetSpeke20Video = "presetSpeke20Video"
        }
    }

    public struct HarvestJob: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
        public let arn: String?
        /// The ID of the Channel that the HarvestJob will harvest from.
        public let channelId: String?
        /// The date and time the HarvestJob was submitted.
        public let createdAt: String?
        /// The end of the time-window which will be harvested.
        public let endTime: String?
        /// The ID of the HarvestJob. The ID must be unique within the region
        /// and it cannot be changed after the HarvestJob is submitted.
        public let id: String?
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
        /// This cannot be changed after the HarvestJob is submitted.
        public let originEndpointId: String?
        public let s3Destination: S3Destination?
        /// The start of the time-window which will be harvested.
        public let startTime: String?
        /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
        /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
        /// include an explanation of why the HarvestJob failed.
        public let status: Status?

        public init(arn: String? = nil, channelId: String? = nil, createdAt: String? = nil, endTime: String? = nil, id: String? = nil, originEndpointId: String? = nil, s3Destination: S3Destination? = nil, startTime: String? = nil, status: Status? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelId = "channelId"
            case createdAt = "createdAt"
            case endTime = "endTime"
            case id = "id"
            case originEndpointId = "originEndpointId"
            case s3Destination = "s3Destination"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct HlsEncryption: AWSEncodableShape & AWSDecodableShape {
        /// A constant initialization vector for encryption (optional).
        /// When not specified the initialization vector will be periodically rotated.
        public let constantInitializationVector: String?
        /// The encryption method to use.
        public let encryptionMethod: EncryptionMethod?
        /// Interval (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int?
        /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
        public let repeatExtXKey: Bool?
        public let spekeKeyProvider: SpekeKeyProvider?

        public init(constantInitializationVector: String? = nil, encryptionMethod: EncryptionMethod? = nil, keyRotationIntervalSeconds: Int? = nil, repeatExtXKey: Bool? = nil, spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.repeatExtXKey = repeatExtXKey
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector = "constantInitializationVector"
            case encryptionMethod = "encryptionMethod"
            case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
            case repeatExtXKey = "repeatExtXKey"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct HlsIngest: AWSDecodableShape {
        /// A list of endpoints to which the source stream should be sent.
        public let ingestEndpoints: [IngestEndpoint]?

        public init(ingestEndpoints: [IngestEndpoint]? = nil) {
            self.ingestEndpoints = ingestEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case ingestEndpoints = "ingestEndpoints"
        }
    }

    public struct HlsManifest: AWSDecodableShape {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
        /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
        /// that is greater than 0.
        public let adMarkers: AdMarkers?
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let adTriggers: [AdTriggersElement]?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        public let id: String?
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public let manifestName: String?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?

        public init(adMarkers: AdMarkers? = nil, adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, adTriggers: [AdTriggersElement]? = nil, id: String? = nil, includeIframeOnlyStream: Bool? = nil, manifestName: String? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, url: String? = nil) {
            self.adMarkers = adMarkers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.adTriggers = adTriggers
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers = "adMarkers"
            case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
            case adTriggers = "adTriggers"
            case id = "id"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case manifestName = "manifestName"
            case playlistType = "playlistType"
            case playlistWindowSeconds = "playlistWindowSeconds"
            case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
            case url = "url"
        }
    }

    public struct HlsManifestCreateOrUpdateParameters: AWSEncodableShape {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
        /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
        /// that is greater than 0.
        public let adMarkers: AdMarkers?
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let adTriggers: [AdTriggersElement]?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        public let id: String?
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public let manifestName: String?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?

        public init(adMarkers: AdMarkers? = nil, adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, adTriggers: [AdTriggersElement]? = nil, id: String? = nil, includeIframeOnlyStream: Bool? = nil, manifestName: String? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil) {
            self.adMarkers = adMarkers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.adTriggers = adTriggers
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers = "adMarkers"
            case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
            case adTriggers = "adTriggers"
            case id = "id"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case manifestName = "manifestName"
            case playlistType = "playlistType"
            case playlistWindowSeconds = "playlistWindowSeconds"
            case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
        }
    }

    public struct HlsPackage: AWSEncodableShape & AWSDecodableShape {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
        /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
        /// that is greater than 0.
        public let adMarkers: AdMarkers?
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let adTriggers: [AdTriggersElement]?
        public let encryption: HlsEncryption?
        /// When enabled, MediaPackage passes through digital video broadcasting (DVB) subtitles into the output.
        public let includeDvbSubtitles: Bool?
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?
        /// Duration (in seconds) of each fragment. Actual fragments will be
        /// rounded to the nearest multiple of the source fragment duration.
        public let segmentDurationSeconds: Int?
        public let streamSelection: StreamSelection?
        /// When enabled, audio streams will be placed in rendition groups in the output.
        public let useAudioRenditionGroup: Bool?

        public init(adMarkers: AdMarkers? = nil, adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, adTriggers: [AdTriggersElement]? = nil, encryption: HlsEncryption? = nil, includeDvbSubtitles: Bool? = nil, includeIframeOnlyStream: Bool? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, segmentDurationSeconds: Int? = nil, streamSelection: StreamSelection? = nil, useAudioRenditionGroup: Bool? = nil) {
            self.adMarkers = adMarkers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.adTriggers = adTriggers
            self.encryption = encryption
            self.includeDvbSubtitles = includeDvbSubtitles
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
            self.useAudioRenditionGroup = useAudioRenditionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers = "adMarkers"
            case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
            case adTriggers = "adTriggers"
            case encryption = "encryption"
            case includeDvbSubtitles = "includeDvbSubtitles"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case playlistType = "playlistType"
            case playlistWindowSeconds = "playlistWindowSeconds"
            case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case streamSelection = "streamSelection"
            case useAudioRenditionGroup = "useAudioRenditionGroup"
        }
    }

    public struct IngestEndpoint: AWSDecodableShape {
        /// The system generated unique identifier for the IngestEndpoint
        public let id: String?
        /// The system generated password for ingest authentication.
        public let password: String?
        /// The ingest URL to which the source stream should be sent.
        public let url: String?
        /// The system generated username for ingest authentication.
        public let username: String?

        public init(id: String? = nil, password: String? = nil, url: String? = nil, username: String? = nil) {
            self.id = id
            self.password = password
            self.url = url
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case password = "password"
            case url = "url"
            case username = "username"
        }
    }

    public struct IngressAccessLogs: AWSEncodableShape & AWSDecodableShape {
        /// Customize the log group name.
        public let logGroupName: String?

        public init(logGroupName: String? = nil) {
            self.logGroupName = logGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName = "logGroupName"
        }
    }

    public struct ListChannelsRequest: AWSEncodableShape {
        /// Upper bound on number of records to return.
        public let maxResults: Int?
        /// A token used to resume pagination from the end of a previous request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsResponse: AWSDecodableShape {
        /// A list of Channel records.
        public let channels: [Channel]?
        /// A token that can be used to resume pagination from the end of the collection.
        public let nextToken: String?

        public init(channels: [Channel]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case nextToken = "nextToken"
        }
    }

    public struct ListHarvestJobsRequest: AWSEncodableShape {
        /// When specified, the request will return only HarvestJobs associated with the given Channel ID.
        public let includeChannelId: String?
        /// When specified, the request will return only HarvestJobs in the given status.
        public let includeStatus: String?
        /// The upper bound on the number of records to return.
        public let maxResults: Int?
        /// A token used to resume pagination from the end of a previous request.
        public let nextToken: String?

        public init(includeChannelId: String? = nil, includeStatus: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.includeChannelId = includeChannelId
            self.includeStatus = includeStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.includeChannelId, key: "includeChannelId")
            request.encodeQuery(self.includeStatus, key: "includeStatus")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListHarvestJobsResponse: AWSDecodableShape {
        /// A list of HarvestJob records.
        public let harvestJobs: [HarvestJob]?
        /// A token that can be used to resume pagination from the end of the collection.
        public let nextToken: String?

        public init(harvestJobs: [HarvestJob]? = nil, nextToken: String? = nil) {
            self.harvestJobs = harvestJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case harvestJobs = "harvestJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListOriginEndpointsRequest: AWSEncodableShape {
        /// When specified, the request will return only OriginEndpoints associated with the given Channel ID.
        public let channelId: String?
        /// The upper bound on the number of records to return.
        public let maxResults: Int?
        /// A token used to resume pagination from the end of a previous request.
        public let nextToken: String?

        public init(channelId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelId = channelId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.channelId, key: "channelId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOriginEndpointsResponse: AWSDecodableShape {
        /// A token that can be used to resume pagination from the end of the collection.
        public let nextToken: String?
        /// A list of OriginEndpoint records.
        public let originEndpoints: [OriginEndpoint]?

        public init(nextToken: String? = nil, originEndpoints: [OriginEndpoint]? = nil) {
            self.nextToken = nextToken
            self.originEndpoints = originEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case originEndpoints = "originEndpoints"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MssEncryption: AWSEncodableShape & AWSDecodableShape {
        public let spekeKeyProvider: SpekeKeyProvider?

        public init(spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct MssPackage: AWSEncodableShape & AWSDecodableShape {
        public let encryption: MssEncryption?
        /// The time window (in seconds) contained in each manifest.
        public let manifestWindowSeconds: Int?
        /// The duration (in seconds) of each segment.
        public let segmentDurationSeconds: Int?
        public let streamSelection: StreamSelection?

        public init(encryption: MssEncryption? = nil, manifestWindowSeconds: Int? = nil, segmentDurationSeconds: Int? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.manifestWindowSeconds = manifestWindowSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case manifestWindowSeconds = "manifestWindowSeconds"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case streamSelection = "streamSelection"
        }
    }

    public struct OriginEndpoint: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public let arn: String?
        public let authorization: Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        /// The date and time the OriginEndpoint was created.
        public let createdAt: String?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.
        public let id: String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, createdAt: String? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.createdAt = createdAt
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorization = "authorization"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case createdAt = "createdAt"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }

    public struct RotateChannelCredentialsRequest: AWSEncodableShape {
        /// The ID of the channel to update.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RotateChannelCredentialsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// The date and time the Channel was created.
        public let createdAt: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case egressAccessLogs = "egressAccessLogs"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case ingressAccessLogs = "ingressAccessLogs"
            case tags = "tags"
        }
    }

    public struct RotateIngestEndpointCredentialsRequest: AWSEncodableShape {
        /// The ID of the channel the IngestEndpoint is on.
        public let id: String
        /// The id of the IngestEndpoint whose credentials should be rotated
        public let ingestEndpointId: String

        public init(id: String, ingestEndpointId: String) {
            self.id = id
            self.ingestEndpointId = ingestEndpointId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            request.encodePath(self.ingestEndpointId, key: "IngestEndpointId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RotateIngestEndpointCredentialsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// The date and time the Channel was created.
        public let createdAt: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case egressAccessLogs = "egressAccessLogs"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case ingressAccessLogs = "ingressAccessLogs"
            case tags = "tags"
        }
    }

    public struct S3Destination: AWSEncodableShape & AWSDecodableShape {
        /// The name of an S3 bucket within which harvested content will be exported
        public let bucketName: String?
        /// The key in the specified S3 bucket where the harvested top-level manifest will be placed.
        public let manifestKey: String?
        /// The IAM role used to write to the specified S3 bucket
        public let roleArn: String?

        public init(bucketName: String? = nil, manifestKey: String? = nil, roleArn: String? = nil) {
            self.bucketName = bucketName
            self.manifestKey = manifestKey
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case manifestKey = "manifestKey"
            case roleArn = "roleArn"
        }
    }

    public struct SpekeKeyProvider: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Resource Name (ARN) of a Certificate Manager certificate
        /// that MediaPackage will use for enforcing secure end-to-end data
        /// transfer with the key provider service.
        public let certificateArn: String?
        public let encryptionContractConfiguration: EncryptionContractConfiguration?
        /// The resource ID to include in key requests.
        public let resourceId: String?
        /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental
        /// MediaPackage will assume when accessing the key provider service.
        public let roleArn: String?
        /// The system IDs to include in key requests.
        public let systemIds: [String]?
        /// The URL of the external key provider service.
        public let url: String?

        public init(certificateArn: String? = nil, encryptionContractConfiguration: EncryptionContractConfiguration? = nil, resourceId: String? = nil, roleArn: String? = nil, systemIds: [String]? = nil, url: String? = nil) {
            self.certificateArn = certificateArn
            self.encryptionContractConfiguration = encryptionContractConfiguration
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.systemIds = systemIds
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
            case encryptionContractConfiguration = "encryptionContractConfiguration"
            case resourceId = "resourceId"
            case roleArn = "roleArn"
            case systemIds = "systemIds"
            case url = "url"
        }
    }

    public struct StreamSelection: AWSEncodableShape & AWSDecodableShape {
        /// The maximum video bitrate (bps) to include in output.
        public let maxVideoBitsPerSecond: Int?
        /// The minimum video bitrate (bps) to include in output.
        public let minVideoBitsPerSecond: Int?
        /// A directive that determines the order of streams in the output.
        public let streamOrder: StreamOrder?

        public init(maxVideoBitsPerSecond: Int? = nil, minVideoBitsPerSecond: Int? = nil, streamOrder: StreamOrder? = nil) {
            self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
            self.minVideoBitsPerSecond = minVideoBitsPerSecond
            self.streamOrder = streamOrder
        }

        private enum CodingKeys: String, CodingKey {
            case maxVideoBitsPerSecond = "maxVideoBitsPerSecond"
            case minVideoBitsPerSecond = "minVideoBitsPerSecond"
            case streamOrder = "streamOrder"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public let resourceArn: String
        public let tags: [String: String]?

        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public let resourceArn: String
        /// The key(s) of tag to be deleted
        public let tagKeys: [String]?

        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateChannelRequest: AWSEncodableShape {
        /// A short text description of the Channel.
        public let description: String?
        /// The ID of the Channel to update.
        public let id: String

        public init(description: String? = nil, id: String) {
            self.description = description
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// The date and time the Channel was created.
        public let createdAt: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case egressAccessLogs = "egressAccessLogs"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case ingressAccessLogs = "ingressAccessLogs"
            case tags = "tags"
        }
    }

    public struct UpdateOriginEndpointRequest: AWSEncodableShape {
        public let authorization: Authorization?
        public let cmafPackage: CmafPackageCreateOrUpdateParameters?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint to update.
        public let id: String
        /// A short string that will be appended to the end of the Endpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (in seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        /// Amount of delay (in seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(authorization: Authorization? = nil, cmafPackage: CmafPackageCreateOrUpdateParameters? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, timeDelaySeconds: Int? = nil, whitelist: [String]? = nil) {
            self.authorization = authorization
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.timeDelaySeconds = timeDelaySeconds
            self.whitelist = whitelist
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authorization, forKey: .authorization)
            try container.encodeIfPresent(self.cmafPackage, forKey: .cmafPackage)
            try container.encodeIfPresent(self.dashPackage, forKey: .dashPackage)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.hlsPackage, forKey: .hlsPackage)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.manifestName, forKey: .manifestName)
            try container.encodeIfPresent(self.mssPackage, forKey: .mssPackage)
            try container.encodeIfPresent(self.origination, forKey: .origination)
            try container.encodeIfPresent(self.startoverWindowSeconds, forKey: .startoverWindowSeconds)
            try container.encodeIfPresent(self.timeDelaySeconds, forKey: .timeDelaySeconds)
            try container.encodeIfPresent(self.whitelist, forKey: .whitelist)
        }

        private enum CodingKeys: String, CodingKey {
            case authorization = "authorization"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case timeDelaySeconds = "timeDelaySeconds"
            case whitelist = "whitelist"
        }
    }

    public struct UpdateOriginEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public let arn: String?
        public let authorization: Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        /// The date and time the OriginEndpoint was created.
        public let createdAt: String?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.
        public let id: String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, createdAt: String? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.createdAt = createdAt
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorization = "authorization"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case createdAt = "createdAt"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }
}

// MARK: - Errors

/// Error enum for MediaPackage
public struct MediaPackageErrorType: AWSErrorType {
    enum Code: String {
        case forbiddenException = "ForbiddenException"
        case internalServerErrorException = "InternalServerErrorException"
        case notFoundException = "NotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case tooManyRequestsException = "TooManyRequestsException"
        case unprocessableEntityException = "UnprocessableEntityException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MediaPackage
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The client is not authorized to access the requested resource.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// An unexpected error occurred.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// The requested resource does not exist.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// An unexpected error occurred.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The client has exceeded their resource or throttling limits.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// The parameters sent in the request are not valid.
    public static var unprocessableEntityException: Self { .init(.unprocessableEntityException) }
}

extension MediaPackageErrorType: Equatable {
    public static func == (lhs: MediaPackageErrorType, rhs: MediaPackageErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MediaPackageErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
