//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension MediaPackage {
    // MARK: Enums

    public enum AdMarkers: String, CustomStringConvertible, Codable {
        case daterange = "DATERANGE"
        case none = "NONE"
        case passthrough = "PASSTHROUGH"
        case scte35Enhanced = "SCTE35_ENHANCED"
        public var description: String { return self.rawValue }
    }

    public enum AdsOnDeliveryRestrictions: String, CustomStringConvertible, Codable {
        case both = "BOTH"
        case none = "NONE"
        case restricted = "RESTRICTED"
        case unrestricted = "UNRESTRICTED"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionMethod: String, CustomStringConvertible, Codable {
        case aes128 = "AES_128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public enum ManifestLayout: String, CustomStringConvertible, Codable {
        case compact = "COMPACT"
        case full = "FULL"
        public var description: String { return self.rawValue }
    }

    public enum Origination: String, CustomStringConvertible, Codable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum PlaylistType: String, CustomStringConvertible, Codable {
        case event = "EVENT"
        case none = "NONE"
        case vod = "VOD"
        public var description: String { return self.rawValue }
    }

    public enum PresetSpeke20Audio: String, CustomStringConvertible, Codable {
        case presetAudio1 = "PRESET-AUDIO-1"
        public var description: String { return self.rawValue }
    }

    public enum PresetSpeke20Video: String, CustomStringConvertible, Codable {
        case presetVideo1 = "PRESET-VIDEO-1"
        public var description: String { return self.rawValue }
    }

    public enum Profile: String, CustomStringConvertible, Codable {
        case hbbtv15 = "HBBTV_1_5"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum SegmentTemplateFormat: String, CustomStringConvertible, Codable {
        case numberWithDuration = "NUMBER_WITH_DURATION"
        case numberWithTimeline = "NUMBER_WITH_TIMELINE"
        case timeWithTimeline = "TIME_WITH_TIMELINE"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum StreamOrder: String, CustomStringConvertible, Codable {
        case original = "ORIGINAL"
        case videoBitrateAscending = "VIDEO_BITRATE_ASCENDING"
        case videoBitrateDescending = "VIDEO_BITRATE_DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum UtcTiming: String, CustomStringConvertible, Codable {
        case httpHead = "HTTP-HEAD"
        case httpIso = "HTTP-ISO"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum AdTriggersElement: String, CustomStringConvertible, Codable {
        case `break` = "BREAK"
        case distributorAdvertisement = "DISTRIBUTOR_ADVERTISEMENT"
        case distributorOverlayPlacementOpportunity = "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
        case distributorPlacementOpportunity = "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
        case providerAdvertisement = "PROVIDER_ADVERTISEMENT"
        case providerOverlayPlacementOpportunity = "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
        case providerPlacementOpportunity = "PROVIDER_PLACEMENT_OPPORTUNITY"
        case spliceInsert = "SPLICE_INSERT"
        public var description: String { return self.rawValue }
    }

    public enum PeriodTriggersElement: String, CustomStringConvertible, Codable {
        case ads = "ADS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Authorization: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the secret in Secrets Manager that your Content Distribution Network (CDN) uses for authorization to access your endpoint.
        public let cdnIdentifierSecret: String
        /// The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
        public let secretsRoleArn: String

        public init(cdnIdentifierSecret: String, secretsRoleArn: String) {
            self.cdnIdentifierSecret = cdnIdentifierSecret
            self.secretsRoleArn = secretsRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case cdnIdentifierSecret
            case secretsRoleArn
        }
    }

    public struct Channel: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case egressAccessLogs
            case hlsIngest
            case id
            case ingressAccessLogs
            case tags
        }
    }

    public struct CmafEncryption: AWSEncodableShape & AWSDecodableShape {
        /// An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public let constantInitializationVector: String?
        /// Time (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(constantInitializationVector: String? = nil, keyRotationIntervalSeconds: Int? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.constantInitializationVector = constantInitializationVector
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector
            case keyRotationIntervalSeconds
            case spekeKeyProvider
        }
    }

    public struct CmafPackage: AWSDecodableShape {
        public let encryption: CmafEncryption?
        /// A list of HLS manifest configurations
        public let hlsManifests: [HlsManifest]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public let segmentPrefix: String?
        public let streamSelection: StreamSelection?

        public init(encryption: CmafEncryption? = nil, hlsManifests: [HlsManifest]? = nil, segmentDurationSeconds: Int? = nil, segmentPrefix: String? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption
            case hlsManifests
            case segmentDurationSeconds
            case segmentPrefix
            case streamSelection
        }
    }

    public struct CmafPackageCreateOrUpdateParameters: AWSEncodableShape {
        public let encryption: CmafEncryption?
        /// A list of HLS manifest configurations
        public let hlsManifests: [HlsManifestCreateOrUpdateParameters]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public let segmentPrefix: String?
        public let streamSelection: StreamSelection?

        public init(encryption: CmafEncryption? = nil, hlsManifests: [HlsManifestCreateOrUpdateParameters]? = nil, segmentDurationSeconds: Int? = nil, segmentPrefix: String? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption
            case hlsManifests
            case segmentDurationSeconds
            case segmentPrefix
            case streamSelection
        }
    }

    public struct ConfigureLogsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        public let egressAccessLogs: EgressAccessLogs?
        /// The ID of the channel to log subscription.
        public let id: String
        public let ingressAccessLogs: IngressAccessLogs?

        public init(egressAccessLogs: EgressAccessLogs? = nil, id: String, ingressAccessLogs: IngressAccessLogs? = nil) {
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
        }

        private enum CodingKeys: String, CodingKey {
            case egressAccessLogs
            case ingressAccessLogs
        }
    }

    public struct ConfigureLogsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case egressAccessLogs
            case hlsIngest
            case id
            case ingressAccessLogs
            case tags
        }
    }

    public struct CreateChannelRequest: AWSEncodableShape {
        /// A short text description of the Channel.
        public let description: String?
        /// The ID of the Channel. The ID must be unique within the region and it
        /// cannot be changed after a Channel is created.
        public let id: String
        public let tags: [String: String]?

        public init(description: String? = nil, id: String, tags: [String: String]? = nil) {
            self.description = description
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case id
            case tags
        }
    }

    public struct CreateChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case egressAccessLogs
            case hlsIngest
            case id
            case ingressAccessLogs
            case tags
        }
    }

    public struct CreateHarvestJobRequest: AWSEncodableShape {
        /// The end of the time-window which will be harvested
        public let endTime: String
        /// The ID of the HarvestJob. The ID must be unique within the region
        /// and it cannot be changed after the HarvestJob is submitted
        public let id: String
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
        /// This cannot be changed after the HarvestJob is submitted.
        public let originEndpointId: String
        public let s3Destination: S3Destination
        /// The start of the time-window which will be harvested
        public let startTime: String

        public init(endTime: String, id: String, originEndpointId: String, s3Destination: S3Destination, startTime: String) {
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case id
            case originEndpointId
            case s3Destination
            case startTime
        }
    }

    public struct CreateHarvestJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
        public let arn: String?
        /// The ID of the Channel that the HarvestJob will harvest from.
        public let channelId: String?
        /// The time the HarvestJob was submitted
        public let createdAt: String?
        /// The end of the time-window which will be harvested.
        public let endTime: String?
        /// The ID of the HarvestJob. The ID must be unique within the region
        /// and it cannot be changed after the HarvestJob is submitted.
        public let id: String?
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
        /// This cannot be changed after the HarvestJob is submitted.
        public let originEndpointId: String?
        public let s3Destination: S3Destination?
        /// The start of the time-window which will be harvested.
        public let startTime: String?
        /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
        /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
        /// include an explanation of why the HarvestJob failed.
        public let status: Status?

        public init(arn: String? = nil, channelId: String? = nil, createdAt: String? = nil, endTime: String? = nil, id: String? = nil, originEndpointId: String? = nil, s3Destination: S3Destination? = nil, startTime: String? = nil, status: Status? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case channelId
            case createdAt
            case endTime
            case id
            case originEndpointId
            case s3Destination
            case startTime
            case status
        }
    }

    public struct CreateOriginEndpointRequest: AWSEncodableShape {
        public let authorization: Authorization?
        /// The ID of the Channel that the OriginEndpoint will be associated with.
        /// This cannot be changed after the OriginEndpoint is created.
        public let channelId: String
        public let cmafPackage: CmafPackageCreateOrUpdateParameters?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.  The ID must be unique within the region
        /// and it cannot be changed after the OriginEndpoint is created.
        public let id: String
        /// A short string that will be used as the filename of the OriginEndpoint URL (defaults to "index").
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(authorization: Authorization? = nil, channelId: String, cmafPackage: CmafPackageCreateOrUpdateParameters? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, whitelist: [String]? = nil) {
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case authorization
            case channelId
            case cmafPackage
            case dashPackage
            case description
            case hlsPackage
            case id
            case manifestName
            case mssPackage
            case origination
            case startoverWindowSeconds
            case tags
            case timeDelaySeconds
            case whitelist
        }
    }

    public struct CreateOriginEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public let arn: String?
        public let authorization: Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.
        public let id: String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authorization
            case channelId
            case cmafPackage
            case dashPackage
            case description
            case hlsPackage
            case id
            case manifestName
            case mssPackage
            case origination
            case startoverWindowSeconds
            case tags
            case timeDelaySeconds
            case url
            case whitelist
        }
    }

    public struct DashEncryption: AWSEncodableShape & AWSDecodableShape {
        /// Time (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(keyRotationIntervalSeconds: Int? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case keyRotationIntervalSeconds
            case spekeKeyProvider
        }
    }

    public struct DashPackage: AWSEncodableShape & AWSDecodableShape {
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let adTriggers: [AdTriggersElement]?
        public let encryption: DashEncryption?
        /// Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
        public let manifestLayout: ManifestLayout?
        /// Time window (in seconds) contained in each manifest.
        public let manifestWindowSeconds: Int?
        /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
        public let minBufferTimeSeconds: Int?
        /// Minimum duration (in seconds) between potential changes to the Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD).
        public let minUpdatePeriodSeconds: Int?
        /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH)
        /// Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not
        /// be partitioned into more than one period. If the list contains "ADS", new periods will be created where
        /// the Channel source contains SCTE-35 ad markers.
        public let periodTriggers: [PeriodTriggersElement]?
        /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
        public let profile: Profile?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?
        /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
        public let segmentTemplateFormat: SegmentTemplateFormat?
        public let streamSelection: StreamSelection?
        /// Duration (in seconds) to delay live content before presentation.
        public let suggestedPresentationDelaySeconds: Int?
        /// Determines the type of UTCTiming included in the Media Presentation Description (MPD)
        public let utcTiming: UtcTiming?
        /// Specifies the value attribute of the UTCTiming field when utcTiming is set to HTTP-ISO or HTTP-HEAD
        public let utcTimingUri: String?

        public init(adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, adTriggers: [AdTriggersElement]? = nil, encryption: DashEncryption? = nil, manifestLayout: ManifestLayout? = nil, manifestWindowSeconds: Int? = nil, minBufferTimeSeconds: Int? = nil, minUpdatePeriodSeconds: Int? = nil, periodTriggers: [PeriodTriggersElement]? = nil, profile: Profile? = nil, segmentDurationSeconds: Int? = nil, segmentTemplateFormat: SegmentTemplateFormat? = nil, streamSelection: StreamSelection? = nil, suggestedPresentationDelaySeconds: Int? = nil, utcTiming: UtcTiming? = nil, utcTimingUri: String? = nil) {
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.adTriggers = adTriggers
            self.encryption = encryption
            self.manifestLayout = manifestLayout
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.periodTriggers = periodTriggers
            self.profile = profile
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentTemplateFormat = segmentTemplateFormat
            self.streamSelection = streamSelection
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
            self.utcTiming = utcTiming
            self.utcTimingUri = utcTimingUri
        }

        private enum CodingKeys: String, CodingKey {
            case adsOnDeliveryRestrictions
            case adTriggers
            case encryption
            case manifestLayout
            case manifestWindowSeconds
            case minBufferTimeSeconds
            case minUpdatePeriodSeconds
            case periodTriggers
            case profile
            case segmentDurationSeconds
            case segmentTemplateFormat
            case streamSelection
            case suggestedPresentationDelaySeconds
            case utcTiming
            case utcTimingUri
        }
    }

    public struct DeleteChannelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        /// The ID of the Channel to delete.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOriginEndpointRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        /// The ID of the OriginEndpoint to delete.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOriginEndpointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeChannelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        /// The ID of a Channel.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case egressAccessLogs
            case hlsIngest
            case id
            case ingressAccessLogs
            case tags
        }
    }

    public struct DescribeHarvestJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        /// The ID of the HarvestJob.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeHarvestJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
        public let arn: String?
        /// The ID of the Channel that the HarvestJob will harvest from.
        public let channelId: String?
        /// The time the HarvestJob was submitted
        public let createdAt: String?
        /// The end of the time-window which will be harvested.
        public let endTime: String?
        /// The ID of the HarvestJob. The ID must be unique within the region
        /// and it cannot be changed after the HarvestJob is submitted.
        public let id: String?
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
        /// This cannot be changed after the HarvestJob is submitted.
        public let originEndpointId: String?
        public let s3Destination: S3Destination?
        /// The start of the time-window which will be harvested.
        public let startTime: String?
        /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
        /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
        /// include an explanation of why the HarvestJob failed.
        public let status: Status?

        public init(arn: String? = nil, channelId: String? = nil, createdAt: String? = nil, endTime: String? = nil, id: String? = nil, originEndpointId: String? = nil, s3Destination: S3Destination? = nil, startTime: String? = nil, status: Status? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case channelId
            case createdAt
            case endTime
            case id
            case originEndpointId
            case s3Destination
            case startTime
            case status
        }
    }

    public struct DescribeOriginEndpointRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        /// The ID of the OriginEndpoint.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeOriginEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public let arn: String?
        public let authorization: Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.
        public let id: String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authorization
            case channelId
            case cmafPackage
            case dashPackage
            case description
            case hlsPackage
            case id
            case manifestName
            case mssPackage
            case origination
            case startoverWindowSeconds
            case tags
            case timeDelaySeconds
            case url
            case whitelist
        }
    }

    public struct EgressAccessLogs: AWSEncodableShape & AWSDecodableShape {
        /// Customize the log group name.
        public let logGroupName: String?

        public init(logGroupName: String? = nil) {
            self.logGroupName = logGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName
        }
    }

    public struct EncryptionContractConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A collection of audio encryption presets.
        public let presetSpeke20Audio: PresetSpeke20Audio
        /// A collection of video encryption presets.
        public let presetSpeke20Video: PresetSpeke20Video

        public init(presetSpeke20Audio: PresetSpeke20Audio, presetSpeke20Video: PresetSpeke20Video) {
            self.presetSpeke20Audio = presetSpeke20Audio
            self.presetSpeke20Video = presetSpeke20Video
        }

        private enum CodingKeys: String, CodingKey {
            case presetSpeke20Audio
            case presetSpeke20Video
        }
    }

    public struct HarvestJob: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
        public let arn: String?
        /// The ID of the Channel that the HarvestJob will harvest from.
        public let channelId: String?
        /// The time the HarvestJob was submitted
        public let createdAt: String?
        /// The end of the time-window which will be harvested.
        public let endTime: String?
        /// The ID of the HarvestJob. The ID must be unique within the region
        /// and it cannot be changed after the HarvestJob is submitted.
        public let id: String?
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
        /// This cannot be changed after the HarvestJob is submitted.
        public let originEndpointId: String?
        public let s3Destination: S3Destination?
        /// The start of the time-window which will be harvested.
        public let startTime: String?
        /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
        /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
        /// include an explanation of why the HarvestJob failed.
        public let status: Status?

        public init(arn: String? = nil, channelId: String? = nil, createdAt: String? = nil, endTime: String? = nil, id: String? = nil, originEndpointId: String? = nil, s3Destination: S3Destination? = nil, startTime: String? = nil, status: Status? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case channelId
            case createdAt
            case endTime
            case id
            case originEndpointId
            case s3Destination
            case startTime
            case status
        }
    }

    public struct HlsEncryption: AWSEncodableShape & AWSDecodableShape {
        /// A constant initialization vector for encryption (optional).
        /// When not specified the initialization vector will be periodically rotated.
        public let constantInitializationVector: String?
        /// The encryption method to use.
        public let encryptionMethod: EncryptionMethod?
        /// Interval (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int?
        /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
        public let repeatExtXKey: Bool?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(constantInitializationVector: String? = nil, encryptionMethod: EncryptionMethod? = nil, keyRotationIntervalSeconds: Int? = nil, repeatExtXKey: Bool? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.repeatExtXKey = repeatExtXKey
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector
            case encryptionMethod
            case keyRotationIntervalSeconds
            case repeatExtXKey
            case spekeKeyProvider
        }
    }

    public struct HlsIngest: AWSDecodableShape {
        /// A list of endpoints to which the source stream should be sent.
        public let ingestEndpoints: [IngestEndpoint]?

        public init(ingestEndpoints: [IngestEndpoint]? = nil) {
            self.ingestEndpoints = ingestEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case ingestEndpoints
        }
    }

    public struct HlsManifest: AWSDecodableShape {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
        /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
        /// that is greater than 0.
        public let adMarkers: AdMarkers?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        public let id: String
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public let manifestName: String?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?

        public init(adMarkers: AdMarkers? = nil, id: String, includeIframeOnlyStream: Bool? = nil, manifestName: String? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, url: String? = nil) {
            self.adMarkers = adMarkers
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers
            case id
            case includeIframeOnlyStream
            case manifestName
            case playlistType
            case playlistWindowSeconds
            case programDateTimeIntervalSeconds
            case url
        }
    }

    public struct HlsManifestCreateOrUpdateParameters: AWSEncodableShape {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
        /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
        /// that is greater than 0.
        public let adMarkers: AdMarkers?
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let adTriggers: [AdTriggersElement]?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        public let id: String
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public let manifestName: String?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?

        public init(adMarkers: AdMarkers? = nil, adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, adTriggers: [AdTriggersElement]? = nil, id: String, includeIframeOnlyStream: Bool? = nil, manifestName: String? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil) {
            self.adMarkers = adMarkers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.adTriggers = adTriggers
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers
            case adsOnDeliveryRestrictions
            case adTriggers
            case id
            case includeIframeOnlyStream
            case manifestName
            case playlistType
            case playlistWindowSeconds
            case programDateTimeIntervalSeconds
        }
    }

    public struct HlsPackage: AWSEncodableShape & AWSDecodableShape {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
        /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
        /// that is greater than 0.
        public let adMarkers: AdMarkers?
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let adTriggers: [AdTriggersElement]?
        public let encryption: HlsEncryption?
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?
        /// Duration (in seconds) of each fragment. Actual fragments will be
        /// rounded to the nearest multiple of the source fragment duration.
        public let segmentDurationSeconds: Int?
        public let streamSelection: StreamSelection?
        /// When enabled, audio streams will be placed in rendition groups in the output.
        public let useAudioRenditionGroup: Bool?

        public init(adMarkers: AdMarkers? = nil, adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, adTriggers: [AdTriggersElement]? = nil, encryption: HlsEncryption? = nil, includeIframeOnlyStream: Bool? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, segmentDurationSeconds: Int? = nil, streamSelection: StreamSelection? = nil, useAudioRenditionGroup: Bool? = nil) {
            self.adMarkers = adMarkers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.adTriggers = adTriggers
            self.encryption = encryption
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
            self.useAudioRenditionGroup = useAudioRenditionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers
            case adsOnDeliveryRestrictions
            case adTriggers
            case encryption
            case includeIframeOnlyStream
            case playlistType
            case playlistWindowSeconds
            case programDateTimeIntervalSeconds
            case segmentDurationSeconds
            case streamSelection
            case useAudioRenditionGroup
        }
    }

    public struct IngestEndpoint: AWSDecodableShape {
        /// The system generated unique identifier for the IngestEndpoint
        public let id: String?
        /// The system generated password for ingest authentication.
        public let password: String?
        /// The ingest URL to which the source stream should be sent.
        public let url: String?
        /// The system generated username for ingest authentication.
        public let username: String?

        public init(id: String? = nil, password: String? = nil, url: String? = nil, username: String? = nil) {
            self.id = id
            self.password = password
            self.url = url
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case password
            case url
            case username
        }
    }

    public struct IngressAccessLogs: AWSEncodableShape & AWSDecodableShape {
        /// Customize the log group name.
        public let logGroupName: String?

        public init(logGroupName: String? = nil) {
            self.logGroupName = logGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName
        }
    }

    public struct ListChannelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// Upper bound on number of records to return.
        public let maxResults: Int?
        /// A token used to resume pagination from the end of a previous request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsResponse: AWSDecodableShape {
        /// A list of Channel records.
        public let channels: [Channel]?
        /// A token that can be used to resume pagination from the end of the collection.
        public let nextToken: String?

        public init(channels: [Channel]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels
            case nextToken
        }
    }

    public struct ListHarvestJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "includeChannelId", location: .querystring(locationName: "includeChannelId")),
            AWSMemberEncoding(label: "includeStatus", location: .querystring(locationName: "includeStatus")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// When specified, the request will return only HarvestJobs associated with the given Channel ID.
        public let includeChannelId: String?
        /// When specified, the request will return only HarvestJobs in the given status.
        public let includeStatus: String?
        /// The upper bound on the number of records to return.
        public let maxResults: Int?
        /// A token used to resume pagination from the end of a previous request.
        public let nextToken: String?

        public init(includeChannelId: String? = nil, includeStatus: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.includeChannelId = includeChannelId
            self.includeStatus = includeStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListHarvestJobsResponse: AWSDecodableShape {
        /// A list of HarvestJob records.
        public let harvestJobs: [HarvestJob]?
        /// A token that can be used to resume pagination from the end of the collection.
        public let nextToken: String?

        public init(harvestJobs: [HarvestJob]? = nil, nextToken: String? = nil) {
            self.harvestJobs = harvestJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case harvestJobs
            case nextToken
        }
    }

    public struct ListOriginEndpointsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelId", location: .querystring(locationName: "channelId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// When specified, the request will return only OriginEndpoints associated with the given Channel ID.
        public let channelId: String?
        /// The upper bound on the number of records to return.
        public let maxResults: Int?
        /// A token used to resume pagination from the end of a previous request.
        public let nextToken: String?

        public init(channelId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelId = channelId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOriginEndpointsResponse: AWSDecodableShape {
        /// A token that can be used to resume pagination from the end of the collection.
        public let nextToken: String?
        /// A list of OriginEndpoint records.
        public let originEndpoints: [OriginEndpoint]?

        public init(nextToken: String? = nil, originEndpoints: [OriginEndpoint]? = nil) {
            self.nextToken = nextToken
            self.originEndpoints = originEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case originEndpoints
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn"))
        ]

        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct MssEncryption: AWSEncodableShape & AWSDecodableShape {
        public let spekeKeyProvider: SpekeKeyProvider

        public init(spekeKeyProvider: SpekeKeyProvider) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider
        }
    }

    public struct MssPackage: AWSEncodableShape & AWSDecodableShape {
        public let encryption: MssEncryption?
        /// The time window (in seconds) contained in each manifest.
        public let manifestWindowSeconds: Int?
        /// The duration (in seconds) of each segment.
        public let segmentDurationSeconds: Int?
        public let streamSelection: StreamSelection?

        public init(encryption: MssEncryption? = nil, manifestWindowSeconds: Int? = nil, segmentDurationSeconds: Int? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.manifestWindowSeconds = manifestWindowSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption
            case manifestWindowSeconds
            case segmentDurationSeconds
            case streamSelection
        }
    }

    public struct OriginEndpoint: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public let arn: String?
        public let authorization: Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.
        public let id: String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authorization
            case channelId
            case cmafPackage
            case dashPackage
            case description
            case hlsPackage
            case id
            case manifestName
            case mssPackage
            case origination
            case startoverWindowSeconds
            case tags
            case timeDelaySeconds
            case url
            case whitelist
        }
    }

    public struct RotateChannelCredentialsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        /// The ID of the channel to update.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RotateChannelCredentialsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case egressAccessLogs
            case hlsIngest
            case id
            case ingressAccessLogs
            case tags
        }
    }

    public struct RotateIngestEndpointCredentialsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id")),
            AWSMemberEncoding(label: "ingestEndpointId", location: .uri(locationName: "IngestEndpointId"))
        ]

        /// The ID of the channel the IngestEndpoint is on.
        public let id: String
        /// The id of the IngestEndpoint whose credentials should be rotated
        public let ingestEndpointId: String

        public init(id: String, ingestEndpointId: String) {
            self.id = id
            self.ingestEndpointId = ingestEndpointId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RotateIngestEndpointCredentialsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case egressAccessLogs
            case hlsIngest
            case id
            case ingressAccessLogs
            case tags
        }
    }

    public struct S3Destination: AWSEncodableShape & AWSDecodableShape {
        /// The name of an S3 bucket within which harvested content will be exported
        public let bucketName: String
        /// The key in the specified S3 bucket where the harvested top-level manifest will be placed.
        public let manifestKey: String
        /// The IAM role used to write to the specified S3 bucket
        public let roleArn: String

        public init(bucketName: String, manifestKey: String, roleArn: String) {
            self.bucketName = bucketName
            self.manifestKey = manifestKey
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName
            case manifestKey
            case roleArn
        }
    }

    public struct SpekeKeyProvider: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Resource Name (ARN) of a Certificate Manager certificate
        /// that MediaPackage will use for enforcing secure end-to-end data
        /// transfer with the key provider service.
        public let certificateArn: String?
        public let encryptionContractConfiguration: EncryptionContractConfiguration?
        /// The resource ID to include in key requests.
        public let resourceId: String
        /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental
        /// MediaPackage will assume when accessing the key provider service.
        public let roleArn: String
        /// The system IDs to include in key requests.
        public let systemIds: [String]
        /// The URL of the external key provider service.
        public let url: String

        public init(certificateArn: String? = nil, encryptionContractConfiguration: EncryptionContractConfiguration? = nil, resourceId: String, roleArn: String, systemIds: [String], url: String) {
            self.certificateArn = certificateArn
            self.encryptionContractConfiguration = encryptionContractConfiguration
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.systemIds = systemIds
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn
            case encryptionContractConfiguration
            case resourceId
            case roleArn
            case systemIds
            case url
        }
    }

    public struct StreamSelection: AWSEncodableShape & AWSDecodableShape {
        /// The maximum video bitrate (bps) to include in output.
        public let maxVideoBitsPerSecond: Int?
        /// The minimum video bitrate (bps) to include in output.
        public let minVideoBitsPerSecond: Int?
        /// A directive that determines the order of streams in the output.
        public let streamOrder: StreamOrder?

        public init(maxVideoBitsPerSecond: Int? = nil, minVideoBitsPerSecond: Int? = nil, streamOrder: StreamOrder? = nil) {
            self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
            self.minVideoBitsPerSecond = minVideoBitsPerSecond
            self.streamOrder = streamOrder
        }

        private enum CodingKeys: String, CodingKey {
            case maxVideoBitsPerSecond
            case minVideoBitsPerSecond
            case streamOrder
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn"))
        ]

        public let resourceArn: String
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        public let resourceArn: String
        /// The key(s) of tag to be deleted
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateChannelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        /// A short text description of the Channel.
        public let description: String?
        /// The ID of the Channel to update.
        public let id: String

        public init(description: String? = nil, id: String) {
            self.description = description
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case description
        }
    }

    public struct UpdateChannelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// A short text description of the Channel.
        public let description: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let ingressAccessLogs: IngressAccessLogs?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, ingressAccessLogs: IngressAccessLogs? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case egressAccessLogs
            case hlsIngest
            case id
            case ingressAccessLogs
            case tags
        }
    }

    public struct UpdateOriginEndpointRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        public let authorization: Authorization?
        public let cmafPackage: CmafPackageCreateOrUpdateParameters?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint to update.
        public let id: String
        /// A short string that will be appended to the end of the Endpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (in seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        /// Amount of delay (in seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(authorization: Authorization? = nil, cmafPackage: CmafPackageCreateOrUpdateParameters? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, timeDelaySeconds: Int? = nil, whitelist: [String]? = nil) {
            self.authorization = authorization
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.timeDelaySeconds = timeDelaySeconds
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case authorization
            case cmafPackage
            case dashPackage
            case description
            case hlsPackage
            case manifestName
            case mssPackage
            case origination
            case startoverWindowSeconds
            case timeDelaySeconds
            case whitelist
        }
    }

    public struct UpdateOriginEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public let arn: String?
        public let authorization: Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.
        public let id: String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authorization
            case channelId
            case cmafPackage
            case dashPackage
            case description
            case hlsPackage
            case id
            case manifestName
            case mssPackage
            case origination
            case startoverWindowSeconds
            case tags
            case timeDelaySeconds
            case url
            case whitelist
        }
    }
}
