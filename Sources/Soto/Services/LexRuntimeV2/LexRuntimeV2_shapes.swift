//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension LexRuntimeV2 {
    // MARK: Enums

    public enum ConfirmationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case confirmed = "Confirmed"
        case denied = "Denied"
        case none = "None"
        public var description: String { return self.rawValue }
    }

    public enum ConversationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audio = "AUDIO"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum DialogActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case close = "Close"
        case confirmIntent = "ConfirmIntent"
        case delegate = "Delegate"
        case elicitIntent = "ElicitIntent"
        case elicitSlot = "ElicitSlot"
        case none = "None"
        public var description: String { return self.rawValue }
    }

    public enum InputMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dtmf = "DTMF"
        case speech = "Speech"
        case text = "Text"
        public var description: String { return self.rawValue }
    }

    public enum IntentState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case fulfilled = "Fulfilled"
        case fulfillmentInProgress = "FulfillmentInProgress"
        case inProgress = "InProgress"
        case readyForFulfillment = "ReadyForFulfillment"
        case waiting = "Waiting"
        public var description: String { return self.rawValue }
    }

    public enum InterpretationSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bedrock = "Bedrock"
        case lex = "Lex"
        public var description: String { return self.rawValue }
    }

    public enum MessageContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customPayload = "CustomPayload"
        case imageResponseCard = "ImageResponseCard"
        case plainText = "PlainText"
        case ssml = "SSML"
        public var description: String { return self.rawValue }
    }

    public enum PlaybackInterruptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dtmfStartDetected = "DTMF_START_DETECTED"
        case textDetected = "TEXT_DETECTED"
        case voiceStartDetected = "VOICE_START_DETECTED"
        public var description: String { return self.rawValue }
    }

    public enum SentimentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mixed = "MIXED"
        case negative = "NEGATIVE"
        case neutral = "NEUTRAL"
        case positive = "POSITIVE"
        public var description: String { return self.rawValue }
    }

    public enum Shape: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case composite = "Composite"
        case list = "List"
        case scalar = "Scalar"
        public var description: String { return self.rawValue }
    }

    public enum StyleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "Default"
        case spellByLetter = "SpellByLetter"
        case spellByWord = "SpellByWord"
        public var description: String { return self.rawValue }
    }

    public enum StartConversationRequestEventStream: AWSEncodableShape, Sendable {
        /// Speech audio sent from your client application to Amazon Lex V2. Audio starts accumulating when Amazon Lex V2 identifies a voice and continues until a natural pause in the speech is found before processing.
        case audioInputEvent(AudioInputEvent)
        /// Configuration information sent from your client application to Amazon Lex V2
        case configurationEvent(ConfigurationEvent)
        /// Event sent from the client application to indicate to Amazon Lex V2 that the conversation is over.
        case disconnectionEvent(DisconnectionEvent)
        /// DTMF information sent to Amazon Lex V2 by your application. Amazon Lex V2 accumulates the DMTF information from when the user sends the first character and ends   when there's a pause longer that the value configured for the end timeout.   when there's a digit that is the configured end character.   when Amazon Lex V2 accumulates characters equal to the maximum DTMF character configuration.
        case dtmfInputEvent(DTMFInputEvent)
        /// Event sent from the client application to Amazon Lex V2 to indicate that it has finished playing audio and that Amazon Lex V2 should start listening for user input.
        case playbackCompletionEvent(PlaybackCompletionEvent)
        /// Text sent from your client application to Amazon Lex V2. Each TextInputEvent is processed individually.
        case textInputEvent(TextInputEvent)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .audioInputEvent(let value):
                try container.encode(value, forKey: .audioInputEvent)
            case .configurationEvent(let value):
                try container.encode(value, forKey: .configurationEvent)
            case .disconnectionEvent(let value):
                try container.encode(value, forKey: .disconnectionEvent)
            case .dtmfInputEvent(let value):
                try container.encode(value, forKey: .dtmfInputEvent)
            case .playbackCompletionEvent(let value):
                try container.encode(value, forKey: .playbackCompletionEvent)
            case .textInputEvent(let value):
                try container.encode(value, forKey: .textInputEvent)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .audioInputEvent(let value):
                try value.validate(name: "\(name).audioInputEvent")
            case .configurationEvent(let value):
                try value.validate(name: "\(name).configurationEvent")
            case .disconnectionEvent(let value):
                try value.validate(name: "\(name).disconnectionEvent")
            case .dtmfInputEvent(let value):
                try value.validate(name: "\(name).dtmfInputEvent")
            case .playbackCompletionEvent(let value):
                try value.validate(name: "\(name).playbackCompletionEvent")
            case .textInputEvent(let value):
                try value.validate(name: "\(name).textInputEvent")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case audioInputEvent = "AudioInputEvent"
            case configurationEvent = "ConfigurationEvent"
            case disconnectionEvent = "DisconnectionEvent"
            case dtmfInputEvent = "DTMFInputEvent"
            case playbackCompletionEvent = "PlaybackCompletionEvent"
            case textInputEvent = "TextInputEvent"
        }
    }

    public enum StartConversationResponseEventStream: AWSDecodableShape, Sendable {
        /// Exception thrown when the credentials passed with the request are invalid or expired. Also thrown when the credentials in the request do not have permission to access the StartConversation operation.
        case accessDeniedException(AccessDeniedException)
        case audioResponseEvent(AudioResponseEvent)
        case badGatewayException(BadGatewayException)
        /// Exception thrown when two clients are using the same AWS account, Amazon Lex V2 bot, and session ID.
        case conflictException(ConflictException)
        case dependencyFailedException(DependencyFailedException)
        case heartbeatEvent(HeartbeatEvent)
        /// Event sent from Amazon Lex V2 to the client application containing the current state of the conversation between the user and Amazon Lex V2.
        case intentResultEvent(IntentResultEvent)
        /// An error occurred with Amazon Lex V2.
        case internalServerException(InternalServerException)
        case playbackInterruptionEvent(PlaybackInterruptionEvent)
        /// Exception thrown if one of the input parameters points to a resource that does not exist. For example, if the bot ID specified does not exist.
        case resourceNotFoundException(ResourceNotFoundException)
        case textResponseEvent(TextResponseEvent)
        /// Exception thrown when your application exceeds the maximum number of concurrent requests.
        case throttlingException(ThrottlingException)
        case transcriptEvent(TranscriptEvent)
        /// Exception thrown when one or more parameters could not be validated. The message contains the name of the field that isn't valid.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .audioResponseEvent:
                let value = try container.decode(AudioResponseEvent.self, forKey: .audioResponseEvent)
                self = .audioResponseEvent(value)
            case .badGatewayException:
                let value = try container.decode(BadGatewayException.self, forKey: .badGatewayException)
                self = .badGatewayException(value)
            case .conflictException:
                let value = try container.decode(ConflictException.self, forKey: .conflictException)
                self = .conflictException(value)
            case .dependencyFailedException:
                let value = try container.decode(DependencyFailedException.self, forKey: .dependencyFailedException)
                self = .dependencyFailedException(value)
            case .heartbeatEvent:
                let value = try container.decode(HeartbeatEvent.self, forKey: .heartbeatEvent)
                self = .heartbeatEvent(value)
            case .intentResultEvent:
                let value = try container.decode(IntentResultEvent.self, forKey: .intentResultEvent)
                self = .intentResultEvent(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .playbackInterruptionEvent:
                let value = try container.decode(PlaybackInterruptionEvent.self, forKey: .playbackInterruptionEvent)
                self = .playbackInterruptionEvent(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .textResponseEvent:
                let value = try container.decode(TextResponseEvent.self, forKey: .textResponseEvent)
                self = .textResponseEvent(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .transcriptEvent:
                let value = try container.decode(TranscriptEvent.self, forKey: .transcriptEvent)
                self = .transcriptEvent(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "AccessDeniedException"
            case audioResponseEvent = "AudioResponseEvent"
            case badGatewayException = "BadGatewayException"
            case conflictException = "ConflictException"
            case dependencyFailedException = "DependencyFailedException"
            case heartbeatEvent = "HeartbeatEvent"
            case intentResultEvent = "IntentResultEvent"
            case internalServerException = "InternalServerException"
            case playbackInterruptionEvent = "PlaybackInterruptionEvent"
            case resourceNotFoundException = "ResourceNotFoundException"
            case textResponseEvent = "TextResponseEvent"
            case throttlingException = "ThrottlingException"
            case transcriptEvent = "TranscriptEvent"
            case validationException = "ValidationException"
        }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSDecodableShape {
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ActiveContext: AWSEncodableShape & AWSDecodableShape {
        /// A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request. If you don't specify a list of contexts, Amazon Lex V2 will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.
        public let contextAttributes: [String: String]
        /// The name of the context.
        public let name: String
        /// Indicates the number of turns or seconds that the context is active. Once the time to live expires, the context is no longer returned in a response.
        public let timeToLive: ActiveContextTimeToLive

        public init(contextAttributes: [String: String], name: String, timeToLive: ActiveContextTimeToLive) {
            self.contextAttributes = contextAttributes
            self.name = name
            self.timeToLive = timeToLive
        }

        public func validate(name: String) throws {
            try self.contextAttributes.forEach {
                try validate($0.key, name: "contextAttributes.key", parent: name, max: 100)
                try validate($0.key, name: "contextAttributes.key", parent: name, min: 1)
                try validate($0.value, name: "contextAttributes[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "contextAttributes[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.contextAttributes, name: "contextAttributes", parent: name, max: 10)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([A-Za-z0-9]_?)+$")
            try self.timeToLive.validate(name: "\(name).timeToLive")
        }

        private enum CodingKeys: String, CodingKey {
            case contextAttributes = "contextAttributes"
            case name = "name"
            case timeToLive = "timeToLive"
        }
    }

    public struct ActiveContextTimeToLive: AWSEncodableShape & AWSDecodableShape {
        /// The number of seconds that the context is active. You can specify between 5 and 86400 seconds (24 hours).
        public let timeToLiveInSeconds: Int
        /// The number of turns that the context is active. You can specify up to 20 turns. Each request and response from the bot is a turn.
        public let turnsToLive: Int

        public init(timeToLiveInSeconds: Int, turnsToLive: Int) {
            self.timeToLiveInSeconds = timeToLiveInSeconds
            self.turnsToLive = turnsToLive
        }

        public func validate(name: String) throws {
            try self.validate(self.timeToLiveInSeconds, name: "timeToLiveInSeconds", parent: name, max: 86400)
            try self.validate(self.timeToLiveInSeconds, name: "timeToLiveInSeconds", parent: name, min: 5)
            try self.validate(self.turnsToLive, name: "turnsToLive", parent: name, max: 20)
            try self.validate(self.turnsToLive, name: "turnsToLive", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case timeToLiveInSeconds = "timeToLiveInSeconds"
            case turnsToLive = "turnsToLive"
        }
    }

    public struct AudioInputEvent: AWSEncodableShape {
        /// An encoded stream of audio.
        public let audioChunk: AWSBase64Data?
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public let clientTimestampMillis: Int64?
        /// The encoding used for the audio chunk. You must use 8 KHz PCM 16-bit mono-channel little-endian format. The value of the field should be:  audio/lpcm; sample-rate=8000; sample-size-bits=16; channel-count=1; is-big-endian=false
        public let contentType: String
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public let eventId: String?

        public init(audioChunk: AWSBase64Data? = nil, clientTimestampMillis: Int64? = nil, contentType: String, eventId: String? = nil) {
            self.audioChunk = audioChunk
            self.clientTimestampMillis = clientTimestampMillis
            self.contentType = contentType
            self.eventId = eventId
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.validate(self.eventId, name: "eventId", parent: name, max: 100)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 2)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case audioChunk = "audioChunk"
            case clientTimestampMillis = "clientTimestampMillis"
            case contentType = "contentType"
            case eventId = "eventId"
        }
    }

    public struct AudioResponseEvent: AWSDecodableShape {
        /// A chunk of the audio to play.
        public let audioChunk: AWSBase64Data?
        /// The encoding of the audio chunk. This is the same as the encoding configure in the contentType field of the ConfigurationEvent.
        public let contentType: String?
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public let eventId: String?

        public init(audioChunk: AWSBase64Data? = nil, contentType: String? = nil, eventId: String? = nil) {
            self.audioChunk = audioChunk
            self.contentType = contentType
            self.eventId = eventId
        }

        private enum CodingKeys: String, CodingKey {
            case audioChunk = "audioChunk"
            case contentType = "contentType"
            case eventId = "eventId"
        }
    }

    public struct BadGatewayException: AWSDecodableShape {
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct Button: AWSEncodableShape & AWSDecodableShape {
        /// The text that is displayed on the button.
        public let text: String
        /// The value returned to Amazon Lex V2 when a user chooses the button.
        public let value: String

        public init(text: String, value: String) {
            self.text = text
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 50)
            try self.validate(self.text, name: "text", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 50)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case value = "value"
        }
    }

    public struct ConfidenceScore: AWSDecodableShape {
        /// A score that indicates how confident Amazon Lex V2 is that an intent satisfies the user's intent. Ranges between 0.00 and 1.00. Higher scores indicate higher confidence.
        public let score: Double?

        public init(score: Double? = nil) {
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case score = "score"
        }
    }

    public struct ConfigurationEvent: AWSEncodableShape {
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public let clientTimestampMillis: Int64?
        /// Determines whether Amazon Lex V2 should send audio responses to the client application.   Set this field to false when the client is operating in a playback mode where audio responses are played to the user. If the client isn't operating in playback mode, such as a text chat application, set this to true so that Amazon Lex V2 doesn't wait for the prompt to finish playing on the client.
        public let disablePlayback: Bool?
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public let eventId: String?
        /// Request-specific information passed between the client application and Amazon Lex V2. The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes for prefix x-amz-lex:.
        public let requestAttributes: [String: String]?
        /// The message that Amazon Lex V2 returns in the response can be either text or speech based on the responseContentType value.   If the value is text/plain;charset=utf-8, Amazon Lex V2 returns text in the response.   If the value begins with audio/, Amazon Lex V2 returns speech in the response. Amazon Lex V2 uses Amazon Polly to generate the speech using the configuration that you specified in the requestContentType parameter. For example, if you specify audio/mpeg as the value, Amazon Lex V2 returns speech in the MPEG format.   If the value is audio/pcm, the speech returned is audio/pcm in 16-bit, little-endian format.   The following are the accepted values:   audio/mpeg   audio/ogg   audio/pcm   audio/* (defaults to mpeg)   text/plain; charset=utf-8
        public let responseContentType: String
        public let sessionState: SessionState?
        /// A list of messages to send to the user. If you set the welcomeMessage field, you must also set the  DialogAction structure's  type field.
        public let welcomeMessages: [Message]?

        public init(clientTimestampMillis: Int64? = nil, disablePlayback: Bool? = nil, eventId: String? = nil, requestAttributes: [String: String]? = nil, responseContentType: String, sessionState: SessionState? = nil, welcomeMessages: [Message]? = nil) {
            self.clientTimestampMillis = clientTimestampMillis
            self.disablePlayback = disablePlayback
            self.eventId = eventId
            self.requestAttributes = requestAttributes
            self.responseContentType = responseContentType
            self.sessionState = sessionState
            self.welcomeMessages = welcomeMessages
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 100)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 2)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.requestAttributes?.forEach {
                try validate($0.key, name: "requestAttributes.key", parent: name, min: 1)
            }
            try self.validate(self.responseContentType, name: "responseContentType", parent: name, min: 1)
            try self.sessionState?.validate(name: "\(name).sessionState")
            try self.welcomeMessages?.forEach {
                try $0.validate(name: "\(name).welcomeMessages[]")
            }
            try self.validate(self.welcomeMessages, name: "welcomeMessages", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case clientTimestampMillis = "clientTimestampMillis"
            case disablePlayback = "disablePlayback"
            case eventId = "eventId"
            case requestAttributes = "requestAttributes"
            case responseContentType = "responseContentType"
            case sessionState = "sessionState"
            case welcomeMessages = "welcomeMessages"
        }
    }

    public struct ConflictException: AWSDecodableShape {
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DTMFInputEvent: AWSEncodableShape {
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public let clientTimestampMillis: Int64?
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public let eventId: String?
        /// The DTMF character that the user pressed. The allowed characters are A - D, 0 - 9, # and *.
        public let inputCharacter: String

        public init(clientTimestampMillis: Int64? = nil, eventId: String? = nil, inputCharacter: String) {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
            self.inputCharacter = inputCharacter
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 100)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 2)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.validate(self.inputCharacter, name: "inputCharacter", parent: name, max: 1)
            try self.validate(self.inputCharacter, name: "inputCharacter", parent: name, min: 1)
            try self.validate(self.inputCharacter, name: "inputCharacter", parent: name, pattern: "^[A-D0-9#*]{1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientTimestampMillis = "clientTimestampMillis"
            case eventId = "eventId"
            case inputCharacter = "inputCharacter"
        }
    }

    public struct DeleteSessionRequest: AWSEncodableShape {
        /// The alias identifier in use for the bot that contains the session data.
        public let botAliasId: String
        /// The identifier of the bot that contains the session data.
        public let botId: String
        /// The locale where the session is in use.
        public let localeId: String
        /// The identifier of the session to delete.
        public let sessionId: String

        public init(botAliasId: String, botId: String, localeId: String, sessionId: String) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.localeId = localeId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botAliasId, key: "botAliasId")
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.localeId, key: "localeId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.localeId, name: "localeId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSessionResponse: AWSDecodableShape {
        /// The alias identifier in use for the bot that contained the session data.
        public let botAliasId: String?
        /// The identifier of the bot that contained the session data.
        public let botId: String?
        /// The locale where the session was used.
        public let localeId: String?
        /// The identifier of the deleted session.
        public let sessionId: String?

        public init(botAliasId: String? = nil, botId: String? = nil, localeId: String? = nil, sessionId: String? = nil) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.localeId = localeId
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botId = "botId"
            case localeId = "localeId"
            case sessionId = "sessionId"
        }
    }

    public struct DependencyFailedException: AWSDecodableShape {
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DialogAction: AWSEncodableShape & AWSDecodableShape {
        /// Configures the slot to use spell-by-letter or spell-by-word style. When you use a style on a slot, users can spell out their input to make it clear to your bot.   Spell by letter - "b" "o" "b"   Spell by word - "b as in boy" "o as in oscar" "b as in boy"   For more information, see  Using spelling to enter slot values .
        public let slotElicitationStyle: StyleType?
        /// The name of the slot that should be elicited from the user.
        public let slotToElicit: String?
        /// The name of the constituent sub slot of the composite slot  specified in slotToElicit that should be elicited from the user.
        public let subSlotToElicit: ElicitSubSlot?
        /// The next action that the bot should take in its interaction with the user. The following values are possible:    Close – Indicates that there will not be a response from the user. For example, the statement "Your order has been placed" does not require a response.    ConfirmIntent – The next action is asking the user if the intent is complete and ready to be fulfilled. This is a yes/no question such as "Place the order?"    Delegate – The next action is determined by Amazon Lex V2.    ElicitIntent – The next action is to elicit an intent from the user.    ElicitSlot – The next action is to elicit a slot value from the user.
        public let type: DialogActionType

        public init(slotElicitationStyle: StyleType? = nil, slotToElicit: String? = nil, subSlotToElicit: ElicitSubSlot? = nil, type: DialogActionType) {
            self.slotElicitationStyle = slotElicitationStyle
            self.slotToElicit = slotToElicit
            self.subSlotToElicit = subSlotToElicit
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.slotToElicit, name: "slotToElicit", parent: name, min: 1)
            try self.subSlotToElicit?.validate(name: "\(name).subSlotToElicit")
        }

        private enum CodingKeys: String, CodingKey {
            case slotElicitationStyle = "slotElicitationStyle"
            case slotToElicit = "slotToElicit"
            case subSlotToElicit = "subSlotToElicit"
            case type = "type"
        }
    }

    public struct DisconnectionEvent: AWSEncodableShape {
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public let clientTimestampMillis: Int64?
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public let eventId: String?

        public init(clientTimestampMillis: Int64? = nil, eventId: String? = nil) {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 100)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 2)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientTimestampMillis = "clientTimestampMillis"
            case eventId = "eventId"
        }
    }

    public final class ElicitSubSlot: AWSEncodableShape & AWSDecodableShape {
        /// The name of the slot that should be elicited from the user.
        public let name: String
        /// The field is not supported.
        public let subSlotToElicit: ElicitSubSlot?

        public init(name: String, subSlotToElicit: ElicitSubSlot? = nil) {
            self.name = name
            self.subSlotToElicit = subSlotToElicit
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.subSlotToElicit?.validate(name: "\(name).subSlotToElicit")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case subSlotToElicit = "subSlotToElicit"
        }
    }

    public struct GetSessionRequest: AWSEncodableShape {
        /// The alias identifier in use for the bot that contains the session data.
        public let botAliasId: String
        /// The identifier of the bot that contains the session data.
        public let botId: String
        /// The locale where the session is in use.
        public let localeId: String
        /// The identifier of the session to return.
        public let sessionId: String

        public init(botAliasId: String, botId: String, localeId: String, sessionId: String) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.localeId = localeId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botAliasId, key: "botAliasId")
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.localeId, key: "localeId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.localeId, name: "localeId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionResponse: AWSDecodableShape {
        /// A list of intents that Amazon Lex V2 determined might satisfy the user's utterance.  Each interpretation includes the intent, a score that indicates how confident Amazon Lex V2 is that the interpretation is the correct one, and an optional sentiment response that indicates the sentiment expressed in the utterance.
        public let interpretations: [Interpretation]?
        /// A list of messages that were last sent to the user. The messages are ordered based on the order that your returned the messages from your Lambda function or the order that messages are defined in the bot.
        public let messages: [Message]?
        /// The identifier of the returned session.
        public let sessionId: String?
        /// Represents the current state of the dialog between the user and the bot. You can use this to determine the progress of the conversation and what the next action might be.
        public let sessionState: SessionState?

        public init(interpretations: [Interpretation]? = nil, messages: [Message]? = nil, sessionId: String? = nil, sessionState: SessionState? = nil) {
            self.interpretations = interpretations
            self.messages = messages
            self.sessionId = sessionId
            self.sessionState = sessionState
        }

        private enum CodingKeys: String, CodingKey {
            case interpretations = "interpretations"
            case messages = "messages"
            case sessionId = "sessionId"
            case sessionState = "sessionState"
        }
    }

    public struct HeartbeatEvent: AWSDecodableShape {
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public let eventId: String?

        public init(eventId: String? = nil) {
            self.eventId = eventId
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
        }
    }

    public struct ImageResponseCard: AWSEncodableShape & AWSDecodableShape {
        /// A list of buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button.
        public let buttons: [Button]?
        /// The URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
        public let imageUrl: String?
        /// The subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
        public let subtitle: String?
        /// The title to display on the response card. The format of the title is determined by the platform displaying the response card.
        public let title: String

        public init(buttons: [Button]? = nil, imageUrl: String? = nil, subtitle: String? = nil, title: String) {
            self.buttons = buttons
            self.imageUrl = imageUrl
            self.subtitle = subtitle
            self.title = title
        }

        public func validate(name: String) throws {
            try self.buttons?.forEach {
                try $0.validate(name: "\(name).buttons[]")
            }
            try self.validate(self.buttons, name: "buttons", parent: name, max: 5)
            try self.validate(self.imageUrl, name: "imageUrl", parent: name, max: 250)
            try self.validate(self.imageUrl, name: "imageUrl", parent: name, min: 1)
            try self.validate(self.subtitle, name: "subtitle", parent: name, max: 250)
            try self.validate(self.subtitle, name: "subtitle", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, max: 250)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case buttons = "buttons"
            case imageUrl = "imageUrl"
            case subtitle = "subtitle"
            case title = "title"
        }
    }

    public struct Intent: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the intent has been Confirmed, Denied, or None if the confirmation stage has not yet been reached.
        public let confirmationState: ConfirmationState?
        /// The name of the intent.
        public let name: String
        /// A map of all of the slots for the intent. The name of the slot maps to the value of the slot. If a slot has not been filled, the value is null.
        public let slots: [String: Slot]?
        /// Indicates the fulfillment state for the intent. The meanings of each value are as follows:    Failed – The bot failed to fulfill the intent.    Fulfilled – The bot has completed fulfillment of the intent.    FulfillmentInProgress – The bot is in the middle of fulfilling the intent.    InProgress – The bot is in the middle of eliciting the slot values that are necessary to fulfill the intent.    ReadyForFulfillment – The bot has elicited all the slot values for the intent and is ready to fulfill the intent.    Waiting – The bot is waiting for a response from the user (limited to streaming conversations).
        public let state: IntentState?

        public init(confirmationState: ConfirmationState? = nil, name: String, slots: [String: Slot]? = nil, state: IntentState? = nil) {
            self.confirmationState = confirmationState
            self.name = name
            self.slots = slots
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.slots?.forEach {
                try validate($0.key, name: "slots.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).slots[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case confirmationState = "confirmationState"
            case name = "name"
            case slots = "slots"
            case state = "state"
        }
    }

    public struct IntentResultEvent: AWSDecodableShape {
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public let eventId: String?
        /// Indicates whether the input to the operation was text, speech, or from a touch-tone keypad.
        public let inputMode: InputMode?
        /// A list of intents that Amazon Lex V2 determined might satisfy the user's utterance. Each interpretation includes the intent, a score that indicates how confident Amazon Lex V2 is that the interpretation is the correct one, and an optional sentiment response that indicates the sentiment expressed in the utterance.
        public let interpretations: [Interpretation]?
        /// The bot member that is processing the intent.
        public let recognizedBotMember: RecognizedBotMember?
        /// The attributes sent in the request.
        public let requestAttributes: [String: String]?
        /// The identifier of the session in use.
        public let sessionId: String?
        public let sessionState: SessionState?

        public init(eventId: String? = nil, inputMode: InputMode? = nil, interpretations: [Interpretation]? = nil, recognizedBotMember: RecognizedBotMember? = nil, requestAttributes: [String: String]? = nil, sessionId: String? = nil, sessionState: SessionState? = nil) {
            self.eventId = eventId
            self.inputMode = inputMode
            self.interpretations = interpretations
            self.recognizedBotMember = recognizedBotMember
            self.requestAttributes = requestAttributes
            self.sessionId = sessionId
            self.sessionState = sessionState
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case inputMode = "inputMode"
            case interpretations = "interpretations"
            case recognizedBotMember = "recognizedBotMember"
            case requestAttributes = "requestAttributes"
            case sessionId = "sessionId"
            case sessionState = "sessionState"
        }
    }

    public struct InternalServerException: AWSDecodableShape {
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct Interpretation: AWSDecodableShape {
        /// A list of intents that might satisfy the user's utterance. The intents are ordered by the confidence score.
        public let intent: Intent?
        /// Specifies the service that interpreted the input.
        public let interpretationSource: InterpretationSource?
        /// Determines the threshold where Amazon Lex V2 will insert the AMAZON.FallbackIntent, AMAZON.KendraSearchIntent, or both when returning alternative intents in a response. AMAZON.FallbackIntent and AMAZON.KendraSearchIntent are only inserted if they are configured for the bot.
        public let nluConfidence: ConfidenceScore?
        /// The sentiment expressed in an utterance.  When the bot is configured to send utterances to Amazon Comprehend for sentiment analysis, this field contains the result of the analysis.
        public let sentimentResponse: SentimentResponse?

        public init(intent: Intent? = nil, interpretationSource: InterpretationSource? = nil, nluConfidence: ConfidenceScore? = nil, sentimentResponse: SentimentResponse? = nil) {
            self.intent = intent
            self.interpretationSource = interpretationSource
            self.nluConfidence = nluConfidence
            self.sentimentResponse = sentimentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case intent = "intent"
            case interpretationSource = "interpretationSource"
            case nluConfidence = "nluConfidence"
            case sentimentResponse = "sentimentResponse"
        }
    }

    public struct Message: AWSEncodableShape & AWSDecodableShape {
        /// The text of the message.
        public let content: String?
        /// Indicates the type of response.
        public let contentType: MessageContentType
        public let imageResponseCard: ImageResponseCard?

        public init(content: String? = nil, contentType: MessageContentType, imageResponseCard: ImageResponseCard? = nil) {
            self.content = content
            self.contentType = contentType
            self.imageResponseCard = imageResponseCard
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 1024)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.imageResponseCard?.validate(name: "\(name).imageResponseCard")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case contentType = "contentType"
            case imageResponseCard = "imageResponseCard"
        }
    }

    public struct PlaybackCompletionEvent: AWSEncodableShape {
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public let clientTimestampMillis: Int64?
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public let eventId: String?

        public init(clientTimestampMillis: Int64? = nil, eventId: String? = nil) {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 100)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 2)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientTimestampMillis = "clientTimestampMillis"
            case eventId = "eventId"
        }
    }

    public struct PlaybackInterruptionEvent: AWSDecodableShape {
        /// The identifier of the event that contained the audio, DTMF, or text that caused the interruption.
        public let causedByEventId: String?
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public let eventId: String?
        /// Indicates the type of user input that Amazon Lex V2 detected.
        public let eventReason: PlaybackInterruptionReason?

        public init(causedByEventId: String? = nil, eventId: String? = nil, eventReason: PlaybackInterruptionReason? = nil) {
            self.causedByEventId = causedByEventId
            self.eventId = eventId
            self.eventReason = eventReason
        }

        private enum CodingKeys: String, CodingKey {
            case causedByEventId = "causedByEventId"
            case eventId = "eventId"
            case eventReason = "eventReason"
        }
    }

    public struct PutSessionRequest: AWSEncodableShape {
        /// The alias identifier of the bot that receives the session data.
        public let botAliasId: String
        /// The identifier of the bot that receives the session data.
        public let botId: String
        /// The locale where the session is in use.
        public let localeId: String
        /// A list of messages to send to the user. Messages are sent in the order that they are defined in the list.
        public let messages: [Message]?
        /// Request-specific information passed between Amazon Lex V2 and the client application. The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes with the prefix x-amz-lex:.
        public let requestAttributes: [String: String]?
        /// The message that Amazon Lex V2 returns in the response can be either text or speech depending on the value of this parameter.    If the value is text/plain; charset=utf-8, Amazon Lex V2 returns text in the response.
        public let responseContentType: String?
        /// The identifier of the session that receives the session data.
        public let sessionId: String
        /// Sets the state of the session with the user. You can use this to set the current intent, attributes, context, and dialog action. Use the dialog action to determine the next step that Amazon Lex V2 should use in the conversation with the user.
        public let sessionState: SessionState

        public init(botAliasId: String, botId: String, localeId: String, messages: [Message]? = nil, requestAttributes: [String: String]? = nil, responseContentType: String? = nil, sessionId: String, sessionState: SessionState) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.localeId = localeId
            self.messages = messages
            self.requestAttributes = requestAttributes
            self.responseContentType = responseContentType
            self.sessionId = sessionId
            self.sessionState = sessionState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botAliasId, key: "botAliasId")
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.messages, forKey: .messages)
            try container.encodeIfPresent(self.requestAttributes, forKey: .requestAttributes)
            request.encodeHeader(self.responseContentType, key: "ResponseContentType")
            request.encodePath(self.sessionId, key: "sessionId")
            try container.encode(self.sessionState, forKey: .sessionState)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.localeId, name: "localeId", parent: name, min: 1)
            try self.messages?.forEach {
                try $0.validate(name: "\(name).messages[]")
            }
            try self.validate(self.messages, name: "messages", parent: name, max: 10)
            try self.requestAttributes?.forEach {
                try validate($0.key, name: "requestAttributes.key", parent: name, min: 1)
            }
            try self.validate(self.responseContentType, name: "responseContentType", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.sessionState.validate(name: "\(name).sessionState")
        }

        private enum CodingKeys: String, CodingKey {
            case messages = "messages"
            case requestAttributes = "requestAttributes"
            case sessionState = "sessionState"
        }
    }

    public struct PutSessionResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// If the requested content type was audio, the audio version of the message to convey to the user.
        public let audioStream: AWSHTTPBody
        /// The type of response. Same as the type specified in the responseContentType field in the request.
        public let contentType: String?
        /// A list of messages that were last sent to the user. The messages are ordered based on how you return the messages from you Lambda function or the order that the messages are defined in the bot.
        public let messages: String?
        /// A base-64-encoded gzipped field that provides request-specific information  passed between the client application and Amazon Lex V2. These are the same as the  requestAttribute parameter in the call to the  PutSession operation.
        public let requestAttributes: String?
        /// The identifier of the session that received the data.
        public let sessionId: String?
        /// A base-64-encoded gzipped field that represents the current state of  the dialog between the user and the bot. Use this to determine the progress  of the conversation and what the next action may be.
        public let sessionState: String?

        public init(audioStream: AWSHTTPBody, contentType: String? = nil, messages: String? = nil, requestAttributes: String? = nil, sessionId: String? = nil, sessionState: String? = nil) {
            self.audioStream = audioStream
            self.contentType = contentType
            self.messages = messages
            self.requestAttributes = requestAttributes
            self.sessionId = sessionId
            self.sessionState = sessionState
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.audioStream = try container.decode(AWSHTTPBody.self)
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.messages = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-messages")
            self.requestAttributes = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-request-attributes")
            self.sessionId = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-session-id")
            self.sessionState = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-session-state")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RecognizeTextRequest: AWSEncodableShape {
        /// The alias identifier in use for the bot that processes the request.
        public let botAliasId: String
        /// The identifier of the bot that processes the request.
        public let botId: String
        /// The locale where the session is in use.
        public let localeId: String
        /// Request-specific information passed between the client application and Amazon Lex V2  The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes with the prefix x-amz-lex:.
        public let requestAttributes: [String: String]?
        /// The identifier of the user session that is having the conversation.
        public let sessionId: String
        /// The current state of the dialog between the user and the bot.
        public let sessionState: SessionState?
        /// The text that the user entered. Amazon Lex V2 interprets this text.
        public let text: String

        public init(botAliasId: String, botId: String, localeId: String, requestAttributes: [String: String]? = nil, sessionId: String, sessionState: SessionState? = nil, text: String) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.localeId = localeId
            self.requestAttributes = requestAttributes
            self.sessionId = sessionId
            self.sessionState = sessionState
            self.text = text
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botAliasId, key: "botAliasId")
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.requestAttributes, forKey: .requestAttributes)
            request.encodePath(self.sessionId, key: "sessionId")
            try container.encodeIfPresent(self.sessionState, forKey: .sessionState)
            try container.encode(self.text, forKey: .text)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.localeId, name: "localeId", parent: name, min: 1)
            try self.requestAttributes?.forEach {
                try validate($0.key, name: "requestAttributes.key", parent: name, min: 1)
            }
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.sessionState?.validate(name: "\(name).sessionState")
            try self.validate(self.text, name: "text", parent: name, max: 1024)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case requestAttributes = "requestAttributes"
            case sessionState = "sessionState"
            case text = "text"
        }
    }

    public struct RecognizeTextResponse: AWSDecodableShape {
        /// A list of intents that Amazon Lex V2 determined might satisfy the user's utterance.  Each interpretation includes the intent, a score that indicates now confident Amazon Lex V2 is that the interpretation is the correct one, and an optional sentiment response that indicates the sentiment expressed in the utterance.
        public let interpretations: [Interpretation]?
        /// A list of messages last sent to the user. The messages are ordered based on the order that you returned the messages from your Lambda function or the order that the messages are defined in the bot.
        public let messages: [Message]?
        /// The bot member that recognized the text.
        public let recognizedBotMember: RecognizedBotMember?
        /// The attributes sent in the request.
        public let requestAttributes: [String: String]?
        /// The identifier of the session in use.
        public let sessionId: String?
        /// Represents the current state of the dialog between the user and the bot.  Use this to determine the progress of the conversation and what the next action may be.
        public let sessionState: SessionState?

        public init(interpretations: [Interpretation]? = nil, messages: [Message]? = nil, recognizedBotMember: RecognizedBotMember? = nil, requestAttributes: [String: String]? = nil, sessionId: String? = nil, sessionState: SessionState? = nil) {
            self.interpretations = interpretations
            self.messages = messages
            self.recognizedBotMember = recognizedBotMember
            self.requestAttributes = requestAttributes
            self.sessionId = sessionId
            self.sessionState = sessionState
        }

        private enum CodingKeys: String, CodingKey {
            case interpretations = "interpretations"
            case messages = "messages"
            case recognizedBotMember = "recognizedBotMember"
            case requestAttributes = "requestAttributes"
            case sessionId = "sessionId"
            case sessionState = "sessionState"
        }
    }

    public struct RecognizeUtteranceRequest: AWSEncodableShape {
        public static let _options: AWSShapeOptions = [.allowStreaming, .allowChunkedStreaming]
        /// The alias identifier in use for the bot that should receive the request.
        public let botAliasId: String
        /// The identifier of the bot that should receive the request.
        public let botId: String
        /// User input in PCM or Opus audio format or text format as described in the requestContentType parameter.
        public let inputStream: AWSHTTPBody?
        /// The locale where the session is in use.
        public let localeId: String
        /// Request-specific information passed between the client application and Amazon Lex V2  The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes for prefix x-amz-lex:. The requestAttributes field must be compressed using gzip and then base64 encoded before sending to Amazon Lex V2.
        public let requestAttributes: String?
        /// Indicates the format for audio input or that the content is text. The header must start with one of the following prefixes:   PCM format, audio data must be in little-endian byte order.   audio/l16; rate=16000; channels=1   audio/x-l16; sample-rate=16000; channel-count=1   audio/lpcm; sample-rate=8000; sample-size-bits=16; channel-count=1; is-big-endian=false     Opus format   audio/x-cbr-opus-with-preamble;preamble-size=0;bit-rate=256000;frame-size-milliseconds=4     Text format   text/plain; charset=utf-8
        public let requestContentType: String
        /// The message that Amazon Lex V2 returns in the response can be either text or speech based on the responseContentType value.   If the value is text/plain;charset=utf-8, Amazon Lex V2 returns text in the response.   If the value begins with audio/, Amazon Lex V2 returns speech in the response. Amazon Lex V2 uses Amazon Polly to generate the speech using the configuration that you specified in the responseContentType parameter. For example, if you specify audio/mpeg as the value, Amazon Lex V2 returns speech in the MPEG format.   If the value is audio/pcm, the speech returned is audio/pcm at 16 KHz in 16-bit, little-endian format.   The following are the accepted values:   audio/mpeg   audio/ogg   audio/pcm (16 KHz)   audio/* (defaults to mpeg)   text/plain; charset=utf-8
        public let responseContentType: String?
        /// The identifier of the session in use.
        public let sessionId: String
        /// Sets the state of the session with the user. You can use this to set the current intent, attributes, context, and dialog action. Use the dialog action to determine the next step that Amazon Lex V2 should use in the conversation with the user. The sessionState field must be compressed using gzip and then base64 encoded before sending to Amazon Lex V2.
        public let sessionState: String?

        public init(botAliasId: String, botId: String, inputStream: AWSHTTPBody? = nil, localeId: String, requestAttributes: String? = nil, requestContentType: String, responseContentType: String? = nil, sessionId: String, sessionState: String? = nil) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.inputStream = inputStream
            self.localeId = localeId
            self.requestAttributes = requestAttributes
            self.requestContentType = requestContentType
            self.responseContentType = responseContentType
            self.sessionId = sessionId
            self.sessionState = sessionState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.botAliasId, key: "botAliasId")
            request.encodePath(self.botId, key: "botId")
            try container.encode(self.inputStream)
            request.encodePath(self.localeId, key: "localeId")
            request.encodeHeader(self.requestAttributes, key: "x-amz-lex-request-attributes")
            request.encodeHeader(self.requestContentType, key: "Content-Type")
            request.encodeHeader(self.responseContentType, key: "Response-Content-Type")
            request.encodePath(self.sessionId, key: "sessionId")
            request.encodeHeader(self.sessionState, key: "x-amz-lex-session-state")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.localeId, name: "localeId", parent: name, min: 1)
            try self.validate(self.requestContentType, name: "requestContentType", parent: name, min: 1)
            try self.validate(self.responseContentType, name: "responseContentType", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RecognizeUtteranceResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The prompt or statement to send to the user. This is based on the bot configuration and context. For example, if Amazon Lex V2 did not understand the user intent, it sends the clarificationPrompt configured for the bot. If the intent requires confirmation before taking the fulfillment action, it sends the confirmationPrompt. Another example: Suppose that the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. Then Amazon Lex V2 sends that message in the response.
        public let audioStream: AWSHTTPBody
        /// Content type as specified in the responseContentType in the request.
        public let contentType: String?
        /// Indicates whether the input mode to the operation was text, speech, or from a touch-tone keypad.
        public let inputMode: String?
        /// The text used to process the request. If the input was an audio stream, the inputTranscript field contains the text extracted from the audio stream. This is the text that is actually processed to recognize intents and slot values. You can use this information to determine if Amazon Lex V2 is correctly processing the audio that you send. The inputTranscript field is compressed with gzip and then base64 encoded. Before you can use the contents of the field, you must decode and decompress the contents. See the example for a simple function to decode and decompress the contents.
        public let inputTranscript: String?
        /// A list of intents that Amazon Lex V2 determined might satisfy the user's utterance. Each interpretation includes the intent, a score that indicates how confident Amazon Lex V2 is that the interpretation is the correct one, and an optional sentiment response that indicates the sentiment expressed in the utterance. The interpretations field is compressed with gzip and then base64 encoded. Before you can use the contents of the field, you must decode and decompress the contents. See the example for a simple function to decode and decompress the contents.
        public let interpretations: String?
        /// A list of messages that were last sent to the user. The messages are ordered based on the order that you returned the messages from your Lambda function or the order that the messages are defined in the bot. The messages field is compressed with gzip and then base64 encoded. Before you can use the contents of the field, you must decode and decompress the contents. See the example for a simple function to decode and decompress the contents.
        public let messages: String?
        /// The bot member that recognized the utterance.
        public let recognizedBotMember: String?
        /// The attributes sent in the request. The requestAttributes field is compressed with gzip and then base64 encoded. Before you can use the contents of the field, you must decode and decompress the contents.
        public let requestAttributes: String?
        /// The identifier of the session in use.
        public let sessionId: String?
        /// Represents the current state of the dialog between the user and the bot. Use this to determine the progress of the conversation and what the next action might be. The sessionState field is compressed with gzip and then base64 encoded. Before you can use the contents of the field, you must decode and decompress the contents. See the example for a simple function to decode and decompress the contents.
        public let sessionState: String?

        public init(audioStream: AWSHTTPBody, contentType: String? = nil, inputMode: String? = nil, inputTranscript: String? = nil, interpretations: String? = nil, messages: String? = nil, recognizedBotMember: String? = nil, requestAttributes: String? = nil, sessionId: String? = nil, sessionState: String? = nil) {
            self.audioStream = audioStream
            self.contentType = contentType
            self.inputMode = inputMode
            self.inputTranscript = inputTranscript
            self.interpretations = interpretations
            self.messages = messages
            self.recognizedBotMember = recognizedBotMember
            self.requestAttributes = requestAttributes
            self.sessionId = sessionId
            self.sessionState = sessionState
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.audioStream = try container.decode(AWSHTTPBody.self)
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.inputMode = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-input-mode")
            self.inputTranscript = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-input-transcript")
            self.interpretations = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-interpretations")
            self.messages = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-messages")
            self.recognizedBotMember = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-recognized-bot-member")
            self.requestAttributes = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-request-attributes")
            self.sessionId = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-session-id")
            self.sessionState = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lex-session-state")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RecognizedBotMember: AWSDecodableShape {
        /// The identifier of the bot member that processes the request.
        public let botId: String
        /// The name of the bot member that processes the request.
        public let botName: String?

        public init(botId: String, botName: String? = nil) {
            self.botId = botId
            self.botName = botName
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botName = "botName"
        }
    }

    public struct ResourceNotFoundException: AWSDecodableShape {
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct RuntimeHintDetails: AWSEncodableShape & AWSDecodableShape {
        /// One or more strings that Amazon Lex V2 should look for in the input to the bot. Each phrase is given preference when deciding on slot values.
        public let runtimeHintValues: [RuntimeHintValue]?
        /// A map of constituent sub slot names inside a composite slot in the intent and the phrases  that should be added for each sub slot. Inside each composite slot hints, this structure provides  a mechanism to add granular sub slot phrases. Only sub slot hints are supported for composite slots.  The intent name, composite slot name and the constituent sub slot names must exist.
        public let subSlotHints: [String: RuntimeHintDetails]?

        public init(runtimeHintValues: [RuntimeHintValue]? = nil, subSlotHints: [String: RuntimeHintDetails]? = nil) {
            self.runtimeHintValues = runtimeHintValues
            self.subSlotHints = subSlotHints
        }

        public func validate(name: String) throws {
            try self.runtimeHintValues?.forEach {
                try $0.validate(name: "\(name).runtimeHintValues[]")
            }
            try self.validate(self.runtimeHintValues, name: "runtimeHintValues", parent: name, max: 100)
            try self.validate(self.runtimeHintValues, name: "runtimeHintValues", parent: name, min: 1)
            try self.subSlotHints?.forEach {
                try validate($0.key, name: "subSlotHints.key", parent: name, max: 100)
                try validate($0.key, name: "subSlotHints.key", parent: name, min: 1)
                try validate($0.key, name: "subSlotHints.key", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
                try $0.value.validate(name: "\(name).subSlotHints[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case runtimeHintValues = "runtimeHintValues"
            case subSlotHints = "subSlotHints"
        }
    }

    public struct RuntimeHintValue: AWSEncodableShape & AWSDecodableShape {
        /// The phrase that Amazon Lex V2 should look for in the user's input to the bot.
        public let phrase: String

        public init(phrase: String) {
            self.phrase = phrase
        }

        public func validate(name: String) throws {
            try self.validate(self.phrase, name: "phrase", parent: name, max: 140)
            try self.validate(self.phrase, name: "phrase", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case phrase = "phrase"
        }
    }

    public struct RuntimeHints: AWSEncodableShape & AWSDecodableShape {
        /// A list of the slots in the intent that should have runtime hints added, and the phrases that should be added for each slot. The first level of the slotHints map is the name of the intent. The second level is the name of the slot within the intent. For more information, see Using hints to improve accuracy. The intent name and slot name must exist.
        public let slotHints: [String: [String: RuntimeHintDetails]]?

        public init(slotHints: [String: [String: RuntimeHintDetails]]? = nil) {
            self.slotHints = slotHints
        }

        public func validate(name: String) throws {
            try self.slotHints?.forEach {
                try validate($0.key, name: "slotHints.key", parent: name, max: 100)
                try validate($0.key, name: "slotHints.key", parent: name, min: 1)
                try validate($0.key, name: "slotHints.key", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case slotHints = "slotHints"
        }
    }

    public struct SentimentResponse: AWSDecodableShape {
        /// The overall sentiment expressed in the user's response. This is the sentiment most likely expressed by the user based on the analysis by Amazon Comprehend.
        public let sentiment: SentimentType?
        public let sentimentScore: SentimentScore?

        public init(sentiment: SentimentType? = nil, sentimentScore: SentimentScore? = nil) {
            self.sentiment = sentiment
            self.sentimentScore = sentimentScore
        }

        private enum CodingKeys: String, CodingKey {
            case sentiment = "sentiment"
            case sentimentScore = "sentimentScore"
        }
    }

    public struct SentimentScore: AWSDecodableShape {
        /// The level of confidence that Amazon Comprehend has in the accuracy of its detection of the MIXED sentiment.
        public let mixed: Double?
        /// The level of confidence that Amazon Comprehend has in the accuracy of its detection of the NEGATIVE sentiment.
        public let negative: Double?
        /// The level of confidence that Amazon Comprehend has in the accuracy of its detection of the NEUTRAL sentiment.
        public let neutral: Double?
        /// The level of confidence that Amazon Comprehend has in the accuracy of its detection of the POSITIVE sentiment.
        public let positive: Double?

        public init(mixed: Double? = nil, negative: Double? = nil, neutral: Double? = nil, positive: Double? = nil) {
            self.mixed = mixed
            self.negative = negative
            self.neutral = neutral
            self.positive = positive
        }

        private enum CodingKeys: String, CodingKey {
            case mixed = "mixed"
            case negative = "negative"
            case neutral = "neutral"
            case positive = "positive"
        }
    }

    public struct SessionState: AWSEncodableShape & AWSDecodableShape {
        /// One or more contexts that indicate to Amazon Lex V2 the context of a request. When a context is active, Amazon Lex V2 considers intents with the matching context as a trigger as the next intent in a session.
        public let activeContexts: [ActiveContext]?
        /// The next step that Amazon Lex V2 should take in the conversation with a user.
        public let dialogAction: DialogAction?
        /// The active intent that Amazon Lex V2 is processing.
        public let intent: Intent?
        /// A unique identifier for a specific request.
        public let originatingRequestId: String?
        /// Hints for phrases that a customer is likely to use for a slot. Amazon Lex V2 uses the hints to help determine the correct value of a slot.
        public let runtimeHints: RuntimeHints?
        /// Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex V2 and a client application.
        public let sessionAttributes: [String: String]?

        public init(activeContexts: [ActiveContext]? = nil, dialogAction: DialogAction? = nil, intent: Intent? = nil, originatingRequestId: String? = nil, runtimeHints: RuntimeHints? = nil, sessionAttributes: [String: String]? = nil) {
            self.activeContexts = activeContexts
            self.dialogAction = dialogAction
            self.intent = intent
            self.originatingRequestId = originatingRequestId
            self.runtimeHints = runtimeHints
            self.sessionAttributes = sessionAttributes
        }

        public func validate(name: String) throws {
            try self.activeContexts?.forEach {
                try $0.validate(name: "\(name).activeContexts[]")
            }
            try self.validate(self.activeContexts, name: "activeContexts", parent: name, max: 20)
            try self.dialogAction?.validate(name: "\(name).dialogAction")
            try self.intent?.validate(name: "\(name).intent")
            try self.validate(self.originatingRequestId, name: "originatingRequestId", parent: name, min: 1)
            try self.runtimeHints?.validate(name: "\(name).runtimeHints")
            try self.sessionAttributes?.forEach {
                try validate($0.key, name: "sessionAttributes.key", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case activeContexts = "activeContexts"
            case dialogAction = "dialogAction"
            case intent = "intent"
            case originatingRequestId = "originatingRequestId"
            case runtimeHints = "runtimeHints"
            case sessionAttributes = "sessionAttributes"
        }
    }

    public struct Slot: AWSEncodableShape & AWSDecodableShape {
        /// When the shape value is List, it indicates that the values field contains a list of slot values. When the value is Scalar, it indicates that the value field contains a single value.
        public let shape: Shape?
        /// The constituent sub slots of a composite slot.
        public let subSlots: [String: Slot]?
        /// The current value of the slot.
        public let value: Value?
        /// A list of one or more values that the user provided for the slot. For example, if a for a slot that elicits pizza toppings, the values might be "pepperoni" and "pineapple."
        public let values: [Slot]?

        public init(shape: Shape? = nil, subSlots: [String: Slot]? = nil, value: Value? = nil, values: [Slot]? = nil) {
            self.shape = shape
            self.subSlots = subSlots
            self.value = value
            self.values = values
        }

        public func validate(name: String) throws {
            try self.subSlots?.forEach {
                try validate($0.key, name: "subSlots.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).subSlots[\"\($0.key)\"]")
            }
            try self.value?.validate(name: "\(name).value")
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case shape = "shape"
            case subSlots = "subSlots"
            case value = "value"
            case values = "values"
        }
    }

    public struct StartConversationRequest: AWSEncodableShape {
        /// The alias identifier in use for the bot that processes the request.
        public let botAliasId: String
        /// The identifier of the bot to process the request.
        public let botId: String
        /// The conversation type that you are using the Amazon Lex V2. If the conversation mode is AUDIO you can send both audio and DTMF information. If the mode is TEXT you can only send text.
        public let conversationMode: ConversationMode?
        /// The locale where the session is in use.
        public let localeId: String
        /// Represents the stream of events to Amazon Lex V2 from your application. The events are encoded as HTTP/2 data frames.
        public let requestEventStream: AWSEventStream<StartConversationRequestEventStream>
        /// The identifier of the user session that is having the conversation.
        public let sessionId: String

        public init(botAliasId: String, botId: String, conversationMode: ConversationMode? = nil, localeId: String, requestEventStream: AWSEventStream<StartConversationRequestEventStream>, sessionId: String) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.conversationMode = conversationMode
            self.localeId = localeId
            self.requestEventStream = requestEventStream
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.botAliasId, key: "botAliasId")
            request.encodePath(self.botId, key: "botId")
            request.encodeHeader(self.conversationMode, key: "x-amz-lex-conversation-mode")
            request.encodePath(self.localeId, key: "localeId")
            try container.encode(self.requestEventStream)
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.localeId, name: "localeId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartConversationResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Represents the stream of events from Amazon Lex V2 to your application. The events are encoded as HTTP/2 data frames.
        public let responseEventStream: AWSEventStream<StartConversationResponseEventStream>

        public init(responseEventStream: AWSEventStream<StartConversationResponseEventStream>) {
            self.responseEventStream = responseEventStream
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.responseEventStream = try container.decode(AWSEventStream<StartConversationResponseEventStream>.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct TextInputEvent: AWSEncodableShape {
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public let clientTimestampMillis: Int64?
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public let eventId: String?
        /// The text from the user. Amazon Lex V2 processes this as a complete statement.
        public let text: String

        public init(clientTimestampMillis: Int64? = nil, eventId: String? = nil, text: String) {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 100)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 2)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
            try self.validate(self.text, name: "text", parent: name, max: 1024)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientTimestampMillis = "clientTimestampMillis"
            case eventId = "eventId"
            case text = "text"
        }
    }

    public struct TextResponseEvent: AWSDecodableShape {
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public let eventId: String?
        /// A list of messages to send to the user. Messages are ordered based on the order that you returned the messages from your Lambda function or the order that the messages are defined in the bot.
        public let messages: [Message]?

        public init(eventId: String? = nil, messages: [Message]? = nil) {
            self.eventId = eventId
            self.messages = messages
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case messages = "messages"
        }
    }

    public struct ThrottlingException: AWSDecodableShape {
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct TranscriptEvent: AWSDecodableShape {
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public let eventId: String?
        /// The transcript of the voice audio from the user.
        public let transcript: String?

        public init(eventId: String? = nil, transcript: String? = nil) {
            self.eventId = eventId
            self.transcript = transcript
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case transcript = "transcript"
        }
    }

    public struct ValidationException: AWSDecodableShape {
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct Value: AWSEncodableShape & AWSDecodableShape {
        /// The value that Amazon Lex V2 determines for the slot, given the user input. The actual value depends on the setting of the value selection strategy for the bot. You can choose to use the value entered by the user, or you can have Amazon Lex V2 choose the first value in the resolvedValues list.
        public let interpretedValue: String
        /// The part of the user's response to the slot elicitation that Amazon Lex V2 determines is relevant to the slot value.
        public let originalValue: String?
        /// A list of values that Amazon Lex V2 determines are possible resolutions for the user input. The first value matches the interpretedValue.
        public let resolvedValues: [String]?

        public init(interpretedValue: String, originalValue: String? = nil, resolvedValues: [String]? = nil) {
            self.interpretedValue = interpretedValue
            self.originalValue = originalValue
            self.resolvedValues = resolvedValues
        }

        public func validate(name: String) throws {
            try self.validate(self.interpretedValue, name: "interpretedValue", parent: name, min: 1)
            try self.validate(self.originalValue, name: "originalValue", parent: name, min: 1)
            try self.resolvedValues?.forEach {
                try validate($0, name: "resolvedValues[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case interpretedValue = "interpretedValue"
            case originalValue = "originalValue"
            case resolvedValues = "resolvedValues"
        }
    }
}

// MARK: - Errors

/// Error enum for LexRuntimeV2
public struct LexRuntimeV2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badGatewayException = "BadGatewayException"
        case conflictException = "ConflictException"
        case dependencyFailedException = "DependencyFailedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize LexRuntimeV2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    public static var badGatewayException: Self { .init(.badGatewayException) }
    public static var conflictException: Self { .init(.conflictException) }
    public static var dependencyFailedException: Self { .init(.dependencyFailedException) }
    public static var internalServerException: Self { .init(.internalServerException) }
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    public static var throttlingException: Self { .init(.throttlingException) }
    public static var validationException: Self { .init(.validationException) }
}

extension LexRuntimeV2ErrorType: Equatable {
    public static func == (lhs: LexRuntimeV2ErrorType, rhs: LexRuntimeV2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension LexRuntimeV2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
