//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgentCoreControl {
    // MARK: Enums

    public enum AgentRuntimeEndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AgentRuntimeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ApiKeyCredentialLocation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case header = "HEADER"
        case queryParameter = "QUERY_PARAMETER"
        public var description: String { return self.rawValue }
    }

    public enum AuthorizerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsIam = "AWS_IAM"
        case customJwt = "CUSTOM_JWT"
        public var description: String { return self.rawValue }
    }

    public enum BrowserNetworkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `public` = "PUBLIC"
        case vpc = "VPC"
        public var description: String { return self.rawValue }
    }

    public enum BrowserStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum CodeInterpreterNetworkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `public` = "PUBLIC"
        case sandbox = "SANDBOX"
        case vpc = "VPC"
        public var description: String { return self.rawValue }
    }

    public enum CodeInterpreterStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum CredentialProviderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case apiKey = "API_KEY"
        case gatewayIamRole = "GATEWAY_IAM_ROLE"
        case oauth = "OAUTH"
        public var description: String { return self.rawValue }
    }

    public enum CredentialProviderVendorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case atlassianOauth2 = "AtlassianOauth2"
        case auth0Oauth2 = "Auth0Oauth2"
        case cognitoOauth2 = "CognitoOauth2"
        case customOauth2 = "CustomOauth2"
        case cyberArkOauth2 = "CyberArkOauth2"
        case dropboxOauth2 = "DropboxOauth2"
        case facebookOauth2 = "FacebookOauth2"
        case fusionAuthOauth2 = "FusionAuthOauth2"
        case githubOauth2 = "GithubOauth2"
        case googleOauth2 = "GoogleOauth2"
        case hubspotOauth2 = "HubspotOauth2"
        case linkedinOauth2 = "LinkedinOauth2"
        case microsoftOauth2 = "MicrosoftOauth2"
        case notionOauth2 = "NotionOauth2"
        case oktaOauth2 = "OktaOauth2"
        case oneLoginOauth2 = "OneLoginOauth2"
        case pingOneOauth2 = "PingOneOauth2"
        case redditOauth2 = "RedditOauth2"
        case salesforceOauth2 = "SalesforceOauth2"
        case slackOauth2 = "SlackOauth2"
        case spotifyOauth2 = "SpotifyOauth2"
        case twitchOauth2 = "TwitchOauth2"
        case xOauth2 = "XOauth2"
        case yandexOauth2 = "YandexOauth2"
        case zoomOauth2 = "ZoomOauth2"
        public var description: String { return self.rawValue }
    }

    public enum ExceptionLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "DEBUG"
        public var description: String { return self.rawValue }
    }

    public enum GatewayProtocolType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mcp = "MCP"
        public var description: String { return self.rawValue }
    }

    public enum GatewayStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case ready = "READY"
        case updateUnsuccessful = "UPDATE_UNSUCCESSFUL"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum KeyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customerManagedKey = "CustomerManagedKey"
        case serviceManagedKey = "ServiceManagedKey"
        public var description: String { return self.rawValue }
    }

    public enum MemoryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum MemoryStrategyStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum MemoryStrategyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case semantic = "SEMANTIC"
        case summarization = "SUMMARIZATION"
        case userPreference = "USER_PREFERENCE"
        public var description: String { return self.rawValue }
    }

    public enum NetworkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `public` = "PUBLIC"
        case vpc = "VPC"
        public var description: String { return self.rawValue }
    }

    public enum OverrideType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case selfManaged = "SELF_MANAGED"
        case semanticOverride = "SEMANTIC_OVERRIDE"
        case summaryOverride = "SUMMARY_OVERRIDE"
        case userPreferenceOverride = "USER_PREFERENCE_OVERRIDE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum SchemaType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case array = "array"
        case boolean = "boolean"
        case integer = "integer"
        case number = "number"
        case object = "object"
        case string = "string"
        public var description: String { return self.rawValue }
    }

    public enum SearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum ServerProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case a2a = "A2A"
        case http = "HTTP"
        case mcp = "MCP"
        public var description: String { return self.rawValue }
    }

    public enum TargetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case ready = "READY"
        case synchronizeUnsuccessful = "SYNCHRONIZE_UNSUCCESSFUL"
        case synchronizing = "SYNCHRONIZING"
        case updateUnsuccessful = "UPDATE_UNSUCCESSFUL"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CannotParse"
        case fieldValidationFailed = "FieldValidationFailed"
        case idempotentParameterMismatchException = "IdempotentParameterMismatchException"
        case resourceConflict = "ResourceConflict"
        case rootEventInOtherSession = "EventInOtherSession"
        public var description: String { return self.rawValue }
    }

    public enum ApiSchemaConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The inline payload containing the API schema definition.
        case inlinePayload(String)
        case s3(S3Configuration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .inlinePayload:
                let value = try container.decode(String.self, forKey: .inlinePayload)
                self = .inlinePayload(value)
            case .s3:
                let value = try container.decode(S3Configuration.self, forKey: .s3)
                self = .s3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .inlinePayload(let value):
                try container.encode(value, forKey: .inlinePayload)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inlinePayload = "inlinePayload"
            case s3 = "s3"
        }
    }

    public enum CredentialProvider: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The API key credential provider. This provider uses an API key to authenticate with the target endpoint.
        case apiKeyCredentialProvider(GatewayApiKeyCredentialProvider)
        /// The OAuth credential provider. This provider uses OAuth authentication to access the target endpoint.
        case oauthCredentialProvider(OAuthCredentialProvider)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .apiKeyCredentialProvider:
                let value = try container.decode(GatewayApiKeyCredentialProvider.self, forKey: .apiKeyCredentialProvider)
                self = .apiKeyCredentialProvider(value)
            case .oauthCredentialProvider:
                let value = try container.decode(OAuthCredentialProvider.self, forKey: .oauthCredentialProvider)
                self = .oauthCredentialProvider(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .apiKeyCredentialProvider(let value):
                try container.encode(value, forKey: .apiKeyCredentialProvider)
            case .oauthCredentialProvider(let value):
                try container.encode(value, forKey: .oauthCredentialProvider)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .apiKeyCredentialProvider(let value):
                try value.validate(name: "\(name).apiKeyCredentialProvider")
            case .oauthCredentialProvider(let value):
                try value.validate(name: "\(name).oauthCredentialProvider")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeyCredentialProvider = "apiKeyCredentialProvider"
            case oauthCredentialProvider = "oauthCredentialProvider"
        }
    }

    public enum CustomConfigurationInput: AWSEncodableShape, Sendable {
        /// The self managed configuration for a custom memory strategy.
        case selfManagedConfiguration(SelfManagedConfigurationInput)
        /// The semantic override configuration for a custom memory strategy.
        case semanticOverride(SemanticOverrideConfigurationInput)
        /// The summary override configuration for a custom memory strategy.
        case summaryOverride(SummaryOverrideConfigurationInput)
        /// The user preference override configuration for a custom memory strategy.
        case userPreferenceOverride(UserPreferenceOverrideConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .selfManagedConfiguration(let value):
                try container.encode(value, forKey: .selfManagedConfiguration)
            case .semanticOverride(let value):
                try container.encode(value, forKey: .semanticOverride)
            case .summaryOverride(let value):
                try container.encode(value, forKey: .summaryOverride)
            case .userPreferenceOverride(let value):
                try container.encode(value, forKey: .userPreferenceOverride)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .selfManagedConfiguration(let value):
                try value.validate(name: "\(name).selfManagedConfiguration")
            case .semanticOverride(let value):
                try value.validate(name: "\(name).semanticOverride")
            case .summaryOverride(let value):
                try value.validate(name: "\(name).summaryOverride")
            case .userPreferenceOverride(let value):
                try value.validate(name: "\(name).userPreferenceOverride")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case selfManagedConfiguration = "selfManagedConfiguration"
            case semanticOverride = "semanticOverride"
            case summaryOverride = "summaryOverride"
            case userPreferenceOverride = "userPreferenceOverride"
        }
    }

    public enum CustomConsolidationConfiguration: AWSDecodableShape, Sendable {
        /// The semantic consolidation override configuration.
        case semanticConsolidationOverride(SemanticConsolidationOverride)
        /// The summary consolidation override configuration.
        case summaryConsolidationOverride(SummaryConsolidationOverride)
        /// The user preference consolidation override configuration.
        case userPreferenceConsolidationOverride(UserPreferenceConsolidationOverride)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .semanticConsolidationOverride:
                let value = try container.decode(SemanticConsolidationOverride.self, forKey: .semanticConsolidationOverride)
                self = .semanticConsolidationOverride(value)
            case .summaryConsolidationOverride:
                let value = try container.decode(SummaryConsolidationOverride.self, forKey: .summaryConsolidationOverride)
                self = .summaryConsolidationOverride(value)
            case .userPreferenceConsolidationOverride:
                let value = try container.decode(UserPreferenceConsolidationOverride.self, forKey: .userPreferenceConsolidationOverride)
                self = .userPreferenceConsolidationOverride(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case semanticConsolidationOverride = "semanticConsolidationOverride"
            case summaryConsolidationOverride = "summaryConsolidationOverride"
            case userPreferenceConsolidationOverride = "userPreferenceConsolidationOverride"
        }
    }

    public enum CustomConsolidationConfigurationInput: AWSEncodableShape, Sendable {
        /// The semantic consolidation override configuration input.
        case semanticConsolidationOverride(SemanticOverrideConsolidationConfigurationInput)
        /// The summary consolidation override configuration input.
        case summaryConsolidationOverride(SummaryOverrideConsolidationConfigurationInput)
        /// The user preference consolidation override configuration input.
        case userPreferenceConsolidationOverride(UserPreferenceOverrideConsolidationConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .semanticConsolidationOverride(let value):
                try container.encode(value, forKey: .semanticConsolidationOverride)
            case .summaryConsolidationOverride(let value):
                try container.encode(value, forKey: .summaryConsolidationOverride)
            case .userPreferenceConsolidationOverride(let value):
                try container.encode(value, forKey: .userPreferenceConsolidationOverride)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .semanticConsolidationOverride(let value):
                try value.validate(name: "\(name).semanticConsolidationOverride")
            case .summaryConsolidationOverride(let value):
                try value.validate(name: "\(name).summaryConsolidationOverride")
            case .userPreferenceConsolidationOverride(let value):
                try value.validate(name: "\(name).userPreferenceConsolidationOverride")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case semanticConsolidationOverride = "semanticConsolidationOverride"
            case summaryConsolidationOverride = "summaryConsolidationOverride"
            case userPreferenceConsolidationOverride = "userPreferenceConsolidationOverride"
        }
    }

    public enum CustomExtractionConfiguration: AWSDecodableShape, Sendable {
        /// The semantic extraction override configuration.
        case semanticExtractionOverride(SemanticExtractionOverride)
        /// The user preference extraction override configuration.
        case userPreferenceExtractionOverride(UserPreferenceExtractionOverride)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .semanticExtractionOverride:
                let value = try container.decode(SemanticExtractionOverride.self, forKey: .semanticExtractionOverride)
                self = .semanticExtractionOverride(value)
            case .userPreferenceExtractionOverride:
                let value = try container.decode(UserPreferenceExtractionOverride.self, forKey: .userPreferenceExtractionOverride)
                self = .userPreferenceExtractionOverride(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case semanticExtractionOverride = "semanticExtractionOverride"
            case userPreferenceExtractionOverride = "userPreferenceExtractionOverride"
        }
    }

    public enum CustomExtractionConfigurationInput: AWSEncodableShape, Sendable {
        /// The semantic extraction override configuration input.
        case semanticExtractionOverride(SemanticOverrideExtractionConfigurationInput)
        /// The user preference extraction override configuration input.
        case userPreferenceExtractionOverride(UserPreferenceOverrideExtractionConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .semanticExtractionOverride(let value):
                try container.encode(value, forKey: .semanticExtractionOverride)
            case .userPreferenceExtractionOverride(let value):
                try container.encode(value, forKey: .userPreferenceExtractionOverride)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .semanticExtractionOverride(let value):
                try value.validate(name: "\(name).semanticExtractionOverride")
            case .userPreferenceExtractionOverride(let value):
                try value.validate(name: "\(name).userPreferenceExtractionOverride")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case semanticExtractionOverride = "semanticExtractionOverride"
            case userPreferenceExtractionOverride = "userPreferenceExtractionOverride"
        }
    }

    public enum McpTargetConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The Lambda configuration for the Model Context Protocol target. This configuration defines how the gateway uses a Lambda function to communicate with the target.
        case lambda(McpLambdaTargetConfiguration)
        /// The MCP server specified as the gateway target.
        case mcpServer(McpServerTargetConfiguration)
        /// The OpenAPI schema for the Model Context Protocol target. This schema defines the API structure of the target.
        case openApiSchema(ApiSchemaConfiguration)
        /// The Smithy model for the Model Context Protocol target. This model defines the API structure of the target using the Smithy specification.
        case smithyModel(ApiSchemaConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .lambda:
                let value = try container.decode(McpLambdaTargetConfiguration.self, forKey: .lambda)
                self = .lambda(value)
            case .mcpServer:
                let value = try container.decode(McpServerTargetConfiguration.self, forKey: .mcpServer)
                self = .mcpServer(value)
            case .openApiSchema:
                let value = try container.decode(ApiSchemaConfiguration.self, forKey: .openApiSchema)
                self = .openApiSchema(value)
            case .smithyModel:
                let value = try container.decode(ApiSchemaConfiguration.self, forKey: .smithyModel)
                self = .smithyModel(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .lambda(let value):
                try container.encode(value, forKey: .lambda)
            case .mcpServer(let value):
                try container.encode(value, forKey: .mcpServer)
            case .openApiSchema(let value):
                try container.encode(value, forKey: .openApiSchema)
            case .smithyModel(let value):
                try container.encode(value, forKey: .smithyModel)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .lambda(let value):
                try value.validate(name: "\(name).lambda")
            case .openApiSchema(let value):
                try value.validate(name: "\(name).openApiSchema")
            case .smithyModel(let value):
                try value.validate(name: "\(name).smithyModel")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case lambda = "lambda"
            case mcpServer = "mcpServer"
            case openApiSchema = "openApiSchema"
            case smithyModel = "smithyModel"
        }
    }

    public enum MemoryStrategyInput: AWSEncodableShape, Sendable {
        /// Input for creating a custom memory strategy.
        case customMemoryStrategy(CustomMemoryStrategyInput)
        /// Input for creating a semantic memory strategy.
        case semanticMemoryStrategy(SemanticMemoryStrategyInput)
        /// Input for creating a summary memory strategy.
        case summaryMemoryStrategy(SummaryMemoryStrategyInput)
        /// Input for creating a user preference memory strategy.
        case userPreferenceMemoryStrategy(UserPreferenceMemoryStrategyInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customMemoryStrategy(let value):
                try container.encode(value, forKey: .customMemoryStrategy)
            case .semanticMemoryStrategy(let value):
                try container.encode(value, forKey: .semanticMemoryStrategy)
            case .summaryMemoryStrategy(let value):
                try container.encode(value, forKey: .summaryMemoryStrategy)
            case .userPreferenceMemoryStrategy(let value):
                try container.encode(value, forKey: .userPreferenceMemoryStrategy)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .customMemoryStrategy(let value):
                try value.validate(name: "\(name).customMemoryStrategy")
            case .semanticMemoryStrategy(let value):
                try value.validate(name: "\(name).semanticMemoryStrategy")
            case .summaryMemoryStrategy(let value):
                try value.validate(name: "\(name).summaryMemoryStrategy")
            case .userPreferenceMemoryStrategy(let value):
                try value.validate(name: "\(name).userPreferenceMemoryStrategy")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customMemoryStrategy = "customMemoryStrategy"
            case semanticMemoryStrategy = "semanticMemoryStrategy"
            case summaryMemoryStrategy = "summaryMemoryStrategy"
            case userPreferenceMemoryStrategy = "userPreferenceMemoryStrategy"
        }
    }

    public enum Oauth2Discovery: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The authorization server metadata for the OAuth2 provider.
        case authorizationServerMetadata(Oauth2AuthorizationServerMetadata)
        /// The discovery URL for the OAuth2 provider.
        case discoveryUrl(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .authorizationServerMetadata:
                let value = try container.decode(Oauth2AuthorizationServerMetadata.self, forKey: .authorizationServerMetadata)
                self = .authorizationServerMetadata(value)
            case .discoveryUrl:
                let value = try container.decode(String.self, forKey: .discoveryUrl)
                self = .discoveryUrl(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .authorizationServerMetadata(let value):
                try container.encode(value, forKey: .authorizationServerMetadata)
            case .discoveryUrl(let value):
                try container.encode(value, forKey: .discoveryUrl)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .authorizationServerMetadata(let value):
                try value.validate(name: "\(name).authorizationServerMetadata")
            case .discoveryUrl(let value):
                try self.validate(value, name: "discoveryUrl", parent: name, pattern: "^.+/\\.well-known/openid-configuration$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationServerMetadata = "authorizationServerMetadata"
            case discoveryUrl = "discoveryUrl"
        }
    }

    public enum Oauth2ProviderConfigInput: AWSEncodableShape, Sendable {
        /// Configuration settings for Atlassian OAuth2 provider integration.
        case atlassianOauth2ProviderConfig(AtlassianOauth2ProviderConfigInput)
        /// The configuration for a custom OAuth2 provider.
        case customOauth2ProviderConfig(CustomOauth2ProviderConfigInput)
        /// The configuration for a GitHub OAuth2 provider.
        case githubOauth2ProviderConfig(GithubOauth2ProviderConfigInput)
        /// The configuration for a Google OAuth2 provider.
        case googleOauth2ProviderConfig(GoogleOauth2ProviderConfigInput)
        /// The configuration for a non-custom OAuth2 provider. This includes settings for supported OAuth2 providers that have built-in integration support.
        case includedOauth2ProviderConfig(IncludedOauth2ProviderConfigInput)
        /// Configuration settings for LinkedIn OAuth2 provider integration.
        case linkedinOauth2ProviderConfig(LinkedinOauth2ProviderConfigInput)
        /// The configuration for a Microsoft OAuth2 provider.
        case microsoftOauth2ProviderConfig(MicrosoftOauth2ProviderConfigInput)
        /// The configuration for a Salesforce OAuth2 provider.
        case salesforceOauth2ProviderConfig(SalesforceOauth2ProviderConfigInput)
        /// The configuration for a Slack OAuth2 provider.
        case slackOauth2ProviderConfig(SlackOauth2ProviderConfigInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .atlassianOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .atlassianOauth2ProviderConfig)
            case .customOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .customOauth2ProviderConfig)
            case .githubOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .githubOauth2ProviderConfig)
            case .googleOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .googleOauth2ProviderConfig)
            case .includedOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .includedOauth2ProviderConfig)
            case .linkedinOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .linkedinOauth2ProviderConfig)
            case .microsoftOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .microsoftOauth2ProviderConfig)
            case .salesforceOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .salesforceOauth2ProviderConfig)
            case .slackOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .slackOauth2ProviderConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .atlassianOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).atlassianOauth2ProviderConfig")
            case .customOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).customOauth2ProviderConfig")
            case .githubOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).githubOauth2ProviderConfig")
            case .googleOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).googleOauth2ProviderConfig")
            case .includedOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).includedOauth2ProviderConfig")
            case .linkedinOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).linkedinOauth2ProviderConfig")
            case .microsoftOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).microsoftOauth2ProviderConfig")
            case .salesforceOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).salesforceOauth2ProviderConfig")
            case .slackOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).slackOauth2ProviderConfig")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case atlassianOauth2ProviderConfig = "atlassianOauth2ProviderConfig"
            case customOauth2ProviderConfig = "customOauth2ProviderConfig"
            case githubOauth2ProviderConfig = "githubOauth2ProviderConfig"
            case googleOauth2ProviderConfig = "googleOauth2ProviderConfig"
            case includedOauth2ProviderConfig = "includedOauth2ProviderConfig"
            case linkedinOauth2ProviderConfig = "linkedinOauth2ProviderConfig"
            case microsoftOauth2ProviderConfig = "microsoftOauth2ProviderConfig"
            case salesforceOauth2ProviderConfig = "salesforceOauth2ProviderConfig"
            case slackOauth2ProviderConfig = "slackOauth2ProviderConfig"
        }
    }

    public enum Oauth2ProviderConfigOutput: AWSDecodableShape, Sendable {
        /// The configuration details for the Atlassian OAuth2 provider.
        case atlassianOauth2ProviderConfig(AtlassianOauth2ProviderConfigOutput)
        /// The output configuration for a custom OAuth2 provider.
        case customOauth2ProviderConfig(CustomOauth2ProviderConfigOutput)
        /// The output configuration for a GitHub OAuth2 provider.
        case githubOauth2ProviderConfig(GithubOauth2ProviderConfigOutput)
        /// The output configuration for a Google OAuth2 provider.
        case googleOauth2ProviderConfig(GoogleOauth2ProviderConfigOutput)
        /// The configuration for a non-custom OAuth2 provider. This includes the configuration details for supported OAuth2 providers that have built-in integration support.
        case includedOauth2ProviderConfig(IncludedOauth2ProviderConfigOutput)
        /// The configuration details for the LinkedIn OAuth2 provider.
        case linkedinOauth2ProviderConfig(LinkedinOauth2ProviderConfigOutput)
        /// The output configuration for a Microsoft OAuth2 provider.
        case microsoftOauth2ProviderConfig(MicrosoftOauth2ProviderConfigOutput)
        /// The output configuration for a Salesforce OAuth2 provider.
        case salesforceOauth2ProviderConfig(SalesforceOauth2ProviderConfigOutput)
        /// The output configuration for a Slack OAuth2 provider.
        case slackOauth2ProviderConfig(SlackOauth2ProviderConfigOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .atlassianOauth2ProviderConfig:
                let value = try container.decode(AtlassianOauth2ProviderConfigOutput.self, forKey: .atlassianOauth2ProviderConfig)
                self = .atlassianOauth2ProviderConfig(value)
            case .customOauth2ProviderConfig:
                let value = try container.decode(CustomOauth2ProviderConfigOutput.self, forKey: .customOauth2ProviderConfig)
                self = .customOauth2ProviderConfig(value)
            case .githubOauth2ProviderConfig:
                let value = try container.decode(GithubOauth2ProviderConfigOutput.self, forKey: .githubOauth2ProviderConfig)
                self = .githubOauth2ProviderConfig(value)
            case .googleOauth2ProviderConfig:
                let value = try container.decode(GoogleOauth2ProviderConfigOutput.self, forKey: .googleOauth2ProviderConfig)
                self = .googleOauth2ProviderConfig(value)
            case .includedOauth2ProviderConfig:
                let value = try container.decode(IncludedOauth2ProviderConfigOutput.self, forKey: .includedOauth2ProviderConfig)
                self = .includedOauth2ProviderConfig(value)
            case .linkedinOauth2ProviderConfig:
                let value = try container.decode(LinkedinOauth2ProviderConfigOutput.self, forKey: .linkedinOauth2ProviderConfig)
                self = .linkedinOauth2ProviderConfig(value)
            case .microsoftOauth2ProviderConfig:
                let value = try container.decode(MicrosoftOauth2ProviderConfigOutput.self, forKey: .microsoftOauth2ProviderConfig)
                self = .microsoftOauth2ProviderConfig(value)
            case .salesforceOauth2ProviderConfig:
                let value = try container.decode(SalesforceOauth2ProviderConfigOutput.self, forKey: .salesforceOauth2ProviderConfig)
                self = .salesforceOauth2ProviderConfig(value)
            case .slackOauth2ProviderConfig:
                let value = try container.decode(SlackOauth2ProviderConfigOutput.self, forKey: .slackOauth2ProviderConfig)
                self = .slackOauth2ProviderConfig(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case atlassianOauth2ProviderConfig = "atlassianOauth2ProviderConfig"
            case customOauth2ProviderConfig = "customOauth2ProviderConfig"
            case githubOauth2ProviderConfig = "githubOauth2ProviderConfig"
            case googleOauth2ProviderConfig = "googleOauth2ProviderConfig"
            case includedOauth2ProviderConfig = "includedOauth2ProviderConfig"
            case linkedinOauth2ProviderConfig = "linkedinOauth2ProviderConfig"
            case microsoftOauth2ProviderConfig = "microsoftOauth2ProviderConfig"
            case salesforceOauth2ProviderConfig = "salesforceOauth2ProviderConfig"
            case slackOauth2ProviderConfig = "slackOauth2ProviderConfig"
        }
    }

    public enum ToolSchema: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The inline payload of the tool schema. This payload contains the schema definition directly in the request.
        case inlinePayload([ToolDefinition])
        /// The Amazon S3 location of the tool schema. This location contains the schema definition file.
        case s3(S3Configuration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .inlinePayload:
                let value = try container.decode([ToolDefinition].self, forKey: .inlinePayload)
                self = .inlinePayload(value)
            case .s3:
                let value = try container.decode(S3Configuration.self, forKey: .s3)
                self = .s3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .inlinePayload(let value):
                try container.encode(value, forKey: .inlinePayload)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inlinePayload = "inlinePayload"
            case s3 = "s3"
        }
    }

    public enum TriggerCondition: AWSDecodableShape, Sendable {
        /// Message based trigger configuration.
        case messageBasedTrigger(MessageBasedTrigger)
        /// Time based trigger configuration.
        case timeBasedTrigger(TimeBasedTrigger)
        /// Token based trigger configuration.
        case tokenBasedTrigger(TokenBasedTrigger)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .messageBasedTrigger:
                let value = try container.decode(MessageBasedTrigger.self, forKey: .messageBasedTrigger)
                self = .messageBasedTrigger(value)
            case .timeBasedTrigger:
                let value = try container.decode(TimeBasedTrigger.self, forKey: .timeBasedTrigger)
                self = .timeBasedTrigger(value)
            case .tokenBasedTrigger:
                let value = try container.decode(TokenBasedTrigger.self, forKey: .tokenBasedTrigger)
                self = .tokenBasedTrigger(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case messageBasedTrigger = "messageBasedTrigger"
            case timeBasedTrigger = "timeBasedTrigger"
            case tokenBasedTrigger = "tokenBasedTrigger"
        }
    }

    public enum TriggerConditionInput: AWSEncodableShape, Sendable {
        /// Message based trigger configuration.
        case messageBasedTrigger(MessageBasedTriggerInput)
        /// Time based trigger configuration.
        case timeBasedTrigger(TimeBasedTriggerInput)
        /// Token based trigger configuration.
        case tokenBasedTrigger(TokenBasedTriggerInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .messageBasedTrigger(let value):
                try container.encode(value, forKey: .messageBasedTrigger)
            case .timeBasedTrigger(let value):
                try container.encode(value, forKey: .timeBasedTrigger)
            case .tokenBasedTrigger(let value):
                try container.encode(value, forKey: .tokenBasedTrigger)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case messageBasedTrigger = "messageBasedTrigger"
            case timeBasedTrigger = "timeBasedTrigger"
            case tokenBasedTrigger = "tokenBasedTrigger"
        }
    }

    // MARK: Shapes

    public struct AgentRuntime: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent runtime.
        public let agentRuntimeArn: String
        /// The unique identifier of the agent runtime.
        public let agentRuntimeId: String
        /// The name of the agent runtime.
        public let agentRuntimeName: String
        /// The version of the agent runtime.
        public let agentRuntimeVersion: String
        /// The description of the agent runtime.
        public let description: String
        /// The timestamp when the agent runtime was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the agent runtime.
        public let status: AgentRuntimeStatus

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeId: String, agentRuntimeName: String, agentRuntimeVersion: String, description: String, lastUpdatedAt: Date, status: AgentRuntimeStatus) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeName = agentRuntimeName
            self.agentRuntimeVersion = agentRuntimeVersion
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeName = "agentRuntimeName"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case description = "description"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
        }
    }

    public struct AgentRuntimeEndpoint: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent runtime associated with the endpoint.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the agent runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The timestamp when the agent runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the agent runtime endpoint.
        public let description: String?
        /// The unique identifier of the agent runtime endpoint.
        public let id: String
        /// The timestamp when the agent runtime endpoint was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The live version of the agent runtime endpoint. This is the version that is currently serving requests.
        public let liveVersion: String?
        /// The name of the agent runtime endpoint.
        public let name: String
        /// The current status of the agent runtime endpoint.
        public let status: AgentRuntimeEndpointStatus
        /// The target version of the agent runtime endpoint. This is the version that the endpoint is being updated to.
        public let targetVersion: String?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, createdAt: Date, description: String? = nil, id: String, lastUpdatedAt: Date, liveVersion: String? = nil, name: String, status: AgentRuntimeEndpointStatus, targetVersion: String? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.liveVersion = liveVersion
            self.name = name
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case liveVersion = "liveVersion"
            case name = "name"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct ApiKeyCredentialProviderItem: AWSDecodableShape {
        /// The timestamp when the API key credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the API key credential provider.
        public let credentialProviderArn: String
        /// The timestamp when the API key credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the API key credential provider.
        public let name: String

        @inlinable
        public init(createdTime: Date, credentialProviderArn: String, lastUpdatedTime: Date, name: String) {
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct AtlassianOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Atlassian OAuth2 provider. This identifier is assigned by Atlassian when you register your application.
        public let clientId: String
        /// The client secret for the Atlassian OAuth2 provider. This secret is assigned by Atlassian and used along with the client ID to authenticate your application.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct AtlassianOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the Atlassian OAuth2 provider.
        public let clientId: String?
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct BrowserNetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The network mode for the browser. This field specifies how the browser connects to the network.
        public let networkMode: BrowserNetworkMode
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(networkMode: BrowserNetworkMode, vpcConfig: VpcConfig? = nil) {
            self.networkMode = networkMode
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case networkMode = "networkMode"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct BrowserSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the browser.
        public let browserArn: String
        /// The unique identifier of the browser.
        public let browserId: String
        /// The timestamp when the browser was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the browser.
        public let description: String?
        /// The timestamp when the browser was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the browser.
        public let name: String?
        /// The current status of the browser.
        public let status: BrowserStatus

        @inlinable
        public init(browserArn: String, browserId: String, createdAt: Date, description: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, status: BrowserStatus) {
            self.browserArn = browserArn
            self.browserId = browserId
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserArn = "browserArn"
            case browserId = "browserId"
            case createdAt = "createdAt"
            case description = "description"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct CodeInterpreterNetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The network mode for the code interpreter. This field specifies how the code interpreter connects to the network.
        public let networkMode: CodeInterpreterNetworkMode
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(networkMode: CodeInterpreterNetworkMode, vpcConfig: VpcConfig? = nil) {
            self.networkMode = networkMode
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case networkMode = "networkMode"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct CodeInterpreterSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the code interpreter.
        public let codeInterpreterArn: String
        /// The unique identifier of the code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the code interpreter.
        public let description: String?
        /// The timestamp when the code interpreter was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the code interpreter.
        public let name: String?
        /// The current status of the code interpreter.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterArn: String, codeInterpreterId: String, createdAt: Date, description: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, status: CodeInterpreterStatus) {
            self.codeInterpreterArn = codeInterpreterArn
            self.codeInterpreterId = codeInterpreterId
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterArn = "codeInterpreterArn"
            case codeInterpreterId = "codeInterpreterId"
            case createdAt = "createdAt"
            case description = "description"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct ContainerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ECR URI of the container.
        public let containerUri: String

        @inlinable
        public init(containerUri: String) {
            self.containerUri = containerUri
        }

        public func validate(name: String) throws {
            try self.validate(self.containerUri, name: "containerUri", parent: name, max: 1024)
            try self.validate(self.containerUri, name: "containerUri", parent: name, min: 1)
            try self.validate(self.containerUri, name: "containerUri", parent: name, pattern: "^([0-9]{12})\\.dkr\\.ecr\\.([a-z0-9-]+)\\.amazonaws\\.com/((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*)(?::([^:@]{1,300}))?(?:@(.+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case containerUri = "containerUri"
        }
    }

    public struct CreateAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime to create an endpoint for.
        public let agentRuntimeId: String
        /// The version of the AgentCore Runtime to use for the endpoint.
        public let agentRuntimeVersion: String?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The description of the AgentCore Runtime endpoint.
        public let description: String?
        /// The name of the AgentCore Runtime endpoint.
        public let name: String
        /// A map of tag keys and values to assign to the agent runtime endpoint. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(agentRuntimeId: String, agentRuntimeVersion: String? = nil, clientToken: String? = CreateAgentRuntimeEndpointRequest.idempotencyToken(), description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            try container.encodeIfPresent(self.agentRuntimeVersion, forKey: .agentRuntimeVersion)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, max: 5)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, min: 1)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, pattern: "^([1-9][0-9]{0,4})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeVersion = "agentRuntimeVersion"
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The unique identifier of the AgentCore Runtime.
        public let agentRuntimeId: String?
        /// The timestamp when the AgentCore Runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The name of the AgentCore Runtime endpoint.
        public let endpointName: String?
        /// The current status of the AgentCore Runtime endpoint.
        public let status: AgentRuntimeEndpointStatus
        /// The target version of the AgentCore Runtime for the endpoint.
        public let targetVersion: String

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, agentRuntimeId: String? = nil, createdAt: Date, endpointName: String? = nil, status: AgentRuntimeEndpointStatus, targetVersion: String) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.agentRuntimeId = agentRuntimeId
            self.createdAt = createdAt
            self.endpointName = endpointName
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case agentRuntimeId = "agentRuntimeId"
            case createdAt = "createdAt"
            case endpointName = "endpointName"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct CreateAgentRuntimeRequest: AWSEncodableShape {
        /// The artifact of the AgentCore Runtime.
        public let agentRuntimeArtifact: AgentRuntimeArtifact
        /// The name of the AgentCore Runtime.
        public let agentRuntimeName: String
        /// The authorizer configuration for the AgentCore Runtime.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The description of the AgentCore Runtime.
        public let description: String?
        /// Environment variables to set in the AgentCore Runtime environment.
        public let environmentVariables: [String: String]?
        /// The life cycle configuration for the AgentCore Runtime.
        public let lifecycleConfiguration: LifecycleConfiguration?
        /// The network configuration for the AgentCore Runtime.
        public let networkConfiguration: NetworkConfiguration
        public let protocolConfiguration: ProtocolConfiguration?
        /// Configuration for HTTP request headers that will be passed through to the runtime.
        public let requestHeaderConfiguration: RequestHeaderConfiguration?
        /// The IAM role ARN that provides permissions for the AgentCore Runtime.
        public let roleArn: String
        /// A map of tag keys and values to assign to the agent runtime. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(agentRuntimeArtifact: AgentRuntimeArtifact, agentRuntimeName: String, authorizerConfiguration: AuthorizerConfiguration? = nil, clientToken: String? = CreateAgentRuntimeRequest.idempotencyToken(), description: String? = nil, environmentVariables: [String: String]? = nil, lifecycleConfiguration: LifecycleConfiguration? = nil, networkConfiguration: NetworkConfiguration, protocolConfiguration: ProtocolConfiguration? = nil, requestHeaderConfiguration: RequestHeaderConfiguration? = nil, roleArn: String, tags: [String: String]? = nil) {
            self.agentRuntimeArtifact = agentRuntimeArtifact
            self.agentRuntimeName = agentRuntimeName
            self.authorizerConfiguration = authorizerConfiguration
            self.clientToken = clientToken
            self.description = description
            self.environmentVariables = environmentVariables
            self.lifecycleConfiguration = lifecycleConfiguration
            self.networkConfiguration = networkConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.requestHeaderConfiguration = requestHeaderConfiguration
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.agentRuntimeArtifact.validate(name: "\(name).agentRuntimeArtifact")
            try self.validate(self.agentRuntimeName, name: "agentRuntimeName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.authorizerConfiguration?.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 100)
                try validate($0.key, name: "environmentVariables.key", parent: name, min: 1)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 5000)
            }
            try self.validate(self.environmentVariables, name: "environmentVariables", parent: name, max: 50)
            try self.networkConfiguration.validate(name: "\(name).networkConfiguration")
            try self.requestHeaderConfiguration?.validate(name: "\(name).requestHeaderConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArtifact = "agentRuntimeArtifact"
            case agentRuntimeName = "agentRuntimeName"
            case authorizerConfiguration = "authorizerConfiguration"
            case clientToken = "clientToken"
            case description = "description"
            case environmentVariables = "environmentVariables"
            case lifecycleConfiguration = "lifecycleConfiguration"
            case networkConfiguration = "networkConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case requestHeaderConfiguration = "requestHeaderConfiguration"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateAgentRuntimeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The unique identifier of the AgentCore Runtime.
        public let agentRuntimeId: String
        /// The version of the AgentCore Runtime.
        public let agentRuntimeVersion: String
        /// The timestamp when the AgentCore Runtime was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The current status of the AgentCore Runtime.
        public let status: AgentRuntimeStatus
        /// The workload identity details for the AgentCore Runtime.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeId: String, agentRuntimeVersion: String, createdAt: Date, status: AgentRuntimeStatus, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.createdAt = createdAt
            self.status = status
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case createdAt = "createdAt"
            case status = "status"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct CreateApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The API key to use for authentication. This value is encrypted and stored securely.
        public let apiKey: String
        /// The name of the API key credential provider. The name must be unique within your account.
        public let name: String
        /// A map of tag keys and values to assign to the API key credential provider. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(apiKey: String, name: String, tags: [String: String]? = nil) {
            self.apiKey = apiKey
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 65536)
            try self.validate(self.apiKey, name: "apiKey", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateApiKeyCredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the secret containing the API key.
        public let apiKeySecretArn: Secret
        /// The Amazon Resource Name (ARN) of the created API key credential provider.
        public let credentialProviderArn: String
        /// The name of the created API key credential provider.
        public let name: String

        @inlinable
        public init(apiKeySecretArn: Secret, credentialProviderArn: String, name: String) {
            self.apiKeySecretArn = apiKeySecretArn
            self.credentialProviderArn = credentialProviderArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySecretArn = "apiKeySecretArn"
            case credentialProviderArn = "credentialProviderArn"
            case name = "name"
        }
    }

    public struct CreateBrowserRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
        public let clientToken: String?
        /// The description of the browser.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the browser to access Amazon Web Services services.
        public let executionRoleArn: String?
        /// The name of the browser. The name must be unique within your account.
        public let name: String
        /// The network configuration for the browser. This configuration specifies the network mode for the browser.
        public let networkConfiguration: BrowserNetworkConfiguration
        /// The recording configuration for the browser. When enabled, browser sessions are recorded and stored in the specified Amazon S3 location.
        public let recording: RecordingConfig?
        /// A map of tag keys and values to assign to the browser. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateBrowserRequest.idempotencyToken(), description: String? = nil, executionRoleArn: String? = nil, name: String, networkConfiguration: BrowserNetworkConfiguration, recording: RecordingConfig? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.recording = recording
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.networkConfiguration.validate(name: "\(name).networkConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
            case recording = "recording"
            case tags = "tags"
        }
    }

    public struct CreateBrowserResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created browser.
        public let browserArn: String
        /// The unique identifier of the created browser.
        public let browserId: String
        /// The timestamp when the browser was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The current status of the browser.
        public let status: BrowserStatus

        @inlinable
        public init(browserArn: String, browserId: String, createdAt: Date, status: BrowserStatus) {
            self.browserArn = browserArn
            self.browserId = browserId
            self.createdAt = createdAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserArn = "browserArn"
            case browserId = "browserId"
            case createdAt = "createdAt"
            case status = "status"
        }
    }

    public struct CreateCodeInterpreterRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
        public let clientToken: String?
        /// The description of the code interpreter.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the code interpreter to access Amazon Web Services services.
        public let executionRoleArn: String?
        /// The name of the code interpreter. The name must be unique within your account.
        public let name: String
        /// The network configuration for the code interpreter. This configuration specifies the network mode for the code interpreter.
        public let networkConfiguration: CodeInterpreterNetworkConfiguration
        /// A map of tag keys and values to assign to the code interpreter. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateCodeInterpreterRequest.idempotencyToken(), description: String? = nil, executionRoleArn: String? = nil, name: String, networkConfiguration: CodeInterpreterNetworkConfiguration, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.networkConfiguration.validate(name: "\(name).networkConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateCodeInterpreterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created code interpreter.
        public let codeInterpreterArn: String
        /// The unique identifier of the created code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The current status of the code interpreter.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterArn: String, codeInterpreterId: String, createdAt: Date, status: CodeInterpreterStatus) {
            self.codeInterpreterArn = codeInterpreterArn
            self.codeInterpreterId = codeInterpreterId
            self.createdAt = createdAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterArn = "codeInterpreterArn"
            case codeInterpreterId = "codeInterpreterId"
            case createdAt = "createdAt"
            case status = "status"
        }
    }

    public struct CreateGatewayRequest: AWSEncodableShape {
        /// The authorizer configuration for the gateway. Required if authorizerType is CUSTOM_JWT.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The type of authorizer to use for the gateway.    CUSTOM_JWT - Authorize with a bearer token.    AWS_IAM - Authorize with your Amazon Web Services IAM credentials.
        public let authorizerType: AuthorizerType
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The description of the gateway.
        public let description: String?
        /// The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
        public let exceptionLevel: ExceptionLevel?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt data associated with the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway. The name must be unique within your account.
        public let name: String
        /// The configuration settings for the protocol specified in the protocolType parameter.
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The protocol type for the gateway.
        public let protocolType: GatewayProtocolType
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the gateway to access Amazon Web Services services.
        public let roleArn: String
        /// A map of key-value pairs to associate with the gateway as metadata tags.
        public let tags: [String: String]?

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, clientToken: String? = CreateGatewayRequest.idempotencyToken(), description: String? = nil, exceptionLevel: ExceptionLevel? = nil, kmsKeyArn: String? = nil, name: String, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String, tags: [String: String]? = nil) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.clientToken = clientToken
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.authorizerConfiguration?.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.protocolConfiguration?.validate(name: "\(name).protocolConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case clientToken = "clientToken"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateGatewayResponse: AWSDecodableShape {
        /// The authorizer configuration for the created gateway.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The type of authorizer used by the gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the gateway.
        public let description: String?
        /// The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
        public let exceptionLevel: ExceptionLevel?
        /// The Amazon Resource Name (ARN) of the created gateway.
        public let gatewayArn: String
        /// The unique identifier of the created gateway.
        public let gatewayId: String
        /// The URL endpoint for the created gateway.
        public let gatewayUrl: String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt data associated with the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway.
        public let name: String
        /// The configuration settings for the protocol used by the gateway.
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The protocol type of the gateway.
        public let protocolType: GatewayProtocolType
        /// The Amazon Resource Name (ARN) of the IAM role associated with the gateway.
        public let roleArn: String?
        /// The current status of the gateway.
        public let status: GatewayStatus
        /// The reasons for the current status of the gateway.
        public let statusReasons: [String]?
        /// The timestamp when the gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The workload identity details for the created gateway.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayArn: String, gatewayId: String, gatewayUrl: String? = nil, kmsKeyArn: String? = nil, name: String, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String? = nil, status: GatewayStatus, statusReasons: [String]? = nil, updatedAt: Date, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
            self.gatewayUrl = gatewayUrl
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
            case gatewayUrl = "gatewayUrl"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct CreateGatewayTargetRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The credential provider configurations for the target. These configurations specify how the gateway authenticates with the target endpoint.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]?
        /// The description of the gateway target.
        public let description: String?
        /// The identifier of the gateway to create a target for.
        public let gatewayIdentifier: String
        /// The name of the gateway target. The name must be unique within the gateway.
        public let name: String
        /// The configuration settings for the target, including endpoint information and schema definitions.
        public let targetConfiguration: TargetConfiguration

        @inlinable
        public init(clientToken: String? = CreateGatewayTargetRequest.idempotencyToken(), credentialProviderConfigurations: [CredentialProviderConfiguration]? = nil, description: String? = nil, gatewayIdentifier: String, name: String, targetConfiguration: TargetConfiguration) {
            self.clientToken = clientToken
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayIdentifier = gatewayIdentifier
            self.name = name
            self.targetConfiguration = targetConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.credentialProviderConfigurations, forKey: .credentialProviderConfigurations)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.targetConfiguration, forKey: .targetConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.credentialProviderConfigurations?.forEach {
                try $0.validate(name: "\(name).credentialProviderConfigurations[]")
            }
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, max: 1)
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.targetConfiguration.validate(name: "\(name).targetConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case name = "name"
            case targetConfiguration = "targetConfiguration"
        }
    }

    public struct CreateGatewayTargetResponse: AWSDecodableShape {
        /// The timestamp when the target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The credential provider configurations for the target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The description of the target.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the gateway.
        public let gatewayArn: String
        /// The last synchronization of the target.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastSynchronizedAt: Date?
        /// The name of the target.
        public let name: String
        /// The current status of the target.
        public let status: TargetStatus
        /// The reasons for the current status of the target.
        public let statusReasons: [String]?
        /// The configuration settings for the target.
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the created target.
        public let targetId: String
        /// The timestamp when the target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayArn: String, lastSynchronizedAt: Date? = nil, name: String, status: TargetStatus, statusReasons: [String]? = nil, targetConfiguration: TargetConfiguration, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayArn = gatewayArn
            self.lastSynchronizedAt = lastSynchronizedAt
            self.name = name
            self.status = status
            self.statusReasons = statusReasons
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case gatewayArn = "gatewayArn"
            case lastSynchronizedAt = "lastSynchronizedAt"
            case name = "name"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetConfiguration = "targetConfiguration"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateMemoryInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
        public let clientToken: String?
        /// The description of the memory.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the memory data.
        public let encryptionKeyArn: String?
        /// The duration after which memory events expire. Specified as an ISO 8601 duration.
        public let eventExpiryDuration: Int
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the memory to access Amazon Web Services services.
        public let memoryExecutionRoleArn: String?
        /// The memory strategies to use for this memory. Strategies define how information is extracted, processed, and consolidated.
        public let memoryStrategies: [MemoryStrategyInput]?
        /// The name of the memory. The name must be unique within your account.
        public let name: String
        /// A map of tag keys and values to assign to an AgentCore Memory. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateMemoryInput.idempotencyToken(), description: String? = nil, encryptionKeyArn: String? = nil, eventExpiryDuration: Int, memoryExecutionRoleArn: String? = nil, memoryStrategies: [MemoryStrategyInput]? = nil, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.encryptionKeyArn = encryptionKeyArn
            self.eventExpiryDuration = eventExpiryDuration
            self.memoryExecutionRoleArn = memoryExecutionRoleArn
            self.memoryStrategies = memoryStrategies
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memoryExecutionRoleArn, name: "memoryExecutionRoleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.memoryStrategies?.forEach {
                try $0.validate(name: "\(name).memoryStrategies[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case encryptionKeyArn = "encryptionKeyArn"
            case eventExpiryDuration = "eventExpiryDuration"
            case memoryExecutionRoleArn = "memoryExecutionRoleArn"
            case memoryStrategies = "memoryStrategies"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateMemoryOutput: AWSDecodableShape {
        /// The details of the created memory, including its ID, ARN, name, description, and configuration settings.
        public let memory: Memory?

        @inlinable
        public init(memory: Memory? = nil) {
            self.memory = memory
        }

        private enum CodingKeys: String, CodingKey {
            case memory = "memory"
        }
    }

    public struct CreateOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The vendor of the OAuth2 credential provider. This specifies which OAuth2 implementation to use.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The name of the OAuth2 credential provider. The name must be unique within your account.
        public let name: String
        /// The configuration settings for the OAuth2 provider, including client ID, client secret, and other vendor-specific settings.
        public let oauth2ProviderConfigInput: Oauth2ProviderConfigInput
        /// A map of tag keys and values to assign to the OAuth2 credential provider. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(credentialProviderVendor: CredentialProviderVendorType, name: String, oauth2ProviderConfigInput: Oauth2ProviderConfigInput, tags: [String: String]? = nil) {
            self.credentialProviderVendor = credentialProviderVendor
            self.name = name
            self.oauth2ProviderConfigInput = oauth2ProviderConfigInput
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.oauth2ProviderConfigInput.validate(name: "\(name).oauth2ProviderConfigInput")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviderVendor = "credentialProviderVendor"
            case name = "name"
            case oauth2ProviderConfigInput = "oauth2ProviderConfigInput"
            case tags = "tags"
        }
    }

    public struct CreateOauth2CredentialProviderResponse: AWSDecodableShape {
        /// Callback URL to register on the OAuth2 credential provider as an allowed callback URL. This URL is where the OAuth2 authorization server redirects users after they complete the authorization flow.
        public let callbackUrl: String?
        /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
        public let clientSecretArn: Secret
        /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
        public let credentialProviderArn: String
        /// The name of the OAuth2 credential provider.
        public let name: String
        public let oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput?

        @inlinable
        public init(callbackUrl: String? = nil, clientSecretArn: Secret, credentialProviderArn: String, name: String, oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput? = nil) {
            self.callbackUrl = callbackUrl
            self.clientSecretArn = clientSecretArn
            self.credentialProviderArn = credentialProviderArn
            self.name = name
            self.oauth2ProviderConfigOutput = oauth2ProviderConfigOutput
        }

        private enum CodingKeys: String, CodingKey {
            case callbackUrl = "callbackUrl"
            case clientSecretArn = "clientSecretArn"
            case credentialProviderArn = "credentialProviderArn"
            case name = "name"
            case oauth2ProviderConfigOutput = "oauth2ProviderConfigOutput"
        }
    }

    public struct CreateWorkloadIdentityRequest: AWSEncodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The name of the workload identity. The name must be unique within your account.
        public let name: String
        /// A map of tag keys and values to assign to the workload identity. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, name: String, tags: [String: String]? = nil) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.allowedResourceOauth2ReturnUrls?.forEach {
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, max: 2048)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, min: 1)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, pattern: "^\\w+:(\\/?\\/?)[^\\s]+$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateWorkloadIdentityResponse: AWSDecodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, name: String, workloadIdentityArn: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct CredentialProviderConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The credential provider. This field contains the specific configuration for the credential provider type.
        public let credentialProvider: CredentialProvider?
        /// The type of credential provider. This field specifies which authentication method the gateway uses.
        public let credentialProviderType: CredentialProviderType

        @inlinable
        public init(credentialProvider: CredentialProvider? = nil, credentialProviderType: CredentialProviderType) {
            self.credentialProvider = credentialProvider
            self.credentialProviderType = credentialProviderType
        }

        public func validate(name: String) throws {
            try self.credentialProvider?.validate(name: "\(name).credentialProvider")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProvider = "credentialProvider"
            case credentialProviderType = "credentialProviderType"
        }
    }

    public struct CustomJWTAuthorizerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Represents individual audience values that are validated in the incoming JWT token validation process.
        public let allowedAudience: [String]?
        /// Represents individual client IDs that are validated in the incoming JWT token validation process.
        public let allowedClients: [String]?
        /// This URL is used to fetch OpenID Connect configuration or authorization server metadata for validating incoming tokens.
        public let discoveryUrl: String

        @inlinable
        public init(allowedAudience: [String]? = nil, allowedClients: [String]? = nil, discoveryUrl: String) {
            self.allowedAudience = allowedAudience
            self.allowedClients = allowedClients
            self.discoveryUrl = discoveryUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.allowedAudience, name: "allowedAudience", parent: name, min: 1)
            try self.validate(self.allowedClients, name: "allowedClients", parent: name, min: 1)
            try self.validate(self.discoveryUrl, name: "discoveryUrl", parent: name, pattern: "^.+/\\.well-known/openid-configuration$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAudience = "allowedAudience"
            case allowedClients = "allowedClients"
            case discoveryUrl = "discoveryUrl"
        }
    }

    public struct CustomMemoryStrategyInput: AWSEncodableShape {
        /// The configuration for the custom memory strategy.
        public let configuration: CustomConfigurationInput?
        /// The description of the custom memory strategy.
        public let description: String?
        /// The name of the custom memory strategy.
        public let name: String
        /// The namespaces associated with the custom memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(configuration: CustomConfigurationInput? = nil, description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct CustomOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the custom OAuth2 provider.
        public let clientId: String
        /// The client secret for the custom OAuth2 provider.
        public let clientSecret: String
        /// The OAuth2 discovery information for the custom provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String, clientSecret: String, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oauthDiscovery = oauthDiscovery
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
            try self.oauthDiscovery.validate(name: "\(name).oauthDiscovery")
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct CustomOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the custom OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the custom provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct DeleteAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime associated with the endpoint.
        public let agentRuntimeId: String
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The name of the AgentCore Runtime endpoint to delete.
        public let endpointName: String

        @inlinable
        public init(agentRuntimeId: String, clientToken: String? = DeleteAgentRuntimeEndpointRequest.idempotencyToken(), endpointName: String) {
            self.agentRuntimeId = agentRuntimeId
            self.clientToken = clientToken
            self.endpointName = endpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.endpointName, key: "endpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The unique identifier of the AgentCore Runtime.
        public let agentRuntimeId: String?
        /// The name of the AgentCore Runtime endpoint.
        public let endpointName: String?
        /// The current status of the AgentCore Runtime endpoint deletion.
        public let status: AgentRuntimeEndpointStatus

        @inlinable
        public init(agentRuntimeId: String? = nil, endpointName: String? = nil, status: AgentRuntimeEndpointStatus) {
            self.agentRuntimeId = agentRuntimeId
            self.endpointName = endpointName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeId = "agentRuntimeId"
            case endpointName = "endpointName"
            case status = "status"
        }
    }

    public struct DeleteAgentRuntimeRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime to delete.
        public let agentRuntimeId: String

        @inlinable
        public init(agentRuntimeId: String) {
            self.agentRuntimeId = agentRuntimeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentRuntimeResponse: AWSDecodableShape {
        /// The unique identifier of the AgentCore Runtime.
        public let agentRuntimeId: String?
        /// The current status of the AgentCore Runtime deletion.
        public let status: AgentRuntimeStatus

        @inlinable
        public init(agentRuntimeId: String? = nil, status: AgentRuntimeStatus) {
            self.agentRuntimeId = agentRuntimeId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeId = "agentRuntimeId"
            case status = "status"
        }
    }

    public struct DeleteApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The name of the API key credential provider to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteApiKeyCredentialProviderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteBrowserRequest: AWSEncodableShape {
        /// The unique identifier of the browser to delete.
        public let browserId: String
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?

        @inlinable
        public init(browserId: String, clientToken: String? = DeleteBrowserRequest.idempotencyToken()) {
            self.browserId = browserId
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserId, key: "browserId")
            request.encodeQuery(self.clientToken, key: "clientToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserId, name: "browserId", parent: name, pattern: "^(aws\\.browser\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBrowserResponse: AWSDecodableShape {
        /// The unique identifier of the deleted browser.
        public let browserId: String
        /// The timestamp when the browser was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the browser deletion.
        public let status: BrowserStatus

        @inlinable
        public init(browserId: String, lastUpdatedAt: Date, status: BrowserStatus) {
            self.browserId = browserId
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserId = "browserId"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
        }
    }

    public struct DeleteCodeInterpreterRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the code interpreter to delete.
        public let codeInterpreterId: String

        @inlinable
        public init(clientToken: String? = DeleteCodeInterpreterRequest.idempotencyToken(), codeInterpreterId: String) {
            self.clientToken = clientToken
            self.codeInterpreterId = codeInterpreterId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.codeInterpreterId, key: "codeInterpreterId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.codeInterpreterId, name: "codeInterpreterId", parent: name, pattern: "^(aws\\.codeinterpreter\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCodeInterpreterResponse: AWSDecodableShape {
        /// The unique identifier of the deleted code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the code interpreter deletion.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterId: String, lastUpdatedAt: Date, status: CodeInterpreterStatus) {
            self.codeInterpreterId = codeInterpreterId
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterId = "codeInterpreterId"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
        }
    }

    public struct DeleteGatewayRequest: AWSEncodableShape {
        /// The identifier of the gateway to delete.
        public let gatewayIdentifier: String

        @inlinable
        public init(gatewayIdentifier: String) {
            self.gatewayIdentifier = gatewayIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGatewayResponse: AWSDecodableShape {
        /// The unique identifier of the deleted gateway.
        public let gatewayId: String
        /// The current status of the gateway deletion.
        public let status: GatewayStatus
        /// The reasons for the current status of the gateway deletion.
        public let statusReasons: [String]?

        @inlinable
        public init(gatewayId: String, status: GatewayStatus, statusReasons: [String]? = nil) {
            self.gatewayId = gatewayId
            self.status = status
            self.statusReasons = statusReasons
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayId = "gatewayId"
            case status = "status"
            case statusReasons = "statusReasons"
        }
    }

    public struct DeleteGatewayTargetRequest: AWSEncodableShape {
        /// The unique identifier of the gateway associated with the target.
        public let gatewayIdentifier: String
        /// The unique identifier of the gateway target to delete.
        public let targetId: String

        @inlinable
        public init(gatewayIdentifier: String, targetId: String) {
            self.gatewayIdentifier = gatewayIdentifier
            self.targetId = targetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            request.encodePath(self.targetId, key: "targetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.targetId, name: "targetId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGatewayTargetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the gateway.
        public let gatewayArn: String
        /// The current status of the gateway target deletion.
        public let status: TargetStatus
        /// The reasons for the current status of the gateway target deletion.
        public let statusReasons: [String]?
        /// The unique identifier of the deleted gateway target.
        public let targetId: String

        @inlinable
        public init(gatewayArn: String, status: TargetStatus, statusReasons: [String]? = nil, targetId: String) {
            self.gatewayArn = gatewayArn
            self.status = status
            self.statusReasons = statusReasons
            self.targetId = targetId
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayArn = "gatewayArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetId = "targetId"
        }
    }

    public struct DeleteMemoryInput: AWSEncodableShape {
        /// A client token is used for keeping track of idempotent requests. It can contain a session id which can be around 250 chars, combined with a unique AWS identifier.
        public let clientToken: String?
        /// The unique identifier of the memory to delete.
        public let memoryId: String

        @inlinable
        public init(clientToken: String? = DeleteMemoryInput.idempotencyToken(), memoryId: String) {
            self.clientToken = clientToken
            self.memoryId = memoryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.memoryId, key: "memoryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemoryOutput: AWSDecodableShape {
        /// The unique identifier of the deleted AgentCore Memory resource.
        public let memoryId: String
        /// The current status of the AgentCore Memory resource deletion.
        public let status: MemoryStatus?

        @inlinable
        public init(memoryId: String, status: MemoryStatus? = nil) {
            self.memoryId = memoryId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case memoryId = "memoryId"
            case status = "status"
        }
    }

    public struct DeleteMemoryStrategyInput: AWSEncodableShape {
        /// The unique identifier of the memory strategy to delete.
        public let memoryStrategyId: String

        @inlinable
        public init(memoryStrategyId: String) {
            self.memoryStrategyId = memoryStrategyId
        }

        private enum CodingKeys: String, CodingKey {
            case memoryStrategyId = "memoryStrategyId"
        }
    }

    public struct DeleteOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The name of the OAuth2 credential provider to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteOauth2CredentialProviderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWorkloadIdentityRequest: AWSEncodableShape {
        /// The name of the workload identity to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteWorkloadIdentityResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GatewayApiKeyCredentialProvider: AWSEncodableShape & AWSDecodableShape {
        /// The location of the API key credential. This field specifies where in the request the API key should be placed.
        public let credentialLocation: ApiKeyCredentialLocation?
        /// The name of the credential parameter for the API key. This parameter name is used when sending the API key to the target endpoint.
        public let credentialParameterName: String?
        /// The prefix for the API key credential. This prefix is added to the API key when sending it to the target endpoint.
        public let credentialPrefix: String?
        /// The Amazon Resource Name (ARN) of the API key credential provider. This ARN identifies the provider in Amazon Web Services.
        public let providerArn: String

        @inlinable
        public init(credentialLocation: ApiKeyCredentialLocation? = nil, credentialParameterName: String? = nil, credentialPrefix: String? = nil, providerArn: String) {
            self.credentialLocation = credentialLocation
            self.credentialParameterName = credentialParameterName
            self.credentialPrefix = credentialPrefix
            self.providerArn = providerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialParameterName, name: "credentialParameterName", parent: name, max: 64)
            try self.validate(self.credentialParameterName, name: "credentialParameterName", parent: name, min: 1)
            try self.validate(self.credentialPrefix, name: "credentialPrefix", parent: name, max: 64)
            try self.validate(self.credentialPrefix, name: "credentialPrefix", parent: name, min: 1)
            try self.validate(self.providerArn, name: "providerArn", parent: name, pattern: "^arn:([^:]*):([^:]*):([^:]*):([0-9]{12})?:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialLocation = "credentialLocation"
            case credentialParameterName = "credentialParameterName"
            case credentialPrefix = "credentialPrefix"
            case providerArn = "providerArn"
        }
    }

    public struct GatewaySummary: AWSDecodableShape {
        /// The type of authorizer used by the gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the gateway.
        public let description: String?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The name of the gateway.
        public let name: String
        /// The protocol type used by the gateway.
        public let protocolType: GatewayProtocolType
        /// The current status of the gateway.
        public let status: GatewayStatus
        /// The timestamp when the gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, gatewayId: String, name: String, protocolType: GatewayProtocolType, status: GatewayStatus, updatedAt: Date) {
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.gatewayId = gatewayId
            self.name = name
            self.protocolType = protocolType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case gatewayId = "gatewayId"
            case name = "name"
            case protocolType = "protocolType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GatewayTarget: AWSDecodableShape {
        /// The date and time at which the target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The provider configurations.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The description for the gateway target.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the gateway target.
        public let gatewayArn: String
        /// The last synchronization time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastSynchronizedAt: Date?
        /// The name of the gateway target.
        public let name: String
        /// The status of the gateway target.
        public let status: TargetStatus
        /// The status reasons for the target status.
        public let statusReasons: [String]?
        public let targetConfiguration: TargetConfiguration
        /// The target ID.
        public let targetId: String
        /// The date and time at which the target was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayArn: String, lastSynchronizedAt: Date? = nil, name: String, status: TargetStatus, statusReasons: [String]? = nil, targetConfiguration: TargetConfiguration, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayArn = gatewayArn
            self.lastSynchronizedAt = lastSynchronizedAt
            self.name = name
            self.status = status
            self.statusReasons = statusReasons
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case gatewayArn = "gatewayArn"
            case lastSynchronizedAt = "lastSynchronizedAt"
            case name = "name"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetConfiguration = "targetConfiguration"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime associated with the endpoint.
        public let agentRuntimeId: String
        /// The name of the AgentCore Runtime endpoint to retrieve.
        public let endpointName: String

        @inlinable
        public init(agentRuntimeId: String, endpointName: String) {
            self.agentRuntimeId = agentRuntimeId
            self.endpointName = endpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodePath(self.endpointName, key: "endpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The timestamp when the AgentCore Runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the AgentCore Runtime endpoint.
        public let description: String?
        /// The reason for failure if the AgentCore Runtime endpoint is in a failed state.
        public let failureReason: String?
        /// The unique identifier of the AgentCore Runtime endpoint.
        public let id: String
        /// The timestamp when the AgentCore Runtime endpoint was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The currently deployed version of the AgentCore Runtime on the endpoint.
        public let liveVersion: String?
        /// The name of the AgentCore Runtime endpoint.
        public let name: String
        /// The current status of the AgentCore Runtime endpoint.
        public let status: AgentRuntimeEndpointStatus
        /// The target version of the AgentCore Runtime for the endpoint.
        public let targetVersion: String?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, createdAt: Date, description: String? = nil, failureReason: String? = nil, id: String, lastUpdatedAt: Date, liveVersion: String? = nil, name: String, status: AgentRuntimeEndpointStatus, targetVersion: String? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.createdAt = createdAt
            self.description = description
            self.failureReason = failureReason
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.liveVersion = liveVersion
            self.name = name
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case createdAt = "createdAt"
            case description = "description"
            case failureReason = "failureReason"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case liveVersion = "liveVersion"
            case name = "name"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct GetAgentRuntimeRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime to retrieve.
        public let agentRuntimeId: String
        /// The version of the AgentCore Runtime to retrieve.
        public let agentRuntimeVersion: String?

        @inlinable
        public init(agentRuntimeId: String, agentRuntimeVersion: String? = nil) {
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.agentRuntimeVersion, key: "version")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, max: 5)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, min: 1)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, pattern: "^([1-9][0-9]{0,4})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentRuntimeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The artifact of the AgentCore Runtime.
        public let agentRuntimeArtifact: AgentRuntimeArtifact?
        /// The unique identifier of the AgentCore Runtime.
        public let agentRuntimeId: String
        /// The name of the AgentCore Runtime.
        public let agentRuntimeName: String
        /// The version of the AgentCore Runtime.
        public let agentRuntimeVersion: String
        /// The authorizer configuration for the AgentCore Runtime.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The timestamp when the AgentCore Runtime was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the AgentCore Runtime.
        public let description: String?
        /// Environment variables set in the AgentCore Runtime environment.
        public let environmentVariables: [String: String]?
        /// The timestamp when the AgentCore Runtime was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The life cycle configuration for the AgentCore Runtime.
        public let lifecycleConfiguration: LifecycleConfiguration
        /// The network configuration for the AgentCore Runtime.
        public let networkConfiguration: NetworkConfiguration
        public let protocolConfiguration: ProtocolConfiguration?
        /// Configuration for HTTP request headers that will be passed through to the runtime.
        public let requestHeaderConfiguration: RequestHeaderConfiguration?
        /// The IAM role ARN that provides permissions for the AgentCore Runtime.
        public let roleArn: String
        /// The current status of the AgentCore Runtime.
        public let status: AgentRuntimeStatus
        /// The workload identity details for the AgentCore Runtime.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeArtifact: AgentRuntimeArtifact? = nil, agentRuntimeId: String, agentRuntimeName: String, agentRuntimeVersion: String, authorizerConfiguration: AuthorizerConfiguration? = nil, createdAt: Date, description: String? = nil, environmentVariables: [String: String]? = nil, lastUpdatedAt: Date, lifecycleConfiguration: LifecycleConfiguration, networkConfiguration: NetworkConfiguration, protocolConfiguration: ProtocolConfiguration? = nil, requestHeaderConfiguration: RequestHeaderConfiguration? = nil, roleArn: String, status: AgentRuntimeStatus, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeArtifact = agentRuntimeArtifact
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeName = agentRuntimeName
            self.agentRuntimeVersion = agentRuntimeVersion
            self.authorizerConfiguration = authorizerConfiguration
            self.createdAt = createdAt
            self.description = description
            self.environmentVariables = environmentVariables
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleConfiguration = lifecycleConfiguration
            self.networkConfiguration = networkConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.requestHeaderConfiguration = requestHeaderConfiguration
            self.roleArn = roleArn
            self.status = status
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeArtifact = "agentRuntimeArtifact"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeName = "agentRuntimeName"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case authorizerConfiguration = "authorizerConfiguration"
            case createdAt = "createdAt"
            case description = "description"
            case environmentVariables = "environmentVariables"
            case lastUpdatedAt = "lastUpdatedAt"
            case lifecycleConfiguration = "lifecycleConfiguration"
            case networkConfiguration = "networkConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case requestHeaderConfiguration = "requestHeaderConfiguration"
            case roleArn = "roleArn"
            case status = "status"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct GetApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The name of the API key credential provider to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetApiKeyCredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the API key secret in AWS Secrets Manager.
        public let apiKeySecretArn: Secret
        /// The timestamp when the API key credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the API key credential provider.
        public let credentialProviderArn: String
        /// The timestamp when the API key credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the API key credential provider.
        public let name: String

        @inlinable
        public init(apiKeySecretArn: Secret, createdTime: Date, credentialProviderArn: String, lastUpdatedTime: Date, name: String) {
            self.apiKeySecretArn = apiKeySecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySecretArn = "apiKeySecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct GetBrowserRequest: AWSEncodableShape {
        /// The unique identifier of the browser to retrieve.
        public let browserId: String

        @inlinable
        public init(browserId: String) {
            self.browserId = browserId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserId, key: "browserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserId, name: "browserId", parent: name, pattern: "^(aws\\.browser\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBrowserResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the browser.
        public let browserArn: String
        /// The unique identifier of the browser.
        public let browserId: String
        /// The timestamp when the browser was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the browser.
        public let description: String?
        /// The IAM role ARN that provides permissions for the browser.
        public let executionRoleArn: String?
        /// The reason for failure if the browser is in a failed state.
        public let failureReason: String?
        /// The timestamp when the browser was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The name of the browser.
        public let name: String
        public let networkConfiguration: BrowserNetworkConfiguration
        public let recording: RecordingConfig?
        /// The current status of the browser.
        public let status: BrowserStatus

        @inlinable
        public init(browserArn: String, browserId: String, createdAt: Date, description: String? = nil, executionRoleArn: String? = nil, failureReason: String? = nil, lastUpdatedAt: Date, name: String, networkConfiguration: BrowserNetworkConfiguration, recording: RecordingConfig? = nil, status: BrowserStatus) {
            self.browserArn = browserArn
            self.browserId = browserId
            self.createdAt = createdAt
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.failureReason = failureReason
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.recording = recording
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserArn = "browserArn"
            case browserId = "browserId"
            case createdAt = "createdAt"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case failureReason = "failureReason"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
            case recording = "recording"
            case status = "status"
        }
    }

    public struct GetCodeInterpreterRequest: AWSEncodableShape {
        /// The unique identifier of the code interpreter to retrieve.
        public let codeInterpreterId: String

        @inlinable
        public init(codeInterpreterId: String) {
            self.codeInterpreterId = codeInterpreterId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.codeInterpreterId, key: "codeInterpreterId")
        }

        public func validate(name: String) throws {
            try self.validate(self.codeInterpreterId, name: "codeInterpreterId", parent: name, pattern: "^(aws\\.codeinterpreter\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodeInterpreterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the code interpreter.
        public let codeInterpreterArn: String
        /// The unique identifier of the code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the code interpreter.
        public let description: String?
        /// The IAM role ARN that provides permissions for the code interpreter.
        public let executionRoleArn: String?
        /// The reason for failure if the code interpreter is in a failed state.
        public let failureReason: String?
        /// The timestamp when the code interpreter was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The name of the code interpreter.
        public let name: String
        public let networkConfiguration: CodeInterpreterNetworkConfiguration
        /// The current status of the code interpreter.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterArn: String, codeInterpreterId: String, createdAt: Date, description: String? = nil, executionRoleArn: String? = nil, failureReason: String? = nil, lastUpdatedAt: Date, name: String, networkConfiguration: CodeInterpreterNetworkConfiguration, status: CodeInterpreterStatus) {
            self.codeInterpreterArn = codeInterpreterArn
            self.codeInterpreterId = codeInterpreterId
            self.createdAt = createdAt
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.failureReason = failureReason
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterArn = "codeInterpreterArn"
            case codeInterpreterId = "codeInterpreterId"
            case createdAt = "createdAt"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case failureReason = "failureReason"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
            case status = "status"
        }
    }

    public struct GetGatewayRequest: AWSEncodableShape {
        /// The identifier of the gateway to retrieve.
        public let gatewayIdentifier: String

        @inlinable
        public init(gatewayIdentifier: String) {
            self.gatewayIdentifier = gatewayIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGatewayResponse: AWSDecodableShape {
        /// The authorizer configuration for the gateway.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// Authorizer type for the gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the gateway.
        public let description: String?
        /// The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
        public let exceptionLevel: ExceptionLevel?
        /// The Amazon Resource Name (ARN) of the gateway.
        public let gatewayArn: String
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// An endpoint for invoking gateway.
        public let gatewayUrl: String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway.
        public let name: String
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// Protocol applied to a gateway.
        public let protocolType: GatewayProtocolType
        /// The IAM role ARN that provides permissions for the gateway.
        public let roleArn: String?
        /// The current status of the gateway.
        public let status: GatewayStatus
        /// The reasons for the current status of the gateway.
        public let statusReasons: [String]?
        /// The timestamp when the gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The workload identity details for the gateway.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayArn: String, gatewayId: String, gatewayUrl: String? = nil, kmsKeyArn: String? = nil, name: String, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String? = nil, status: GatewayStatus, statusReasons: [String]? = nil, updatedAt: Date, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
            self.gatewayUrl = gatewayUrl
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
            case gatewayUrl = "gatewayUrl"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct GetGatewayTargetRequest: AWSEncodableShape {
        /// The identifier of the gateway that contains the target.
        public let gatewayIdentifier: String
        /// The unique identifier of the target to retrieve.
        public let targetId: String

        @inlinable
        public init(gatewayIdentifier: String, targetId: String) {
            self.gatewayIdentifier = gatewayIdentifier
            self.targetId = targetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            request.encodePath(self.targetId, key: "targetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.targetId, name: "targetId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGatewayTargetResponse: AWSDecodableShape {
        /// The timestamp when the gateway target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The credential provider configurations for the gateway target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The description of the gateway target.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the gateway.
        public let gatewayArn: String
        /// The last synchronization of the target.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastSynchronizedAt: Date?
        /// The name of the gateway target.
        public let name: String
        /// The current status of the gateway target.
        public let status: TargetStatus
        /// The reasons for the current status of the gateway target.
        public let statusReasons: [String]?
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the gateway target.
        public let targetId: String
        /// The timestamp when the gateway target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayArn: String, lastSynchronizedAt: Date? = nil, name: String, status: TargetStatus, statusReasons: [String]? = nil, targetConfiguration: TargetConfiguration, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayArn = gatewayArn
            self.lastSynchronizedAt = lastSynchronizedAt
            self.name = name
            self.status = status
            self.statusReasons = statusReasons
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case gatewayArn = "gatewayArn"
            case lastSynchronizedAt = "lastSynchronizedAt"
            case name = "name"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetConfiguration = "targetConfiguration"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetMemoryInput: AWSEncodableShape {
        /// The unique identifier of the memory to retrieve.
        public let memoryId: String

        @inlinable
        public init(memoryId: String) {
            self.memoryId = memoryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.memoryId, key: "memoryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMemoryOutput: AWSDecodableShape {
        /// The retrieved AgentCore Memory resource details.
        public let memory: Memory

        @inlinable
        public init(memory: Memory) {
            self.memory = memory
        }

        private enum CodingKeys: String, CodingKey {
            case memory = "memory"
        }
    }

    public struct GetOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The name of the OAuth2 credential provider to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetOauth2CredentialProviderResponse: AWSDecodableShape {
        /// Callback URL to register on the OAuth2 credential provider as an allowed callback URL. This URL is where the OAuth2 authorization server redirects users after they complete the authorization flow.
        public let callbackUrl: String?
        /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
        public let clientSecretArn: Secret
        /// The timestamp when the OAuth2 credential provider was created.
        public let createdTime: Date
        /// ARN of the credential provider requested.
        public let credentialProviderArn: String
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The timestamp when the OAuth2 credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the OAuth2 credential provider.
        public let name: String
        /// The configuration output for the OAuth2 provider.
        public let oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput

        @inlinable
        public init(callbackUrl: String? = nil, clientSecretArn: Secret, createdTime: Date, credentialProviderArn: String, credentialProviderVendor: CredentialProviderVendorType, lastUpdatedTime: Date, name: String, oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput) {
            self.callbackUrl = callbackUrl
            self.clientSecretArn = clientSecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.credentialProviderVendor = credentialProviderVendor
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.oauth2ProviderConfigOutput = oauth2ProviderConfigOutput
        }

        private enum CodingKeys: String, CodingKey {
            case callbackUrl = "callbackUrl"
            case clientSecretArn = "clientSecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case credentialProviderVendor = "credentialProviderVendor"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case oauth2ProviderConfigOutput = "oauth2ProviderConfigOutput"
        }
    }

    public struct GetTokenVaultRequest: AWSEncodableShape {
        /// The unique identifier of the token vault to retrieve.
        public let tokenVaultId: String?

        @inlinable
        public init(tokenVaultId: String? = nil) {
            self.tokenVaultId = tokenVaultId
        }

        public func validate(name: String) throws {
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, max: 64)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, min: 1)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct GetTokenVaultResponse: AWSDecodableShape {
        /// The KMS configuration for the token vault.
        public let kmsConfiguration: KmsConfiguration
        /// The timestamp when the token vault was last modified.
        public let lastModifiedDate: Date
        /// The ID of the token vault.
        public let tokenVaultId: String

        @inlinable
        public init(kmsConfiguration: KmsConfiguration, lastModifiedDate: Date, tokenVaultId: String) {
            self.kmsConfiguration = kmsConfiguration
            self.lastModifiedDate = lastModifiedDate
            self.tokenVaultId = tokenVaultId
        }

        private enum CodingKeys: String, CodingKey {
            case kmsConfiguration = "kmsConfiguration"
            case lastModifiedDate = "lastModifiedDate"
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct GetWorkloadIdentityRequest: AWSEncodableShape {
        /// The name of the workload identity to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetWorkloadIdentityResponse: AWSDecodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The timestamp when the workload identity was created.
        public let createdTime: Date
        /// The timestamp when the workload identity was last updated.
        public let lastUpdatedTime: Date
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, createdTime: Date, lastUpdatedTime: Date, name: String, workloadIdentityArn: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case createdTime = "createdTime"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct GithubOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the GitHub OAuth2 provider.
        public let clientId: String
        /// The client secret for the GitHub OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct GithubOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the GitHub OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the GitHub provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct GoogleOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Google OAuth2 provider.
        public let clientId: String
        /// The client secret for the Google OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct GoogleOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the Google OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the Google provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct IncludedOauth2ProviderConfigInput: AWSEncodableShape {
        /// OAuth2 authorization endpoint for your isolated OAuth2 application tenant. This is where users are redirected to authenticate and authorize access to their resources.
        public let authorizationEndpoint: String?
        /// The client ID for the supported OAuth2 provider. This identifier is assigned by the OAuth2 provider when you register your application.
        public let clientId: String
        /// The client secret for the supported OAuth2 provider. This secret is assigned by the OAuth2 provider and used along with the client ID to authenticate your application.
        public let clientSecret: String
        /// Token issuer of your isolated OAuth2 application tenant. This URL identifies the authorization server that issues tokens for this provider.
        public let issuer: String?
        /// OAuth2 token endpoint for your isolated OAuth2 application tenant. This is where authorization codes are exchanged for access tokens.
        public let tokenEndpoint: String?

        @inlinable
        public init(authorizationEndpoint: String? = nil, clientId: String, clientSecret: String, issuer: String? = nil, tokenEndpoint: String? = nil) {
            self.authorizationEndpoint = authorizationEndpoint
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.issuer = issuer
            self.tokenEndpoint = tokenEndpoint
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationEndpoint = "authorizationEndpoint"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case issuer = "issuer"
            case tokenEndpoint = "tokenEndpoint"
        }
    }

    public struct IncludedOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the supported OAuth2 provider.
        public let clientId: String?
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct InvocationConfiguration: AWSDecodableShape {
        /// The S3 bucket name for event payload delivery.
        public let payloadDeliveryBucketName: String
        /// The ARN of the SNS topic for job notifications.
        public let topicArn: String

        @inlinable
        public init(payloadDeliveryBucketName: String, topicArn: String) {
            self.payloadDeliveryBucketName = payloadDeliveryBucketName
            self.topicArn = topicArn
        }

        private enum CodingKeys: String, CodingKey {
            case payloadDeliveryBucketName = "payloadDeliveryBucketName"
            case topicArn = "topicArn"
        }
    }

    public struct InvocationConfigurationInput: AWSEncodableShape {
        /// The S3 bucket name for event payload delivery.
        public let payloadDeliveryBucketName: String
        /// The ARN of the SNS topic for job notifications.
        public let topicArn: String

        @inlinable
        public init(payloadDeliveryBucketName: String, topicArn: String) {
            self.payloadDeliveryBucketName = payloadDeliveryBucketName
            self.topicArn = topicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.topicArn, name: "topicArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case payloadDeliveryBucketName = "payloadDeliveryBucketName"
            case topicArn = "topicArn"
        }
    }

    public struct KmsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of KMS key (CustomerManagedKey or ServiceManagedKey).
        public let keyType: KeyType
        /// The Amazon Resource Name (ARN) of the KMS key.
        public let kmsKeyArn: String?

        @inlinable
        public init(keyType: KeyType, kmsKeyArn: String? = nil) {
            self.keyType = keyType
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case keyType = "keyType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct LifecycleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Timeout in seconds for idle runtime sessions. When a session remains idle for this duration, it will be automatically terminated. Default: 900 seconds (15 minutes).
        public let idleRuntimeSessionTimeout: Int?
        /// Maximum lifetime for the instance in seconds. Once reached, instances will be automatically terminated and replaced. Default: 28800 seconds (8 hours).
        public let maxLifetime: Int?

        @inlinable
        public init(idleRuntimeSessionTimeout: Int? = nil, maxLifetime: Int? = nil) {
            self.idleRuntimeSessionTimeout = idleRuntimeSessionTimeout
            self.maxLifetime = maxLifetime
        }

        private enum CodingKeys: String, CodingKey {
            case idleRuntimeSessionTimeout = "idleRuntimeSessionTimeout"
            case maxLifetime = "maxLifetime"
        }
    }

    public struct LinkedinOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the LinkedIn OAuth2 provider. This identifier is assigned by LinkedIn when you register your application.
        public let clientId: String
        /// The client secret for the LinkedIn OAuth2 provider. This secret is assigned by LinkedIn and used along with the client ID to authenticate your application.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct LinkedinOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the LinkedIn OAuth2 provider.
        public let clientId: String?
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct ListAgentRuntimeEndpointsRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime to list endpoints for.
        public let agentRuntimeId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimeId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentRuntimeId = agentRuntimeId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAgentRuntimeEndpointsResponse: AWSDecodableShape {
        /// A token to retrieve the next page of results.
        public let nextToken: String?
        /// The list of AgentCore Runtime endpoints.
        public let runtimeEndpoints: [AgentRuntimeEndpoint]

        @inlinable
        public init(nextToken: String? = nil, runtimeEndpoints: [AgentRuntimeEndpoint]) {
            self.nextToken = nextToken
            self.runtimeEndpoints = runtimeEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case runtimeEndpoints = "runtimeEndpoints"
        }
    }

    public struct ListAgentRuntimeVersionsRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime to list versions for.
        public let agentRuntimeId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimeId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentRuntimeId = agentRuntimeId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAgentRuntimeVersionsResponse: AWSDecodableShape {
        /// The list of AgentCore Runtime versions.
        public let agentRuntimes: [AgentRuntime]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimes: [AgentRuntime], nextToken: String? = nil) {
            self.agentRuntimes = agentRuntimes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimes = "agentRuntimes"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentRuntimesRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAgentRuntimesResponse: AWSDecodableShape {
        /// The list of AgentCore Runtime resources.
        public let agentRuntimes: [AgentRuntime]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimes: [AgentRuntime], nextToken: String? = nil) {
            self.agentRuntimes = agentRuntimes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimes = "agentRuntimes"
            case nextToken = "nextToken"
        }
    }

    public struct ListApiKeyCredentialProvidersRequest: AWSEncodableShape {
        /// Maximum number of results to return.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListApiKeyCredentialProvidersResponse: AWSDecodableShape {
        /// The list of API key credential providers.
        public let credentialProviders: [ApiKeyCredentialProviderItem]
        /// Pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(credentialProviders: [ApiKeyCredentialProviderItem], nextToken: String? = nil) {
            self.credentialProviders = credentialProviders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviders = "credentialProviders"
            case nextToken = "nextToken"
        }
    }

    public struct ListBrowsersRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The type of browsers to list. If not specified, all browser types are returned.
        public let type: ResourceType?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, type: ResourceType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBrowsersResponse: AWSDecodableShape {
        /// The list of browser summaries.
        public let browserSummaries: [BrowserSummary]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(browserSummaries: [BrowserSummary], nextToken: String? = nil) {
            self.browserSummaries = browserSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case browserSummaries = "browserSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCodeInterpretersRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?
        /// The type of code interpreters to list.
        public let type: ResourceType?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, type: ResourceType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCodeInterpretersResponse: AWSDecodableShape {
        /// The list of code interpreter summaries.
        public let codeInterpreterSummaries: [CodeInterpreterSummary]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(codeInterpreterSummaries: [CodeInterpreterSummary], nextToken: String? = nil) {
            self.codeInterpreterSummaries = codeInterpreterSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterSummaries = "codeInterpreterSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListGatewayTargetsRequest: AWSEncodableShape {
        /// The identifier of the gateway to list targets for.
        public let gatewayIdentifier: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(gatewayIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.gatewayIdentifier = gatewayIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewayTargetsResponse: AWSDecodableShape {
        /// The list of gateway target summaries.
        public let items: [TargetSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(items: [TargetSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListGatewaysRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewaysResponse: AWSDecodableShape {
        /// The list of gateway summaries.
        public let items: [GatewaySummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(items: [GatewaySummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoriesInput: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoriesOutput: AWSDecodableShape {
        /// The list of AgentCore Memory resource summaries.
        public let memories: [MemorySummary]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(memories: [MemorySummary], nextToken: String? = nil) {
            self.memories = memories
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memories = "memories"
            case nextToken = "nextToken"
        }
    }

    public struct ListOauth2CredentialProvidersRequest: AWSEncodableShape {
        /// Maximum number of results to return.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListOauth2CredentialProvidersResponse: AWSDecodableShape {
        /// The list of OAuth2 credential providers.
        public let credentialProviders: [Oauth2CredentialProviderItem]
        /// Pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(credentialProviders: [Oauth2CredentialProviderItem], nextToken: String? = nil) {
            self.credentialProviders = credentialProviders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviders = "credentialProviders"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(?:[^:]+)?:bedrock-agentcore:[a-z0-9-]+:[0-9]{12}:([a-z-]+/[^/]+)(?:/[a-z-]+/[^/]+)*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWorkloadIdentitiesRequest: AWSEncodableShape {
        /// Maximum number of results to return.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorkloadIdentitiesResponse: AWSDecodableShape {
        /// Pagination token for the next page of results.
        public let nextToken: String?
        /// The list of workload identities.
        public let workloadIdentities: [WorkloadIdentityType]

        @inlinable
        public init(nextToken: String? = nil, workloadIdentities: [WorkloadIdentityType]) {
            self.nextToken = nextToken
            self.workloadIdentities = workloadIdentities
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workloadIdentities = "workloadIdentities"
        }
    }

    public struct MCPGatewayConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The instructions for using the Model Context Protocol gateway. These instructions provide guidance on how to interact with the gateway.
        public let instructions: String?
        /// The search type for the Model Context Protocol gateway. This field specifies how the gateway handles search operations.
        public let searchType: SearchType?
        /// The supported versions of the Model Context Protocol. This field specifies which versions of the protocol the gateway can use.
        public let supportedVersions: [String]?

        @inlinable
        public init(instructions: String? = nil, searchType: SearchType? = nil, supportedVersions: [String]? = nil) {
            self.instructions = instructions
            self.searchType = searchType
            self.supportedVersions = supportedVersions
        }

        public func validate(name: String) throws {
            try self.validate(self.instructions, name: "instructions", parent: name, max: 2048)
            try self.validate(self.instructions, name: "instructions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instructions = "instructions"
            case searchType = "searchType"
            case supportedVersions = "supportedVersions"
        }
    }

    public struct McpLambdaTargetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function. This function is invoked by the gateway to communicate with the target.
        public let lambdaArn: String
        /// The tool schema for the Lambda function. This schema defines the structure of the tools that the Lambda function provides.
        public let toolSchema: ToolSchema

        @inlinable
        public init(lambdaArn: String, toolSchema: ToolSchema) {
            self.lambdaArn = lambdaArn
            self.toolSchema = toolSchema
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 170)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, min: 1)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:([a-z]{2}(-gov)?-[a-z]+-\\d{1}):(\\d{12}):function:([a-zA-Z0-9-_.]+)(:(\\$LATEST|[a-zA-Z0-9-]+))?$")
            try self.toolSchema.validate(name: "\(name).toolSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaArn = "lambdaArn"
            case toolSchema = "toolSchema"
        }
    }

    public struct McpServerTargetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint for the MCP server target configuration.
        public let endpoint: String

        @inlinable
        public init(endpoint: String) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "endpoint"
        }
    }

    public struct Memory: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the memory.
        public let arn: String
        /// The timestamp when the memory was created.
        public let createdAt: Date
        /// The description of the memory.
        public let description: String?
        /// The ARN of the KMS key used to encrypt the memory.
        public let encryptionKeyArn: String?
        /// The number of days after which memory events will expire.
        public let eventExpiryDuration: Int
        /// The reason for failure if the memory is in a failed state.
        public let failureReason: String?
        /// The unique identifier of the memory.
        public let id: String
        /// The ARN of the IAM role that provides permissions for the memory.
        public let memoryExecutionRoleArn: String?
        /// The name of the memory.
        public let name: String
        /// The current status of the memory.
        public let status: MemoryStatus
        /// The list of memory strategies associated with this memory.
        public let strategies: [MemoryStrategy]?
        /// The timestamp when the memory was last updated.
        public let updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, encryptionKeyArn: String? = nil, eventExpiryDuration: Int, failureReason: String? = nil, id: String, memoryExecutionRoleArn: String? = nil, name: String, status: MemoryStatus, strategies: [MemoryStrategy]? = nil, updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.encryptionKeyArn = encryptionKeyArn
            self.eventExpiryDuration = eventExpiryDuration
            self.failureReason = failureReason
            self.id = id
            self.memoryExecutionRoleArn = memoryExecutionRoleArn
            self.name = name
            self.status = status
            self.strategies = strategies
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case encryptionKeyArn = "encryptionKeyArn"
            case eventExpiryDuration = "eventExpiryDuration"
            case failureReason = "failureReason"
            case id = "id"
            case memoryExecutionRoleArn = "memoryExecutionRoleArn"
            case name = "name"
            case status = "status"
            case strategies = "strategies"
            case updatedAt = "updatedAt"
        }
    }

    public struct MemoryStrategy: AWSDecodableShape {
        /// The configuration of the memory strategy.
        public let configuration: StrategyConfiguration?
        /// The timestamp when the memory strategy was created.
        public let createdAt: Date?
        /// The description of the memory strategy.
        public let description: String?
        /// The name of the memory strategy.
        public let name: String
        /// The namespaces associated with the memory strategy.
        public let namespaces: [String]
        /// The current status of the memory strategy.
        public let status: MemoryStrategyStatus?
        /// The unique identifier of the memory strategy.
        public let strategyId: String
        /// The type of the memory strategy.
        public let type: MemoryStrategyType
        /// The timestamp when the memory strategy was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(configuration: StrategyConfiguration? = nil, createdAt: Date? = nil, description: String? = nil, name: String, namespaces: [String], status: MemoryStrategyStatus? = nil, strategyId: String, type: MemoryStrategyType, updatedAt: Date? = nil) {
            self.configuration = configuration
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.namespaces = namespaces
            self.status = status
            self.strategyId = strategyId
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case createdAt = "createdAt"
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
            case status = "status"
            case strategyId = "strategyId"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct MemorySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the memory.
        public let arn: String?
        /// The timestamp when the memory was created.
        public let createdAt: Date
        /// The unique identifier of the memory.
        public let id: String?
        /// The current status of the memory.
        public let status: MemoryStatus?
        /// The timestamp when the memory was last updated.
        public let updatedAt: Date

        @inlinable
        public init(arn: String? = nil, createdAt: Date, id: String? = nil, status: MemoryStatus? = nil, updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct MessageBasedTrigger: AWSDecodableShape {
        /// The number of messages that trigger memory processing.
        public let messageCount: Int?

        @inlinable
        public init(messageCount: Int? = nil) {
            self.messageCount = messageCount
        }

        private enum CodingKeys: String, CodingKey {
            case messageCount = "messageCount"
        }
    }

    public struct MessageBasedTriggerInput: AWSEncodableShape {
        /// The number of messages that trigger memory processing.
        public let messageCount: Int?

        @inlinable
        public init(messageCount: Int? = nil) {
            self.messageCount = messageCount
        }

        private enum CodingKeys: String, CodingKey {
            case messageCount = "messageCount"
        }
    }

    public struct MicrosoftOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Microsoft OAuth2 provider.
        public let clientId: String
        /// The client secret for the Microsoft OAuth2 provider.
        public let clientSecret: String
        /// The Microsoft Entra ID (formerly Azure AD) tenant ID for your organization. This identifies the specific tenant within Microsoft's identity platform where your application is registered.
        public let tenantId: String?

        @inlinable
        public init(clientId: String, clientSecret: String, tenantId: String? = nil) {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.tenantId = tenantId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
            try self.validate(self.tenantId, name: "tenantId", parent: name, max: 2048)
            try self.validate(self.tenantId, name: "tenantId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case tenantId = "tenantId"
        }
    }

    public struct MicrosoftOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the Microsoft OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the Microsoft provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct ModifyInvocationConfigurationInput: AWSEncodableShape {
        /// The updated S3 bucket name for event payload delivery.
        public let payloadDeliveryBucketName: String?
        /// The updated ARN of the SNS topic for job notifications.
        public let topicArn: String?

        @inlinable
        public init(payloadDeliveryBucketName: String? = nil, topicArn: String? = nil) {
            self.payloadDeliveryBucketName = payloadDeliveryBucketName
            self.topicArn = topicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.topicArn, name: "topicArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case payloadDeliveryBucketName = "payloadDeliveryBucketName"
            case topicArn = "topicArn"
        }
    }

    public struct ModifyMemoryStrategies: AWSEncodableShape {
        /// The list of memory strategies to add.
        public let addMemoryStrategies: [MemoryStrategyInput]?
        /// The list of memory strategies to delete.
        public let deleteMemoryStrategies: [DeleteMemoryStrategyInput]?
        /// The list of memory strategies to modify.
        public let modifyMemoryStrategies: [ModifyMemoryStrategyInput]?

        @inlinable
        public init(addMemoryStrategies: [MemoryStrategyInput]? = nil, deleteMemoryStrategies: [DeleteMemoryStrategyInput]? = nil, modifyMemoryStrategies: [ModifyMemoryStrategyInput]? = nil) {
            self.addMemoryStrategies = addMemoryStrategies
            self.deleteMemoryStrategies = deleteMemoryStrategies
            self.modifyMemoryStrategies = modifyMemoryStrategies
        }

        public func validate(name: String) throws {
            try self.addMemoryStrategies?.forEach {
                try $0.validate(name: "\(name).addMemoryStrategies[]")
            }
            try self.modifyMemoryStrategies?.forEach {
                try $0.validate(name: "\(name).modifyMemoryStrategies[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case addMemoryStrategies = "addMemoryStrategies"
            case deleteMemoryStrategies = "deleteMemoryStrategies"
            case modifyMemoryStrategies = "modifyMemoryStrategies"
        }
    }

    public struct ModifyMemoryStrategyInput: AWSEncodableShape {
        /// The updated configuration for the memory strategy.
        public let configuration: ModifyStrategyConfiguration?
        /// The updated description of the memory strategy.
        public let description: String?
        /// The unique identifier of the memory strategy to modify.
        public let memoryStrategyId: String
        /// The updated namespaces for the memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(configuration: ModifyStrategyConfiguration? = nil, description: String? = nil, memoryStrategyId: String, namespaces: [String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case memoryStrategyId = "memoryStrategyId"
            case namespaces = "namespaces"
        }
    }

    public struct ModifySelfManagedConfiguration: AWSEncodableShape {
        /// The updated number of historical messages to include in processing context.
        public let historicalContextWindowSize: Int?
        /// The updated configuration to invoke self-managed memory processing pipeline.
        public let invocationConfiguration: ModifyInvocationConfigurationInput?
        /// The updated list of conditions that trigger memory processing.
        public let triggerConditions: [TriggerConditionInput]?

        @inlinable
        public init(historicalContextWindowSize: Int? = nil, invocationConfiguration: ModifyInvocationConfigurationInput? = nil, triggerConditions: [TriggerConditionInput]? = nil) {
            self.historicalContextWindowSize = historicalContextWindowSize
            self.invocationConfiguration = invocationConfiguration
            self.triggerConditions = triggerConditions
        }

        public func validate(name: String) throws {
            try self.invocationConfiguration?.validate(name: "\(name).invocationConfiguration")
            try self.validate(self.triggerConditions, name: "triggerConditions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case historicalContextWindowSize = "historicalContextWindowSize"
            case invocationConfiguration = "invocationConfiguration"
            case triggerConditions = "triggerConditions"
        }
    }

    public struct ModifyStrategyConfiguration: AWSEncodableShape {
        /// The updated consolidation configuration.
        public let consolidation: ModifyConsolidationConfiguration?
        /// The updated extraction configuration.
        public let extraction: ModifyExtractionConfiguration?
        /// The updated self-managed configuration.
        public let selfManagedConfiguration: ModifySelfManagedConfiguration?

        @inlinable
        public init(consolidation: ModifyConsolidationConfiguration? = nil, extraction: ModifyExtractionConfiguration? = nil, selfManagedConfiguration: ModifySelfManagedConfiguration? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
            self.selfManagedConfiguration = selfManagedConfiguration
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
            try self.extraction?.validate(name: "\(name).extraction")
            try self.selfManagedConfiguration?.validate(name: "\(name).selfManagedConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
            case selfManagedConfiguration = "selfManagedConfiguration"
        }
    }

    public struct NetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The network mode for the AgentCore Runtime.
        public let networkMode: NetworkMode
        /// The network mode configuration for the AgentCore Runtime.
        public let networkModeConfig: VpcConfig?

        @inlinable
        public init(networkMode: NetworkMode, networkModeConfig: VpcConfig? = nil) {
            self.networkMode = networkMode
            self.networkModeConfig = networkModeConfig
        }

        public func validate(name: String) throws {
            try self.networkModeConfig?.validate(name: "\(name).networkModeConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case networkMode = "networkMode"
            case networkModeConfig = "networkModeConfig"
        }
    }

    public struct OAuthCredentialProvider: AWSEncodableShape & AWSDecodableShape {
        /// The custom parameters for the OAuth credential provider. These parameters provide additional configuration for the OAuth authentication process.
        public let customParameters: [String: String]?
        /// The Amazon Resource Name (ARN) of the OAuth credential provider. This ARN identifies the provider in Amazon Web Services.
        public let providerArn: String
        /// The OAuth scopes for the credential provider. These scopes define the level of access requested from the OAuth provider.
        public let scopes: [String]

        @inlinable
        public init(customParameters: [String: String]? = nil, providerArn: String, scopes: [String]) {
            self.customParameters = customParameters
            self.providerArn = providerArn
            self.scopes = scopes
        }

        public func validate(name: String) throws {
            try self.customParameters?.forEach {
                try validate($0.key, name: "customParameters.key", parent: name, max: 256)
                try validate($0.key, name: "customParameters.key", parent: name, min: 1)
                try validate($0.value, name: "customParameters[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "customParameters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.customParameters, name: "customParameters", parent: name, max: 10)
            try self.validate(self.customParameters, name: "customParameters", parent: name, min: 1)
            try self.validate(self.providerArn, name: "providerArn", parent: name, pattern: "^arn:([^:]*):([^:]*):([^:]*):([0-9]{12})?:(.+)$")
            try self.scopes.forEach {
                try validate($0, name: "scopes[]", parent: name, max: 64)
                try validate($0, name: "scopes[]", parent: name, min: 1)
            }
            try self.validate(self.scopes, name: "scopes", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case customParameters = "customParameters"
            case providerArn = "providerArn"
            case scopes = "scopes"
        }
    }

    public struct Oauth2AuthorizationServerMetadata: AWSEncodableShape & AWSDecodableShape {
        /// The authorization endpoint URL for the OAuth2 authorization server.
        public let authorizationEndpoint: String
        /// The issuer URL for the OAuth2 authorization server.
        public let issuer: String
        /// The supported response types for the OAuth2 authorization server.
        public let responseTypes: [String]?
        /// The token endpoint URL for the OAuth2 authorization server.
        public let tokenEndpoint: String
        /// The authentication methods supported by the token endpoint. This specifies how clients can authenticate when requesting tokens from the authorization server.
        public let tokenEndpointAuthMethods: [String]?

        @inlinable
        public init(authorizationEndpoint: String, issuer: String, responseTypes: [String]? = nil, tokenEndpoint: String, tokenEndpointAuthMethods: [String]? = nil) {
            self.authorizationEndpoint = authorizationEndpoint
            self.issuer = issuer
            self.responseTypes = responseTypes
            self.tokenEndpoint = tokenEndpoint
            self.tokenEndpointAuthMethods = tokenEndpointAuthMethods
        }

        public func validate(name: String) throws {
            try self.tokenEndpointAuthMethods?.forEach {
                try validate($0, name: "tokenEndpointAuthMethods[]", parent: name, pattern: "^(client_secret_post|client_secret_basic)$")
            }
            try self.validate(self.tokenEndpointAuthMethods, name: "tokenEndpointAuthMethods", parent: name, max: 2)
            try self.validate(self.tokenEndpointAuthMethods, name: "tokenEndpointAuthMethods", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationEndpoint = "authorizationEndpoint"
            case issuer = "issuer"
            case responseTypes = "responseTypes"
            case tokenEndpoint = "tokenEndpoint"
            case tokenEndpointAuthMethods = "tokenEndpointAuthMethods"
        }
    }

    public struct Oauth2CredentialProviderItem: AWSDecodableShape {
        /// The timestamp when the OAuth2 credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
        public let credentialProviderArn: String
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The timestamp when the OAuth2 credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the OAuth2 credential provider.
        public let name: String

        @inlinable
        public init(createdTime: Date, credentialProviderArn: String, credentialProviderVendor: CredentialProviderVendorType, lastUpdatedTime: Date, name: String) {
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.credentialProviderVendor = credentialProviderVendor
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case credentialProviderVendor = "credentialProviderVendor"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct ProtocolConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The server protocol for the agent runtime. This field specifies which protocol the agent runtime uses to communicate with clients.
        public let serverProtocol: ServerProtocol

        @inlinable
        public init(serverProtocol: ServerProtocol) {
            self.serverProtocol = serverProtocol
        }

        private enum CodingKeys: String, CodingKey {
            case serverProtocol = "serverProtocol"
        }
    }

    public struct RecordingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether recording is enabled for the browser. When set to true, browser sessions are recorded.
        public let enabled: Bool?
        /// The Amazon S3 location where browser recordings are stored. This location contains the recorded browser sessions.
        public let s3Location: S3Location?

        @inlinable
        public init(enabled: Bool? = nil, s3Location: S3Location? = nil) {
            self.enabled = enabled
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case s3Location = "s3Location"
        }
    }

    public struct S3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The account ID of the Amazon S3 bucket owner. This ID is used for cross-account access to the bucket.
        public let bucketOwnerAccountId: String?
        /// The URI of the Amazon S3 object. This URI specifies the location of the object in Amazon S3.
        public let uri: String?

        @inlinable
        public init(bucketOwnerAccountId: String? = nil, uri: String? = nil) {
            self.bucketOwnerAccountId = bucketOwnerAccountId
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://.{1,2043}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketOwnerAccountId = "bucketOwnerAccountId"
            case uri = "uri"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket. This bucket contains the stored data.
        public let bucket: String
        /// The prefix for objects in the Amazon S3 bucket. This prefix is added to the object keys to organize the data.
        public let prefix: String

        @inlinable
        public init(bucket: String, prefix: String) {
            self.bucket = bucket
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case prefix = "prefix"
        }
    }

    public struct SalesforceOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Salesforce OAuth2 provider.
        public let clientId: String
        /// The client secret for the Salesforce OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct SalesforceOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the Salesforce OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the Salesforce provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public final class SchemaDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The description of the schema definition. This description provides information about the purpose and usage of the schema.
        public let description: String?
        /// The items in the schema definition. This field is used for array types to define the structure of the array elements.
        public let items: SchemaDefinition?
        /// The properties of the schema definition. These properties define the fields in the schema.
        public let properties: [String: SchemaDefinition]?
        /// The required fields in the schema definition. These fields must be provided when using the schema.
        public let required: [String]?
        /// The type of the schema definition. This field specifies the data type of the schema.
        public let type: SchemaType

        @inlinable
        public init(description: String? = nil, items: SchemaDefinition? = nil, properties: [String: SchemaDefinition]? = nil, required: [String]? = nil, type: SchemaType) {
            self.description = description
            self.items = items
            self.properties = properties
            self.required = required
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case items = "items"
            case properties = "properties"
            case required = "required"
            case type = "type"
        }
    }

    public struct Secret: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the secret in AWS Secrets Manager.
        public let secretArn: String

        @inlinable
        public init(secretArn: String) {
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case secretArn = "secretArn"
        }
    }

    public struct SelfManagedConfiguration: AWSDecodableShape {
        /// The number of historical messages to include in processing context.
        public let historicalContextWindowSize: Int
        /// The configuration to use when invoking memory processing.
        public let invocationConfiguration: InvocationConfiguration
        /// A list of conditions that trigger memory processing.
        public let triggerConditions: [TriggerCondition]

        @inlinable
        public init(historicalContextWindowSize: Int, invocationConfiguration: InvocationConfiguration, triggerConditions: [TriggerCondition]) {
            self.historicalContextWindowSize = historicalContextWindowSize
            self.invocationConfiguration = invocationConfiguration
            self.triggerConditions = triggerConditions
        }

        private enum CodingKeys: String, CodingKey {
            case historicalContextWindowSize = "historicalContextWindowSize"
            case invocationConfiguration = "invocationConfiguration"
            case triggerConditions = "triggerConditions"
        }
    }

    public struct SelfManagedConfigurationInput: AWSEncodableShape {
        /// Number of historical messages to include in processing context.
        public let historicalContextWindowSize: Int?
        /// Configuration to invoke a self-managed memory processing pipeline with.
        public let invocationConfiguration: InvocationConfigurationInput
        /// A list of conditions that trigger memory processing.
        public let triggerConditions: [TriggerConditionInput]?

        @inlinable
        public init(historicalContextWindowSize: Int? = nil, invocationConfiguration: InvocationConfigurationInput, triggerConditions: [TriggerConditionInput]? = nil) {
            self.historicalContextWindowSize = historicalContextWindowSize
            self.invocationConfiguration = invocationConfiguration
            self.triggerConditions = triggerConditions
        }

        public func validate(name: String) throws {
            try self.invocationConfiguration.validate(name: "\(name).invocationConfiguration")
            try self.validate(self.triggerConditions, name: "triggerConditions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case historicalContextWindowSize = "historicalContextWindowSize"
            case invocationConfiguration = "invocationConfiguration"
            case triggerConditions = "triggerConditions"
        }
    }

    public struct SemanticConsolidationOverride: AWSDecodableShape {
        /// The text to append to the prompt for semantic consolidation.
        public let appendToPrompt: String
        /// The model ID to use for semantic consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SemanticExtractionOverride: AWSDecodableShape {
        /// The text to append to the prompt for semantic extraction.
        public let appendToPrompt: String
        /// The model ID to use for semantic extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SemanticMemoryStrategyInput: AWSEncodableShape {
        /// The description of the semantic memory strategy.
        public let description: String?
        /// The name of the semantic memory strategy.
        public let name: String
        /// The namespaces associated with the semantic memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct SemanticOverrideConfigurationInput: AWSEncodableShape {
        /// The consolidation configuration for a semantic override.
        public let consolidation: SemanticOverrideConsolidationConfigurationInput?
        /// The extraction configuration for a semantic override.
        public let extraction: SemanticOverrideExtractionConfigurationInput?

        @inlinable
        public init(consolidation: SemanticOverrideConsolidationConfigurationInput? = nil, extraction: SemanticOverrideExtractionConfigurationInput? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
            try self.extraction?.validate(name: "\(name).extraction")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
        }
    }

    public struct SemanticOverrideConsolidationConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for semantic consolidation.
        public let appendToPrompt: String
        /// The model ID to use for semantic consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SemanticOverrideExtractionConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for semantic extraction.
        public let appendToPrompt: String
        /// The model ID to use for semantic extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SetTokenVaultCMKRequest: AWSEncodableShape {
        /// The KMS configuration for the token vault, including the key type and KMS key ARN.
        public let kmsConfiguration: KmsConfiguration
        /// The unique identifier of the token vault to update.
        public let tokenVaultId: String?

        @inlinable
        public init(kmsConfiguration: KmsConfiguration, tokenVaultId: String? = nil) {
            self.kmsConfiguration = kmsConfiguration
            self.tokenVaultId = tokenVaultId
        }

        public func validate(name: String) throws {
            try self.kmsConfiguration.validate(name: "\(name).kmsConfiguration")
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, max: 64)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, min: 1)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsConfiguration = "kmsConfiguration"
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct SetTokenVaultCMKResponse: AWSDecodableShape {
        /// The KMS configuration for the token vault.
        public let kmsConfiguration: KmsConfiguration
        /// The timestamp when the token vault was last modified.
        public let lastModifiedDate: Date
        /// The ID of the token vault.
        public let tokenVaultId: String

        @inlinable
        public init(kmsConfiguration: KmsConfiguration, lastModifiedDate: Date, tokenVaultId: String) {
            self.kmsConfiguration = kmsConfiguration
            self.lastModifiedDate = lastModifiedDate
            self.tokenVaultId = tokenVaultId
        }

        private enum CodingKeys: String, CodingKey {
            case kmsConfiguration = "kmsConfiguration"
            case lastModifiedDate = "lastModifiedDate"
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct SlackOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Slack OAuth2 provider.
        public let clientId: String
        /// The client secret for the Slack OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct SlackOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the Slack OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the Slack provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct StrategyConfiguration: AWSDecodableShape {
        /// The consolidation configuration for the memory strategy.
        public let consolidation: ConsolidationConfiguration?
        /// The extraction configuration for the memory strategy.
        public let extraction: ExtractionConfiguration?
        /// Self-managed configuration settings.
        public let selfManagedConfiguration: SelfManagedConfiguration?
        /// The type of override for the strategy configuration.
        public let type: OverrideType?

        @inlinable
        public init(consolidation: ConsolidationConfiguration? = nil, extraction: ExtractionConfiguration? = nil, selfManagedConfiguration: SelfManagedConfiguration? = nil, type: OverrideType? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
            self.selfManagedConfiguration = selfManagedConfiguration
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
            case selfManagedConfiguration = "selfManagedConfiguration"
            case type = "type"
        }
    }

    public struct SummaryConsolidationOverride: AWSDecodableShape {
        /// The text to append to the prompt for summary consolidation.
        public let appendToPrompt: String
        /// The model ID to use for summary consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SummaryMemoryStrategyInput: AWSEncodableShape {
        /// The description of the summary memory strategy.
        public let description: String?
        /// The name of the summary memory strategy.
        public let name: String
        /// The namespaces associated with the summary memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct SummaryOverrideConfigurationInput: AWSEncodableShape {
        /// The consolidation configuration for a summary override.
        public let consolidation: SummaryOverrideConsolidationConfigurationInput?

        @inlinable
        public init(consolidation: SummaryOverrideConsolidationConfigurationInput? = nil) {
            self.consolidation = consolidation
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
        }
    }

    public struct SummaryOverrideConsolidationConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for summary consolidation.
        public let appendToPrompt: String
        /// The model ID to use for summary consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SynchronizeGatewayTargetsRequest: AWSEncodableShape {
        /// The gateway Identifier.
        public let gatewayIdentifier: String
        /// The target ID list.
        public let targetIdList: [String]

        @inlinable
        public init(gatewayIdentifier: String, targetIdList: [String]) {
            self.gatewayIdentifier = gatewayIdentifier
            self.targetIdList = targetIdList
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            try container.encode(self.targetIdList, forKey: .targetIdList)
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.targetIdList.forEach {
                try validate($0, name: "targetIdList[]", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            }
            try self.validate(self.targetIdList, name: "targetIdList", parent: name, max: 1)
            try self.validate(self.targetIdList, name: "targetIdList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetIdList = "targetIdList"
        }
    }

    public struct SynchronizeGatewayTargetsResponse: AWSDecodableShape {
        /// The gateway targets for synchronization.
        public let targets: [GatewayTarget]?

        @inlinable
        public init(targets: [GatewayTarget]? = nil) {
            self.targets = targets
        }

        private enum CodingKeys: String, CodingKey {
            case targets = "targets"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is a key-value pair.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(?:[^:]+)?:bedrock-agentcore:[a-z0-9-]+:[0-9]{12}:([a-z-]+/[^/]+)(?:/[a-z-]+/[^/]+)*$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetSummary: AWSDecodableShape {
        /// The timestamp when the target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the target.
        public let description: String?
        /// The name of the target.
        public let name: String
        /// The current status of the target.
        public let status: TargetStatus
        /// The unique identifier of the target.
        public let targetId: String
        /// The timestamp when the target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, name: String, status: TargetStatus, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.status = status
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case name = "name"
            case status = "status"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct TimeBasedTrigger: AWSDecodableShape {
        /// Idle session timeout (seconds) that triggers memory processing.
        public let idleSessionTimeout: Int?

        @inlinable
        public init(idleSessionTimeout: Int? = nil) {
            self.idleSessionTimeout = idleSessionTimeout
        }

        private enum CodingKeys: String, CodingKey {
            case idleSessionTimeout = "idleSessionTimeout"
        }
    }

    public struct TimeBasedTriggerInput: AWSEncodableShape {
        /// Idle session timeout (seconds) that triggers memory processing.
        public let idleSessionTimeout: Int?

        @inlinable
        public init(idleSessionTimeout: Int? = nil) {
            self.idleSessionTimeout = idleSessionTimeout
        }

        private enum CodingKeys: String, CodingKey {
            case idleSessionTimeout = "idleSessionTimeout"
        }
    }

    public struct TokenBasedTrigger: AWSDecodableShape {
        /// Number of tokens that trigger memory processing.
        public let tokenCount: Int?

        @inlinable
        public init(tokenCount: Int? = nil) {
            self.tokenCount = tokenCount
        }

        private enum CodingKeys: String, CodingKey {
            case tokenCount = "tokenCount"
        }
    }

    public struct TokenBasedTriggerInput: AWSEncodableShape {
        /// Number of tokens that trigger memory processing.
        public let tokenCount: Int?

        @inlinable
        public init(tokenCount: Int? = nil) {
            self.tokenCount = tokenCount
        }

        private enum CodingKeys: String, CodingKey {
            case tokenCount = "tokenCount"
        }
    }

    public struct ToolDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The description of the tool. This description provides information about the purpose and usage of the tool.
        public let description: String
        /// The input schema for the tool. This schema defines the structure of the input that the tool accepts.
        public let inputSchema: SchemaDefinition
        /// The name of the tool. This name identifies the tool in the Model Context Protocol.
        public let name: String
        /// The output schema for the tool. This schema defines the structure of the output that the tool produces.
        public let outputSchema: SchemaDefinition?

        @inlinable
        public init(description: String, inputSchema: SchemaDefinition, name: String, outputSchema: SchemaDefinition? = nil) {
            self.description = description
            self.inputSchema = inputSchema
            self.name = name
            self.outputSchema = outputSchema
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case inputSchema = "inputSchema"
            case name = "name"
            case outputSchema = "outputSchema"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        /// The tag keys of the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(?:[^:]+)?:bedrock-agentcore:[a-z0-9-]+:[0-9]{12}:([a-z-]+/[^/]+)(?:/[a-z-]+/[^/]+)*$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime associated with the endpoint.
        public let agentRuntimeId: String
        /// The updated version of the AgentCore Runtime for the endpoint.
        public let agentRuntimeVersion: String?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The updated description of the AgentCore Runtime endpoint.
        public let description: String?
        /// The name of the AgentCore Runtime endpoint to update.
        public let endpointName: String

        @inlinable
        public init(agentRuntimeId: String, agentRuntimeVersion: String? = nil, clientToken: String? = UpdateAgentRuntimeEndpointRequest.idempotencyToken(), description: String? = nil, endpointName: String) {
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.clientToken = clientToken
            self.description = description
            self.endpointName = endpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            try container.encodeIfPresent(self.agentRuntimeVersion, forKey: .agentRuntimeVersion)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.endpointName, key: "endpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, max: 5)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, min: 1)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, pattern: "^([1-9][0-9]{0,4})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeVersion = "agentRuntimeVersion"
            case clientToken = "clientToken"
            case description = "description"
        }
    }

    public struct UpdateAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The timestamp when the AgentCore Runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the AgentCore Runtime endpoint was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The currently deployed version of the AgentCore Runtime on the endpoint.
        public let liveVersion: String?
        /// The current status of the updated AgentCore Runtime endpoint.
        public let status: AgentRuntimeEndpointStatus
        /// The target version of the AgentCore Runtime for the endpoint.
        public let targetVersion: String?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, createdAt: Date, lastUpdatedAt: Date, liveVersion: String? = nil, status: AgentRuntimeEndpointStatus, targetVersion: String? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.liveVersion = liveVersion
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case liveVersion = "liveVersion"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct UpdateAgentRuntimeRequest: AWSEncodableShape {
        /// The updated artifact of the AgentCore Runtime.
        public let agentRuntimeArtifact: AgentRuntimeArtifact
        /// The unique identifier of the AgentCore Runtime to update.
        public let agentRuntimeId: String
        /// The updated authorizer configuration for the AgentCore Runtime.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The updated description of the AgentCore Runtime.
        public let description: String?
        /// Updated environment variables to set in the AgentCore Runtime environment.
        public let environmentVariables: [String: String]?
        /// The updated life cycle configuration for the AgentCore Runtime.
        public let lifecycleConfiguration: LifecycleConfiguration?
        /// The updated network configuration for the AgentCore Runtime.
        public let networkConfiguration: NetworkConfiguration
        public let protocolConfiguration: ProtocolConfiguration?
        /// The updated configuration for HTTP request headers that will be passed through to the runtime.
        public let requestHeaderConfiguration: RequestHeaderConfiguration?
        /// The updated IAM role ARN that provides permissions for the AgentCore Runtime.
        public let roleArn: String

        @inlinable
        public init(agentRuntimeArtifact: AgentRuntimeArtifact, agentRuntimeId: String, authorizerConfiguration: AuthorizerConfiguration? = nil, clientToken: String? = UpdateAgentRuntimeRequest.idempotencyToken(), description: String? = nil, environmentVariables: [String: String]? = nil, lifecycleConfiguration: LifecycleConfiguration? = nil, networkConfiguration: NetworkConfiguration, protocolConfiguration: ProtocolConfiguration? = nil, requestHeaderConfiguration: RequestHeaderConfiguration? = nil, roleArn: String) {
            self.agentRuntimeArtifact = agentRuntimeArtifact
            self.agentRuntimeId = agentRuntimeId
            self.authorizerConfiguration = authorizerConfiguration
            self.clientToken = clientToken
            self.description = description
            self.environmentVariables = environmentVariables
            self.lifecycleConfiguration = lifecycleConfiguration
            self.networkConfiguration = networkConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.requestHeaderConfiguration = requestHeaderConfiguration
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.agentRuntimeArtifact, forKey: .agentRuntimeArtifact)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            try container.encodeIfPresent(self.authorizerConfiguration, forKey: .authorizerConfiguration)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.environmentVariables, forKey: .environmentVariables)
            try container.encodeIfPresent(self.lifecycleConfiguration, forKey: .lifecycleConfiguration)
            try container.encode(self.networkConfiguration, forKey: .networkConfiguration)
            try container.encodeIfPresent(self.protocolConfiguration, forKey: .protocolConfiguration)
            try container.encodeIfPresent(self.requestHeaderConfiguration, forKey: .requestHeaderConfiguration)
            try container.encode(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.agentRuntimeArtifact.validate(name: "\(name).agentRuntimeArtifact")
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.authorizerConfiguration?.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 100)
                try validate($0.key, name: "environmentVariables.key", parent: name, min: 1)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 5000)
            }
            try self.validate(self.environmentVariables, name: "environmentVariables", parent: name, max: 50)
            try self.networkConfiguration.validate(name: "\(name).networkConfiguration")
            try self.requestHeaderConfiguration?.validate(name: "\(name).requestHeaderConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArtifact = "agentRuntimeArtifact"
            case authorizerConfiguration = "authorizerConfiguration"
            case clientToken = "clientToken"
            case description = "description"
            case environmentVariables = "environmentVariables"
            case lifecycleConfiguration = "lifecycleConfiguration"
            case networkConfiguration = "networkConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case requestHeaderConfiguration = "requestHeaderConfiguration"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateAgentRuntimeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The unique identifier of the updated AgentCore Runtime.
        public let agentRuntimeId: String
        /// The version of the updated AgentCore Runtime.
        public let agentRuntimeVersion: String
        /// The timestamp when the AgentCore Runtime was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the AgentCore Runtime was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the updated AgentCore Runtime.
        public let status: AgentRuntimeStatus
        /// The workload identity details for the updated AgentCore Runtime.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeId: String, agentRuntimeVersion: String, createdAt: Date, lastUpdatedAt: Date, status: AgentRuntimeStatus, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct UpdateApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The new API key to use for authentication. This value replaces the existing API key and is encrypted and stored securely.
        public let apiKey: String
        /// The name of the API key credential provider to update.
        public let name: String

        @inlinable
        public init(apiKey: String, name: String) {
            self.apiKey = apiKey
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 65536)
            try self.validate(self.apiKey, name: "apiKey", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case name = "name"
        }
    }

    public struct UpdateApiKeyCredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the API key secret in AWS Secrets Manager.
        public let apiKeySecretArn: Secret
        /// The timestamp when the API key credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the API key credential provider.
        public let credentialProviderArn: String
        /// The timestamp when the API key credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the API key credential provider.
        public let name: String

        @inlinable
        public init(apiKeySecretArn: Secret, createdTime: Date, credentialProviderArn: String, lastUpdatedTime: Date, name: String) {
            self.apiKeySecretArn = apiKeySecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySecretArn = "apiKeySecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct UpdateGatewayRequest: AWSEncodableShape {
        /// The updated authorizer configuration for the gateway.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The updated authorizer type for the gateway.
        public let authorizerType: AuthorizerType
        /// The updated description for the gateway.
        public let description: String?
        /// The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
        public let exceptionLevel: ExceptionLevel?
        /// The identifier of the gateway to update.
        public let gatewayIdentifier: String
        /// The updated ARN of the KMS key used to encrypt the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway. This name must be the same as the one when the gateway was created.
        public let name: String
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The updated protocol type for the gateway.
        public let protocolType: GatewayProtocolType
        /// The updated IAM role ARN that provides permissions for the gateway.
        public let roleArn: String

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayIdentifier: String, kmsKeyArn: String? = nil, name: String, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayIdentifier = gatewayIdentifier
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authorizerConfiguration, forKey: .authorizerConfiguration)
            try container.encode(self.authorizerType, forKey: .authorizerType)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.exceptionLevel, forKey: .exceptionLevel)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            try container.encodeIfPresent(self.kmsKeyArn, forKey: .kmsKeyArn)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.protocolConfiguration, forKey: .protocolConfiguration)
            try container.encode(self.protocolType, forKey: .protocolType)
            try container.encode(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.authorizerConfiguration?.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.protocolConfiguration?.validate(name: "\(name).protocolConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateGatewayResponse: AWSDecodableShape {
        /// The updated authorizer configuration for the gateway.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The updated authorizer type for the gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The updated description of the gateway.
        public let description: String?
        /// The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
        public let exceptionLevel: ExceptionLevel?
        /// The Amazon Resource Name (ARN) of the updated gateway.
        public let gatewayArn: String
        /// The unique identifier of the updated gateway.
        public let gatewayId: String
        /// An endpoint for invoking the updated gateway.
        public let gatewayUrl: String?
        /// The updated ARN of the KMS key used to encrypt the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway.
        public let name: String
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The updated protocol type for the gateway.
        public let protocolType: GatewayProtocolType
        /// The updated IAM role ARN that provides permissions for the gateway.
        public let roleArn: String?
        /// The current status of the updated gateway.
        public let status: GatewayStatus
        /// The reasons for the current status of the updated gateway.
        public let statusReasons: [String]?
        /// The timestamp when the gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The workload identity details for the updated gateway.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayArn: String, gatewayId: String, gatewayUrl: String? = nil, kmsKeyArn: String? = nil, name: String, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String? = nil, status: GatewayStatus, statusReasons: [String]? = nil, updatedAt: Date, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
            self.gatewayUrl = gatewayUrl
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
            case gatewayUrl = "gatewayUrl"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct UpdateGatewayTargetRequest: AWSEncodableShape {
        /// The updated credential provider configurations for the gateway target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]?
        /// The updated description for the gateway target.
        public let description: String?
        /// The unique identifier of the gateway associated with the target.
        public let gatewayIdentifier: String
        /// The updated name for the gateway target.
        public let name: String
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the gateway target to update.
        public let targetId: String

        @inlinable
        public init(credentialProviderConfigurations: [CredentialProviderConfiguration]? = nil, description: String? = nil, gatewayIdentifier: String, name: String, targetConfiguration: TargetConfiguration, targetId: String) {
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayIdentifier = gatewayIdentifier
            self.name = name
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.credentialProviderConfigurations, forKey: .credentialProviderConfigurations)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.targetConfiguration, forKey: .targetConfiguration)
            request.encodePath(self.targetId, key: "targetId")
        }

        public func validate(name: String) throws {
            try self.credentialProviderConfigurations?.forEach {
                try $0.validate(name: "\(name).credentialProviderConfigurations[]")
            }
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, max: 1)
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.targetConfiguration.validate(name: "\(name).targetConfiguration")
            try self.validate(self.targetId, name: "targetId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case name = "name"
            case targetConfiguration = "targetConfiguration"
        }
    }

    public struct UpdateGatewayTargetResponse: AWSDecodableShape {
        /// The timestamp when the gateway target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The updated credential provider configurations for the gateway target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The updated description of the gateway target.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the gateway.
        public let gatewayArn: String
        /// The date and time at which the targets were last synchronized.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastSynchronizedAt: Date?
        /// The updated name of the gateway target.
        public let name: String
        /// The current status of the updated gateway target.
        public let status: TargetStatus
        /// The reasons for the current status of the updated gateway target.
        public let statusReasons: [String]?
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the updated gateway target.
        public let targetId: String
        /// The timestamp when the gateway target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayArn: String, lastSynchronizedAt: Date? = nil, name: String, status: TargetStatus, statusReasons: [String]? = nil, targetConfiguration: TargetConfiguration, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayArn = gatewayArn
            self.lastSynchronizedAt = lastSynchronizedAt
            self.name = name
            self.status = status
            self.statusReasons = statusReasons
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case gatewayArn = "gatewayArn"
            case lastSynchronizedAt = "lastSynchronizedAt"
            case name = "name"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetConfiguration = "targetConfiguration"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateMemoryInput: AWSEncodableShape {
        /// A client token is used for keeping track of idempotent requests. It can contain a session id which can be around 250 chars, combined with a unique AWS identifier.
        public let clientToken: String?
        /// The updated description of the AgentCore Memory resource.
        public let description: String?
        /// The number of days after which memory events will expire, between 7 and 365 days.
        public let eventExpiryDuration: Int?
        /// The ARN of the IAM role that provides permissions for the AgentCore Memory resource.
        public let memoryExecutionRoleArn: String?
        /// The unique identifier of the memory to update.
        public let memoryId: String
        /// The memory strategies to add, modify, or delete.
        public let memoryStrategies: ModifyMemoryStrategies?

        @inlinable
        public init(clientToken: String? = UpdateMemoryInput.idempotencyToken(), description: String? = nil, eventExpiryDuration: Int? = nil, memoryExecutionRoleArn: String? = nil, memoryId: String, memoryStrategies: ModifyMemoryStrategies? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.eventExpiryDuration = eventExpiryDuration
            self.memoryExecutionRoleArn = memoryExecutionRoleArn
            self.memoryId = memoryId
            self.memoryStrategies = memoryStrategies
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.eventExpiryDuration, forKey: .eventExpiryDuration)
            try container.encodeIfPresent(self.memoryExecutionRoleArn, forKey: .memoryExecutionRoleArn)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.memoryStrategies, forKey: .memoryStrategies)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.memoryExecutionRoleArn, name: "memoryExecutionRoleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.memoryStrategies?.validate(name: "\(name).memoryStrategies")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case eventExpiryDuration = "eventExpiryDuration"
            case memoryExecutionRoleArn = "memoryExecutionRoleArn"
            case memoryStrategies = "memoryStrategies"
        }
    }

    public struct UpdateMemoryOutput: AWSDecodableShape {
        /// The updated AgentCore Memory resource details.
        public let memory: Memory?

        @inlinable
        public init(memory: Memory? = nil) {
            self.memory = memory
        }

        private enum CodingKeys: String, CodingKey {
            case memory = "memory"
        }
    }

    public struct UpdateOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The name of the OAuth2 credential provider to update.
        public let name: String
        /// The configuration input for the OAuth2 provider.
        public let oauth2ProviderConfigInput: Oauth2ProviderConfigInput

        @inlinable
        public init(credentialProviderVendor: CredentialProviderVendorType, name: String, oauth2ProviderConfigInput: Oauth2ProviderConfigInput) {
            self.credentialProviderVendor = credentialProviderVendor
            self.name = name
            self.oauth2ProviderConfigInput = oauth2ProviderConfigInput
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.oauth2ProviderConfigInput.validate(name: "\(name).oauth2ProviderConfigInput")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviderVendor = "credentialProviderVendor"
            case name = "name"
            case oauth2ProviderConfigInput = "oauth2ProviderConfigInput"
        }
    }

    public struct UpdateOauth2CredentialProviderResponse: AWSDecodableShape {
        /// Callback URL to register on the OAuth2 credential provider as an allowed callback URL. This URL is where the OAuth2 authorization server redirects users after they complete the authorization flow.
        public let callbackUrl: String?
        /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
        public let clientSecretArn: Secret
        /// The timestamp when the OAuth2 credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
        public let credentialProviderArn: String
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The timestamp when the OAuth2 credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the OAuth2 credential provider.
        public let name: String
        /// The configuration output for the OAuth2 provider.
        public let oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput

        @inlinable
        public init(callbackUrl: String? = nil, clientSecretArn: Secret, createdTime: Date, credentialProviderArn: String, credentialProviderVendor: CredentialProviderVendorType, lastUpdatedTime: Date, name: String, oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput) {
            self.callbackUrl = callbackUrl
            self.clientSecretArn = clientSecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.credentialProviderVendor = credentialProviderVendor
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.oauth2ProviderConfigOutput = oauth2ProviderConfigOutput
        }

        private enum CodingKeys: String, CodingKey {
            case callbackUrl = "callbackUrl"
            case clientSecretArn = "clientSecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case credentialProviderVendor = "credentialProviderVendor"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case oauth2ProviderConfigOutput = "oauth2ProviderConfigOutput"
        }
    }

    public struct UpdateWorkloadIdentityRequest: AWSEncodableShape {
        /// The new list of allowed OAuth2 return URLs for resources associated with this workload identity. This list replaces the existing list.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The name of the workload identity to update.
        public let name: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, name: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.name = name
        }

        public func validate(name: String) throws {
            try self.allowedResourceOauth2ReturnUrls?.forEach {
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, max: 2048)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, min: 1)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, pattern: "^\\w+:(\\/?\\/?)[^\\s]+$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case name = "name"
        }
    }

    public struct UpdateWorkloadIdentityResponse: AWSDecodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The timestamp when the workload identity was created.
        public let createdTime: Date
        /// The timestamp when the workload identity was last updated.
        public let lastUpdatedTime: Date
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, createdTime: Date, lastUpdatedTime: Date, name: String, workloadIdentityArn: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case createdTime = "createdTime"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct UserPreferenceConsolidationOverride: AWSDecodableShape {
        /// The text to append to the prompt for user preference consolidation.
        public let appendToPrompt: String
        /// The model ID to use for user preference consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct UserPreferenceExtractionOverride: AWSDecodableShape {
        /// The text to append to the prompt for user preference extraction.
        public let appendToPrompt: String
        /// The model ID to use for user preference extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct UserPreferenceMemoryStrategyInput: AWSEncodableShape {
        /// The description of the user preference memory strategy.
        public let description: String?
        /// The name of the user preference memory strategy.
        public let name: String
        /// The namespaces associated with the user preference memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct UserPreferenceOverrideConfigurationInput: AWSEncodableShape {
        /// The consolidation configuration for a user preference override.
        public let consolidation: UserPreferenceOverrideConsolidationConfigurationInput?
        /// The extraction configuration for a user preference override.
        public let extraction: UserPreferenceOverrideExtractionConfigurationInput?

        @inlinable
        public init(consolidation: UserPreferenceOverrideConsolidationConfigurationInput? = nil, extraction: UserPreferenceOverrideExtractionConfigurationInput? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
            try self.extraction?.validate(name: "\(name).extraction")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
        }
    }

    public struct UserPreferenceOverrideConsolidationConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for user preference consolidation.
        public let appendToPrompt: String
        /// The model ID to use for user preference consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct UserPreferenceOverrideExtractionConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for user preference extraction.
        public let appendToPrompt: String
        /// The model ID to use for user preference extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message describing why this field failed validation.
        public let message: String
        /// The name of the field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct VpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// The security groups associated with the VPC configuration.
        public let securityGroups: [String]
        /// The subnets associated with the VPC configuration.
        public let subnets: [String]

        @inlinable
        public init(securityGroups: [String], subnets: [String]) {
            self.securityGroups = securityGroups
            self.subnets = subnets
        }

        public func validate(name: String) throws {
            try self.securityGroups.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "^sg-[0-9a-zA-Z]{8,17}$")
            }
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, max: 16)
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, min: 1)
            try self.subnets.forEach {
                try validate($0, name: "subnets[]", parent: name, pattern: "^subnet-[0-9a-zA-Z]{8,17}$")
            }
            try self.validate(self.subnets, name: "subnets", parent: name, max: 16)
            try self.validate(self.subnets, name: "subnets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroups = "securityGroups"
            case subnets = "subnets"
        }
    }

    public struct WorkloadIdentityDetails: AWSDecodableShape {
        /// The ARN associated with the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(workloadIdentityArn: String) {
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct WorkloadIdentityType: AWSDecodableShape {
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(name: String, workloadIdentityArn: String) {
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct AgentRuntimeArtifact: AWSEncodableShape & AWSDecodableShape {
        /// The container configuration for the agent artifact.
        public let containerConfiguration: ContainerConfiguration?

        @inlinable
        public init(containerConfiguration: ContainerConfiguration? = nil) {
            self.containerConfiguration = containerConfiguration
        }

        public func validate(name: String) throws {
            try self.containerConfiguration?.validate(name: "\(name).containerConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case containerConfiguration = "containerConfiguration"
        }
    }

    public struct AuthorizerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The inbound JWT-based authorization, specifying how incoming requests should be authenticated.
        public let customJWTAuthorizer: CustomJWTAuthorizerConfiguration?

        @inlinable
        public init(customJWTAuthorizer: CustomJWTAuthorizerConfiguration? = nil) {
            self.customJWTAuthorizer = customJWTAuthorizer
        }

        public func validate(name: String) throws {
            try self.customJWTAuthorizer?.validate(name: "\(name).customJWTAuthorizer")
        }

        private enum CodingKeys: String, CodingKey {
            case customJWTAuthorizer = "customJWTAuthorizer"
        }
    }

    public struct ConsolidationConfiguration: AWSDecodableShape {
        /// The custom consolidation configuration.
        public let customConsolidationConfiguration: CustomConsolidationConfiguration?

        @inlinable
        public init(customConsolidationConfiguration: CustomConsolidationConfiguration? = nil) {
            self.customConsolidationConfiguration = customConsolidationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case customConsolidationConfiguration = "customConsolidationConfiguration"
        }
    }

    public struct ExtractionConfiguration: AWSDecodableShape {
        /// The custom extraction configuration.
        public let customExtractionConfiguration: CustomExtractionConfiguration?

        @inlinable
        public init(customExtractionConfiguration: CustomExtractionConfiguration? = nil) {
            self.customExtractionConfiguration = customExtractionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case customExtractionConfiguration = "customExtractionConfiguration"
        }
    }

    public struct GatewayProtocolConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the Model Context Protocol (MCP). This protocol enables communication between Amazon Bedrock Agent and external tools.
        public let mcp: MCPGatewayConfiguration?

        @inlinable
        public init(mcp: MCPGatewayConfiguration? = nil) {
            self.mcp = mcp
        }

        public func validate(name: String) throws {
            try self.mcp?.validate(name: "\(name).mcp")
        }

        private enum CodingKeys: String, CodingKey {
            case mcp = "mcp"
        }
    }

    public struct ModifyConsolidationConfiguration: AWSEncodableShape {
        /// The updated custom consolidation configuration.
        public let customConsolidationConfiguration: CustomConsolidationConfigurationInput?

        @inlinable
        public init(customConsolidationConfiguration: CustomConsolidationConfigurationInput? = nil) {
            self.customConsolidationConfiguration = customConsolidationConfiguration
        }

        public func validate(name: String) throws {
            try self.customConsolidationConfiguration?.validate(name: "\(name).customConsolidationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customConsolidationConfiguration = "customConsolidationConfiguration"
        }
    }

    public struct ModifyExtractionConfiguration: AWSEncodableShape {
        /// The updated custom extraction configuration.
        public let customExtractionConfiguration: CustomExtractionConfigurationInput?

        @inlinable
        public init(customExtractionConfiguration: CustomExtractionConfigurationInput? = nil) {
            self.customExtractionConfiguration = customExtractionConfiguration
        }

        public func validate(name: String) throws {
            try self.customExtractionConfiguration?.validate(name: "\(name).customExtractionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customExtractionConfiguration = "customExtractionConfiguration"
        }
    }

    public struct RequestHeaderConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of HTTP request headers that are allowed to be passed through to the runtime.
        public let requestHeaderAllowlist: [String]?

        @inlinable
        public init(requestHeaderAllowlist: [String]? = nil) {
            self.requestHeaderAllowlist = requestHeaderAllowlist
        }

        public func validate(name: String) throws {
            try self.requestHeaderAllowlist?.forEach {
                try validate($0, name: "requestHeaderAllowlist[]", parent: name, max: 256)
                try validate($0, name: "requestHeaderAllowlist[]", parent: name, min: 1)
                try validate($0, name: "requestHeaderAllowlist[]", parent: name, pattern: "^(Authorization|X-Amzn-Bedrock-AgentCore-Runtime-Custom-[a-zA-Z0-9_-]+)$")
            }
            try self.validate(self.requestHeaderAllowlist, name: "requestHeaderAllowlist", parent: name, max: 20)
            try self.validate(self.requestHeaderAllowlist, name: "requestHeaderAllowlist", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case requestHeaderAllowlist = "requestHeaderAllowlist"
        }
    }

    public struct TargetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Model Context Protocol (MCP) configuration for the target. This configuration defines how the gateway uses MCP to communicate with the target.
        public let mcp: McpTargetConfiguration?

        @inlinable
        public init(mcp: McpTargetConfiguration? = nil) {
            self.mcp = mcp
        }

        public func validate(name: String) throws {
            try self.mcp?.validate(name: "\(name).mcp")
        }

        private enum CodingKeys: String, CodingKey {
            case mcp = "mcp"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgentCoreControl
public struct BedrockAgentCoreControlErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case concurrentModificationException = "ConcurrentModificationException"
        case conflictException = "ConflictException"
        case decryptionFailure = "DecryptionFailure"
        case encryptionFailure = "EncryptionFailure"
        case internalServerException = "InternalServerException"
        case resourceLimitExceededException = "ResourceLimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceException = "ServiceException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttledException = "ThrottledException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgentCoreControl
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// This exception is thrown when a request is denied per access permissions
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Exception thrown when a resource is modified concurrently by multiple requests.
    public static var concurrentModificationException: Self { .init(.concurrentModificationException) }
    /// This exception is thrown when there is a conflict performing an operation
    public static var conflictException: Self { .init(.conflictException) }
    /// Exception thrown when decryption of a secret fails.
    public static var decryptionFailure: Self { .init(.decryptionFailure) }
    /// Exception thrown when encryption of a secret fails.
    public static var encryptionFailure: Self { .init(.encryptionFailure) }
    /// This exception is thrown if there was an unexpected error during processing of request
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Exception thrown when a resource limit is exceeded.
    public static var resourceLimitExceededException: Self { .init(.resourceLimitExceededException) }
    /// This exception is thrown when a resource referenced by the operation does not exist
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// An internal error occurred.
    public static var serviceException: Self { .init(.serviceException) }
    /// This exception is thrown when a request is made beyond the service quota
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// API rate limit has been exceeded.
    public static var throttledException: Self { .init(.throttledException) }
    /// This exception is thrown when the number of requests exceeds the limit
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This exception is thrown when the JWT bearer token is invalid or not found for OAuth bearer token based access
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The input fails to satisfy the constraints specified by the service.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentCoreControlErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": BedrockAgentCoreControl.ValidationException.self
    ]
}

extension BedrockAgentCoreControlErrorType: Equatable {
    public static func == (lhs: BedrockAgentCoreControlErrorType, rhs: BedrockAgentCoreControlErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentCoreControlErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
