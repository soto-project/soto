//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgentCoreControl {
    // MARK: Enums

    public enum AgentEndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AgentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ApiKeyCredentialLocation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case header = "HEADER"
        case queryParameter = "QUERY_PARAMETER"
        public var description: String { return self.rawValue }
    }

    public enum AuthorizerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customJwt = "CUSTOM_JWT"
        public var description: String { return self.rawValue }
    }

    public enum BrowserNetworkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `public` = "PUBLIC"
        public var description: String { return self.rawValue }
    }

    public enum BrowserStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum CodeInterpreterNetworkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `public` = "PUBLIC"
        case sandbox = "SANDBOX"
        public var description: String { return self.rawValue }
    }

    public enum CodeInterpreterStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum CredentialProviderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case apiKey = "API_KEY"
        case gatewayIamRole = "GATEWAY_IAM_ROLE"
        case oauth = "OAUTH"
        public var description: String { return self.rawValue }
    }

    public enum CredentialProviderVendorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customOauth2 = "CustomOauth2"
        case githubOauth2 = "GithubOauth2"
        case googleOauth2 = "GoogleOauth2"
        case microsoftOauth2 = "MicrosoftOauth2"
        case salesforceOauth2 = "SalesforceOauth2"
        case slackOauth2 = "SlackOauth2"
        public var description: String { return self.rawValue }
    }

    public enum ExceptionLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "DEBUG"
        public var description: String { return self.rawValue }
    }

    public enum GatewayProtocolType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mcp = "MCP"
        public var description: String { return self.rawValue }
    }

    public enum GatewayStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case ready = "READY"
        case updateUnsuccessful = "UPDATE_UNSUCCESSFUL"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum KeyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customerManagedKey = "CustomerManagedKey"
        case serviceManagedKey = "ServiceManagedKey"
        public var description: String { return self.rawValue }
    }

    public enum MemoryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum MemoryStrategyStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum MemoryStrategyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case semantic = "SEMANTIC"
        case summarization = "SUMMARIZATION"
        case userPreference = "USER_PREFERENCE"
        public var description: String { return self.rawValue }
    }

    public enum NetworkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `public` = "PUBLIC"
        public var description: String { return self.rawValue }
    }

    public enum OverrideType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case semanticOverride = "SEMANTIC_OVERRIDE"
        case summaryOverride = "SUMMARY_OVERRIDE"
        case userPreferenceOverride = "USER_PREFERENCE_OVERRIDE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum SchemaType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case array = "array"
        case boolean = "boolean"
        case integer = "integer"
        case number = "number"
        case object = "object"
        case string = "string"
        public var description: String { return self.rawValue }
    }

    public enum SearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum ServerProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case http = "HTTP"
        case mcp = "MCP"
        public var description: String { return self.rawValue }
    }

    public enum TargetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case ready = "READY"
        case updateUnsuccessful = "UPDATE_UNSUCCESSFUL"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CannotParse"
        case fieldValidationFailed = "FieldValidationFailed"
        case idempotentParameterMismatchException = "IdempotentParameterMismatchException"
        case resourceConflict = "ResourceConflict"
        case rootEventInOtherSession = "EventInOtherSession"
        public var description: String { return self.rawValue }
    }

    public enum ApiSchemaConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The inline payload containing the API schema definition.
        case inlinePayload(String)
        case s3(S3Configuration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .inlinePayload:
                let value = try container.decode(String.self, forKey: .inlinePayload)
                self = .inlinePayload(value)
            case .s3:
                let value = try container.decode(S3Configuration.self, forKey: .s3)
                self = .s3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .inlinePayload(let value):
                try container.encode(value, forKey: .inlinePayload)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inlinePayload = "inlinePayload"
            case s3 = "s3"
        }
    }

    public enum CredentialProvider: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The API key credential provider. This provider uses an API key to authenticate with the target endpoint.
        case apiKeyCredentialProvider(GatewayApiKeyCredentialProvider)
        /// The OAuth credential provider. This provider uses OAuth authentication to access the target endpoint.
        case oauthCredentialProvider(OAuthCredentialProvider)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .apiKeyCredentialProvider:
                let value = try container.decode(GatewayApiKeyCredentialProvider.self, forKey: .apiKeyCredentialProvider)
                self = .apiKeyCredentialProvider(value)
            case .oauthCredentialProvider:
                let value = try container.decode(OAuthCredentialProvider.self, forKey: .oauthCredentialProvider)
                self = .oauthCredentialProvider(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .apiKeyCredentialProvider(let value):
                try container.encode(value, forKey: .apiKeyCredentialProvider)
            case .oauthCredentialProvider(let value):
                try container.encode(value, forKey: .oauthCredentialProvider)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .apiKeyCredentialProvider(let value):
                try value.validate(name: "\(name).apiKeyCredentialProvider")
            case .oauthCredentialProvider(let value):
                try value.validate(name: "\(name).oauthCredentialProvider")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeyCredentialProvider = "apiKeyCredentialProvider"
            case oauthCredentialProvider = "oauthCredentialProvider"
        }
    }

    public enum CustomConfigurationInput: AWSEncodableShape, Sendable {
        /// The semantic override configuration for a custom memory strategy.
        case semanticOverride(SemanticOverrideConfigurationInput)
        /// The summary override configuration for a custom memory strategy.
        case summaryOverride(SummaryOverrideConfigurationInput)
        /// The user preference override configuration for a custom memory strategy.
        case userPreferenceOverride(UserPreferenceOverrideConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .semanticOverride(let value):
                try container.encode(value, forKey: .semanticOverride)
            case .summaryOverride(let value):
                try container.encode(value, forKey: .summaryOverride)
            case .userPreferenceOverride(let value):
                try container.encode(value, forKey: .userPreferenceOverride)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .semanticOverride(let value):
                try value.validate(name: "\(name).semanticOverride")
            case .summaryOverride(let value):
                try value.validate(name: "\(name).summaryOverride")
            case .userPreferenceOverride(let value):
                try value.validate(name: "\(name).userPreferenceOverride")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case semanticOverride = "semanticOverride"
            case summaryOverride = "summaryOverride"
            case userPreferenceOverride = "userPreferenceOverride"
        }
    }

    public enum CustomConsolidationConfiguration: AWSDecodableShape, Sendable {
        /// The semantic consolidation override configuration.
        case semanticConsolidationOverride(SemanticConsolidationOverride)
        /// The summary consolidation override configuration.
        case summaryConsolidationOverride(SummaryConsolidationOverride)
        /// The user preference consolidation override configuration.
        case userPreferenceConsolidationOverride(UserPreferenceConsolidationOverride)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .semanticConsolidationOverride:
                let value = try container.decode(SemanticConsolidationOverride.self, forKey: .semanticConsolidationOverride)
                self = .semanticConsolidationOverride(value)
            case .summaryConsolidationOverride:
                let value = try container.decode(SummaryConsolidationOverride.self, forKey: .summaryConsolidationOverride)
                self = .summaryConsolidationOverride(value)
            case .userPreferenceConsolidationOverride:
                let value = try container.decode(UserPreferenceConsolidationOverride.self, forKey: .userPreferenceConsolidationOverride)
                self = .userPreferenceConsolidationOverride(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case semanticConsolidationOverride = "semanticConsolidationOverride"
            case summaryConsolidationOverride = "summaryConsolidationOverride"
            case userPreferenceConsolidationOverride = "userPreferenceConsolidationOverride"
        }
    }

    public enum CustomConsolidationConfigurationInput: AWSEncodableShape, Sendable {
        /// The semantic consolidation override configuration input.
        case semanticConsolidationOverride(SemanticOverrideConsolidationConfigurationInput)
        /// The summary consolidation override configuration input.
        case summaryConsolidationOverride(SummaryOverrideConsolidationConfigurationInput)
        /// The user preference consolidation override configuration input.
        case userPreferenceConsolidationOverride(UserPreferenceOverrideConsolidationConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .semanticConsolidationOverride(let value):
                try container.encode(value, forKey: .semanticConsolidationOverride)
            case .summaryConsolidationOverride(let value):
                try container.encode(value, forKey: .summaryConsolidationOverride)
            case .userPreferenceConsolidationOverride(let value):
                try container.encode(value, forKey: .userPreferenceConsolidationOverride)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .semanticConsolidationOverride(let value):
                try value.validate(name: "\(name).semanticConsolidationOverride")
            case .summaryConsolidationOverride(let value):
                try value.validate(name: "\(name).summaryConsolidationOverride")
            case .userPreferenceConsolidationOverride(let value):
                try value.validate(name: "\(name).userPreferenceConsolidationOverride")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case semanticConsolidationOverride = "semanticConsolidationOverride"
            case summaryConsolidationOverride = "summaryConsolidationOverride"
            case userPreferenceConsolidationOverride = "userPreferenceConsolidationOverride"
        }
    }

    public enum CustomExtractionConfiguration: AWSDecodableShape, Sendable {
        /// The semantic extraction override configuration.
        case semanticExtractionOverride(SemanticExtractionOverride)
        /// The user preference extraction override configuration.
        case userPreferenceExtractionOverride(UserPreferenceExtractionOverride)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .semanticExtractionOverride:
                let value = try container.decode(SemanticExtractionOverride.self, forKey: .semanticExtractionOverride)
                self = .semanticExtractionOverride(value)
            case .userPreferenceExtractionOverride:
                let value = try container.decode(UserPreferenceExtractionOverride.self, forKey: .userPreferenceExtractionOverride)
                self = .userPreferenceExtractionOverride(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case semanticExtractionOverride = "semanticExtractionOverride"
            case userPreferenceExtractionOverride = "userPreferenceExtractionOverride"
        }
    }

    public enum CustomExtractionConfigurationInput: AWSEncodableShape, Sendable {
        /// The semantic extraction override configuration input.
        case semanticExtractionOverride(SemanticOverrideExtractionConfigurationInput)
        /// The user preference extraction override configuration input.
        case userPreferenceExtractionOverride(UserPreferenceOverrideExtractionConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .semanticExtractionOverride(let value):
                try container.encode(value, forKey: .semanticExtractionOverride)
            case .userPreferenceExtractionOverride(let value):
                try container.encode(value, forKey: .userPreferenceExtractionOverride)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .semanticExtractionOverride(let value):
                try value.validate(name: "\(name).semanticExtractionOverride")
            case .userPreferenceExtractionOverride(let value):
                try value.validate(name: "\(name).userPreferenceExtractionOverride")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case semanticExtractionOverride = "semanticExtractionOverride"
            case userPreferenceExtractionOverride = "userPreferenceExtractionOverride"
        }
    }

    public enum McpTargetConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The Lambda configuration for the Model Context Protocol target. This configuration defines how the gateway uses a Lambda function to communicate with the target.
        case lambda(McpLambdaTargetConfiguration)
        /// The OpenAPI schema for the Model Context Protocol target. This schema defines the API structure of the target.
        case openApiSchema(ApiSchemaConfiguration)
        /// The Smithy model for the Model Context Protocol target. This model defines the API structure of the target using the Smithy specification.
        case smithyModel(ApiSchemaConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .lambda:
                let value = try container.decode(McpLambdaTargetConfiguration.self, forKey: .lambda)
                self = .lambda(value)
            case .openApiSchema:
                let value = try container.decode(ApiSchemaConfiguration.self, forKey: .openApiSchema)
                self = .openApiSchema(value)
            case .smithyModel:
                let value = try container.decode(ApiSchemaConfiguration.self, forKey: .smithyModel)
                self = .smithyModel(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .lambda(let value):
                try container.encode(value, forKey: .lambda)
            case .openApiSchema(let value):
                try container.encode(value, forKey: .openApiSchema)
            case .smithyModel(let value):
                try container.encode(value, forKey: .smithyModel)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .lambda(let value):
                try value.validate(name: "\(name).lambda")
            case .openApiSchema(let value):
                try value.validate(name: "\(name).openApiSchema")
            case .smithyModel(let value):
                try value.validate(name: "\(name).smithyModel")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case lambda = "lambda"
            case openApiSchema = "openApiSchema"
            case smithyModel = "smithyModel"
        }
    }

    public enum MemoryStrategyInput: AWSEncodableShape, Sendable {
        /// Input for creating a custom memory strategy.
        case customMemoryStrategy(CustomMemoryStrategyInput)
        /// Input for creating a semantic memory strategy.
        case semanticMemoryStrategy(SemanticMemoryStrategyInput)
        /// Input for creating a summary memory strategy.
        case summaryMemoryStrategy(SummaryMemoryStrategyInput)
        /// Input for creating a user preference memory strategy.
        case userPreferenceMemoryStrategy(UserPreferenceMemoryStrategyInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customMemoryStrategy(let value):
                try container.encode(value, forKey: .customMemoryStrategy)
            case .semanticMemoryStrategy(let value):
                try container.encode(value, forKey: .semanticMemoryStrategy)
            case .summaryMemoryStrategy(let value):
                try container.encode(value, forKey: .summaryMemoryStrategy)
            case .userPreferenceMemoryStrategy(let value):
                try container.encode(value, forKey: .userPreferenceMemoryStrategy)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .customMemoryStrategy(let value):
                try value.validate(name: "\(name).customMemoryStrategy")
            case .semanticMemoryStrategy(let value):
                try value.validate(name: "\(name).semanticMemoryStrategy")
            case .summaryMemoryStrategy(let value):
                try value.validate(name: "\(name).summaryMemoryStrategy")
            case .userPreferenceMemoryStrategy(let value):
                try value.validate(name: "\(name).userPreferenceMemoryStrategy")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customMemoryStrategy = "customMemoryStrategy"
            case semanticMemoryStrategy = "semanticMemoryStrategy"
            case summaryMemoryStrategy = "summaryMemoryStrategy"
            case userPreferenceMemoryStrategy = "userPreferenceMemoryStrategy"
        }
    }

    public enum Oauth2Discovery: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The authorization server metadata for the OAuth2 provider.
        case authorizationServerMetadata(Oauth2AuthorizationServerMetadata)
        /// The discovery URL for the OAuth2 provider.
        case discoveryUrl(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .authorizationServerMetadata:
                let value = try container.decode(Oauth2AuthorizationServerMetadata.self, forKey: .authorizationServerMetadata)
                self = .authorizationServerMetadata(value)
            case .discoveryUrl:
                let value = try container.decode(String.self, forKey: .discoveryUrl)
                self = .discoveryUrl(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .authorizationServerMetadata(let value):
                try container.encode(value, forKey: .authorizationServerMetadata)
            case .discoveryUrl(let value):
                try container.encode(value, forKey: .discoveryUrl)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .discoveryUrl(let value):
                try self.validate(value, name: "discoveryUrl", parent: name, pattern: "^.+/\\.well-known/openid-configuration$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationServerMetadata = "authorizationServerMetadata"
            case discoveryUrl = "discoveryUrl"
        }
    }

    public enum Oauth2ProviderConfigInput: AWSEncodableShape, Sendable {
        /// The configuration for a custom OAuth2 provider.
        case customOauth2ProviderConfig(CustomOauth2ProviderConfigInput)
        /// The configuration for a GitHub OAuth2 provider.
        case githubOauth2ProviderConfig(GithubOauth2ProviderConfigInput)
        /// The configuration for a Google OAuth2 provider.
        case googleOauth2ProviderConfig(GoogleOauth2ProviderConfigInput)
        /// The configuration for a Microsoft OAuth2 provider.
        case microsoftOauth2ProviderConfig(MicrosoftOauth2ProviderConfigInput)
        /// The configuration for a Salesforce OAuth2 provider.
        case salesforceOauth2ProviderConfig(SalesforceOauth2ProviderConfigInput)
        /// The configuration for a Slack OAuth2 provider.
        case slackOauth2ProviderConfig(SlackOauth2ProviderConfigInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .customOauth2ProviderConfig)
            case .githubOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .githubOauth2ProviderConfig)
            case .googleOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .googleOauth2ProviderConfig)
            case .microsoftOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .microsoftOauth2ProviderConfig)
            case .salesforceOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .salesforceOauth2ProviderConfig)
            case .slackOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .slackOauth2ProviderConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .customOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).customOauth2ProviderConfig")
            case .githubOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).githubOauth2ProviderConfig")
            case .googleOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).googleOauth2ProviderConfig")
            case .microsoftOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).microsoftOauth2ProviderConfig")
            case .salesforceOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).salesforceOauth2ProviderConfig")
            case .slackOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).slackOauth2ProviderConfig")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customOauth2ProviderConfig = "customOauth2ProviderConfig"
            case githubOauth2ProviderConfig = "githubOauth2ProviderConfig"
            case googleOauth2ProviderConfig = "googleOauth2ProviderConfig"
            case microsoftOauth2ProviderConfig = "microsoftOauth2ProviderConfig"
            case salesforceOauth2ProviderConfig = "salesforceOauth2ProviderConfig"
            case slackOauth2ProviderConfig = "slackOauth2ProviderConfig"
        }
    }

    public enum Oauth2ProviderConfigOutput: AWSDecodableShape, Sendable {
        /// The output configuration for a custom OAuth2 provider.
        case customOauth2ProviderConfig(CustomOauth2ProviderConfigOutput)
        /// The output configuration for a GitHub OAuth2 provider.
        case githubOauth2ProviderConfig(GithubOauth2ProviderConfigOutput)
        /// The output configuration for a Google OAuth2 provider.
        case googleOauth2ProviderConfig(GoogleOauth2ProviderConfigOutput)
        /// The output configuration for a Microsoft OAuth2 provider.
        case microsoftOauth2ProviderConfig(MicrosoftOauth2ProviderConfigOutput)
        /// The output configuration for a Salesforce OAuth2 provider.
        case salesforceOauth2ProviderConfig(SalesforceOauth2ProviderConfigOutput)
        /// The output configuration for a Slack OAuth2 provider.
        case slackOauth2ProviderConfig(SlackOauth2ProviderConfigOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .customOauth2ProviderConfig:
                let value = try container.decode(CustomOauth2ProviderConfigOutput.self, forKey: .customOauth2ProviderConfig)
                self = .customOauth2ProviderConfig(value)
            case .githubOauth2ProviderConfig:
                let value = try container.decode(GithubOauth2ProviderConfigOutput.self, forKey: .githubOauth2ProviderConfig)
                self = .githubOauth2ProviderConfig(value)
            case .googleOauth2ProviderConfig:
                let value = try container.decode(GoogleOauth2ProviderConfigOutput.self, forKey: .googleOauth2ProviderConfig)
                self = .googleOauth2ProviderConfig(value)
            case .microsoftOauth2ProviderConfig:
                let value = try container.decode(MicrosoftOauth2ProviderConfigOutput.self, forKey: .microsoftOauth2ProviderConfig)
                self = .microsoftOauth2ProviderConfig(value)
            case .salesforceOauth2ProviderConfig:
                let value = try container.decode(SalesforceOauth2ProviderConfigOutput.self, forKey: .salesforceOauth2ProviderConfig)
                self = .salesforceOauth2ProviderConfig(value)
            case .slackOauth2ProviderConfig:
                let value = try container.decode(SlackOauth2ProviderConfigOutput.self, forKey: .slackOauth2ProviderConfig)
                self = .slackOauth2ProviderConfig(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customOauth2ProviderConfig = "customOauth2ProviderConfig"
            case githubOauth2ProviderConfig = "githubOauth2ProviderConfig"
            case googleOauth2ProviderConfig = "googleOauth2ProviderConfig"
            case microsoftOauth2ProviderConfig = "microsoftOauth2ProviderConfig"
            case salesforceOauth2ProviderConfig = "salesforceOauth2ProviderConfig"
            case slackOauth2ProviderConfig = "slackOauth2ProviderConfig"
        }
    }

    public enum ToolSchema: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The inline payload of the tool schema. This payload contains the schema definition directly in the request.
        case inlinePayload([ToolDefinition])
        /// The Amazon S3 location of the tool schema. This location contains the schema definition file.
        case s3(S3Configuration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .inlinePayload:
                let value = try container.decode([ToolDefinition].self, forKey: .inlinePayload)
                self = .inlinePayload(value)
            case .s3:
                let value = try container.decode(S3Configuration.self, forKey: .s3)
                self = .s3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .inlinePayload(let value):
                try container.encode(value, forKey: .inlinePayload)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inlinePayload = "inlinePayload"
            case s3 = "s3"
        }
    }

    // MARK: Shapes

    public struct Agent: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent runtime.
        public let agentRuntimeArn: String
        /// The unique identifier of the agent runtime.
        public let agentRuntimeId: String
        /// The name of the agent runtime.
        public let agentRuntimeName: String
        /// The version of the agent runtime.
        public let agentRuntimeVersion: String
        /// The description of the agent runtime.
        public let description: String
        /// The timestamp when the agent runtime was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the agent runtime.
        public let status: AgentStatus

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeId: String, agentRuntimeName: String, agentRuntimeVersion: String, description: String, lastUpdatedAt: Date, status: AgentStatus) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeName = agentRuntimeName
            self.agentRuntimeVersion = agentRuntimeVersion
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeName = "agentRuntimeName"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case description = "description"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
        }
    }

    public struct AgentEndpoint: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent runtime associated with the endpoint.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the agent runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The timestamp when the agent runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the agent runtime endpoint.
        public let description: String?
        /// The unique identifier of the agent runtime endpoint.
        public let id: String
        /// The timestamp when the agent runtime endpoint was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The live version of the agent runtime endpoint. This is the version that is currently serving requests.
        public let liveVersion: String?
        /// The name of the agent runtime endpoint.
        public let name: String
        /// The current status of the agent runtime endpoint.
        public let status: AgentEndpointStatus
        /// The target version of the agent runtime endpoint. This is the version that the endpoint is being updated to.
        public let targetVersion: String?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, createdAt: Date, description: String? = nil, id: String, lastUpdatedAt: Date, liveVersion: String? = nil, name: String, status: AgentEndpointStatus, targetVersion: String? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.liveVersion = liveVersion
            self.name = name
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case liveVersion = "liveVersion"
            case name = "name"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct ApiKeyCredentialProviderItem: AWSDecodableShape {
        /// The timestamp when the API key credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the API key credential provider.
        public let credentialProviderArn: String
        /// The timestamp when the API key credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the API key credential provider.
        public let name: String

        @inlinable
        public init(createdTime: Date, credentialProviderArn: String, lastUpdatedTime: Date, name: String) {
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct BrowserNetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The network mode for the browser. This field specifies how the browser connects to the network.
        public let networkMode: BrowserNetworkMode

        @inlinable
        public init(networkMode: BrowserNetworkMode) {
            self.networkMode = networkMode
        }

        private enum CodingKeys: String, CodingKey {
            case networkMode = "networkMode"
        }
    }

    public struct BrowserSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the browser.
        public let browserArn: String
        /// The unique identifier of the browser.
        public let browserId: String
        /// The timestamp when the browser was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the browser.
        public let description: String?
        /// The timestamp when the browser was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the browser.
        public let name: String?
        /// The current status of the browser.
        public let status: BrowserStatus

        @inlinable
        public init(browserArn: String, browserId: String, createdAt: Date, description: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, status: BrowserStatus) {
            self.browserArn = browserArn
            self.browserId = browserId
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserArn = "browserArn"
            case browserId = "browserId"
            case createdAt = "createdAt"
            case description = "description"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct CodeInterpreterNetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The network mode for the code interpreter. This field specifies how the code interpreter connects to the network.
        public let networkMode: CodeInterpreterNetworkMode

        @inlinable
        public init(networkMode: CodeInterpreterNetworkMode) {
            self.networkMode = networkMode
        }

        private enum CodingKeys: String, CodingKey {
            case networkMode = "networkMode"
        }
    }

    public struct CodeInterpreterSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the code interpreter.
        public let codeInterpreterArn: String
        /// The unique identifier of the code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the code interpreter.
        public let description: String?
        /// The timestamp when the code interpreter was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the code interpreter.
        public let name: String?
        /// The current status of the code interpreter.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterArn: String, codeInterpreterId: String, createdAt: Date, description: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, status: CodeInterpreterStatus) {
            self.codeInterpreterArn = codeInterpreterArn
            self.codeInterpreterId = codeInterpreterId
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterArn = "codeInterpreterArn"
            case codeInterpreterId = "codeInterpreterId"
            case createdAt = "createdAt"
            case description = "description"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct ContainerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ECR URI of the container.
        public let containerUri: String

        @inlinable
        public init(containerUri: String) {
            self.containerUri = containerUri
        }

        public func validate(name: String) throws {
            try self.validate(self.containerUri, name: "containerUri", parent: name, max: 1024)
            try self.validate(self.containerUri, name: "containerUri", parent: name, min: 1)
            try self.validate(self.containerUri, name: "containerUri", parent: name, pattern: "^\\d{12}\\.dkr\\.ecr\\.([a-z0-9-]+)\\.amazonaws\\.com/((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*)([:@]\\S+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case containerUri = "containerUri"
        }
    }

    public struct CreateAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the agent runtime to create an endpoint for.
        public let agentRuntimeId: String
        /// The version of the agent runtime to use for the endpoint.
        public let agentRuntimeVersion: String?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The description of the agent runtime endpoint.
        public let description: String?
        /// The name of the agent runtime endpoint.
        public let name: String

        @inlinable
        public init(agentRuntimeId: String, agentRuntimeVersion: String? = nil, clientToken: String? = CreateAgentRuntimeEndpointRequest.idempotencyToken(), description: String? = nil, name: String) {
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.clientToken = clientToken
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            try container.encodeIfPresent(self.agentRuntimeVersion, forKey: .agentRuntimeVersion)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, max: 5)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, min: 1)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, pattern: "^([1-9][0-9]{0,4})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeVersion = "agentRuntimeVersion"
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
        }
    }

    public struct CreateAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent runtime.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the agent runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The timestamp when the agent runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The current status of the agent runtime endpoint.
        public let status: AgentEndpointStatus
        /// The target version of the agent runtime for the endpoint.
        public let targetVersion: String

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, createdAt: Date, status: AgentEndpointStatus, targetVersion: String) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.createdAt = createdAt
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case createdAt = "createdAt"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct CreateAgentRuntimeRequest: AWSEncodableShape {
        /// The artifact of the agent.
        public let agentRuntimeArtifact: AgentArtifact
        /// The name of the secure agent.
        public let agentRuntimeName: String
        /// The authorizer configuration for the agent runtime.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The description of the agent runtime.
        public let description: String?
        /// Environment variables to set in the agent runtime environment.
        public let environmentVariables: [String: String]?
        /// The network configuration for the agent runtime.
        public let networkConfiguration: NetworkConfiguration
        public let protocolConfiguration: ProtocolConfiguration?
        /// The IAM role ARN that provides permissions for the agent runtime.
        public let roleArn: String

        @inlinable
        public init(agentRuntimeArtifact: AgentArtifact, agentRuntimeName: String, authorizerConfiguration: AuthorizerConfiguration? = nil, clientToken: String? = CreateAgentRuntimeRequest.idempotencyToken(), description: String? = nil, environmentVariables: [String: String]? = nil, networkConfiguration: NetworkConfiguration, protocolConfiguration: ProtocolConfiguration? = nil, roleArn: String) {
            self.agentRuntimeArtifact = agentRuntimeArtifact
            self.agentRuntimeName = agentRuntimeName
            self.authorizerConfiguration = authorizerConfiguration
            self.clientToken = clientToken
            self.description = description
            self.environmentVariables = environmentVariables
            self.networkConfiguration = networkConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.agentRuntimeArtifact.validate(name: "\(name).agentRuntimeArtifact")
            try self.validate(self.agentRuntimeName, name: "agentRuntimeName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.authorizerConfiguration?.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 100)
                try validate($0.key, name: "environmentVariables.key", parent: name, min: 1)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 5000)
            }
            try self.validate(self.environmentVariables, name: "environmentVariables", parent: name, max: 50)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArtifact = "agentRuntimeArtifact"
            case agentRuntimeName = "agentRuntimeName"
            case authorizerConfiguration = "authorizerConfiguration"
            case clientToken = "clientToken"
            case description = "description"
            case environmentVariables = "environmentVariables"
            case networkConfiguration = "networkConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case roleArn = "roleArn"
        }
    }

    public struct CreateAgentRuntimeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent runtime.
        public let agentRuntimeArn: String
        /// The unique identifier of the agent runtime.
        public let agentRuntimeId: String
        /// The version of the agent runtime.
        public let agentRuntimeVersion: String
        /// The timestamp when the agent runtime was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The current status of the agent runtime.
        public let status: AgentStatus
        /// The workload identity details for the agent runtime.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeId: String, agentRuntimeVersion: String, createdAt: Date, status: AgentStatus, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.createdAt = createdAt
            self.status = status
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case createdAt = "createdAt"
            case status = "status"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct CreateApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The API key to use for authentication. This value is encrypted and stored securely.
        public let apiKey: String
        /// The name of the API key credential provider. The name must be unique within your account.
        public let name: String

        @inlinable
        public init(apiKey: String, name: String) {
            self.apiKey = apiKey
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 65536)
            try self.validate(self.apiKey, name: "apiKey", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case name = "name"
        }
    }

    public struct CreateApiKeyCredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the secret containing the API key.
        public let apiKeySecretArn: Secret
        /// The Amazon Resource Name (ARN) of the created API key credential provider.
        public let credentialProviderArn: String
        /// The name of the created API key credential provider.
        public let name: String

        @inlinable
        public init(apiKeySecretArn: Secret, credentialProviderArn: String, name: String) {
            self.apiKeySecretArn = apiKeySecretArn
            self.credentialProviderArn = credentialProviderArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySecretArn = "apiKeySecretArn"
            case credentialProviderArn = "credentialProviderArn"
            case name = "name"
        }
    }

    public struct CreateBrowserRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
        public let clientToken: String?
        /// The description of the browser.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the browser to access Amazon Web Services services.
        public let executionRoleArn: String?
        /// The name of the browser. The name must be unique within your account.
        public let name: String
        /// The network configuration for the browser. This configuration specifies the network mode for the browser.
        public let networkConfiguration: BrowserNetworkConfiguration
        /// The recording configuration for the browser. When enabled, browser sessions are recorded and stored in the specified Amazon S3 location.
        public let recording: RecordingConfig?

        @inlinable
        public init(clientToken: String? = CreateBrowserRequest.idempotencyToken(), description: String? = nil, executionRoleArn: String? = nil, name: String, networkConfiguration: BrowserNetworkConfiguration, recording: RecordingConfig? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.recording = recording
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
            case recording = "recording"
        }
    }

    public struct CreateBrowserResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created browser.
        public let browserArn: String
        /// The unique identifier of the created browser.
        public let browserId: String
        /// The timestamp when the browser was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The current status of the browser.
        public let status: BrowserStatus

        @inlinable
        public init(browserArn: String, browserId: String, createdAt: Date, status: BrowserStatus) {
            self.browserArn = browserArn
            self.browserId = browserId
            self.createdAt = createdAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserArn = "browserArn"
            case browserId = "browserId"
            case createdAt = "createdAt"
            case status = "status"
        }
    }

    public struct CreateCodeInterpreterRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
        public let clientToken: String?
        /// The description of the code interpreter.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the code interpreter to access Amazon Web Services services.
        public let executionRoleArn: String?
        /// The name of the code interpreter. The name must be unique within your account.
        public let name: String
        /// The network configuration for the code interpreter. This configuration specifies the network mode for the code interpreter.
        public let networkConfiguration: CodeInterpreterNetworkConfiguration

        @inlinable
        public init(clientToken: String? = CreateCodeInterpreterRequest.idempotencyToken(), description: String? = nil, executionRoleArn: String? = nil, name: String, networkConfiguration: CodeInterpreterNetworkConfiguration) {
            self.clientToken = clientToken
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.name = name
            self.networkConfiguration = networkConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
        }
    }

    public struct CreateCodeInterpreterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created code interpreter.
        public let codeInterpreterArn: String
        /// The unique identifier of the created code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The current status of the code interpreter.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterArn: String, codeInterpreterId: String, createdAt: Date, status: CodeInterpreterStatus) {
            self.codeInterpreterArn = codeInterpreterArn
            self.codeInterpreterId = codeInterpreterId
            self.createdAt = createdAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterArn = "codeInterpreterArn"
            case codeInterpreterId = "codeInterpreterId"
            case createdAt = "createdAt"
            case status = "status"
        }
    }

    public struct CreateGatewayRequest: AWSEncodableShape {
        /// The authorizer configuration for the Gateway.
        public let authorizerConfiguration: AuthorizerConfiguration
        /// The type of authorizer to use for the gateway.
        public let authorizerType: AuthorizerType
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
        public let clientToken: String?
        /// The description of the gateway.
        public let description: String?
        /// The verbosity of exception messages. Use DEBUG mode to see granular exception messages from a Gateway. If this parameter is not set, exception messages are by default sanitized for presentation to end users.
        public let exceptionLevel: ExceptionLevel?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt data associated with the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway. The name must be unique within your account.
        public let name: String
        /// The configuration settings for the protocol specified in the protocolType parameter.
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The protocol type for the gateway. Currently supports MCP (Model Context Protocol).
        public let protocolType: GatewayProtocolType
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the gateway to access Amazon Web Services services.
        public let roleArn: String

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration, authorizerType: AuthorizerType, clientToken: String? = CreateGatewayRequest.idempotencyToken(), description: String? = nil, exceptionLevel: ExceptionLevel? = nil, kmsKeyArn: String? = nil, name: String, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.clientToken = clientToken
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.authorizerConfiguration.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.protocolConfiguration?.validate(name: "\(name).protocolConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case clientToken = "clientToken"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
        }
    }

    public struct CreateGatewayResponse: AWSDecodableShape {
        /// The authorizer configuration for the created Gateway.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The type of authorizer used by the gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the gateway.
        public let description: String?
        /// The verbosity of exception messages. Use DEBUG mode to see granular exception messages from a Gateway. If this parameter is not set, exception messages are by default sanitized for presentation to end users.
        public let exceptionLevel: ExceptionLevel?
        /// The Amazon Resource Name (ARN) of the created gateway.
        public let gatewayArn: String
        /// The unique identifier of the created gateway.
        public let gatewayId: String
        /// The URL endpoint for the created gateway.
        public let gatewayUrl: String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt data associated with the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway.
        public let name: String
        /// The configuration settings for the protocol used by the gateway.
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The protocol type of the gateway.
        public let protocolType: GatewayProtocolType
        /// The Amazon Resource Name (ARN) of the IAM role associated with the gateway.
        public let roleArn: String?
        /// The current status of the gateway.
        public let status: GatewayStatus
        /// The reasons for the current status of the gateway.
        public let statusReasons: [String]?
        /// The timestamp when the gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The workload identity details for the created Gateway.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayArn: String, gatewayId: String, gatewayUrl: String? = nil, kmsKeyArn: String? = nil, name: String, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String? = nil, status: GatewayStatus, statusReasons: [String]? = nil, updatedAt: Date, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
            self.gatewayUrl = gatewayUrl
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
            case gatewayUrl = "gatewayUrl"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct CreateGatewayTargetRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
        public let clientToken: String?
        /// The credential provider configurations for the target. These configurations specify how the gateway authenticates with the target endpoint.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The description of the gateway target.
        public let description: String?
        /// The identifier of the gateway to create a target for. This can be either the gateway ID or the gateway ARN.
        public let gatewayIdentifier: String
        /// The name of the gateway target. The name must be unique within the gateway.
        public let name: String
        /// The configuration settings for the target, including endpoint information and schema definitions.
        public let targetConfiguration: TargetConfiguration

        @inlinable
        public init(clientToken: String? = CreateGatewayTargetRequest.idempotencyToken(), credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayIdentifier: String, name: String, targetConfiguration: TargetConfiguration) {
            self.clientToken = clientToken
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayIdentifier = gatewayIdentifier
            self.name = name
            self.targetConfiguration = targetConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.credentialProviderConfigurations, forKey: .credentialProviderConfigurations)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.targetConfiguration, forKey: .targetConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.credentialProviderConfigurations.forEach {
                try $0.validate(name: "\(name).credentialProviderConfigurations[]")
            }
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, max: 1)
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.targetConfiguration.validate(name: "\(name).targetConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case name = "name"
            case targetConfiguration = "targetConfiguration"
        }
    }

    public struct CreateGatewayTargetResponse: AWSDecodableShape {
        /// The timestamp when the target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The credential provider configurations for the target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The description of the target.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the gateway.
        public let gatewayArn: String
        /// The name of the target.
        public let name: String
        /// The current status of the target.
        public let status: TargetStatus
        /// The reasons for the current status of the target.
        public let statusReasons: [String]?
        /// The configuration settings for the target.
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the created target.
        public let targetId: String
        /// The timestamp when the target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayArn: String, name: String, status: TargetStatus, statusReasons: [String]? = nil, targetConfiguration: TargetConfiguration, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayArn = gatewayArn
            self.name = name
            self.status = status
            self.statusReasons = statusReasons
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case gatewayArn = "gatewayArn"
            case name = "name"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetConfiguration = "targetConfiguration"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateMemoryInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
        public let clientToken: String?
        /// The description of the memory.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the memory data.
        public let encryptionKeyArn: String?
        /// The duration after which memory events expire. Specified as an ISO 8601 duration.
        public let eventExpiryDuration: Int
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the memory to access Amazon Web Services services.
        public let memoryExecutionRoleArn: String?
        /// The memory strategies to use for this memory. Strategies define how information is extracted, processed, and consolidated.
        public let memoryStrategies: [MemoryStrategyInput]?
        /// The name of the memory. The name must be unique within your account.
        public let name: String

        @inlinable
        public init(clientToken: String? = CreateMemoryInput.idempotencyToken(), description: String? = nil, encryptionKeyArn: String? = nil, eventExpiryDuration: Int, memoryExecutionRoleArn: String? = nil, memoryStrategies: [MemoryStrategyInput]? = nil, name: String) {
            self.clientToken = clientToken
            self.description = description
            self.encryptionKeyArn = encryptionKeyArn
            self.eventExpiryDuration = eventExpiryDuration
            self.memoryExecutionRoleArn = memoryExecutionRoleArn
            self.memoryStrategies = memoryStrategies
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memoryExecutionRoleArn, name: "memoryExecutionRoleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.memoryStrategies?.forEach {
                try $0.validate(name: "\(name).memoryStrategies[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case encryptionKeyArn = "encryptionKeyArn"
            case eventExpiryDuration = "eventExpiryDuration"
            case memoryExecutionRoleArn = "memoryExecutionRoleArn"
            case memoryStrategies = "memoryStrategies"
            case name = "name"
        }
    }

    public struct CreateMemoryOutput: AWSDecodableShape {
        /// The details of the created memory, including its ID, ARN, name, description, and configuration settings.
        public let memory: Memory?

        @inlinable
        public init(memory: Memory? = nil) {
            self.memory = memory
        }

        private enum CodingKeys: String, CodingKey {
            case memory = "memory"
        }
    }

    public struct CreateOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The vendor of the OAuth2 credential provider. This specifies which OAuth2 implementation to use.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The name of the OAuth2 credential provider. The name must be unique within your account.
        public let name: String
        /// The configuration settings for the OAuth2 provider, including client ID, client secret, and other vendor-specific settings.
        public let oauth2ProviderConfigInput: Oauth2ProviderConfigInput

        @inlinable
        public init(credentialProviderVendor: CredentialProviderVendorType, name: String, oauth2ProviderConfigInput: Oauth2ProviderConfigInput) {
            self.credentialProviderVendor = credentialProviderVendor
            self.name = name
            self.oauth2ProviderConfigInput = oauth2ProviderConfigInput
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.oauth2ProviderConfigInput.validate(name: "\(name).oauth2ProviderConfigInput")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviderVendor = "credentialProviderVendor"
            case name = "name"
            case oauth2ProviderConfigInput = "oauth2ProviderConfigInput"
        }
    }

    public struct CreateOauth2CredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
        public let clientSecretArn: Secret
        /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
        public let credentialProviderArn: String
        /// The name of the OAuth2 credential provider.
        public let name: String

        @inlinable
        public init(clientSecretArn: Secret, credentialProviderArn: String, name: String) {
            self.clientSecretArn = clientSecretArn
            self.credentialProviderArn = credentialProviderArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case clientSecretArn = "clientSecretArn"
            case credentialProviderArn = "credentialProviderArn"
            case name = "name"
        }
    }

    public struct CreateWorkloadIdentityRequest: AWSEncodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The name of the workload identity. The name must be unique within your account.
        public let name: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, name: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.name = name
        }

        public func validate(name: String) throws {
            try self.allowedResourceOauth2ReturnUrls?.forEach {
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, max: 2048)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, min: 1)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, pattern: "^\\w+:(\\/?\\/?)[^\\s]+$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case name = "name"
        }
    }

    public struct CreateWorkloadIdentityResponse: AWSDecodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, name: String, workloadIdentityArn: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct CredentialProviderConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The credential provider. This field contains the specific configuration for the credential provider type.
        public let credentialProvider: CredentialProvider?
        /// The type of credential provider. This field specifies which authentication method the gateway uses.
        public let credentialProviderType: CredentialProviderType

        @inlinable
        public init(credentialProvider: CredentialProvider? = nil, credentialProviderType: CredentialProviderType) {
            self.credentialProvider = credentialProvider
            self.credentialProviderType = credentialProviderType
        }

        public func validate(name: String) throws {
            try self.credentialProvider?.validate(name: "\(name).credentialProvider")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProvider = "credentialProvider"
            case credentialProviderType = "credentialProviderType"
        }
    }

    public struct CustomJWTAuthorizerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Represents individual audience values that are validated in the incoming JWT token validation process.
        public let allowedAudience: [String]?
        /// Represents individual client IDs that are validated in the incoming JWT token validation process.
        public let allowedClients: [String]?
        /// This URL is used to fetch OpenID Connect configuration or authorization server metadata for validating incoming tokens.
        public let discoveryUrl: String

        @inlinable
        public init(allowedAudience: [String]? = nil, allowedClients: [String]? = nil, discoveryUrl: String) {
            self.allowedAudience = allowedAudience
            self.allowedClients = allowedClients
            self.discoveryUrl = discoveryUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.allowedAudience, name: "allowedAudience", parent: name, min: 1)
            try self.validate(self.allowedClients, name: "allowedClients", parent: name, min: 1)
            try self.validate(self.discoveryUrl, name: "discoveryUrl", parent: name, pattern: "^.+/\\.well-known/openid-configuration$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAudience = "allowedAudience"
            case allowedClients = "allowedClients"
            case discoveryUrl = "discoveryUrl"
        }
    }

    public struct CustomMemoryStrategyInput: AWSEncodableShape {
        /// The configuration for the custom memory strategy.
        public let configuration: CustomConfigurationInput?
        /// The description of the custom memory strategy.
        public let description: String?
        /// The name of the custom memory strategy.
        public let name: String
        /// The namespaces associated with the custom memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(configuration: CustomConfigurationInput? = nil, description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct CustomOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the custom OAuth2 provider.
        public let clientId: String
        /// The client secret for the custom OAuth2 provider.
        public let clientSecret: String
        /// The OAuth2 discovery information for the custom provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String, clientSecret: String, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oauthDiscovery = oauthDiscovery
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
            try self.oauthDiscovery.validate(name: "\(name).oauthDiscovery")
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct CustomOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The OAuth2 discovery information for the custom provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(oauthDiscovery: Oauth2Discovery) {
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct DeleteAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the agent runtime associated with the endpoint.
        public let agentRuntimeId: String
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The name of the agent runtime endpoint to delete.
        public let endpointName: String

        @inlinable
        public init(agentRuntimeId: String, clientToken: String? = DeleteAgentRuntimeEndpointRequest.idempotencyToken(), endpointName: String) {
            self.agentRuntimeId = agentRuntimeId
            self.clientToken = clientToken
            self.endpointName = endpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.endpointName, key: "endpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The current status of the agent runtime endpoint deletion.
        public let status: AgentEndpointStatus

        @inlinable
        public init(status: AgentEndpointStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteAgentRuntimeRequest: AWSEncodableShape {
        /// The unique identifier of the agent runtime to delete.
        public let agentRuntimeId: String

        @inlinable
        public init(agentRuntimeId: String) {
            self.agentRuntimeId = agentRuntimeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentRuntimeResponse: AWSDecodableShape {
        /// The current status of the agent runtime deletion.
        public let status: AgentStatus

        @inlinable
        public init(status: AgentStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The name of the API key credential provider to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteApiKeyCredentialProviderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteBrowserRequest: AWSEncodableShape {
        /// The unique identifier of the browser to delete.
        public let browserId: String
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?

        @inlinable
        public init(browserId: String, clientToken: String? = DeleteBrowserRequest.idempotencyToken()) {
            self.browserId = browserId
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserId, key: "browserId")
            request.encodeQuery(self.clientToken, key: "clientToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserId, name: "browserId", parent: name, pattern: "^(aws\\.browser\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBrowserResponse: AWSDecodableShape {
        /// The unique identifier of the deleted browser.
        public let browserId: String
        /// The timestamp when the browser was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the browser deletion.
        public let status: BrowserStatus

        @inlinable
        public init(browserId: String, lastUpdatedAt: Date, status: BrowserStatus) {
            self.browserId = browserId
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserId = "browserId"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
        }
    }

    public struct DeleteCodeInterpreterRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the code interpreter to delete.
        public let codeInterpreterId: String

        @inlinable
        public init(clientToken: String? = DeleteCodeInterpreterRequest.idempotencyToken(), codeInterpreterId: String) {
            self.clientToken = clientToken
            self.codeInterpreterId = codeInterpreterId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.codeInterpreterId, key: "codeInterpreterId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.codeInterpreterId, name: "codeInterpreterId", parent: name, pattern: "^(aws\\.codeinterpreter\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCodeInterpreterResponse: AWSDecodableShape {
        /// The unique identifier of the deleted code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the code interpreter deletion.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterId: String, lastUpdatedAt: Date, status: CodeInterpreterStatus) {
            self.codeInterpreterId = codeInterpreterId
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterId = "codeInterpreterId"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
        }
    }

    public struct DeleteGatewayRequest: AWSEncodableShape {
        /// The identifier of the gateway to delete. This can be either the gateway ID or the gateway ARN.
        public let gatewayIdentifier: String

        @inlinable
        public init(gatewayIdentifier: String) {
            self.gatewayIdentifier = gatewayIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGatewayResponse: AWSDecodableShape {
        /// The unique identifier of the deleted Gateway.
        public let gatewayId: String
        /// The current status of the Gateway deletion.
        public let status: GatewayStatus
        /// The reasons for the current status of the Gateway deletion.
        public let statusReasons: [String]?

        @inlinable
        public init(gatewayId: String, status: GatewayStatus, statusReasons: [String]? = nil) {
            self.gatewayId = gatewayId
            self.status = status
            self.statusReasons = statusReasons
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayId = "gatewayId"
            case status = "status"
            case statusReasons = "statusReasons"
        }
    }

    public struct DeleteGatewayTargetRequest: AWSEncodableShape {
        /// The unique identifier of the Gateway associated with the target.
        public let gatewayIdentifier: String
        /// The unique identifier of the Gateway Target to delete.
        public let targetId: String

        @inlinable
        public init(gatewayIdentifier: String, targetId: String) {
            self.gatewayIdentifier = gatewayIdentifier
            self.targetId = targetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            request.encodePath(self.targetId, key: "targetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.targetId, name: "targetId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGatewayTargetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Gateway.
        public let gatewayArn: String
        /// The current status of the Gateway Target deletion.
        public let status: TargetStatus
        /// The reasons for the current status of the Gateway Target deletion.
        public let statusReasons: [String]?
        /// The unique identifier of the deleted Gateway Target.
        public let targetId: String

        @inlinable
        public init(gatewayArn: String, status: TargetStatus, statusReasons: [String]? = nil, targetId: String) {
            self.gatewayArn = gatewayArn
            self.status = status
            self.statusReasons = statusReasons
            self.targetId = targetId
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayArn = "gatewayArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetId = "targetId"
        }
    }

    public struct DeleteMemoryInput: AWSEncodableShape {
        /// A client token is used for keeping track of idempotent requests. It can contain a session id which can be around 250 chars, combined with a unique AWS identifier.
        public let clientToken: String?
        /// The unique identifier of the memory to delete.
        public let memoryId: String

        @inlinable
        public init(clientToken: String? = DeleteMemoryInput.idempotencyToken(), memoryId: String) {
            self.clientToken = clientToken
            self.memoryId = memoryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.memoryId, key: "memoryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemoryOutput: AWSDecodableShape {
        /// The unique identifier of the deleted memory.
        public let memoryId: String
        /// The current status of the memory deletion.
        public let status: MemoryStatus?

        @inlinable
        public init(memoryId: String, status: MemoryStatus? = nil) {
            self.memoryId = memoryId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case memoryId = "memoryId"
            case status = "status"
        }
    }

    public struct DeleteMemoryStrategyInput: AWSEncodableShape {
        /// The unique identifier of the memory strategy to delete.
        public let memoryStrategyId: String

        @inlinable
        public init(memoryStrategyId: String) {
            self.memoryStrategyId = memoryStrategyId
        }

        private enum CodingKeys: String, CodingKey {
            case memoryStrategyId = "memoryStrategyId"
        }
    }

    public struct DeleteOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The name of the OAuth2 credential provider to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteOauth2CredentialProviderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWorkloadIdentityRequest: AWSEncodableShape {
        /// The name of the workload identity to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteWorkloadIdentityResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GatewayApiKeyCredentialProvider: AWSEncodableShape & AWSDecodableShape {
        /// The location of the API key credential. This field specifies where in the request the API key should be placed.
        public let credentialLocation: ApiKeyCredentialLocation?
        /// The name of the credential parameter for the API key. This parameter name is used when sending the API key to the target endpoint.
        public let credentialParameterName: String?
        /// The prefix for the API key credential. This prefix is added to the API key when sending it to the target endpoint.
        public let credentialPrefix: String?
        /// The Amazon Resource Name (ARN) of the API key credential provider. This ARN identifies the provider in Amazon Web Services.
        public let providerArn: String

        @inlinable
        public init(credentialLocation: ApiKeyCredentialLocation? = nil, credentialParameterName: String? = nil, credentialPrefix: String? = nil, providerArn: String) {
            self.credentialLocation = credentialLocation
            self.credentialParameterName = credentialParameterName
            self.credentialPrefix = credentialPrefix
            self.providerArn = providerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialParameterName, name: "credentialParameterName", parent: name, max: 64)
            try self.validate(self.credentialParameterName, name: "credentialParameterName", parent: name, min: 1)
            try self.validate(self.credentialPrefix, name: "credentialPrefix", parent: name, max: 64)
            try self.validate(self.credentialPrefix, name: "credentialPrefix", parent: name, min: 1)
            try self.validate(self.providerArn, name: "providerArn", parent: name, pattern: "^arn:([^:]*):([^:]*):([^:]*):([0-9]{12})?:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialLocation = "credentialLocation"
            case credentialParameterName = "credentialParameterName"
            case credentialPrefix = "credentialPrefix"
            case providerArn = "providerArn"
        }
    }

    public struct GatewaySummary: AWSDecodableShape {
        /// The type of authorizer used by the gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the gateway.
        public let description: String?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The name of the gateway.
        public let name: String
        /// The protocol type used by the gateway.
        public let protocolType: GatewayProtocolType
        /// The current status of the gateway.
        public let status: GatewayStatus
        /// The timestamp when the gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, gatewayId: String, name: String, protocolType: GatewayProtocolType, status: GatewayStatus, updatedAt: Date) {
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.gatewayId = gatewayId
            self.name = name
            self.protocolType = protocolType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case gatewayId = "gatewayId"
            case name = "name"
            case protocolType = "protocolType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the agent runtime associated with the endpoint.
        public let agentRuntimeId: String
        /// The name of the agent runtime endpoint to retrieve.
        public let endpointName: String

        @inlinable
        public init(agentRuntimeId: String, endpointName: String) {
            self.agentRuntimeId = agentRuntimeId
            self.endpointName = endpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodePath(self.endpointName, key: "endpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent runtime.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the agent runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The timestamp when the agent runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the agent runtime endpoint.
        public let description: String?
        /// The reason for failure if the agent runtime endpoint is in a failed state.
        public let failureReason: String?
        /// The unique identifier of the agent runtime endpoint.
        public let id: String
        /// The timestamp when the agent runtime endpoint was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The currently deployed version of the agent runtime on the endpoint.
        public let liveVersion: String?
        /// The name of the agent runtime endpoint.
        public let name: String
        /// The current status of the agent runtime endpoint.
        public let status: AgentEndpointStatus
        /// The target version of the agent runtime for the endpoint.
        public let targetVersion: String?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, createdAt: Date, description: String? = nil, failureReason: String? = nil, id: String, lastUpdatedAt: Date, liveVersion: String? = nil, name: String, status: AgentEndpointStatus, targetVersion: String? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.createdAt = createdAt
            self.description = description
            self.failureReason = failureReason
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.liveVersion = liveVersion
            self.name = name
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case createdAt = "createdAt"
            case description = "description"
            case failureReason = "failureReason"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case liveVersion = "liveVersion"
            case name = "name"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct GetAgentRuntimeRequest: AWSEncodableShape {
        /// The unique identifier of the agent runtime to retrieve.
        public let agentRuntimeId: String
        /// The version of the agent runtime to retrieve.
        public let agentRuntimeVersion: String?

        @inlinable
        public init(agentRuntimeId: String, agentRuntimeVersion: String? = nil) {
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.agentRuntimeVersion, key: "version")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, max: 5)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, min: 1)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, pattern: "^([1-9][0-9]{0,4})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentRuntimeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent runtime.
        public let agentRuntimeArn: String
        /// The artifact of the agent runtime.
        public let agentRuntimeArtifact: AgentArtifact?
        /// The unique identifier of the agent runtime.
        public let agentRuntimeId: String
        /// The name of the agent runtime.
        public let agentRuntimeName: String
        /// The version of the agent runtime.
        public let agentRuntimeVersion: String
        /// The authorizer configuration for the agent runtime.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The timestamp when the agent runtime was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the agent runtime.
        public let description: String?
        /// Environment variables set in the agent runtime environment.
        public let environmentVariables: [String: String]?
        /// The timestamp when the agent runtime was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The network configuration for the agent runtime.
        public let networkConfiguration: NetworkConfiguration
        public let protocolConfiguration: ProtocolConfiguration?
        /// The IAM role ARN that provides permissions for the agent runtime.
        public let roleArn: String
        /// The current status of the agent runtime.
        public let status: AgentStatus
        /// The workload identity details for the agent runtime.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeArtifact: AgentArtifact? = nil, agentRuntimeId: String, agentRuntimeName: String, agentRuntimeVersion: String, authorizerConfiguration: AuthorizerConfiguration? = nil, createdAt: Date, description: String? = nil, environmentVariables: [String: String]? = nil, lastUpdatedAt: Date, networkConfiguration: NetworkConfiguration, protocolConfiguration: ProtocolConfiguration? = nil, roleArn: String, status: AgentStatus, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeArtifact = agentRuntimeArtifact
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeName = agentRuntimeName
            self.agentRuntimeVersion = agentRuntimeVersion
            self.authorizerConfiguration = authorizerConfiguration
            self.createdAt = createdAt
            self.description = description
            self.environmentVariables = environmentVariables
            self.lastUpdatedAt = lastUpdatedAt
            self.networkConfiguration = networkConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.roleArn = roleArn
            self.status = status
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeArtifact = "agentRuntimeArtifact"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeName = "agentRuntimeName"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case authorizerConfiguration = "authorizerConfiguration"
            case createdAt = "createdAt"
            case description = "description"
            case environmentVariables = "environmentVariables"
            case lastUpdatedAt = "lastUpdatedAt"
            case networkConfiguration = "networkConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case roleArn = "roleArn"
            case status = "status"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct GetApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The name of the API key credential provider to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetApiKeyCredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the API key secret in AWS Secrets Manager.
        public let apiKeySecretArn: Secret
        /// The timestamp when the API key credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the API key credential provider.
        public let credentialProviderArn: String
        /// The timestamp when the API key credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the API key credential provider.
        public let name: String

        @inlinable
        public init(apiKeySecretArn: Secret, createdTime: Date, credentialProviderArn: String, lastUpdatedTime: Date, name: String) {
            self.apiKeySecretArn = apiKeySecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySecretArn = "apiKeySecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct GetBrowserRequest: AWSEncodableShape {
        /// The unique identifier of the browser to retrieve.
        public let browserId: String

        @inlinable
        public init(browserId: String) {
            self.browserId = browserId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserId, key: "browserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserId, name: "browserId", parent: name, pattern: "^(aws\\.browser\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBrowserResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the browser.
        public let browserArn: String
        /// The unique identifier of the browser.
        public let browserId: String
        /// The timestamp when the browser was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the browser.
        public let description: String?
        /// The IAM role ARN that provides permissions for the browser.
        public let executionRoleArn: String?
        /// The timestamp when the browser was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The name of the browser.
        public let name: String
        public let networkConfiguration: BrowserNetworkConfiguration
        public let recording: RecordingConfig?
        /// The current status of the browser.
        public let status: BrowserStatus

        @inlinable
        public init(browserArn: String, browserId: String, createdAt: Date, description: String? = nil, executionRoleArn: String? = nil, lastUpdatedAt: Date, name: String, networkConfiguration: BrowserNetworkConfiguration, recording: RecordingConfig? = nil, status: BrowserStatus) {
            self.browserArn = browserArn
            self.browserId = browserId
            self.createdAt = createdAt
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.recording = recording
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserArn = "browserArn"
            case browserId = "browserId"
            case createdAt = "createdAt"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
            case recording = "recording"
            case status = "status"
        }
    }

    public struct GetCodeInterpreterRequest: AWSEncodableShape {
        /// The unique identifier of the code interpreter to retrieve.
        public let codeInterpreterId: String

        @inlinable
        public init(codeInterpreterId: String) {
            self.codeInterpreterId = codeInterpreterId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.codeInterpreterId, key: "codeInterpreterId")
        }

        public func validate(name: String) throws {
            try self.validate(self.codeInterpreterId, name: "codeInterpreterId", parent: name, pattern: "^(aws\\.codeinterpreter\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodeInterpreterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the code interpreter.
        public let codeInterpreterArn: String
        /// The unique identifier of the code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the code interpreter.
        public let description: String?
        /// The IAM role ARN that provides permissions for the code interpreter.
        public let executionRoleArn: String?
        /// The timestamp when the code interpreter was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The name of the code interpreter.
        public let name: String
        public let networkConfiguration: CodeInterpreterNetworkConfiguration
        /// The current status of the code interpreter.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterArn: String, codeInterpreterId: String, createdAt: Date, description: String? = nil, executionRoleArn: String? = nil, lastUpdatedAt: Date, name: String, networkConfiguration: CodeInterpreterNetworkConfiguration, status: CodeInterpreterStatus) {
            self.codeInterpreterArn = codeInterpreterArn
            self.codeInterpreterId = codeInterpreterId
            self.createdAt = createdAt
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterArn = "codeInterpreterArn"
            case codeInterpreterId = "codeInterpreterId"
            case createdAt = "createdAt"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
            case status = "status"
        }
    }

    public struct GetGatewayRequest: AWSEncodableShape {
        /// The identifier of the gateway to retrieve. This can be either the gateway ID or the gateway ARN.
        public let gatewayIdentifier: String

        @inlinable
        public init(gatewayIdentifier: String) {
            self.gatewayIdentifier = gatewayIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGatewayResponse: AWSDecodableShape {
        /// The authorizer configuration for the Gateway.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// Authorizer type for the gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the Gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the Gateway.
        public let description: String?
        /// The verbosity of exception messages. Use DEBUG mode to see granular exception messages from a Gateway. If this parameter is not set, exception messages are by default sanitized for presentation to end users.
        public let exceptionLevel: ExceptionLevel?
        /// The Amazon Resource Name (ARN) of the Gateway.
        public let gatewayArn: String
        /// The unique identifier of the Gateway.
        public let gatewayId: String
        /// An endpoint for invoking Gateway.
        public let gatewayUrl: String?
        /// The ARN of the KMS key used to encrypt the Gateway.
        public let kmsKeyArn: String?
        /// The name of the Gateway.
        public let name: String
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// Protocol applied to a Gateway.
        public let protocolType: GatewayProtocolType
        /// The IAM role ARN that provides permissions for the Gateway.
        public let roleArn: String?
        /// The current status of the Gateway.
        public let status: GatewayStatus
        /// The reasons for the current status of the Gateway.
        public let statusReasons: [String]?
        /// The timestamp when the Gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The workload identity details for the Gateway.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayArn: String, gatewayId: String, gatewayUrl: String? = nil, kmsKeyArn: String? = nil, name: String, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String? = nil, status: GatewayStatus, statusReasons: [String]? = nil, updatedAt: Date, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
            self.gatewayUrl = gatewayUrl
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
            case gatewayUrl = "gatewayUrl"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct GetGatewayTargetRequest: AWSEncodableShape {
        /// The identifier of the gateway that contains the target. This can be either the gateway ID or the gateway ARN.
        public let gatewayIdentifier: String
        /// The unique identifier of the target to retrieve.
        public let targetId: String

        @inlinable
        public init(gatewayIdentifier: String, targetId: String) {
            self.gatewayIdentifier = gatewayIdentifier
            self.targetId = targetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            request.encodePath(self.targetId, key: "targetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.targetId, name: "targetId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGatewayTargetResponse: AWSDecodableShape {
        /// The timestamp when the Gateway Target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The credential provider configurations for the Gateway Target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The description of the Gateway Target.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the Gateway.
        public let gatewayArn: String
        /// The name of the Gateway Target.
        public let name: String
        /// The current status of the Gateway Target.
        public let status: TargetStatus
        /// The reasons for the current status of the Gateway Target.
        public let statusReasons: [String]?
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the Gateway Target.
        public let targetId: String
        /// The timestamp when the Gateway Target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayArn: String, name: String, status: TargetStatus, statusReasons: [String]? = nil, targetConfiguration: TargetConfiguration, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayArn = gatewayArn
            self.name = name
            self.status = status
            self.statusReasons = statusReasons
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case gatewayArn = "gatewayArn"
            case name = "name"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetConfiguration = "targetConfiguration"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetMemoryInput: AWSEncodableShape {
        /// The unique identifier of the memory to retrieve.
        public let memoryId: String

        @inlinable
        public init(memoryId: String) {
            self.memoryId = memoryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.memoryId, key: "memoryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMemoryOutput: AWSDecodableShape {
        /// The retrieved memory details.
        public let memory: Memory

        @inlinable
        public init(memory: Memory) {
            self.memory = memory
        }

        private enum CodingKeys: String, CodingKey {
            case memory = "memory"
        }
    }

    public struct GetOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The name of the OAuth2 credential provider to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetOauth2CredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
        public let clientSecretArn: Secret
        /// The timestamp when the OAuth2 credential provider was created.
        public let createdTime: Date
        /// ARN of the credential provider requested.
        public let credentialProviderArn: String
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The timestamp when the OAuth2 credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the OAuth2 credential provider.
        public let name: String
        /// The configuration output for the OAuth2 provider.
        public let oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput

        @inlinable
        public init(clientSecretArn: Secret, createdTime: Date, credentialProviderArn: String, credentialProviderVendor: CredentialProviderVendorType, lastUpdatedTime: Date, name: String, oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput) {
            self.clientSecretArn = clientSecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.credentialProviderVendor = credentialProviderVendor
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.oauth2ProviderConfigOutput = oauth2ProviderConfigOutput
        }

        private enum CodingKeys: String, CodingKey {
            case clientSecretArn = "clientSecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case credentialProviderVendor = "credentialProviderVendor"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case oauth2ProviderConfigOutput = "oauth2ProviderConfigOutput"
        }
    }

    public struct GetTokenVaultRequest: AWSEncodableShape {
        /// The unique identifier of the token vault to retrieve.
        public let tokenVaultId: String?

        @inlinable
        public init(tokenVaultId: String? = nil) {
            self.tokenVaultId = tokenVaultId
        }

        public func validate(name: String) throws {
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, max: 64)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, min: 1)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct GetTokenVaultResponse: AWSDecodableShape {
        /// The KMS configuration for the token vault.
        public let kmsConfiguration: KmsConfiguration
        /// The timestamp when the token vault was last modified.
        public let lastModifiedDate: Date
        /// The ID of the token vault.
        public let tokenVaultId: String

        @inlinable
        public init(kmsConfiguration: KmsConfiguration, lastModifiedDate: Date, tokenVaultId: String) {
            self.kmsConfiguration = kmsConfiguration
            self.lastModifiedDate = lastModifiedDate
            self.tokenVaultId = tokenVaultId
        }

        private enum CodingKeys: String, CodingKey {
            case kmsConfiguration = "kmsConfiguration"
            case lastModifiedDate = "lastModifiedDate"
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct GetWorkloadIdentityRequest: AWSEncodableShape {
        /// The name of the workload identity to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetWorkloadIdentityResponse: AWSDecodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The timestamp when the workload identity was created.
        public let createdTime: Date
        /// The timestamp when the workload identity was last updated.
        public let lastUpdatedTime: Date
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, createdTime: Date, lastUpdatedTime: Date, name: String, workloadIdentityArn: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case createdTime = "createdTime"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct GithubOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the GitHub OAuth2 provider.
        public let clientId: String
        /// The client secret for the GitHub OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct GithubOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The OAuth2 discovery information for the GitHub provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(oauthDiscovery: Oauth2Discovery) {
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct GoogleOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Google OAuth2 provider.
        public let clientId: String
        /// The client secret for the Google OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct GoogleOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The OAuth2 discovery information for the Google provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(oauthDiscovery: Oauth2Discovery) {
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct KmsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of KMS key (CustomerManagedKey or ServiceManagedKey).
        public let keyType: KeyType
        /// The Amazon Resource Name (ARN) of the KMS key.
        public let kmsKeyArn: String?

        @inlinable
        public init(keyType: KeyType, kmsKeyArn: String? = nil) {
            self.keyType = keyType
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case keyType = "keyType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct ListAgentRuntimeEndpointsRequest: AWSEncodableShape {
        /// The unique identifier of the agent runtime to list endpoints for.
        public let agentRuntimeId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimeId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentRuntimeId = agentRuntimeId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAgentRuntimeEndpointsResponse: AWSDecodableShape {
        /// A token to retrieve the next page of results.
        public let nextToken: String?
        /// The list of agent runtime endpoints.
        public let runtimeEndpoints: [AgentEndpoint]

        @inlinable
        public init(nextToken: String? = nil, runtimeEndpoints: [AgentEndpoint]) {
            self.nextToken = nextToken
            self.runtimeEndpoints = runtimeEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case runtimeEndpoints = "runtimeEndpoints"
        }
    }

    public struct ListAgentRuntimeVersionsRequest: AWSEncodableShape {
        /// The unique identifier of the agent runtime to list versions for.
        public let agentRuntimeId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimeId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentRuntimeId = agentRuntimeId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAgentRuntimeVersionsResponse: AWSDecodableShape {
        /// The list of agent runtime versions.
        public let agentRuntimes: [Agent]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimes: [Agent], nextToken: String? = nil) {
            self.agentRuntimes = agentRuntimes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimes = "agentRuntimes"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentRuntimesRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAgentRuntimesResponse: AWSDecodableShape {
        /// The list of agent runtimes.
        public let agentRuntimes: [Agent]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimes: [Agent], nextToken: String? = nil) {
            self.agentRuntimes = agentRuntimes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimes = "agentRuntimes"
            case nextToken = "nextToken"
        }
    }

    public struct ListApiKeyCredentialProvidersRequest: AWSEncodableShape {
        /// Maximum number of results to return.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListApiKeyCredentialProvidersResponse: AWSDecodableShape {
        /// The list of API key credential providers.
        public let credentialProviders: [ApiKeyCredentialProviderItem]
        /// Pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(credentialProviders: [ApiKeyCredentialProviderItem], nextToken: String? = nil) {
            self.credentialProviders = credentialProviders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviders = "credentialProviders"
            case nextToken = "nextToken"
        }
    }

    public struct ListBrowsersRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The type of browsers to list. If not specified, all browser types are returned.
        public let type: ResourceType?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, type: ResourceType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBrowsersResponse: AWSDecodableShape {
        /// The list of browser summaries.
        public let browserSummaries: [BrowserSummary]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(browserSummaries: [BrowserSummary], nextToken: String? = nil) {
            self.browserSummaries = browserSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case browserSummaries = "browserSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCodeInterpretersRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?
        /// The type of code interpreters to list.
        public let type: ResourceType?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, type: ResourceType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCodeInterpretersResponse: AWSDecodableShape {
        /// The list of code interpreter summaries.
        public let codeInterpreterSummaries: [CodeInterpreterSummary]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(codeInterpreterSummaries: [CodeInterpreterSummary], nextToken: String? = nil) {
            self.codeInterpreterSummaries = codeInterpreterSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterSummaries = "codeInterpreterSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListGatewayTargetsRequest: AWSEncodableShape {
        /// The identifier of the gateway to list targets for. This can be either the gateway ID or the gateway ARN.
        public let gatewayIdentifier: String
        /// The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(gatewayIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.gatewayIdentifier = gatewayIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewayTargetsResponse: AWSDecodableShape {
        /// The list of Gateway Target summaries.
        public let items: [TargetSummary]
        /// Opaque continuation token for the next paginated response.
        public let nextToken: String?

        @inlinable
        public init(items: [TargetSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListGatewaysRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewaysResponse: AWSDecodableShape {
        /// The list of Gateway summaries.
        public let items: [GatewaySummary]
        /// Opaque continuation token for the next paginated response.
        public let nextToken: String?

        @inlinable
        public init(items: [GatewaySummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoriesInput: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoriesOutput: AWSDecodableShape {
        /// The list of memory summaries.
        public let memories: [MemorySummary]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(memories: [MemorySummary], nextToken: String? = nil) {
            self.memories = memories
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memories = "memories"
            case nextToken = "nextToken"
        }
    }

    public struct ListOauth2CredentialProvidersRequest: AWSEncodableShape {
        /// Maximum number of results to return.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListOauth2CredentialProvidersResponse: AWSDecodableShape {
        /// The list of OAuth2 credential providers.
        public let credentialProviders: [Oauth2CredentialProviderItem]
        /// Pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(credentialProviders: [Oauth2CredentialProviderItem], nextToken: String? = nil) {
            self.credentialProviders = credentialProviders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviders = "credentialProviders"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorkloadIdentitiesRequest: AWSEncodableShape {
        /// Maximum number of results to return.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorkloadIdentitiesResponse: AWSDecodableShape {
        /// Pagination token for the next page of results.
        public let nextToken: String?
        /// The list of workload identities.
        public let workloadIdentities: [WorkloadIdentityType]

        @inlinable
        public init(nextToken: String? = nil, workloadIdentities: [WorkloadIdentityType]) {
            self.nextToken = nextToken
            self.workloadIdentities = workloadIdentities
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workloadIdentities = "workloadIdentities"
        }
    }

    public struct MCPGatewayConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The instructions for using the Model Context Protocol gateway. These instructions provide guidance on how to interact with the gateway.
        public let instructions: String?
        /// The search type for the Model Context Protocol gateway. This field specifies how the gateway handles search operations.
        public let searchType: SearchType?
        /// The supported versions of the Model Context Protocol. This field specifies which versions of the protocol the gateway can use.
        public let supportedVersions: [String]?

        @inlinable
        public init(instructions: String? = nil, searchType: SearchType? = nil, supportedVersions: [String]? = nil) {
            self.instructions = instructions
            self.searchType = searchType
            self.supportedVersions = supportedVersions
        }

        public func validate(name: String) throws {
            try self.validate(self.instructions, name: "instructions", parent: name, max: 2048)
            try self.validate(self.instructions, name: "instructions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instructions = "instructions"
            case searchType = "searchType"
            case supportedVersions = "supportedVersions"
        }
    }

    public struct McpLambdaTargetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function. This function is invoked by the gateway to communicate with the target.
        public let lambdaArn: String
        /// The tool schema for the Lambda function. This schema defines the structure of the tools that the Lambda function provides.
        public let toolSchema: ToolSchema

        @inlinable
        public init(lambdaArn: String, toolSchema: ToolSchema) {
            self.lambdaArn = lambdaArn
            self.toolSchema = toolSchema
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 170)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, min: 1)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:([a-z]{2}(-gov)?-[a-z]+-\\d{1}):(\\d{12}):function:([a-zA-Z0-9-_.]+)(:(\\$LATEST|[a-zA-Z0-9-]+))?$")
            try self.toolSchema.validate(name: "\(name).toolSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaArn = "lambdaArn"
            case toolSchema = "toolSchema"
        }
    }

    public struct Memory: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the memory.
        public let arn: String
        /// The timestamp when the memory was created.
        public let createdAt: Date
        /// The description of the memory.
        public let description: String?
        /// The ARN of the KMS key used to encrypt the memory.
        public let encryptionKeyArn: String?
        /// The number of days after which memory events will expire.
        public let eventExpiryDuration: Int
        /// The reason for failure if the memory is in a failed state.
        public let failureReason: String?
        /// The unique identifier of the memory.
        public let id: String
        /// The ARN of the IAM role that provides permissions for the memory.
        public let memoryExecutionRoleArn: String?
        /// The name of the memory.
        public let name: String
        /// The current status of the memory.
        public let status: MemoryStatus
        /// The list of memory strategies associated with this memory.
        public let strategies: [MemoryStrategy]?
        /// The timestamp when the memory was last updated.
        public let updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, encryptionKeyArn: String? = nil, eventExpiryDuration: Int, failureReason: String? = nil, id: String, memoryExecutionRoleArn: String? = nil, name: String, status: MemoryStatus, strategies: [MemoryStrategy]? = nil, updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.encryptionKeyArn = encryptionKeyArn
            self.eventExpiryDuration = eventExpiryDuration
            self.failureReason = failureReason
            self.id = id
            self.memoryExecutionRoleArn = memoryExecutionRoleArn
            self.name = name
            self.status = status
            self.strategies = strategies
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case encryptionKeyArn = "encryptionKeyArn"
            case eventExpiryDuration = "eventExpiryDuration"
            case failureReason = "failureReason"
            case id = "id"
            case memoryExecutionRoleArn = "memoryExecutionRoleArn"
            case name = "name"
            case status = "status"
            case strategies = "strategies"
            case updatedAt = "updatedAt"
        }
    }

    public struct MemoryStrategy: AWSDecodableShape {
        /// The configuration of the memory strategy.
        public let configuration: StrategyConfiguration?
        /// The timestamp when the memory strategy was created.
        public let createdAt: Date?
        /// The description of the memory strategy.
        public let description: String?
        /// The name of the memory strategy.
        public let name: String
        /// The namespaces associated with the memory strategy.
        public let namespaces: [String]
        /// The current status of the memory strategy.
        public let status: MemoryStrategyStatus?
        /// The unique identifier of the memory strategy.
        public let strategyId: String
        /// The type of the memory strategy.
        public let type: MemoryStrategyType
        /// The timestamp when the memory strategy was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(configuration: StrategyConfiguration? = nil, createdAt: Date? = nil, description: String? = nil, name: String, namespaces: [String], status: MemoryStrategyStatus? = nil, strategyId: String, type: MemoryStrategyType, updatedAt: Date? = nil) {
            self.configuration = configuration
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.namespaces = namespaces
            self.status = status
            self.strategyId = strategyId
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case createdAt = "createdAt"
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
            case status = "status"
            case strategyId = "strategyId"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct MemorySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the memory.
        public let arn: String?
        /// The timestamp when the memory was created.
        public let createdAt: Date
        /// The unique identifier of the memory.
        public let id: String?
        /// The current status of the memory.
        public let status: MemoryStatus?
        /// The timestamp when the memory was last updated.
        public let updatedAt: Date

        @inlinable
        public init(arn: String? = nil, createdAt: Date, id: String? = nil, status: MemoryStatus? = nil, updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct MicrosoftOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Microsoft OAuth2 provider.
        public let clientId: String
        /// The client secret for the Microsoft OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct MicrosoftOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The OAuth2 discovery information for the Microsoft provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(oauthDiscovery: Oauth2Discovery) {
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct ModifyMemoryStrategies: AWSEncodableShape {
        /// The list of memory strategies to add.
        public let addMemoryStrategies: [MemoryStrategyInput]?
        /// The list of memory strategies to delete.
        public let deleteMemoryStrategies: [DeleteMemoryStrategyInput]?
        /// The list of memory strategies to modify.
        public let modifyMemoryStrategies: [ModifyMemoryStrategyInput]?

        @inlinable
        public init(addMemoryStrategies: [MemoryStrategyInput]? = nil, deleteMemoryStrategies: [DeleteMemoryStrategyInput]? = nil, modifyMemoryStrategies: [ModifyMemoryStrategyInput]? = nil) {
            self.addMemoryStrategies = addMemoryStrategies
            self.deleteMemoryStrategies = deleteMemoryStrategies
            self.modifyMemoryStrategies = modifyMemoryStrategies
        }

        public func validate(name: String) throws {
            try self.addMemoryStrategies?.forEach {
                try $0.validate(name: "\(name).addMemoryStrategies[]")
            }
            try self.modifyMemoryStrategies?.forEach {
                try $0.validate(name: "\(name).modifyMemoryStrategies[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case addMemoryStrategies = "addMemoryStrategies"
            case deleteMemoryStrategies = "deleteMemoryStrategies"
            case modifyMemoryStrategies = "modifyMemoryStrategies"
        }
    }

    public struct ModifyMemoryStrategyInput: AWSEncodableShape {
        /// The updated configuration for the memory strategy.
        public let configuration: ModifyStrategyConfiguration?
        /// The updated description of the memory strategy.
        public let description: String?
        /// The unique identifier of the memory strategy to modify.
        public let memoryStrategyId: String
        /// The updated namespaces for the memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(configuration: ModifyStrategyConfiguration? = nil, description: String? = nil, memoryStrategyId: String, namespaces: [String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case memoryStrategyId = "memoryStrategyId"
            case namespaces = "namespaces"
        }
    }

    public struct ModifyStrategyConfiguration: AWSEncodableShape {
        /// The updated consolidation configuration.
        public let consolidation: ModifyConsolidationConfiguration?
        /// The updated extraction configuration.
        public let extraction: ModifyExtractionConfiguration?

        @inlinable
        public init(consolidation: ModifyConsolidationConfiguration? = nil, extraction: ModifyExtractionConfiguration? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
            try self.extraction?.validate(name: "\(name).extraction")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
        }
    }

    public struct NetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The network mode for the agent runtime.
        public let networkMode: NetworkMode

        @inlinable
        public init(networkMode: NetworkMode) {
            self.networkMode = networkMode
        }

        private enum CodingKeys: String, CodingKey {
            case networkMode = "networkMode"
        }
    }

    public struct OAuthCredentialProvider: AWSEncodableShape & AWSDecodableShape {
        /// The custom parameters for the OAuth credential provider. These parameters provide additional configuration for the OAuth authentication process.
        public let customParameters: [String: String]?
        /// The Amazon Resource Name (ARN) of the OAuth credential provider. This ARN identifies the provider in Amazon Web Services.
        public let providerArn: String
        /// The OAuth scopes for the credential provider. These scopes define the level of access requested from the OAuth provider.
        public let scopes: [String]

        @inlinable
        public init(customParameters: [String: String]? = nil, providerArn: String, scopes: [String]) {
            self.customParameters = customParameters
            self.providerArn = providerArn
            self.scopes = scopes
        }

        public func validate(name: String) throws {
            try self.customParameters?.forEach {
                try validate($0.key, name: "customParameters.key", parent: name, max: 256)
                try validate($0.key, name: "customParameters.key", parent: name, min: 1)
                try validate($0.value, name: "customParameters[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "customParameters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.customParameters, name: "customParameters", parent: name, max: 10)
            try self.validate(self.customParameters, name: "customParameters", parent: name, min: 1)
            try self.validate(self.providerArn, name: "providerArn", parent: name, pattern: "^arn:([^:]*):([^:]*):([^:]*):([0-9]{12})?:(.+)$")
            try self.scopes.forEach {
                try validate($0, name: "scopes[]", parent: name, max: 64)
                try validate($0, name: "scopes[]", parent: name, min: 1)
            }
            try self.validate(self.scopes, name: "scopes", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case customParameters = "customParameters"
            case providerArn = "providerArn"
            case scopes = "scopes"
        }
    }

    public struct Oauth2AuthorizationServerMetadata: AWSEncodableShape & AWSDecodableShape {
        /// The authorization endpoint URL for the OAuth2 authorization server.
        public let authorizationEndpoint: String
        /// The issuer URL for the OAuth2 authorization server.
        public let issuer: String
        /// The supported response types for the OAuth2 authorization server.
        public let responseTypes: [String]?
        /// The token endpoint URL for the OAuth2 authorization server.
        public let tokenEndpoint: String

        @inlinable
        public init(authorizationEndpoint: String, issuer: String, responseTypes: [String]? = nil, tokenEndpoint: String) {
            self.authorizationEndpoint = authorizationEndpoint
            self.issuer = issuer
            self.responseTypes = responseTypes
            self.tokenEndpoint = tokenEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationEndpoint = "authorizationEndpoint"
            case issuer = "issuer"
            case responseTypes = "responseTypes"
            case tokenEndpoint = "tokenEndpoint"
        }
    }

    public struct Oauth2CredentialProviderItem: AWSDecodableShape {
        /// The timestamp when the OAuth2 credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
        public let credentialProviderArn: String
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The timestamp when the OAuth2 credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the OAuth2 credential provider.
        public let name: String

        @inlinable
        public init(createdTime: Date, credentialProviderArn: String, credentialProviderVendor: CredentialProviderVendorType, lastUpdatedTime: Date, name: String) {
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.credentialProviderVendor = credentialProviderVendor
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case credentialProviderVendor = "credentialProviderVendor"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct ProtocolConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The server protocol for the agent runtime. This field specifies which protocol the agent runtime uses to communicate with clients.
        public let serverProtocol: ServerProtocol

        @inlinable
        public init(serverProtocol: ServerProtocol) {
            self.serverProtocol = serverProtocol
        }

        private enum CodingKeys: String, CodingKey {
            case serverProtocol = "serverProtocol"
        }
    }

    public struct RecordingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether recording is enabled for the browser. When set to true, browser sessions are recorded.
        public let enabled: Bool?
        /// The Amazon S3 location where browser recordings are stored. This location contains the recorded browser sessions.
        public let s3Location: S3Location?

        @inlinable
        public init(enabled: Bool? = nil, s3Location: S3Location? = nil) {
            self.enabled = enabled
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case s3Location = "s3Location"
        }
    }

    public struct S3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The account ID of the Amazon S3 bucket owner. This ID is used for cross-account access to the bucket.
        public let bucketOwnerAccountId: String?
        /// The URI of the Amazon S3 object. This URI specifies the location of the object in Amazon S3.
        public let uri: String?

        @inlinable
        public init(bucketOwnerAccountId: String? = nil, uri: String? = nil) {
            self.bucketOwnerAccountId = bucketOwnerAccountId
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://.{1,2043}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketOwnerAccountId = "bucketOwnerAccountId"
            case uri = "uri"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket. This bucket contains the stored data.
        public let bucket: String
        /// The prefix for objects in the Amazon S3 bucket. This prefix is added to the object keys to organize the data.
        public let prefix: String

        @inlinable
        public init(bucket: String, prefix: String) {
            self.bucket = bucket
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case prefix = "prefix"
        }
    }

    public struct SalesforceOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Salesforce OAuth2 provider.
        public let clientId: String
        /// The client secret for the Salesforce OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct SalesforceOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The OAuth2 discovery information for the Salesforce provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(oauthDiscovery: Oauth2Discovery) {
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public final class SchemaDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The description of the schema definition. This description provides information about the purpose and usage of the schema.
        public let description: String?
        /// The items in the schema definition. This field is used for array types to define the structure of the array elements.
        public let items: SchemaDefinition?
        /// The properties of the schema definition. These properties define the fields in the schema.
        public let properties: [String: SchemaDefinition]?
        /// The required fields in the schema definition. These fields must be provided when using the schema.
        public let required: [String]?
        /// The type of the schema definition. This field specifies the data type of the schema.
        public let type: SchemaType

        @inlinable
        public init(description: String? = nil, items: SchemaDefinition? = nil, properties: [String: SchemaDefinition]? = nil, required: [String]? = nil, type: SchemaType) {
            self.description = description
            self.items = items
            self.properties = properties
            self.required = required
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case items = "items"
            case properties = "properties"
            case required = "required"
            case type = "type"
        }
    }

    public struct Secret: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the secret in AWS Secrets Manager.
        public let secretArn: String

        @inlinable
        public init(secretArn: String) {
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case secretArn = "secretArn"
        }
    }

    public struct SemanticConsolidationOverride: AWSDecodableShape {
        /// The text to append to the prompt for semantic consolidation.
        public let appendToPrompt: String
        /// The model ID to use for semantic consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SemanticExtractionOverride: AWSDecodableShape {
        /// The text to append to the prompt for semantic extraction.
        public let appendToPrompt: String
        /// The model ID to use for semantic extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SemanticMemoryStrategyInput: AWSEncodableShape {
        /// The description of the semantic memory strategy.
        public let description: String?
        /// The name of the semantic memory strategy.
        public let name: String
        /// The namespaces associated with the semantic memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct SemanticOverrideConfigurationInput: AWSEncodableShape {
        /// The consolidation configuration for a semantic override.
        public let consolidation: SemanticOverrideConsolidationConfigurationInput?
        /// The extraction configuration for a semantic override.
        public let extraction: SemanticOverrideExtractionConfigurationInput?

        @inlinable
        public init(consolidation: SemanticOverrideConsolidationConfigurationInput? = nil, extraction: SemanticOverrideExtractionConfigurationInput? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
            try self.extraction?.validate(name: "\(name).extraction")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
        }
    }

    public struct SemanticOverrideConsolidationConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for semantic consolidation.
        public let appendToPrompt: String
        /// The model ID to use for semantic consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SemanticOverrideExtractionConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for semantic extraction.
        public let appendToPrompt: String
        /// The model ID to use for semantic extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SetTokenVaultCMKRequest: AWSEncodableShape {
        /// The KMS configuration for the token vault, including the key type and KMS key ARN.
        public let kmsConfiguration: KmsConfiguration
        /// The unique identifier of the token vault to update.
        public let tokenVaultId: String?

        @inlinable
        public init(kmsConfiguration: KmsConfiguration, tokenVaultId: String? = nil) {
            self.kmsConfiguration = kmsConfiguration
            self.tokenVaultId = tokenVaultId
        }

        public func validate(name: String) throws {
            try self.kmsConfiguration.validate(name: "\(name).kmsConfiguration")
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, max: 64)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, min: 1)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsConfiguration = "kmsConfiguration"
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct SetTokenVaultCMKResponse: AWSDecodableShape {
        /// The KMS configuration for the token vault.
        public let kmsConfiguration: KmsConfiguration
        /// The timestamp when the token vault was last modified.
        public let lastModifiedDate: Date
        /// The ID of the token vault.
        public let tokenVaultId: String

        @inlinable
        public init(kmsConfiguration: KmsConfiguration, lastModifiedDate: Date, tokenVaultId: String) {
            self.kmsConfiguration = kmsConfiguration
            self.lastModifiedDate = lastModifiedDate
            self.tokenVaultId = tokenVaultId
        }

        private enum CodingKeys: String, CodingKey {
            case kmsConfiguration = "kmsConfiguration"
            case lastModifiedDate = "lastModifiedDate"
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct SlackOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Slack OAuth2 provider.
        public let clientId: String
        /// The client secret for the Slack OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct SlackOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The OAuth2 discovery information for the Slack provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(oauthDiscovery: Oauth2Discovery) {
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct StrategyConfiguration: AWSDecodableShape {
        /// The consolidation configuration for the memory strategy.
        public let consolidation: ConsolidationConfiguration?
        /// The extraction configuration for the memory strategy.
        public let extraction: ExtractionConfiguration?
        /// The type of override for the strategy configuration.
        public let type: OverrideType?

        @inlinable
        public init(consolidation: ConsolidationConfiguration? = nil, extraction: ExtractionConfiguration? = nil, type: OverrideType? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
            case type = "type"
        }
    }

    public struct SummaryConsolidationOverride: AWSDecodableShape {
        /// The text to append to the prompt for summary consolidation.
        public let appendToPrompt: String
        /// The model ID to use for summary consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SummaryMemoryStrategyInput: AWSEncodableShape {
        /// The description of the summary memory strategy.
        public let description: String?
        /// The name of the summary memory strategy.
        public let name: String
        /// The namespaces associated with the summary memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct SummaryOverrideConfigurationInput: AWSEncodableShape {
        /// The consolidation configuration for a summary override.
        public let consolidation: SummaryOverrideConsolidationConfigurationInput?

        @inlinable
        public init(consolidation: SummaryOverrideConsolidationConfigurationInput? = nil) {
            self.consolidation = consolidation
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
        }
    }

    public struct SummaryOverrideConsolidationConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for summary consolidation.
        public let appendToPrompt: String
        /// The model ID to use for summary consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct TargetSummary: AWSDecodableShape {
        /// The timestamp when the target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the target.
        public let description: String?
        /// The name of the target.
        public let name: String
        /// The current status of the target.
        public let status: TargetStatus
        /// The unique identifier of the target.
        public let targetId: String
        /// The timestamp when the target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, name: String, status: TargetStatus, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.status = status
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case name = "name"
            case status = "status"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct ToolDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The description of the tool. This description provides information about the purpose and usage of the tool.
        public let description: String
        /// The input schema for the tool. This schema defines the structure of the input that the tool accepts.
        public let inputSchema: SchemaDefinition
        /// The name of the tool. This name identifies the tool in the Model Context Protocol.
        public let name: String
        /// The output schema for the tool. This schema defines the structure of the output that the tool produces.
        public let outputSchema: SchemaDefinition?

        @inlinable
        public init(description: String, inputSchema: SchemaDefinition, name: String, outputSchema: SchemaDefinition? = nil) {
            self.description = description
            self.inputSchema = inputSchema
            self.name = name
            self.outputSchema = outputSchema
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case inputSchema = "inputSchema"
            case name = "name"
            case outputSchema = "outputSchema"
        }
    }

    public struct UpdateAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the agent runtime associated with the endpoint.
        public let agentRuntimeId: String
        /// The updated version of the agent runtime for the endpoint.
        public let agentRuntimeVersion: String?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The updated description of the agent runtime endpoint.
        public let description: String?
        /// The name of the agent runtime endpoint to update.
        public let endpointName: String

        @inlinable
        public init(agentRuntimeId: String, agentRuntimeVersion: String? = nil, clientToken: String? = UpdateAgentRuntimeEndpointRequest.idempotencyToken(), description: String? = nil, endpointName: String) {
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.clientToken = clientToken
            self.description = description
            self.endpointName = endpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            try container.encodeIfPresent(self.agentRuntimeVersion, forKey: .agentRuntimeVersion)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.endpointName, key: "endpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, max: 5)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, min: 1)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, pattern: "^([1-9][0-9]{0,4})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeVersion = "agentRuntimeVersion"
            case clientToken = "clientToken"
            case description = "description"
        }
    }

    public struct UpdateAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent runtime.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the agent runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The timestamp when the agent runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the agent runtime endpoint was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The currently deployed version of the agent runtime on the endpoint.
        public let liveVersion: String?
        /// The current status of the updated agent runtime endpoint.
        public let status: AgentEndpointStatus
        /// The target version of the agent runtime for the endpoint.
        public let targetVersion: String?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, createdAt: Date, lastUpdatedAt: Date, liveVersion: String? = nil, status: AgentEndpointStatus, targetVersion: String? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.liveVersion = liveVersion
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case liveVersion = "liveVersion"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct UpdateAgentRuntimeRequest: AWSEncodableShape {
        /// The updated artifact of the agent runtime.
        public let agentRuntimeArtifact: AgentArtifact
        /// The unique identifier of the agent runtime to update.
        public let agentRuntimeId: String
        /// The updated authorizer configuration for the agent runtime.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The updated description of the agent runtime.
        public let description: String?
        /// Updated environment variables to set in the agent runtime environment.
        public let environmentVariables: [String: String]?
        /// The updated network configuration for the agent runtime.
        public let networkConfiguration: NetworkConfiguration
        public let protocolConfiguration: ProtocolConfiguration?
        /// The updated IAM role ARN that provides permissions for the agent runtime.
        public let roleArn: String

        @inlinable
        public init(agentRuntimeArtifact: AgentArtifact, agentRuntimeId: String, authorizerConfiguration: AuthorizerConfiguration? = nil, clientToken: String? = UpdateAgentRuntimeRequest.idempotencyToken(), description: String? = nil, environmentVariables: [String: String]? = nil, networkConfiguration: NetworkConfiguration, protocolConfiguration: ProtocolConfiguration? = nil, roleArn: String) {
            self.agentRuntimeArtifact = agentRuntimeArtifact
            self.agentRuntimeId = agentRuntimeId
            self.authorizerConfiguration = authorizerConfiguration
            self.clientToken = clientToken
            self.description = description
            self.environmentVariables = environmentVariables
            self.networkConfiguration = networkConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.agentRuntimeArtifact, forKey: .agentRuntimeArtifact)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            try container.encodeIfPresent(self.authorizerConfiguration, forKey: .authorizerConfiguration)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.environmentVariables, forKey: .environmentVariables)
            try container.encode(self.networkConfiguration, forKey: .networkConfiguration)
            try container.encodeIfPresent(self.protocolConfiguration, forKey: .protocolConfiguration)
            try container.encode(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.agentRuntimeArtifact.validate(name: "\(name).agentRuntimeArtifact")
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.authorizerConfiguration?.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 100)
                try validate($0.key, name: "environmentVariables.key", parent: name, min: 1)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 5000)
            }
            try self.validate(self.environmentVariables, name: "environmentVariables", parent: name, max: 50)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArtifact = "agentRuntimeArtifact"
            case authorizerConfiguration = "authorizerConfiguration"
            case clientToken = "clientToken"
            case description = "description"
            case environmentVariables = "environmentVariables"
            case networkConfiguration = "networkConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateAgentRuntimeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated agent runtime.
        public let agentRuntimeArn: String
        /// The unique identifier of the updated agent runtime.
        public let agentRuntimeId: String
        /// The version of the updated agent runtime.
        public let agentRuntimeVersion: String
        /// The timestamp when the agent runtime was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the agent runtime was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the updated agent runtime.
        public let status: AgentStatus
        /// The workload identity details for the updated agent runtime.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeId: String, agentRuntimeVersion: String, createdAt: Date, lastUpdatedAt: Date, status: AgentStatus, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct UpdateApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The new API key to use for authentication. This value replaces the existing API key and is encrypted and stored securely.
        public let apiKey: String
        /// The name of the API key credential provider to update.
        public let name: String

        @inlinable
        public init(apiKey: String, name: String) {
            self.apiKey = apiKey
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 65536)
            try self.validate(self.apiKey, name: "apiKey", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case name = "name"
        }
    }

    public struct UpdateApiKeyCredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the API key secret in AWS Secrets Manager.
        public let apiKeySecretArn: Secret
        /// The timestamp when the API key credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the API key credential provider.
        public let credentialProviderArn: String
        /// The timestamp when the API key credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the API key credential provider.
        public let name: String

        @inlinable
        public init(apiKeySecretArn: Secret, createdTime: Date, credentialProviderArn: String, lastUpdatedTime: Date, name: String) {
            self.apiKeySecretArn = apiKeySecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySecretArn = "apiKeySecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct UpdateGatewayRequest: AWSEncodableShape {
        /// The updated authorizer configuration for the Gateway.
        public let authorizerConfiguration: AuthorizerConfiguration
        /// The updated authorizer type for the Gateway.
        public let authorizerType: AuthorizerType
        /// The updated description for the Gateway.
        public let description: String?
        /// The verbosity of exception messages. Use DEBUG mode to see granular exception messages from a Gateway. If this parameter is not set, exception messages are by default sanitized for presentation to end users.
        public let exceptionLevel: ExceptionLevel?
        /// The identifier of the gateway to update. This can be either the gateway ID or the gateway ARN.
        public let gatewayIdentifier: String
        /// The updated ARN of the KMS key used to encrypt the Gateway.
        public let kmsKeyArn: String?
        /// The updated name for the Gateway.
        public let name: String
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The updated protocol type for the Gateway.
        public let protocolType: GatewayProtocolType
        /// The updated IAM role ARN that provides permissions for the Gateway.
        public let roleArn: String

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration, authorizerType: AuthorizerType, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayIdentifier: String, kmsKeyArn: String? = nil, name: String, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayIdentifier = gatewayIdentifier
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.authorizerConfiguration, forKey: .authorizerConfiguration)
            try container.encode(self.authorizerType, forKey: .authorizerType)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.exceptionLevel, forKey: .exceptionLevel)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            try container.encodeIfPresent(self.kmsKeyArn, forKey: .kmsKeyArn)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.protocolConfiguration, forKey: .protocolConfiguration)
            try container.encode(self.protocolType, forKey: .protocolType)
            try container.encode(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.authorizerConfiguration.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.protocolConfiguration?.validate(name: "\(name).protocolConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateGatewayResponse: AWSDecodableShape {
        /// The updated authorizer configuration for the Gateway.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The updated authorizer type for the Gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the Gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The updated description of the Gateway.
        public let description: String?
        /// The verbosity of exception messages. Use DEBUG mode to see granular exception messages from a Gateway. If this parameter is not set, exception messages are by default sanitized for presentation to end users.
        public let exceptionLevel: ExceptionLevel?
        /// The Amazon Resource Name (ARN) of the updated Gateway.
        public let gatewayArn: String
        /// The unique identifier of the updated Gateway.
        public let gatewayId: String
        /// An endpoint for invoking the updated Gateway.
        public let gatewayUrl: String?
        /// The updated ARN of the KMS key used to encrypt the Gateway.
        public let kmsKeyArn: String?
        /// The updated name of the Gateway.
        public let name: String
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The updated protocol type for the Gateway.
        public let protocolType: GatewayProtocolType
        /// The updated IAM role ARN that provides permissions for the Gateway.
        public let roleArn: String?
        /// The current status of the updated Gateway.
        public let status: GatewayStatus
        /// The reasons for the current status of the updated Gateway.
        public let statusReasons: [String]?
        /// The timestamp when the Gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The workload identity details for the updated Gateway.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayArn: String, gatewayId: String, gatewayUrl: String? = nil, kmsKeyArn: String? = nil, name: String, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String? = nil, status: GatewayStatus, statusReasons: [String]? = nil, updatedAt: Date, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
            self.gatewayUrl = gatewayUrl
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
            case gatewayUrl = "gatewayUrl"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct UpdateGatewayTargetRequest: AWSEncodableShape {
        /// The updated credential provider configurations for the Gateway Target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The updated description for the Gateway Target.
        public let description: String?
        /// The unique identifier of the Gateway associated with the target.
        public let gatewayIdentifier: String
        /// The updated name for the Gateway Target.
        public let name: String
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the Gateway Target to update.
        public let targetId: String

        @inlinable
        public init(credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayIdentifier: String, name: String, targetConfiguration: TargetConfiguration, targetId: String) {
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayIdentifier = gatewayIdentifier
            self.name = name
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.credentialProviderConfigurations, forKey: .credentialProviderConfigurations)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.targetConfiguration, forKey: .targetConfiguration)
            request.encodePath(self.targetId, key: "targetId")
        }

        public func validate(name: String) throws {
            try self.credentialProviderConfigurations.forEach {
                try $0.validate(name: "\(name).credentialProviderConfigurations[]")
            }
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, max: 1)
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.targetConfiguration.validate(name: "\(name).targetConfiguration")
            try self.validate(self.targetId, name: "targetId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case name = "name"
            case targetConfiguration = "targetConfiguration"
        }
    }

    public struct UpdateGatewayTargetResponse: AWSDecodableShape {
        /// The timestamp when the Gateway Target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The updated credential provider configurations for the Gateway Target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The updated description of the Gateway Target.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the Gateway.
        public let gatewayArn: String
        /// The updated name of the Gateway Target.
        public let name: String
        /// The current status of the updated Gateway Target.
        public let status: TargetStatus
        /// The reasons for the current status of the updated Gateway Target.
        public let statusReasons: [String]?
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the updated Gateway Target.
        public let targetId: String
        /// The timestamp when the Gateway Target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayArn: String, name: String, status: TargetStatus, statusReasons: [String]? = nil, targetConfiguration: TargetConfiguration, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayArn = gatewayArn
            self.name = name
            self.status = status
            self.statusReasons = statusReasons
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case gatewayArn = "gatewayArn"
            case name = "name"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetConfiguration = "targetConfiguration"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateMemoryInput: AWSEncodableShape {
        /// A client token is used for keeping track of idempotent requests. It can contain a session id which can be around 250 chars, combined with a unique AWS identifier.
        public let clientToken: String?
        /// The updated description of the memory.
        public let description: String?
        /// The number of days after which memory events will expire, between 7 and 365 days.
        public let eventExpiryDuration: Int?
        /// The ARN of the IAM role that provides permissions for the memory.
        public let memoryExecutionRoleArn: String?
        /// The unique identifier of the memory to update.
        public let memoryId: String
        /// The memory strategies to add, modify, or delete.
        public let memoryStrategies: ModifyMemoryStrategies?

        @inlinable
        public init(clientToken: String? = UpdateMemoryInput.idempotencyToken(), description: String? = nil, eventExpiryDuration: Int? = nil, memoryExecutionRoleArn: String? = nil, memoryId: String, memoryStrategies: ModifyMemoryStrategies? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.eventExpiryDuration = eventExpiryDuration
            self.memoryExecutionRoleArn = memoryExecutionRoleArn
            self.memoryId = memoryId
            self.memoryStrategies = memoryStrategies
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.eventExpiryDuration, forKey: .eventExpiryDuration)
            try container.encodeIfPresent(self.memoryExecutionRoleArn, forKey: .memoryExecutionRoleArn)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.memoryStrategies, forKey: .memoryStrategies)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.memoryExecutionRoleArn, name: "memoryExecutionRoleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.memoryStrategies?.validate(name: "\(name).memoryStrategies")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case eventExpiryDuration = "eventExpiryDuration"
            case memoryExecutionRoleArn = "memoryExecutionRoleArn"
            case memoryStrategies = "memoryStrategies"
        }
    }

    public struct UpdateMemoryOutput: AWSDecodableShape {
        /// The updated memory details.
        public let memory: Memory?

        @inlinable
        public init(memory: Memory? = nil) {
            self.memory = memory
        }

        private enum CodingKeys: String, CodingKey {
            case memory = "memory"
        }
    }

    public struct UpdateOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The name of the OAuth2 credential provider to update.
        public let name: String
        /// The configuration input for the OAuth2 provider.
        public let oauth2ProviderConfigInput: Oauth2ProviderConfigInput

        @inlinable
        public init(credentialProviderVendor: CredentialProviderVendorType, name: String, oauth2ProviderConfigInput: Oauth2ProviderConfigInput) {
            self.credentialProviderVendor = credentialProviderVendor
            self.name = name
            self.oauth2ProviderConfigInput = oauth2ProviderConfigInput
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.oauth2ProviderConfigInput.validate(name: "\(name).oauth2ProviderConfigInput")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviderVendor = "credentialProviderVendor"
            case name = "name"
            case oauth2ProviderConfigInput = "oauth2ProviderConfigInput"
        }
    }

    public struct UpdateOauth2CredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
        public let clientSecretArn: Secret
        /// The timestamp when the OAuth2 credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
        public let credentialProviderArn: String
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The timestamp when the OAuth2 credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the OAuth2 credential provider.
        public let name: String
        /// The configuration output for the OAuth2 provider.
        public let oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput

        @inlinable
        public init(clientSecretArn: Secret, createdTime: Date, credentialProviderArn: String, credentialProviderVendor: CredentialProviderVendorType, lastUpdatedTime: Date, name: String, oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput) {
            self.clientSecretArn = clientSecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.credentialProviderVendor = credentialProviderVendor
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.oauth2ProviderConfigOutput = oauth2ProviderConfigOutput
        }

        private enum CodingKeys: String, CodingKey {
            case clientSecretArn = "clientSecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case credentialProviderVendor = "credentialProviderVendor"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case oauth2ProviderConfigOutput = "oauth2ProviderConfigOutput"
        }
    }

    public struct UpdateWorkloadIdentityRequest: AWSEncodableShape {
        /// The new list of allowed OAuth2 return URLs for resources associated with this workload identity. This list replaces the existing list.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The name of the workload identity to update.
        public let name: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, name: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.name = name
        }

        public func validate(name: String) throws {
            try self.allowedResourceOauth2ReturnUrls?.forEach {
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, max: 2048)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, min: 1)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, pattern: "^\\w+:(\\/?\\/?)[^\\s]+$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case name = "name"
        }
    }

    public struct UpdateWorkloadIdentityResponse: AWSDecodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The timestamp when the workload identity was created.
        public let createdTime: Date
        /// The timestamp when the workload identity was last updated.
        public let lastUpdatedTime: Date
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, createdTime: Date, lastUpdatedTime: Date, name: String, workloadIdentityArn: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case createdTime = "createdTime"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct UserPreferenceConsolidationOverride: AWSDecodableShape {
        /// The text to append to the prompt for user preference consolidation.
        public let appendToPrompt: String
        /// The model ID to use for user preference consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct UserPreferenceExtractionOverride: AWSDecodableShape {
        /// The text to append to the prompt for user preference extraction.
        public let appendToPrompt: String
        /// The model ID to use for user preference extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct UserPreferenceMemoryStrategyInput: AWSEncodableShape {
        /// The description of the user preference memory strategy.
        public let description: String?
        /// The name of the user preference memory strategy.
        public let name: String
        /// The namespaces associated with the user preference memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct UserPreferenceOverrideConfigurationInput: AWSEncodableShape {
        /// The consolidation configuration for a user preference override.
        public let consolidation: UserPreferenceOverrideConsolidationConfigurationInput?
        /// The extraction configuration for a user preference override.
        public let extraction: UserPreferenceOverrideExtractionConfigurationInput?

        @inlinable
        public init(consolidation: UserPreferenceOverrideConsolidationConfigurationInput? = nil, extraction: UserPreferenceOverrideExtractionConfigurationInput? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
            try self.extraction?.validate(name: "\(name).extraction")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
        }
    }

    public struct UserPreferenceOverrideConsolidationConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for user preference consolidation.
        public let appendToPrompt: String
        /// The model ID to use for user preference consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct UserPreferenceOverrideExtractionConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for user preference extraction.
        public let appendToPrompt: String
        /// The model ID to use for user preference extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message describing why this field failed validation.
        public let message: String
        /// The name of the field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct WorkloadIdentityDetails: AWSDecodableShape {
        /// The ARN associated with the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(workloadIdentityArn: String) {
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct WorkloadIdentityType: AWSDecodableShape {
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(name: String, workloadIdentityArn: String) {
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct AgentArtifact: AWSEncodableShape & AWSDecodableShape {
        /// The container configuration for the agent artifact.
        public let containerConfiguration: ContainerConfiguration?

        @inlinable
        public init(containerConfiguration: ContainerConfiguration? = nil) {
            self.containerConfiguration = containerConfiguration
        }

        public func validate(name: String) throws {
            try self.containerConfiguration?.validate(name: "\(name).containerConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case containerConfiguration = "containerConfiguration"
        }
    }

    public struct AuthorizerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The inbound JWT-based authorization, specifying how incoming requests should be authenticated.
        public let customJWTAuthorizer: CustomJWTAuthorizerConfiguration?

        @inlinable
        public init(customJWTAuthorizer: CustomJWTAuthorizerConfiguration? = nil) {
            self.customJWTAuthorizer = customJWTAuthorizer
        }

        public func validate(name: String) throws {
            try self.customJWTAuthorizer?.validate(name: "\(name).customJWTAuthorizer")
        }

        private enum CodingKeys: String, CodingKey {
            case customJWTAuthorizer = "customJWTAuthorizer"
        }
    }

    public struct ConsolidationConfiguration: AWSDecodableShape {
        /// The custom consolidation configuration.
        public let customConsolidationConfiguration: CustomConsolidationConfiguration?

        @inlinable
        public init(customConsolidationConfiguration: CustomConsolidationConfiguration? = nil) {
            self.customConsolidationConfiguration = customConsolidationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case customConsolidationConfiguration = "customConsolidationConfiguration"
        }
    }

    public struct ExtractionConfiguration: AWSDecodableShape {
        /// The custom extraction configuration.
        public let customExtractionConfiguration: CustomExtractionConfiguration?

        @inlinable
        public init(customExtractionConfiguration: CustomExtractionConfiguration? = nil) {
            self.customExtractionConfiguration = customExtractionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case customExtractionConfiguration = "customExtractionConfiguration"
        }
    }

    public struct GatewayProtocolConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the Model Context Protocol (MCP). This protocol enables communication between Amazon Bedrock Agent and external tools.
        public let mcp: MCPGatewayConfiguration?

        @inlinable
        public init(mcp: MCPGatewayConfiguration? = nil) {
            self.mcp = mcp
        }

        public func validate(name: String) throws {
            try self.mcp?.validate(name: "\(name).mcp")
        }

        private enum CodingKeys: String, CodingKey {
            case mcp = "mcp"
        }
    }

    public struct ModifyConsolidationConfiguration: AWSEncodableShape {
        /// The updated custom consolidation configuration.
        public let customConsolidationConfiguration: CustomConsolidationConfigurationInput?

        @inlinable
        public init(customConsolidationConfiguration: CustomConsolidationConfigurationInput? = nil) {
            self.customConsolidationConfiguration = customConsolidationConfiguration
        }

        public func validate(name: String) throws {
            try self.customConsolidationConfiguration?.validate(name: "\(name).customConsolidationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customConsolidationConfiguration = "customConsolidationConfiguration"
        }
    }

    public struct ModifyExtractionConfiguration: AWSEncodableShape {
        /// The updated custom extraction configuration.
        public let customExtractionConfiguration: CustomExtractionConfigurationInput?

        @inlinable
        public init(customExtractionConfiguration: CustomExtractionConfigurationInput? = nil) {
            self.customExtractionConfiguration = customExtractionConfiguration
        }

        public func validate(name: String) throws {
            try self.customExtractionConfiguration?.validate(name: "\(name).customExtractionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customExtractionConfiguration = "customExtractionConfiguration"
        }
    }

    public struct TargetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Model Context Protocol (MCP) configuration for the target. This configuration defines how the gateway uses MCP to communicate with the target.
        public let mcp: McpTargetConfiguration?

        @inlinable
        public init(mcp: McpTargetConfiguration? = nil) {
            self.mcp = mcp
        }

        public func validate(name: String) throws {
            try self.mcp?.validate(name: "\(name).mcp")
        }

        private enum CodingKeys: String, CodingKey {
            case mcp = "mcp"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgentCoreControl
public struct BedrockAgentCoreControlErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case concurrentModificationException = "ConcurrentModificationException"
        case conflictException = "ConflictException"
        case decryptionFailure = "DecryptionFailure"
        case encryptionFailure = "EncryptionFailure"
        case internalServerException = "InternalServerException"
        case resourceLimitExceededException = "ResourceLimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceException = "ServiceException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttledException = "ThrottledException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgentCoreControl
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// This exception is thrown when a request is denied per access permissions
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Exception thrown when a resource is modified concurrently by multiple requests.
    public static var concurrentModificationException: Self { .init(.concurrentModificationException) }
    /// This exception is thrown when there is a conflict performing an operation
    public static var conflictException: Self { .init(.conflictException) }
    /// Exception thrown when decryption of a secret fails.
    public static var decryptionFailure: Self { .init(.decryptionFailure) }
    /// Exception thrown when encryption of a secret fails.
    public static var encryptionFailure: Self { .init(.encryptionFailure) }
    /// This exception is thrown if there was an unexpected error during processing of request
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Exception thrown when a resource limit is exceeded.
    public static var resourceLimitExceededException: Self { .init(.resourceLimitExceededException) }
    /// This exception is thrown when a resource referenced by the operation does not exist
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// An internal error occurred.
    public static var serviceException: Self { .init(.serviceException) }
    /// This exception is thrown when a request is made beyond the service quota
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// API rate limit has been exceeded.
    public static var throttledException: Self { .init(.throttledException) }
    /// This exception is thrown when the number of requests exceeds the limit
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This exception is thrown when the JWT bearer token is invalid or not found for OAuth bearer token based access
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The input fails to satisfy the constraints specified by the service.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentCoreControlErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": BedrockAgentCoreControl.ValidationException.self
    ]
}

extension BedrockAgentCoreControlErrorType: Equatable {
    public static func == (lhs: BedrockAgentCoreControlErrorType, rhs: BedrockAgentCoreControlErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentCoreControlErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
