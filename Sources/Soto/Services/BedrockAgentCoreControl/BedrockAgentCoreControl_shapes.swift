//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgentCoreControl {
    // MARK: Enums

    public enum AgentManagedRuntimeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case python310 = "PYTHON_3_10"
        case python311 = "PYTHON_3_11"
        case python312 = "PYTHON_3_12"
        case python313 = "PYTHON_3_13"
        public var description: String { return self.rawValue }
    }

    public enum AgentRuntimeEndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AgentRuntimeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ApiKeyCredentialLocation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case header = "HEADER"
        case queryParameter = "QUERY_PARAMETER"
        public var description: String { return self.rawValue }
    }

    public enum AuthorizerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsIam = "AWS_IAM"
        case customJwt = "CUSTOM_JWT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum BrowserNetworkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `public` = "PUBLIC"
        case vpc = "VPC"
        public var description: String { return self.rawValue }
    }

    public enum BrowserStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum ClaimMatchOperatorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case containsAny = "CONTAINS_ANY"
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum CodeInterpreterNetworkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `public` = "PUBLIC"
        case sandbox = "SANDBOX"
        case vpc = "VPC"
        public var description: String { return self.rawValue }
    }

    public enum CodeInterpreterStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum CredentialProviderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case apiKey = "API_KEY"
        case gatewayIamRole = "GATEWAY_IAM_ROLE"
        case oauth = "OAUTH"
        public var description: String { return self.rawValue }
    }

    public enum CredentialProviderVendorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case atlassianOauth2 = "AtlassianOauth2"
        case auth0Oauth2 = "Auth0Oauth2"
        case cognitoOauth2 = "CognitoOauth2"
        case customOauth2 = "CustomOauth2"
        case cyberArkOauth2 = "CyberArkOauth2"
        case dropboxOauth2 = "DropboxOauth2"
        case facebookOauth2 = "FacebookOauth2"
        case fusionAuthOauth2 = "FusionAuthOauth2"
        case githubOauth2 = "GithubOauth2"
        case googleOauth2 = "GoogleOauth2"
        case hubspotOauth2 = "HubspotOauth2"
        case linkedinOauth2 = "LinkedinOauth2"
        case microsoftOauth2 = "MicrosoftOauth2"
        case notionOauth2 = "NotionOauth2"
        case oktaOauth2 = "OktaOauth2"
        case oneLoginOauth2 = "OneLoginOauth2"
        case pingOneOauth2 = "PingOneOauth2"
        case redditOauth2 = "RedditOauth2"
        case salesforceOauth2 = "SalesforceOauth2"
        case slackOauth2 = "SlackOauth2"
        case spotifyOauth2 = "SpotifyOauth2"
        case twitchOauth2 = "TwitchOauth2"
        case xOauth2 = "XOauth2"
        case yandexOauth2 = "YandexOauth2"
        case zoomOauth2 = "ZoomOauth2"
        public var description: String { return self.rawValue }
    }

    public enum EvaluatorLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case session = "SESSION"
        case toolCall = "TOOL_CALL"
        case trace = "TRACE"
        public var description: String { return self.rawValue }
    }

    public enum EvaluatorStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum EvaluatorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case builtin = "Builtin"
        case custom = "Custom"
        public var description: String { return self.rawValue }
    }

    public enum ExceptionLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "DEBUG"
        public var description: String { return self.rawValue }
    }

    public enum FilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "Contains"
        case equals = "Equals"
        case greaterThan = "GreaterThan"
        case greaterThanOrEqual = "GreaterThanOrEqual"
        case lessThan = "LessThan"
        case lessThanOrEqual = "LessThanOrEqual"
        case notContains = "NotContains"
        case notEquals = "NotEquals"
        public var description: String { return self.rawValue }
    }

    public enum FindingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allowAll = "ALLOW_ALL"
        case allowNone = "ALLOW_NONE"
        case denyAll = "DENY_ALL"
        case denyNone = "DENY_NONE"
        case invalid = "INVALID"
        case notTranslatable = "NOT_TRANSLATABLE"
        case valid = "VALID"
        public var description: String { return self.rawValue }
    }

    public enum GatewayInterceptionPoint: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case request = "REQUEST"
        case response = "RESPONSE"
        public var description: String { return self.rawValue }
    }

    public enum GatewayPolicyEngineMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enforce = "ENFORCE"
        case logOnly = "LOG_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum GatewayProtocolType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mcp = "MCP"
        public var description: String { return self.rawValue }
    }

    public enum GatewayStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case ready = "READY"
        case updateUnsuccessful = "UPDATE_UNSUCCESSFUL"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum InboundTokenClaimValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case string = "STRING"
        case stringArray = "STRING_ARRAY"
        public var description: String { return self.rawValue }
    }

    public enum KeyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customerManagedKey = "CustomerManagedKey"
        case serviceManagedKey = "ServiceManagedKey"
        public var description: String { return self.rawValue }
    }

    public enum MemoryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum MemoryStrategyStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum MemoryStrategyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case episodic = "EPISODIC"
        case semantic = "SEMANTIC"
        case summarization = "SUMMARIZATION"
        case userPreference = "USER_PREFERENCE"
        public var description: String { return self.rawValue }
    }

    public enum NetworkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `public` = "PUBLIC"
        case vpc = "VPC"
        public var description: String { return self.rawValue }
    }

    public enum OAuthGrantType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case authorizationCode = "AUTHORIZATION_CODE"
        case clientCredentials = "CLIENT_CREDENTIALS"
        public var description: String { return self.rawValue }
    }

    public enum OnlineEvaluationConfigStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum OnlineEvaluationExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum OverrideType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case episodicOverride = "EPISODIC_OVERRIDE"
        case selfManaged = "SELF_MANAGED"
        case semanticOverride = "SEMANTIC_OVERRIDE"
        case summaryOverride = "SUMMARY_OVERRIDE"
        case userPreferenceOverride = "USER_PREFERENCE_OVERRIDE"
        public var description: String { return self.rawValue }
    }

    public enum PolicyEngineStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum PolicyGenerationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleteFailed = "DELETE_FAILED"
        case generateFailed = "GENERATE_FAILED"
        case generated = "GENERATED"
        case generating = "GENERATING"
        public var description: String { return self.rawValue }
    }

    public enum PolicyStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum PolicyValidationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failOnAnyFindings = "FAIL_ON_ANY_FINDINGS"
        case ignoreAllFindings = "IGNORE_ALL_FINDINGS"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum RestApiMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        case get = "GET"
        case head = "HEAD"
        case options = "OPTIONS"
        case patch = "PATCH"
        case post = "POST"
        case put = "PUT"
        public var description: String { return self.rawValue }
    }

    public enum SchemaType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case array = "array"
        case boolean = "boolean"
        case integer = "integer"
        case number = "number"
        case object = "object"
        case string = "string"
        public var description: String { return self.rawValue }
    }

    public enum SearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum ServerProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case a2a = "A2A"
        case http = "HTTP"
        case mcp = "MCP"
        public var description: String { return self.rawValue }
    }

    public enum TargetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case ready = "READY"
        case synchronizeUnsuccessful = "SYNCHRONIZE_UNSUCCESSFUL"
        case synchronizing = "SYNCHRONIZING"
        case updateUnsuccessful = "UPDATE_UNSUCCESSFUL"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CannotParse"
        case fieldValidationFailed = "FieldValidationFailed"
        case idempotentParameterMismatchException = "IdempotentParameterMismatchException"
        case resourceConflict = "ResourceConflict"
        case rootEventInOtherSession = "EventInOtherSession"
        public var description: String { return self.rawValue }
    }

    public enum AgentRuntimeArtifact: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The code configuration for the agent runtime artifact, including the source code location and execution settings.
        case codeConfiguration(CodeConfiguration)
        /// The container configuration for the agent artifact.
        case containerConfiguration(ContainerConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .codeConfiguration:
                let value = try container.decode(CodeConfiguration.self, forKey: .codeConfiguration)
                self = .codeConfiguration(value)
            case .containerConfiguration:
                let value = try container.decode(ContainerConfiguration.self, forKey: .containerConfiguration)
                self = .containerConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .codeConfiguration(let value):
                try container.encode(value, forKey: .codeConfiguration)
            case .containerConfiguration(let value):
                try container.encode(value, forKey: .containerConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .codeConfiguration(let value):
                try value.validate(name: "\(name).codeConfiguration")
            case .containerConfiguration(let value):
                try value.validate(name: "\(name).containerConfiguration")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case codeConfiguration = "codeConfiguration"
            case containerConfiguration = "containerConfiguration"
        }
    }

    public enum ApiSchemaConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The inline payload containing the API schema definition.
        case inlinePayload(String)
        case s3(S3Configuration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .inlinePayload:
                let value = try container.decode(String.self, forKey: .inlinePayload)
                self = .inlinePayload(value)
            case .s3:
                let value = try container.decode(S3Configuration.self, forKey: .s3)
                self = .s3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .inlinePayload(let value):
                try container.encode(value, forKey: .inlinePayload)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inlinePayload = "inlinePayload"
            case s3 = "s3"
        }
    }

    public enum ClaimMatchValueType: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The string value to match for.
        case matchValueString(String)
        /// An array of strings to check for a match.
        case matchValueStringList([String])

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .matchValueString:
                let value = try container.decode(String.self, forKey: .matchValueString)
                self = .matchValueString(value)
            case .matchValueStringList:
                let value = try container.decode([String].self, forKey: .matchValueStringList)
                self = .matchValueStringList(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .matchValueString(let value):
                try container.encode(value, forKey: .matchValueString)
            case .matchValueStringList(let value):
                try container.encode(value, forKey: .matchValueStringList)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .matchValueString(let value):
                try self.validate(value, name: "matchValueString", parent: name, max: 255)
                try self.validate(value, name: "matchValueString", parent: name, min: 1)
                try self.validate(value, name: "matchValueString", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
            case .matchValueStringList(let value):
                try value.forEach {
                    try validate($0, name: "matchValueStringList[]", parent: name, max: 255)
                    try validate($0, name: "matchValueStringList[]", parent: name, min: 1)
                    try validate($0, name: "matchValueStringList[]", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
                }
                try self.validate(value, name: "matchValueStringList", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case matchValueString = "matchValueString"
            case matchValueStringList = "matchValueStringList"
        }
    }

    public enum CredentialProvider: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The API key credential provider. This provider uses an API key to authenticate with the target endpoint.
        case apiKeyCredentialProvider(GatewayApiKeyCredentialProvider)
        /// The OAuth credential provider. This provider uses OAuth authentication to access the target endpoint.
        case oauthCredentialProvider(OAuthCredentialProvider)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .apiKeyCredentialProvider:
                let value = try container.decode(GatewayApiKeyCredentialProvider.self, forKey: .apiKeyCredentialProvider)
                self = .apiKeyCredentialProvider(value)
            case .oauthCredentialProvider:
                let value = try container.decode(OAuthCredentialProvider.self, forKey: .oauthCredentialProvider)
                self = .oauthCredentialProvider(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .apiKeyCredentialProvider(let value):
                try container.encode(value, forKey: .apiKeyCredentialProvider)
            case .oauthCredentialProvider(let value):
                try container.encode(value, forKey: .oauthCredentialProvider)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .apiKeyCredentialProvider(let value):
                try value.validate(name: "\(name).apiKeyCredentialProvider")
            case .oauthCredentialProvider(let value):
                try value.validate(name: "\(name).oauthCredentialProvider")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeyCredentialProvider = "apiKeyCredentialProvider"
            case oauthCredentialProvider = "oauthCredentialProvider"
        }
    }

    public enum CustomConfigurationInput: AWSEncodableShape, Sendable {
        /// The episodic memory strategy override configuration for a custom memory strategy.
        case episodicOverride(EpisodicOverrideConfigurationInput)
        /// The self managed configuration for a custom memory strategy.
        case selfManagedConfiguration(SelfManagedConfigurationInput)
        /// The semantic override configuration for a custom memory strategy.
        case semanticOverride(SemanticOverrideConfigurationInput)
        /// The summary override configuration for a custom memory strategy.
        case summaryOverride(SummaryOverrideConfigurationInput)
        /// The user preference override configuration for a custom memory strategy.
        case userPreferenceOverride(UserPreferenceOverrideConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .episodicOverride(let value):
                try container.encode(value, forKey: .episodicOverride)
            case .selfManagedConfiguration(let value):
                try container.encode(value, forKey: .selfManagedConfiguration)
            case .semanticOverride(let value):
                try container.encode(value, forKey: .semanticOverride)
            case .summaryOverride(let value):
                try container.encode(value, forKey: .summaryOverride)
            case .userPreferenceOverride(let value):
                try container.encode(value, forKey: .userPreferenceOverride)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .episodicOverride(let value):
                try value.validate(name: "\(name).episodicOverride")
            case .selfManagedConfiguration(let value):
                try value.validate(name: "\(name).selfManagedConfiguration")
            case .semanticOverride(let value):
                try value.validate(name: "\(name).semanticOverride")
            case .summaryOverride(let value):
                try value.validate(name: "\(name).summaryOverride")
            case .userPreferenceOverride(let value):
                try value.validate(name: "\(name).userPreferenceOverride")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case episodicOverride = "episodicOverride"
            case selfManagedConfiguration = "selfManagedConfiguration"
            case semanticOverride = "semanticOverride"
            case summaryOverride = "summaryOverride"
            case userPreferenceOverride = "userPreferenceOverride"
        }
    }

    public enum CustomConsolidationConfiguration: AWSDecodableShape, Sendable {
        /// The configurations to override the default consolidation step for the episodic memory strategy.
        case episodicConsolidationOverride(EpisodicConsolidationOverride)
        /// The semantic consolidation override configuration.
        case semanticConsolidationOverride(SemanticConsolidationOverride)
        /// The summary consolidation override configuration.
        case summaryConsolidationOverride(SummaryConsolidationOverride)
        /// The user preference consolidation override configuration.
        case userPreferenceConsolidationOverride(UserPreferenceConsolidationOverride)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .episodicConsolidationOverride:
                let value = try container.decode(EpisodicConsolidationOverride.self, forKey: .episodicConsolidationOverride)
                self = .episodicConsolidationOverride(value)
            case .semanticConsolidationOverride:
                let value = try container.decode(SemanticConsolidationOverride.self, forKey: .semanticConsolidationOverride)
                self = .semanticConsolidationOverride(value)
            case .summaryConsolidationOverride:
                let value = try container.decode(SummaryConsolidationOverride.self, forKey: .summaryConsolidationOverride)
                self = .summaryConsolidationOverride(value)
            case .userPreferenceConsolidationOverride:
                let value = try container.decode(UserPreferenceConsolidationOverride.self, forKey: .userPreferenceConsolidationOverride)
                self = .userPreferenceConsolidationOverride(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case episodicConsolidationOverride = "episodicConsolidationOverride"
            case semanticConsolidationOverride = "semanticConsolidationOverride"
            case summaryConsolidationOverride = "summaryConsolidationOverride"
            case userPreferenceConsolidationOverride = "userPreferenceConsolidationOverride"
        }
    }

    public enum CustomConsolidationConfigurationInput: AWSEncodableShape, Sendable {
        /// Configurations to override the consolidation step of the episodic strategy.
        case episodicConsolidationOverride(EpisodicOverrideConsolidationConfigurationInput)
        /// The semantic consolidation override configuration input.
        case semanticConsolidationOverride(SemanticOverrideConsolidationConfigurationInput)
        /// The summary consolidation override configuration input.
        case summaryConsolidationOverride(SummaryOverrideConsolidationConfigurationInput)
        /// The user preference consolidation override configuration input.
        case userPreferenceConsolidationOverride(UserPreferenceOverrideConsolidationConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .episodicConsolidationOverride(let value):
                try container.encode(value, forKey: .episodicConsolidationOverride)
            case .semanticConsolidationOverride(let value):
                try container.encode(value, forKey: .semanticConsolidationOverride)
            case .summaryConsolidationOverride(let value):
                try container.encode(value, forKey: .summaryConsolidationOverride)
            case .userPreferenceConsolidationOverride(let value):
                try container.encode(value, forKey: .userPreferenceConsolidationOverride)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .episodicConsolidationOverride(let value):
                try value.validate(name: "\(name).episodicConsolidationOverride")
            case .semanticConsolidationOverride(let value):
                try value.validate(name: "\(name).semanticConsolidationOverride")
            case .summaryConsolidationOverride(let value):
                try value.validate(name: "\(name).summaryConsolidationOverride")
            case .userPreferenceConsolidationOverride(let value):
                try value.validate(name: "\(name).userPreferenceConsolidationOverride")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case episodicConsolidationOverride = "episodicConsolidationOverride"
            case semanticConsolidationOverride = "semanticConsolidationOverride"
            case summaryConsolidationOverride = "summaryConsolidationOverride"
            case userPreferenceConsolidationOverride = "userPreferenceConsolidationOverride"
        }
    }

    public enum CustomExtractionConfiguration: AWSDecodableShape, Sendable {
        /// The configurations to override the default extraction step for the episodic memory strategy.
        case episodicExtractionOverride(EpisodicExtractionOverride)
        /// The semantic extraction override configuration.
        case semanticExtractionOverride(SemanticExtractionOverride)
        /// The user preference extraction override configuration.
        case userPreferenceExtractionOverride(UserPreferenceExtractionOverride)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .episodicExtractionOverride:
                let value = try container.decode(EpisodicExtractionOverride.self, forKey: .episodicExtractionOverride)
                self = .episodicExtractionOverride(value)
            case .semanticExtractionOverride:
                let value = try container.decode(SemanticExtractionOverride.self, forKey: .semanticExtractionOverride)
                self = .semanticExtractionOverride(value)
            case .userPreferenceExtractionOverride:
                let value = try container.decode(UserPreferenceExtractionOverride.self, forKey: .userPreferenceExtractionOverride)
                self = .userPreferenceExtractionOverride(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case episodicExtractionOverride = "episodicExtractionOverride"
            case semanticExtractionOverride = "semanticExtractionOverride"
            case userPreferenceExtractionOverride = "userPreferenceExtractionOverride"
        }
    }

    public enum CustomExtractionConfigurationInput: AWSEncodableShape, Sendable {
        /// Configurations to override the extraction step of the episodic strategy.
        case episodicExtractionOverride(EpisodicOverrideExtractionConfigurationInput)
        /// The semantic extraction override configuration input.
        case semanticExtractionOverride(SemanticOverrideExtractionConfigurationInput)
        /// The user preference extraction override configuration input.
        case userPreferenceExtractionOverride(UserPreferenceOverrideExtractionConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .episodicExtractionOverride(let value):
                try container.encode(value, forKey: .episodicExtractionOverride)
            case .semanticExtractionOverride(let value):
                try container.encode(value, forKey: .semanticExtractionOverride)
            case .userPreferenceExtractionOverride(let value):
                try container.encode(value, forKey: .userPreferenceExtractionOverride)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .episodicExtractionOverride(let value):
                try value.validate(name: "\(name).episodicExtractionOverride")
            case .semanticExtractionOverride(let value):
                try value.validate(name: "\(name).semanticExtractionOverride")
            case .userPreferenceExtractionOverride(let value):
                try value.validate(name: "\(name).userPreferenceExtractionOverride")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case episodicExtractionOverride = "episodicExtractionOverride"
            case semanticExtractionOverride = "semanticExtractionOverride"
            case userPreferenceExtractionOverride = "userPreferenceExtractionOverride"
        }
    }

    public enum FilterValue: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  The boolean value for true/false filtering conditions.
        case booleanValue(Bool)
        ///  The numeric value for numerical filtering and comparisons.
        case doubleValue(Double)
        ///  The string value for text-based filtering.
        case stringValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .booleanValue:
                let value = try container.decode(Bool.self, forKey: .booleanValue)
                self = .booleanValue(value)
            case .doubleValue:
                let value = try container.decode(Double.self, forKey: .doubleValue)
                self = .doubleValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .booleanValue(let value):
                try container.encode(value, forKey: .booleanValue)
            case .doubleValue(let value):
                try container.encode(value, forKey: .doubleValue)
            case .stringValue(let value):
                try container.encode(value, forKey: .stringValue)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "booleanValue"
            case doubleValue = "doubleValue"
            case stringValue = "stringValue"
        }
    }

    public enum McpTargetConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The configuration for an Amazon API Gateway target.
        case apiGateway(ApiGatewayTargetConfiguration)
        /// The Lambda configuration for the Model Context Protocol target. This configuration defines how the gateway uses a Lambda function to communicate with the target.
        case lambda(McpLambdaTargetConfiguration)
        /// The MCP server specified as the gateway target.
        case mcpServer(McpServerTargetConfiguration)
        /// The OpenAPI schema for the Model Context Protocol target. This schema defines the API structure of the target.
        case openApiSchema(ApiSchemaConfiguration)
        /// The Smithy model for the Model Context Protocol target. This model defines the API structure of the target using the Smithy specification.
        case smithyModel(ApiSchemaConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .apiGateway:
                let value = try container.decode(ApiGatewayTargetConfiguration.self, forKey: .apiGateway)
                self = .apiGateway(value)
            case .lambda:
                let value = try container.decode(McpLambdaTargetConfiguration.self, forKey: .lambda)
                self = .lambda(value)
            case .mcpServer:
                let value = try container.decode(McpServerTargetConfiguration.self, forKey: .mcpServer)
                self = .mcpServer(value)
            case .openApiSchema:
                let value = try container.decode(ApiSchemaConfiguration.self, forKey: .openApiSchema)
                self = .openApiSchema(value)
            case .smithyModel:
                let value = try container.decode(ApiSchemaConfiguration.self, forKey: .smithyModel)
                self = .smithyModel(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .apiGateway(let value):
                try container.encode(value, forKey: .apiGateway)
            case .lambda(let value):
                try container.encode(value, forKey: .lambda)
            case .mcpServer(let value):
                try container.encode(value, forKey: .mcpServer)
            case .openApiSchema(let value):
                try container.encode(value, forKey: .openApiSchema)
            case .smithyModel(let value):
                try container.encode(value, forKey: .smithyModel)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .lambda(let value):
                try value.validate(name: "\(name).lambda")
            case .openApiSchema(let value):
                try value.validate(name: "\(name).openApiSchema")
            case .smithyModel(let value):
                try value.validate(name: "\(name).smithyModel")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case apiGateway = "apiGateway"
            case lambda = "lambda"
            case mcpServer = "mcpServer"
            case openApiSchema = "openApiSchema"
            case smithyModel = "smithyModel"
        }
    }

    public enum MemoryStrategyInput: AWSEncodableShape, Sendable {
        /// Input for creating a custom memory strategy.
        case customMemoryStrategy(CustomMemoryStrategyInput)
        /// Input for creating an episodic memory strategy
        case episodicMemoryStrategy(EpisodicMemoryStrategyInput)
        /// Input for creating a semantic memory strategy.
        case semanticMemoryStrategy(SemanticMemoryStrategyInput)
        /// Input for creating a summary memory strategy.
        case summaryMemoryStrategy(SummaryMemoryStrategyInput)
        /// Input for creating a user preference memory strategy.
        case userPreferenceMemoryStrategy(UserPreferenceMemoryStrategyInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customMemoryStrategy(let value):
                try container.encode(value, forKey: .customMemoryStrategy)
            case .episodicMemoryStrategy(let value):
                try container.encode(value, forKey: .episodicMemoryStrategy)
            case .semanticMemoryStrategy(let value):
                try container.encode(value, forKey: .semanticMemoryStrategy)
            case .summaryMemoryStrategy(let value):
                try container.encode(value, forKey: .summaryMemoryStrategy)
            case .userPreferenceMemoryStrategy(let value):
                try container.encode(value, forKey: .userPreferenceMemoryStrategy)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .customMemoryStrategy(let value):
                try value.validate(name: "\(name).customMemoryStrategy")
            case .episodicMemoryStrategy(let value):
                try value.validate(name: "\(name).episodicMemoryStrategy")
            case .semanticMemoryStrategy(let value):
                try value.validate(name: "\(name).semanticMemoryStrategy")
            case .summaryMemoryStrategy(let value):
                try value.validate(name: "\(name).summaryMemoryStrategy")
            case .userPreferenceMemoryStrategy(let value):
                try value.validate(name: "\(name).userPreferenceMemoryStrategy")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customMemoryStrategy = "customMemoryStrategy"
            case episodicMemoryStrategy = "episodicMemoryStrategy"
            case semanticMemoryStrategy = "semanticMemoryStrategy"
            case summaryMemoryStrategy = "summaryMemoryStrategy"
            case userPreferenceMemoryStrategy = "userPreferenceMemoryStrategy"
        }
    }

    public enum ModifyReflectionConfiguration: AWSEncodableShape, Sendable {
        /// The updated custom reflection configuration.
        case customReflectionConfiguration(CustomReflectionConfigurationInput)
        /// The updated episodic reflection configuration.
        case episodicReflectionConfiguration(EpisodicReflectionConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customReflectionConfiguration(let value):
                try container.encode(value, forKey: .customReflectionConfiguration)
            case .episodicReflectionConfiguration(let value):
                try container.encode(value, forKey: .episodicReflectionConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .customReflectionConfiguration(let value):
                try value.validate(name: "\(name).customReflectionConfiguration")
            case .episodicReflectionConfiguration(let value):
                try value.validate(name: "\(name).episodicReflectionConfiguration")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customReflectionConfiguration = "customReflectionConfiguration"
            case episodicReflectionConfiguration = "episodicReflectionConfiguration"
        }
    }

    public enum Oauth2Discovery: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The authorization server metadata for the OAuth2 provider.
        case authorizationServerMetadata(Oauth2AuthorizationServerMetadata)
        /// The discovery URL for the OAuth2 provider.
        case discoveryUrl(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .authorizationServerMetadata:
                let value = try container.decode(Oauth2AuthorizationServerMetadata.self, forKey: .authorizationServerMetadata)
                self = .authorizationServerMetadata(value)
            case .discoveryUrl:
                let value = try container.decode(String.self, forKey: .discoveryUrl)
                self = .discoveryUrl(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .authorizationServerMetadata(let value):
                try container.encode(value, forKey: .authorizationServerMetadata)
            case .discoveryUrl(let value):
                try container.encode(value, forKey: .discoveryUrl)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .authorizationServerMetadata(let value):
                try value.validate(name: "\(name).authorizationServerMetadata")
            case .discoveryUrl(let value):
                try self.validate(value, name: "discoveryUrl", parent: name, pattern: "^.+/\\.well-known/openid-configuration$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationServerMetadata = "authorizationServerMetadata"
            case discoveryUrl = "discoveryUrl"
        }
    }

    public enum Oauth2ProviderConfigInput: AWSEncodableShape, Sendable {
        /// Configuration settings for Atlassian OAuth2 provider integration.
        case atlassianOauth2ProviderConfig(AtlassianOauth2ProviderConfigInput)
        /// The configuration for a custom OAuth2 provider.
        case customOauth2ProviderConfig(CustomOauth2ProviderConfigInput)
        /// The configuration for a GitHub OAuth2 provider.
        case githubOauth2ProviderConfig(GithubOauth2ProviderConfigInput)
        /// The configuration for a Google OAuth2 provider.
        case googleOauth2ProviderConfig(GoogleOauth2ProviderConfigInput)
        /// The configuration for a non-custom OAuth2 provider. This includes settings for supported OAuth2 providers that have built-in integration support.
        case includedOauth2ProviderConfig(IncludedOauth2ProviderConfigInput)
        /// Configuration settings for LinkedIn OAuth2 provider integration.
        case linkedinOauth2ProviderConfig(LinkedinOauth2ProviderConfigInput)
        /// The configuration for a Microsoft OAuth2 provider.
        case microsoftOauth2ProviderConfig(MicrosoftOauth2ProviderConfigInput)
        /// The configuration for a Salesforce OAuth2 provider.
        case salesforceOauth2ProviderConfig(SalesforceOauth2ProviderConfigInput)
        /// The configuration for a Slack OAuth2 provider.
        case slackOauth2ProviderConfig(SlackOauth2ProviderConfigInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .atlassianOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .atlassianOauth2ProviderConfig)
            case .customOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .customOauth2ProviderConfig)
            case .githubOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .githubOauth2ProviderConfig)
            case .googleOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .googleOauth2ProviderConfig)
            case .includedOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .includedOauth2ProviderConfig)
            case .linkedinOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .linkedinOauth2ProviderConfig)
            case .microsoftOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .microsoftOauth2ProviderConfig)
            case .salesforceOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .salesforceOauth2ProviderConfig)
            case .slackOauth2ProviderConfig(let value):
                try container.encode(value, forKey: .slackOauth2ProviderConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .atlassianOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).atlassianOauth2ProviderConfig")
            case .customOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).customOauth2ProviderConfig")
            case .githubOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).githubOauth2ProviderConfig")
            case .googleOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).googleOauth2ProviderConfig")
            case .includedOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).includedOauth2ProviderConfig")
            case .linkedinOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).linkedinOauth2ProviderConfig")
            case .microsoftOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).microsoftOauth2ProviderConfig")
            case .salesforceOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).salesforceOauth2ProviderConfig")
            case .slackOauth2ProviderConfig(let value):
                try value.validate(name: "\(name).slackOauth2ProviderConfig")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case atlassianOauth2ProviderConfig = "atlassianOauth2ProviderConfig"
            case customOauth2ProviderConfig = "customOauth2ProviderConfig"
            case githubOauth2ProviderConfig = "githubOauth2ProviderConfig"
            case googleOauth2ProviderConfig = "googleOauth2ProviderConfig"
            case includedOauth2ProviderConfig = "includedOauth2ProviderConfig"
            case linkedinOauth2ProviderConfig = "linkedinOauth2ProviderConfig"
            case microsoftOauth2ProviderConfig = "microsoftOauth2ProviderConfig"
            case salesforceOauth2ProviderConfig = "salesforceOauth2ProviderConfig"
            case slackOauth2ProviderConfig = "slackOauth2ProviderConfig"
        }
    }

    public enum Oauth2ProviderConfigOutput: AWSDecodableShape, Sendable {
        /// The configuration details for the Atlassian OAuth2 provider.
        case atlassianOauth2ProviderConfig(AtlassianOauth2ProviderConfigOutput)
        /// The output configuration for a custom OAuth2 provider.
        case customOauth2ProviderConfig(CustomOauth2ProviderConfigOutput)
        /// The output configuration for a GitHub OAuth2 provider.
        case githubOauth2ProviderConfig(GithubOauth2ProviderConfigOutput)
        /// The output configuration for a Google OAuth2 provider.
        case googleOauth2ProviderConfig(GoogleOauth2ProviderConfigOutput)
        /// The configuration for a non-custom OAuth2 provider. This includes the configuration details for supported OAuth2 providers that have built-in integration support.
        case includedOauth2ProviderConfig(IncludedOauth2ProviderConfigOutput)
        /// The configuration details for the LinkedIn OAuth2 provider.
        case linkedinOauth2ProviderConfig(LinkedinOauth2ProviderConfigOutput)
        /// The output configuration for a Microsoft OAuth2 provider.
        case microsoftOauth2ProviderConfig(MicrosoftOauth2ProviderConfigOutput)
        /// The output configuration for a Salesforce OAuth2 provider.
        case salesforceOauth2ProviderConfig(SalesforceOauth2ProviderConfigOutput)
        /// The output configuration for a Slack OAuth2 provider.
        case slackOauth2ProviderConfig(SlackOauth2ProviderConfigOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .atlassianOauth2ProviderConfig:
                let value = try container.decode(AtlassianOauth2ProviderConfigOutput.self, forKey: .atlassianOauth2ProviderConfig)
                self = .atlassianOauth2ProviderConfig(value)
            case .customOauth2ProviderConfig:
                let value = try container.decode(CustomOauth2ProviderConfigOutput.self, forKey: .customOauth2ProviderConfig)
                self = .customOauth2ProviderConfig(value)
            case .githubOauth2ProviderConfig:
                let value = try container.decode(GithubOauth2ProviderConfigOutput.self, forKey: .githubOauth2ProviderConfig)
                self = .githubOauth2ProviderConfig(value)
            case .googleOauth2ProviderConfig:
                let value = try container.decode(GoogleOauth2ProviderConfigOutput.self, forKey: .googleOauth2ProviderConfig)
                self = .googleOauth2ProviderConfig(value)
            case .includedOauth2ProviderConfig:
                let value = try container.decode(IncludedOauth2ProviderConfigOutput.self, forKey: .includedOauth2ProviderConfig)
                self = .includedOauth2ProviderConfig(value)
            case .linkedinOauth2ProviderConfig:
                let value = try container.decode(LinkedinOauth2ProviderConfigOutput.self, forKey: .linkedinOauth2ProviderConfig)
                self = .linkedinOauth2ProviderConfig(value)
            case .microsoftOauth2ProviderConfig:
                let value = try container.decode(MicrosoftOauth2ProviderConfigOutput.self, forKey: .microsoftOauth2ProviderConfig)
                self = .microsoftOauth2ProviderConfig(value)
            case .salesforceOauth2ProviderConfig:
                let value = try container.decode(SalesforceOauth2ProviderConfigOutput.self, forKey: .salesforceOauth2ProviderConfig)
                self = .salesforceOauth2ProviderConfig(value)
            case .slackOauth2ProviderConfig:
                let value = try container.decode(SlackOauth2ProviderConfigOutput.self, forKey: .slackOauth2ProviderConfig)
                self = .slackOauth2ProviderConfig(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case atlassianOauth2ProviderConfig = "atlassianOauth2ProviderConfig"
            case customOauth2ProviderConfig = "customOauth2ProviderConfig"
            case githubOauth2ProviderConfig = "githubOauth2ProviderConfig"
            case googleOauth2ProviderConfig = "googleOauth2ProviderConfig"
            case includedOauth2ProviderConfig = "includedOauth2ProviderConfig"
            case linkedinOauth2ProviderConfig = "linkedinOauth2ProviderConfig"
            case microsoftOauth2ProviderConfig = "microsoftOauth2ProviderConfig"
            case salesforceOauth2ProviderConfig = "salesforceOauth2ProviderConfig"
            case slackOauth2ProviderConfig = "slackOauth2ProviderConfig"
        }
    }

    public enum RatingScale: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  The categorical rating scale with named categories and definitions for qualitative evaluation.
        case categorical([CategoricalScaleDefinition])
        ///  The numerical rating scale with defined score values and descriptions for quantitative evaluation.
        case numerical([NumericalScaleDefinition])

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .categorical:
                let value = try container.decode([CategoricalScaleDefinition].self, forKey: .categorical)
                self = .categorical(value)
            case .numerical:
                let value = try container.decode([NumericalScaleDefinition].self, forKey: .numerical)
                self = .numerical(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .categorical(let value):
                try container.encode(value, forKey: .categorical)
            case .numerical(let value):
                try container.encode(value, forKey: .numerical)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case categorical = "categorical"
            case numerical = "numerical"
        }
    }

    public enum ReflectionConfiguration: AWSDecodableShape, Sendable {
        /// The configuration for a custom reflection strategy.
        case customReflectionConfiguration(CustomReflectionConfiguration)
        /// The configuration for the episodic reflection strategy.
        case episodicReflectionConfiguration(EpisodicReflectionConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .customReflectionConfiguration:
                let value = try container.decode(CustomReflectionConfiguration.self, forKey: .customReflectionConfiguration)
                self = .customReflectionConfiguration(value)
            case .episodicReflectionConfiguration:
                let value = try container.decode(EpisodicReflectionConfiguration.self, forKey: .episodicReflectionConfiguration)
                self = .episodicReflectionConfiguration(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customReflectionConfiguration = "customReflectionConfiguration"
            case episodicReflectionConfiguration = "episodicReflectionConfiguration"
        }
    }

    public enum ToolSchema: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The inline payload of the tool schema. This payload contains the schema definition directly in the request.
        case inlinePayload([ToolDefinition])
        /// The Amazon S3 location of the tool schema. This location contains the schema definition file.
        case s3(S3Configuration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .inlinePayload:
                let value = try container.decode([ToolDefinition].self, forKey: .inlinePayload)
                self = .inlinePayload(value)
            case .s3:
                let value = try container.decode(S3Configuration.self, forKey: .s3)
                self = .s3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .inlinePayload(let value):
                try container.encode(value, forKey: .inlinePayload)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inlinePayload = "inlinePayload"
            case s3 = "s3"
        }
    }

    public enum TriggerCondition: AWSDecodableShape, Sendable {
        /// Message based trigger configuration.
        case messageBasedTrigger(MessageBasedTrigger)
        /// Time based trigger configuration.
        case timeBasedTrigger(TimeBasedTrigger)
        /// Token based trigger configuration.
        case tokenBasedTrigger(TokenBasedTrigger)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .messageBasedTrigger:
                let value = try container.decode(MessageBasedTrigger.self, forKey: .messageBasedTrigger)
                self = .messageBasedTrigger(value)
            case .timeBasedTrigger:
                let value = try container.decode(TimeBasedTrigger.self, forKey: .timeBasedTrigger)
                self = .timeBasedTrigger(value)
            case .tokenBasedTrigger:
                let value = try container.decode(TokenBasedTrigger.self, forKey: .tokenBasedTrigger)
                self = .tokenBasedTrigger(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case messageBasedTrigger = "messageBasedTrigger"
            case timeBasedTrigger = "timeBasedTrigger"
            case tokenBasedTrigger = "tokenBasedTrigger"
        }
    }

    public enum TriggerConditionInput: AWSEncodableShape, Sendable {
        /// Message based trigger configuration.
        case messageBasedTrigger(MessageBasedTriggerInput)
        /// Time based trigger configuration.
        case timeBasedTrigger(TimeBasedTriggerInput)
        /// Token based trigger configuration.
        case tokenBasedTrigger(TokenBasedTriggerInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .messageBasedTrigger(let value):
                try container.encode(value, forKey: .messageBasedTrigger)
            case .timeBasedTrigger(let value):
                try container.encode(value, forKey: .timeBasedTrigger)
            case .tokenBasedTrigger(let value):
                try container.encode(value, forKey: .tokenBasedTrigger)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case messageBasedTrigger = "messageBasedTrigger"
            case timeBasedTrigger = "timeBasedTrigger"
            case tokenBasedTrigger = "tokenBasedTrigger"
        }
    }

    // MARK: Shapes

    public struct AgentRuntime: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent runtime.
        public let agentRuntimeArn: String
        /// The unique identifier of the agent runtime.
        public let agentRuntimeId: String
        /// The name of the agent runtime.
        public let agentRuntimeName: String
        /// The version of the agent runtime.
        public let agentRuntimeVersion: String
        /// The description of the agent runtime.
        public let description: String
        /// The timestamp when the agent runtime was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the agent runtime.
        public let status: AgentRuntimeStatus

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeId: String, agentRuntimeName: String, agentRuntimeVersion: String, description: String, lastUpdatedAt: Date, status: AgentRuntimeStatus) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeName = agentRuntimeName
            self.agentRuntimeVersion = agentRuntimeVersion
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeName = "agentRuntimeName"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case description = "description"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
        }
    }

    public struct AgentRuntimeEndpoint: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent runtime associated with the endpoint.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the agent runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The timestamp when the agent runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the agent runtime endpoint.
        public let description: String?
        /// The unique identifier of the agent runtime endpoint.
        public let id: String
        /// The timestamp when the agent runtime endpoint was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The live version of the agent runtime endpoint. This is the version that is currently serving requests.
        public let liveVersion: String?
        /// The name of the agent runtime endpoint.
        public let name: String
        /// The current status of the agent runtime endpoint.
        public let status: AgentRuntimeEndpointStatus
        /// The target version of the agent runtime endpoint. This is the version that the endpoint is being updated to.
        public let targetVersion: String?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, createdAt: Date, description: String? = nil, id: String, lastUpdatedAt: Date, liveVersion: String? = nil, name: String, status: AgentRuntimeEndpointStatus, targetVersion: String? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.liveVersion = liveVersion
            self.name = name
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case liveVersion = "liveVersion"
            case name = "name"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct ApiGatewayTargetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for defining REST API tool filters and overrides for the gateway target.
        public let apiGatewayToolConfiguration: ApiGatewayToolConfiguration
        /// The ID of the API Gateway REST API.
        public let restApiId: String
        /// The ID of the stage of the REST API to add as a target.
        public let stage: String

        @inlinable
        public init(apiGatewayToolConfiguration: ApiGatewayToolConfiguration, restApiId: String, stage: String) {
            self.apiGatewayToolConfiguration = apiGatewayToolConfiguration
            self.restApiId = restApiId
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case apiGatewayToolConfiguration = "apiGatewayToolConfiguration"
            case restApiId = "restApiId"
            case stage = "stage"
        }
    }

    public struct ApiGatewayToolConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of path and method patterns to expose as tools using metadata from the REST API's OpenAPI specification.
        public let toolFilters: [ApiGatewayToolFilter]
        /// A list of explicit tool definitions with optional custom names and descriptions.
        public let toolOverrides: [ApiGatewayToolOverride]?

        @inlinable
        public init(toolFilters: [ApiGatewayToolFilter], toolOverrides: [ApiGatewayToolOverride]? = nil) {
            self.toolFilters = toolFilters
            self.toolOverrides = toolOverrides
        }

        private enum CodingKeys: String, CodingKey {
            case toolFilters = "toolFilters"
            case toolOverrides = "toolOverrides"
        }
    }

    public struct ApiGatewayToolFilter: AWSEncodableShape & AWSDecodableShape {
        /// Resource path to match in the REST API. Supports exact paths (for example, /pets) or wildcard paths (for example, /pets/* to match all paths under /pets). Must match existing paths in the REST API.
        public let filterPath: String
        /// The methods to filter for.
        public let methods: [RestApiMethod]

        @inlinable
        public init(filterPath: String, methods: [RestApiMethod]) {
            self.filterPath = filterPath
            self.methods = methods
        }

        private enum CodingKeys: String, CodingKey {
            case filterPath = "filterPath"
            case methods = "methods"
        }
    }

    public struct ApiGatewayToolOverride: AWSEncodableShape & AWSDecodableShape {
        /// The description of the tool. Provides information about the purpose and usage of the tool. If not provided, uses the description from the API's OpenAPI specification.
        public let description: String?
        /// The HTTP method to expose for the specified path.
        public let method: RestApiMethod
        /// The name of tool. Identifies the tool in the Model Context Protocol.
        public let name: String
        /// Resource path in the REST API (e.g., /pets). Must explicitly match an existing path in the REST API.
        public let path: String

        @inlinable
        public init(description: String? = nil, method: RestApiMethod, name: String, path: String) {
            self.description = description
            self.method = method
            self.name = name
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case method = "method"
            case name = "name"
            case path = "path"
        }
    }

    public struct ApiKeyCredentialProviderItem: AWSDecodableShape {
        /// The timestamp when the API key credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the API key credential provider.
        public let credentialProviderArn: String
        /// The timestamp when the API key credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the API key credential provider.
        public let name: String

        @inlinable
        public init(createdTime: Date, credentialProviderArn: String, lastUpdatedTime: Date, name: String) {
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct AtlassianOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Atlassian OAuth2 provider. This identifier is assigned by Atlassian when you register your application.
        public let clientId: String
        /// The client secret for the Atlassian OAuth2 provider. This secret is assigned by Atlassian and used along with the client ID to authenticate your application.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct AtlassianOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the Atlassian OAuth2 provider.
        public let clientId: String?
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct AuthorizingClaimMatchValueType: AWSEncodableShape & AWSDecodableShape {
        /// Defines the relationship between the claim field value and the value or values you're matching for.
        public let claimMatchOperator: ClaimMatchOperatorType
        /// The value or values to match for.
        public let claimMatchValue: ClaimMatchValueType

        @inlinable
        public init(claimMatchOperator: ClaimMatchOperatorType, claimMatchValue: ClaimMatchValueType) {
            self.claimMatchOperator = claimMatchOperator
            self.claimMatchValue = claimMatchValue
        }

        public func validate(name: String) throws {
            try self.claimMatchValue.validate(name: "\(name).claimMatchValue")
        }

        private enum CodingKeys: String, CodingKey {
            case claimMatchOperator = "claimMatchOperator"
            case claimMatchValue = "claimMatchValue"
        }
    }

    public struct BedrockEvaluatorModelConfig: AWSEncodableShape & AWSDecodableShape {
        ///  Additional model-specific request fields to customize model behavior beyond the standard inference configuration.
        public let additionalModelRequestFields: AWSDocument?
        ///  The inference configuration parameters that control model behavior during evaluation, including temperature, token limits, and sampling settings.
        public let inferenceConfig: InferenceConfiguration?
        ///  The identifier of the Amazon Bedrock model to use for evaluation. Must be a supported foundation model available in your region.
        public let modelId: String

        @inlinable
        public init(additionalModelRequestFields: AWSDocument? = nil, inferenceConfig: InferenceConfiguration? = nil, modelId: String) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.inferenceConfig = inferenceConfig
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.inferenceConfig?.validate(name: "\(name).inferenceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case inferenceConfig = "inferenceConfig"
            case modelId = "modelId"
        }
    }

    public struct BrowserNetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The network mode for the browser. This field specifies how the browser connects to the network.
        public let networkMode: BrowserNetworkMode
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(networkMode: BrowserNetworkMode, vpcConfig: VpcConfig? = nil) {
            self.networkMode = networkMode
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case networkMode = "networkMode"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct BrowserSigningConfigInput: AWSEncodableShape {
        /// Specifies whether browser signing is enabled. When enabled, the browser will cryptographically sign HTTP requests to identify itself as an AI agent to bot control vendors.
        public let enabled: Bool

        @inlinable
        public init(enabled: Bool = false) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct BrowserSigningConfigOutput: AWSDecodableShape {
        /// Indicates whether browser signing is currently enabled for cryptographic agent identification using HTTP message signatures.
        public let enabled: Bool

        @inlinable
        public init(enabled: Bool) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct BrowserSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the browser.
        public let browserArn: String
        /// The unique identifier of the browser.
        public let browserId: String
        /// The timestamp when the browser was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the browser.
        public let description: String?
        /// The timestamp when the browser was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the browser.
        public let name: String?
        /// The current status of the browser.
        public let status: BrowserStatus

        @inlinable
        public init(browserArn: String, browserId: String, createdAt: Date, description: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, status: BrowserStatus) {
            self.browserArn = browserArn
            self.browserId = browserId
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserArn = "browserArn"
            case browserId = "browserId"
            case createdAt = "createdAt"
            case description = "description"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct CategoricalScaleDefinition: AWSEncodableShape & AWSDecodableShape {
        ///  The description that explains what this categorical rating represents and when it should be used.
        public let definition: String
        ///  The label or name of this categorical rating option.
        public let label: String

        @inlinable
        public init(definition: String, label: String) {
            self.definition = definition
            self.label = label
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case label = "label"
        }
    }

    public struct CedarPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The Cedar policy statement that defines the authorization logic. This statement follows Cedar syntax and specifies principals, actions, resources, and conditions that determine when access should be allowed or denied.
        public let statement: String

        @inlinable
        public init(statement: String) {
            self.statement = statement
        }

        public func validate(name: String) throws {
            try self.validate(self.statement, name: "statement", parent: name, max: 153600)
            try self.validate(self.statement, name: "statement", parent: name, min: 35)
        }

        private enum CodingKeys: String, CodingKey {
            case statement = "statement"
        }
    }

    public struct CloudWatchLogsInputConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The list of CloudWatch log group names to monitor for agent traces.
        public let logGroupNames: [String]
        ///  The list of service names to filter traces within the specified log groups. Used to identify relevant agent sessions.
        public let serviceNames: [String]

        @inlinable
        public init(logGroupNames: [String], serviceNames: [String]) {
            self.logGroupNames = logGroupNames
            self.serviceNames = serviceNames
        }

        public func validate(name: String) throws {
            try self.logGroupNames.forEach {
                try validate($0, name: "logGroupNames[]", parent: name, max: 512)
                try validate($0, name: "logGroupNames[]", parent: name, min: 1)
                try validate($0, name: "logGroupNames[]", parent: name, pattern: "^[.\\-_/#A-Za-z0-9]+$")
            }
            try self.serviceNames.forEach {
                try validate($0, name: "serviceNames[]", parent: name, max: 256)
                try validate($0, name: "serviceNames[]", parent: name, min: 1)
                try validate($0, name: "serviceNames[]", parent: name, pattern: "^[a-zA-Z0-9._-]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupNames = "logGroupNames"
            case serviceNames = "serviceNames"
        }
    }

    public struct CloudWatchOutputConfig: AWSDecodableShape {
        ///  The name of the CloudWatch log group where evaluation results will be written. The log group will be created if it doesn't exist.
        public let logGroupName: String

        @inlinable
        public init(logGroupName: String) {
            self.logGroupName = logGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName = "logGroupName"
        }
    }

    public struct CodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The source code location and configuration details.
        public let code: Code
        /// The entry point for the code execution, specifying the function or method that should be invoked when the code runs.
        public let entryPoint: [String]
        /// The runtime environment for executing the code (for example, Python 3.9 or Node.js 18).
        public let runtime: AgentManagedRuntimeType

        @inlinable
        public init(code: Code, entryPoint: [String], runtime: AgentManagedRuntimeType) {
            self.code = code
            self.entryPoint = entryPoint
            self.runtime = runtime
        }

        public func validate(name: String) throws {
            try self.entryPoint.forEach {
                try validate($0, name: "entryPoint[]", parent: name, max: 128)
                try validate($0, name: "entryPoint[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case entryPoint = "entryPoint"
            case runtime = "runtime"
        }
    }

    public struct CodeInterpreterNetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The network mode for the code interpreter. This field specifies how the code interpreter connects to the network.
        public let networkMode: CodeInterpreterNetworkMode
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(networkMode: CodeInterpreterNetworkMode, vpcConfig: VpcConfig? = nil) {
            self.networkMode = networkMode
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case networkMode = "networkMode"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct CodeInterpreterSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the code interpreter.
        public let codeInterpreterArn: String
        /// The unique identifier of the code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the code interpreter.
        public let description: String?
        /// The timestamp when the code interpreter was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the code interpreter.
        public let name: String?
        /// The current status of the code interpreter.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterArn: String, codeInterpreterId: String, createdAt: Date, description: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, status: CodeInterpreterStatus) {
            self.codeInterpreterArn = codeInterpreterArn
            self.codeInterpreterId = codeInterpreterId
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterArn = "codeInterpreterArn"
            case codeInterpreterId = "codeInterpreterId"
            case createdAt = "createdAt"
            case description = "description"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct ContainerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ECR URI of the container.
        public let containerUri: String

        @inlinable
        public init(containerUri: String) {
            self.containerUri = containerUri
        }

        public func validate(name: String) throws {
            try self.validate(self.containerUri, name: "containerUri", parent: name, max: 1024)
            try self.validate(self.containerUri, name: "containerUri", parent: name, min: 1)
            try self.validate(self.containerUri, name: "containerUri", parent: name, pattern: "^([0-9]{12})\\.dkr\\.ecr\\.([a-z0-9-]+)\\.amazonaws\\.com/((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*)(?::([^:@]{1,300}))?(?:@(.+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case containerUri = "containerUri"
        }
    }

    public struct CreateAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime to create an endpoint for.
        public let agentRuntimeId: String
        /// The version of the AgentCore Runtime to use for the endpoint.
        public let agentRuntimeVersion: String?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The description of the AgentCore Runtime endpoint.
        public let description: String?
        /// The name of the AgentCore Runtime endpoint.
        public let name: String
        /// A map of tag keys and values to assign to the agent runtime endpoint. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(agentRuntimeId: String, agentRuntimeVersion: String? = nil, clientToken: String? = CreateAgentRuntimeEndpointRequest.idempotencyToken(), description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            try container.encodeIfPresent(self.agentRuntimeVersion, forKey: .agentRuntimeVersion)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, max: 5)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, min: 1)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, pattern: "^([1-9][0-9]{0,4})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeVersion = "agentRuntimeVersion"
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The unique identifier of the AgentCore Runtime.
        public let agentRuntimeId: String?
        /// The timestamp when the AgentCore Runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The name of the AgentCore Runtime endpoint.
        public let endpointName: String?
        /// The current status of the AgentCore Runtime endpoint.
        public let status: AgentRuntimeEndpointStatus
        /// The target version of the AgentCore Runtime for the endpoint.
        public let targetVersion: String

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, agentRuntimeId: String? = nil, createdAt: Date, endpointName: String? = nil, status: AgentRuntimeEndpointStatus, targetVersion: String) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.agentRuntimeId = agentRuntimeId
            self.createdAt = createdAt
            self.endpointName = endpointName
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case agentRuntimeId = "agentRuntimeId"
            case createdAt = "createdAt"
            case endpointName = "endpointName"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct CreateAgentRuntimeRequest: AWSEncodableShape {
        /// The artifact of the AgentCore Runtime.
        public let agentRuntimeArtifact: AgentRuntimeArtifact
        /// The name of the AgentCore Runtime.
        public let agentRuntimeName: String
        /// The authorizer configuration for the AgentCore Runtime.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The description of the AgentCore Runtime.
        public let description: String?
        /// Environment variables to set in the AgentCore Runtime environment.
        public let environmentVariables: [String: String]?
        /// The life cycle configuration for the AgentCore Runtime.
        public let lifecycleConfiguration: LifecycleConfiguration?
        /// The network configuration for the AgentCore Runtime.
        public let networkConfiguration: NetworkConfiguration
        public let protocolConfiguration: ProtocolConfiguration?
        /// Configuration for HTTP request headers that will be passed through to the runtime.
        public let requestHeaderConfiguration: RequestHeaderConfiguration?
        /// The IAM role ARN that provides permissions for the AgentCore Runtime.
        public let roleArn: String
        /// A map of tag keys and values to assign to the agent runtime. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(agentRuntimeArtifact: AgentRuntimeArtifact, agentRuntimeName: String, authorizerConfiguration: AuthorizerConfiguration? = nil, clientToken: String? = CreateAgentRuntimeRequest.idempotencyToken(), description: String? = nil, environmentVariables: [String: String]? = nil, lifecycleConfiguration: LifecycleConfiguration? = nil, networkConfiguration: NetworkConfiguration, protocolConfiguration: ProtocolConfiguration? = nil, requestHeaderConfiguration: RequestHeaderConfiguration? = nil, roleArn: String, tags: [String: String]? = nil) {
            self.agentRuntimeArtifact = agentRuntimeArtifact
            self.agentRuntimeName = agentRuntimeName
            self.authorizerConfiguration = authorizerConfiguration
            self.clientToken = clientToken
            self.description = description
            self.environmentVariables = environmentVariables
            self.lifecycleConfiguration = lifecycleConfiguration
            self.networkConfiguration = networkConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.requestHeaderConfiguration = requestHeaderConfiguration
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.agentRuntimeArtifact.validate(name: "\(name).agentRuntimeArtifact")
            try self.validate(self.agentRuntimeName, name: "agentRuntimeName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.authorizerConfiguration?.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 100)
                try validate($0.key, name: "environmentVariables.key", parent: name, min: 1)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 5000)
            }
            try self.validate(self.environmentVariables, name: "environmentVariables", parent: name, max: 50)
            try self.networkConfiguration.validate(name: "\(name).networkConfiguration")
            try self.requestHeaderConfiguration?.validate(name: "\(name).requestHeaderConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArtifact = "agentRuntimeArtifact"
            case agentRuntimeName = "agentRuntimeName"
            case authorizerConfiguration = "authorizerConfiguration"
            case clientToken = "clientToken"
            case description = "description"
            case environmentVariables = "environmentVariables"
            case lifecycleConfiguration = "lifecycleConfiguration"
            case networkConfiguration = "networkConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case requestHeaderConfiguration = "requestHeaderConfiguration"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateAgentRuntimeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The unique identifier of the AgentCore Runtime.
        public let agentRuntimeId: String
        /// The version of the AgentCore Runtime.
        public let agentRuntimeVersion: String
        /// The timestamp when the AgentCore Runtime was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The current status of the AgentCore Runtime.
        public let status: AgentRuntimeStatus
        /// The workload identity details for the AgentCore Runtime.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeId: String, agentRuntimeVersion: String, createdAt: Date, status: AgentRuntimeStatus, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.createdAt = createdAt
            self.status = status
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case createdAt = "createdAt"
            case status = "status"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct CreateApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The API key to use for authentication. This value is encrypted and stored securely.
        public let apiKey: String
        /// The name of the API key credential provider. The name must be unique within your account.
        public let name: String
        /// A map of tag keys and values to assign to the API key credential provider. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(apiKey: String, name: String, tags: [String: String]? = nil) {
            self.apiKey = apiKey
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 65536)
            try self.validate(self.apiKey, name: "apiKey", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateApiKeyCredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the secret containing the API key.
        public let apiKeySecretArn: Secret
        /// The Amazon Resource Name (ARN) of the created API key credential provider.
        public let credentialProviderArn: String
        /// The name of the created API key credential provider.
        public let name: String

        @inlinable
        public init(apiKeySecretArn: Secret, credentialProviderArn: String, name: String) {
            self.apiKeySecretArn = apiKeySecretArn
            self.credentialProviderArn = credentialProviderArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySecretArn = "apiKeySecretArn"
            case credentialProviderArn = "credentialProviderArn"
            case name = "name"
        }
    }

    public struct CreateBrowserRequest: AWSEncodableShape {
        /// The browser signing configuration that enables cryptographic agent identification using HTTP message signatures for web bot authentication.
        public let browserSigning: BrowserSigningConfigInput?
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
        public let clientToken: String?
        /// The description of the browser.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the browser to access Amazon Web Services services.
        public let executionRoleArn: String?
        /// The name of the browser. The name must be unique within your account.
        public let name: String
        /// The network configuration for the browser. This configuration specifies the network mode for the browser.
        public let networkConfiguration: BrowserNetworkConfiguration
        /// The recording configuration for the browser. When enabled, browser sessions are recorded and stored in the specified Amazon S3 location.
        public let recording: RecordingConfig?
        /// A map of tag keys and values to assign to the browser. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(browserSigning: BrowserSigningConfigInput? = nil, clientToken: String? = CreateBrowserRequest.idempotencyToken(), description: String? = nil, executionRoleArn: String? = nil, name: String, networkConfiguration: BrowserNetworkConfiguration, recording: RecordingConfig? = nil, tags: [String: String]? = nil) {
            self.browserSigning = browserSigning
            self.clientToken = clientToken
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.recording = recording
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.networkConfiguration.validate(name: "\(name).networkConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case browserSigning = "browserSigning"
            case clientToken = "clientToken"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
            case recording = "recording"
            case tags = "tags"
        }
    }

    public struct CreateBrowserResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created browser.
        public let browserArn: String
        /// The unique identifier of the created browser.
        public let browserId: String
        /// The timestamp when the browser was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The current status of the browser.
        public let status: BrowserStatus

        @inlinable
        public init(browserArn: String, browserId: String, createdAt: Date, status: BrowserStatus) {
            self.browserArn = browserArn
            self.browserId = browserId
            self.createdAt = createdAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserArn = "browserArn"
            case browserId = "browserId"
            case createdAt = "createdAt"
            case status = "status"
        }
    }

    public struct CreateCodeInterpreterRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
        public let clientToken: String?
        /// The description of the code interpreter.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the code interpreter to access Amazon Web Services services.
        public let executionRoleArn: String?
        /// The name of the code interpreter. The name must be unique within your account.
        public let name: String
        /// The network configuration for the code interpreter. This configuration specifies the network mode for the code interpreter.
        public let networkConfiguration: CodeInterpreterNetworkConfiguration
        /// A map of tag keys and values to assign to the code interpreter. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateCodeInterpreterRequest.idempotencyToken(), description: String? = nil, executionRoleArn: String? = nil, name: String, networkConfiguration: CodeInterpreterNetworkConfiguration, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 1)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.networkConfiguration.validate(name: "\(name).networkConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateCodeInterpreterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created code interpreter.
        public let codeInterpreterArn: String
        /// The unique identifier of the created code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The current status of the code interpreter.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterArn: String, codeInterpreterId: String, createdAt: Date, status: CodeInterpreterStatus) {
            self.codeInterpreterArn = codeInterpreterArn
            self.codeInterpreterId = codeInterpreterId
            self.createdAt = createdAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterArn = "codeInterpreterArn"
            case codeInterpreterId = "codeInterpreterId"
            case createdAt = "createdAt"
            case status = "status"
        }
    }

    public struct CreateEvaluatorRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        ///  The description of the evaluator that explains its purpose and evaluation criteria.
        public let description: String?
        ///  The configuration for the evaluator, including LLM-as-a-Judge settings with instructions, rating scale, and model configuration.
        public let evaluatorConfig: EvaluatorConfig
        ///  The name of the evaluator. Must be unique within your account.
        public let evaluatorName: String
        ///  The evaluation level that determines the scope of evaluation. Valid values are TOOL_CALL for individual tool invocations, TRACE for single request-response interactions, or SESSION for entire conversation sessions.
        public let level: EvaluatorLevel

        @inlinable
        public init(clientToken: String? = CreateEvaluatorRequest.idempotencyToken(), description: String? = nil, evaluatorConfig: EvaluatorConfig, evaluatorName: String, level: EvaluatorLevel) {
            self.clientToken = clientToken
            self.description = description
            self.evaluatorConfig = evaluatorConfig
            self.evaluatorName = evaluatorName
            self.level = level
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.evaluatorConfig.validate(name: "\(name).evaluatorConfig")
            try self.validate(self.evaluatorName, name: "evaluatorName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case evaluatorConfig = "evaluatorConfig"
            case evaluatorName = "evaluatorName"
            case level = "level"
        }
    }

    public struct CreateEvaluatorResponse: AWSDecodableShape {
        ///  The timestamp when the evaluator was created.
        public let createdAt: Date
        ///  The Amazon Resource Name (ARN) of the created evaluator.
        public let evaluatorArn: String
        ///  The unique identifier of the created evaluator.
        public let evaluatorId: String
        ///  The status of the evaluator creation operation.
        public let status: EvaluatorStatus

        @inlinable
        public init(createdAt: Date, evaluatorArn: String, evaluatorId: String, status: EvaluatorStatus) {
            self.createdAt = createdAt
            self.evaluatorArn = evaluatorArn
            self.evaluatorId = evaluatorId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case evaluatorArn = "evaluatorArn"
            case evaluatorId = "evaluatorId"
            case status = "status"
        }
    }

    public struct CreateGatewayRequest: AWSEncodableShape {
        /// The authorizer configuration for the gateway. Required if authorizerType is CUSTOM_JWT.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The type of authorizer to use for the gateway.    CUSTOM_JWT - Authorize with a bearer token.    AWS_IAM - Authorize with your Amazon Web Services IAM credentials.    NONE - No authorization
        public let authorizerType: AuthorizerType
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The description of the gateway.
        public let description: String?
        /// The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
        public let exceptionLevel: ExceptionLevel?
        /// A list of configuration settings for a gateway interceptor. Gateway interceptors allow custom code to be invoked during gateway invocations.
        public let interceptorConfigurations: [GatewayInterceptorConfiguration]?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt data associated with the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway. The name must be unique within your account.
        public let name: String
        /// The policy engine configuration for the gateway. A policy engine is a collection of policies that evaluates and authorizes agent tool calls. When associated with a gateway, the policy engine intercepts all agent requests and determines whether to allow or deny each action based on the defined policies.
        public let policyEngineConfiguration: GatewayPolicyEngineConfiguration?
        /// The configuration settings for the protocol specified in the protocolType parameter.
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The protocol type for the gateway.
        public let protocolType: GatewayProtocolType
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the gateway to access Amazon Web Services services.
        public let roleArn: String
        /// A map of key-value pairs to associate with the gateway as metadata tags.
        public let tags: [String: String]?

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, clientToken: String? = CreateGatewayRequest.idempotencyToken(), description: String? = nil, exceptionLevel: ExceptionLevel? = nil, interceptorConfigurations: [GatewayInterceptorConfiguration]? = nil, kmsKeyArn: String? = nil, name: String, policyEngineConfiguration: GatewayPolicyEngineConfiguration? = nil, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String, tags: [String: String]? = nil) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.clientToken = clientToken
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.interceptorConfigurations = interceptorConfigurations
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.policyEngineConfiguration = policyEngineConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.authorizerConfiguration?.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.interceptorConfigurations?.forEach {
                try $0.validate(name: "\(name).interceptorConfigurations[]")
            }
            try self.validate(self.interceptorConfigurations, name: "interceptorConfigurations", parent: name, max: 2)
            try self.validate(self.interceptorConfigurations, name: "interceptorConfigurations", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.policyEngineConfiguration?.validate(name: "\(name).policyEngineConfiguration")
            try self.protocolConfiguration?.validate(name: "\(name).protocolConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case clientToken = "clientToken"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case interceptorConfigurations = "interceptorConfigurations"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case policyEngineConfiguration = "policyEngineConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateGatewayResponse: AWSDecodableShape {
        /// The authorizer configuration for the created gateway.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The type of authorizer used by the gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the gateway.
        public let description: String?
        /// The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
        public let exceptionLevel: ExceptionLevel?
        /// The Amazon Resource Name (ARN) of the created gateway.
        public let gatewayArn: String
        /// The unique identifier of the created gateway.
        public let gatewayId: String
        /// The URL endpoint for the created gateway.
        public let gatewayUrl: String?
        /// The list of interceptor configurations for the created gateway.
        public let interceptorConfigurations: [GatewayInterceptorConfiguration]?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt data associated with the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway.
        public let name: String
        /// The policy engine configuration for the created gateway.
        public let policyEngineConfiguration: GatewayPolicyEngineConfiguration?
        /// The configuration settings for the protocol used by the gateway.
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The protocol type of the gateway.
        public let protocolType: GatewayProtocolType
        /// The Amazon Resource Name (ARN) of the IAM role associated with the gateway.
        public let roleArn: String?
        /// The current status of the gateway.
        public let status: GatewayStatus
        /// The reasons for the current status of the gateway.
        public let statusReasons: [String]?
        /// The timestamp when the gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The workload identity details for the created gateway.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayArn: String, gatewayId: String, gatewayUrl: String? = nil, interceptorConfigurations: [GatewayInterceptorConfiguration]? = nil, kmsKeyArn: String? = nil, name: String, policyEngineConfiguration: GatewayPolicyEngineConfiguration? = nil, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String? = nil, status: GatewayStatus, statusReasons: [String]? = nil, updatedAt: Date, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
            self.gatewayUrl = gatewayUrl
            self.interceptorConfigurations = interceptorConfigurations
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.policyEngineConfiguration = policyEngineConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
            case gatewayUrl = "gatewayUrl"
            case interceptorConfigurations = "interceptorConfigurations"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case policyEngineConfiguration = "policyEngineConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct CreateGatewayTargetRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        /// The credential provider configurations for the target. These configurations specify how the gateway authenticates with the target endpoint.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]?
        /// The description of the gateway target.
        public let description: String?
        /// The identifier of the gateway to create a target for.
        public let gatewayIdentifier: String
        /// The name of the gateway target. The name must be unique within the gateway.
        public let name: String
        /// The configuration settings for the target, including endpoint information and schema definitions.
        public let targetConfiguration: TargetConfiguration

        @inlinable
        public init(clientToken: String? = CreateGatewayTargetRequest.idempotencyToken(), credentialProviderConfigurations: [CredentialProviderConfiguration]? = nil, description: String? = nil, gatewayIdentifier: String, name: String, targetConfiguration: TargetConfiguration) {
            self.clientToken = clientToken
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayIdentifier = gatewayIdentifier
            self.name = name
            self.targetConfiguration = targetConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.credentialProviderConfigurations, forKey: .credentialProviderConfigurations)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.targetConfiguration, forKey: .targetConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.credentialProviderConfigurations?.forEach {
                try $0.validate(name: "\(name).credentialProviderConfigurations[]")
            }
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, max: 1)
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.targetConfiguration.validate(name: "\(name).targetConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case name = "name"
            case targetConfiguration = "targetConfiguration"
        }
    }

    public struct CreateGatewayTargetResponse: AWSDecodableShape {
        /// The timestamp when the target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The credential provider configurations for the target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The description of the target.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the gateway.
        public let gatewayArn: String
        /// The last synchronization of the target.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastSynchronizedAt: Date?
        /// The name of the target.
        public let name: String
        /// The current status of the target.
        public let status: TargetStatus
        /// The reasons for the current status of the target.
        public let statusReasons: [String]?
        /// The configuration settings for the target.
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the created target.
        public let targetId: String
        /// The timestamp when the target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayArn: String, lastSynchronizedAt: Date? = nil, name: String, status: TargetStatus, statusReasons: [String]? = nil, targetConfiguration: TargetConfiguration, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayArn = gatewayArn
            self.lastSynchronizedAt = lastSynchronizedAt
            self.name = name
            self.status = status
            self.statusReasons = statusReasons
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case gatewayArn = "gatewayArn"
            case lastSynchronizedAt = "lastSynchronizedAt"
            case name = "name"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetConfiguration = "targetConfiguration"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateMemoryInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
        public let clientToken: String?
        /// The description of the memory.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the memory data.
        public let encryptionKeyArn: String?
        /// The duration after which memory events expire. Specified as an ISO 8601 duration.
        public let eventExpiryDuration: Int
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the memory to access Amazon Web Services services.
        public let memoryExecutionRoleArn: String?
        /// The memory strategies to use for this memory. Strategies define how information is extracted, processed, and consolidated.
        public let memoryStrategies: [MemoryStrategyInput]?
        /// The name of the memory. The name must be unique within your account.
        public let name: String
        /// A map of tag keys and values to assign to an AgentCore Memory. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateMemoryInput.idempotencyToken(), description: String? = nil, encryptionKeyArn: String? = nil, eventExpiryDuration: Int, memoryExecutionRoleArn: String? = nil, memoryStrategies: [MemoryStrategyInput]? = nil, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.encryptionKeyArn = encryptionKeyArn
            self.eventExpiryDuration = eventExpiryDuration
            self.memoryExecutionRoleArn = memoryExecutionRoleArn
            self.memoryStrategies = memoryStrategies
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memoryExecutionRoleArn, name: "memoryExecutionRoleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.memoryStrategies?.forEach {
                try $0.validate(name: "\(name).memoryStrategies[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case encryptionKeyArn = "encryptionKeyArn"
            case eventExpiryDuration = "eventExpiryDuration"
            case memoryExecutionRoleArn = "memoryExecutionRoleArn"
            case memoryStrategies = "memoryStrategies"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateMemoryOutput: AWSDecodableShape {
        /// The details of the created memory, including its ID, ARN, name, description, and configuration settings.
        public let memory: Memory?

        @inlinable
        public init(memory: Memory? = nil) {
            self.memory = memory
        }

        private enum CodingKeys: String, CodingKey {
            case memory = "memory"
        }
    }

    public struct CreateOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The vendor of the OAuth2 credential provider. This specifies which OAuth2 implementation to use.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The name of the OAuth2 credential provider. The name must be unique within your account.
        public let name: String
        /// The configuration settings for the OAuth2 provider, including client ID, client secret, and other vendor-specific settings.
        public let oauth2ProviderConfigInput: Oauth2ProviderConfigInput
        /// A map of tag keys and values to assign to the OAuth2 credential provider. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(credentialProviderVendor: CredentialProviderVendorType, name: String, oauth2ProviderConfigInput: Oauth2ProviderConfigInput, tags: [String: String]? = nil) {
            self.credentialProviderVendor = credentialProviderVendor
            self.name = name
            self.oauth2ProviderConfigInput = oauth2ProviderConfigInput
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.oauth2ProviderConfigInput.validate(name: "\(name).oauth2ProviderConfigInput")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviderVendor = "credentialProviderVendor"
            case name = "name"
            case oauth2ProviderConfigInput = "oauth2ProviderConfigInput"
            case tags = "tags"
        }
    }

    public struct CreateOauth2CredentialProviderResponse: AWSDecodableShape {
        /// Callback URL to register on the OAuth2 credential provider as an allowed callback URL. This URL is where the OAuth2 authorization server redirects users after they complete the authorization flow.
        public let callbackUrl: String?
        /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
        public let clientSecretArn: Secret
        /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
        public let credentialProviderArn: String
        /// The name of the OAuth2 credential provider.
        public let name: String
        public let oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput?

        @inlinable
        public init(callbackUrl: String? = nil, clientSecretArn: Secret, credentialProviderArn: String, name: String, oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput? = nil) {
            self.callbackUrl = callbackUrl
            self.clientSecretArn = clientSecretArn
            self.credentialProviderArn = credentialProviderArn
            self.name = name
            self.oauth2ProviderConfigOutput = oauth2ProviderConfigOutput
        }

        private enum CodingKeys: String, CodingKey {
            case callbackUrl = "callbackUrl"
            case clientSecretArn = "clientSecretArn"
            case credentialProviderArn = "credentialProviderArn"
            case name = "name"
            case oauth2ProviderConfigOutput = "oauth2ProviderConfigOutput"
        }
    }

    public struct CreateOnlineEvaluationConfigRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        ///  The data source configuration that specifies CloudWatch log groups and service names to monitor for agent traces.
        public let dataSourceConfig: DataSourceConfig
        ///  The description of the online evaluation configuration that explains its monitoring purpose and scope.
        public let description: String?
        ///  Whether to enable the online evaluation configuration immediately upon creation. If true, evaluation begins automatically.
        public let enableOnCreate: Bool
        ///  The Amazon Resource Name (ARN) of the IAM role that grants permissions to read from CloudWatch logs, write evaluation results, and invoke Amazon Bedrock models for evaluation.
        public let evaluationExecutionRoleArn: String
        ///  The list of evaluators to apply during online evaluation. Can include both built-in evaluators and custom evaluators created with CreateEvaluator.
        public let evaluators: [EvaluatorReference]
        ///  The name of the online evaluation configuration. Must be unique within your account.
        public let onlineEvaluationConfigName: String
        ///  The evaluation rule that defines sampling configuration, filters, and session detection settings for the online evaluation.
        public let rule: Rule

        @inlinable
        public init(clientToken: String? = CreateOnlineEvaluationConfigRequest.idempotencyToken(), dataSourceConfig: DataSourceConfig, description: String? = nil, enableOnCreate: Bool, evaluationExecutionRoleArn: String, evaluators: [EvaluatorReference], onlineEvaluationConfigName: String, rule: Rule) {
            self.clientToken = clientToken
            self.dataSourceConfig = dataSourceConfig
            self.description = description
            self.enableOnCreate = enableOnCreate
            self.evaluationExecutionRoleArn = evaluationExecutionRoleArn
            self.evaluators = evaluators
            self.onlineEvaluationConfigName = onlineEvaluationConfigName
            self.rule = rule
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.dataSourceConfig.validate(name: "\(name).dataSourceConfig")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.validate(self.evaluationExecutionRoleArn, name: "evaluationExecutionRoleArn", parent: name, max: 2048)
            try self.validate(self.evaluationExecutionRoleArn, name: "evaluationExecutionRoleArn", parent: name, min: 1)
            try self.validate(self.evaluationExecutionRoleArn, name: "evaluationExecutionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.evaluators.forEach {
                try $0.validate(name: "\(name).evaluators[]")
            }
            try self.validate(self.evaluators, name: "evaluators", parent: name, max: 10)
            try self.validate(self.evaluators, name: "evaluators", parent: name, min: 1)
            try self.validate(self.onlineEvaluationConfigName, name: "onlineEvaluationConfigName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.rule.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dataSourceConfig = "dataSourceConfig"
            case description = "description"
            case enableOnCreate = "enableOnCreate"
            case evaluationExecutionRoleArn = "evaluationExecutionRoleArn"
            case evaluators = "evaluators"
            case onlineEvaluationConfigName = "onlineEvaluationConfigName"
            case rule = "rule"
        }
    }

    public struct CreateOnlineEvaluationConfigResponse: AWSDecodableShape {
        ///  The timestamp when the online evaluation configuration was created.
        public let createdAt: Date
        ///  The execution status indicating whether the online evaluation is currently running.
        public let executionStatus: OnlineEvaluationExecutionStatus
        ///  The reason for failure if the online evaluation configuration creation or execution failed.
        public let failureReason: String?
        ///  The Amazon Resource Name (ARN) of the created online evaluation configuration.
        public let onlineEvaluationConfigArn: String
        ///  The unique identifier of the created online evaluation configuration.
        public let onlineEvaluationConfigId: String
        public let outputConfig: OutputConfig?
        ///  The status of the online evaluation configuration.
        public let status: OnlineEvaluationConfigStatus

        @inlinable
        public init(createdAt: Date, executionStatus: OnlineEvaluationExecutionStatus, failureReason: String? = nil, onlineEvaluationConfigArn: String, onlineEvaluationConfigId: String, outputConfig: OutputConfig? = nil, status: OnlineEvaluationConfigStatus) {
            self.createdAt = createdAt
            self.executionStatus = executionStatus
            self.failureReason = failureReason
            self.onlineEvaluationConfigArn = onlineEvaluationConfigArn
            self.onlineEvaluationConfigId = onlineEvaluationConfigId
            self.outputConfig = outputConfig
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case executionStatus = "executionStatus"
            case failureReason = "failureReason"
            case onlineEvaluationConfigArn = "onlineEvaluationConfigArn"
            case onlineEvaluationConfigId = "onlineEvaluationConfigId"
            case outputConfig = "outputConfig"
            case status = "status"
        }
    }

    public struct CreatePolicyEngineRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request with the same client token, the service returns the same response without creating a duplicate policy engine.
        public let clientToken: String?
        /// A human-readable description of the policy engine's purpose and scope (1-4,096 characters). This helps administrators understand the policy engine's role in the overall governance strategy. Document which Gateway this engine will be associated with, what types of tools or workflows it governs, and the team or service responsible for maintaining it. Clear descriptions are essential when managing multiple policy engines across different services or environments.
        public let description: String?
        /// The customer-assigned immutable name for the policy engine. This name identifies the policy engine and cannot be changed after creation.
        public let name: String

        @inlinable
        public init(clientToken: String? = CreatePolicyEngineRequest.idempotencyToken(), description: String? = nil, name: String) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 48)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
        }
    }

    public struct CreatePolicyEngineResponse: AWSDecodableShape {
        /// The timestamp when the policy engine was created. This is automatically set by the service and used for auditing and lifecycle management.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A human-readable description of the policy engine's purpose.
        public let description: String?
        /// The customer-assigned name of the created policy engine. This matches the name provided in the request and serves as the human-readable identifier.
        public let name: String
        /// The Amazon Resource Name (ARN) of the created policy engine. This globally unique identifier can be used for cross-service references and IAM policy statements.
        public let policyEngineArn: String
        /// The unique identifier for the created policy engine. This system-generated identifier consists of the user name plus a 10-character generated suffix and is used for all subsequent policy engine operations.
        public let policyEngineId: String
        /// The current status of the policy engine. A status of ACTIVE indicates the policy engine is ready for use.
        public let status: PolicyEngineStatus
        /// Additional information about the policy engine status. This provides details about any failures or the current state of the policy engine creation process.
        public let statusReasons: [String]
        /// The timestamp when the policy engine was last updated. For newly created policy engines, this matches the createdAt timestamp.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, name: String, policyEngineArn: String, policyEngineId: String, status: PolicyEngineStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.policyEngineArn = policyEngineArn
            self.policyEngineId = policyEngineId
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case name = "name"
            case policyEngineArn = "policyEngineArn"
            case policyEngineId = "policyEngineId"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreatePolicyRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure the idempotency of the request. The AWS SDK automatically generates this token, so you don't need to provide it in most cases. If you retry a request with the same client token, the service returns the same response without creating a duplicate policy.
        public let clientToken: String?
        /// The Cedar policy statement that defines the access control rules. This contains the actual policy logic written in Cedar policy language, specifying effect (permit or forbid), principals, actions, resources, and conditions for agent behavior control.
        public let definition: PolicyDefinition
        /// A human-readable description of the policy's purpose and functionality (1-4,096 characters). This helps policy administrators understand the policy's intent, business rules, and operational scope. Use this field to document why the policy exists, what business requirement it addresses, and any special considerations for maintenance. Clear descriptions are essential for policy governance, auditing, and troubleshooting.
        public let description: String?
        /// The customer-assigned immutable name for the policy. Must be unique within the account. This name is used for policy identification and cannot be changed after creation.
        public let name: String
        /// The identifier of the policy engine which contains this policy. Policy engines group related policies and provide the execution context for policy evaluation.
        public let policyEngineId: String
        /// The validation mode for the policy creation. Determines how Cedar analyzer validation results are handled during policy creation. FAIL_ON_ANY_FINDINGS (default) runs the Cedar analyzer to validate the policy against the Cedar schema and tool context, failing creation if the analyzer detects any validation issues to ensure strict conformance. IGNORE_ALL_FINDINGS runs the Cedar analyzer but allows policy creation even if validation issues are detected, useful for testing or when the policy schema is evolving. Use FAIL_ON_ANY_FINDINGS for production policies to ensure correctness, and IGNORE_ALL_FINDINGS only when you understand and accept the analyzer findings.
        public let validationMode: PolicyValidationMode?

        @inlinable
        public init(clientToken: String? = CreatePolicyRequest.idempotencyToken(), definition: PolicyDefinition, description: String? = nil, name: String, policyEngineId: String, validationMode: PolicyValidationMode? = nil) {
            self.clientToken = clientToken
            self.definition = definition
            self.description = description
            self.name = name
            self.policyEngineId = policyEngineId
            self.validationMode = validationMode
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.definition, forKey: .definition)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            request.encodePath(self.policyEngineId, key: "policyEngineId")
            try container.encodeIfPresent(self.validationMode, forKey: .validationMode)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.definition.validate(name: "\(name).definition")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 48)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*$")
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case definition = "definition"
            case description = "description"
            case name = "name"
            case validationMode = "validationMode"
        }
    }

    public struct CreatePolicyResponse: AWSDecodableShape {
        /// The timestamp when the policy was created. This is automatically set by the service and used for auditing and lifecycle management.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Cedar policy statement that was created. This is the validated policy definition that will be used for agent behavior control and access decisions.
        public let definition: PolicyDefinition
        /// The human-readable description of the policy's purpose and functionality. This helps administrators understand and manage the policy.
        public let description: String?
        /// The customer-assigned name of the created policy. This matches the name provided in the request and serves as the human-readable identifier for the policy.
        public let name: String
        /// The Amazon Resource Name (ARN) of the created policy. This globally unique identifier can be used for cross-service references and IAM policy statements.
        public let policyArn: String
        /// The identifier of the policy engine that manages this policy. This confirms the policy engine assignment and is used for policy evaluation routing.
        public let policyEngineId: String
        /// The unique identifier for the created policy. This is a system-generated identifier consisting of the user name plus a 10-character generated suffix, used for all subsequent policy operations.
        public let policyId: String
        /// The current status of the policy. A status of ACTIVE indicates the policy is ready for use.
        public let status: PolicyStatus
        /// Additional information about the policy status. This provides details about any failures or the current state of the policy creation process.
        public let statusReasons: [String]
        /// The timestamp when the policy was last updated. For newly created policies, this matches the createdAt timestamp.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, definition: PolicyDefinition, description: String? = nil, name: String, policyArn: String, policyEngineId: String, policyId: String, status: PolicyStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.definition = definition
            self.description = description
            self.name = name
            self.policyArn = policyArn
            self.policyEngineId = policyEngineId
            self.policyId = policyId
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case definition = "definition"
            case description = "description"
            case name = "name"
            case policyArn = "policyArn"
            case policyEngineId = "policyEngineId"
            case policyId = "policyId"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateWorkloadIdentityRequest: AWSEncodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The name of the workload identity. The name must be unique within your account.
        public let name: String
        /// A map of tag keys and values to assign to the workload identity. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
        public let tags: [String: String]?

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, name: String, tags: [String: String]? = nil) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.allowedResourceOauth2ReturnUrls?.forEach {
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, max: 2048)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, min: 1)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, pattern: "^\\w+:(\\/?\\/?)[^\\s]+$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateWorkloadIdentityResponse: AWSDecodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, name: String, workloadIdentityArn: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct CredentialProviderConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The credential provider. This field contains the specific configuration for the credential provider type.
        public let credentialProvider: CredentialProvider?
        /// The type of credential provider. This field specifies which authentication method the gateway uses.
        public let credentialProviderType: CredentialProviderType

        @inlinable
        public init(credentialProvider: CredentialProvider? = nil, credentialProviderType: CredentialProviderType) {
            self.credentialProvider = credentialProvider
            self.credentialProviderType = credentialProviderType
        }

        public func validate(name: String) throws {
            try self.credentialProvider?.validate(name: "\(name).credentialProvider")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProvider = "credentialProvider"
            case credentialProviderType = "credentialProviderType"
        }
    }

    public struct CustomClaimValidationType: AWSEncodableShape & AWSDecodableShape {
        /// Defines the value or values to match for and the relationship of the match.
        public let authorizingClaimMatchValue: AuthorizingClaimMatchValueType
        /// The name of the custom claim field to check.
        public let inboundTokenClaimName: String
        /// The data type of the claim value to check for.   Use STRING if you want to find an exact match to a string you define.   Use STRING_ARRAY if you want to fnd a match to at least one value in an array you define.
        public let inboundTokenClaimValueType: InboundTokenClaimValueType

        @inlinable
        public init(authorizingClaimMatchValue: AuthorizingClaimMatchValueType, inboundTokenClaimName: String, inboundTokenClaimValueType: InboundTokenClaimValueType) {
            self.authorizingClaimMatchValue = authorizingClaimMatchValue
            self.inboundTokenClaimName = inboundTokenClaimName
            self.inboundTokenClaimValueType = inboundTokenClaimValueType
        }

        public func validate(name: String) throws {
            try self.authorizingClaimMatchValue.validate(name: "\(name).authorizingClaimMatchValue")
            try self.validate(self.inboundTokenClaimName, name: "inboundTokenClaimName", parent: name, max: 255)
            try self.validate(self.inboundTokenClaimName, name: "inboundTokenClaimName", parent: name, min: 1)
            try self.validate(self.inboundTokenClaimName, name: "inboundTokenClaimName", parent: name, pattern: "^[A-Za-z0-9_.-:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizingClaimMatchValue = "authorizingClaimMatchValue"
            case inboundTokenClaimName = "inboundTokenClaimName"
            case inboundTokenClaimValueType = "inboundTokenClaimValueType"
        }
    }

    public struct CustomJWTAuthorizerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Represents individual audience values that are validated in the incoming JWT token validation process.
        public let allowedAudience: [String]?
        /// Represents individual client IDs that are validated in the incoming JWT token validation process.
        public let allowedClients: [String]?
        /// An array of scopes that are allowed to access the token.
        public let allowedScopes: [String]?
        /// An array of objects that define a custom claim validation name, value, and operation
        public let customClaims: [CustomClaimValidationType]?
        /// This URL is used to fetch OpenID Connect configuration or authorization server metadata for validating incoming tokens.
        public let discoveryUrl: String

        @inlinable
        public init(allowedAudience: [String]? = nil, allowedClients: [String]? = nil, allowedScopes: [String]? = nil, customClaims: [CustomClaimValidationType]? = nil, discoveryUrl: String) {
            self.allowedAudience = allowedAudience
            self.allowedClients = allowedClients
            self.allowedScopes = allowedScopes
            self.customClaims = customClaims
            self.discoveryUrl = discoveryUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.allowedAudience, name: "allowedAudience", parent: name, min: 1)
            try self.validate(self.allowedClients, name: "allowedClients", parent: name, min: 1)
            try self.allowedScopes?.forEach {
                try validate($0, name: "allowedScopes[]", parent: name, max: 255)
                try validate($0, name: "allowedScopes[]", parent: name, min: 1)
                try validate($0, name: "allowedScopes[]", parent: name, pattern: "^[\\x21\\x23-\\x5B\\x5D-\\x7E]+$")
            }
            try self.validate(self.allowedScopes, name: "allowedScopes", parent: name, min: 1)
            try self.customClaims?.forEach {
                try $0.validate(name: "\(name).customClaims[]")
            }
            try self.validate(self.customClaims, name: "customClaims", parent: name, min: 1)
            try self.validate(self.discoveryUrl, name: "discoveryUrl", parent: name, pattern: "^.+/\\.well-known/openid-configuration$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAudience = "allowedAudience"
            case allowedClients = "allowedClients"
            case allowedScopes = "allowedScopes"
            case customClaims = "customClaims"
            case discoveryUrl = "discoveryUrl"
        }
    }

    public struct CustomMemoryStrategyInput: AWSEncodableShape {
        /// The configuration for the custom memory strategy.
        public let configuration: CustomConfigurationInput?
        /// The description of the custom memory strategy.
        public let description: String?
        /// The name of the custom memory strategy.
        public let name: String
        /// The namespaces associated with the custom memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(configuration: CustomConfigurationInput? = nil, description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct CustomOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the custom OAuth2 provider.
        public let clientId: String
        /// The client secret for the custom OAuth2 provider.
        public let clientSecret: String
        /// The OAuth2 discovery information for the custom provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String, clientSecret: String, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oauthDiscovery = oauthDiscovery
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
            try self.oauthDiscovery.validate(name: "\(name).oauthDiscovery")
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct CustomOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the custom OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the custom provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct DeleteAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime associated with the endpoint.
        public let agentRuntimeId: String
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The name of the AgentCore Runtime endpoint to delete.
        public let endpointName: String

        @inlinable
        public init(agentRuntimeId: String, clientToken: String? = DeleteAgentRuntimeEndpointRequest.idempotencyToken(), endpointName: String) {
            self.agentRuntimeId = agentRuntimeId
            self.clientToken = clientToken
            self.endpointName = endpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.endpointName, key: "endpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The unique identifier of the AgentCore Runtime.
        public let agentRuntimeId: String?
        /// The name of the AgentCore Runtime endpoint.
        public let endpointName: String?
        /// The current status of the AgentCore Runtime endpoint deletion.
        public let status: AgentRuntimeEndpointStatus

        @inlinable
        public init(agentRuntimeId: String? = nil, endpointName: String? = nil, status: AgentRuntimeEndpointStatus) {
            self.agentRuntimeId = agentRuntimeId
            self.endpointName = endpointName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeId = "agentRuntimeId"
            case endpointName = "endpointName"
            case status = "status"
        }
    }

    public struct DeleteAgentRuntimeRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime to delete.
        public let agentRuntimeId: String
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, the service ignores the request but does not return an error.
        public let clientToken: String?

        @inlinable
        public init(agentRuntimeId: String, clientToken: String? = DeleteAgentRuntimeRequest.idempotencyToken()) {
            self.agentRuntimeId = agentRuntimeId
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.clientToken, key: "clientToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAgentRuntimeResponse: AWSDecodableShape {
        /// The unique identifier of the AgentCore Runtime.
        public let agentRuntimeId: String?
        /// The current status of the AgentCore Runtime deletion.
        public let status: AgentRuntimeStatus

        @inlinable
        public init(agentRuntimeId: String? = nil, status: AgentRuntimeStatus) {
            self.agentRuntimeId = agentRuntimeId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeId = "agentRuntimeId"
            case status = "status"
        }
    }

    public struct DeleteApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The name of the API key credential provider to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteApiKeyCredentialProviderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteBrowserRequest: AWSEncodableShape {
        /// The unique identifier of the browser to delete.
        public let browserId: String
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?

        @inlinable
        public init(browserId: String, clientToken: String? = DeleteBrowserRequest.idempotencyToken()) {
            self.browserId = browserId
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserId, key: "browserId")
            request.encodeQuery(self.clientToken, key: "clientToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserId, name: "browserId", parent: name, pattern: "^(aws\\.browser\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBrowserResponse: AWSDecodableShape {
        /// The unique identifier of the deleted browser.
        public let browserId: String
        /// The timestamp when the browser was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the browser deletion.
        public let status: BrowserStatus

        @inlinable
        public init(browserId: String, lastUpdatedAt: Date, status: BrowserStatus) {
            self.browserId = browserId
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserId = "browserId"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
        }
    }

    public struct DeleteCodeInterpreterRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the code interpreter to delete.
        public let codeInterpreterId: String

        @inlinable
        public init(clientToken: String? = DeleteCodeInterpreterRequest.idempotencyToken(), codeInterpreterId: String) {
            self.clientToken = clientToken
            self.codeInterpreterId = codeInterpreterId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.codeInterpreterId, key: "codeInterpreterId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.codeInterpreterId, name: "codeInterpreterId", parent: name, pattern: "^(aws\\.codeinterpreter\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCodeInterpreterResponse: AWSDecodableShape {
        /// The unique identifier of the deleted code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the code interpreter deletion.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterId: String, lastUpdatedAt: Date, status: CodeInterpreterStatus) {
            self.codeInterpreterId = codeInterpreterId
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterId = "codeInterpreterId"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
        }
    }

    public struct DeleteEvaluatorRequest: AWSEncodableShape {
        ///  The unique identifier of the evaluator to delete.
        public let evaluatorId: String

        @inlinable
        public init(evaluatorId: String) {
            self.evaluatorId = evaluatorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.evaluatorId, key: "evaluatorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluatorId, name: "evaluatorId", parent: name, pattern: "^(Builtin.[a-zA-Z0-9_-]+|[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEvaluatorResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the deleted evaluator.
        public let evaluatorArn: String
        ///  The unique identifier of the deleted evaluator.
        public let evaluatorId: String
        ///  The status of the evaluator deletion operation.
        public let status: EvaluatorStatus

        @inlinable
        public init(evaluatorArn: String, evaluatorId: String, status: EvaluatorStatus) {
            self.evaluatorArn = evaluatorArn
            self.evaluatorId = evaluatorId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case evaluatorArn = "evaluatorArn"
            case evaluatorId = "evaluatorId"
            case status = "status"
        }
    }

    public struct DeleteGatewayRequest: AWSEncodableShape {
        /// The identifier of the gateway to delete.
        public let gatewayIdentifier: String

        @inlinable
        public init(gatewayIdentifier: String) {
            self.gatewayIdentifier = gatewayIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGatewayResponse: AWSDecodableShape {
        /// The unique identifier of the deleted gateway.
        public let gatewayId: String
        /// The current status of the gateway deletion.
        public let status: GatewayStatus
        /// The reasons for the current status of the gateway deletion.
        public let statusReasons: [String]?

        @inlinable
        public init(gatewayId: String, status: GatewayStatus, statusReasons: [String]? = nil) {
            self.gatewayId = gatewayId
            self.status = status
            self.statusReasons = statusReasons
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayId = "gatewayId"
            case status = "status"
            case statusReasons = "statusReasons"
        }
    }

    public struct DeleteGatewayTargetRequest: AWSEncodableShape {
        /// The unique identifier of the gateway associated with the target.
        public let gatewayIdentifier: String
        /// The unique identifier of the gateway target to delete.
        public let targetId: String

        @inlinable
        public init(gatewayIdentifier: String, targetId: String) {
            self.gatewayIdentifier = gatewayIdentifier
            self.targetId = targetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            request.encodePath(self.targetId, key: "targetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.targetId, name: "targetId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGatewayTargetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the gateway.
        public let gatewayArn: String
        /// The current status of the gateway target deletion.
        public let status: TargetStatus
        /// The reasons for the current status of the gateway target deletion.
        public let statusReasons: [String]?
        /// The unique identifier of the deleted gateway target.
        public let targetId: String

        @inlinable
        public init(gatewayArn: String, status: TargetStatus, statusReasons: [String]? = nil, targetId: String) {
            self.gatewayArn = gatewayArn
            self.status = status
            self.statusReasons = statusReasons
            self.targetId = targetId
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayArn = "gatewayArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetId = "targetId"
        }
    }

    public struct DeleteMemoryInput: AWSEncodableShape {
        /// A client token is used for keeping track of idempotent requests. It can contain a session id which can be around 250 chars, combined with a unique AWS identifier.
        public let clientToken: String?
        /// The unique identifier of the memory to delete.
        public let memoryId: String

        @inlinable
        public init(clientToken: String? = DeleteMemoryInput.idempotencyToken(), memoryId: String) {
            self.clientToken = clientToken
            self.memoryId = memoryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.memoryId, key: "memoryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemoryOutput: AWSDecodableShape {
        /// The unique identifier of the deleted AgentCore Memory resource.
        public let memoryId: String
        /// The current status of the AgentCore Memory resource deletion.
        public let status: MemoryStatus?

        @inlinable
        public init(memoryId: String, status: MemoryStatus? = nil) {
            self.memoryId = memoryId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case memoryId = "memoryId"
            case status = "status"
        }
    }

    public struct DeleteMemoryStrategyInput: AWSEncodableShape {
        /// The unique identifier of the memory strategy to delete.
        public let memoryStrategyId: String

        @inlinable
        public init(memoryStrategyId: String) {
            self.memoryStrategyId = memoryStrategyId
        }

        private enum CodingKeys: String, CodingKey {
            case memoryStrategyId = "memoryStrategyId"
        }
    }

    public struct DeleteOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The name of the OAuth2 credential provider to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteOauth2CredentialProviderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOnlineEvaluationConfigRequest: AWSEncodableShape {
        ///  The unique identifier of the online evaluation configuration to delete.
        public let onlineEvaluationConfigId: String

        @inlinable
        public init(onlineEvaluationConfigId: String) {
            self.onlineEvaluationConfigId = onlineEvaluationConfigId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.onlineEvaluationConfigId, key: "onlineEvaluationConfigId")
        }

        public func validate(name: String) throws {
            try self.validate(self.onlineEvaluationConfigId, name: "onlineEvaluationConfigId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOnlineEvaluationConfigResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the deleted online evaluation configuration.
        public let onlineEvaluationConfigArn: String
        ///  The unique identifier of the deleted online evaluation configuration.
        public let onlineEvaluationConfigId: String
        ///  The status of the online evaluation configuration deletion operation.
        public let status: OnlineEvaluationConfigStatus

        @inlinable
        public init(onlineEvaluationConfigArn: String, onlineEvaluationConfigId: String, status: OnlineEvaluationConfigStatus) {
            self.onlineEvaluationConfigArn = onlineEvaluationConfigArn
            self.onlineEvaluationConfigId = onlineEvaluationConfigId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case onlineEvaluationConfigArn = "onlineEvaluationConfigArn"
            case onlineEvaluationConfigId = "onlineEvaluationConfigId"
            case status = "status"
        }
    }

    public struct DeletePolicyEngineRequest: AWSEncodableShape {
        /// The unique identifier of the policy engine to be deleted. This must be a valid policy engine ID that exists within the account.
        public let policyEngineId: String

        @inlinable
        public init(policyEngineId: String) {
            self.policyEngineId = policyEngineId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.policyEngineId, key: "policyEngineId")
        }

        public func validate(name: String) throws {
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePolicyEngineResponse: AWSDecodableShape {
        /// The timestamp when the deleted policy engine was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The human-readable description of the deleted policy engine.
        public let description: String?
        /// The customer-assigned name of the deleted policy engine.
        public let name: String
        /// The Amazon Resource Name (ARN) of the deleted policy engine. This globally unique identifier confirms which policy engine resource was successfully removed.
        public let policyEngineArn: String
        /// The unique identifier of the policy engine being deleted. This confirms which policy engine the deletion operation targets.
        public let policyEngineId: String
        /// The status of the policy engine deletion operation. This provides status about any issues that occurred during the deletion process.
        public let status: PolicyEngineStatus
        /// Additional information about the deletion status. This provides details about the deletion process or any issues that may have occurred.
        public let statusReasons: [String]
        /// The timestamp when the deleted policy engine was last modified before deletion. This tracks the final state of the policy engine before it was removed from the system.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, name: String, policyEngineArn: String, policyEngineId: String, status: PolicyEngineStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.policyEngineArn = policyEngineArn
            self.policyEngineId = policyEngineId
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case name = "name"
            case policyEngineArn = "policyEngineArn"
            case policyEngineId = "policyEngineId"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeletePolicyRequest: AWSEncodableShape {
        /// The identifier of the policy engine that manages the policy to be deleted. This ensures the policy is deleted from the correct policy engine context.
        public let policyEngineId: String
        /// The unique identifier of the policy to be deleted. This must be a valid policy ID that exists within the specified policy engine.
        public let policyId: String

        @inlinable
        public init(policyEngineId: String, policyId: String) {
            self.policyEngineId = policyEngineId
            self.policyId = policyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.policyEngineId, key: "policyEngineId")
            request.encodePath(self.policyId, key: "policyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
            try self.validate(self.policyId, name: "policyId", parent: name, max: 59)
            try self.validate(self.policyId, name: "policyId", parent: name, min: 12)
            try self.validate(self.policyId, name: "policyId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePolicyResponse: AWSDecodableShape {
        /// The timestamp when the deleted policy was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        public let definition: PolicyDefinition
        /// The human-readable description of the deleted policy.
        public let description: String?
        /// The customer-assigned name of the deleted policy. This confirms which policy was successfully removed from the system and matches the name that was originally assigned during policy creation.
        public let name: String
        /// The Amazon Resource Name (ARN) of the deleted policy. This globally unique identifier confirms which policy resource was successfully removed.
        public let policyArn: String
        /// The identifier of the policy engine from which the policy was deleted. This confirms the policy engine context for the deletion operation.
        public let policyEngineId: String
        /// The unique identifier of the policy being deleted. This confirms which policy the deletion operation targets.
        public let policyId: String
        /// The status of the policy deletion operation. This provides information about any issues that occurred during the deletion process.
        public let status: PolicyStatus
        /// Additional information about the deletion status. This provides details about the deletion process or any issues that may have occurred.
        public let statusReasons: [String]
        /// The timestamp when the deleted policy was last modified before deletion. This tracks the final state of the policy before it was removed from the system.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, definition: PolicyDefinition, description: String? = nil, name: String, policyArn: String, policyEngineId: String, policyId: String, status: PolicyStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.definition = definition
            self.description = description
            self.name = name
            self.policyArn = policyArn
            self.policyEngineId = policyEngineId
            self.policyId = policyId
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case definition = "definition"
            case description = "description"
            case name = "name"
            case policyArn = "policyArn"
            case policyEngineId = "policyEngineId"
            case policyId = "policyId"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which to delete the resource policy.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWorkloadIdentityRequest: AWSEncodableShape {
        /// The name of the workload identity to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteWorkloadIdentityResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EpisodicConsolidationOverride: AWSDecodableShape {
        /// The text appended to the prompt for the consolidation step of the episodic memory strategy.
        public let appendToPrompt: String
        /// The model ID used for the consolidation step of the episodic memory strategy.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct EpisodicExtractionOverride: AWSDecodableShape {
        /// The text appended to the prompt for the extraction step of the episodic memory strategy.
        public let appendToPrompt: String
        /// The model ID used for the extraction step of the episodic memory strategy.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct EpisodicMemoryStrategyInput: AWSEncodableShape {
        /// The description of the episodic memory strategy.
        public let description: String?
        /// The name of the episodic memory strategy.
        public let name: String
        /// The namespaces for which to create episodes.
        public let namespaces: [String]?
        /// The configuration for the reflections created with the episodic memory strategy.
        public let reflectionConfiguration: EpisodicReflectionConfigurationInput?

        @inlinable
        public init(description: String? = nil, name: String, namespaces: [String]? = nil, reflectionConfiguration: EpisodicReflectionConfigurationInput? = nil) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
            self.reflectionConfiguration = reflectionConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
            try self.reflectionConfiguration?.validate(name: "\(name).reflectionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
            case reflectionConfiguration = "reflectionConfiguration"
        }
    }

    public struct EpisodicOverrideConfigurationInput: AWSEncodableShape {
        /// Contains configurations for overriding the consolidation step of the episodic memory strategy.
        public let consolidation: EpisodicOverrideConsolidationConfigurationInput?
        /// Contains configurations for overriding the extraction step of the episodic memory strategy.
        public let extraction: EpisodicOverrideExtractionConfigurationInput?
        /// Contains configurations for overriding the reflection step of the episodic memory strategy.
        public let reflection: EpisodicOverrideReflectionConfigurationInput?

        @inlinable
        public init(consolidation: EpisodicOverrideConsolidationConfigurationInput? = nil, extraction: EpisodicOverrideExtractionConfigurationInput? = nil, reflection: EpisodicOverrideReflectionConfigurationInput? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
            self.reflection = reflection
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
            try self.extraction?.validate(name: "\(name).extraction")
            try self.reflection?.validate(name: "\(name).reflection")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
            case reflection = "reflection"
        }
    }

    public struct EpisodicOverrideConsolidationConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for the consolidation step of the episodic memory strategy.
        public let appendToPrompt: String
        /// The model ID to use for the consolidation step of the episodic memory strategy.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct EpisodicOverrideExtractionConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for the extraction step of the episodic memory strategy.
        public let appendToPrompt: String
        /// The model ID to use for the extraction step of the episodic memory strategy.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct EpisodicOverrideReflectionConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for reflection step of the episodic memory strategy.
        public let appendToPrompt: String
        /// The model ID to use for the reflection step of the episodic memory strategy.
        public let modelId: String
        /// The namespaces to use for episodic reflection. Can be less nested than the episodic namespaces.
        public let namespaces: [String]?

        @inlinable
        public init(appendToPrompt: String, modelId: String, namespaces: [String]? = nil) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
            case namespaces = "namespaces"
        }
    }

    public struct EpisodicReflectionConfiguration: AWSDecodableShape {
        /// The namespaces for which to create reflections. Can be less nested than the episodic namespaces.
        public let namespaces: [String]

        @inlinable
        public init(namespaces: [String]) {
            self.namespaces = namespaces
        }

        private enum CodingKeys: String, CodingKey {
            case namespaces = "namespaces"
        }
    }

    public struct EpisodicReflectionConfigurationInput: AWSEncodableShape {
        /// The namespaces over which to create reflections. Can be less nested than episode namespaces.
        public let namespaces: [String]

        @inlinable
        public init(namespaces: [String]) {
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.namespaces.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case namespaces = "namespaces"
        }
    }

    public struct EpisodicReflectionOverride: AWSDecodableShape {
        /// The text appended to the prompt for the reflection step of the episodic memory strategy.
        public let appendToPrompt: String
        /// The model ID used for the reflection step of the episodic memory strategy.
        public let modelId: String
        /// The namespaces over which reflections were created. Can be less nested than the episodic namespaces.
        public let namespaces: [String]?

        @inlinable
        public init(appendToPrompt: String, modelId: String, namespaces: [String]? = nil) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
            self.namespaces = namespaces
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
            case namespaces = "namespaces"
        }
    }

    public struct EvaluatorSummary: AWSDecodableShape {
        ///  The timestamp when the evaluator was created.
        public let createdAt: Date
        ///  The description of the evaluator.
        public let description: String?
        ///  The Amazon Resource Name (ARN) of the evaluator.
        public let evaluatorArn: String
        ///  The unique identifier of the evaluator.
        public let evaluatorId: String
        ///  The name of the evaluator.
        public let evaluatorName: String
        ///  The type of evaluator, indicating whether it is a built-in evaluator provided by the service or a custom evaluator created by the user.
        public let evaluatorType: EvaluatorType
        ///  The evaluation level (TOOL_CALL, TRACE, or SESSION) that determines the scope of evaluation.
        public let level: EvaluatorLevel?
        ///  Whether the evaluator is locked for modification due to being referenced by active online evaluation configurations.
        public let lockedForModification: Bool?
        ///  The current status of the evaluator.
        public let status: EvaluatorStatus
        ///  The timestamp when the evaluator was last updated.
        public let updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, evaluatorArn: String, evaluatorId: String, evaluatorName: String, evaluatorType: EvaluatorType, level: EvaluatorLevel? = nil, lockedForModification: Bool? = nil, status: EvaluatorStatus, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.evaluatorArn = evaluatorArn
            self.evaluatorId = evaluatorId
            self.evaluatorName = evaluatorName
            self.evaluatorType = evaluatorType
            self.level = level
            self.lockedForModification = lockedForModification
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case evaluatorArn = "evaluatorArn"
            case evaluatorId = "evaluatorId"
            case evaluatorName = "evaluatorName"
            case evaluatorType = "evaluatorType"
            case level = "level"
            case lockedForModification = "lockedForModification"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct Filter: AWSEncodableShape & AWSDecodableShape {
        ///  The key or field name to filter on within the agent trace data.
        public let key: String
        ///  The comparison operator to use for filtering.
        public let `operator`: FilterOperator
        ///  The value to compare against using the specified operator.
        public let value: FilterValue

        @inlinable
        public init(key: String, operator: FilterOperator, value: FilterValue) {
            self.key = key
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case `operator` = "operator"
            case value = "value"
        }
    }

    public struct Finding: AWSDecodableShape {
        /// A human-readable description of the finding. This provides detailed information about the issue, recommendation, or validation result to help users understand and address the finding.
        public let description: String?
        /// The type or category of the finding. This classifies the finding as an error, warning, recommendation, or informational message to help users understand the severity and nature of the issue.
        public let type: FindingType?

        @inlinable
        public init(description: String? = nil, type: FindingType? = nil) {
            self.description = description
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case type = "type"
        }
    }

    public struct GatewayApiKeyCredentialProvider: AWSEncodableShape & AWSDecodableShape {
        /// The location of the API key credential. This field specifies where in the request the API key should be placed.
        public let credentialLocation: ApiKeyCredentialLocation?
        /// The name of the credential parameter for the API key. This parameter name is used when sending the API key to the target endpoint.
        public let credentialParameterName: String?
        /// The prefix for the API key credential. This prefix is added to the API key when sending it to the target endpoint.
        public let credentialPrefix: String?
        /// The Amazon Resource Name (ARN) of the API key credential provider. This ARN identifies the provider in Amazon Web Services.
        public let providerArn: String

        @inlinable
        public init(credentialLocation: ApiKeyCredentialLocation? = nil, credentialParameterName: String? = nil, credentialPrefix: String? = nil, providerArn: String) {
            self.credentialLocation = credentialLocation
            self.credentialParameterName = credentialParameterName
            self.credentialPrefix = credentialPrefix
            self.providerArn = providerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialParameterName, name: "credentialParameterName", parent: name, max: 64)
            try self.validate(self.credentialParameterName, name: "credentialParameterName", parent: name, min: 1)
            try self.validate(self.credentialPrefix, name: "credentialPrefix", parent: name, max: 64)
            try self.validate(self.credentialPrefix, name: "credentialPrefix", parent: name, min: 1)
            try self.validate(self.providerArn, name: "providerArn", parent: name, pattern: "^arn:([^:]*):([^:]*):([^:]*):([0-9]{12})?:(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialLocation = "credentialLocation"
            case credentialParameterName = "credentialParameterName"
            case credentialPrefix = "credentialPrefix"
            case providerArn = "providerArn"
        }
    }

    public struct GatewayInterceptorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the input of the interceptor. This field specifies how the input to the interceptor is constructed
        public let inputConfiguration: InterceptorInputConfiguration?
        /// The supported points of interception. This field specifies which points during the gateway invocation to invoke the interceptor
        public let interceptionPoints: [GatewayInterceptionPoint]
        /// The infrastructure settings of an interceptor configuration. This structure defines how the interceptor can be invoked.
        public let interceptor: InterceptorConfiguration

        @inlinable
        public init(inputConfiguration: InterceptorInputConfiguration? = nil, interceptionPoints: [GatewayInterceptionPoint], interceptor: InterceptorConfiguration) {
            self.inputConfiguration = inputConfiguration
            self.interceptionPoints = interceptionPoints
            self.interceptor = interceptor
        }

        public func validate(name: String) throws {
            try self.validate(self.interceptionPoints, name: "interceptionPoints", parent: name, max: 2)
            try self.validate(self.interceptionPoints, name: "interceptionPoints", parent: name, min: 1)
            try self.interceptor.validate(name: "\(name).interceptor")
        }

        private enum CodingKeys: String, CodingKey {
            case inputConfiguration = "inputConfiguration"
            case interceptionPoints = "interceptionPoints"
            case interceptor = "interceptor"
        }
    }

    public struct GatewayPolicyEngineConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the policy engine. The policy engine contains Cedar policies that define fine-grained authorization rules specifying who can perform what actions on which resources as agents interact through the gateway.
        public let arn: String
        /// The enforcement mode for the policy engine. Valid values include:    LOG_ONLY - The policy engine evaluates each action against your policies and adds traces on whether tool calls would be allowed or denied, but does not enforce the decision. Use this mode to test and validate policies before enabling enforcement.    ENFORCE - The policy engine evaluates actions against your policies and enforces decisions by allowing or denying agent operations. Test and validate policies in LOG_ONLY mode before enabling enforcement to avoid unintended denials or adversely affecting production traffic.
        public let mode: GatewayPolicyEngineMode

        @inlinable
        public init(arn: String, mode: GatewayPolicyEngineMode) {
            self.arn = arn
            self.mode = mode
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 170)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:bedrock-agentcore:[a-z0-9-]+:[0-9]{12}:policy-engine\\/[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9_]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case mode = "mode"
        }
    }

    public struct GatewaySummary: AWSDecodableShape {
        /// The type of authorizer used by the gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the gateway.
        public let description: String?
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// The name of the gateway.
        public let name: String
        /// The protocol type used by the gateway.
        public let protocolType: GatewayProtocolType
        /// The current status of the gateway.
        public let status: GatewayStatus
        /// The timestamp when the gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, gatewayId: String, name: String, protocolType: GatewayProtocolType, status: GatewayStatus, updatedAt: Date) {
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.gatewayId = gatewayId
            self.name = name
            self.protocolType = protocolType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case gatewayId = "gatewayId"
            case name = "name"
            case protocolType = "protocolType"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GatewayTarget: AWSDecodableShape {
        /// The date and time at which the target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The provider configurations.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The description for the gateway target.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the gateway target.
        public let gatewayArn: String
        /// The last synchronization time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastSynchronizedAt: Date?
        /// The name of the gateway target.
        public let name: String
        /// The status of the gateway target.
        public let status: TargetStatus
        /// The status reasons for the target status.
        public let statusReasons: [String]?
        public let targetConfiguration: TargetConfiguration
        /// The target ID.
        public let targetId: String
        /// The date and time at which the target was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayArn: String, lastSynchronizedAt: Date? = nil, name: String, status: TargetStatus, statusReasons: [String]? = nil, targetConfiguration: TargetConfiguration, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayArn = gatewayArn
            self.lastSynchronizedAt = lastSynchronizedAt
            self.name = name
            self.status = status
            self.statusReasons = statusReasons
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case gatewayArn = "gatewayArn"
            case lastSynchronizedAt = "lastSynchronizedAt"
            case name = "name"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetConfiguration = "targetConfiguration"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime associated with the endpoint.
        public let agentRuntimeId: String
        /// The name of the AgentCore Runtime endpoint to retrieve.
        public let endpointName: String

        @inlinable
        public init(agentRuntimeId: String, endpointName: String) {
            self.agentRuntimeId = agentRuntimeId
            self.endpointName = endpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodePath(self.endpointName, key: "endpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The timestamp when the AgentCore Runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the AgentCore Runtime endpoint.
        public let description: String?
        /// The reason for failure if the AgentCore Runtime endpoint is in a failed state.
        public let failureReason: String?
        /// The unique identifier of the AgentCore Runtime endpoint.
        public let id: String
        /// The timestamp when the AgentCore Runtime endpoint was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The currently deployed version of the AgentCore Runtime on the endpoint.
        public let liveVersion: String?
        /// The name of the AgentCore Runtime endpoint.
        public let name: String
        /// The current status of the AgentCore Runtime endpoint.
        public let status: AgentRuntimeEndpointStatus
        /// The target version of the AgentCore Runtime for the endpoint.
        public let targetVersion: String?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, createdAt: Date, description: String? = nil, failureReason: String? = nil, id: String, lastUpdatedAt: Date, liveVersion: String? = nil, name: String, status: AgentRuntimeEndpointStatus, targetVersion: String? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.createdAt = createdAt
            self.description = description
            self.failureReason = failureReason
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.liveVersion = liveVersion
            self.name = name
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case createdAt = "createdAt"
            case description = "description"
            case failureReason = "failureReason"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case liveVersion = "liveVersion"
            case name = "name"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct GetAgentRuntimeRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime to retrieve.
        public let agentRuntimeId: String
        /// The version of the AgentCore Runtime to retrieve.
        public let agentRuntimeVersion: String?

        @inlinable
        public init(agentRuntimeId: String, agentRuntimeVersion: String? = nil) {
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.agentRuntimeVersion, key: "version")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, max: 5)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, min: 1)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, pattern: "^([1-9][0-9]{0,4})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentRuntimeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The artifact of the AgentCore Runtime.
        public let agentRuntimeArtifact: AgentRuntimeArtifact?
        /// The unique identifier of the AgentCore Runtime.
        public let agentRuntimeId: String
        /// The name of the AgentCore Runtime.
        public let agentRuntimeName: String
        /// The version of the AgentCore Runtime.
        public let agentRuntimeVersion: String
        /// The authorizer configuration for the AgentCore Runtime.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The timestamp when the AgentCore Runtime was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the AgentCore Runtime.
        public let description: String?
        /// Environment variables set in the AgentCore Runtime environment.
        public let environmentVariables: [String: String]?
        /// The reason for failure if the AgentCore Runtime is in a failed state.
        public let failureReason: String?
        /// The timestamp when the AgentCore Runtime was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The life cycle configuration for the AgentCore Runtime.
        public let lifecycleConfiguration: LifecycleConfiguration
        /// The network configuration for the AgentCore Runtime.
        public let networkConfiguration: NetworkConfiguration
        public let protocolConfiguration: ProtocolConfiguration?
        /// Configuration for HTTP request headers that will be passed through to the runtime.
        public let requestHeaderConfiguration: RequestHeaderConfiguration?
        /// The IAM role ARN that provides permissions for the AgentCore Runtime.
        public let roleArn: String
        /// The current status of the AgentCore Runtime.
        public let status: AgentRuntimeStatus
        /// The workload identity details for the AgentCore Runtime.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeArtifact: AgentRuntimeArtifact? = nil, agentRuntimeId: String, agentRuntimeName: String, agentRuntimeVersion: String, authorizerConfiguration: AuthorizerConfiguration? = nil, createdAt: Date, description: String? = nil, environmentVariables: [String: String]? = nil, failureReason: String? = nil, lastUpdatedAt: Date, lifecycleConfiguration: LifecycleConfiguration, networkConfiguration: NetworkConfiguration, protocolConfiguration: ProtocolConfiguration? = nil, requestHeaderConfiguration: RequestHeaderConfiguration? = nil, roleArn: String, status: AgentRuntimeStatus, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeArtifact = agentRuntimeArtifact
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeName = agentRuntimeName
            self.agentRuntimeVersion = agentRuntimeVersion
            self.authorizerConfiguration = authorizerConfiguration
            self.createdAt = createdAt
            self.description = description
            self.environmentVariables = environmentVariables
            self.failureReason = failureReason
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleConfiguration = lifecycleConfiguration
            self.networkConfiguration = networkConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.requestHeaderConfiguration = requestHeaderConfiguration
            self.roleArn = roleArn
            self.status = status
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeArtifact = "agentRuntimeArtifact"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeName = "agentRuntimeName"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case authorizerConfiguration = "authorizerConfiguration"
            case createdAt = "createdAt"
            case description = "description"
            case environmentVariables = "environmentVariables"
            case failureReason = "failureReason"
            case lastUpdatedAt = "lastUpdatedAt"
            case lifecycleConfiguration = "lifecycleConfiguration"
            case networkConfiguration = "networkConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case requestHeaderConfiguration = "requestHeaderConfiguration"
            case roleArn = "roleArn"
            case status = "status"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct GetApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The name of the API key credential provider to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetApiKeyCredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the API key secret in AWS Secrets Manager.
        public let apiKeySecretArn: Secret
        /// The timestamp when the API key credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the API key credential provider.
        public let credentialProviderArn: String
        /// The timestamp when the API key credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the API key credential provider.
        public let name: String

        @inlinable
        public init(apiKeySecretArn: Secret, createdTime: Date, credentialProviderArn: String, lastUpdatedTime: Date, name: String) {
            self.apiKeySecretArn = apiKeySecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySecretArn = "apiKeySecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct GetBrowserRequest: AWSEncodableShape {
        /// The unique identifier of the browser to retrieve.
        public let browserId: String

        @inlinable
        public init(browserId: String) {
            self.browserId = browserId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserId, key: "browserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserId, name: "browserId", parent: name, pattern: "^(aws\\.browser\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBrowserResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the browser.
        public let browserArn: String
        /// The unique identifier of the browser.
        public let browserId: String
        /// The browser signing configuration that shows whether cryptographic agent identification is enabled for web bot authentication.
        public let browserSigning: BrowserSigningConfigOutput?
        /// The timestamp when the browser was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the browser.
        public let description: String?
        /// The IAM role ARN that provides permissions for the browser.
        public let executionRoleArn: String?
        /// The reason for failure if the browser is in a failed state.
        public let failureReason: String?
        /// The timestamp when the browser was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The name of the browser.
        public let name: String
        public let networkConfiguration: BrowserNetworkConfiguration
        public let recording: RecordingConfig?
        /// The current status of the browser.
        public let status: BrowserStatus

        @inlinable
        public init(browserArn: String, browserId: String, browserSigning: BrowserSigningConfigOutput? = nil, createdAt: Date, description: String? = nil, executionRoleArn: String? = nil, failureReason: String? = nil, lastUpdatedAt: Date, name: String, networkConfiguration: BrowserNetworkConfiguration, recording: RecordingConfig? = nil, status: BrowserStatus) {
            self.browserArn = browserArn
            self.browserId = browserId
            self.browserSigning = browserSigning
            self.createdAt = createdAt
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.failureReason = failureReason
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.recording = recording
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserArn = "browserArn"
            case browserId = "browserId"
            case browserSigning = "browserSigning"
            case createdAt = "createdAt"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case failureReason = "failureReason"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
            case recording = "recording"
            case status = "status"
        }
    }

    public struct GetCodeInterpreterRequest: AWSEncodableShape {
        /// The unique identifier of the code interpreter to retrieve.
        public let codeInterpreterId: String

        @inlinable
        public init(codeInterpreterId: String) {
            self.codeInterpreterId = codeInterpreterId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.codeInterpreterId, key: "codeInterpreterId")
        }

        public func validate(name: String) throws {
            try self.validate(self.codeInterpreterId, name: "codeInterpreterId", parent: name, pattern: "^(aws\\.codeinterpreter\\.v1|[a-zA-Z][a-zA-Z0-9_]{0,47}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodeInterpreterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the code interpreter.
        public let codeInterpreterArn: String
        /// The unique identifier of the code interpreter.
        public let codeInterpreterId: String
        /// The timestamp when the code interpreter was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the code interpreter.
        public let description: String?
        /// The IAM role ARN that provides permissions for the code interpreter.
        public let executionRoleArn: String?
        /// The reason for failure if the code interpreter is in a failed state.
        public let failureReason: String?
        /// The timestamp when the code interpreter was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The name of the code interpreter.
        public let name: String
        public let networkConfiguration: CodeInterpreterNetworkConfiguration
        /// The current status of the code interpreter.
        public let status: CodeInterpreterStatus

        @inlinable
        public init(codeInterpreterArn: String, codeInterpreterId: String, createdAt: Date, description: String? = nil, executionRoleArn: String? = nil, failureReason: String? = nil, lastUpdatedAt: Date, name: String, networkConfiguration: CodeInterpreterNetworkConfiguration, status: CodeInterpreterStatus) {
            self.codeInterpreterArn = codeInterpreterArn
            self.codeInterpreterId = codeInterpreterId
            self.createdAt = createdAt
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.failureReason = failureReason
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterArn = "codeInterpreterArn"
            case codeInterpreterId = "codeInterpreterId"
            case createdAt = "createdAt"
            case description = "description"
            case executionRoleArn = "executionRoleArn"
            case failureReason = "failureReason"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case networkConfiguration = "networkConfiguration"
            case status = "status"
        }
    }

    public struct GetEvaluatorRequest: AWSEncodableShape {
        ///  The unique identifier of the evaluator to retrieve. Can be a built-in evaluator ID (e.g., Builtin.Helpfulness) or a custom evaluator ID.
        public let evaluatorId: String

        @inlinable
        public init(evaluatorId: String) {
            self.evaluatorId = evaluatorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.evaluatorId, key: "evaluatorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluatorId, name: "evaluatorId", parent: name, pattern: "^(Builtin.[a-zA-Z0-9_-]+|[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvaluatorResponse: AWSDecodableShape {
        ///  The timestamp when the evaluator was created.
        public let createdAt: Date
        ///  The description of the evaluator.
        public let description: String?
        ///  The Amazon Resource Name (ARN) of the evaluator.
        public let evaluatorArn: String
        ///  The configuration of the evaluator, including LLM-as-a-Judge settings for custom evaluators.
        public let evaluatorConfig: EvaluatorConfig
        ///  The unique identifier of the evaluator.
        public let evaluatorId: String
        ///  The name of the evaluator.
        public let evaluatorName: String
        ///  The evaluation level (TOOL_CALL, TRACE, or SESSION) that determines the scope of evaluation.
        public let level: EvaluatorLevel
        ///  Whether the evaluator is locked for modification due to being referenced by active online evaluation configurations.
        public let lockedForModification: Bool?
        ///  The current status of the evaluator.
        public let status: EvaluatorStatus
        ///  The timestamp when the evaluator was last updated.
        public let updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, evaluatorArn: String, evaluatorConfig: EvaluatorConfig, evaluatorId: String, evaluatorName: String, level: EvaluatorLevel, lockedForModification: Bool? = nil, status: EvaluatorStatus, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.evaluatorArn = evaluatorArn
            self.evaluatorConfig = evaluatorConfig
            self.evaluatorId = evaluatorId
            self.evaluatorName = evaluatorName
            self.level = level
            self.lockedForModification = lockedForModification
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case evaluatorArn = "evaluatorArn"
            case evaluatorConfig = "evaluatorConfig"
            case evaluatorId = "evaluatorId"
            case evaluatorName = "evaluatorName"
            case level = "level"
            case lockedForModification = "lockedForModification"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetGatewayRequest: AWSEncodableShape {
        /// The identifier of the gateway to retrieve.
        public let gatewayIdentifier: String

        @inlinable
        public init(gatewayIdentifier: String) {
            self.gatewayIdentifier = gatewayIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGatewayResponse: AWSDecodableShape {
        /// The authorizer configuration for the gateway.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// Authorizer type for the gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the gateway.
        public let description: String?
        /// The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
        public let exceptionLevel: ExceptionLevel?
        /// The Amazon Resource Name (ARN) of the gateway.
        public let gatewayArn: String
        /// The unique identifier of the gateway.
        public let gatewayId: String
        /// An endpoint for invoking gateway.
        public let gatewayUrl: String?
        /// The interceptors configured on the gateway.
        public let interceptorConfigurations: [GatewayInterceptorConfiguration]?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway.
        public let name: String
        /// The policy engine configuration for the gateway.
        public let policyEngineConfiguration: GatewayPolicyEngineConfiguration?
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// Protocol applied to a gateway.
        public let protocolType: GatewayProtocolType
        /// The IAM role ARN that provides permissions for the gateway.
        public let roleArn: String?
        /// The current status of the gateway.
        public let status: GatewayStatus
        /// The reasons for the current status of the gateway.
        public let statusReasons: [String]?
        /// The timestamp when the gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The workload identity details for the gateway.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayArn: String, gatewayId: String, gatewayUrl: String? = nil, interceptorConfigurations: [GatewayInterceptorConfiguration]? = nil, kmsKeyArn: String? = nil, name: String, policyEngineConfiguration: GatewayPolicyEngineConfiguration? = nil, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String? = nil, status: GatewayStatus, statusReasons: [String]? = nil, updatedAt: Date, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
            self.gatewayUrl = gatewayUrl
            self.interceptorConfigurations = interceptorConfigurations
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.policyEngineConfiguration = policyEngineConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
            case gatewayUrl = "gatewayUrl"
            case interceptorConfigurations = "interceptorConfigurations"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case policyEngineConfiguration = "policyEngineConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct GetGatewayTargetRequest: AWSEncodableShape {
        /// The identifier of the gateway that contains the target.
        public let gatewayIdentifier: String
        /// The unique identifier of the target to retrieve.
        public let targetId: String

        @inlinable
        public init(gatewayIdentifier: String, targetId: String) {
            self.gatewayIdentifier = gatewayIdentifier
            self.targetId = targetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            request.encodePath(self.targetId, key: "targetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.targetId, name: "targetId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGatewayTargetResponse: AWSDecodableShape {
        /// The timestamp when the gateway target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The credential provider configurations for the gateway target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The description of the gateway target.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the gateway.
        public let gatewayArn: String
        /// The last synchronization of the target.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastSynchronizedAt: Date?
        /// The name of the gateway target.
        public let name: String
        /// The current status of the gateway target.
        public let status: TargetStatus
        /// The reasons for the current status of the gateway target.
        public let statusReasons: [String]?
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the gateway target.
        public let targetId: String
        /// The timestamp when the gateway target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayArn: String, lastSynchronizedAt: Date? = nil, name: String, status: TargetStatus, statusReasons: [String]? = nil, targetConfiguration: TargetConfiguration, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayArn = gatewayArn
            self.lastSynchronizedAt = lastSynchronizedAt
            self.name = name
            self.status = status
            self.statusReasons = statusReasons
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case gatewayArn = "gatewayArn"
            case lastSynchronizedAt = "lastSynchronizedAt"
            case name = "name"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetConfiguration = "targetConfiguration"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetMemoryInput: AWSEncodableShape {
        /// The unique identifier of the memory to retrieve.
        public let memoryId: String

        @inlinable
        public init(memoryId: String) {
            self.memoryId = memoryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.memoryId, key: "memoryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMemoryOutput: AWSDecodableShape {
        /// The retrieved AgentCore Memory resource details.
        public let memory: Memory

        @inlinable
        public init(memory: Memory) {
            self.memory = memory
        }

        private enum CodingKeys: String, CodingKey {
            case memory = "memory"
        }
    }

    public struct GetOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The name of the OAuth2 credential provider to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetOauth2CredentialProviderResponse: AWSDecodableShape {
        /// Callback URL to register on the OAuth2 credential provider as an allowed callback URL. This URL is where the OAuth2 authorization server redirects users after they complete the authorization flow.
        public let callbackUrl: String?
        /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
        public let clientSecretArn: Secret
        /// The timestamp when the OAuth2 credential provider was created.
        public let createdTime: Date
        /// ARN of the credential provider requested.
        public let credentialProviderArn: String
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The timestamp when the OAuth2 credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the OAuth2 credential provider.
        public let name: String
        /// The configuration output for the OAuth2 provider.
        public let oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput

        @inlinable
        public init(callbackUrl: String? = nil, clientSecretArn: Secret, createdTime: Date, credentialProviderArn: String, credentialProviderVendor: CredentialProviderVendorType, lastUpdatedTime: Date, name: String, oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput) {
            self.callbackUrl = callbackUrl
            self.clientSecretArn = clientSecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.credentialProviderVendor = credentialProviderVendor
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.oauth2ProviderConfigOutput = oauth2ProviderConfigOutput
        }

        private enum CodingKeys: String, CodingKey {
            case callbackUrl = "callbackUrl"
            case clientSecretArn = "clientSecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case credentialProviderVendor = "credentialProviderVendor"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case oauth2ProviderConfigOutput = "oauth2ProviderConfigOutput"
        }
    }

    public struct GetOnlineEvaluationConfigRequest: AWSEncodableShape {
        ///  The unique identifier of the online evaluation configuration to retrieve.
        public let onlineEvaluationConfigId: String

        @inlinable
        public init(onlineEvaluationConfigId: String) {
            self.onlineEvaluationConfigId = onlineEvaluationConfigId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.onlineEvaluationConfigId, key: "onlineEvaluationConfigId")
        }

        public func validate(name: String) throws {
            try self.validate(self.onlineEvaluationConfigId, name: "onlineEvaluationConfigId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOnlineEvaluationConfigResponse: AWSDecodableShape {
        ///  The timestamp when the online evaluation configuration was created.
        public let createdAt: Date
        ///  The data source configuration specifying CloudWatch log groups and service names to monitor.
        public let dataSourceConfig: DataSourceConfig
        ///  The description of the online evaluation configuration.
        public let description: String?
        ///  The Amazon Resource Name (ARN) of the IAM role used for evaluation execution.
        public let evaluationExecutionRoleArn: String?
        ///  The list of evaluators applied during online evaluation.
        public let evaluators: [EvaluatorReference]
        ///  The execution status indicating whether the online evaluation is currently running.
        public let executionStatus: OnlineEvaluationExecutionStatus
        ///  The reason for failure if the online evaluation configuration execution failed.
        public let failureReason: String?
        ///  The Amazon Resource Name (ARN) of the online evaluation configuration.
        public let onlineEvaluationConfigArn: String
        ///  The unique identifier of the online evaluation configuration.
        public let onlineEvaluationConfigId: String
        ///  The name of the online evaluation configuration.
        public let onlineEvaluationConfigName: String
        ///  The output configuration specifying where evaluation results are written.
        public let outputConfig: OutputConfig?
        ///  The evaluation rule containing sampling configuration, filters, and session settings.
        public let rule: Rule
        ///  The status of the online evaluation configuration.
        public let status: OnlineEvaluationConfigStatus
        ///  The timestamp when the online evaluation configuration was last updated.
        public let updatedAt: Date

        @inlinable
        public init(createdAt: Date, dataSourceConfig: DataSourceConfig, description: String? = nil, evaluationExecutionRoleArn: String? = nil, evaluators: [EvaluatorReference], executionStatus: OnlineEvaluationExecutionStatus, failureReason: String? = nil, onlineEvaluationConfigArn: String, onlineEvaluationConfigId: String, onlineEvaluationConfigName: String, outputConfig: OutputConfig? = nil, rule: Rule, status: OnlineEvaluationConfigStatus, updatedAt: Date) {
            self.createdAt = createdAt
            self.dataSourceConfig = dataSourceConfig
            self.description = description
            self.evaluationExecutionRoleArn = evaluationExecutionRoleArn
            self.evaluators = evaluators
            self.executionStatus = executionStatus
            self.failureReason = failureReason
            self.onlineEvaluationConfigArn = onlineEvaluationConfigArn
            self.onlineEvaluationConfigId = onlineEvaluationConfigId
            self.onlineEvaluationConfigName = onlineEvaluationConfigName
            self.outputConfig = outputConfig
            self.rule = rule
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSourceConfig = "dataSourceConfig"
            case description = "description"
            case evaluationExecutionRoleArn = "evaluationExecutionRoleArn"
            case evaluators = "evaluators"
            case executionStatus = "executionStatus"
            case failureReason = "failureReason"
            case onlineEvaluationConfigArn = "onlineEvaluationConfigArn"
            case onlineEvaluationConfigId = "onlineEvaluationConfigId"
            case onlineEvaluationConfigName = "onlineEvaluationConfigName"
            case outputConfig = "outputConfig"
            case rule = "rule"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetPolicyEngineRequest: AWSEncodableShape {
        /// The unique identifier of the policy engine to be retrieved. This must be a valid policy engine ID that exists within the account.
        public let policyEngineId: String

        @inlinable
        public init(policyEngineId: String) {
            self.policyEngineId = policyEngineId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.policyEngineId, key: "policyEngineId")
        }

        public func validate(name: String) throws {
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPolicyEngineResponse: AWSDecodableShape {
        /// The timestamp when the policy engine was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The human-readable description of the policy engine's purpose and scope. This helps administrators understand the policy engine's role in governance.
        public let description: String?
        /// The customer-assigned name of the policy engine. This is the human-readable identifier that was specified when the policy engine was created.
        public let name: String
        /// The Amazon Resource Name (ARN) of the policy engine. This globally unique identifier can be used for cross-service references and IAM policy statements.
        public let policyEngineArn: String
        /// The unique identifier of the retrieved policy engine. This matches the policy engine ID provided in the request and serves as the system identifier.
        public let policyEngineId: String
        /// The current status of the policy engine.
        public let status: PolicyEngineStatus
        /// Additional information about the policy engine status. This provides details about any failures or the current state of the policy engine.
        public let statusReasons: [String]
        /// The timestamp when the policy engine was last modified. This tracks the most recent changes to the policy engine configuration.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, name: String, policyEngineArn: String, policyEngineId: String, status: PolicyEngineStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.policyEngineArn = policyEngineArn
            self.policyEngineId = policyEngineId
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case name = "name"
            case policyEngineArn = "policyEngineArn"
            case policyEngineId = "policyEngineId"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetPolicyGenerationRequest: AWSEncodableShape {
        /// The identifier of the policy engine associated with the policy generation request. This provides the context for the generation operation and schema validation.
        public let policyEngineId: String
        /// The unique identifier of the policy generation request to be retrieved. This must be a valid generation ID from a previous StartPolicyGeneration call.
        public let policyGenerationId: String

        @inlinable
        public init(policyEngineId: String, policyGenerationId: String) {
            self.policyEngineId = policyEngineId
            self.policyGenerationId = policyGenerationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.policyEngineId, key: "policyEngineId")
            request.encodePath(self.policyGenerationId, key: "policyGenerationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
            try self.validate(self.policyGenerationId, name: "policyGenerationId", parent: name, max: 59)
            try self.validate(self.policyGenerationId, name: "policyGenerationId", parent: name, min: 12)
            try self.validate(self.policyGenerationId, name: "policyGenerationId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPolicyGenerationResponse: AWSDecodableShape {
        /// The timestamp when the policy generation request was created. This is used for tracking and auditing generation operations and their lifecycle.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The findings and results from the policy generation process. This includes any issues, recommendations, validation results, or insights from the generated policies.
        public let findings: String?
        /// The customer-assigned name for the policy generation request. This helps identify and track generation operations across multiple requests.
        public let name: String
        /// The identifier of the policy engine associated with this policy generation. This confirms the policy engine context for the generation operation.
        public let policyEngineId: String
        /// The Amazon Resource Name (ARN) of the policy generation. This globally unique identifier can be used for tracking, auditing, and cross-service references.
        public let policyGenerationArn: String
        /// The unique identifier of the policy generation request. This matches the generation ID provided in the request and serves as the tracking identifier.
        public let policyGenerationId: String
        /// The resource information associated with the policy generation. This provides context about the target resources for which the policies are being generated.
        public let resource: Resource
        /// The current status of the policy generation. This indicates whether the generation is in progress, completed successfully, or failed during processing.
        public let status: PolicyGenerationStatus
        /// Additional information about the generation status. This provides details about any failures, warnings, or the current state of the generation process.
        public let statusReasons: [String]
        /// The timestamp when the policy generation was last updated. This tracks the progress of the generation process and any status changes.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, findings: String? = nil, name: String, policyEngineId: String, policyGenerationArn: String, policyGenerationId: String, resource: Resource, status: PolicyGenerationStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.findings = findings
            self.name = name
            self.policyEngineId = policyEngineId
            self.policyGenerationArn = policyGenerationArn
            self.policyGenerationId = policyGenerationId
            self.resource = resource
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case findings = "findings"
            case name = "name"
            case policyEngineId = "policyEngineId"
            case policyGenerationArn = "policyGenerationArn"
            case policyGenerationId = "policyGenerationId"
            case resource = "resource"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetPolicyRequest: AWSEncodableShape {
        /// The identifier of the policy engine that manages the policy to be retrieved.
        public let policyEngineId: String
        /// The unique identifier of the policy to be retrieved. This must be a valid policy ID that exists within the specified policy engine.
        public let policyId: String

        @inlinable
        public init(policyEngineId: String, policyId: String) {
            self.policyEngineId = policyEngineId
            self.policyId = policyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.policyEngineId, key: "policyEngineId")
            request.encodePath(self.policyId, key: "policyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
            try self.validate(self.policyId, name: "policyId", parent: name, max: 59)
            try self.validate(self.policyId, name: "policyId", parent: name, min: 12)
            try self.validate(self.policyId, name: "policyId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPolicyResponse: AWSDecodableShape {
        /// The timestamp when the policy was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Cedar policy statement that defines the access control rules. This contains the actual policy logic used for agent behavior control and access decisions.
        public let definition: PolicyDefinition
        /// The human-readable description of the policy's purpose and functionality. This helps administrators understand and manage the policy.
        public let description: String?
        /// The customer-assigned name of the policy. This is the human-readable identifier that was specified when the policy was created.
        public let name: String
        /// The Amazon Resource Name (ARN) of the policy. This globally unique identifier can be used for cross-service references and IAM policy statements.
        public let policyArn: String
        /// The identifier of the policy engine that manages this policy. This confirms the policy engine context for the retrieved policy.
        public let policyEngineId: String
        /// The unique identifier of the retrieved policy. This matches the policy ID provided in the request and serves as the system identifier for the policy.
        public let policyId: String
        /// The current status of the policy.
        public let status: PolicyStatus
        /// Additional information about the policy status. This provides details about any failures or the current state of the policy.
        public let statusReasons: [String]
        /// The timestamp when the policy was last modified. This tracks the most recent changes to the policy configuration.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, definition: PolicyDefinition, description: String? = nil, name: String, policyArn: String, policyEngineId: String, policyId: String, status: PolicyStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.definition = definition
            self.description = description
            self.name = name
            self.policyArn = policyArn
            self.policyEngineId = policyEngineId
            self.policyId = policyId
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case definition = "definition"
            case description = "description"
            case name = "name"
            case policyArn = "policyArn"
            case policyEngineId = "policyEngineId"
            case policyId = "policyId"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which to retrieve the resource policy.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// The resource policy associated with the specified resource.
        public let policy: String?

        @inlinable
        public init(policy: String? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct GetTokenVaultRequest: AWSEncodableShape {
        /// The unique identifier of the token vault to retrieve.
        public let tokenVaultId: String?

        @inlinable
        public init(tokenVaultId: String? = nil) {
            self.tokenVaultId = tokenVaultId
        }

        public func validate(name: String) throws {
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, max: 64)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, min: 1)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct GetTokenVaultResponse: AWSDecodableShape {
        /// The KMS configuration for the token vault.
        public let kmsConfiguration: KmsConfiguration
        /// The timestamp when the token vault was last modified.
        public let lastModifiedDate: Date
        /// The ID of the token vault.
        public let tokenVaultId: String

        @inlinable
        public init(kmsConfiguration: KmsConfiguration, lastModifiedDate: Date, tokenVaultId: String) {
            self.kmsConfiguration = kmsConfiguration
            self.lastModifiedDate = lastModifiedDate
            self.tokenVaultId = tokenVaultId
        }

        private enum CodingKeys: String, CodingKey {
            case kmsConfiguration = "kmsConfiguration"
            case lastModifiedDate = "lastModifiedDate"
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct GetWorkloadIdentityRequest: AWSEncodableShape {
        /// The name of the workload identity to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetWorkloadIdentityResponse: AWSDecodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The timestamp when the workload identity was created.
        public let createdTime: Date
        /// The timestamp when the workload identity was last updated.
        public let lastUpdatedTime: Date
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, createdTime: Date, lastUpdatedTime: Date, name: String, workloadIdentityArn: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case createdTime = "createdTime"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct GithubOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the GitHub OAuth2 provider.
        public let clientId: String
        /// The client secret for the GitHub OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct GithubOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the GitHub OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the GitHub provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct GoogleOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Google OAuth2 provider.
        public let clientId: String
        /// The client secret for the Google OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct GoogleOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the Google OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the Google provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct IncludedOauth2ProviderConfigInput: AWSEncodableShape {
        /// OAuth2 authorization endpoint for your isolated OAuth2 application tenant. This is where users are redirected to authenticate and authorize access to their resources.
        public let authorizationEndpoint: String?
        /// The client ID for the supported OAuth2 provider. This identifier is assigned by the OAuth2 provider when you register your application.
        public let clientId: String
        /// The client secret for the supported OAuth2 provider. This secret is assigned by the OAuth2 provider and used along with the client ID to authenticate your application.
        public let clientSecret: String
        /// Token issuer of your isolated OAuth2 application tenant. This URL identifies the authorization server that issues tokens for this provider.
        public let issuer: String?
        /// OAuth2 token endpoint for your isolated OAuth2 application tenant. This is where authorization codes are exchanged for access tokens.
        public let tokenEndpoint: String?

        @inlinable
        public init(authorizationEndpoint: String? = nil, clientId: String, clientSecret: String, issuer: String? = nil, tokenEndpoint: String? = nil) {
            self.authorizationEndpoint = authorizationEndpoint
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.issuer = issuer
            self.tokenEndpoint = tokenEndpoint
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationEndpoint = "authorizationEndpoint"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case issuer = "issuer"
            case tokenEndpoint = "tokenEndpoint"
        }
    }

    public struct IncludedOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the supported OAuth2 provider.
        public let clientId: String?
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct InferenceConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum number of tokens to generate in the model response during evaluation.
        public let maxTokens: Int?
        ///  The list of sequences that will cause the model to stop generating tokens when encountered.
        public let stopSequences: [String]?
        ///  The temperature value that controls randomness in the model's responses. Lower values produce more deterministic outputs.
        public let temperature: Float?
        ///  The top-p sampling parameter that controls the diversity of the model's responses by limiting the cumulative probability of token choices.
        public let topP: Float?

        @inlinable
        public init(maxTokens: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topP: Float? = nil) {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topP = topP
        }

        public func validate(name: String) throws {
            try self.stopSequences?.forEach {
                try validate($0, name: "stopSequences[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topP = "topP"
        }
    }

    public struct InterceptorInputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether to pass request headers as input into the interceptor. When set to true, request headers will be passed.
        public let passRequestHeaders: Bool

        @inlinable
        public init(passRequestHeaders: Bool) {
            self.passRequestHeaders = passRequestHeaders
        }

        private enum CodingKeys: String, CodingKey {
            case passRequestHeaders = "passRequestHeaders"
        }
    }

    public struct InvocationConfiguration: AWSDecodableShape {
        /// The S3 bucket name for event payload delivery.
        public let payloadDeliveryBucketName: String
        /// The ARN of the SNS topic for job notifications.
        public let topicArn: String

        @inlinable
        public init(payloadDeliveryBucketName: String, topicArn: String) {
            self.payloadDeliveryBucketName = payloadDeliveryBucketName
            self.topicArn = topicArn
        }

        private enum CodingKeys: String, CodingKey {
            case payloadDeliveryBucketName = "payloadDeliveryBucketName"
            case topicArn = "topicArn"
        }
    }

    public struct InvocationConfigurationInput: AWSEncodableShape {
        /// The S3 bucket name for event payload delivery.
        public let payloadDeliveryBucketName: String
        /// The ARN of the SNS topic for job notifications.
        public let topicArn: String

        @inlinable
        public init(payloadDeliveryBucketName: String, topicArn: String) {
            self.payloadDeliveryBucketName = payloadDeliveryBucketName
            self.topicArn = topicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.topicArn, name: "topicArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case payloadDeliveryBucketName = "payloadDeliveryBucketName"
            case topicArn = "topicArn"
        }
    }

    public struct KmsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of KMS key (CustomerManagedKey or ServiceManagedKey).
        public let keyType: KeyType
        /// The Amazon Resource Name (ARN) of the KMS key.
        public let kmsKeyArn: String?

        @inlinable
        public init(keyType: KeyType, kmsKeyArn: String? = nil) {
            self.keyType = keyType
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case keyType = "keyType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct LambdaInterceptorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The arn of the lambda function to be invoked for the interceptor.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 170)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:([a-z]{2}(-gov)?-[a-z]+-\\d{1}):(\\d{12}):function:([a-zA-Z0-9-_.]+)(:(\\$LATEST|[a-zA-Z0-9-]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct LifecycleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Timeout in seconds for idle runtime sessions. When a session remains idle for this duration, it will be automatically terminated. Default: 900 seconds (15 minutes).
        public let idleRuntimeSessionTimeout: Int?
        /// Maximum lifetime for the instance in seconds. Once reached, instances will be automatically terminated and replaced. Default: 28800 seconds (8 hours).
        public let maxLifetime: Int?

        @inlinable
        public init(idleRuntimeSessionTimeout: Int? = nil, maxLifetime: Int? = nil) {
            self.idleRuntimeSessionTimeout = idleRuntimeSessionTimeout
            self.maxLifetime = maxLifetime
        }

        private enum CodingKeys: String, CodingKey {
            case idleRuntimeSessionTimeout = "idleRuntimeSessionTimeout"
            case maxLifetime = "maxLifetime"
        }
    }

    public struct LinkedinOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the LinkedIn OAuth2 provider. This identifier is assigned by LinkedIn when you register your application.
        public let clientId: String
        /// The client secret for the LinkedIn OAuth2 provider. This secret is assigned by LinkedIn and used along with the client ID to authenticate your application.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct LinkedinOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the LinkedIn OAuth2 provider.
        public let clientId: String?
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct ListAgentRuntimeEndpointsRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime to list endpoints for.
        public let agentRuntimeId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimeId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentRuntimeId = agentRuntimeId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAgentRuntimeEndpointsResponse: AWSDecodableShape {
        /// A token to retrieve the next page of results.
        public let nextToken: String?
        /// The list of AgentCore Runtime endpoints.
        public let runtimeEndpoints: [AgentRuntimeEndpoint]

        @inlinable
        public init(nextToken: String? = nil, runtimeEndpoints: [AgentRuntimeEndpoint]) {
            self.nextToken = nextToken
            self.runtimeEndpoints = runtimeEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case runtimeEndpoints = "runtimeEndpoints"
        }
    }

    public struct ListAgentRuntimeVersionsRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime to list versions for.
        public let agentRuntimeId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimeId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentRuntimeId = agentRuntimeId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAgentRuntimeVersionsResponse: AWSDecodableShape {
        /// The list of AgentCore Runtime versions.
        public let agentRuntimes: [AgentRuntime]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimes: [AgentRuntime], nextToken: String? = nil) {
            self.agentRuntimes = agentRuntimes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimes = "agentRuntimes"
            case nextToken = "nextToken"
        }
    }

    public struct ListAgentRuntimesRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAgentRuntimesResponse: AWSDecodableShape {
        /// The list of AgentCore Runtime resources.
        public let agentRuntimes: [AgentRuntime]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(agentRuntimes: [AgentRuntime], nextToken: String? = nil) {
            self.agentRuntimes = agentRuntimes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimes = "agentRuntimes"
            case nextToken = "nextToken"
        }
    }

    public struct ListApiKeyCredentialProvidersRequest: AWSEncodableShape {
        /// Maximum number of results to return.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListApiKeyCredentialProvidersResponse: AWSDecodableShape {
        /// The list of API key credential providers.
        public let credentialProviders: [ApiKeyCredentialProviderItem]
        /// Pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(credentialProviders: [ApiKeyCredentialProviderItem], nextToken: String? = nil) {
            self.credentialProviders = credentialProviders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviders = "credentialProviders"
            case nextToken = "nextToken"
        }
    }

    public struct ListBrowsersRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The type of browsers to list. If not specified, all browser types are returned.
        public let type: ResourceType?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, type: ResourceType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBrowsersResponse: AWSDecodableShape {
        /// The list of browser summaries.
        public let browserSummaries: [BrowserSummary]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(browserSummaries: [BrowserSummary], nextToken: String? = nil) {
            self.browserSummaries = browserSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case browserSummaries = "browserSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCodeInterpretersRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to retrieve the next page of results.
        public let nextToken: String?
        /// The type of code interpreters to list.
        public let type: ResourceType?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, type: ResourceType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCodeInterpretersResponse: AWSDecodableShape {
        /// The list of code interpreter summaries.
        public let codeInterpreterSummaries: [CodeInterpreterSummary]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(codeInterpreterSummaries: [CodeInterpreterSummary], nextToken: String? = nil) {
            self.codeInterpreterSummaries = codeInterpreterSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterSummaries = "codeInterpreterSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListEvaluatorsRequest: AWSEncodableShape {
        ///  The maximum number of evaluators to return in a single response.
        public let maxResults: Int?
        ///  The pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEvaluatorsResponse: AWSDecodableShape {
        ///  The list of evaluator summaries containing basic information about each evaluator.
        public let evaluators: [EvaluatorSummary]
        ///  The pagination token to use in a subsequent request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(evaluators: [EvaluatorSummary], nextToken: String? = nil) {
            self.evaluators = evaluators
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evaluators = "evaluators"
            case nextToken = "nextToken"
        }
    }

    public struct ListGatewayTargetsRequest: AWSEncodableShape {
        /// The identifier of the gateway to list targets for.
        public let gatewayIdentifier: String
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(gatewayIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.gatewayIdentifier = gatewayIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewayTargetsResponse: AWSDecodableShape {
        /// The list of gateway target summaries.
        public let items: [TargetSummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(items: [TargetSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListGatewaysRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewaysResponse: AWSDecodableShape {
        /// The list of gateway summaries.
        public let items: [GatewaySummary]
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(items: [GatewaySummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoriesInput: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoriesOutput: AWSDecodableShape {
        /// The list of AgentCore Memory resource summaries.
        public let memories: [MemorySummary]
        /// A token to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(memories: [MemorySummary], nextToken: String? = nil) {
            self.memories = memories
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memories = "memories"
            case nextToken = "nextToken"
        }
    }

    public struct ListOauth2CredentialProvidersRequest: AWSEncodableShape {
        /// Maximum number of results to return.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListOauth2CredentialProvidersResponse: AWSDecodableShape {
        /// The list of OAuth2 credential providers.
        public let credentialProviders: [Oauth2CredentialProviderItem]
        /// Pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(credentialProviders: [Oauth2CredentialProviderItem], nextToken: String? = nil) {
            self.credentialProviders = credentialProviders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviders = "credentialProviders"
            case nextToken = "nextToken"
        }
    }

    public struct ListOnlineEvaluationConfigsRequest: AWSEncodableShape {
        ///  The maximum number of online evaluation configurations to return in a single response.
        public let maxResults: Int?
        ///  The pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOnlineEvaluationConfigsResponse: AWSDecodableShape {
        ///  The pagination token to use in a subsequent request to retrieve the next page of results.
        public let nextToken: String?
        ///  The list of online evaluation configuration summaries containing basic information about each configuration.
        public let onlineEvaluationConfigs: [OnlineEvaluationConfigSummary]

        @inlinable
        public init(nextToken: String? = nil, onlineEvaluationConfigs: [OnlineEvaluationConfigSummary]) {
            self.nextToken = nextToken
            self.onlineEvaluationConfigs = onlineEvaluationConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case onlineEvaluationConfigs = "onlineEvaluationConfigs"
        }
    }

    public struct ListPoliciesRequest: AWSEncodableShape {
        /// The maximum number of policies to return in a single response. If not specified, the default is 10 policies per page, with a maximum of 100 per page.
        public let maxResults: Int?
        /// A pagination token returned from a previous ListPolicies call. Use this token to retrieve the next page of results when the response is paginated.
        public let nextToken: String?
        /// The identifier of the policy engine whose policies to retrieve.
        public let policyEngineId: String
        /// Optional filter to list policies that apply to a specific resource scope or resource type. This helps narrow down policy results to those relevant for particular Amazon Web Services resources, agent tools, or operational contexts within the policy engine ecosystem.
        public let targetResourceScope: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, policyEngineId: String, targetResourceScope: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyEngineId = policyEngineId
            self.targetResourceScope = targetResourceScope
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.policyEngineId, key: "policyEngineId")
            request.encodeQuery(self.targetResourceScope, key: "targetResourceScope")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
            try self.validate(self.targetResourceScope, name: "targetResourceScope", parent: name, max: 1011)
            try self.validate(self.targetResourceScope, name: "targetResourceScope", parent: name, min: 20)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPoliciesResponse: AWSDecodableShape {
        /// A pagination token that can be used in subsequent ListPolicies calls to retrieve additional results. This token is only present when there are more results available.
        public let nextToken: String?
        /// An array of policy objects that match the specified criteria. Each policy object contains the policy metadata, status, and key identifiers for further operations.
        public let policies: [Policy]

        @inlinable
        public init(nextToken: String? = nil, policies: [Policy]) {
            self.nextToken = nextToken
            self.policies = policies
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case policies = "policies"
        }
    }

    public struct ListPolicyEnginesRequest: AWSEncodableShape {
        /// The maximum number of policy engines to return in a single response. If not specified, the default is 10 policy engines per page, with a maximum of 100 per page.
        public let maxResults: Int?
        /// A pagination token returned from a previous ListPolicyEngines call. Use this token to retrieve the next page of results when the response is paginated.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPolicyEnginesResponse: AWSDecodableShape {
        /// A pagination token that can be used in subsequent ListPolicyEngines calls to retrieve additional results. This token is only present when there are more results available.
        public let nextToken: String?
        /// An array of policy engine objects that exist in the account. Each policy engine object contains the engine metadata, status, and key identifiers for further operations.
        public let policyEngines: [PolicyEngine]

        @inlinable
        public init(nextToken: String? = nil, policyEngines: [PolicyEngine]) {
            self.nextToken = nextToken
            self.policyEngines = policyEngines
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case policyEngines = "policyEngines"
        }
    }

    public struct ListPolicyGenerationAssetsRequest: AWSEncodableShape {
        /// The maximum number of policy generation assets to return in a single response. If not specified, the default is 10 assets per page, with a maximum of 100 per page. This helps control response size when dealing with policy generations that produce many alternative policy options.
        public let maxResults: Int?
        /// A pagination token returned from a previous ListPolicyGenerationAssets call. Use this token to retrieve the next page of assets when the response is paginated due to large numbers of generated policy options.
        public let nextToken: String?
        /// The unique identifier of the policy engine associated with the policy generation request. This provides the context for the generation operation and ensures assets are retrieved from the correct policy engine.
        public let policyEngineId: String
        /// The unique identifier of the policy generation request whose assets are to be retrieved. This must be a valid generation ID from a previous StartPolicyGeneration call that has completed processing.
        public let policyGenerationId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, policyEngineId: String, policyGenerationId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyEngineId = policyEngineId
            self.policyGenerationId = policyGenerationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.policyEngineId, key: "policyEngineId")
            request.encodePath(self.policyGenerationId, key: "policyGenerationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
            try self.validate(self.policyGenerationId, name: "policyGenerationId", parent: name, max: 59)
            try self.validate(self.policyGenerationId, name: "policyGenerationId", parent: name, min: 12)
            try self.validate(self.policyGenerationId, name: "policyGenerationId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPolicyGenerationAssetsResponse: AWSDecodableShape {
        /// A pagination token that can be used in subsequent ListPolicyGenerationAssets calls to retrieve additional assets. This token is only present when there are more generated policy assets available beyond the current response.
        public let nextToken: String?
        /// An array of generated policy assets including Cedar policies and related artifacts from the AI-powered policy generation process. Each asset represents a different policy option or variation generated from the original natural language input.
        public let policyGenerationAssets: [PolicyGenerationAsset]?

        @inlinable
        public init(nextToken: String? = nil, policyGenerationAssets: [PolicyGenerationAsset]? = nil) {
            self.nextToken = nextToken
            self.policyGenerationAssets = policyGenerationAssets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case policyGenerationAssets = "policyGenerationAssets"
        }
    }

    public struct ListPolicyGenerationsRequest: AWSEncodableShape {
        /// The maximum number of policy generations to return in a single response.
        public let maxResults: Int?
        /// A pagination token for retrieving additional policy generations when results are paginated.
        public let nextToken: String?
        /// The identifier of the policy engine whose policy generations to retrieve.
        public let policyEngineId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, policyEngineId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyEngineId = policyEngineId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.policyEngineId, key: "policyEngineId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPolicyGenerationsResponse: AWSDecodableShape {
        /// A pagination token for retrieving additional policy generations if more results are available.
        public let nextToken: String?
        /// An array of policy generation objects that match the specified criteria.
        public let policyGenerations: [PolicyGeneration]

        @inlinable
        public init(nextToken: String? = nil, policyGenerations: [PolicyGeneration]) {
            self.nextToken = nextToken
            self.policyGenerations = policyGenerations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case policyGenerations = "policyGenerations"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(?:[^:]+)?:bedrock-agentcore:[a-z0-9-]+:[0-9]{12}:([a-z-]+/[^/]+)(?:/[a-z-]+/[^/]+)*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWorkloadIdentitiesRequest: AWSEncodableShape {
        /// Maximum number of results to return.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorkloadIdentitiesResponse: AWSDecodableShape {
        /// Pagination token for the next page of results.
        public let nextToken: String?
        /// The list of workload identities.
        public let workloadIdentities: [WorkloadIdentityType]

        @inlinable
        public init(nextToken: String? = nil, workloadIdentities: [WorkloadIdentityType]) {
            self.nextToken = nextToken
            self.workloadIdentities = workloadIdentities
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workloadIdentities = "workloadIdentities"
        }
    }

    public struct LlmAsAJudgeEvaluatorConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The evaluation instructions that guide the language model in assessing agent performance, including criteria and evaluation guidelines.
        public let instructions: String
        ///  The model configuration that specifies which foundation model to use and how to configure it for evaluation.
        public let modelConfig: EvaluatorModelConfig
        ///  The rating scale that defines how the evaluator should score agent performance, either numerical or categorical.
        public let ratingScale: RatingScale

        @inlinable
        public init(instructions: String, modelConfig: EvaluatorModelConfig, ratingScale: RatingScale) {
            self.instructions = instructions
            self.modelConfig = modelConfig
            self.ratingScale = ratingScale
        }

        public func validate(name: String) throws {
            try self.modelConfig.validate(name: "\(name).modelConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case instructions = "instructions"
            case modelConfig = "modelConfig"
            case ratingScale = "ratingScale"
        }
    }

    public struct MCPGatewayConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The instructions for using the Model Context Protocol gateway. These instructions provide guidance on how to interact with the gateway.
        public let instructions: String?
        /// The search type for the Model Context Protocol gateway. This field specifies how the gateway handles search operations.
        public let searchType: SearchType?
        /// The supported versions of the Model Context Protocol. This field specifies which versions of the protocol the gateway can use.
        public let supportedVersions: [String]?

        @inlinable
        public init(instructions: String? = nil, searchType: SearchType? = nil, supportedVersions: [String]? = nil) {
            self.instructions = instructions
            self.searchType = searchType
            self.supportedVersions = supportedVersions
        }

        public func validate(name: String) throws {
            try self.validate(self.instructions, name: "instructions", parent: name, max: 2048)
            try self.validate(self.instructions, name: "instructions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instructions = "instructions"
            case searchType = "searchType"
            case supportedVersions = "supportedVersions"
        }
    }

    public struct McpLambdaTargetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function. This function is invoked by the gateway to communicate with the target.
        public let lambdaArn: String
        /// The tool schema for the Lambda function. This schema defines the structure of the tools that the Lambda function provides.
        public let toolSchema: ToolSchema

        @inlinable
        public init(lambdaArn: String, toolSchema: ToolSchema) {
            self.lambdaArn = lambdaArn
            self.toolSchema = toolSchema
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 170)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, min: 1)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:lambda:([a-z]{2}(-gov)?-[a-z]+-\\d{1}):(\\d{12}):function:([a-zA-Z0-9-_.]+)(:(\\$LATEST|[a-zA-Z0-9-]+))?$")
            try self.toolSchema.validate(name: "\(name).toolSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaArn = "lambdaArn"
            case toolSchema = "toolSchema"
        }
    }

    public struct McpServerTargetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint for the MCP server target configuration.
        public let endpoint: String

        @inlinable
        public init(endpoint: String) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "endpoint"
        }
    }

    public struct Memory: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the memory.
        public let arn: String
        /// The timestamp when the memory was created.
        public let createdAt: Date
        /// The description of the memory.
        public let description: String?
        /// The ARN of the KMS key used to encrypt the memory.
        public let encryptionKeyArn: String?
        /// The number of days after which memory events will expire.
        public let eventExpiryDuration: Int
        /// The reason for failure if the memory is in a failed state.
        public let failureReason: String?
        /// The unique identifier of the memory.
        public let id: String
        /// The ARN of the IAM role that provides permissions for the memory.
        public let memoryExecutionRoleArn: String?
        /// The name of the memory.
        public let name: String
        /// The current status of the memory.
        public let status: MemoryStatus
        /// The list of memory strategies associated with this memory.
        public let strategies: [MemoryStrategy]?
        /// The timestamp when the memory was last updated.
        public let updatedAt: Date

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, encryptionKeyArn: String? = nil, eventExpiryDuration: Int, failureReason: String? = nil, id: String, memoryExecutionRoleArn: String? = nil, name: String, status: MemoryStatus, strategies: [MemoryStrategy]? = nil, updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.encryptionKeyArn = encryptionKeyArn
            self.eventExpiryDuration = eventExpiryDuration
            self.failureReason = failureReason
            self.id = id
            self.memoryExecutionRoleArn = memoryExecutionRoleArn
            self.name = name
            self.status = status
            self.strategies = strategies
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case encryptionKeyArn = "encryptionKeyArn"
            case eventExpiryDuration = "eventExpiryDuration"
            case failureReason = "failureReason"
            case id = "id"
            case memoryExecutionRoleArn = "memoryExecutionRoleArn"
            case name = "name"
            case status = "status"
            case strategies = "strategies"
            case updatedAt = "updatedAt"
        }
    }

    public struct MemoryStrategy: AWSDecodableShape {
        /// The configuration of the memory strategy.
        public let configuration: StrategyConfiguration?
        /// The timestamp when the memory strategy was created.
        public let createdAt: Date?
        /// The description of the memory strategy.
        public let description: String?
        /// The name of the memory strategy.
        public let name: String
        /// The namespaces associated with the memory strategy.
        public let namespaces: [String]
        /// The current status of the memory strategy.
        public let status: MemoryStrategyStatus?
        /// The unique identifier of the memory strategy.
        public let strategyId: String
        /// The type of the memory strategy.
        public let type: MemoryStrategyType
        /// The timestamp when the memory strategy was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(configuration: StrategyConfiguration? = nil, createdAt: Date? = nil, description: String? = nil, name: String, namespaces: [String], status: MemoryStrategyStatus? = nil, strategyId: String, type: MemoryStrategyType, updatedAt: Date? = nil) {
            self.configuration = configuration
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.namespaces = namespaces
            self.status = status
            self.strategyId = strategyId
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case createdAt = "createdAt"
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
            case status = "status"
            case strategyId = "strategyId"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct MemorySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the memory.
        public let arn: String?
        /// The timestamp when the memory was created.
        public let createdAt: Date
        /// The unique identifier of the memory.
        public let id: String?
        /// The current status of the memory.
        public let status: MemoryStatus?
        /// The timestamp when the memory was last updated.
        public let updatedAt: Date

        @inlinable
        public init(arn: String? = nil, createdAt: Date, id: String? = nil, status: MemoryStatus? = nil, updatedAt: Date) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct MessageBasedTrigger: AWSDecodableShape {
        /// The number of messages that trigger memory processing.
        public let messageCount: Int?

        @inlinable
        public init(messageCount: Int? = nil) {
            self.messageCount = messageCount
        }

        private enum CodingKeys: String, CodingKey {
            case messageCount = "messageCount"
        }
    }

    public struct MessageBasedTriggerInput: AWSEncodableShape {
        /// The number of messages that trigger memory processing.
        public let messageCount: Int?

        @inlinable
        public init(messageCount: Int? = nil) {
            self.messageCount = messageCount
        }

        private enum CodingKeys: String, CodingKey {
            case messageCount = "messageCount"
        }
    }

    public struct MicrosoftOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Microsoft OAuth2 provider.
        public let clientId: String
        /// The client secret for the Microsoft OAuth2 provider.
        public let clientSecret: String
        /// The Microsoft Entra ID (formerly Azure AD) tenant ID for your organization. This identifies the specific tenant within Microsoft's identity platform where your application is registered.
        public let tenantId: String?

        @inlinable
        public init(clientId: String, clientSecret: String, tenantId: String? = nil) {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.tenantId = tenantId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
            try self.validate(self.tenantId, name: "tenantId", parent: name, max: 2048)
            try self.validate(self.tenantId, name: "tenantId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case tenantId = "tenantId"
        }
    }

    public struct MicrosoftOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the Microsoft OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the Microsoft provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct ModifyInvocationConfigurationInput: AWSEncodableShape {
        /// The updated S3 bucket name for event payload delivery.
        public let payloadDeliveryBucketName: String?
        /// The updated ARN of the SNS topic for job notifications.
        public let topicArn: String?

        @inlinable
        public init(payloadDeliveryBucketName: String? = nil, topicArn: String? = nil) {
            self.payloadDeliveryBucketName = payloadDeliveryBucketName
            self.topicArn = topicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.topicArn, name: "topicArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case payloadDeliveryBucketName = "payloadDeliveryBucketName"
            case topicArn = "topicArn"
        }
    }

    public struct ModifyMemoryStrategies: AWSEncodableShape {
        /// The list of memory strategies to add.
        public let addMemoryStrategies: [MemoryStrategyInput]?
        /// The list of memory strategies to delete.
        public let deleteMemoryStrategies: [DeleteMemoryStrategyInput]?
        /// The list of memory strategies to modify.
        public let modifyMemoryStrategies: [ModifyMemoryStrategyInput]?

        @inlinable
        public init(addMemoryStrategies: [MemoryStrategyInput]? = nil, deleteMemoryStrategies: [DeleteMemoryStrategyInput]? = nil, modifyMemoryStrategies: [ModifyMemoryStrategyInput]? = nil) {
            self.addMemoryStrategies = addMemoryStrategies
            self.deleteMemoryStrategies = deleteMemoryStrategies
            self.modifyMemoryStrategies = modifyMemoryStrategies
        }

        public func validate(name: String) throws {
            try self.addMemoryStrategies?.forEach {
                try $0.validate(name: "\(name).addMemoryStrategies[]")
            }
            try self.modifyMemoryStrategies?.forEach {
                try $0.validate(name: "\(name).modifyMemoryStrategies[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case addMemoryStrategies = "addMemoryStrategies"
            case deleteMemoryStrategies = "deleteMemoryStrategies"
            case modifyMemoryStrategies = "modifyMemoryStrategies"
        }
    }

    public struct ModifyMemoryStrategyInput: AWSEncodableShape {
        /// The updated configuration for the memory strategy.
        public let configuration: ModifyStrategyConfiguration?
        /// The updated description of the memory strategy.
        public let description: String?
        /// The unique identifier of the memory strategy to modify.
        public let memoryStrategyId: String
        /// The updated namespaces for the memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(configuration: ModifyStrategyConfiguration? = nil, description: String? = nil, memoryStrategyId: String, namespaces: [String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case memoryStrategyId = "memoryStrategyId"
            case namespaces = "namespaces"
        }
    }

    public struct ModifySelfManagedConfiguration: AWSEncodableShape {
        /// The updated number of historical messages to include in processing context.
        public let historicalContextWindowSize: Int?
        /// The updated configuration to invoke self-managed memory processing pipeline.
        public let invocationConfiguration: ModifyInvocationConfigurationInput?
        /// The updated list of conditions that trigger memory processing.
        public let triggerConditions: [TriggerConditionInput]?

        @inlinable
        public init(historicalContextWindowSize: Int? = nil, invocationConfiguration: ModifyInvocationConfigurationInput? = nil, triggerConditions: [TriggerConditionInput]? = nil) {
            self.historicalContextWindowSize = historicalContextWindowSize
            self.invocationConfiguration = invocationConfiguration
            self.triggerConditions = triggerConditions
        }

        public func validate(name: String) throws {
            try self.invocationConfiguration?.validate(name: "\(name).invocationConfiguration")
            try self.validate(self.triggerConditions, name: "triggerConditions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case historicalContextWindowSize = "historicalContextWindowSize"
            case invocationConfiguration = "invocationConfiguration"
            case triggerConditions = "triggerConditions"
        }
    }

    public struct ModifyStrategyConfiguration: AWSEncodableShape {
        /// The updated consolidation configuration.
        public let consolidation: ModifyConsolidationConfiguration?
        /// The updated extraction configuration.
        public let extraction: ModifyExtractionConfiguration?
        /// The updated reflection configuration.
        public let reflection: ModifyReflectionConfiguration?
        /// The updated self-managed configuration.
        public let selfManagedConfiguration: ModifySelfManagedConfiguration?

        @inlinable
        public init(consolidation: ModifyConsolidationConfiguration? = nil, extraction: ModifyExtractionConfiguration? = nil, reflection: ModifyReflectionConfiguration? = nil, selfManagedConfiguration: ModifySelfManagedConfiguration? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
            self.reflection = reflection
            self.selfManagedConfiguration = selfManagedConfiguration
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
            try self.extraction?.validate(name: "\(name).extraction")
            try self.reflection?.validate(name: "\(name).reflection")
            try self.selfManagedConfiguration?.validate(name: "\(name).selfManagedConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
            case reflection = "reflection"
            case selfManagedConfiguration = "selfManagedConfiguration"
        }
    }

    public struct NetworkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The network mode for the AgentCore Runtime.
        public let networkMode: NetworkMode
        /// The network mode configuration for the AgentCore Runtime.
        public let networkModeConfig: VpcConfig?

        @inlinable
        public init(networkMode: NetworkMode, networkModeConfig: VpcConfig? = nil) {
            self.networkMode = networkMode
            self.networkModeConfig = networkModeConfig
        }

        public func validate(name: String) throws {
            try self.networkModeConfig?.validate(name: "\(name).networkModeConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case networkMode = "networkMode"
            case networkModeConfig = "networkModeConfig"
        }
    }

    public struct NumericalScaleDefinition: AWSEncodableShape & AWSDecodableShape {
        ///  The description that explains what this numerical rating represents and when it should be used.
        public let definition: String
        ///  The label or name that describes this numerical rating option.
        public let label: String
        ///  The numerical value for this rating scale option.
        public let value: Double

        @inlinable
        public init(definition: String, label: String, value: Double) {
            self.definition = definition
            self.label = label
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case label = "label"
            case value = "value"
        }
    }

    public struct OAuthCredentialProvider: AWSEncodableShape & AWSDecodableShape {
        /// The custom parameters for the OAuth credential provider. These parameters provide additional configuration for the OAuth authentication process.
        public let customParameters: [String: String]?
        /// The URL where the end user's browser is redirected after obtaining the authorization code. Generally points to the customer's application.
        public let defaultReturnUrl: String?
        /// Specifies the kind of credentials to use for authorization:    CLIENT_CREDENTIALS - Authorization with a client ID and secret.    AUTHORIZATION_CODE - Authorization with a token that is specific to an individual end user.
        public let grantType: OAuthGrantType?
        /// The Amazon Resource Name (ARN) of the OAuth credential provider. This ARN identifies the provider in Amazon Web Services.
        public let providerArn: String
        /// The OAuth scopes for the credential provider. These scopes define the level of access requested from the OAuth provider.
        public let scopes: [String]

        @inlinable
        public init(customParameters: [String: String]? = nil, defaultReturnUrl: String? = nil, grantType: OAuthGrantType? = nil, providerArn: String, scopes: [String]) {
            self.customParameters = customParameters
            self.defaultReturnUrl = defaultReturnUrl
            self.grantType = grantType
            self.providerArn = providerArn
            self.scopes = scopes
        }

        public func validate(name: String) throws {
            try self.customParameters?.forEach {
                try validate($0.key, name: "customParameters.key", parent: name, max: 256)
                try validate($0.key, name: "customParameters.key", parent: name, min: 1)
                try validate($0.value, name: "customParameters[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "customParameters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.customParameters, name: "customParameters", parent: name, max: 10)
            try self.validate(self.customParameters, name: "customParameters", parent: name, min: 1)
            try self.validate(self.defaultReturnUrl, name: "defaultReturnUrl", parent: name, max: 2048)
            try self.validate(self.defaultReturnUrl, name: "defaultReturnUrl", parent: name, min: 1)
            try self.validate(self.defaultReturnUrl, name: "defaultReturnUrl", parent: name, pattern: "^\\w+:(\\/?\\/?)[^\\s]+$")
            try self.validate(self.providerArn, name: "providerArn", parent: name, pattern: "^arn:([^:]*):([^:]*):([^:]*):([0-9]{12})?:(.+)$")
            try self.scopes.forEach {
                try validate($0, name: "scopes[]", parent: name, max: 64)
                try validate($0, name: "scopes[]", parent: name, min: 1)
            }
            try self.validate(self.scopes, name: "scopes", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case customParameters = "customParameters"
            case defaultReturnUrl = "defaultReturnUrl"
            case grantType = "grantType"
            case providerArn = "providerArn"
            case scopes = "scopes"
        }
    }

    public struct Oauth2AuthorizationServerMetadata: AWSEncodableShape & AWSDecodableShape {
        /// The authorization endpoint URL for the OAuth2 authorization server.
        public let authorizationEndpoint: String
        /// The issuer URL for the OAuth2 authorization server.
        public let issuer: String
        /// The supported response types for the OAuth2 authorization server.
        public let responseTypes: [String]?
        /// The token endpoint URL for the OAuth2 authorization server.
        public let tokenEndpoint: String
        /// The authentication methods supported by the token endpoint. This specifies how clients can authenticate when requesting tokens from the authorization server.
        public let tokenEndpointAuthMethods: [String]?

        @inlinable
        public init(authorizationEndpoint: String, issuer: String, responseTypes: [String]? = nil, tokenEndpoint: String, tokenEndpointAuthMethods: [String]? = nil) {
            self.authorizationEndpoint = authorizationEndpoint
            self.issuer = issuer
            self.responseTypes = responseTypes
            self.tokenEndpoint = tokenEndpoint
            self.tokenEndpointAuthMethods = tokenEndpointAuthMethods
        }

        public func validate(name: String) throws {
            try self.tokenEndpointAuthMethods?.forEach {
                try validate($0, name: "tokenEndpointAuthMethods[]", parent: name, pattern: "^(client_secret_post|client_secret_basic)$")
            }
            try self.validate(self.tokenEndpointAuthMethods, name: "tokenEndpointAuthMethods", parent: name, max: 2)
            try self.validate(self.tokenEndpointAuthMethods, name: "tokenEndpointAuthMethods", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationEndpoint = "authorizationEndpoint"
            case issuer = "issuer"
            case responseTypes = "responseTypes"
            case tokenEndpoint = "tokenEndpoint"
            case tokenEndpointAuthMethods = "tokenEndpointAuthMethods"
        }
    }

    public struct Oauth2CredentialProviderItem: AWSDecodableShape {
        /// The timestamp when the OAuth2 credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
        public let credentialProviderArn: String
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The timestamp when the OAuth2 credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the OAuth2 credential provider.
        public let name: String

        @inlinable
        public init(createdTime: Date, credentialProviderArn: String, credentialProviderVendor: CredentialProviderVendorType, lastUpdatedTime: Date, name: String) {
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.credentialProviderVendor = credentialProviderVendor
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case credentialProviderVendor = "credentialProviderVendor"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct OnlineEvaluationConfigSummary: AWSDecodableShape {
        ///  The timestamp when the online evaluation configuration was created.
        public let createdAt: Date
        ///  The description of the online evaluation configuration.
        public let description: String?
        ///  The execution status indicating whether the online evaluation is currently running.
        public let executionStatus: OnlineEvaluationExecutionStatus
        ///  The reason for failure if the online evaluation configuration execution failed.
        public let failureReason: String?
        ///  The Amazon Resource Name (ARN) of the online evaluation configuration.
        public let onlineEvaluationConfigArn: String
        ///  The unique identifier of the online evaluation configuration.
        public let onlineEvaluationConfigId: String
        ///  The name of the online evaluation configuration.
        public let onlineEvaluationConfigName: String
        ///  The status of the online evaluation configuration.
        public let status: OnlineEvaluationConfigStatus
        ///  The timestamp when the online evaluation configuration was last updated.
        public let updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, executionStatus: OnlineEvaluationExecutionStatus, failureReason: String? = nil, onlineEvaluationConfigArn: String, onlineEvaluationConfigId: String, onlineEvaluationConfigName: String, status: OnlineEvaluationConfigStatus, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.executionStatus = executionStatus
            self.failureReason = failureReason
            self.onlineEvaluationConfigArn = onlineEvaluationConfigArn
            self.onlineEvaluationConfigId = onlineEvaluationConfigId
            self.onlineEvaluationConfigName = onlineEvaluationConfigName
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case executionStatus = "executionStatus"
            case failureReason = "failureReason"
            case onlineEvaluationConfigArn = "onlineEvaluationConfigArn"
            case onlineEvaluationConfigId = "onlineEvaluationConfigId"
            case onlineEvaluationConfigName = "onlineEvaluationConfigName"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct OutputConfig: AWSDecodableShape {
        ///  The CloudWatch configuration for writing evaluation results to CloudWatch logs with embedded metric format.
        public let cloudWatchConfig: CloudWatchOutputConfig

        @inlinable
        public init(cloudWatchConfig: CloudWatchOutputConfig) {
            self.cloudWatchConfig = cloudWatchConfig
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchConfig = "cloudWatchConfig"
        }
    }

    public struct Policy: AWSDecodableShape {
        /// The timestamp when the policy was originally created. This is automatically set by the service and used for auditing and lifecycle management.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Cedar policy statement that defines the access control rules. This contains the actual policy logic used for agent behavior control and access decisions.
        public let definition: PolicyDefinition
        /// A human-readable description of the policy's purpose and functionality. Limited to 4,096 characters, this helps administrators understand and manage the policy.
        public let description: String?
        /// The customer-assigned immutable name for the policy. This human-readable identifier must be unique within the account and cannot exceed 48 characters.
        public let name: String
        /// The Amazon Resource Name (ARN) of the policy. This globally unique identifier can be used for cross-service references and IAM policy statements.
        public let policyArn: String
        /// The identifier of the policy engine that manages this policy. This establishes the policy engine context for policy evaluation and management.
        public let policyEngineId: String
        /// The unique identifier for the policy. This system-generated identifier consists of the user name plus a 10-character generated suffix and serves as the primary key for policy operations.
        public let policyId: String
        /// The current status of the policy.
        public let status: PolicyStatus
        /// Additional information about the policy status. This provides details about any failures or the current state of the policy lifecycle.
        public let statusReasons: [String]
        /// The timestamp when the policy was last modified. This tracks the most recent changes to the policy configuration or metadata.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, definition: PolicyDefinition, description: String? = nil, name: String, policyArn: String, policyEngineId: String, policyId: String, status: PolicyStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.definition = definition
            self.description = description
            self.name = name
            self.policyArn = policyArn
            self.policyEngineId = policyEngineId
            self.policyId = policyId
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case definition = "definition"
            case description = "description"
            case name = "name"
            case policyArn = "policyArn"
            case policyEngineId = "policyEngineId"
            case policyId = "policyId"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct PolicyEngine: AWSDecodableShape {
        /// The timestamp when the policy engine was originally created. This is automatically set by the service and used for auditing and lifecycle management.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A human-readable description of the policy engine's purpose and scope. Limited to 4,096 characters, this helps administrators understand the policy engine's role in the overall governance strategy.
        public let description: String?
        /// The customer-assigned immutable name for the policy engine. This human-readable identifier must be unique within the account and cannot exceed 48 characters.
        public let name: String
        /// The Amazon Resource Name (ARN) of the policy engine. This globally unique identifier can be used for cross-service references and IAM policy statements.
        public let policyEngineArn: String
        /// The unique identifier for the policy engine. This system-generated identifier consists of the user name plus a 10-character generated suffix and serves as the primary key for policy engine operations.
        public let policyEngineId: String
        /// The current status of the policy engine.
        public let status: PolicyEngineStatus
        /// Additional information about the policy engine status. This provides details about any failures or the current state of the policy engine lifecycle.
        public let statusReasons: [String]
        /// The timestamp when the policy engine was last modified. This tracks the most recent changes to the policy engine configuration or metadata.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, name: String, policyEngineArn: String, policyEngineId: String, status: PolicyEngineStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.policyEngineArn = policyEngineArn
            self.policyEngineId = policyEngineId
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case name = "name"
            case policyEngineArn = "policyEngineArn"
            case policyEngineId = "policyEngineId"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct PolicyGeneration: AWSDecodableShape {
        /// The timestamp when this policy generation request was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Findings and insights from this policy generation process.
        public let findings: String?
        /// The customer-assigned name for this policy generation request.
        public let name: String
        /// The identifier of the policy engine associated with this generation request.
        public let policyEngineId: String
        /// The ARN of this policy generation request.
        public let policyGenerationArn: String
        /// The unique identifier for this policy generation request.
        public let policyGenerationId: String
        /// The resource information associated with this policy generation.
        public let resource: Resource
        /// The current status of this policy generation request.
        public let status: PolicyGenerationStatus
        /// Additional information about the generation status.
        public let statusReasons: [String]
        /// The timestamp when this policy generation was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, findings: String? = nil, name: String, policyEngineId: String, policyGenerationArn: String, policyGenerationId: String, resource: Resource, status: PolicyGenerationStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.findings = findings
            self.name = name
            self.policyEngineId = policyEngineId
            self.policyGenerationArn = policyGenerationArn
            self.policyGenerationId = policyGenerationId
            self.resource = resource
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case findings = "findings"
            case name = "name"
            case policyEngineId = "policyEngineId"
            case policyGenerationArn = "policyGenerationArn"
            case policyGenerationId = "policyGenerationId"
            case resource = "resource"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct PolicyGenerationAsset: AWSDecodableShape {
        public let definition: PolicyDefinition?
        /// Analysis findings and insights related to this specific generated policy asset. These findings may include validation results, potential issues, or recommendations for improvement to help users evaluate the quality and appropriateness of the generated policy.
        public let findings: [Finding]
        /// The unique identifier for this generated policy asset within the policy generation request. This ID can be used to reference specific generated policy options when creating actual policies from the generation results.
        public let policyGenerationAssetId: String
        /// The portion of the original natural language input that this generated policy asset addresses. This helps users understand which part of their policy description was translated into this specific Cedar policy statement, enabling better policy selection and refinement. When a single natural language input describes multiple authorization requirements, the generation process creates separate policy assets for each requirement, with each asset's rawTextFragment showing which requirement it addresses. Use this mapping to verify that all parts of your natural language input were correctly translated into Cedar policies.
        public let rawTextFragment: String

        @inlinable
        public init(definition: PolicyDefinition? = nil, findings: [Finding], policyGenerationAssetId: String, rawTextFragment: String) {
            self.definition = definition
            self.findings = findings
            self.policyGenerationAssetId = policyGenerationAssetId
            self.rawTextFragment = rawTextFragment
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case findings = "findings"
            case policyGenerationAssetId = "policyGenerationAssetId"
            case rawTextFragment = "rawTextFragment"
        }
    }

    public struct ProtocolConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The server protocol for the agent runtime. This field specifies which protocol the agent runtime uses to communicate with clients.
        public let serverProtocol: ServerProtocol

        @inlinable
        public init(serverProtocol: ServerProtocol) {
            self.serverProtocol = serverProtocol
        }

        private enum CodingKeys: String, CodingKey {
            case serverProtocol = "serverProtocol"
        }
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// The resource policy to create or update.
        public let policy: String
        /// The Amazon Resource Name (ARN) of the resource for which to create or update the resource policy.
        public let resourceArn: String

        @inlinable
        public init(policy: String, resourceArn: String) {
            self.policy = policy
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.policy, forKey: .policy)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct PutResourcePolicyResponse: AWSDecodableShape {
        /// The resource policy that was created or updated.
        public let policy: String

        @inlinable
        public init(policy: String) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct RecordingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether recording is enabled for the browser. When set to true, browser sessions are recorded.
        public let enabled: Bool?
        /// The Amazon S3 location where browser recordings are stored. This location contains the recorded browser sessions.
        public let s3Location: S3Location?

        @inlinable
        public init(enabled: Bool? = nil, s3Location: S3Location? = nil) {
            self.enabled = enabled
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case s3Location = "s3Location"
        }
    }

    public struct Rule: AWSEncodableShape & AWSDecodableShape {
        ///  The list of filters that determine which agent traces should be included in the evaluation based on trace properties.
        public let filters: [Filter]?
        ///  The sampling configuration that determines what percentage of agent traces to evaluate.
        public let samplingConfig: SamplingConfig
        ///  The session configuration that defines timeout settings for detecting when agent sessions are complete and ready for evaluation.
        public let sessionConfig: SessionConfig?

        @inlinable
        public init(filters: [Filter]? = nil, samplingConfig: SamplingConfig, sessionConfig: SessionConfig? = nil) {
            self.filters = filters
            self.samplingConfig = samplingConfig
            self.sessionConfig = sessionConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.filters, name: "filters", parent: name, max: 5)
            try self.samplingConfig.validate(name: "\(name).samplingConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case samplingConfig = "samplingConfig"
            case sessionConfig = "sessionConfig"
        }
    }

    public struct S3Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The account ID of the Amazon S3 bucket owner. This ID is used for cross-account access to the bucket.
        public let bucketOwnerAccountId: String?
        /// The URI of the Amazon S3 object. This URI specifies the location of the object in Amazon S3.
        public let uri: String?

        @inlinable
        public init(bucketOwnerAccountId: String? = nil, uri: String? = nil) {
            self.bucketOwnerAccountId = bucketOwnerAccountId
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketOwnerAccountId, name: "bucketOwnerAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://.{1,2043}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketOwnerAccountId = "bucketOwnerAccountId"
            case uri = "uri"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket. This bucket contains the stored data.
        public let bucket: String
        /// The prefix for objects in the Amazon S3 bucket. This prefix is added to the object keys to organize the data.
        public let prefix: String
        /// The version ID of the Amazon Amazon S3 object. If not specified, the latest version of the object is used.
        public let versionId: String?

        @inlinable
        public init(bucket: String, prefix: String, versionId: String? = nil) {
            self.bucket = bucket
            self.prefix = prefix
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case prefix = "prefix"
            case versionId = "versionId"
        }
    }

    public struct SalesforceOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Salesforce OAuth2 provider.
        public let clientId: String
        /// The client secret for the Salesforce OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct SalesforceOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the Salesforce OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the Salesforce provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct SamplingConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The percentage of agent traces to sample for evaluation, ranging from 0.01% to 100%.
        public let samplingPercentage: Double

        @inlinable
        public init(samplingPercentage: Double) {
            self.samplingPercentage = samplingPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.samplingPercentage, name: "samplingPercentage", parent: name, max: 100.0)
            try self.validate(self.samplingPercentage, name: "samplingPercentage", parent: name, min: 0.01)
        }

        private enum CodingKeys: String, CodingKey {
            case samplingPercentage = "samplingPercentage"
        }
    }

    public final class SchemaDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The description of the schema definition. This description provides information about the purpose and usage of the schema.
        public let description: String?
        /// The items in the schema definition. This field is used for array types to define the structure of the array elements.
        public let items: SchemaDefinition?
        /// The properties of the schema definition. These properties define the fields in the schema.
        public let properties: [String: SchemaDefinition]?
        /// The required fields in the schema definition. These fields must be provided when using the schema.
        public let required: [String]?
        /// The type of the schema definition. This field specifies the data type of the schema.
        public let type: SchemaType

        @inlinable
        public init(description: String? = nil, items: SchemaDefinition? = nil, properties: [String: SchemaDefinition]? = nil, required: [String]? = nil, type: SchemaType) {
            self.description = description
            self.items = items
            self.properties = properties
            self.required = required
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case items = "items"
            case properties = "properties"
            case required = "required"
            case type = "type"
        }
    }

    public struct Secret: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the secret in AWS Secrets Manager.
        public let secretArn: String

        @inlinable
        public init(secretArn: String) {
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case secretArn = "secretArn"
        }
    }

    public struct SelfManagedConfiguration: AWSDecodableShape {
        /// The number of historical messages to include in processing context.
        public let historicalContextWindowSize: Int
        /// The configuration to use when invoking memory processing.
        public let invocationConfiguration: InvocationConfiguration
        /// A list of conditions that trigger memory processing.
        public let triggerConditions: [TriggerCondition]

        @inlinable
        public init(historicalContextWindowSize: Int, invocationConfiguration: InvocationConfiguration, triggerConditions: [TriggerCondition]) {
            self.historicalContextWindowSize = historicalContextWindowSize
            self.invocationConfiguration = invocationConfiguration
            self.triggerConditions = triggerConditions
        }

        private enum CodingKeys: String, CodingKey {
            case historicalContextWindowSize = "historicalContextWindowSize"
            case invocationConfiguration = "invocationConfiguration"
            case triggerConditions = "triggerConditions"
        }
    }

    public struct SelfManagedConfigurationInput: AWSEncodableShape {
        /// Number of historical messages to include in processing context.
        public let historicalContextWindowSize: Int?
        /// Configuration to invoke a self-managed memory processing pipeline with.
        public let invocationConfiguration: InvocationConfigurationInput
        /// A list of conditions that trigger memory processing.
        public let triggerConditions: [TriggerConditionInput]?

        @inlinable
        public init(historicalContextWindowSize: Int? = nil, invocationConfiguration: InvocationConfigurationInput, triggerConditions: [TriggerConditionInput]? = nil) {
            self.historicalContextWindowSize = historicalContextWindowSize
            self.invocationConfiguration = invocationConfiguration
            self.triggerConditions = triggerConditions
        }

        public func validate(name: String) throws {
            try self.invocationConfiguration.validate(name: "\(name).invocationConfiguration")
            try self.validate(self.triggerConditions, name: "triggerConditions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case historicalContextWindowSize = "historicalContextWindowSize"
            case invocationConfiguration = "invocationConfiguration"
            case triggerConditions = "triggerConditions"
        }
    }

    public struct SemanticConsolidationOverride: AWSDecodableShape {
        /// The text to append to the prompt for semantic consolidation.
        public let appendToPrompt: String
        /// The model ID to use for semantic consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SemanticExtractionOverride: AWSDecodableShape {
        /// The text to append to the prompt for semantic extraction.
        public let appendToPrompt: String
        /// The model ID to use for semantic extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SemanticMemoryStrategyInput: AWSEncodableShape {
        /// The description of the semantic memory strategy.
        public let description: String?
        /// The name of the semantic memory strategy.
        public let name: String
        /// The namespaces associated with the semantic memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct SemanticOverrideConfigurationInput: AWSEncodableShape {
        /// The consolidation configuration for a semantic override.
        public let consolidation: SemanticOverrideConsolidationConfigurationInput?
        /// The extraction configuration for a semantic override.
        public let extraction: SemanticOverrideExtractionConfigurationInput?

        @inlinable
        public init(consolidation: SemanticOverrideConsolidationConfigurationInput? = nil, extraction: SemanticOverrideExtractionConfigurationInput? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
            try self.extraction?.validate(name: "\(name).extraction")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
        }
    }

    public struct SemanticOverrideConsolidationConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for semantic consolidation.
        public let appendToPrompt: String
        /// The model ID to use for semantic consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SemanticOverrideExtractionConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for semantic extraction.
        public let appendToPrompt: String
        /// The model ID to use for semantic extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SessionConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The number of minutes of inactivity after which an agent session is considered complete and ready for evaluation. Default is 15 minutes.
        public let sessionTimeoutMinutes: Int

        @inlinable
        public init(sessionTimeoutMinutes: Int) {
            self.sessionTimeoutMinutes = sessionTimeoutMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case sessionTimeoutMinutes = "sessionTimeoutMinutes"
        }
    }

    public struct SetTokenVaultCMKRequest: AWSEncodableShape {
        /// The KMS configuration for the token vault, including the key type and KMS key ARN.
        public let kmsConfiguration: KmsConfiguration
        /// The unique identifier of the token vault to update.
        public let tokenVaultId: String?

        @inlinable
        public init(kmsConfiguration: KmsConfiguration, tokenVaultId: String? = nil) {
            self.kmsConfiguration = kmsConfiguration
            self.tokenVaultId = tokenVaultId
        }

        public func validate(name: String) throws {
            try self.kmsConfiguration.validate(name: "\(name).kmsConfiguration")
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, max: 64)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, min: 1)
            try self.validate(self.tokenVaultId, name: "tokenVaultId", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsConfiguration = "kmsConfiguration"
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct SetTokenVaultCMKResponse: AWSDecodableShape {
        /// The KMS configuration for the token vault.
        public let kmsConfiguration: KmsConfiguration
        /// The timestamp when the token vault was last modified.
        public let lastModifiedDate: Date
        /// The ID of the token vault.
        public let tokenVaultId: String

        @inlinable
        public init(kmsConfiguration: KmsConfiguration, lastModifiedDate: Date, tokenVaultId: String) {
            self.kmsConfiguration = kmsConfiguration
            self.lastModifiedDate = lastModifiedDate
            self.tokenVaultId = tokenVaultId
        }

        private enum CodingKeys: String, CodingKey {
            case kmsConfiguration = "kmsConfiguration"
            case lastModifiedDate = "lastModifiedDate"
            case tokenVaultId = "tokenVaultId"
        }
    }

    public struct SlackOauth2ProviderConfigInput: AWSEncodableShape {
        /// The client ID for the Slack OAuth2 provider.
        public let clientId: String
        /// The client secret for the Slack OAuth2 provider.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 256)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct SlackOauth2ProviderConfigOutput: AWSDecodableShape {
        /// The client ID for the Slack OAuth2 provider.
        public let clientId: String?
        /// The OAuth2 discovery information for the Slack provider.
        public let oauthDiscovery: Oauth2Discovery

        @inlinable
        public init(clientId: String? = nil, oauthDiscovery: Oauth2Discovery) {
            self.clientId = clientId
            self.oauthDiscovery = oauthDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case oauthDiscovery = "oauthDiscovery"
        }
    }

    public struct StartPolicyGenerationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure the idempotency of the request. The AWS SDK automatically generates this token, so you don't need to provide it in most cases. If you retry a request with the same client token, the service returns the same response without starting a duplicate generation.
        public let clientToken: String?
        /// The natural language description of the desired policy behavior. This content is processed by AI to generate corresponding Cedar policy statements that match the described intent.
        public let content: Content
        /// A customer-assigned name for the policy generation request. This helps track and identify generation operations, especially when running multiple generations simultaneously.
        public let name: String
        /// The identifier of the policy engine that provides the context for policy generation. This engine's schema and tool context are used to ensure generated policies are valid and applicable.
        public let policyEngineId: String
        /// The resource information that provides context for policy generation. This helps the AI understand the target resources and generate appropriate access control rules.
        public let resource: Resource

        @inlinable
        public init(clientToken: String? = StartPolicyGenerationRequest.idempotencyToken(), content: Content, name: String, policyEngineId: String, resource: Resource) {
            self.clientToken = clientToken
            self.content = content
            self.name = name
            self.policyEngineId = policyEngineId
            self.resource = resource
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.content, forKey: .content)
            try container.encode(self.name, forKey: .name)
            request.encodePath(self.policyEngineId, key: "policyEngineId")
            try container.encode(self.resource, forKey: .resource)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.content.validate(name: "\(name).content")
            try self.validate(self.name, name: "name", parent: name, max: 48)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*$")
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
            try self.resource.validate(name: "\(name).resource")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case content = "content"
            case name = "name"
            case resource = "resource"
        }
    }

    public struct StartPolicyGenerationResponse: AWSDecodableShape {
        /// The timestamp when the policy generation request was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Initial findings from the policy generation process.
        public let findings: String?
        /// The customer-assigned name for the policy generation request.
        public let name: String
        /// The identifier of the policy engine associated with the started policy generation.
        public let policyEngineId: String
        /// The ARN of the created policy generation request.
        public let policyGenerationArn: String
        /// The unique identifier assigned to the policy generation request for tracking progress.
        public let policyGenerationId: String
        /// The resource information associated with the policy generation request.
        public let resource: Resource
        /// The initial status of the policy generation request.
        public let status: PolicyGenerationStatus
        /// Additional information about the generation status.
        public let statusReasons: [String]
        /// The timestamp when the policy generation was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, findings: String? = nil, name: String, policyEngineId: String, policyGenerationArn: String, policyGenerationId: String, resource: Resource, status: PolicyGenerationStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.findings = findings
            self.name = name
            self.policyEngineId = policyEngineId
            self.policyGenerationArn = policyGenerationArn
            self.policyGenerationId = policyGenerationId
            self.resource = resource
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case findings = "findings"
            case name = "name"
            case policyEngineId = "policyEngineId"
            case policyGenerationArn = "policyGenerationArn"
            case policyGenerationId = "policyGenerationId"
            case resource = "resource"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct StrategyConfiguration: AWSDecodableShape {
        /// The consolidation configuration for the memory strategy.
        public let consolidation: ConsolidationConfiguration?
        /// The extraction configuration for the memory strategy.
        public let extraction: ExtractionConfiguration?
        /// The reflection configuration for the memory strategy.
        public let reflection: ReflectionConfiguration?
        /// Self-managed configuration settings.
        public let selfManagedConfiguration: SelfManagedConfiguration?
        /// The type of override for the strategy configuration.
        public let type: OverrideType?

        @inlinable
        public init(consolidation: ConsolidationConfiguration? = nil, extraction: ExtractionConfiguration? = nil, reflection: ReflectionConfiguration? = nil, selfManagedConfiguration: SelfManagedConfiguration? = nil, type: OverrideType? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
            self.reflection = reflection
            self.selfManagedConfiguration = selfManagedConfiguration
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
            case reflection = "reflection"
            case selfManagedConfiguration = "selfManagedConfiguration"
            case type = "type"
        }
    }

    public struct SummaryConsolidationOverride: AWSDecodableShape {
        /// The text to append to the prompt for summary consolidation.
        public let appendToPrompt: String
        /// The model ID to use for summary consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SummaryMemoryStrategyInput: AWSEncodableShape {
        /// The description of the summary memory strategy.
        public let description: String?
        /// The name of the summary memory strategy.
        public let name: String
        /// The namespaces associated with the summary memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct SummaryOverrideConfigurationInput: AWSEncodableShape {
        /// The consolidation configuration for a summary override.
        public let consolidation: SummaryOverrideConsolidationConfigurationInput?

        @inlinable
        public init(consolidation: SummaryOverrideConsolidationConfigurationInput? = nil) {
            self.consolidation = consolidation
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
        }
    }

    public struct SummaryOverrideConsolidationConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for summary consolidation.
        public let appendToPrompt: String
        /// The model ID to use for summary consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct SynchronizeGatewayTargetsRequest: AWSEncodableShape {
        /// The gateway Identifier.
        public let gatewayIdentifier: String
        /// The target ID list.
        public let targetIdList: [String]

        @inlinable
        public init(gatewayIdentifier: String, targetIdList: [String]) {
            self.gatewayIdentifier = gatewayIdentifier
            self.targetIdList = targetIdList
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            try container.encode(self.targetIdList, forKey: .targetIdList)
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.targetIdList.forEach {
                try validate($0, name: "targetIdList[]", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
            }
            try self.validate(self.targetIdList, name: "targetIdList", parent: name, max: 1)
            try self.validate(self.targetIdList, name: "targetIdList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetIdList = "targetIdList"
        }
    }

    public struct SynchronizeGatewayTargetsResponse: AWSDecodableShape {
        /// The gateway targets for synchronization.
        public let targets: [GatewayTarget]?

        @inlinable
        public init(targets: [GatewayTarget]? = nil) {
            self.targets = targets
        }

        private enum CodingKeys: String, CodingKey {
            case targets = "targets"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is a key-value pair.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(?:[^:]+)?:bedrock-agentcore:[a-z0-9-]+:[0-9]{12}:([a-z-]+/[^/]+)(?:/[a-z-]+/[^/]+)*$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetSummary: AWSDecodableShape {
        /// The timestamp when the target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the target.
        public let description: String?
        /// The name of the target.
        public let name: String
        /// The current status of the target.
        public let status: TargetStatus
        /// The unique identifier of the target.
        public let targetId: String
        /// The timestamp when the target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, name: String, status: TargetStatus, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.status = status
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case name = "name"
            case status = "status"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct TimeBasedTrigger: AWSDecodableShape {
        /// Idle session timeout (seconds) that triggers memory processing.
        public let idleSessionTimeout: Int?

        @inlinable
        public init(idleSessionTimeout: Int? = nil) {
            self.idleSessionTimeout = idleSessionTimeout
        }

        private enum CodingKeys: String, CodingKey {
            case idleSessionTimeout = "idleSessionTimeout"
        }
    }

    public struct TimeBasedTriggerInput: AWSEncodableShape {
        /// Idle session timeout (seconds) that triggers memory processing.
        public let idleSessionTimeout: Int?

        @inlinable
        public init(idleSessionTimeout: Int? = nil) {
            self.idleSessionTimeout = idleSessionTimeout
        }

        private enum CodingKeys: String, CodingKey {
            case idleSessionTimeout = "idleSessionTimeout"
        }
    }

    public struct TokenBasedTrigger: AWSDecodableShape {
        /// Number of tokens that trigger memory processing.
        public let tokenCount: Int?

        @inlinable
        public init(tokenCount: Int? = nil) {
            self.tokenCount = tokenCount
        }

        private enum CodingKeys: String, CodingKey {
            case tokenCount = "tokenCount"
        }
    }

    public struct TokenBasedTriggerInput: AWSEncodableShape {
        /// Number of tokens that trigger memory processing.
        public let tokenCount: Int?

        @inlinable
        public init(tokenCount: Int? = nil) {
            self.tokenCount = tokenCount
        }

        private enum CodingKeys: String, CodingKey {
            case tokenCount = "tokenCount"
        }
    }

    public struct ToolDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The description of the tool. This description provides information about the purpose and usage of the tool.
        public let description: String
        /// The input schema for the tool. This schema defines the structure of the input that the tool accepts.
        public let inputSchema: SchemaDefinition
        /// The name of the tool. This name identifies the tool in the Model Context Protocol.
        public let name: String
        /// The output schema for the tool. This schema defines the structure of the output that the tool produces.
        public let outputSchema: SchemaDefinition?

        @inlinable
        public init(description: String, inputSchema: SchemaDefinition, name: String, outputSchema: SchemaDefinition? = nil) {
            self.description = description
            self.inputSchema = inputSchema
            self.name = name
            self.outputSchema = outputSchema
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case inputSchema = "inputSchema"
            case name = "name"
            case outputSchema = "outputSchema"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        /// The tag keys of the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(?:[^:]+)?:bedrock-agentcore:[a-z0-9-]+:[0-9]{12}:([a-z-]+/[^/]+)(?:/[a-z-]+/[^/]+)*$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAgentRuntimeEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the AgentCore Runtime associated with the endpoint.
        public let agentRuntimeId: String
        /// The updated version of the AgentCore Runtime for the endpoint.
        public let agentRuntimeVersion: String?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The updated description of the AgentCore Runtime endpoint.
        public let description: String?
        /// The name of the AgentCore Runtime endpoint to update.
        public let endpointName: String

        @inlinable
        public init(agentRuntimeId: String, agentRuntimeVersion: String? = nil, clientToken: String? = UpdateAgentRuntimeEndpointRequest.idempotencyToken(), description: String? = nil, endpointName: String) {
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.clientToken = clientToken
            self.description = description
            self.endpointName = endpointName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            try container.encodeIfPresent(self.agentRuntimeVersion, forKey: .agentRuntimeVersion)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.endpointName, key: "endpointName")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, max: 5)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, min: 1)
            try self.validate(self.agentRuntimeVersion, name: "agentRuntimeVersion", parent: name, pattern: "^([1-9][0-9]{0,4})$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.endpointName, name: "endpointName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeVersion = "agentRuntimeVersion"
            case clientToken = "clientToken"
            case description = "description"
        }
    }

    public struct UpdateAgentRuntimeEndpointResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The Amazon Resource Name (ARN) of the AgentCore Runtime endpoint.
        public let agentRuntimeEndpointArn: String
        /// The timestamp when the AgentCore Runtime endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the AgentCore Runtime endpoint was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The currently deployed version of the AgentCore Runtime on the endpoint.
        public let liveVersion: String?
        /// The current status of the updated AgentCore Runtime endpoint.
        public let status: AgentRuntimeEndpointStatus
        /// The target version of the AgentCore Runtime for the endpoint.
        public let targetVersion: String?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeEndpointArn: String, createdAt: Date, lastUpdatedAt: Date, liveVersion: String? = nil, status: AgentRuntimeEndpointStatus, targetVersion: String? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeEndpointArn = agentRuntimeEndpointArn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.liveVersion = liveVersion
            self.status = status
            self.targetVersion = targetVersion
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeEndpointArn = "agentRuntimeEndpointArn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case liveVersion = "liveVersion"
            case status = "status"
            case targetVersion = "targetVersion"
        }
    }

    public struct UpdateAgentRuntimeRequest: AWSEncodableShape {
        /// The updated artifact of the AgentCore Runtime.
        public let agentRuntimeArtifact: AgentRuntimeArtifact
        /// The unique identifier of the AgentCore Runtime to update.
        public let agentRuntimeId: String
        /// The updated authorizer configuration for the AgentCore Runtime.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The updated description of the AgentCore Runtime.
        public let description: String?
        /// Updated environment variables to set in the AgentCore Runtime environment.
        public let environmentVariables: [String: String]?
        /// The updated life cycle configuration for the AgentCore Runtime.
        public let lifecycleConfiguration: LifecycleConfiguration?
        /// The updated network configuration for the AgentCore Runtime.
        public let networkConfiguration: NetworkConfiguration
        public let protocolConfiguration: ProtocolConfiguration?
        /// The updated configuration for HTTP request headers that will be passed through to the runtime.
        public let requestHeaderConfiguration: RequestHeaderConfiguration?
        /// The updated IAM role ARN that provides permissions for the AgentCore Runtime.
        public let roleArn: String

        @inlinable
        public init(agentRuntimeArtifact: AgentRuntimeArtifact, agentRuntimeId: String, authorizerConfiguration: AuthorizerConfiguration? = nil, clientToken: String? = UpdateAgentRuntimeRequest.idempotencyToken(), description: String? = nil, environmentVariables: [String: String]? = nil, lifecycleConfiguration: LifecycleConfiguration? = nil, networkConfiguration: NetworkConfiguration, protocolConfiguration: ProtocolConfiguration? = nil, requestHeaderConfiguration: RequestHeaderConfiguration? = nil, roleArn: String) {
            self.agentRuntimeArtifact = agentRuntimeArtifact
            self.agentRuntimeId = agentRuntimeId
            self.authorizerConfiguration = authorizerConfiguration
            self.clientToken = clientToken
            self.description = description
            self.environmentVariables = environmentVariables
            self.lifecycleConfiguration = lifecycleConfiguration
            self.networkConfiguration = networkConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.requestHeaderConfiguration = requestHeaderConfiguration
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.agentRuntimeArtifact, forKey: .agentRuntimeArtifact)
            request.encodePath(self.agentRuntimeId, key: "agentRuntimeId")
            try container.encodeIfPresent(self.authorizerConfiguration, forKey: .authorizerConfiguration)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.environmentVariables, forKey: .environmentVariables)
            try container.encodeIfPresent(self.lifecycleConfiguration, forKey: .lifecycleConfiguration)
            try container.encode(self.networkConfiguration, forKey: .networkConfiguration)
            try container.encodeIfPresent(self.protocolConfiguration, forKey: .protocolConfiguration)
            try container.encodeIfPresent(self.requestHeaderConfiguration, forKey: .requestHeaderConfiguration)
            try container.encode(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.agentRuntimeArtifact.validate(name: "\(name).agentRuntimeArtifact")
            try self.validate(self.agentRuntimeId, name: "agentRuntimeId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.authorizerConfiguration?.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 100)
                try validate($0.key, name: "environmentVariables.key", parent: name, min: 1)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 5000)
            }
            try self.validate(self.environmentVariables, name: "environmentVariables", parent: name, max: 50)
            try self.networkConfiguration.validate(name: "\(name).networkConfiguration")
            try self.requestHeaderConfiguration?.validate(name: "\(name).requestHeaderConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArtifact = "agentRuntimeArtifact"
            case authorizerConfiguration = "authorizerConfiguration"
            case clientToken = "clientToken"
            case description = "description"
            case environmentVariables = "environmentVariables"
            case lifecycleConfiguration = "lifecycleConfiguration"
            case networkConfiguration = "networkConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case requestHeaderConfiguration = "requestHeaderConfiguration"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateAgentRuntimeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated AgentCore Runtime.
        public let agentRuntimeArn: String
        /// The unique identifier of the updated AgentCore Runtime.
        public let agentRuntimeId: String
        /// The version of the updated AgentCore Runtime.
        public let agentRuntimeVersion: String
        /// The timestamp when the AgentCore Runtime was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the AgentCore Runtime was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The current status of the updated AgentCore Runtime.
        public let status: AgentRuntimeStatus
        /// The workload identity details for the updated AgentCore Runtime.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(agentRuntimeArn: String, agentRuntimeId: String, agentRuntimeVersion: String, createdAt: Date, lastUpdatedAt: Date, status: AgentRuntimeStatus, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.agentRuntimeArn = agentRuntimeArn
            self.agentRuntimeId = agentRuntimeId
            self.agentRuntimeVersion = agentRuntimeVersion
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case agentRuntimeArn = "agentRuntimeArn"
            case agentRuntimeId = "agentRuntimeId"
            case agentRuntimeVersion = "agentRuntimeVersion"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct UpdateApiKeyCredentialProviderRequest: AWSEncodableShape {
        /// The new API key to use for authentication. This value replaces the existing API key and is encrypted and stored securely.
        public let apiKey: String
        /// The name of the API key credential provider to update.
        public let name: String

        @inlinable
        public init(apiKey: String, name: String) {
            self.apiKey = apiKey
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 65536)
            try self.validate(self.apiKey, name: "apiKey", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case name = "name"
        }
    }

    public struct UpdateApiKeyCredentialProviderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the API key secret in AWS Secrets Manager.
        public let apiKeySecretArn: Secret
        /// The timestamp when the API key credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the API key credential provider.
        public let credentialProviderArn: String
        /// The timestamp when the API key credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the API key credential provider.
        public let name: String

        @inlinable
        public init(apiKeySecretArn: Secret, createdTime: Date, credentialProviderArn: String, lastUpdatedTime: Date, name: String) {
            self.apiKeySecretArn = apiKeySecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySecretArn = "apiKeySecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct UpdateEvaluatorRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        ///  The updated description of the evaluator.
        public let description: String?
        ///  The updated configuration for the evaluator, including LLM-as-a-Judge settings with instructions, rating scale, and model configuration.
        public let evaluatorConfig: EvaluatorConfig?
        ///  The unique identifier of the evaluator to update.
        public let evaluatorId: String
        ///  The updated evaluation level (TOOL_CALL, TRACE, or SESSION) that determines the scope of evaluation.
        public let level: EvaluatorLevel?

        @inlinable
        public init(clientToken: String? = UpdateEvaluatorRequest.idempotencyToken(), description: String? = nil, evaluatorConfig: EvaluatorConfig? = nil, evaluatorId: String, level: EvaluatorLevel? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.evaluatorConfig = evaluatorConfig
            self.evaluatorId = evaluatorId
            self.level = level
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.evaluatorConfig, forKey: .evaluatorConfig)
            request.encodePath(self.evaluatorId, key: "evaluatorId")
            try container.encodeIfPresent(self.level, forKey: .level)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.evaluatorConfig?.validate(name: "\(name).evaluatorConfig")
            try self.validate(self.evaluatorId, name: "evaluatorId", parent: name, pattern: "^(Builtin.[a-zA-Z0-9_-]+|[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case evaluatorConfig = "evaluatorConfig"
            case level = "level"
        }
    }

    public struct UpdateEvaluatorResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the updated evaluator.
        public let evaluatorArn: String
        ///  The unique identifier of the updated evaluator.
        public let evaluatorId: String
        ///  The status of the evaluator update operation.
        public let status: EvaluatorStatus
        ///  The timestamp when the evaluator was last updated.
        public let updatedAt: Date

        @inlinable
        public init(evaluatorArn: String, evaluatorId: String, status: EvaluatorStatus, updatedAt: Date) {
            self.evaluatorArn = evaluatorArn
            self.evaluatorId = evaluatorId
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case evaluatorArn = "evaluatorArn"
            case evaluatorId = "evaluatorId"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateGatewayRequest: AWSEncodableShape {
        /// The updated authorizer configuration for the gateway.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The updated authorizer type for the gateway.
        public let authorizerType: AuthorizerType
        /// The updated description for the gateway.
        public let description: String?
        /// The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
        public let exceptionLevel: ExceptionLevel?
        /// The identifier of the gateway to update.
        public let gatewayIdentifier: String
        /// The updated interceptor configurations for the gateway.
        public let interceptorConfigurations: [GatewayInterceptorConfiguration]?
        /// The updated ARN of the KMS key used to encrypt the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway. This name must be the same as the one when the gateway was created.
        public let name: String
        /// The updated policy engine configuration for the gateway. A policy engine is a collection of policies that evaluates and authorizes agent tool calls. When associated with a gateway, the policy engine intercepts all agent requests and determines whether to allow or deny each action based on the defined policies.
        public let policyEngineConfiguration: GatewayPolicyEngineConfiguration?
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The updated protocol type for the gateway.
        public let protocolType: GatewayProtocolType
        /// The updated IAM role ARN that provides permissions for the gateway.
        public let roleArn: String

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayIdentifier: String, interceptorConfigurations: [GatewayInterceptorConfiguration]? = nil, kmsKeyArn: String? = nil, name: String, policyEngineConfiguration: GatewayPolicyEngineConfiguration? = nil, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayIdentifier = gatewayIdentifier
            self.interceptorConfigurations = interceptorConfigurations
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.policyEngineConfiguration = policyEngineConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authorizerConfiguration, forKey: .authorizerConfiguration)
            try container.encode(self.authorizerType, forKey: .authorizerType)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.exceptionLevel, forKey: .exceptionLevel)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            try container.encodeIfPresent(self.interceptorConfigurations, forKey: .interceptorConfigurations)
            try container.encodeIfPresent(self.kmsKeyArn, forKey: .kmsKeyArn)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.policyEngineConfiguration, forKey: .policyEngineConfiguration)
            try container.encodeIfPresent(self.protocolConfiguration, forKey: .protocolConfiguration)
            try container.encode(self.protocolType, forKey: .protocolType)
            try container.encode(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.authorizerConfiguration?.validate(name: "\(name).authorizerConfiguration")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.interceptorConfigurations?.forEach {
                try $0.validate(name: "\(name).interceptorConfigurations[]")
            }
            try self.validate(self.interceptorConfigurations, name: "interceptorConfigurations", parent: name, max: 2)
            try self.validate(self.interceptorConfigurations, name: "interceptorConfigurations", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.policyEngineConfiguration?.validate(name: "\(name).policyEngineConfiguration")
            try self.protocolConfiguration?.validate(name: "\(name).protocolConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case interceptorConfigurations = "interceptorConfigurations"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case policyEngineConfiguration = "policyEngineConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateGatewayResponse: AWSDecodableShape {
        /// The updated authorizer configuration for the gateway.
        public let authorizerConfiguration: AuthorizerConfiguration?
        /// The updated authorizer type for the gateway.
        public let authorizerType: AuthorizerType
        /// The timestamp when the gateway was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The updated description of the gateway.
        public let description: String?
        /// The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
        public let exceptionLevel: ExceptionLevel?
        /// The Amazon Resource Name (ARN) of the updated gateway.
        public let gatewayArn: String
        /// The unique identifier of the updated gateway.
        public let gatewayId: String
        /// An endpoint for invoking the updated gateway.
        public let gatewayUrl: String?
        /// The updated interceptor configurations for the gateway.
        public let interceptorConfigurations: [GatewayInterceptorConfiguration]?
        /// The updated ARN of the KMS key used to encrypt the gateway.
        public let kmsKeyArn: String?
        /// The name of the gateway.
        public let name: String
        /// The updated policy engine configuration for the gateway.
        public let policyEngineConfiguration: GatewayPolicyEngineConfiguration?
        public let protocolConfiguration: GatewayProtocolConfiguration?
        /// The updated protocol type for the gateway.
        public let protocolType: GatewayProtocolType
        /// The updated IAM role ARN that provides permissions for the gateway.
        public let roleArn: String?
        /// The current status of the updated gateway.
        public let status: GatewayStatus
        /// The reasons for the current status of the updated gateway.
        public let statusReasons: [String]?
        /// The timestamp when the gateway was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The workload identity details for the updated gateway.
        public let workloadIdentityDetails: WorkloadIdentityDetails?

        @inlinable
        public init(authorizerConfiguration: AuthorizerConfiguration? = nil, authorizerType: AuthorizerType, createdAt: Date, description: String? = nil, exceptionLevel: ExceptionLevel? = nil, gatewayArn: String, gatewayId: String, gatewayUrl: String? = nil, interceptorConfigurations: [GatewayInterceptorConfiguration]? = nil, kmsKeyArn: String? = nil, name: String, policyEngineConfiguration: GatewayPolicyEngineConfiguration? = nil, protocolConfiguration: GatewayProtocolConfiguration? = nil, protocolType: GatewayProtocolType, roleArn: String? = nil, status: GatewayStatus, statusReasons: [String]? = nil, updatedAt: Date, workloadIdentityDetails: WorkloadIdentityDetails? = nil) {
            self.authorizerConfiguration = authorizerConfiguration
            self.authorizerType = authorizerType
            self.createdAt = createdAt
            self.description = description
            self.exceptionLevel = exceptionLevel
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
            self.gatewayUrl = gatewayUrl
            self.interceptorConfigurations = interceptorConfigurations
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.policyEngineConfiguration = policyEngineConfiguration
            self.protocolConfiguration = protocolConfiguration
            self.protocolType = protocolType
            self.roleArn = roleArn
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
            self.workloadIdentityDetails = workloadIdentityDetails
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerConfiguration = "authorizerConfiguration"
            case authorizerType = "authorizerType"
            case createdAt = "createdAt"
            case description = "description"
            case exceptionLevel = "exceptionLevel"
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
            case gatewayUrl = "gatewayUrl"
            case interceptorConfigurations = "interceptorConfigurations"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case policyEngineConfiguration = "policyEngineConfiguration"
            case protocolConfiguration = "protocolConfiguration"
            case protocolType = "protocolType"
            case roleArn = "roleArn"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
            case workloadIdentityDetails = "workloadIdentityDetails"
        }
    }

    public struct UpdateGatewayTargetRequest: AWSEncodableShape {
        /// The updated credential provider configurations for the gateway target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]?
        /// The updated description for the gateway target.
        public let description: String?
        /// The unique identifier of the gateway associated with the target.
        public let gatewayIdentifier: String
        /// The updated name for the gateway target.
        public let name: String
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the gateway target to update.
        public let targetId: String

        @inlinable
        public init(credentialProviderConfigurations: [CredentialProviderConfiguration]? = nil, description: String? = nil, gatewayIdentifier: String, name: String, targetConfiguration: TargetConfiguration, targetId: String) {
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayIdentifier = gatewayIdentifier
            self.name = name
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.credentialProviderConfigurations, forKey: .credentialProviderConfigurations)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.gatewayIdentifier, key: "gatewayIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.targetConfiguration, forKey: .targetConfiguration)
            request.encodePath(self.targetId, key: "targetId")
        }

        public func validate(name: String) throws {
            try self.credentialProviderConfigurations?.forEach {
                try $0.validate(name: "\(name).credentialProviderConfigurations[]")
            }
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, max: 1)
            try self.validate(self.credentialProviderConfigurations, name: "credentialProviderConfigurations", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.gatewayIdentifier, name: "gatewayIdentifier", parent: name, pattern: "^([0-9a-z][-]?){1,100}-[0-9a-z]{10}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][-]?){1,100}$")
            try self.targetConfiguration.validate(name: "\(name).targetConfiguration")
            try self.validate(self.targetId, name: "targetId", parent: name, pattern: "^[0-9a-zA-Z]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case name = "name"
            case targetConfiguration = "targetConfiguration"
        }
    }

    public struct UpdateGatewayTargetResponse: AWSDecodableShape {
        /// The timestamp when the gateway target was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The updated credential provider configurations for the gateway target.
        public let credentialProviderConfigurations: [CredentialProviderConfiguration]
        /// The updated description of the gateway target.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the gateway.
        public let gatewayArn: String
        /// The date and time at which the targets were last synchronized.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastSynchronizedAt: Date?
        /// The updated name of the gateway target.
        public let name: String
        /// The current status of the updated gateway target.
        public let status: TargetStatus
        /// The reasons for the current status of the updated gateway target.
        public let statusReasons: [String]?
        public let targetConfiguration: TargetConfiguration
        /// The unique identifier of the updated gateway target.
        public let targetId: String
        /// The timestamp when the gateway target was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, credentialProviderConfigurations: [CredentialProviderConfiguration], description: String? = nil, gatewayArn: String, lastSynchronizedAt: Date? = nil, name: String, status: TargetStatus, statusReasons: [String]? = nil, targetConfiguration: TargetConfiguration, targetId: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.credentialProviderConfigurations = credentialProviderConfigurations
            self.description = description
            self.gatewayArn = gatewayArn
            self.lastSynchronizedAt = lastSynchronizedAt
            self.name = name
            self.status = status
            self.statusReasons = statusReasons
            self.targetConfiguration = targetConfiguration
            self.targetId = targetId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialProviderConfigurations = "credentialProviderConfigurations"
            case description = "description"
            case gatewayArn = "gatewayArn"
            case lastSynchronizedAt = "lastSynchronizedAt"
            case name = "name"
            case status = "status"
            case statusReasons = "statusReasons"
            case targetConfiguration = "targetConfiguration"
            case targetId = "targetId"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateMemoryInput: AWSEncodableShape {
        /// A client token is used for keeping track of idempotent requests. It can contain a session id which can be around 250 chars, combined with a unique AWS identifier.
        public let clientToken: String?
        /// The updated description of the AgentCore Memory resource.
        public let description: String?
        /// The number of days after which memory events will expire, between 7 and 365 days.
        public let eventExpiryDuration: Int?
        /// The ARN of the IAM role that provides permissions for the AgentCore Memory resource.
        public let memoryExecutionRoleArn: String?
        /// The unique identifier of the memory to update.
        public let memoryId: String
        /// The memory strategies to add, modify, or delete.
        public let memoryStrategies: ModifyMemoryStrategies?

        @inlinable
        public init(clientToken: String? = UpdateMemoryInput.idempotencyToken(), description: String? = nil, eventExpiryDuration: Int? = nil, memoryExecutionRoleArn: String? = nil, memoryId: String, memoryStrategies: ModifyMemoryStrategies? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.eventExpiryDuration = eventExpiryDuration
            self.memoryExecutionRoleArn = memoryExecutionRoleArn
            self.memoryId = memoryId
            self.memoryStrategies = memoryStrategies
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.eventExpiryDuration, forKey: .eventExpiryDuration)
            try container.encodeIfPresent(self.memoryExecutionRoleArn, forKey: .memoryExecutionRoleArn)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.memoryStrategies, forKey: .memoryStrategies)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.memoryExecutionRoleArn, name: "memoryExecutionRoleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.memoryStrategies?.validate(name: "\(name).memoryStrategies")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case eventExpiryDuration = "eventExpiryDuration"
            case memoryExecutionRoleArn = "memoryExecutionRoleArn"
            case memoryStrategies = "memoryStrategies"
        }
    }

    public struct UpdateMemoryOutput: AWSDecodableShape {
        /// The updated AgentCore Memory resource details.
        public let memory: Memory?

        @inlinable
        public init(memory: Memory? = nil) {
            self.memory = memory
        }

        private enum CodingKeys: String, CodingKey {
            case memory = "memory"
        }
    }

    public struct UpdateOauth2CredentialProviderRequest: AWSEncodableShape {
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The name of the OAuth2 credential provider to update.
        public let name: String
        /// The configuration input for the OAuth2 provider.
        public let oauth2ProviderConfigInput: Oauth2ProviderConfigInput

        @inlinable
        public init(credentialProviderVendor: CredentialProviderVendorType, name: String, oauth2ProviderConfigInput: Oauth2ProviderConfigInput) {
            self.credentialProviderVendor = credentialProviderVendor
            self.name = name
            self.oauth2ProviderConfigInput = oauth2ProviderConfigInput
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.oauth2ProviderConfigInput.validate(name: "\(name).oauth2ProviderConfigInput")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialProviderVendor = "credentialProviderVendor"
            case name = "name"
            case oauth2ProviderConfigInput = "oauth2ProviderConfigInput"
        }
    }

    public struct UpdateOauth2CredentialProviderResponse: AWSDecodableShape {
        /// Callback URL to register on the OAuth2 credential provider as an allowed callback URL. This URL is where the OAuth2 authorization server redirects users after they complete the authorization flow.
        public let callbackUrl: String?
        /// The Amazon Resource Name (ARN) of the client secret in AWS Secrets Manager.
        public let clientSecretArn: Secret
        /// The timestamp when the OAuth2 credential provider was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) of the OAuth2 credential provider.
        public let credentialProviderArn: String
        /// The vendor of the OAuth2 credential provider.
        public let credentialProviderVendor: CredentialProviderVendorType
        /// The timestamp when the OAuth2 credential provider was last updated.
        public let lastUpdatedTime: Date
        /// The name of the OAuth2 credential provider.
        public let name: String
        /// The configuration output for the OAuth2 provider.
        public let oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput

        @inlinable
        public init(callbackUrl: String? = nil, clientSecretArn: Secret, createdTime: Date, credentialProviderArn: String, credentialProviderVendor: CredentialProviderVendorType, lastUpdatedTime: Date, name: String, oauth2ProviderConfigOutput: Oauth2ProviderConfigOutput) {
            self.callbackUrl = callbackUrl
            self.clientSecretArn = clientSecretArn
            self.createdTime = createdTime
            self.credentialProviderArn = credentialProviderArn
            self.credentialProviderVendor = credentialProviderVendor
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.oauth2ProviderConfigOutput = oauth2ProviderConfigOutput
        }

        private enum CodingKeys: String, CodingKey {
            case callbackUrl = "callbackUrl"
            case clientSecretArn = "clientSecretArn"
            case createdTime = "createdTime"
            case credentialProviderArn = "credentialProviderArn"
            case credentialProviderVendor = "credentialProviderVendor"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case oauth2ProviderConfigOutput = "oauth2ProviderConfigOutput"
        }
    }

    public struct UpdateOnlineEvaluationConfigRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
        public let clientToken: String?
        ///  The updated data source configuration specifying CloudWatch log groups and service names to monitor.
        public let dataSourceConfig: DataSourceConfig?
        ///  The updated description of the online evaluation configuration.
        public let description: String?
        ///  The updated Amazon Resource Name (ARN) of the IAM role used for evaluation execution.
        public let evaluationExecutionRoleArn: String?
        ///  The updated list of evaluators to apply during online evaluation.
        public let evaluators: [EvaluatorReference]?
        ///  The updated execution status to enable or disable the online evaluation.
        public let executionStatus: OnlineEvaluationExecutionStatus?
        ///  The unique identifier of the online evaluation configuration to update.
        public let onlineEvaluationConfigId: String
        ///  The updated evaluation rule containing sampling configuration, filters, and session settings.
        public let rule: Rule?

        @inlinable
        public init(clientToken: String? = UpdateOnlineEvaluationConfigRequest.idempotencyToken(), dataSourceConfig: DataSourceConfig? = nil, description: String? = nil, evaluationExecutionRoleArn: String? = nil, evaluators: [EvaluatorReference]? = nil, executionStatus: OnlineEvaluationExecutionStatus? = nil, onlineEvaluationConfigId: String, rule: Rule? = nil) {
            self.clientToken = clientToken
            self.dataSourceConfig = dataSourceConfig
            self.description = description
            self.evaluationExecutionRoleArn = evaluationExecutionRoleArn
            self.evaluators = evaluators
            self.executionStatus = executionStatus
            self.onlineEvaluationConfigId = onlineEvaluationConfigId
            self.rule = rule
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.dataSourceConfig, forKey: .dataSourceConfig)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.evaluationExecutionRoleArn, forKey: .evaluationExecutionRoleArn)
            try container.encodeIfPresent(self.evaluators, forKey: .evaluators)
            try container.encodeIfPresent(self.executionStatus, forKey: .executionStatus)
            request.encodePath(self.onlineEvaluationConfigId, key: "onlineEvaluationConfigId")
            try container.encodeIfPresent(self.rule, forKey: .rule)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.dataSourceConfig?.validate(name: "\(name).dataSourceConfig")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.validate(self.evaluationExecutionRoleArn, name: "evaluationExecutionRoleArn", parent: name, max: 2048)
            try self.validate(self.evaluationExecutionRoleArn, name: "evaluationExecutionRoleArn", parent: name, min: 1)
            try self.validate(self.evaluationExecutionRoleArn, name: "evaluationExecutionRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.evaluators?.forEach {
                try $0.validate(name: "\(name).evaluators[]")
            }
            try self.validate(self.evaluators, name: "evaluators", parent: name, max: 10)
            try self.validate(self.evaluators, name: "evaluators", parent: name, min: 1)
            try self.validate(self.onlineEvaluationConfigId, name: "onlineEvaluationConfigId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.rule?.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dataSourceConfig = "dataSourceConfig"
            case description = "description"
            case evaluationExecutionRoleArn = "evaluationExecutionRoleArn"
            case evaluators = "evaluators"
            case executionStatus = "executionStatus"
            case rule = "rule"
        }
    }

    public struct UpdateOnlineEvaluationConfigResponse: AWSDecodableShape {
        ///  The execution status indicating whether the online evaluation is currently running.
        public let executionStatus: OnlineEvaluationExecutionStatus
        ///  The reason for failure if the online evaluation configuration update or execution failed.
        public let failureReason: String?
        ///  The Amazon Resource Name (ARN) of the updated online evaluation configuration.
        public let onlineEvaluationConfigArn: String
        ///  The unique identifier of the updated online evaluation configuration.
        public let onlineEvaluationConfigId: String
        ///  The status of the online evaluation configuration.
        public let status: OnlineEvaluationConfigStatus
        ///  The timestamp when the online evaluation configuration was last updated.
        public let updatedAt: Date

        @inlinable
        public init(executionStatus: OnlineEvaluationExecutionStatus, failureReason: String? = nil, onlineEvaluationConfigArn: String, onlineEvaluationConfigId: String, status: OnlineEvaluationConfigStatus, updatedAt: Date) {
            self.executionStatus = executionStatus
            self.failureReason = failureReason
            self.onlineEvaluationConfigArn = onlineEvaluationConfigArn
            self.onlineEvaluationConfigId = onlineEvaluationConfigId
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case executionStatus = "executionStatus"
            case failureReason = "failureReason"
            case onlineEvaluationConfigArn = "onlineEvaluationConfigArn"
            case onlineEvaluationConfigId = "onlineEvaluationConfigId"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdatePolicyEngineRequest: AWSEncodableShape {
        /// The new description for the policy engine.
        public let description: String?
        /// The unique identifier of the policy engine to be updated.
        public let policyEngineId: String

        @inlinable
        public init(description: String? = nil, policyEngineId: String) {
            self.description = description
            self.policyEngineId = policyEngineId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.policyEngineId, key: "policyEngineId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdatePolicyEngineResponse: AWSDecodableShape {
        /// The original creation timestamp of the policy engine.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The updated description of the policy engine.
        public let description: String?
        /// The name of the updated policy engine.
        public let name: String
        /// The ARN of the updated policy engine.
        public let policyEngineArn: String
        /// The unique identifier of the updated policy engine.
        public let policyEngineId: String
        /// The current status of the updated policy engine.
        public let status: PolicyEngineStatus
        /// Additional information about the update status.
        public let statusReasons: [String]
        /// The timestamp when the policy engine was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, description: String? = nil, name: String, policyEngineArn: String, policyEngineId: String, status: PolicyEngineStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.policyEngineArn = policyEngineArn
            self.policyEngineId = policyEngineId
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case name = "name"
            case policyEngineArn = "policyEngineArn"
            case policyEngineId = "policyEngineId"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdatePolicyRequest: AWSEncodableShape {
        /// The new Cedar policy statement that defines the access control rules. This replaces the existing policy definition with new logic while maintaining the policy's identity.
        public let definition: PolicyDefinition
        /// The new human-readable description for the policy. This optional field allows updating the policy's documentation while keeping the same policy logic.
        public let description: String?
        /// The identifier of the policy engine that manages the policy to be updated. This ensures the policy is updated within the correct policy engine context.
        public let policyEngineId: String
        /// The unique identifier of the policy to be updated. This must be a valid policy ID that exists within the specified policy engine.
        public let policyId: String
        /// The validation mode for the policy update. Determines how Cedar analyzer validation results are handled during policy updates. FAIL_ON_ANY_FINDINGS runs the Cedar analyzer and fails the update if validation issues are detected, ensuring the policy conforms to the Cedar schema and tool context. IGNORE_ALL_FINDINGS runs the Cedar analyzer but allows updates despite validation warnings. Use FAIL_ON_ANY_FINDINGS to ensure policy correctness during updates, especially when modifying policy logic or conditions.
        public let validationMode: PolicyValidationMode?

        @inlinable
        public init(definition: PolicyDefinition, description: String? = nil, policyEngineId: String, policyId: String, validationMode: PolicyValidationMode? = nil) {
            self.definition = definition
            self.description = description
            self.policyEngineId = policyEngineId
            self.policyId = policyId
            self.validationMode = validationMode
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.definition, forKey: .definition)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.policyEngineId, key: "policyEngineId")
            request.encodePath(self.policyId, key: "policyId")
            try container.encodeIfPresent(self.validationMode, forKey: .validationMode)
        }

        public func validate(name: String) throws {
            try self.definition.validate(name: "\(name).definition")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, max: 59)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, min: 12)
            try self.validate(self.policyEngineId, name: "policyEngineId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
            try self.validate(self.policyId, name: "policyId", parent: name, max: 59)
            try self.validate(self.policyId, name: "policyId", parent: name, min: 12)
            try self.validate(self.policyId, name: "policyId", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_]*-[a-z0-9_]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case description = "description"
            case validationMode = "validationMode"
        }
    }

    public struct UpdatePolicyResponse: AWSDecodableShape {
        /// The original creation timestamp of the policy.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The updated Cedar policy statement.
        public let definition: PolicyDefinition
        /// The updated description of the policy.
        public let description: String?
        /// The name of the updated policy.
        public let name: String
        /// The ARN of the updated policy.
        public let policyArn: String
        /// The identifier of the policy engine managing the updated policy.
        public let policyEngineId: String
        /// The unique identifier of the updated policy.
        public let policyId: String
        /// The current status of the updated policy.
        public let status: PolicyStatus
        /// Additional information about the update status.
        public let statusReasons: [String]
        /// The timestamp when the policy was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, definition: PolicyDefinition, description: String? = nil, name: String, policyArn: String, policyEngineId: String, policyId: String, status: PolicyStatus, statusReasons: [String], updatedAt: Date) {
            self.createdAt = createdAt
            self.definition = definition
            self.description = description
            self.name = name
            self.policyArn = policyArn
            self.policyEngineId = policyEngineId
            self.policyId = policyId
            self.status = status
            self.statusReasons = statusReasons
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case definition = "definition"
            case description = "description"
            case name = "name"
            case policyArn = "policyArn"
            case policyEngineId = "policyEngineId"
            case policyId = "policyId"
            case status = "status"
            case statusReasons = "statusReasons"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateWorkloadIdentityRequest: AWSEncodableShape {
        /// The new list of allowed OAuth2 return URLs for resources associated with this workload identity. This list replaces the existing list.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The name of the workload identity to update.
        public let name: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, name: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.name = name
        }

        public func validate(name: String) throws {
            try self.allowedResourceOauth2ReturnUrls?.forEach {
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, max: 2048)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, min: 1)
                try validate($0, name: "allowedResourceOauth2ReturnUrls[]", parent: name, pattern: "^\\w+:(\\/?\\/?)[^\\s]+$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case name = "name"
        }
    }

    public struct UpdateWorkloadIdentityResponse: AWSDecodableShape {
        /// The list of allowed OAuth2 return URLs for resources associated with this workload identity.
        public let allowedResourceOauth2ReturnUrls: [String]?
        /// The timestamp when the workload identity was created.
        public let createdTime: Date
        /// The timestamp when the workload identity was last updated.
        public let lastUpdatedTime: Date
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(allowedResourceOauth2ReturnUrls: [String]? = nil, createdTime: Date, lastUpdatedTime: Date, name: String, workloadIdentityArn: String) {
            self.allowedResourceOauth2ReturnUrls = allowedResourceOauth2ReturnUrls
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case allowedResourceOauth2ReturnUrls = "allowedResourceOauth2ReturnUrls"
            case createdTime = "createdTime"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct UserPreferenceConsolidationOverride: AWSDecodableShape {
        /// The text to append to the prompt for user preference consolidation.
        public let appendToPrompt: String
        /// The model ID to use for user preference consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct UserPreferenceExtractionOverride: AWSDecodableShape {
        /// The text to append to the prompt for user preference extraction.
        public let appendToPrompt: String
        /// The model ID to use for user preference extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct UserPreferenceMemoryStrategyInput: AWSEncodableShape {
        /// The description of the user preference memory strategy.
        public let description: String?
        /// The name of the user preference memory strategy.
        public let name: String
        /// The namespaces associated with the user preference memory strategy.
        public let namespaces: [String]?

        @inlinable
        public init(description: String? = nil, name: String, namespaces: [String]? = nil) {
            self.description = description
            self.name = name
            self.namespaces = namespaces
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]{0,47}$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9\\-_\\/]*(\\{(actorId|sessionId|memoryStrategyId)\\}[a-zA-Z0-9\\-_\\/]*)*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case namespaces = "namespaces"
        }
    }

    public struct UserPreferenceOverrideConfigurationInput: AWSEncodableShape {
        /// The consolidation configuration for a user preference override.
        public let consolidation: UserPreferenceOverrideConsolidationConfigurationInput?
        /// The extraction configuration for a user preference override.
        public let extraction: UserPreferenceOverrideExtractionConfigurationInput?

        @inlinable
        public init(consolidation: UserPreferenceOverrideConsolidationConfigurationInput? = nil, extraction: UserPreferenceOverrideExtractionConfigurationInput? = nil) {
            self.consolidation = consolidation
            self.extraction = extraction
        }

        public func validate(name: String) throws {
            try self.consolidation?.validate(name: "\(name).consolidation")
            try self.extraction?.validate(name: "\(name).extraction")
        }

        private enum CodingKeys: String, CodingKey {
            case consolidation = "consolidation"
            case extraction = "extraction"
        }
    }

    public struct UserPreferenceOverrideConsolidationConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for user preference consolidation.
        public let appendToPrompt: String
        /// The model ID to use for user preference consolidation.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct UserPreferenceOverrideExtractionConfigurationInput: AWSEncodableShape {
        /// The text to append to the prompt for user preference extraction.
        public let appendToPrompt: String
        /// The model ID to use for user preference extraction.
        public let modelId: String

        @inlinable
        public init(appendToPrompt: String, modelId: String) {
            self.appendToPrompt = appendToPrompt
            self.modelId = modelId
        }

        public func validate(name: String) throws {
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, max: 30000)
            try self.validate(self.appendToPrompt, name: "appendToPrompt", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appendToPrompt = "appendToPrompt"
            case modelId = "modelId"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message describing why this field failed validation.
        public let message: String
        /// The name of the field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct VpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// The security groups associated with the VPC configuration.
        public let securityGroups: [String]
        /// The subnets associated with the VPC configuration.
        public let subnets: [String]

        @inlinable
        public init(securityGroups: [String], subnets: [String]) {
            self.securityGroups = securityGroups
            self.subnets = subnets
        }

        public func validate(name: String) throws {
            try self.securityGroups.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "^sg-[0-9a-zA-Z]{8,17}$")
            }
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, max: 16)
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, min: 1)
            try self.subnets.forEach {
                try validate($0, name: "subnets[]", parent: name, pattern: "^subnet-[0-9a-zA-Z]{8,17}$")
            }
            try self.validate(self.subnets, name: "subnets", parent: name, max: 16)
            try self.validate(self.subnets, name: "subnets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroups = "securityGroups"
            case subnets = "subnets"
        }
    }

    public struct WorkloadIdentityDetails: AWSDecodableShape {
        /// The ARN associated with the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(workloadIdentityArn: String) {
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct WorkloadIdentityType: AWSDecodableShape {
        /// The name of the workload identity.
        public let name: String
        /// The Amazon Resource Name (ARN) of the workload identity.
        public let workloadIdentityArn: String

        @inlinable
        public init(name: String, workloadIdentityArn: String) {
            self.name = name
            self.workloadIdentityArn = workloadIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case workloadIdentityArn = "workloadIdentityArn"
        }
    }

    public struct AuthorizerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The inbound JWT-based authorization, specifying how incoming requests should be authenticated.
        public let customJWTAuthorizer: CustomJWTAuthorizerConfiguration?

        @inlinable
        public init(customJWTAuthorizer: CustomJWTAuthorizerConfiguration? = nil) {
            self.customJWTAuthorizer = customJWTAuthorizer
        }

        public func validate(name: String) throws {
            try self.customJWTAuthorizer?.validate(name: "\(name).customJWTAuthorizer")
        }

        private enum CodingKeys: String, CodingKey {
            case customJWTAuthorizer = "customJWTAuthorizer"
        }
    }

    public struct Code: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Amazon S3 object that contains the source code for the agent runtime.
        public let s3: S3Location?

        @inlinable
        public init(s3: S3Location? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct ConsolidationConfiguration: AWSDecodableShape {
        /// The custom consolidation configuration.
        public let customConsolidationConfiguration: CustomConsolidationConfiguration?

        @inlinable
        public init(customConsolidationConfiguration: CustomConsolidationConfiguration? = nil) {
            self.customConsolidationConfiguration = customConsolidationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case customConsolidationConfiguration = "customConsolidationConfiguration"
        }
    }

    public struct Content: AWSEncodableShape {
        /// The raw text content containing natural language descriptions of desired policy behavior. This text is processed by AI to generate corresponding Cedar policy statements that match the described intent.
        public let rawText: String?

        @inlinable
        public init(rawText: String? = nil) {
            self.rawText = rawText
        }

        public func validate(name: String) throws {
            try self.validate(self.rawText, name: "rawText", parent: name, max: 2000)
            try self.validate(self.rawText, name: "rawText", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rawText = "rawText"
        }
    }

    public struct CustomReflectionConfiguration: AWSDecodableShape {
        /// The configuration for a reflection strategy to override the default one.
        public let episodicReflectionOverride: EpisodicReflectionOverride?

        @inlinable
        public init(episodicReflectionOverride: EpisodicReflectionOverride? = nil) {
            self.episodicReflectionOverride = episodicReflectionOverride
        }

        private enum CodingKeys: String, CodingKey {
            case episodicReflectionOverride = "episodicReflectionOverride"
        }
    }

    public struct CustomReflectionConfigurationInput: AWSEncodableShape {
        /// The reflection override configuration input.
        public let episodicReflectionOverride: EpisodicOverrideReflectionConfigurationInput?

        @inlinable
        public init(episodicReflectionOverride: EpisodicOverrideReflectionConfigurationInput? = nil) {
            self.episodicReflectionOverride = episodicReflectionOverride
        }

        public func validate(name: String) throws {
            try self.episodicReflectionOverride?.validate(name: "\(name).episodicReflectionOverride")
        }

        private enum CodingKeys: String, CodingKey {
            case episodicReflectionOverride = "episodicReflectionOverride"
        }
    }

    public struct DataSourceConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The CloudWatch logs configuration for reading agent traces from log groups.
        public let cloudWatchLogs: CloudWatchLogsInputConfig?

        @inlinable
        public init(cloudWatchLogs: CloudWatchLogsInputConfig? = nil) {
            self.cloudWatchLogs = cloudWatchLogs
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogs?.validate(name: "\(name).cloudWatchLogs")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogs = "cloudWatchLogs"
        }
    }

    public struct EvaluatorConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The LLM-as-a-Judge configuration that uses a language model to evaluate agent performance based on custom instructions and rating scales.
        public let llmAsAJudge: LlmAsAJudgeEvaluatorConfig?

        @inlinable
        public init(llmAsAJudge: LlmAsAJudgeEvaluatorConfig? = nil) {
            self.llmAsAJudge = llmAsAJudge
        }

        public func validate(name: String) throws {
            try self.llmAsAJudge?.validate(name: "\(name).llmAsAJudge")
        }

        private enum CodingKeys: String, CodingKey {
            case llmAsAJudge = "llmAsAJudge"
        }
    }

    public struct EvaluatorModelConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Bedrock model configuration for evaluation.
        public let bedrockEvaluatorModelConfig: BedrockEvaluatorModelConfig?

        @inlinable
        public init(bedrockEvaluatorModelConfig: BedrockEvaluatorModelConfig? = nil) {
            self.bedrockEvaluatorModelConfig = bedrockEvaluatorModelConfig
        }

        public func validate(name: String) throws {
            try self.bedrockEvaluatorModelConfig?.validate(name: "\(name).bedrockEvaluatorModelConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockEvaluatorModelConfig = "bedrockEvaluatorModelConfig"
        }
    }

    public struct EvaluatorReference: AWSEncodableShape & AWSDecodableShape {
        ///  The unique identifier of the evaluator. Can reference builtin evaluators (e.g., Builtin.Helpfulness) or custom evaluators.
        public let evaluatorId: String?

        @inlinable
        public init(evaluatorId: String? = nil) {
            self.evaluatorId = evaluatorId
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluatorId, name: "evaluatorId", parent: name, pattern: "^(Builtin.[a-zA-Z0-9_-]+|[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: String, CodingKey {
            case evaluatorId = "evaluatorId"
        }
    }

    public struct ExtractionConfiguration: AWSDecodableShape {
        /// The custom extraction configuration.
        public let customExtractionConfiguration: CustomExtractionConfiguration?

        @inlinable
        public init(customExtractionConfiguration: CustomExtractionConfiguration? = nil) {
            self.customExtractionConfiguration = customExtractionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case customExtractionConfiguration = "customExtractionConfiguration"
        }
    }

    public struct GatewayProtocolConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the Model Context Protocol (MCP). This protocol enables communication between Amazon Bedrock Agent and external tools.
        public let mcp: MCPGatewayConfiguration?

        @inlinable
        public init(mcp: MCPGatewayConfiguration? = nil) {
            self.mcp = mcp
        }

        public func validate(name: String) throws {
            try self.mcp?.validate(name: "\(name).mcp")
        }

        private enum CodingKeys: String, CodingKey {
            case mcp = "mcp"
        }
    }

    public struct InterceptorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The details of the lambda function used for the interceptor.
        public let lambda: LambdaInterceptorConfiguration?

        @inlinable
        public init(lambda: LambdaInterceptorConfiguration? = nil) {
            self.lambda = lambda
        }

        public func validate(name: String) throws {
            try self.lambda?.validate(name: "\(name).lambda")
        }

        private enum CodingKeys: String, CodingKey {
            case lambda = "lambda"
        }
    }

    public struct ModifyConsolidationConfiguration: AWSEncodableShape {
        /// The updated custom consolidation configuration.
        public let customConsolidationConfiguration: CustomConsolidationConfigurationInput?

        @inlinable
        public init(customConsolidationConfiguration: CustomConsolidationConfigurationInput? = nil) {
            self.customConsolidationConfiguration = customConsolidationConfiguration
        }

        public func validate(name: String) throws {
            try self.customConsolidationConfiguration?.validate(name: "\(name).customConsolidationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customConsolidationConfiguration = "customConsolidationConfiguration"
        }
    }

    public struct ModifyExtractionConfiguration: AWSEncodableShape {
        /// The updated custom extraction configuration.
        public let customExtractionConfiguration: CustomExtractionConfigurationInput?

        @inlinable
        public init(customExtractionConfiguration: CustomExtractionConfigurationInput? = nil) {
            self.customExtractionConfiguration = customExtractionConfiguration
        }

        public func validate(name: String) throws {
            try self.customExtractionConfiguration?.validate(name: "\(name).customExtractionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customExtractionConfiguration = "customExtractionConfiguration"
        }
    }

    public struct PolicyDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The Cedar policy definition within the policy definition structure. This contains the Cedar policy statement that defines the authorization logic using Cedar's human-readable, analyzable policy language. Cedar policies specify principals (who can access), actions (what operations are allowed), resources (what can be accessed), and optional conditions for fine-grained control. Cedar provides a formal policy language designed for authorization with deterministic evaluation, making policies testable, reviewable, and auditable. All Cedar policies follow a default-deny model where actions are denied unless explicitly permitted, and forbid policies always override permit policies.
        public let cedar: CedarPolicy?

        @inlinable
        public init(cedar: CedarPolicy? = nil) {
            self.cedar = cedar
        }

        public func validate(name: String) throws {
            try self.cedar?.validate(name: "\(name).cedar")
        }

        private enum CodingKeys: String, CodingKey {
            case cedar = "cedar"
        }
    }

    public struct RequestHeaderConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of HTTP request headers that are allowed to be passed through to the runtime.
        public let requestHeaderAllowlist: [String]?

        @inlinable
        public init(requestHeaderAllowlist: [String]? = nil) {
            self.requestHeaderAllowlist = requestHeaderAllowlist
        }

        public func validate(name: String) throws {
            try self.requestHeaderAllowlist?.forEach {
                try validate($0, name: "requestHeaderAllowlist[]", parent: name, max: 256)
                try validate($0, name: "requestHeaderAllowlist[]", parent: name, min: 1)
                try validate($0, name: "requestHeaderAllowlist[]", parent: name, pattern: "^(Authorization|X-Amzn-Bedrock-AgentCore-Runtime-Custom-[a-zA-Z0-9-]+)$")
            }
            try self.validate(self.requestHeaderAllowlist, name: "requestHeaderAllowlist", parent: name, max: 20)
            try self.validate(self.requestHeaderAllowlist, name: "requestHeaderAllowlist", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case requestHeaderAllowlist = "requestHeaderAllowlist"
        }
    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource. This globally unique identifier specifies the exact resource that policies will be evaluated against for access control decisions.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct TargetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Model Context Protocol (MCP) configuration for the target. This configuration defines how the gateway uses MCP to communicate with the target.
        public let mcp: McpTargetConfiguration?

        @inlinable
        public init(mcp: McpTargetConfiguration? = nil) {
            self.mcp = mcp
        }

        public func validate(name: String) throws {
            try self.mcp?.validate(name: "\(name).mcp")
        }

        private enum CodingKeys: String, CodingKey {
            case mcp = "mcp"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgentCoreControl
public struct BedrockAgentCoreControlErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case concurrentModificationException = "ConcurrentModificationException"
        case conflictException = "ConflictException"
        case decryptionFailure = "DecryptionFailure"
        case encryptionFailure = "EncryptionFailure"
        case internalServerException = "InternalServerException"
        case resourceLimitExceededException = "ResourceLimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceException = "ServiceException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttledException = "ThrottledException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgentCoreControl
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// This exception is thrown when a request is denied per access permissions
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Exception thrown when a resource is modified concurrently by multiple requests.
    public static var concurrentModificationException: Self { .init(.concurrentModificationException) }
    /// This exception is thrown when there is a conflict performing an operation
    public static var conflictException: Self { .init(.conflictException) }
    /// Exception thrown when decryption of a secret fails.
    public static var decryptionFailure: Self { .init(.decryptionFailure) }
    /// Exception thrown when encryption of a secret fails.
    public static var encryptionFailure: Self { .init(.encryptionFailure) }
    /// This exception is thrown if there was an unexpected error during processing of request
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Exception thrown when a resource limit is exceeded.
    public static var resourceLimitExceededException: Self { .init(.resourceLimitExceededException) }
    /// This exception is thrown when a resource referenced by the operation does not exist
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// An internal error occurred.
    public static var serviceException: Self { .init(.serviceException) }
    /// This exception is thrown when a request is made beyond the service quota
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// API rate limit has been exceeded.
    public static var throttledException: Self { .init(.throttledException) }
    /// This exception is thrown when the number of requests exceeds the limit
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This exception is thrown when the JWT bearer token is invalid or not found for OAuth bearer token based access
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The input fails to satisfy the constraints specified by the service.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentCoreControlErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": BedrockAgentCoreControl.ValidationException.self
    ]
}

extension BedrockAgentCoreControlErrorType: Equatable {
    public static func == (lhs: BedrockAgentCoreControlErrorType, rhs: BedrockAgentCoreControlErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentCoreControlErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
