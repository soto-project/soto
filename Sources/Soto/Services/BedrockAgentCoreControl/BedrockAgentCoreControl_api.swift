//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS BedrockAgentCoreControl service.
///
/// Welcome to the Amazon Bedrock AgentCore Control plane API reference. Control plane actions configure, create, modify, and monitor Amazon Web Services resources.
public struct BedrockAgentCoreControl: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the BedrockAgentCoreControl client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "BedrockAgentCoreControl",
            serviceIdentifier: "bedrock-agentcore-control",
            signingName: "bedrock-agentcore",
            serviceProtocol: .restjson,
            apiVersion: "2023-06-05",
            endpoint: endpoint,
            errorType: BedrockAgentCoreControlErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Creates an Amazon Bedrock AgentCore Runtime.
    @Sendable
    @inlinable
    public func createAgentRuntime(_ input: CreateAgentRuntimeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAgentRuntimeResponse {
        try await self.client.execute(
            operation: "CreateAgentRuntime", 
            path: "/runtimes/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an Amazon Bedrock AgentCore Runtime.
    ///
    /// Parameters:
    ///   - agentRuntimeArtifact: The artifact of the AgentCore Runtime.
    ///   - agentRuntimeName: The name of the AgentCore Runtime.
    ///   - authorizerConfiguration: The authorizer configuration for the AgentCore Runtime.
    ///   - clientToken: A unique, case-sensitive identifier to ensure idempotency of the request.
    ///   - description: The description of the AgentCore Runtime.
    ///   - environmentVariables: Environment variables to set in the AgentCore Runtime environment.
    ///   - lifecycleConfiguration: The life cycle configuration for the AgentCore Runtime.
    ///   - networkConfiguration: The network configuration for the AgentCore Runtime.
    ///   - protocolConfiguration: 
    ///   - requestHeaderConfiguration: Configuration for HTTP request headers that will be passed through to the runtime.
    ///   - roleArn: The IAM role ARN that provides permissions for the AgentCore Runtime.
    ///   - tags: A map of tag keys and values to assign to the agent runtime. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAgentRuntime(
        agentRuntimeArtifact: AgentRuntimeArtifact,
        agentRuntimeName: String,
        authorizerConfiguration: AuthorizerConfiguration? = nil,
        clientToken: String? = CreateAgentRuntimeRequest.idempotencyToken(),
        description: String? = nil,
        environmentVariables: [String: String]? = nil,
        lifecycleConfiguration: LifecycleConfiguration? = nil,
        networkConfiguration: NetworkConfiguration,
        protocolConfiguration: ProtocolConfiguration? = nil,
        requestHeaderConfiguration: RequestHeaderConfiguration? = nil,
        roleArn: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAgentRuntimeResponse {
        let input = CreateAgentRuntimeRequest(
            agentRuntimeArtifact: agentRuntimeArtifact, 
            agentRuntimeName: agentRuntimeName, 
            authorizerConfiguration: authorizerConfiguration, 
            clientToken: clientToken, 
            description: description, 
            environmentVariables: environmentVariables, 
            lifecycleConfiguration: lifecycleConfiguration, 
            networkConfiguration: networkConfiguration, 
            protocolConfiguration: protocolConfiguration, 
            requestHeaderConfiguration: requestHeaderConfiguration, 
            roleArn: roleArn, 
            tags: tags
        )
        return try await self.createAgentRuntime(input, logger: logger)
    }

    /// Creates an AgentCore Runtime endpoint.
    @Sendable
    @inlinable
    public func createAgentRuntimeEndpoint(_ input: CreateAgentRuntimeEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAgentRuntimeEndpointResponse {
        try await self.client.execute(
            operation: "CreateAgentRuntimeEndpoint", 
            path: "/runtimes/{agentRuntimeId}/runtime-endpoints/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an AgentCore Runtime endpoint.
    ///
    /// Parameters:
    ///   - agentRuntimeId: The unique identifier of the AgentCore Runtime to create an endpoint for.
    ///   - agentRuntimeVersion: The version of the AgentCore Runtime to use for the endpoint.
    ///   - clientToken: A unique, case-sensitive identifier to ensure idempotency of the request.
    ///   - description: The description of the AgentCore Runtime endpoint.
    ///   - name: The name of the AgentCore Runtime endpoint.
    ///   - tags: A map of tag keys and values to assign to the agent runtime endpoint. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAgentRuntimeEndpoint(
        agentRuntimeId: String,
        agentRuntimeVersion: String? = nil,
        clientToken: String? = CreateAgentRuntimeEndpointRequest.idempotencyToken(),
        description: String? = nil,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAgentRuntimeEndpointResponse {
        let input = CreateAgentRuntimeEndpointRequest(
            agentRuntimeId: agentRuntimeId, 
            agentRuntimeVersion: agentRuntimeVersion, 
            clientToken: clientToken, 
            description: description, 
            name: name, 
            tags: tags
        )
        return try await self.createAgentRuntimeEndpoint(input, logger: logger)
    }

    /// Creates a new API key credential provider.
    @Sendable
    @inlinable
    public func createApiKeyCredentialProvider(_ input: CreateApiKeyCredentialProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateApiKeyCredentialProviderResponse {
        try await self.client.execute(
            operation: "CreateApiKeyCredentialProvider", 
            path: "/identities/CreateApiKeyCredentialProvider", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new API key credential provider.
    ///
    /// Parameters:
    ///   - apiKey: The API key to use for authentication. This value is encrypted and stored securely.
    ///   - name: The name of the API key credential provider. The name must be unique within your account.
    ///   - tags: A map of tag keys and values to assign to the API key credential provider. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func createApiKeyCredentialProvider(
        apiKey: String,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateApiKeyCredentialProviderResponse {
        let input = CreateApiKeyCredentialProviderRequest(
            apiKey: apiKey, 
            name: name, 
            tags: tags
        )
        return try await self.createApiKeyCredentialProvider(input, logger: logger)
    }

    /// Creates a custom browser.
    @Sendable
    @inlinable
    public func createBrowser(_ input: CreateBrowserRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBrowserResponse {
        try await self.client.execute(
            operation: "CreateBrowser", 
            path: "/browsers", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a custom browser.
    ///
    /// Parameters:
    ///   - browserSigning: The browser signing configuration that enables cryptographic agent identification using HTTP message signatures for web bot authentication.
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
    ///   - description: The description of the browser.
    ///   - executionRoleArn: The Amazon Resource Name (ARN) of the IAM role that provides permissions for the browser to access Amazon Web Services services.
    ///   - name: The name of the browser. The name must be unique within your account.
    ///   - networkConfiguration: The network configuration for the browser. This configuration specifies the network mode for the browser.
    ///   - recording: The recording configuration for the browser. When enabled, browser sessions are recorded and stored in the specified Amazon S3 location.
    ///   - tags: A map of tag keys and values to assign to the browser. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBrowser(
        browserSigning: BrowserSigningConfigInput? = nil,
        clientToken: String? = CreateBrowserRequest.idempotencyToken(),
        description: String? = nil,
        executionRoleArn: String? = nil,
        name: String,
        networkConfiguration: BrowserNetworkConfiguration,
        recording: RecordingConfig? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBrowserResponse {
        let input = CreateBrowserRequest(
            browserSigning: browserSigning, 
            clientToken: clientToken, 
            description: description, 
            executionRoleArn: executionRoleArn, 
            name: name, 
            networkConfiguration: networkConfiguration, 
            recording: recording, 
            tags: tags
        )
        return try await self.createBrowser(input, logger: logger)
    }

    /// Creates a custom code interpreter.
    @Sendable
    @inlinable
    public func createCodeInterpreter(_ input: CreateCodeInterpreterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCodeInterpreterResponse {
        try await self.client.execute(
            operation: "CreateCodeInterpreter", 
            path: "/code-interpreters", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a custom code interpreter.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
    ///   - description: The description of the code interpreter.
    ///   - executionRoleArn: The Amazon Resource Name (ARN) of the IAM role that provides permissions for the code interpreter to access Amazon Web Services services.
    ///   - name: The name of the code interpreter. The name must be unique within your account.
    ///   - networkConfiguration: The network configuration for the code interpreter. This configuration specifies the network mode for the code interpreter.
    ///   - tags: A map of tag keys and values to assign to the code interpreter. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCodeInterpreter(
        clientToken: String? = CreateCodeInterpreterRequest.idempotencyToken(),
        description: String? = nil,
        executionRoleArn: String? = nil,
        name: String,
        networkConfiguration: CodeInterpreterNetworkConfiguration,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCodeInterpreterResponse {
        let input = CreateCodeInterpreterRequest(
            clientToken: clientToken, 
            description: description, 
            executionRoleArn: executionRoleArn, 
            name: name, 
            networkConfiguration: networkConfiguration, 
            tags: tags
        )
        return try await self.createCodeInterpreter(input, logger: logger)
    }

    ///  Creates a custom evaluator for agent quality assessment. Custom evaluators use LLM-as-a-Judge configurations with user-defined prompts, rating scales, and model settings to evaluate agent performance at tool call, trace, or session levels.
    @Sendable
    @inlinable
    public func createEvaluator(_ input: CreateEvaluatorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateEvaluatorResponse {
        try await self.client.execute(
            operation: "CreateEvaluator", 
            path: "/evaluators/create", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a custom evaluator for agent quality assessment. Custom evaluators use LLM-as-a-Judge configurations with user-defined prompts, rating scales, and model settings to evaluate agent performance at tool call, trace, or session levels.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
    ///   - description:  The description of the evaluator that explains its purpose and evaluation criteria.
    ///   - evaluatorConfig:  The configuration for the evaluator, including LLM-as-a-Judge settings with instructions, rating scale, and model configuration.
    ///   - evaluatorName:  The name of the evaluator. Must be unique within your account.
    ///   - level:  The evaluation level that determines the scope of evaluation. Valid values are TOOL_CALL for individual tool invocations, TRACE for single request-response interactions, or SESSION for entire conversation sessions.
    ///   - logger: Logger use during operation
    @inlinable
    public func createEvaluator(
        clientToken: String? = CreateEvaluatorRequest.idempotencyToken(),
        description: String? = nil,
        evaluatorConfig: EvaluatorConfig,
        evaluatorName: String,
        level: EvaluatorLevel,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateEvaluatorResponse {
        let input = CreateEvaluatorRequest(
            clientToken: clientToken, 
            description: description, 
            evaluatorConfig: evaluatorConfig, 
            evaluatorName: evaluatorName, 
            level: level
        )
        return try await self.createEvaluator(input, logger: logger)
    }

    /// Creates a gateway for Amazon Bedrock Agent. A gateway serves as an integration point between your agent and external services. If you specify CUSTOM_JWT as the authorizerType, you must provide an authorizerConfiguration.
    @Sendable
    @inlinable
    public func createGateway(_ input: CreateGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateGatewayResponse {
        try await self.client.execute(
            operation: "CreateGateway", 
            path: "/gateways/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a gateway for Amazon Bedrock Agent. A gateway serves as an integration point between your agent and external services. If you specify CUSTOM_JWT as the authorizerType, you must provide an authorizerConfiguration.
    ///
    /// Parameters:
    ///   - authorizerConfiguration: The authorizer configuration for the gateway. Required if authorizerType is CUSTOM_JWT.
    ///   - authorizerType: The type of authorizer to use for the gateway.    CUSTOM_JWT - Authorize with a bearer token.    AWS_IAM - Authorize with your Amazon Web Services IAM credentials.    NONE - No authorization
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
    ///   - description: The description of the gateway.
    ///   - exceptionLevel: The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
    ///   - interceptorConfigurations: A list of configuration settings for a gateway interceptor. Gateway interceptors allow custom code to be invoked during gateway invocations.
    ///   - kmsKeyArn: The Amazon Resource Name (ARN) of the KMS key used to encrypt data associated with the gateway.
    ///   - name: The name of the gateway. The name must be unique within your account.
    ///   - policyEngineConfiguration: The policy engine configuration for the gateway. A policy engine is a collection of policies that evaluates and authorizes agent tool calls. When associated with a gateway, the policy engine intercepts all agent requests and determines whether to allow or deny each action based on the defined policies.
    ///   - protocolConfiguration: The configuration settings for the protocol specified in the protocolType parameter.
    ///   - protocolType: The protocol type for the gateway.
    ///   - roleArn: The Amazon Resource Name (ARN) of the IAM role that provides permissions for the gateway to access Amazon Web Services services.
    ///   - tags: A map of key-value pairs to associate with the gateway as metadata tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func createGateway(
        authorizerConfiguration: AuthorizerConfiguration? = nil,
        authorizerType: AuthorizerType,
        clientToken: String? = CreateGatewayRequest.idempotencyToken(),
        description: String? = nil,
        exceptionLevel: ExceptionLevel? = nil,
        interceptorConfigurations: [GatewayInterceptorConfiguration]? = nil,
        kmsKeyArn: String? = nil,
        name: String,
        policyEngineConfiguration: GatewayPolicyEngineConfiguration? = nil,
        protocolConfiguration: GatewayProtocolConfiguration? = nil,
        protocolType: GatewayProtocolType,
        roleArn: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateGatewayResponse {
        let input = CreateGatewayRequest(
            authorizerConfiguration: authorizerConfiguration, 
            authorizerType: authorizerType, 
            clientToken: clientToken, 
            description: description, 
            exceptionLevel: exceptionLevel, 
            interceptorConfigurations: interceptorConfigurations, 
            kmsKeyArn: kmsKeyArn, 
            name: name, 
            policyEngineConfiguration: policyEngineConfiguration, 
            protocolConfiguration: protocolConfiguration, 
            protocolType: protocolType, 
            roleArn: roleArn, 
            tags: tags
        )
        return try await self.createGateway(input, logger: logger)
    }

    /// Creates a target for a gateway. A target defines an endpoint that the gateway can connect to.
    @Sendable
    @inlinable
    public func createGatewayTarget(_ input: CreateGatewayTargetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateGatewayTargetResponse {
        try await self.client.execute(
            operation: "CreateGatewayTarget", 
            path: "/gateways/{gatewayIdentifier}/targets/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a target for a gateway. A target defines an endpoint that the gateway can connect to.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
    ///   - credentialProviderConfigurations: The credential provider configurations for the target. These configurations specify how the gateway authenticates with the target endpoint.
    ///   - description: The description of the gateway target.
    ///   - gatewayIdentifier: The identifier of the gateway to create a target for.
    ///   - metadataConfiguration: Optional configuration for HTTP header and query parameter propagation to and from the gateway target.
    ///   - name: The name of the gateway target. The name must be unique within the gateway.
    ///   - targetConfiguration: The configuration settings for the target, including endpoint information and schema definitions.
    ///   - logger: Logger use during operation
    @inlinable
    public func createGatewayTarget(
        clientToken: String? = CreateGatewayTargetRequest.idempotencyToken(),
        credentialProviderConfigurations: [CredentialProviderConfiguration]? = nil,
        description: String? = nil,
        gatewayIdentifier: String,
        metadataConfiguration: MetadataConfiguration? = nil,
        name: String,
        targetConfiguration: TargetConfiguration,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateGatewayTargetResponse {
        let input = CreateGatewayTargetRequest(
            clientToken: clientToken, 
            credentialProviderConfigurations: credentialProviderConfigurations, 
            description: description, 
            gatewayIdentifier: gatewayIdentifier, 
            metadataConfiguration: metadataConfiguration, 
            name: name, 
            targetConfiguration: targetConfiguration
        )
        return try await self.createGatewayTarget(input, logger: logger)
    }

    /// Creates a new Amazon Bedrock AgentCore Memory resource.
    @Sendable
    @inlinable
    public func createMemory(_ input: CreateMemoryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMemoryOutput {
        try await self.client.execute(
            operation: "CreateMemory", 
            path: "/memories/create", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new Amazon Bedrock AgentCore Memory resource.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but does not return an error.
    ///   - description: The description of the memory.
    ///   - encryptionKeyArn: The Amazon Resource Name (ARN) of the KMS key used to encrypt the memory data.
    ///   - eventExpiryDuration: The duration after which memory events expire. Specified as an ISO 8601 duration.
    ///   - memoryExecutionRoleArn: The Amazon Resource Name (ARN) of the IAM role that provides permissions for the memory to access Amazon Web Services services.
    ///   - memoryStrategies: The memory strategies to use for this memory. Strategies define how information is extracted, processed, and consolidated.
    ///   - name: The name of the memory. The name must be unique within your account.
    ///   - tags: A map of tag keys and values to assign to an AgentCore Memory. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func createMemory(
        clientToken: String? = CreateMemoryInput.idempotencyToken(),
        description: String? = nil,
        encryptionKeyArn: String? = nil,
        eventExpiryDuration: Int,
        memoryExecutionRoleArn: String? = nil,
        memoryStrategies: [MemoryStrategyInput]? = nil,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMemoryOutput {
        let input = CreateMemoryInput(
            clientToken: clientToken, 
            description: description, 
            encryptionKeyArn: encryptionKeyArn, 
            eventExpiryDuration: eventExpiryDuration, 
            memoryExecutionRoleArn: memoryExecutionRoleArn, 
            memoryStrategies: memoryStrategies, 
            name: name, 
            tags: tags
        )
        return try await self.createMemory(input, logger: logger)
    }

    /// Creates a new OAuth2 credential provider.
    @Sendable
    @inlinable
    public func createOauth2CredentialProvider(_ input: CreateOauth2CredentialProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateOauth2CredentialProviderResponse {
        try await self.client.execute(
            operation: "CreateOauth2CredentialProvider", 
            path: "/identities/CreateOauth2CredentialProvider", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new OAuth2 credential provider.
    ///
    /// Parameters:
    ///   - credentialProviderVendor: The vendor of the OAuth2 credential provider. This specifies which OAuth2 implementation to use.
    ///   - name: The name of the OAuth2 credential provider. The name must be unique within your account.
    ///   - oauth2ProviderConfigInput: The configuration settings for the OAuth2 provider, including client ID, client secret, and other vendor-specific settings.
    ///   - tags: A map of tag keys and values to assign to the OAuth2 credential provider. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func createOauth2CredentialProvider(
        credentialProviderVendor: CredentialProviderVendorType,
        name: String,
        oauth2ProviderConfigInput: Oauth2ProviderConfigInput,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateOauth2CredentialProviderResponse {
        let input = CreateOauth2CredentialProviderRequest(
            credentialProviderVendor: credentialProviderVendor, 
            name: name, 
            oauth2ProviderConfigInput: oauth2ProviderConfigInput, 
            tags: tags
        )
        return try await self.createOauth2CredentialProvider(input, logger: logger)
    }

    ///  Creates an online evaluation configuration for continuous monitoring of agent performance. Online evaluation automatically samples live traffic from CloudWatch logs at specified rates and applies evaluators to assess agent quality in production.
    @Sendable
    @inlinable
    public func createOnlineEvaluationConfig(_ input: CreateOnlineEvaluationConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateOnlineEvaluationConfigResponse {
        try await self.client.execute(
            operation: "CreateOnlineEvaluationConfig", 
            path: "/online-evaluation-configs/create", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates an online evaluation configuration for continuous monitoring of agent performance. Online evaluation automatically samples live traffic from CloudWatch logs at specified rates and applies evaluators to assess agent quality in production.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
    ///   - dataSourceConfig:  The data source configuration that specifies CloudWatch log groups and service names to monitor for agent traces.
    ///   - description:  The description of the online evaluation configuration that explains its monitoring purpose and scope.
    ///   - enableOnCreate:  Whether to enable the online evaluation configuration immediately upon creation. If true, evaluation begins automatically.
    ///   - evaluationExecutionRoleArn:  The Amazon Resource Name (ARN) of the IAM role that grants permissions to read from CloudWatch logs, write evaluation results, and invoke Amazon Bedrock models for evaluation.
    ///   - evaluators:  The list of evaluators to apply during online evaluation. Can include both built-in evaluators and custom evaluators created with CreateEvaluator.
    ///   - onlineEvaluationConfigName:  The name of the online evaluation configuration. Must be unique within your account.
    ///   - rule:  The evaluation rule that defines sampling configuration, filters, and session detection settings for the online evaluation.
    ///   - logger: Logger use during operation
    @inlinable
    public func createOnlineEvaluationConfig(
        clientToken: String? = CreateOnlineEvaluationConfigRequest.idempotencyToken(),
        dataSourceConfig: DataSourceConfig,
        description: String? = nil,
        enableOnCreate: Bool,
        evaluationExecutionRoleArn: String,
        evaluators: [EvaluatorReference],
        onlineEvaluationConfigName: String,
        rule: Rule,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateOnlineEvaluationConfigResponse {
        let input = CreateOnlineEvaluationConfigRequest(
            clientToken: clientToken, 
            dataSourceConfig: dataSourceConfig, 
            description: description, 
            enableOnCreate: enableOnCreate, 
            evaluationExecutionRoleArn: evaluationExecutionRoleArn, 
            evaluators: evaluators, 
            onlineEvaluationConfigName: onlineEvaluationConfigName, 
            rule: rule
        )
        return try await self.createOnlineEvaluationConfig(input, logger: logger)
    }

    /// Creates a policy within the AgentCore Policy system. Policies provide real-time, deterministic control over agentic interactions with AgentCore Gateway. Using the Cedar policy language, you can define fine-grained policies that specify which interactions with Gateway tools are permitted based on input parameters and OAuth claims, ensuring agents operate within defined boundaries and business rules. The policy is validated during creation against the Cedar schema generated from the Gateway's tools' input schemas, which defines the available tools, their parameters, and expected data types. This is an asynchronous operation. Use the GetPolicy operation to poll the status field to track completion.
    @Sendable
    @inlinable
    public func createPolicy(_ input: CreatePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePolicyResponse {
        try await self.client.execute(
            operation: "CreatePolicy", 
            path: "/policy-engines/{policyEngineId}/policies", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a policy within the AgentCore Policy system. Policies provide real-time, deterministic control over agentic interactions with AgentCore Gateway. Using the Cedar policy language, you can define fine-grained policies that specify which interactions with Gateway tools are permitted based on input parameters and OAuth claims, ensuring agents operate within defined boundaries and business rules. The policy is validated during creation against the Cedar schema generated from the Gateway's tools' input schemas, which defines the available tools, their parameters, and expected data types. This is an asynchronous operation. Use the GetPolicy operation to poll the status field to track completion.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure the idempotency of the request. The AWS SDK automatically generates this token, so you don't need to provide it in most cases. If you retry a request with the same client token, the service returns the same response without creating a duplicate policy.
    ///   - definition: The Cedar policy statement that defines the access control rules. This contains the actual policy logic written in Cedar policy language, specifying effect (permit or forbid), principals, actions, resources, and conditions for agent behavior control.
    ///   - description: A human-readable description of the policy's purpose and functionality (1-4,096 characters). This helps policy administrators understand the policy's intent, business rules, and operational scope. Use this field to document why the policy exists, what business requirement it addresses, and any special considerations for maintenance. Clear descriptions are essential for policy governance, auditing, and troubleshooting.
    ///   - name: The customer-assigned immutable name for the policy. Must be unique within the account. This name is used for policy identification and cannot be changed after creation.
    ///   - policyEngineId: The identifier of the policy engine which contains this policy. Policy engines group related policies and provide the execution context for policy evaluation.
    ///   - validationMode: The validation mode for the policy creation. Determines how Cedar analyzer validation results are handled during policy creation. FAIL_ON_ANY_FINDINGS (default) runs the Cedar analyzer to validate the policy against the Cedar schema and tool context, failing creation if the analyzer detects any validation issues to ensure strict conformance. IGNORE_ALL_FINDINGS runs the Cedar analyzer but allows policy creation even if validation issues are detected, useful for testing or when the policy schema is evolving. Use FAIL_ON_ANY_FINDINGS for production policies to ensure correctness, and IGNORE_ALL_FINDINGS only when you understand and accept the analyzer findings.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPolicy(
        clientToken: String? = CreatePolicyRequest.idempotencyToken(),
        definition: PolicyDefinition,
        description: String? = nil,
        name: String,
        policyEngineId: String,
        validationMode: PolicyValidationMode? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePolicyResponse {
        let input = CreatePolicyRequest(
            clientToken: clientToken, 
            definition: definition, 
            description: description, 
            name: name, 
            policyEngineId: policyEngineId, 
            validationMode: validationMode
        )
        return try await self.createPolicy(input, logger: logger)
    }

    /// Creates a new policy engine within the AgentCore Policy system. A policy engine is a collection of policies that evaluates and authorizes agent tool calls. When associated with Gateways (each Gateway can be associated with at most one policy engine, but multiple Gateways can be associated with the same engine), the policy engine intercepts all agent requests and determines whether to allow or deny each action based on the defined policies. This is an asynchronous operation. Use the GetPolicyEngine operation to poll the status field to track completion.
    @Sendable
    @inlinable
    public func createPolicyEngine(_ input: CreatePolicyEngineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePolicyEngineResponse {
        try await self.client.execute(
            operation: "CreatePolicyEngine", 
            path: "/policy-engines", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new policy engine within the AgentCore Policy system. A policy engine is a collection of policies that evaluates and authorizes agent tool calls. When associated with Gateways (each Gateway can be associated with at most one policy engine, but multiple Gateways can be associated with the same engine), the policy engine intercepts all agent requests and determines whether to allow or deny each action based on the defined policies. This is an asynchronous operation. Use the GetPolicyEngine operation to poll the status field to track completion.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request with the same client token, the service returns the same response without creating a duplicate policy engine.
    ///   - description: A human-readable description of the policy engine's purpose and scope (1-4,096 characters). This helps administrators understand the policy engine's role in the overall governance strategy. Document which Gateway this engine will be associated with, what types of tools or workflows it governs, and the team or service responsible for maintaining it. Clear descriptions are essential when managing multiple policy engines across different services or environments.
    ///   - name: The customer-assigned immutable name for the policy engine. This name identifies the policy engine and cannot be changed after creation.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPolicyEngine(
        clientToken: String? = CreatePolicyEngineRequest.idempotencyToken(),
        description: String? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePolicyEngineResponse {
        let input = CreatePolicyEngineRequest(
            clientToken: clientToken, 
            description: description, 
            name: name
        )
        return try await self.createPolicyEngine(input, logger: logger)
    }

    /// Creates a new workload identity.
    @Sendable
    @inlinable
    public func createWorkloadIdentity(_ input: CreateWorkloadIdentityRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkloadIdentityResponse {
        try await self.client.execute(
            operation: "CreateWorkloadIdentity", 
            path: "/identities/CreateWorkloadIdentity", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new workload identity.
    ///
    /// Parameters:
    ///   - allowedResourceOauth2ReturnUrls: The list of allowed OAuth2 return URLs for resources associated with this workload identity.
    ///   - name: The name of the workload identity. The name must be unique within your account.
    ///   - tags: A map of tag keys and values to assign to the workload identity. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func createWorkloadIdentity(
        allowedResourceOauth2ReturnUrls: [String]? = nil,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateWorkloadIdentityResponse {
        let input = CreateWorkloadIdentityRequest(
            allowedResourceOauth2ReturnUrls: allowedResourceOauth2ReturnUrls, 
            name: name, 
            tags: tags
        )
        return try await self.createWorkloadIdentity(input, logger: logger)
    }

    /// Deletes an Amazon Bedrock AgentCore Runtime.
    @Sendable
    @inlinable
    public func deleteAgentRuntime(_ input: DeleteAgentRuntimeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAgentRuntimeResponse {
        try await self.client.execute(
            operation: "DeleteAgentRuntime", 
            path: "/runtimes/{agentRuntimeId}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an Amazon Bedrock AgentCore Runtime.
    ///
    /// Parameters:
    ///   - agentRuntimeId: The unique identifier of the AgentCore Runtime to delete.
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, the service ignores the request but does not return an error.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAgentRuntime(
        agentRuntimeId: String,
        clientToken: String? = DeleteAgentRuntimeRequest.idempotencyToken(),
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAgentRuntimeResponse {
        let input = DeleteAgentRuntimeRequest(
            agentRuntimeId: agentRuntimeId, 
            clientToken: clientToken
        )
        return try await self.deleteAgentRuntime(input, logger: logger)
    }

    /// Deletes an AAgentCore Runtime endpoint.
    @Sendable
    @inlinable
    public func deleteAgentRuntimeEndpoint(_ input: DeleteAgentRuntimeEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAgentRuntimeEndpointResponse {
        try await self.client.execute(
            operation: "DeleteAgentRuntimeEndpoint", 
            path: "/runtimes/{agentRuntimeId}/runtime-endpoints/{endpointName}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an AAgentCore Runtime endpoint.
    ///
    /// Parameters:
    ///   - agentRuntimeId: The unique identifier of the AgentCore Runtime associated with the endpoint.
    ///   - clientToken: A unique, case-sensitive identifier to ensure idempotency of the request.
    ///   - endpointName: The name of the AgentCore Runtime endpoint to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAgentRuntimeEndpoint(
        agentRuntimeId: String,
        clientToken: String? = DeleteAgentRuntimeEndpointRequest.idempotencyToken(),
        endpointName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAgentRuntimeEndpointResponse {
        let input = DeleteAgentRuntimeEndpointRequest(
            agentRuntimeId: agentRuntimeId, 
            clientToken: clientToken, 
            endpointName: endpointName
        )
        return try await self.deleteAgentRuntimeEndpoint(input, logger: logger)
    }

    /// Deletes an API key credential provider.
    @Sendable
    @inlinable
    public func deleteApiKeyCredentialProvider(_ input: DeleteApiKeyCredentialProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteApiKeyCredentialProviderResponse {
        try await self.client.execute(
            operation: "DeleteApiKeyCredentialProvider", 
            path: "/identities/DeleteApiKeyCredentialProvider", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an API key credential provider.
    ///
    /// Parameters:
    ///   - name: The name of the API key credential provider to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteApiKeyCredentialProvider(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteApiKeyCredentialProviderResponse {
        let input = DeleteApiKeyCredentialProviderRequest(
            name: name
        )
        return try await self.deleteApiKeyCredentialProvider(input, logger: logger)
    }

    /// Deletes a custom browser.
    @Sendable
    @inlinable
    public func deleteBrowser(_ input: DeleteBrowserRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBrowserResponse {
        try await self.client.execute(
            operation: "DeleteBrowser", 
            path: "/browsers/{browserId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a custom browser.
    ///
    /// Parameters:
    ///   - browserId: The unique identifier of the browser to delete.
    ///   - clientToken: A unique, case-sensitive identifier to ensure idempotency of the request.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteBrowser(
        browserId: String,
        clientToken: String? = DeleteBrowserRequest.idempotencyToken(),
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteBrowserResponse {
        let input = DeleteBrowserRequest(
            browserId: browserId, 
            clientToken: clientToken
        )
        return try await self.deleteBrowser(input, logger: logger)
    }

    /// Deletes a custom code interpreter.
    @Sendable
    @inlinable
    public func deleteCodeInterpreter(_ input: DeleteCodeInterpreterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCodeInterpreterResponse {
        try await self.client.execute(
            operation: "DeleteCodeInterpreter", 
            path: "/code-interpreters/{codeInterpreterId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a custom code interpreter.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure idempotency of the request.
    ///   - codeInterpreterId: The unique identifier of the code interpreter to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCodeInterpreter(
        clientToken: String? = DeleteCodeInterpreterRequest.idempotencyToken(),
        codeInterpreterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCodeInterpreterResponse {
        let input = DeleteCodeInterpreterRequest(
            clientToken: clientToken, 
            codeInterpreterId: codeInterpreterId
        )
        return try await self.deleteCodeInterpreter(input, logger: logger)
    }

    ///  Deletes a custom evaluator. Builtin evaluators cannot be deleted. The evaluator must not be referenced by any active online evaluation configurations.
    @Sendable
    @inlinable
    public func deleteEvaluator(_ input: DeleteEvaluatorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteEvaluatorResponse {
        try await self.client.execute(
            operation: "DeleteEvaluator", 
            path: "/evaluators/{evaluatorId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a custom evaluator. Builtin evaluators cannot be deleted. The evaluator must not be referenced by any active online evaluation configurations.
    ///
    /// Parameters:
    ///   - evaluatorId:  The unique identifier of the evaluator to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteEvaluator(
        evaluatorId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteEvaluatorResponse {
        let input = DeleteEvaluatorRequest(
            evaluatorId: evaluatorId
        )
        return try await self.deleteEvaluator(input, logger: logger)
    }

    /// Deletes a gateway.
    @Sendable
    @inlinable
    public func deleteGateway(_ input: DeleteGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteGatewayResponse {
        try await self.client.execute(
            operation: "DeleteGateway", 
            path: "/gateways/{gatewayIdentifier}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a gateway.
    ///
    /// Parameters:
    ///   - gatewayIdentifier: The identifier of the gateway to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteGateway(
        gatewayIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteGatewayResponse {
        let input = DeleteGatewayRequest(
            gatewayIdentifier: gatewayIdentifier
        )
        return try await self.deleteGateway(input, logger: logger)
    }

    /// Deletes a gateway target.
    @Sendable
    @inlinable
    public func deleteGatewayTarget(_ input: DeleteGatewayTargetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteGatewayTargetResponse {
        try await self.client.execute(
            operation: "DeleteGatewayTarget", 
            path: "/gateways/{gatewayIdentifier}/targets/{targetId}/", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a gateway target.
    ///
    /// Parameters:
    ///   - gatewayIdentifier: The unique identifier of the gateway associated with the target.
    ///   - targetId: The unique identifier of the gateway target to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteGatewayTarget(
        gatewayIdentifier: String,
        targetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteGatewayTargetResponse {
        let input = DeleteGatewayTargetRequest(
            gatewayIdentifier: gatewayIdentifier, 
            targetId: targetId
        )
        return try await self.deleteGatewayTarget(input, logger: logger)
    }

    /// Deletes an Amazon Bedrock AgentCore Memory resource.
    @Sendable
    @inlinable
    public func deleteMemory(_ input: DeleteMemoryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMemoryOutput {
        try await self.client.execute(
            operation: "DeleteMemory", 
            path: "/memories/{memoryId}/delete", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an Amazon Bedrock AgentCore Memory resource.
    ///
    /// Parameters:
    ///   - clientToken: A client token is used for keeping track of idempotent requests. It can contain a session id which can be around 250 chars, combined with a unique AWS identifier.
    ///   - memoryId: The unique identifier of the memory to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMemory(
        clientToken: String? = DeleteMemoryInput.idempotencyToken(),
        memoryId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteMemoryOutput {
        let input = DeleteMemoryInput(
            clientToken: clientToken, 
            memoryId: memoryId
        )
        return try await self.deleteMemory(input, logger: logger)
    }

    /// Deletes an OAuth2 credential provider.
    @Sendable
    @inlinable
    public func deleteOauth2CredentialProvider(_ input: DeleteOauth2CredentialProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteOauth2CredentialProviderResponse {
        try await self.client.execute(
            operation: "DeleteOauth2CredentialProvider", 
            path: "/identities/DeleteOauth2CredentialProvider", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an OAuth2 credential provider.
    ///
    /// Parameters:
    ///   - name: The name of the OAuth2 credential provider to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteOauth2CredentialProvider(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteOauth2CredentialProviderResponse {
        let input = DeleteOauth2CredentialProviderRequest(
            name: name
        )
        return try await self.deleteOauth2CredentialProvider(input, logger: logger)
    }

    ///  Deletes an online evaluation configuration and stops any ongoing evaluation processes associated with it.
    @Sendable
    @inlinable
    public func deleteOnlineEvaluationConfig(_ input: DeleteOnlineEvaluationConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteOnlineEvaluationConfigResponse {
        try await self.client.execute(
            operation: "DeleteOnlineEvaluationConfig", 
            path: "/online-evaluation-configs/{onlineEvaluationConfigId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes an online evaluation configuration and stops any ongoing evaluation processes associated with it.
    ///
    /// Parameters:
    ///   - onlineEvaluationConfigId:  The unique identifier of the online evaluation configuration to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteOnlineEvaluationConfig(
        onlineEvaluationConfigId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteOnlineEvaluationConfigResponse {
        let input = DeleteOnlineEvaluationConfigRequest(
            onlineEvaluationConfigId: onlineEvaluationConfigId
        )
        return try await self.deleteOnlineEvaluationConfig(input, logger: logger)
    }

    /// Deletes an existing policy from the AgentCore Policy system. Once deleted, the policy can no longer be used for agent behavior control and all references to it become invalid. This is an asynchronous operation. Use the GetPolicy operation to poll the status field to track completion.
    @Sendable
    @inlinable
    public func deletePolicy(_ input: DeletePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePolicyResponse {
        try await self.client.execute(
            operation: "DeletePolicy", 
            path: "/policy-engines/{policyEngineId}/policies/{policyId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing policy from the AgentCore Policy system. Once deleted, the policy can no longer be used for agent behavior control and all references to it become invalid. This is an asynchronous operation. Use the GetPolicy operation to poll the status field to track completion.
    ///
    /// Parameters:
    ///   - policyEngineId: The identifier of the policy engine that manages the policy to be deleted. This ensures the policy is deleted from the correct policy engine context.
    ///   - policyId: The unique identifier of the policy to be deleted. This must be a valid policy ID that exists within the specified policy engine.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePolicy(
        policyEngineId: String,
        policyId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePolicyResponse {
        let input = DeletePolicyRequest(
            policyEngineId: policyEngineId, 
            policyId: policyId
        )
        return try await self.deletePolicy(input, logger: logger)
    }

    /// Deletes an existing policy engine from the AgentCore Policy system. The policy engine must not have any associated policies before deletion. Once deleted, the policy engine and all its configurations become unavailable for policy management and evaluation. This is an asynchronous operation. Use the GetPolicyEngine operation to poll the status field to track completion.
    @Sendable
    @inlinable
    public func deletePolicyEngine(_ input: DeletePolicyEngineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePolicyEngineResponse {
        try await self.client.execute(
            operation: "DeletePolicyEngine", 
            path: "/policy-engines/{policyEngineId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing policy engine from the AgentCore Policy system. The policy engine must not have any associated policies before deletion. Once deleted, the policy engine and all its configurations become unavailable for policy management and evaluation. This is an asynchronous operation. Use the GetPolicyEngine operation to poll the status field to track completion.
    ///
    /// Parameters:
    ///   - policyEngineId: The unique identifier of the policy engine to be deleted. This must be a valid policy engine ID that exists within the account.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePolicyEngine(
        policyEngineId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePolicyEngineResponse {
        let input = DeletePolicyEngineRequest(
            policyEngineId: policyEngineId
        )
        return try await self.deletePolicyEngine(input, logger: logger)
    }

    /// Deletes the resource-based policy for a specified resource.  This feature is currently available only for AgentCore Runtime and Gateway.
    @Sendable
    @inlinable
    public func deleteResourcePolicy(_ input: DeleteResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResourcePolicyResponse {
        try await self.client.execute(
            operation: "DeleteResourcePolicy", 
            path: "/resourcepolicy/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the resource-based policy for a specified resource.  This feature is currently available only for AgentCore Runtime and Gateway.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which to delete the resource policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteResourcePolicy(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteResourcePolicyResponse {
        let input = DeleteResourcePolicyRequest(
            resourceArn: resourceArn
        )
        return try await self.deleteResourcePolicy(input, logger: logger)
    }

    /// Deletes a workload identity.
    @Sendable
    @inlinable
    public func deleteWorkloadIdentity(_ input: DeleteWorkloadIdentityRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteWorkloadIdentityResponse {
        try await self.client.execute(
            operation: "DeleteWorkloadIdentity", 
            path: "/identities/DeleteWorkloadIdentity", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a workload identity.
    ///
    /// Parameters:
    ///   - name: The name of the workload identity to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteWorkloadIdentity(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteWorkloadIdentityResponse {
        let input = DeleteWorkloadIdentityRequest(
            name: name
        )
        return try await self.deleteWorkloadIdentity(input, logger: logger)
    }

    /// Gets an Amazon Bedrock AgentCore Runtime.
    @Sendable
    @inlinable
    public func getAgentRuntime(_ input: GetAgentRuntimeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentRuntimeResponse {
        try await self.client.execute(
            operation: "GetAgentRuntime", 
            path: "/runtimes/{agentRuntimeId}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets an Amazon Bedrock AgentCore Runtime.
    ///
    /// Parameters:
    ///   - agentRuntimeId: The unique identifier of the AgentCore Runtime to retrieve.
    ///   - agentRuntimeVersion: The version of the AgentCore Runtime to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAgentRuntime(
        agentRuntimeId: String,
        agentRuntimeVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAgentRuntimeResponse {
        let input = GetAgentRuntimeRequest(
            agentRuntimeId: agentRuntimeId, 
            agentRuntimeVersion: agentRuntimeVersion
        )
        return try await self.getAgentRuntime(input, logger: logger)
    }

    /// Gets information about an Amazon Secure AgentEndpoint.
    @Sendable
    @inlinable
    public func getAgentRuntimeEndpoint(_ input: GetAgentRuntimeEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAgentRuntimeEndpointResponse {
        try await self.client.execute(
            operation: "GetAgentRuntimeEndpoint", 
            path: "/runtimes/{agentRuntimeId}/runtime-endpoints/{endpointName}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about an Amazon Secure AgentEndpoint.
    ///
    /// Parameters:
    ///   - agentRuntimeId: The unique identifier of the AgentCore Runtime associated with the endpoint.
    ///   - endpointName: The name of the AgentCore Runtime endpoint to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAgentRuntimeEndpoint(
        agentRuntimeId: String,
        endpointName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAgentRuntimeEndpointResponse {
        let input = GetAgentRuntimeEndpointRequest(
            agentRuntimeId: agentRuntimeId, 
            endpointName: endpointName
        )
        return try await self.getAgentRuntimeEndpoint(input, logger: logger)
    }

    /// Retrieves information about an API key credential provider.
    @Sendable
    @inlinable
    public func getApiKeyCredentialProvider(_ input: GetApiKeyCredentialProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetApiKeyCredentialProviderResponse {
        try await self.client.execute(
            operation: "GetApiKeyCredentialProvider", 
            path: "/identities/GetApiKeyCredentialProvider", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about an API key credential provider.
    ///
    /// Parameters:
    ///   - name: The name of the API key credential provider to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getApiKeyCredentialProvider(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetApiKeyCredentialProviderResponse {
        let input = GetApiKeyCredentialProviderRequest(
            name: name
        )
        return try await self.getApiKeyCredentialProvider(input, logger: logger)
    }

    /// Gets information about a custom browser.
    @Sendable
    @inlinable
    public func getBrowser(_ input: GetBrowserRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBrowserResponse {
        try await self.client.execute(
            operation: "GetBrowser", 
            path: "/browsers/{browserId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a custom browser.
    ///
    /// Parameters:
    ///   - browserId: The unique identifier of the browser to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBrowser(
        browserId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBrowserResponse {
        let input = GetBrowserRequest(
            browserId: browserId
        )
        return try await self.getBrowser(input, logger: logger)
    }

    /// Gets information about a custom code interpreter.
    @Sendable
    @inlinable
    public func getCodeInterpreter(_ input: GetCodeInterpreterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCodeInterpreterResponse {
        try await self.client.execute(
            operation: "GetCodeInterpreter", 
            path: "/code-interpreters/{codeInterpreterId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a custom code interpreter.
    ///
    /// Parameters:
    ///   - codeInterpreterId: The unique identifier of the code interpreter to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCodeInterpreter(
        codeInterpreterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCodeInterpreterResponse {
        let input = GetCodeInterpreterRequest(
            codeInterpreterId: codeInterpreterId
        )
        return try await self.getCodeInterpreter(input, logger: logger)
    }

    ///  Retrieves detailed information about an evaluator, including its configuration, status, and metadata. Works with both built-in and custom evaluators.
    @Sendable
    @inlinable
    public func getEvaluator(_ input: GetEvaluatorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEvaluatorResponse {
        try await self.client.execute(
            operation: "GetEvaluator", 
            path: "/evaluators/{evaluatorId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves detailed information about an evaluator, including its configuration, status, and metadata. Works with both built-in and custom evaluators.
    ///
    /// Parameters:
    ///   - evaluatorId:  The unique identifier of the evaluator to retrieve. Can be a built-in evaluator ID (e.g., Builtin.Helpfulness) or a custom evaluator ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getEvaluator(
        evaluatorId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEvaluatorResponse {
        let input = GetEvaluatorRequest(
            evaluatorId: evaluatorId
        )
        return try await self.getEvaluator(input, logger: logger)
    }

    /// Retrieves information about a specific Gateway.
    @Sendable
    @inlinable
    public func getGateway(_ input: GetGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetGatewayResponse {
        try await self.client.execute(
            operation: "GetGateway", 
            path: "/gateways/{gatewayIdentifier}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a specific Gateway.
    ///
    /// Parameters:
    ///   - gatewayIdentifier: The identifier of the gateway to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getGateway(
        gatewayIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetGatewayResponse {
        let input = GetGatewayRequest(
            gatewayIdentifier: gatewayIdentifier
        )
        return try await self.getGateway(input, logger: logger)
    }

    /// Retrieves information about a specific gateway target.
    @Sendable
    @inlinable
    public func getGatewayTarget(_ input: GetGatewayTargetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetGatewayTargetResponse {
        try await self.client.execute(
            operation: "GetGatewayTarget", 
            path: "/gateways/{gatewayIdentifier}/targets/{targetId}/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a specific gateway target.
    ///
    /// Parameters:
    ///   - gatewayIdentifier: The identifier of the gateway that contains the target.
    ///   - targetId: The unique identifier of the target to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getGatewayTarget(
        gatewayIdentifier: String,
        targetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetGatewayTargetResponse {
        let input = GetGatewayTargetRequest(
            gatewayIdentifier: gatewayIdentifier, 
            targetId: targetId
        )
        return try await self.getGatewayTarget(input, logger: logger)
    }

    /// Retrieve an existing Amazon Bedrock AgentCore Memory resource.
    @Sendable
    @inlinable
    public func getMemory(_ input: GetMemoryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMemoryOutput {
        try await self.client.execute(
            operation: "GetMemory", 
            path: "/memories/{memoryId}/details", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve an existing Amazon Bedrock AgentCore Memory resource.
    ///
    /// Parameters:
    ///   - memoryId: The unique identifier of the memory to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMemory(
        memoryId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMemoryOutput {
        let input = GetMemoryInput(
            memoryId: memoryId
        )
        return try await self.getMemory(input, logger: logger)
    }

    /// Retrieves information about an OAuth2 credential provider.
    @Sendable
    @inlinable
    public func getOauth2CredentialProvider(_ input: GetOauth2CredentialProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetOauth2CredentialProviderResponse {
        try await self.client.execute(
            operation: "GetOauth2CredentialProvider", 
            path: "/identities/GetOauth2CredentialProvider", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about an OAuth2 credential provider.
    ///
    /// Parameters:
    ///   - name: The name of the OAuth2 credential provider to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getOauth2CredentialProvider(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetOauth2CredentialProviderResponse {
        let input = GetOauth2CredentialProviderRequest(
            name: name
        )
        return try await self.getOauth2CredentialProvider(input, logger: logger)
    }

    ///  Retrieves detailed information about an online evaluation configuration, including its rules, data sources, evaluators, and execution status.
    @Sendable
    @inlinable
    public func getOnlineEvaluationConfig(_ input: GetOnlineEvaluationConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetOnlineEvaluationConfigResponse {
        try await self.client.execute(
            operation: "GetOnlineEvaluationConfig", 
            path: "/online-evaluation-configs/{onlineEvaluationConfigId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves detailed information about an online evaluation configuration, including its rules, data sources, evaluators, and execution status.
    ///
    /// Parameters:
    ///   - onlineEvaluationConfigId:  The unique identifier of the online evaluation configuration to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getOnlineEvaluationConfig(
        onlineEvaluationConfigId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetOnlineEvaluationConfigResponse {
        let input = GetOnlineEvaluationConfigRequest(
            onlineEvaluationConfigId: onlineEvaluationConfigId
        )
        return try await self.getOnlineEvaluationConfig(input, logger: logger)
    }

    /// Retrieves detailed information about a specific policy within the AgentCore Policy system. This operation returns the complete policy definition, metadata, and current status, allowing administrators to review and manage policy configurations.
    @Sendable
    @inlinable
    public func getPolicy(_ input: GetPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPolicyResponse {
        try await self.client.execute(
            operation: "GetPolicy", 
            path: "/policy-engines/{policyEngineId}/policies/{policyId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves detailed information about a specific policy within the AgentCore Policy system. This operation returns the complete policy definition, metadata, and current status, allowing administrators to review and manage policy configurations.
    ///
    /// Parameters:
    ///   - policyEngineId: The identifier of the policy engine that manages the policy to be retrieved.
    ///   - policyId: The unique identifier of the policy to be retrieved. This must be a valid policy ID that exists within the specified policy engine.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPolicy(
        policyEngineId: String,
        policyId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPolicyResponse {
        let input = GetPolicyRequest(
            policyEngineId: policyEngineId, 
            policyId: policyId
        )
        return try await self.getPolicy(input, logger: logger)
    }

    /// Retrieves detailed information about a specific policy engine within the AgentCore Policy system. This operation returns the complete policy engine configuration, metadata, and current status, allowing administrators to review and manage policy engine settings.
    @Sendable
    @inlinable
    public func getPolicyEngine(_ input: GetPolicyEngineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPolicyEngineResponse {
        try await self.client.execute(
            operation: "GetPolicyEngine", 
            path: "/policy-engines/{policyEngineId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves detailed information about a specific policy engine within the AgentCore Policy system. This operation returns the complete policy engine configuration, metadata, and current status, allowing administrators to review and manage policy engine settings.
    ///
    /// Parameters:
    ///   - policyEngineId: The unique identifier of the policy engine to be retrieved. This must be a valid policy engine ID that exists within the account.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPolicyEngine(
        policyEngineId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPolicyEngineResponse {
        let input = GetPolicyEngineRequest(
            policyEngineId: policyEngineId
        )
        return try await self.getPolicyEngine(input, logger: logger)
    }

    /// Retrieves information about a policy generation request within the AgentCore Policy system. Policy generation converts natural language descriptions into Cedar policy statements using AI-powered translation, enabling non-technical users to create policies.
    @Sendable
    @inlinable
    public func getPolicyGeneration(_ input: GetPolicyGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPolicyGenerationResponse {
        try await self.client.execute(
            operation: "GetPolicyGeneration", 
            path: "/policy-engines/{policyEngineId}/policy-generations/{policyGenerationId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a policy generation request within the AgentCore Policy system. Policy generation converts natural language descriptions into Cedar policy statements using AI-powered translation, enabling non-technical users to create policies.
    ///
    /// Parameters:
    ///   - policyEngineId: The identifier of the policy engine associated with the policy generation request. This provides the context for the generation operation and schema validation.
    ///   - policyGenerationId: The unique identifier of the policy generation request to be retrieved. This must be a valid generation ID from a previous StartPolicyGeneration call.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPolicyGeneration(
        policyEngineId: String,
        policyGenerationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPolicyGenerationResponse {
        let input = GetPolicyGenerationRequest(
            policyEngineId: policyEngineId, 
            policyGenerationId: policyGenerationId
        )
        return try await self.getPolicyGeneration(input, logger: logger)
    }

    /// Retrieves the resource-based policy for a specified resource.  This feature is currently available only for AgentCore Runtime and Gateway.
    @Sendable
    @inlinable
    public func getResourcePolicy(_ input: GetResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResourcePolicyResponse {
        try await self.client.execute(
            operation: "GetResourcePolicy", 
            path: "/resourcepolicy/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the resource-based policy for a specified resource.  This feature is currently available only for AgentCore Runtime and Gateway.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which to retrieve the resource policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResourcePolicy(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResourcePolicyResponse {
        let input = GetResourcePolicyRequest(
            resourceArn: resourceArn
        )
        return try await self.getResourcePolicy(input, logger: logger)
    }

    /// Retrieves information about a token vault.
    @Sendable
    @inlinable
    public func getTokenVault(_ input: GetTokenVaultRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTokenVaultResponse {
        try await self.client.execute(
            operation: "GetTokenVault", 
            path: "/identities/get-token-vault", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a token vault.
    ///
    /// Parameters:
    ///   - tokenVaultId: The unique identifier of the token vault to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTokenVault(
        tokenVaultId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTokenVaultResponse {
        let input = GetTokenVaultRequest(
            tokenVaultId: tokenVaultId
        )
        return try await self.getTokenVault(input, logger: logger)
    }

    /// Retrieves information about a workload identity.
    @Sendable
    @inlinable
    public func getWorkloadIdentity(_ input: GetWorkloadIdentityRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkloadIdentityResponse {
        try await self.client.execute(
            operation: "GetWorkloadIdentity", 
            path: "/identities/GetWorkloadIdentity", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a workload identity.
    ///
    /// Parameters:
    ///   - name: The name of the workload identity to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkloadIdentity(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkloadIdentityResponse {
        let input = GetWorkloadIdentityRequest(
            name: name
        )
        return try await self.getWorkloadIdentity(input, logger: logger)
    }

    /// Lists all endpoints for a specific Amazon Secure Agent.
    @Sendable
    @inlinable
    public func listAgentRuntimeEndpoints(_ input: ListAgentRuntimeEndpointsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentRuntimeEndpointsResponse {
        try await self.client.execute(
            operation: "ListAgentRuntimeEndpoints", 
            path: "/runtimes/{agentRuntimeId}/runtime-endpoints/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all endpoints for a specific Amazon Secure Agent.
    ///
    /// Parameters:
    ///   - agentRuntimeId: The unique identifier of the AgentCore Runtime to list endpoints for.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAgentRuntimeEndpoints(
        agentRuntimeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAgentRuntimeEndpointsResponse {
        let input = ListAgentRuntimeEndpointsRequest(
            agentRuntimeId: agentRuntimeId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAgentRuntimeEndpoints(input, logger: logger)
    }

    /// Lists all versions of a specific Amazon Secure Agent.
    @Sendable
    @inlinable
    public func listAgentRuntimeVersions(_ input: ListAgentRuntimeVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentRuntimeVersionsResponse {
        try await self.client.execute(
            operation: "ListAgentRuntimeVersions", 
            path: "/runtimes/{agentRuntimeId}/versions/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all versions of a specific Amazon Secure Agent.
    ///
    /// Parameters:
    ///   - agentRuntimeId: The unique identifier of the AgentCore Runtime to list versions for.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAgentRuntimeVersions(
        agentRuntimeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAgentRuntimeVersionsResponse {
        let input = ListAgentRuntimeVersionsRequest(
            agentRuntimeId: agentRuntimeId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAgentRuntimeVersions(input, logger: logger)
    }

    /// Lists all Amazon Secure Agents in your account.
    @Sendable
    @inlinable
    public func listAgentRuntimes(_ input: ListAgentRuntimesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAgentRuntimesResponse {
        try await self.client.execute(
            operation: "ListAgentRuntimes", 
            path: "/runtimes/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all Amazon Secure Agents in your account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAgentRuntimes(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAgentRuntimesResponse {
        let input = ListAgentRuntimesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAgentRuntimes(input, logger: logger)
    }

    /// Lists all API key credential providers in your account.
    @Sendable
    @inlinable
    public func listApiKeyCredentialProviders(_ input: ListApiKeyCredentialProvidersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListApiKeyCredentialProvidersResponse {
        try await self.client.execute(
            operation: "ListApiKeyCredentialProviders", 
            path: "/identities/ListApiKeyCredentialProviders", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all API key credential providers in your account.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results to return.
    ///   - nextToken: Pagination token.
    ///   - logger: Logger use during operation
    @inlinable
    public func listApiKeyCredentialProviders(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListApiKeyCredentialProvidersResponse {
        let input = ListApiKeyCredentialProvidersRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listApiKeyCredentialProviders(input, logger: logger)
    }

    /// Lists all custom browsers in your account.
    @Sendable
    @inlinable
    public func listBrowsers(_ input: ListBrowsersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBrowsersResponse {
        try await self.client.execute(
            operation: "ListBrowsers", 
            path: "/browsers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all custom browsers in your account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///   - type: The type of browsers to list. If not specified, all browser types are returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBrowsers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        type: ResourceType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBrowsersResponse {
        let input = ListBrowsersRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            type: type
        )
        return try await self.listBrowsers(input, logger: logger)
    }

    /// Lists all custom code interpreters in your account.
    @Sendable
    @inlinable
    public func listCodeInterpreters(_ input: ListCodeInterpretersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCodeInterpretersResponse {
        try await self.client.execute(
            operation: "ListCodeInterpreters", 
            path: "/code-interpreters", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all custom code interpreters in your account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: A token to retrieve the next page of results.
    ///   - type: The type of code interpreters to list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCodeInterpreters(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        type: ResourceType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCodeInterpretersResponse {
        let input = ListCodeInterpretersRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            type: type
        )
        return try await self.listCodeInterpreters(input, logger: logger)
    }

    ///  Lists all available evaluators, including both builtin evaluators provided by the service and custom evaluators created by the user.
    @Sendable
    @inlinable
    public func listEvaluators(_ input: ListEvaluatorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEvaluatorsResponse {
        try await self.client.execute(
            operation: "ListEvaluators", 
            path: "/evaluators", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists all available evaluators, including both builtin evaluators provided by the service and custom evaluators created by the user.
    ///
    /// Parameters:
    ///   - maxResults:  The maximum number of evaluators to return in a single response.
    ///   - nextToken:  The pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listEvaluators(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEvaluatorsResponse {
        let input = ListEvaluatorsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listEvaluators(input, logger: logger)
    }

    /// Lists all targets for a specific gateway.
    @Sendable
    @inlinable
    public func listGatewayTargets(_ input: ListGatewayTargetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListGatewayTargetsResponse {
        try await self.client.execute(
            operation: "ListGatewayTargets", 
            path: "/gateways/{gatewayIdentifier}/targets/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all targets for a specific gateway.
    ///
    /// Parameters:
    ///   - gatewayIdentifier: The identifier of the gateway to list targets for.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listGatewayTargets(
        gatewayIdentifier: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListGatewayTargetsResponse {
        let input = ListGatewayTargetsRequest(
            gatewayIdentifier: gatewayIdentifier, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listGatewayTargets(input, logger: logger)
    }

    /// Lists all gateways in the account.
    @Sendable
    @inlinable
    public func listGateways(_ input: ListGatewaysRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListGatewaysResponse {
        try await self.client.execute(
            operation: "ListGateways", 
            path: "/gateways/", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all gateways in the account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - nextToken: If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listGateways(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListGatewaysResponse {
        let input = ListGatewaysRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listGateways(input, logger: logger)
    }

    /// Lists the available Amazon Bedrock AgentCore Memory resources in the current Amazon Web Services Region.
    @Sendable
    @inlinable
    public func listMemories(_ input: ListMemoriesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMemoriesOutput {
        try await self.client.execute(
            operation: "ListMemories", 
            path: "/memories/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the available Amazon Bedrock AgentCore Memory resources in the current Amazon Web Services Region.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMemories(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMemoriesOutput {
        let input = ListMemoriesInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listMemories(input, logger: logger)
    }

    /// Lists all OAuth2 credential providers in your account.
    @Sendable
    @inlinable
    public func listOauth2CredentialProviders(_ input: ListOauth2CredentialProvidersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListOauth2CredentialProvidersResponse {
        try await self.client.execute(
            operation: "ListOauth2CredentialProviders", 
            path: "/identities/ListOauth2CredentialProviders", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all OAuth2 credential providers in your account.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results to return.
    ///   - nextToken: Pagination token.
    ///   - logger: Logger use during operation
    @inlinable
    public func listOauth2CredentialProviders(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListOauth2CredentialProvidersResponse {
        let input = ListOauth2CredentialProvidersRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listOauth2CredentialProviders(input, logger: logger)
    }

    ///  Lists all online evaluation configurations in the account, providing summary information about each configuration's status and settings.
    @Sendable
    @inlinable
    public func listOnlineEvaluationConfigs(_ input: ListOnlineEvaluationConfigsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListOnlineEvaluationConfigsResponse {
        try await self.client.execute(
            operation: "ListOnlineEvaluationConfigs", 
            path: "/online-evaluation-configs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists all online evaluation configurations in the account, providing summary information about each configuration's status and settings.
    ///
    /// Parameters:
    ///   - maxResults:  The maximum number of online evaluation configurations to return in a single response.
    ///   - nextToken:  The pagination token from a previous request to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listOnlineEvaluationConfigs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListOnlineEvaluationConfigsResponse {
        let input = ListOnlineEvaluationConfigsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listOnlineEvaluationConfigs(input, logger: logger)
    }

    /// Retrieves a list of policies within the AgentCore Policy engine. This operation supports pagination and filtering to help administrators manage and discover policies across policy engines. Results can be filtered by policy engine or resource associations.
    @Sendable
    @inlinable
    public func listPolicies(_ input: ListPoliciesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPoliciesResponse {
        try await self.client.execute(
            operation: "ListPolicies", 
            path: "/policy-engines/{policyEngineId}/policies", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of policies within the AgentCore Policy engine. This operation supports pagination and filtering to help administrators manage and discover policies across policy engines. Results can be filtered by policy engine or resource associations.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of policies to return in a single response. If not specified, the default is 10 policies per page, with a maximum of 100 per page.
    ///   - nextToken: A pagination token returned from a previous ListPolicies call. Use this token to retrieve the next page of results when the response is paginated.
    ///   - policyEngineId: The identifier of the policy engine whose policies to retrieve.
    ///   - targetResourceScope: Optional filter to list policies that apply to a specific resource scope or resource type. This helps narrow down policy results to those relevant for particular Amazon Web Services resources, agent tools, or operational contexts within the policy engine ecosystem.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPolicies(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyEngineId: String,
        targetResourceScope: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPoliciesResponse {
        let input = ListPoliciesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            policyEngineId: policyEngineId, 
            targetResourceScope: targetResourceScope
        )
        return try await self.listPolicies(input, logger: logger)
    }

    /// Retrieves a list of policy engines within the AgentCore Policy system. This operation supports pagination to help administrators discover and manage policy engines across their account. Each policy engine serves as a container for related policies.
    @Sendable
    @inlinable
    public func listPolicyEngines(_ input: ListPolicyEnginesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPolicyEnginesResponse {
        try await self.client.execute(
            operation: "ListPolicyEngines", 
            path: "/policy-engines", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of policy engines within the AgentCore Policy system. This operation supports pagination to help administrators discover and manage policy engines across their account. Each policy engine serves as a container for related policies.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of policy engines to return in a single response. If not specified, the default is 10 policy engines per page, with a maximum of 100 per page.
    ///   - nextToken: A pagination token returned from a previous ListPolicyEngines call. Use this token to retrieve the next page of results when the response is paginated.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPolicyEngines(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPolicyEnginesResponse {
        let input = ListPolicyEnginesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listPolicyEngines(input, logger: logger)
    }

    /// Retrieves a list of generated policy assets from a policy generation request within the AgentCore Policy system. This operation returns the actual Cedar policies and related artifacts produced by the AI-powered policy generation process, allowing users to review and select from multiple generated policy options.
    @Sendable
    @inlinable
    public func listPolicyGenerationAssets(_ input: ListPolicyGenerationAssetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPolicyGenerationAssetsResponse {
        try await self.client.execute(
            operation: "ListPolicyGenerationAssets", 
            path: "/policy-engines/{policyEngineId}/policy-generations/{policyGenerationId}/assets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of generated policy assets from a policy generation request within the AgentCore Policy system. This operation returns the actual Cedar policies and related artifacts produced by the AI-powered policy generation process, allowing users to review and select from multiple generated policy options.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of policy generation assets to return in a single response. If not specified, the default is 10 assets per page, with a maximum of 100 per page. This helps control response size when dealing with policy generations that produce many alternative policy options.
    ///   - nextToken: A pagination token returned from a previous ListPolicyGenerationAssets call. Use this token to retrieve the next page of assets when the response is paginated due to large numbers of generated policy options.
    ///   - policyEngineId: The unique identifier of the policy engine associated with the policy generation request. This provides the context for the generation operation and ensures assets are retrieved from the correct policy engine.
    ///   - policyGenerationId: The unique identifier of the policy generation request whose assets are to be retrieved. This must be a valid generation ID from a previous StartPolicyGeneration call that has completed processing.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPolicyGenerationAssets(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyEngineId: String,
        policyGenerationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPolicyGenerationAssetsResponse {
        let input = ListPolicyGenerationAssetsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            policyEngineId: policyEngineId, 
            policyGenerationId: policyGenerationId
        )
        return try await self.listPolicyGenerationAssets(input, logger: logger)
    }

    /// Retrieves a list of policy generation requests within the AgentCore Policy system. This operation supports pagination and filtering to help track and manage AI-powered policy generation operations.
    @Sendable
    @inlinable
    public func listPolicyGenerations(_ input: ListPolicyGenerationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPolicyGenerationsResponse {
        try await self.client.execute(
            operation: "ListPolicyGenerations", 
            path: "/policy-engines/{policyEngineId}/policy-generations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of policy generation requests within the AgentCore Policy system. This operation supports pagination and filtering to help track and manage AI-powered policy generation operations.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of policy generations to return in a single response.
    ///   - nextToken: A pagination token for retrieving additional policy generations when results are paginated.
    ///   - policyEngineId: The identifier of the policy engine whose policy generations to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPolicyGenerations(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyEngineId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPolicyGenerationsResponse {
        let input = ListPolicyGenerationsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            policyEngineId: policyEngineId
        )
        return try await self.listPolicyGenerations(input, logger: logger)
    }

    /// Lists the tags associated with the specified resource.  This feature is currently available only for AgentCore Runtime, Browser, Code Interpreter tool, and Gateway.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the tags associated with the specified resource.  This feature is currently available only for AgentCore Runtime, Browser, Code Interpreter tool, and Gateway.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Lists all workload identities in your account.
    @Sendable
    @inlinable
    public func listWorkloadIdentities(_ input: ListWorkloadIdentitiesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkloadIdentitiesResponse {
        try await self.client.execute(
            operation: "ListWorkloadIdentities", 
            path: "/identities/ListWorkloadIdentities", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all workload identities in your account.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results to return.
    ///   - nextToken: Pagination token.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkloadIdentities(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkloadIdentitiesResponse {
        let input = ListWorkloadIdentitiesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listWorkloadIdentities(input, logger: logger)
    }

    /// Creates or updates a resource-based policy for a resource with the specified resourceArn.  This feature is currently available only for AgentCore Runtime and Gateway.
    @Sendable
    @inlinable
    public func putResourcePolicy(_ input: PutResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutResourcePolicyResponse {
        try await self.client.execute(
            operation: "PutResourcePolicy", 
            path: "/resourcepolicy/{resourceArn}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates or updates a resource-based policy for a resource with the specified resourceArn.  This feature is currently available only for AgentCore Runtime and Gateway.
    ///
    /// Parameters:
    ///   - policy: The resource policy to create or update.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which to create or update the resource policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func putResourcePolicy(
        policy: String,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutResourcePolicyResponse {
        let input = PutResourcePolicyRequest(
            policy: policy, 
            resourceArn: resourceArn
        )
        return try await self.putResourcePolicy(input, logger: logger)
    }

    /// Sets the customer master key (CMK) for a token vault.
    @Sendable
    @inlinable
    public func setTokenVaultCMK(_ input: SetTokenVaultCMKRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SetTokenVaultCMKResponse {
        try await self.client.execute(
            operation: "SetTokenVaultCMK", 
            path: "/identities/set-token-vault-cmk", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sets the customer master key (CMK) for a token vault.
    ///
    /// Parameters:
    ///   - kmsConfiguration: The KMS configuration for the token vault, including the key type and KMS key ARN.
    ///   - tokenVaultId: The unique identifier of the token vault to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func setTokenVaultCMK(
        kmsConfiguration: KmsConfiguration,
        tokenVaultId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SetTokenVaultCMKResponse {
        let input = SetTokenVaultCMKRequest(
            kmsConfiguration: kmsConfiguration, 
            tokenVaultId: tokenVaultId
        )
        return try await self.setTokenVaultCMK(input, logger: logger)
    }

    /// Initiates the AI-powered generation of Cedar policies from natural language descriptions within the AgentCore Policy system. This feature enables both technical and non-technical users to create policies by describing their authorization requirements in plain English, which is then automatically translated into formal Cedar policy statements. The generation process analyzes the natural language input along with the Gateway's tool context to produce validated policy options. Generated policy assets are automatically deleted after 7 days, so you should review and create policies from the generated assets within this timeframe. Once created, policies are permanent and not subject to this expiration. Generated policies should be reviewed and tested in log-only mode before deploying to production. Use this when you want to describe policy intent naturally rather than learning Cedar syntax, though generated policies may require refinement for complex scenarios.
    @Sendable
    @inlinable
    public func startPolicyGeneration(_ input: StartPolicyGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartPolicyGenerationResponse {
        try await self.client.execute(
            operation: "StartPolicyGeneration", 
            path: "/policy-engines/{policyEngineId}/policy-generations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initiates the AI-powered generation of Cedar policies from natural language descriptions within the AgentCore Policy system. This feature enables both technical and non-technical users to create policies by describing their authorization requirements in plain English, which is then automatically translated into formal Cedar policy statements. The generation process analyzes the natural language input along with the Gateway's tool context to produce validated policy options. Generated policy assets are automatically deleted after 7 days, so you should review and create policies from the generated assets within this timeframe. Once created, policies are permanent and not subject to this expiration. Generated policies should be reviewed and tested in log-only mode before deploying to production. Use this when you want to describe policy intent naturally rather than learning Cedar syntax, though generated policies may require refinement for complex scenarios.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure the idempotency of the request. The AWS SDK automatically generates this token, so you don't need to provide it in most cases. If you retry a request with the same client token, the service returns the same response without starting a duplicate generation.
    ///   - content: The natural language description of the desired policy behavior. This content is processed by AI to generate corresponding Cedar policy statements that match the described intent.
    ///   - name: A customer-assigned name for the policy generation request. This helps track and identify generation operations, especially when running multiple generations simultaneously.
    ///   - policyEngineId: The identifier of the policy engine that provides the context for policy generation. This engine's schema and tool context are used to ensure generated policies are valid and applicable.
    ///   - resource: The resource information that provides context for policy generation. This helps the AI understand the target resources and generate appropriate access control rules.
    ///   - logger: Logger use during operation
    @inlinable
    public func startPolicyGeneration(
        clientToken: String? = StartPolicyGenerationRequest.idempotencyToken(),
        content: Content,
        name: String,
        policyEngineId: String,
        resource: Resource,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartPolicyGenerationResponse {
        let input = StartPolicyGenerationRequest(
            clientToken: clientToken, 
            content: content, 
            name: name, 
            policyEngineId: policyEngineId, 
            resource: resource
        )
        return try await self.startPolicyGeneration(input, logger: logger)
    }

    /// The gateway targets.
    @Sendable
    @inlinable
    public func synchronizeGatewayTargets(_ input: SynchronizeGatewayTargetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SynchronizeGatewayTargetsResponse {
        try await self.client.execute(
            operation: "SynchronizeGatewayTargets", 
            path: "/gateways/{gatewayIdentifier}/synchronizeTargets", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The gateway targets.
    ///
    /// Parameters:
    ///   - gatewayIdentifier: The gateway Identifier.
    ///   - targetIdList: The target ID list.
    ///   - logger: Logger use during operation
    @inlinable
    public func synchronizeGatewayTargets(
        gatewayIdentifier: String,
        targetIdList: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SynchronizeGatewayTargetsResponse {
        let input = SynchronizeGatewayTargetsRequest(
            gatewayIdentifier: gatewayIdentifier, 
            targetIdList: targetIdList
        )
        return try await self.synchronizeGatewayTargets(input, logger: logger)
    }

    /// Associates the specified tags to a resource with the specified resourceArn. If existing tags on a resource are not specified in the request parameters, they are not changed. When a resource is deleted, the tags associated with that resource are also deleted.  This feature is currently available only for AgentCore Runtime, Browser, Code Interpreter tool, and Gateway.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates the specified tags to a resource with the specified resourceArn. If existing tags on a resource are not specified in the request parameters, they are not changed. When a resource is deleted, the tags associated with that resource are also deleted.  This feature is currently available only for AgentCore Runtime, Browser, Code Interpreter tool, and Gateway.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource that you want to tag.
    ///   - tags: The tags to add to the resource. A tag is a key-value pair.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes the specified tags from the specified resource.  This feature is currently available only for AgentCore Runtime, Browser, Code Interpreter tool, and Gateway.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the specified tags from the specified resource.  This feature is currently available only for AgentCore Runtime, Browser, Code Interpreter tool, and Gateway.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource that you want to untag.
    ///   - tagKeys: The tag keys of the tags to remove from the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates an existing Amazon Secure Agent.
    @Sendable
    @inlinable
    public func updateAgentRuntime(_ input: UpdateAgentRuntimeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAgentRuntimeResponse {
        try await self.client.execute(
            operation: "UpdateAgentRuntime", 
            path: "/runtimes/{agentRuntimeId}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing Amazon Secure Agent.
    ///
    /// Parameters:
    ///   - agentRuntimeArtifact: The updated artifact of the AgentCore Runtime.
    ///   - agentRuntimeId: The unique identifier of the AgentCore Runtime to update.
    ///   - authorizerConfiguration: The updated authorizer configuration for the AgentCore Runtime.
    ///   - clientToken: A unique, case-sensitive identifier to ensure idempotency of the request.
    ///   - description: The updated description of the AgentCore Runtime.
    ///   - environmentVariables: Updated environment variables to set in the AgentCore Runtime environment.
    ///   - lifecycleConfiguration: The updated life cycle configuration for the AgentCore Runtime.
    ///   - networkConfiguration: The updated network configuration for the AgentCore Runtime.
    ///   - protocolConfiguration: 
    ///   - requestHeaderConfiguration: The updated configuration for HTTP request headers that will be passed through to the runtime.
    ///   - roleArn: The updated IAM role ARN that provides permissions for the AgentCore Runtime.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAgentRuntime(
        agentRuntimeArtifact: AgentRuntimeArtifact,
        agentRuntimeId: String,
        authorizerConfiguration: AuthorizerConfiguration? = nil,
        clientToken: String? = UpdateAgentRuntimeRequest.idempotencyToken(),
        description: String? = nil,
        environmentVariables: [String: String]? = nil,
        lifecycleConfiguration: LifecycleConfiguration? = nil,
        networkConfiguration: NetworkConfiguration,
        protocolConfiguration: ProtocolConfiguration? = nil,
        requestHeaderConfiguration: RequestHeaderConfiguration? = nil,
        roleArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAgentRuntimeResponse {
        let input = UpdateAgentRuntimeRequest(
            agentRuntimeArtifact: agentRuntimeArtifact, 
            agentRuntimeId: agentRuntimeId, 
            authorizerConfiguration: authorizerConfiguration, 
            clientToken: clientToken, 
            description: description, 
            environmentVariables: environmentVariables, 
            lifecycleConfiguration: lifecycleConfiguration, 
            networkConfiguration: networkConfiguration, 
            protocolConfiguration: protocolConfiguration, 
            requestHeaderConfiguration: requestHeaderConfiguration, 
            roleArn: roleArn
        )
        return try await self.updateAgentRuntime(input, logger: logger)
    }

    /// Updates an existing Amazon Bedrock AgentCore Runtime endpoint.
    @Sendable
    @inlinable
    public func updateAgentRuntimeEndpoint(_ input: UpdateAgentRuntimeEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAgentRuntimeEndpointResponse {
        try await self.client.execute(
            operation: "UpdateAgentRuntimeEndpoint", 
            path: "/runtimes/{agentRuntimeId}/runtime-endpoints/{endpointName}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing Amazon Bedrock AgentCore Runtime endpoint.
    ///
    /// Parameters:
    ///   - agentRuntimeId: The unique identifier of the AgentCore Runtime associated with the endpoint.
    ///   - agentRuntimeVersion: The updated version of the AgentCore Runtime for the endpoint.
    ///   - clientToken: A unique, case-sensitive identifier to ensure idempotency of the request.
    ///   - description: The updated description of the AgentCore Runtime endpoint.
    ///   - endpointName: The name of the AgentCore Runtime endpoint to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAgentRuntimeEndpoint(
        agentRuntimeId: String,
        agentRuntimeVersion: String? = nil,
        clientToken: String? = UpdateAgentRuntimeEndpointRequest.idempotencyToken(),
        description: String? = nil,
        endpointName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAgentRuntimeEndpointResponse {
        let input = UpdateAgentRuntimeEndpointRequest(
            agentRuntimeId: agentRuntimeId, 
            agentRuntimeVersion: agentRuntimeVersion, 
            clientToken: clientToken, 
            description: description, 
            endpointName: endpointName
        )
        return try await self.updateAgentRuntimeEndpoint(input, logger: logger)
    }

    /// Updates an existing API key credential provider.
    @Sendable
    @inlinable
    public func updateApiKeyCredentialProvider(_ input: UpdateApiKeyCredentialProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateApiKeyCredentialProviderResponse {
        try await self.client.execute(
            operation: "UpdateApiKeyCredentialProvider", 
            path: "/identities/UpdateApiKeyCredentialProvider", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing API key credential provider.
    ///
    /// Parameters:
    ///   - apiKey: The new API key to use for authentication. This value replaces the existing API key and is encrypted and stored securely.
    ///   - name: The name of the API key credential provider to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateApiKeyCredentialProvider(
        apiKey: String,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateApiKeyCredentialProviderResponse {
        let input = UpdateApiKeyCredentialProviderRequest(
            apiKey: apiKey, 
            name: name
        )
        return try await self.updateApiKeyCredentialProvider(input, logger: logger)
    }

    ///  Updates a custom evaluator's configuration, description, or evaluation level. Built-in evaluators cannot be updated. The evaluator must not be locked for modification.
    @Sendable
    @inlinable
    public func updateEvaluator(_ input: UpdateEvaluatorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateEvaluatorResponse {
        try await self.client.execute(
            operation: "UpdateEvaluator", 
            path: "/evaluators/{evaluatorId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates a custom evaluator's configuration, description, or evaluation level. Built-in evaluators cannot be updated. The evaluator must not be locked for modification.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
    ///   - description:  The updated description of the evaluator.
    ///   - evaluatorConfig:  The updated configuration for the evaluator, including LLM-as-a-Judge settings with instructions, rating scale, and model configuration.
    ///   - evaluatorId:  The unique identifier of the evaluator to update.
    ///   - level:  The updated evaluation level (TOOL_CALL, TRACE, or SESSION) that determines the scope of evaluation.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateEvaluator(
        clientToken: String? = UpdateEvaluatorRequest.idempotencyToken(),
        description: String? = nil,
        evaluatorConfig: EvaluatorConfig? = nil,
        evaluatorId: String,
        level: EvaluatorLevel? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateEvaluatorResponse {
        let input = UpdateEvaluatorRequest(
            clientToken: clientToken, 
            description: description, 
            evaluatorConfig: evaluatorConfig, 
            evaluatorId: evaluatorId, 
            level: level
        )
        return try await self.updateEvaluator(input, logger: logger)
    }

    /// Updates an existing gateway.
    @Sendable
    @inlinable
    public func updateGateway(_ input: UpdateGatewayRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateGatewayResponse {
        try await self.client.execute(
            operation: "UpdateGateway", 
            path: "/gateways/{gatewayIdentifier}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing gateway.
    ///
    /// Parameters:
    ///   - authorizerConfiguration: The updated authorizer configuration for the gateway.
    ///   - authorizerType: The updated authorizer type for the gateway.
    ///   - description: The updated description for the gateway.
    ///   - exceptionLevel: The level of detail in error messages returned when invoking the gateway.   If the value is DEBUG, granular exception messages are returned to help a user debug the gateway.   If the value is omitted, a generic error message is returned to the end user.
    ///   - gatewayIdentifier: The identifier of the gateway to update.
    ///   - interceptorConfigurations: The updated interceptor configurations for the gateway.
    ///   - kmsKeyArn: The updated ARN of the KMS key used to encrypt the gateway.
    ///   - name: The name of the gateway. This name must be the same as the one when the gateway was created.
    ///   - policyEngineConfiguration: The updated policy engine configuration for the gateway. A policy engine is a collection of policies that evaluates and authorizes agent tool calls. When associated with a gateway, the policy engine intercepts all agent requests and determines whether to allow or deny each action based on the defined policies.
    ///   - protocolConfiguration: 
    ///   - protocolType: The updated protocol type for the gateway.
    ///   - roleArn: The updated IAM role ARN that provides permissions for the gateway.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateGateway(
        authorizerConfiguration: AuthorizerConfiguration? = nil,
        authorizerType: AuthorizerType,
        description: String? = nil,
        exceptionLevel: ExceptionLevel? = nil,
        gatewayIdentifier: String,
        interceptorConfigurations: [GatewayInterceptorConfiguration]? = nil,
        kmsKeyArn: String? = nil,
        name: String,
        policyEngineConfiguration: GatewayPolicyEngineConfiguration? = nil,
        protocolConfiguration: GatewayProtocolConfiguration? = nil,
        protocolType: GatewayProtocolType,
        roleArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateGatewayResponse {
        let input = UpdateGatewayRequest(
            authorizerConfiguration: authorizerConfiguration, 
            authorizerType: authorizerType, 
            description: description, 
            exceptionLevel: exceptionLevel, 
            gatewayIdentifier: gatewayIdentifier, 
            interceptorConfigurations: interceptorConfigurations, 
            kmsKeyArn: kmsKeyArn, 
            name: name, 
            policyEngineConfiguration: policyEngineConfiguration, 
            protocolConfiguration: protocolConfiguration, 
            protocolType: protocolType, 
            roleArn: roleArn
        )
        return try await self.updateGateway(input, logger: logger)
    }

    /// Updates an existing gateway target.
    @Sendable
    @inlinable
    public func updateGatewayTarget(_ input: UpdateGatewayTargetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateGatewayTargetResponse {
        try await self.client.execute(
            operation: "UpdateGatewayTarget", 
            path: "/gateways/{gatewayIdentifier}/targets/{targetId}/", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing gateway target.
    ///
    /// Parameters:
    ///   - credentialProviderConfigurations: The updated credential provider configurations for the gateway target.
    ///   - description: The updated description for the gateway target.
    ///   - gatewayIdentifier: The unique identifier of the gateway associated with the target.
    ///   - metadataConfiguration: Configuration for HTTP header and query parameter propagation to the gateway target.
    ///   - name: The updated name for the gateway target.
    ///   - targetConfiguration: 
    ///   - targetId: The unique identifier of the gateway target to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateGatewayTarget(
        credentialProviderConfigurations: [CredentialProviderConfiguration]? = nil,
        description: String? = nil,
        gatewayIdentifier: String,
        metadataConfiguration: MetadataConfiguration? = nil,
        name: String,
        targetConfiguration: TargetConfiguration,
        targetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateGatewayTargetResponse {
        let input = UpdateGatewayTargetRequest(
            credentialProviderConfigurations: credentialProviderConfigurations, 
            description: description, 
            gatewayIdentifier: gatewayIdentifier, 
            metadataConfiguration: metadataConfiguration, 
            name: name, 
            targetConfiguration: targetConfiguration, 
            targetId: targetId
        )
        return try await self.updateGatewayTarget(input, logger: logger)
    }

    /// Update an Amazon Bedrock AgentCore Memory resource memory.
    @Sendable
    @inlinable
    public func updateMemory(_ input: UpdateMemoryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateMemoryOutput {
        try await self.client.execute(
            operation: "UpdateMemory", 
            path: "/memories/{memoryId}/update", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update an Amazon Bedrock AgentCore Memory resource memory.
    ///
    /// Parameters:
    ///   - clientToken: A client token is used for keeping track of idempotent requests. It can contain a session id which can be around 250 chars, combined with a unique AWS identifier.
    ///   - description: The updated description of the AgentCore Memory resource.
    ///   - eventExpiryDuration: The number of days after which memory events will expire, between 7 and 365 days.
    ///   - memoryExecutionRoleArn: The ARN of the IAM role that provides permissions for the AgentCore Memory resource.
    ///   - memoryId: The unique identifier of the memory to update.
    ///   - memoryStrategies: The memory strategies to add, modify, or delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateMemory(
        clientToken: String? = UpdateMemoryInput.idempotencyToken(),
        description: String? = nil,
        eventExpiryDuration: Int? = nil,
        memoryExecutionRoleArn: String? = nil,
        memoryId: String,
        memoryStrategies: ModifyMemoryStrategies? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateMemoryOutput {
        let input = UpdateMemoryInput(
            clientToken: clientToken, 
            description: description, 
            eventExpiryDuration: eventExpiryDuration, 
            memoryExecutionRoleArn: memoryExecutionRoleArn, 
            memoryId: memoryId, 
            memoryStrategies: memoryStrategies
        )
        return try await self.updateMemory(input, logger: logger)
    }

    /// Updates an existing OAuth2 credential provider.
    @Sendable
    @inlinable
    public func updateOauth2CredentialProvider(_ input: UpdateOauth2CredentialProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateOauth2CredentialProviderResponse {
        try await self.client.execute(
            operation: "UpdateOauth2CredentialProvider", 
            path: "/identities/UpdateOauth2CredentialProvider", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing OAuth2 credential provider.
    ///
    /// Parameters:
    ///   - credentialProviderVendor: The vendor of the OAuth2 credential provider.
    ///   - name: The name of the OAuth2 credential provider to update.
    ///   - oauth2ProviderConfigInput: The configuration input for the OAuth2 provider.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateOauth2CredentialProvider(
        credentialProviderVendor: CredentialProviderVendorType,
        name: String,
        oauth2ProviderConfigInput: Oauth2ProviderConfigInput,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateOauth2CredentialProviderResponse {
        let input = UpdateOauth2CredentialProviderRequest(
            credentialProviderVendor: credentialProviderVendor, 
            name: name, 
            oauth2ProviderConfigInput: oauth2ProviderConfigInput
        )
        return try await self.updateOauth2CredentialProvider(input, logger: logger)
    }

    ///  Updates an online evaluation configuration's settings, including rules, data sources, evaluators, and execution status. Changes take effect immediately for ongoing evaluations.
    @Sendable
    @inlinable
    public func updateOnlineEvaluationConfig(_ input: UpdateOnlineEvaluationConfigRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateOnlineEvaluationConfigResponse {
        try await self.client.execute(
            operation: "UpdateOnlineEvaluationConfig", 
            path: "/online-evaluation-configs/{onlineEvaluationConfigId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates an online evaluation configuration's settings, including rules, data sources, evaluators, and execution status. Changes take effect immediately for ongoing evaluations.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If you don't specify this field, a value is randomly generated for you. If this token matches a previous request, the service ignores the request, but doesn't return an error. For more information, see Ensuring idempotency.
    ///   - dataSourceConfig:  The updated data source configuration specifying CloudWatch log groups and service names to monitor.
    ///   - description:  The updated description of the online evaluation configuration.
    ///   - evaluationExecutionRoleArn:  The updated Amazon Resource Name (ARN) of the IAM role used for evaluation execution.
    ///   - evaluators:  The updated list of evaluators to apply during online evaluation.
    ///   - executionStatus:  The updated execution status to enable or disable the online evaluation.
    ///   - onlineEvaluationConfigId:  The unique identifier of the online evaluation configuration to update.
    ///   - rule:  The updated evaluation rule containing sampling configuration, filters, and session settings.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateOnlineEvaluationConfig(
        clientToken: String? = UpdateOnlineEvaluationConfigRequest.idempotencyToken(),
        dataSourceConfig: DataSourceConfig? = nil,
        description: String? = nil,
        evaluationExecutionRoleArn: String? = nil,
        evaluators: [EvaluatorReference]? = nil,
        executionStatus: OnlineEvaluationExecutionStatus? = nil,
        onlineEvaluationConfigId: String,
        rule: Rule? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateOnlineEvaluationConfigResponse {
        let input = UpdateOnlineEvaluationConfigRequest(
            clientToken: clientToken, 
            dataSourceConfig: dataSourceConfig, 
            description: description, 
            evaluationExecutionRoleArn: evaluationExecutionRoleArn, 
            evaluators: evaluators, 
            executionStatus: executionStatus, 
            onlineEvaluationConfigId: onlineEvaluationConfigId, 
            rule: rule
        )
        return try await self.updateOnlineEvaluationConfig(input, logger: logger)
    }

    /// Updates an existing policy within the AgentCore Policy system. This operation allows modification of the policy description and definition while maintaining the policy's identity. The updated policy is validated against the Cedar schema before being applied. This is an asynchronous operation. Use the GetPolicy operation to poll the status field to track completion.
    @Sendable
    @inlinable
    public func updatePolicy(_ input: UpdatePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePolicyResponse {
        try await self.client.execute(
            operation: "UpdatePolicy", 
            path: "/policy-engines/{policyEngineId}/policies/{policyId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing policy within the AgentCore Policy system. This operation allows modification of the policy description and definition while maintaining the policy's identity. The updated policy is validated against the Cedar schema before being applied. This is an asynchronous operation. Use the GetPolicy operation to poll the status field to track completion.
    ///
    /// Parameters:
    ///   - definition: The new Cedar policy statement that defines the access control rules. This replaces the existing policy definition with new logic while maintaining the policy's identity.
    ///   - description: The new human-readable description for the policy. This optional field allows updating the policy's documentation while keeping the same policy logic.
    ///   - policyEngineId: The identifier of the policy engine that manages the policy to be updated. This ensures the policy is updated within the correct policy engine context.
    ///   - policyId: The unique identifier of the policy to be updated. This must be a valid policy ID that exists within the specified policy engine.
    ///   - validationMode: The validation mode for the policy update. Determines how Cedar analyzer validation results are handled during policy updates. FAIL_ON_ANY_FINDINGS runs the Cedar analyzer and fails the update if validation issues are detected, ensuring the policy conforms to the Cedar schema and tool context. IGNORE_ALL_FINDINGS runs the Cedar analyzer but allows updates despite validation warnings. Use FAIL_ON_ANY_FINDINGS to ensure policy correctness during updates, especially when modifying policy logic or conditions.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePolicy(
        definition: PolicyDefinition,
        description: String? = nil,
        policyEngineId: String,
        policyId: String,
        validationMode: PolicyValidationMode? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePolicyResponse {
        let input = UpdatePolicyRequest(
            definition: definition, 
            description: description, 
            policyEngineId: policyEngineId, 
            policyId: policyId, 
            validationMode: validationMode
        )
        return try await self.updatePolicy(input, logger: logger)
    }

    /// Updates an existing policy engine within the AgentCore Policy system. This operation allows modification of the policy engine description while maintaining its identity. This is an asynchronous operation. Use the GetPolicyEngine operation to poll the status field to track completion.
    @Sendable
    @inlinable
    public func updatePolicyEngine(_ input: UpdatePolicyEngineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePolicyEngineResponse {
        try await self.client.execute(
            operation: "UpdatePolicyEngine", 
            path: "/policy-engines/{policyEngineId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing policy engine within the AgentCore Policy system. This operation allows modification of the policy engine description while maintaining its identity. This is an asynchronous operation. Use the GetPolicyEngine operation to poll the status field to track completion.
    ///
    /// Parameters:
    ///   - description: The new description for the policy engine.
    ///   - policyEngineId: The unique identifier of the policy engine to be updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePolicyEngine(
        description: String? = nil,
        policyEngineId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePolicyEngineResponse {
        let input = UpdatePolicyEngineRequest(
            description: description, 
            policyEngineId: policyEngineId
        )
        return try await self.updatePolicyEngine(input, logger: logger)
    }

    /// Updates an existing workload identity.
    @Sendable
    @inlinable
    public func updateWorkloadIdentity(_ input: UpdateWorkloadIdentityRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateWorkloadIdentityResponse {
        try await self.client.execute(
            operation: "UpdateWorkloadIdentity", 
            path: "/identities/UpdateWorkloadIdentity", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing workload identity.
    ///
    /// Parameters:
    ///   - allowedResourceOauth2ReturnUrls: The new list of allowed OAuth2 return URLs for resources associated with this workload identity. This list replaces the existing list.
    ///   - name: The name of the workload identity to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateWorkloadIdentity(
        allowedResourceOauth2ReturnUrls: [String]? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateWorkloadIdentityResponse {
        let input = UpdateWorkloadIdentityRequest(
            allowedResourceOauth2ReturnUrls: allowedResourceOauth2ReturnUrls, 
            name: name
        )
        return try await self.updateWorkloadIdentity(input, logger: logger)
    }
}

extension BedrockAgentCoreControl {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: BedrockAgentCoreControl, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension BedrockAgentCoreControl {
    /// Return PaginatorSequence for operation ``listAgentRuntimeEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentRuntimeEndpointsPaginator(
        _ input: ListAgentRuntimeEndpointsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentRuntimeEndpointsRequest, ListAgentRuntimeEndpointsResponse> {
        return .init(
            input: input,
            command: self.listAgentRuntimeEndpoints,
            inputKey: \ListAgentRuntimeEndpointsRequest.nextToken,
            outputKey: \ListAgentRuntimeEndpointsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAgentRuntimeEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - agentRuntimeId: The unique identifier of the AgentCore Runtime to list endpoints for.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentRuntimeEndpointsPaginator(
        agentRuntimeId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAgentRuntimeEndpointsRequest, ListAgentRuntimeEndpointsResponse> {
        let input = ListAgentRuntimeEndpointsRequest(
            agentRuntimeId: agentRuntimeId, 
            maxResults: maxResults
        )
        return self.listAgentRuntimeEndpointsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAgentRuntimeVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentRuntimeVersionsPaginator(
        _ input: ListAgentRuntimeVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentRuntimeVersionsRequest, ListAgentRuntimeVersionsResponse> {
        return .init(
            input: input,
            command: self.listAgentRuntimeVersions,
            inputKey: \ListAgentRuntimeVersionsRequest.nextToken,
            outputKey: \ListAgentRuntimeVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAgentRuntimeVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - agentRuntimeId: The unique identifier of the AgentCore Runtime to list versions for.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentRuntimeVersionsPaginator(
        agentRuntimeId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAgentRuntimeVersionsRequest, ListAgentRuntimeVersionsResponse> {
        let input = ListAgentRuntimeVersionsRequest(
            agentRuntimeId: agentRuntimeId, 
            maxResults: maxResults
        )
        return self.listAgentRuntimeVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAgentRuntimes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentRuntimesPaginator(
        _ input: ListAgentRuntimesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAgentRuntimesRequest, ListAgentRuntimesResponse> {
        return .init(
            input: input,
            command: self.listAgentRuntimes,
            inputKey: \ListAgentRuntimesRequest.nextToken,
            outputKey: \ListAgentRuntimesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAgentRuntimes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAgentRuntimesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAgentRuntimesRequest, ListAgentRuntimesResponse> {
        let input = ListAgentRuntimesRequest(
            maxResults: maxResults
        )
        return self.listAgentRuntimesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listApiKeyCredentialProviders(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listApiKeyCredentialProvidersPaginator(
        _ input: ListApiKeyCredentialProvidersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListApiKeyCredentialProvidersRequest, ListApiKeyCredentialProvidersResponse> {
        return .init(
            input: input,
            command: self.listApiKeyCredentialProviders,
            inputKey: \ListApiKeyCredentialProvidersRequest.nextToken,
            outputKey: \ListApiKeyCredentialProvidersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listApiKeyCredentialProviders(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of results to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listApiKeyCredentialProvidersPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListApiKeyCredentialProvidersRequest, ListApiKeyCredentialProvidersResponse> {
        let input = ListApiKeyCredentialProvidersRequest(
            maxResults: maxResults
        )
        return self.listApiKeyCredentialProvidersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBrowsers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBrowsersPaginator(
        _ input: ListBrowsersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBrowsersRequest, ListBrowsersResponse> {
        return .init(
            input: input,
            command: self.listBrowsers,
            inputKey: \ListBrowsersRequest.nextToken,
            outputKey: \ListBrowsersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBrowsers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
    ///   - type: The type of browsers to list. If not specified, all browser types are returned.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBrowsersPaginator(
        maxResults: Int? = nil,
        type: ResourceType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBrowsersRequest, ListBrowsersResponse> {
        let input = ListBrowsersRequest(
            maxResults: maxResults, 
            type: type
        )
        return self.listBrowsersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCodeInterpreters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCodeInterpretersPaginator(
        _ input: ListCodeInterpretersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCodeInterpretersRequest, ListCodeInterpretersResponse> {
        return .init(
            input: input,
            command: self.listCodeInterpreters,
            inputKey: \ListCodeInterpretersRequest.nextToken,
            outputKey: \ListCodeInterpretersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCodeInterpreters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - type: The type of code interpreters to list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCodeInterpretersPaginator(
        maxResults: Int? = nil,
        type: ResourceType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCodeInterpretersRequest, ListCodeInterpretersResponse> {
        let input = ListCodeInterpretersRequest(
            maxResults: maxResults, 
            type: type
        )
        return self.listCodeInterpretersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listEvaluators(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listEvaluatorsPaginator(
        _ input: ListEvaluatorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListEvaluatorsRequest, ListEvaluatorsResponse> {
        return .init(
            input: input,
            command: self.listEvaluators,
            inputKey: \ListEvaluatorsRequest.nextToken,
            outputKey: \ListEvaluatorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listEvaluators(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults:  The maximum number of evaluators to return in a single response.
    ///   - logger: Logger used for logging
    @inlinable
    public func listEvaluatorsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListEvaluatorsRequest, ListEvaluatorsResponse> {
        let input = ListEvaluatorsRequest(
            maxResults: maxResults
        )
        return self.listEvaluatorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listGatewayTargets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listGatewayTargetsPaginator(
        _ input: ListGatewayTargetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListGatewayTargetsRequest, ListGatewayTargetsResponse> {
        return .init(
            input: input,
            command: self.listGatewayTargets,
            inputKey: \ListGatewayTargetsRequest.nextToken,
            outputKey: \ListGatewayTargetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listGatewayTargets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - gatewayIdentifier: The identifier of the gateway to list targets for.
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listGatewayTargetsPaginator(
        gatewayIdentifier: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListGatewayTargetsRequest, ListGatewayTargetsResponse> {
        let input = ListGatewayTargetsRequest(
            gatewayIdentifier: gatewayIdentifier, 
            maxResults: maxResults
        )
        return self.listGatewayTargetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listGateways(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listGatewaysPaginator(
        _ input: ListGatewaysRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListGatewaysRequest, ListGatewaysResponse> {
        return .init(
            input: input,
            command: self.listGateways,
            inputKey: \ListGatewaysRequest.nextToken,
            outputKey: \ListGatewaysResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listGateways(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listGatewaysPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListGatewaysRequest, ListGatewaysResponse> {
        let input = ListGatewaysRequest(
            maxResults: maxResults
        )
        return self.listGatewaysPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMemories(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMemoriesPaginator(
        _ input: ListMemoriesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMemoriesInput, ListMemoriesOutput> {
        return .init(
            input: input,
            command: self.listMemories,
            inputKey: \ListMemoriesInput.nextToken,
            outputKey: \ListMemoriesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMemories(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 10. The maximum value is 50.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMemoriesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMemoriesInput, ListMemoriesOutput> {
        let input = ListMemoriesInput(
            maxResults: maxResults
        )
        return self.listMemoriesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listOauth2CredentialProviders(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listOauth2CredentialProvidersPaginator(
        _ input: ListOauth2CredentialProvidersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListOauth2CredentialProvidersRequest, ListOauth2CredentialProvidersResponse> {
        return .init(
            input: input,
            command: self.listOauth2CredentialProviders,
            inputKey: \ListOauth2CredentialProvidersRequest.nextToken,
            outputKey: \ListOauth2CredentialProvidersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listOauth2CredentialProviders(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of results to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listOauth2CredentialProvidersPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListOauth2CredentialProvidersRequest, ListOauth2CredentialProvidersResponse> {
        let input = ListOauth2CredentialProvidersRequest(
            maxResults: maxResults
        )
        return self.listOauth2CredentialProvidersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listOnlineEvaluationConfigs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listOnlineEvaluationConfigsPaginator(
        _ input: ListOnlineEvaluationConfigsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListOnlineEvaluationConfigsRequest, ListOnlineEvaluationConfigsResponse> {
        return .init(
            input: input,
            command: self.listOnlineEvaluationConfigs,
            inputKey: \ListOnlineEvaluationConfigsRequest.nextToken,
            outputKey: \ListOnlineEvaluationConfigsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listOnlineEvaluationConfigs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults:  The maximum number of online evaluation configurations to return in a single response.
    ///   - logger: Logger used for logging
    @inlinable
    public func listOnlineEvaluationConfigsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListOnlineEvaluationConfigsRequest, ListOnlineEvaluationConfigsResponse> {
        let input = ListOnlineEvaluationConfigsRequest(
            maxResults: maxResults
        )
        return self.listOnlineEvaluationConfigsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPoliciesPaginator(
        _ input: ListPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPoliciesRequest, ListPoliciesResponse> {
        return .init(
            input: input,
            command: self.listPolicies,
            inputKey: \ListPoliciesRequest.nextToken,
            outputKey: \ListPoliciesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of policies to return in a single response. If not specified, the default is 10 policies per page, with a maximum of 100 per page.
    ///   - policyEngineId: The identifier of the policy engine whose policies to retrieve.
    ///   - targetResourceScope: Optional filter to list policies that apply to a specific resource scope or resource type. This helps narrow down policy results to those relevant for particular Amazon Web Services resources, agent tools, or operational contexts within the policy engine ecosystem.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPoliciesPaginator(
        maxResults: Int? = nil,
        policyEngineId: String,
        targetResourceScope: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPoliciesRequest, ListPoliciesResponse> {
        let input = ListPoliciesRequest(
            maxResults: maxResults, 
            policyEngineId: policyEngineId, 
            targetResourceScope: targetResourceScope
        )
        return self.listPoliciesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPolicyEngines(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyEnginesPaginator(
        _ input: ListPolicyEnginesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPolicyEnginesRequest, ListPolicyEnginesResponse> {
        return .init(
            input: input,
            command: self.listPolicyEngines,
            inputKey: \ListPolicyEnginesRequest.nextToken,
            outputKey: \ListPolicyEnginesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPolicyEngines(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of policy engines to return in a single response. If not specified, the default is 10 policy engines per page, with a maximum of 100 per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyEnginesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPolicyEnginesRequest, ListPolicyEnginesResponse> {
        let input = ListPolicyEnginesRequest(
            maxResults: maxResults
        )
        return self.listPolicyEnginesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPolicyGenerationAssets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyGenerationAssetsPaginator(
        _ input: ListPolicyGenerationAssetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPolicyGenerationAssetsRequest, ListPolicyGenerationAssetsResponse> {
        return .init(
            input: input,
            command: self.listPolicyGenerationAssets,
            inputKey: \ListPolicyGenerationAssetsRequest.nextToken,
            outputKey: \ListPolicyGenerationAssetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPolicyGenerationAssets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of policy generation assets to return in a single response. If not specified, the default is 10 assets per page, with a maximum of 100 per page. This helps control response size when dealing with policy generations that produce many alternative policy options.
    ///   - policyEngineId: The unique identifier of the policy engine associated with the policy generation request. This provides the context for the generation operation and ensures assets are retrieved from the correct policy engine.
    ///   - policyGenerationId: The unique identifier of the policy generation request whose assets are to be retrieved. This must be a valid generation ID from a previous StartPolicyGeneration call that has completed processing.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyGenerationAssetsPaginator(
        maxResults: Int? = nil,
        policyEngineId: String,
        policyGenerationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPolicyGenerationAssetsRequest, ListPolicyGenerationAssetsResponse> {
        let input = ListPolicyGenerationAssetsRequest(
            maxResults: maxResults, 
            policyEngineId: policyEngineId, 
            policyGenerationId: policyGenerationId
        )
        return self.listPolicyGenerationAssetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPolicyGenerations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyGenerationsPaginator(
        _ input: ListPolicyGenerationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPolicyGenerationsRequest, ListPolicyGenerationsResponse> {
        return .init(
            input: input,
            command: self.listPolicyGenerations,
            inputKey: \ListPolicyGenerationsRequest.nextToken,
            outputKey: \ListPolicyGenerationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPolicyGenerations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of policy generations to return in a single response.
    ///   - policyEngineId: The identifier of the policy engine whose policy generations to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyGenerationsPaginator(
        maxResults: Int? = nil,
        policyEngineId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPolicyGenerationsRequest, ListPolicyGenerationsResponse> {
        let input = ListPolicyGenerationsRequest(
            maxResults: maxResults, 
            policyEngineId: policyEngineId
        )
        return self.listPolicyGenerationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkloadIdentities(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadIdentitiesPaginator(
        _ input: ListWorkloadIdentitiesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkloadIdentitiesRequest, ListWorkloadIdentitiesResponse> {
        return .init(
            input: input,
            command: self.listWorkloadIdentities,
            inputKey: \ListWorkloadIdentitiesRequest.nextToken,
            outputKey: \ListWorkloadIdentitiesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkloadIdentities(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of results to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadIdentitiesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkloadIdentitiesRequest, ListWorkloadIdentitiesResponse> {
        let input = ListWorkloadIdentitiesRequest(
            maxResults: maxResults
        )
        return self.listWorkloadIdentitiesPaginator(input, logger: logger)
    }
}

extension BedrockAgentCoreControl.ListAgentRuntimeEndpointsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListAgentRuntimeEndpointsRequest {
        return .init(
            agentRuntimeId: self.agentRuntimeId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgentCoreControl.ListAgentRuntimeVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListAgentRuntimeVersionsRequest {
        return .init(
            agentRuntimeId: self.agentRuntimeId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgentCoreControl.ListAgentRuntimesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListAgentRuntimesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgentCoreControl.ListApiKeyCredentialProvidersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListApiKeyCredentialProvidersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgentCoreControl.ListBrowsersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListBrowsersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            type: self.type
        )
    }
}

extension BedrockAgentCoreControl.ListCodeInterpretersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListCodeInterpretersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            type: self.type
        )
    }
}

extension BedrockAgentCoreControl.ListEvaluatorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListEvaluatorsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgentCoreControl.ListGatewayTargetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListGatewayTargetsRequest {
        return .init(
            gatewayIdentifier: self.gatewayIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgentCoreControl.ListGatewaysRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListGatewaysRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgentCoreControl.ListMemoriesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListMemoriesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgentCoreControl.ListOauth2CredentialProvidersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListOauth2CredentialProvidersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgentCoreControl.ListOnlineEvaluationConfigsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListOnlineEvaluationConfigsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgentCoreControl.ListPoliciesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListPoliciesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            policyEngineId: self.policyEngineId,
            targetResourceScope: self.targetResourceScope
        )
    }
}

extension BedrockAgentCoreControl.ListPolicyEnginesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListPolicyEnginesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension BedrockAgentCoreControl.ListPolicyGenerationAssetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListPolicyGenerationAssetsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            policyEngineId: self.policyEngineId,
            policyGenerationId: self.policyGenerationId
        )
    }
}

extension BedrockAgentCoreControl.ListPolicyGenerationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListPolicyGenerationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            policyEngineId: self.policyEngineId
        )
    }
}

extension BedrockAgentCoreControl.ListWorkloadIdentitiesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCoreControl.ListWorkloadIdentitiesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension BedrockAgentCoreControl {
    /// Waiter for operation ``getMemory(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilMemoryCreated(
        _ input: GetMemoryInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetMemoryInput, _>(
            acceptors: [
                .init(state: .retry, matcher: try! JMESPathMatcher("memory.status", expected: "CREATING")),
                .init(state: .success, matcher: try! JMESPathMatcher("memory.status", expected: "ACTIVE")),
                .init(state: .failure, matcher: try! JMESPathMatcher("memory.status", expected: "FAILED")),
            ],
            command: self.getMemory
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getMemory(_:logger:)``.
    ///
    /// - Parameters:
    ///   - memoryId: The unique identifier of the memory to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilMemoryCreated(
        memoryId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetMemoryInput(
            memoryId: memoryId
        )
        try await self.waitUntilMemoryCreated(input, logger: logger)
    }

    /// Waiter for operation ``getPolicy(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPolicyActive(
        _ input: GetPolicyRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetPolicyRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CREATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "UPDATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETE_FAILED")),
            ],
            minDelayTime: .seconds(2),
            maxDelayTime: .seconds(120),
            command: self.getPolicy
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getPolicy(_:logger:)``.
    ///
    /// - Parameters:
    ///   - policyEngineId: The identifier of the policy engine that manages the policy to be retrieved.
    ///   - policyId: The unique identifier of the policy to be retrieved. This must be a valid policy ID that exists within the specified policy engine.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPolicyActive(
        policyEngineId: String,
        policyId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetPolicyRequest(
            policyEngineId: policyEngineId, 
            policyId: policyId
        )
        try await self.waitUntilPolicyActive(input, logger: logger)
    }

    /// Waiter for operation ``getPolicy(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPolicyDeleted(
        _ input: GetPolicyRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetPolicyRequest, _>(
            acceptors: [
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETE_FAILED")),
            ],
            minDelayTime: .seconds(2),
            maxDelayTime: .seconds(120),
            command: self.getPolicy
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getPolicy(_:logger:)``.
    ///
    /// - Parameters:
    ///   - policyEngineId: The identifier of the policy engine that manages the policy to be retrieved.
    ///   - policyId: The unique identifier of the policy to be retrieved. This must be a valid policy ID that exists within the specified policy engine.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPolicyDeleted(
        policyEngineId: String,
        policyId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetPolicyRequest(
            policyEngineId: policyEngineId, 
            policyId: policyId
        )
        try await self.waitUntilPolicyDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getPolicyEngine(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPolicyEngineActive(
        _ input: GetPolicyEngineRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetPolicyEngineRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CREATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "UPDATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETE_FAILED")),
            ],
            minDelayTime: .seconds(2),
            maxDelayTime: .seconds(120),
            command: self.getPolicyEngine
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getPolicyEngine(_:logger:)``.
    ///
    /// - Parameters:
    ///   - policyEngineId: The unique identifier of the policy engine to be retrieved. This must be a valid policy engine ID that exists within the account.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPolicyEngineActive(
        policyEngineId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetPolicyEngineRequest(
            policyEngineId: policyEngineId
        )
        try await self.waitUntilPolicyEngineActive(input, logger: logger)
    }

    /// Waiter for operation ``getPolicyEngine(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPolicyEngineDeleted(
        _ input: GetPolicyEngineRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetPolicyEngineRequest, _>(
            acceptors: [
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "DELETING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETE_FAILED")),
            ],
            minDelayTime: .seconds(2),
            maxDelayTime: .seconds(120),
            command: self.getPolicyEngine
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getPolicyEngine(_:logger:)``.
    ///
    /// - Parameters:
    ///   - policyEngineId: The unique identifier of the policy engine to be retrieved. This must be a valid policy engine ID that exists within the account.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPolicyEngineDeleted(
        policyEngineId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetPolicyEngineRequest(
            policyEngineId: policyEngineId
        )
        try await self.waitUntilPolicyEngineDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getPolicyGeneration(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPolicyGenerationCompleted(
        _ input: GetPolicyGenerationRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetPolicyGenerationRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "GENERATED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "GENERATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "GENERATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "DELETE_FAILED")),
            ],
            minDelayTime: .seconds(2),
            maxDelayTime: .seconds(120),
            command: self.getPolicyGeneration
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getPolicyGeneration(_:logger:)``.
    ///
    /// - Parameters:
    ///   - policyEngineId: The identifier of the policy engine associated with the policy generation request. This provides the context for the generation operation and schema validation.
    ///   - policyGenerationId: The unique identifier of the policy generation request to be retrieved. This must be a valid generation ID from a previous StartPolicyGeneration call.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilPolicyGenerationCompleted(
        policyEngineId: String,
        policyGenerationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetPolicyGenerationRequest(
            policyEngineId: policyEngineId, 
            policyGenerationId: policyGenerationId
        )
        try await self.waitUntilPolicyGenerationCompleted(input, logger: logger)
    }
}
