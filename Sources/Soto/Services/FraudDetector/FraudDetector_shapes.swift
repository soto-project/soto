//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension FraudDetector {
    // MARK: Enums

    public enum AsyncJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelInProgress = "CANCEL_IN_PROGRESS"
        case canceled = "CANCELED"
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case inProgressInitializing = "IN_PROGRESS_INITIALIZING"
        public var description: String { return self.rawValue }
    }

    public enum DataSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case event = "EVENT"
        case externalModelScore = "EXTERNAL_MODEL_SCORE"
        case modelScore = "MODEL_SCORE"
        public var description: String { return self.rawValue }
    }

    public enum DataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case boolean = "BOOLEAN"
        case datetime = "DATETIME"
        case float = "FLOAT"
        case integer = "INTEGER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum DetectorVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case draft = "DRAFT"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum EventIngestion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Language: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case detectorpl = "DETECTORPL"
        public var description: String { return self.rawValue }
    }

    public enum ListUpdateMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case append = "APPEND"
        case remove = "REMOVE"
        case replace = "REPLACE"
        public var description: String { return self.rawValue }
    }

    public enum ModelEndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case associated = "ASSOCIATED"
        case dissociated = "DISSOCIATED"
        public var description: String { return self.rawValue }
    }

    public enum ModelInputDataFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "TEXT_CSV"
        case json = "APPLICATION_JSON"
        public var description: String { return self.rawValue }
    }

    public enum ModelOutputDataFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "TEXT_CSV"
        case jsonlines = "APPLICATION_JSONLINES"
        public var description: String { return self.rawValue }
    }

    public enum ModelSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sagemaker = "SAGEMAKER"
        public var description: String { return self.rawValue }
    }

    public enum ModelTypeEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountTakeoverInsights = "ACCOUNT_TAKEOVER_INSIGHTS"
        case onlineFraudInsights = "ONLINE_FRAUD_INSIGHTS"
        case transactionFraudInsights = "TRANSACTION_FRAUD_INSIGHTS"
        public var description: String { return self.rawValue }
    }

    public enum ModelVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        case trainingCancelled = "TRAINING_CANCELLED"
        public var description: String { return self.rawValue }
    }

    public enum RuleExecutionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allMatched = "ALL_MATCHED"
        case firstMatched = "FIRST_MATCHED"
        public var description: String { return self.rawValue }
    }

    public enum TrainingDataSourceEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case externalEvents = "EXTERNAL_EVENTS"
        case ingestedEvents = "INGESTED_EVENTS"
        public var description: String { return self.rawValue }
    }

    public enum UnlabeledEventsTreatment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case fraud = "FRAUD"
        case ignore = "IGNORE"
        case legit = "LEGIT"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ATIMetricDataPoint: AWSDecodableShape {
        ///  The anomaly discovery rate. This metric quantifies the percentage of anomalies that can be detected by the model at the selected score threshold.   A lower score threshold increases the percentage of anomalies captured by the model, but would also require challenging a larger percentage of  login events, leading to a higher customer friction.
        public let adr: Float?
        ///  The account takeover discovery rate. This metric quantifies the percentage of account compromise events that can be detected by the model at the selected score threshold. This metric is only available if 50 or more entities with at-least one labeled account takeover event is present in the ingested dataset.
        public let atodr: Float?
        ///  The challenge rate. This indicates the percentage of login events that the model recommends to challenge such as   one-time password, multi-factor authentication, and investigations.
        public let cr: Float?
        ///  The model's threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is  labeled as fraud.
        public let threshold: Float?

        @inlinable
        public init(adr: Float? = nil, atodr: Float? = nil, cr: Float? = nil, threshold: Float? = nil) {
            self.adr = adr
            self.atodr = atodr
            self.cr = cr
            self.threshold = threshold
        }

        private enum CodingKeys: String, CodingKey {
            case adr = "adr"
            case atodr = "atodr"
            case cr = "cr"
            case threshold = "threshold"
        }
    }

    public struct ATIModelPerformance: AWSDecodableShape {
        ///  The anomaly separation index (ASI) score. This metric summarizes the overall ability of the model to separate anomalous activities from the normal behavior. Depending on the business, a  large fraction of these anomalous activities can be malicious and correspond to the account takeover attacks. A model with no separability power will have the lowest possible  ASI score of 0.5, whereas the a model with a high separability power will have the highest possible ASI score of 1.0
        public let asi: Float?

        @inlinable
        public init(asi: Float? = nil) {
            self.asi = asi
        }

        private enum CodingKeys: String, CodingKey {
            case asi = "asi"
        }
    }

    public struct ATITrainingMetricsValue: AWSDecodableShape {
        ///  The model's performance metrics data points.
        public let metricDataPoints: [ATIMetricDataPoint]?
        ///  The model's overall performance scores.
        public let modelPerformance: ATIModelPerformance?

        @inlinable
        public init(metricDataPoints: [ATIMetricDataPoint]? = nil, modelPerformance: ATIModelPerformance? = nil) {
            self.metricDataPoints = metricDataPoints
            self.modelPerformance = modelPerformance
        }

        private enum CodingKeys: String, CodingKey {
            case metricDataPoints = "metricDataPoints"
            case modelPerformance = "modelPerformance"
        }
    }

    public struct AggregatedLogOddsMetric: AWSDecodableShape {
        ///  The relative importance of the variables in the list to the other event variable.
        public let aggregatedVariablesImportance: Float
        ///  The names of all the variables.
        public let variableNames: [String]

        @inlinable
        public init(aggregatedVariablesImportance: Float, variableNames: [String]) {
            self.aggregatedVariablesImportance = aggregatedVariablesImportance
            self.variableNames = variableNames
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedVariablesImportance = "aggregatedVariablesImportance"
            case variableNames = "variableNames"
        }
    }

    public struct AggregatedVariablesImpactExplanation: AWSDecodableShape {
        ///  The names of all the event variables that were used to derive the aggregated variables.
        public let eventVariableNames: [String]?
        ///  The raw, uninterpreted value represented as log-odds of the fraud.  These values are usually between -10 to +10, but range from -infinity to +infinity.   A positive value indicates that the variables drove the risk score up.   A negative value indicates that the variables drove the risk score down.
        public let logOddsImpact: Float?
        ///  The relative impact of the aggregated variables in terms of magnitude on the prediction scores.
        public let relativeImpact: String?

        @inlinable
        public init(eventVariableNames: [String]? = nil, logOddsImpact: Float? = nil, relativeImpact: String? = nil) {
            self.eventVariableNames = eventVariableNames
            self.logOddsImpact = logOddsImpact
            self.relativeImpact = relativeImpact
        }

        private enum CodingKeys: String, CodingKey {
            case eventVariableNames = "eventVariableNames"
            case logOddsImpact = "logOddsImpact"
            case relativeImpact = "relativeImpact"
        }
    }

    public struct AggregatedVariablesImportanceMetrics: AWSDecodableShape {
        ///  List of variables' metrics.
        public let logOddsMetrics: [AggregatedLogOddsMetric]?

        @inlinable
        public init(logOddsMetrics: [AggregatedLogOddsMetric]? = nil) {
            self.logOddsMetrics = logOddsMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case logOddsMetrics = "logOddsMetrics"
        }
    }

    public struct AllowDenyList: AWSDecodableShape {
        ///  The ARN of the list.
        public let arn: String?
        ///  The time the list was created.
        public let createdTime: String?
        ///  The description of the list.
        public let description: String?
        ///  The name of the list.
        public let name: String
        ///  The time the list was last updated.
        public let updatedTime: String?
        ///  The variable type of the list.
        public let variableType: String?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, name: String, updatedTime: String? = nil, variableType: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.name = name
            self.updatedTime = updatedTime
            self.variableType = variableType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case description = "description"
            case name = "name"
            case updatedTime = "updatedTime"
            case variableType = "variableType"
        }
    }

    public struct BatchCreateVariableError: AWSDecodableShape {
        /// The error code.
        public let code: Int?
        /// The error message.
        public let message: String?
        /// The name.
        public let name: String?

        @inlinable
        public init(code: Int? = nil, message: String? = nil, name: String? = nil) {
            self.code = code
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case name = "name"
        }
    }

    public struct BatchCreateVariableRequest: AWSEncodableShape {
        /// A collection of key and value pairs.
        public let tags: [Tag]?
        /// The list of variables for the batch create variable request.
        public let variableEntries: [VariableEntry]

        @inlinable
        public init(tags: [Tag]? = nil, variableEntries: [VariableEntry]) {
            self.tags = tags
            self.variableEntries = variableEntries
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.variableEntries, name: "variableEntries", parent: name, max: 25)
            try self.validate(self.variableEntries, name: "variableEntries", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
            case variableEntries = "variableEntries"
        }
    }

    public struct BatchCreateVariableResult: AWSDecodableShape {
        /// Provides the errors for the BatchCreateVariable request.
        public let errors: [BatchCreateVariableError]?

        @inlinable
        public init(errors: [BatchCreateVariableError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchGetVariableError: AWSDecodableShape {
        /// The error code.
        public let code: Int?
        /// The error message.
        public let message: String?
        /// The error name.
        public let name: String?

        @inlinable
        public init(code: Int? = nil, message: String? = nil, name: String? = nil) {
            self.code = code
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case name = "name"
        }
    }

    public struct BatchGetVariableRequest: AWSEncodableShape {
        /// The list of variable names to get.
        public let names: [String]

        @inlinable
        public init(names: [String]) {
            self.names = names
        }

        public func validate(name: String) throws {
            try self.validate(self.names, name: "names", parent: name, max: 100)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case names = "names"
        }
    }

    public struct BatchGetVariableResult: AWSDecodableShape {
        /// The errors from the request.
        public let errors: [BatchGetVariableError]?
        /// The returned variables.
        public let variables: [Variable]?

        @inlinable
        public init(errors: [BatchGetVariableError]? = nil, variables: [Variable]? = nil) {
            self.errors = errors
            self.variables = variables
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case variables = "variables"
        }
    }

    public struct BatchImport: AWSDecodableShape {
        /// The ARN of the batch import job.
        public let arn: String?
        /// Timestamp of when batch import job completed.
        public let completionTime: String?
        /// The name of the event type.
        public let eventTypeName: String?
        /// The number of records that failed to import.
        public let failedRecordsCount: Int?
        /// The reason batch import job failed.
        public let failureReason: String?
        /// The ARN of the IAM role to use for this job request.
        public let iamRoleArn: String?
        /// The Amazon S3 location of your data file for batch import.
        public let inputPath: String?
        /// The ID of the batch import job.
        public let jobId: String?
        /// The Amazon S3 location of your output file.
        public let outputPath: String?
        /// The number of records processed by batch import job.
        public let processedRecordsCount: Int?
        /// Timestamp of when the batch import job started.
        public let startTime: String?
        /// The status of the batch import job.
        public let status: AsyncJobStatus?
        /// The total number of records in the batch import job.
        public let totalRecordsCount: Int?

        @inlinable
        public init(arn: String? = nil, completionTime: String? = nil, eventTypeName: String? = nil, failedRecordsCount: Int? = nil, failureReason: String? = nil, iamRoleArn: String? = nil, inputPath: String? = nil, jobId: String? = nil, outputPath: String? = nil, processedRecordsCount: Int? = nil, startTime: String? = nil, status: AsyncJobStatus? = nil, totalRecordsCount: Int? = nil) {
            self.arn = arn
            self.completionTime = completionTime
            self.eventTypeName = eventTypeName
            self.failedRecordsCount = failedRecordsCount
            self.failureReason = failureReason
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.outputPath = outputPath
            self.processedRecordsCount = processedRecordsCount
            self.startTime = startTime
            self.status = status
            self.totalRecordsCount = totalRecordsCount
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case completionTime = "completionTime"
            case eventTypeName = "eventTypeName"
            case failedRecordsCount = "failedRecordsCount"
            case failureReason = "failureReason"
            case iamRoleArn = "iamRoleArn"
            case inputPath = "inputPath"
            case jobId = "jobId"
            case outputPath = "outputPath"
            case processedRecordsCount = "processedRecordsCount"
            case startTime = "startTime"
            case status = "status"
            case totalRecordsCount = "totalRecordsCount"
        }
    }

    public struct BatchPrediction: AWSDecodableShape {
        /// The ARN of batch prediction job.
        public let arn: String?
        /// Timestamp of when the batch prediction job completed.
        public let completionTime: String?
        /// The name of the detector.
        public let detectorName: String?
        /// The detector version.
        public let detectorVersion: String?
        /// The name of the event type.
        public let eventTypeName: String?
        /// The reason a batch prediction job failed.
        public let failureReason: String?
        /// The ARN of the IAM role to use for this job request.
        public let iamRoleArn: String?
        /// The Amazon S3 location of your training file.
        public let inputPath: String?
        /// The job ID for the batch prediction.
        public let jobId: String?
        /// Timestamp of most recent heartbeat indicating the batch prediction job was making progress.
        public let lastHeartbeatTime: String?
        /// The Amazon S3 location of your output file.
        public let outputPath: String?
        /// The number of records processed by the batch prediction job.
        public let processedRecordsCount: Int?
        /// Timestamp of when the batch prediction job started.
        public let startTime: String?
        /// The batch prediction status.
        public let status: AsyncJobStatus?
        /// The total number of records in the batch prediction job.
        public let totalRecordsCount: Int?

        @inlinable
        public init(arn: String? = nil, completionTime: String? = nil, detectorName: String? = nil, detectorVersion: String? = nil, eventTypeName: String? = nil, failureReason: String? = nil, iamRoleArn: String? = nil, inputPath: String? = nil, jobId: String? = nil, lastHeartbeatTime: String? = nil, outputPath: String? = nil, processedRecordsCount: Int? = nil, startTime: String? = nil, status: AsyncJobStatus? = nil, totalRecordsCount: Int? = nil) {
            self.arn = arn
            self.completionTime = completionTime
            self.detectorName = detectorName
            self.detectorVersion = detectorVersion
            self.eventTypeName = eventTypeName
            self.failureReason = failureReason
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.lastHeartbeatTime = lastHeartbeatTime
            self.outputPath = outputPath
            self.processedRecordsCount = processedRecordsCount
            self.startTime = startTime
            self.status = status
            self.totalRecordsCount = totalRecordsCount
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case completionTime = "completionTime"
            case detectorName = "detectorName"
            case detectorVersion = "detectorVersion"
            case eventTypeName = "eventTypeName"
            case failureReason = "failureReason"
            case iamRoleArn = "iamRoleArn"
            case inputPath = "inputPath"
            case jobId = "jobId"
            case lastHeartbeatTime = "lastHeartbeatTime"
            case outputPath = "outputPath"
            case processedRecordsCount = "processedRecordsCount"
            case startTime = "startTime"
            case status = "status"
            case totalRecordsCount = "totalRecordsCount"
        }
    }

    public struct CancelBatchImportJobRequest: AWSEncodableShape {
        ///  The ID of an in-progress batch import job to cancel.  Amazon Fraud Detector will throw an error if the batch import job is in FAILED, CANCELED, or  COMPLETED state.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct CancelBatchImportJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct CancelBatchPredictionJobRequest: AWSEncodableShape {
        /// The ID of the batch prediction job to cancel.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct CancelBatchPredictionJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct CreateBatchImportJobRequest: AWSEncodableShape {
        /// The name of the event type.
        public let eventTypeName: String
        /// The ARN of the IAM role created for Amazon S3 bucket that holds your data file. The IAM role must have read permissions to your input S3 bucket and write permissions to your output S3 bucket. For more information about bucket permissions, see User policy examples in the  Amazon S3 User Guide.
        public let iamRoleArn: String
        /// The URI that points to the Amazon S3 location of your data file.
        public let inputPath: String
        /// The ID of the batch import job. The ID cannot be of a past job, unless the job exists in CREATE_FAILED state.
        public let jobId: String
        /// The URI that points to the Amazon S3 location for storing your results.
        public let outputPath: String
        /// A collection of key-value pairs associated with this request.
        public let tags: [Tag]?

        @inlinable
        public init(eventTypeName: String, iamRoleArn: String, inputPath: String, jobId: String, outputPath: String, tags: [Tag]? = nil) {
            self.eventTypeName = eventTypeName
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.outputPath = outputPath
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, max: 256)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, min: 1)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:iam\\:\\:[0-9]{12}\\:role\\/[^\\s]{2,64}$")
            try self.validate(self.inputPath, name: "inputPath", parent: name, max: 512)
            try self.validate(self.inputPath, name: "inputPath", parent: name, min: 1)
            try self.validate(self.inputPath, name: "inputPath", parent: name, pattern: "^s3:\\/\\/(.+)$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.outputPath, name: "outputPath", parent: name, max: 512)
            try self.validate(self.outputPath, name: "outputPath", parent: name, min: 1)
            try self.validate(self.outputPath, name: "outputPath", parent: name, pattern: "^s3:\\/\\/(.+)$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case eventTypeName = "eventTypeName"
            case iamRoleArn = "iamRoleArn"
            case inputPath = "inputPath"
            case jobId = "jobId"
            case outputPath = "outputPath"
            case tags = "tags"
        }
    }

    public struct CreateBatchImportJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct CreateBatchPredictionJobRequest: AWSEncodableShape {
        /// The name of the detector.
        public let detectorName: String
        /// The detector version.
        public let detectorVersion: String?
        /// The name of the event type.
        public let eventTypeName: String
        /// The ARN of the IAM role to use for this job request. The IAM Role must have read permissions to your input S3 bucket and write permissions to your output S3 bucket. For more information about bucket permissions, see User policy examples in the  Amazon S3 User Guide.
        public let iamRoleArn: String
        /// The Amazon S3 location of your training file.
        public let inputPath: String
        /// The ID of the batch prediction job.
        public let jobId: String
        /// The Amazon S3 location of your output file.
        public let outputPath: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(detectorName: String, detectorVersion: String? = nil, eventTypeName: String, iamRoleArn: String, inputPath: String, jobId: String, outputPath: String, tags: [Tag]? = nil) {
            self.detectorName = detectorName
            self.detectorVersion = detectorVersion
            self.eventTypeName = eventTypeName
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.outputPath = outputPath
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorName, name: "detectorName", parent: name, max: 64)
            try self.validate(self.detectorName, name: "detectorName", parent: name, min: 1)
            try self.validate(self.detectorName, name: "detectorName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersion, name: "detectorVersion", parent: name, max: 5)
            try self.validate(self.detectorVersion, name: "detectorVersion", parent: name, min: 1)
            try self.validate(self.detectorVersion, name: "detectorVersion", parent: name, pattern: "^([1-9][0-9]*)$")
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, max: 256)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, min: 1)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:iam\\:\\:[0-9]{12}\\:role\\/[^\\s]{2,64}$")
            try self.validate(self.inputPath, name: "inputPath", parent: name, max: 512)
            try self.validate(self.inputPath, name: "inputPath", parent: name, min: 1)
            try self.validate(self.inputPath, name: "inputPath", parent: name, pattern: "^s3:\\/\\/(.+)$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.outputPath, name: "outputPath", parent: name, max: 512)
            try self.validate(self.outputPath, name: "outputPath", parent: name, min: 1)
            try self.validate(self.outputPath, name: "outputPath", parent: name, pattern: "^s3:\\/\\/(.+)$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorName = "detectorName"
            case detectorVersion = "detectorVersion"
            case eventTypeName = "eventTypeName"
            case iamRoleArn = "iamRoleArn"
            case inputPath = "inputPath"
            case jobId = "jobId"
            case outputPath = "outputPath"
            case tags = "tags"
        }
    }

    public struct CreateBatchPredictionJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct CreateDetectorVersionRequest: AWSEncodableShape {
        /// The description of the detector version.
        public let description: String?
        /// The ID of the detector under which you want to create a new version.
        public let detectorId: String
        /// The Amazon Sagemaker model endpoints to include in the detector version.
        public let externalModelEndpoints: [String]?
        /// The model versions to include in the detector version.
        public let modelVersions: [ModelVersion]?
        /// The rule execution mode for the rules included in the detector version. You can define and edit the rule mode at the detector version level, when it is in draft status. If you specify FIRST_MATCHED, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule. If you specifiy ALL_MATCHED, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules.  The default behavior is FIRST_MATCHED.
        public let ruleExecutionMode: RuleExecutionMode?
        /// The rules to include in the detector version.
        public let rules: [Rule]
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, detectorId: String, externalModelEndpoints: [String]? = nil, modelVersions: [ModelVersion]? = nil, ruleExecutionMode: RuleExecutionMode? = nil, rules: [Rule], tags: [Tag]? = nil) {
            self.description = description
            self.detectorId = detectorId
            self.externalModelEndpoints = externalModelEndpoints
            self.modelVersions = modelVersions
            self.ruleExecutionMode = ruleExecutionMode
            self.rules = rules
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.modelVersions?.forEach {
                try $0.validate(name: "\(name).modelVersions[]")
            }
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case detectorId = "detectorId"
            case externalModelEndpoints = "externalModelEndpoints"
            case modelVersions = "modelVersions"
            case ruleExecutionMode = "ruleExecutionMode"
            case rules = "rules"
            case tags = "tags"
        }
    }

    public struct CreateDetectorVersionResult: AWSDecodableShape {
        /// The ID for the created version's parent detector.
        public let detectorId: String?
        /// The ID for the created detector.
        public let detectorVersionId: String?
        /// The status of the detector version.
        public let status: DetectorVersionStatus?

        @inlinable
        public init(detectorId: String? = nil, detectorVersionId: String? = nil, status: DetectorVersionStatus? = nil) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
            case status = "status"
        }
    }

    public struct CreateListRequest: AWSEncodableShape {
        ///  The description of the list.
        public let description: String?
        ///  The names of the elements, if providing.  You can also create an empty list and add elements later using the UpdateList API.
        public let elements: [String]?
        ///  The name of the list.
        public let name: String
        ///  A collection of the key and value pairs.
        public let tags: [Tag]?
        ///  The variable type of the list. You can only assign the variable type with String data type.  For more information, see  Variable types.
        public let variableType: String?

        @inlinable
        public init(description: String? = nil, elements: [String]? = nil, name: String, tags: [Tag]? = nil, variableType: String? = nil) {
            self.description = description
            self.elements = elements
            self.name = name
            self.tags = tags
            self.variableType = variableType
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.elements?.forEach {
                try validate($0, name: "elements[]", parent: name, max: 320)
                try validate($0, name: "elements[]", parent: name, min: 1)
                try validate($0, name: "elements[]", parent: name, pattern: "^\\S+( +\\S+)*$")
            }
            try self.validate(self.elements, name: "elements", parent: name, max: 100000)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.variableType, name: "variableType", parent: name, max: 64)
            try self.validate(self.variableType, name: "variableType", parent: name, min: 1)
            try self.validate(self.variableType, name: "variableType", parent: name, pattern: "^[A-Z_]{1,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case elements = "elements"
            case name = "name"
            case tags = "tags"
            case variableType = "variableType"
        }
    }

    public struct CreateListResult: AWSDecodableShape {
        public init() {}
    }

    public struct CreateModelRequest: AWSEncodableShape {
        /// The model description.
        public let description: String?
        /// The name of the event type.
        public let eventTypeName: String
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, eventTypeName: String, modelId: String, modelType: ModelTypeEnum, tags: [Tag]? = nil) {
            self.description = description
            self.eventTypeName = eventTypeName
            self.modelId = modelId
            self.modelType = modelType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case eventTypeName = "eventTypeName"
            case modelId = "modelId"
            case modelType = "modelType"
            case tags = "tags"
        }
    }

    public struct CreateModelResult: AWSDecodableShape {
        public init() {}
    }

    public struct CreateModelVersionRequest: AWSEncodableShape {
        /// Details of the external events data used for model version training. Required if trainingDataSource is EXTERNAL_EVENTS.
        public let externalEventsDetail: ExternalEventsDetail?
        /// Details of the ingested events data used for model version training. Required if trainingDataSource is INGESTED_EVENTS.
        public let ingestedEventsDetail: IngestedEventsDetail?
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// A collection of key and value pairs.
        public let tags: [Tag]?
        /// The training data schema.
        public let trainingDataSchema: TrainingDataSchema
        /// The training data source location in Amazon S3.
        public let trainingDataSource: TrainingDataSourceEnum

        @inlinable
        public init(externalEventsDetail: ExternalEventsDetail? = nil, ingestedEventsDetail: IngestedEventsDetail? = nil, modelId: String, modelType: ModelTypeEnum, tags: [Tag]? = nil, trainingDataSchema: TrainingDataSchema, trainingDataSource: TrainingDataSourceEnum) {
            self.externalEventsDetail = externalEventsDetail
            self.ingestedEventsDetail = ingestedEventsDetail
            self.modelId = modelId
            self.modelType = modelType
            self.tags = tags
            self.trainingDataSchema = trainingDataSchema
            self.trainingDataSource = trainingDataSource
        }

        public func validate(name: String) throws {
            try self.externalEventsDetail?.validate(name: "\(name).externalEventsDetail")
            try self.ingestedEventsDetail?.validate(name: "\(name).ingestedEventsDetail")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case externalEventsDetail = "externalEventsDetail"
            case ingestedEventsDetail = "ingestedEventsDetail"
            case modelId = "modelId"
            case modelType = "modelType"
            case tags = "tags"
            case trainingDataSchema = "trainingDataSchema"
            case trainingDataSource = "trainingDataSource"
        }
    }

    public struct CreateModelVersionResult: AWSDecodableShape {
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The model version number of the model version created.
        public let modelVersionNumber: String?
        /// The model version status.
        public let status: String?

        @inlinable
        public init(modelId: String? = nil, modelType: ModelTypeEnum? = nil, modelVersionNumber: String? = nil, status: String? = nil) {
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case modelId = "modelId"
            case modelType = "modelType"
            case modelVersionNumber = "modelVersionNumber"
            case status = "status"
        }
    }

    public struct CreateRuleRequest: AWSEncodableShape {
        /// The rule description.
        public let description: String?
        /// The detector ID for the rule's parent detector.
        public let detectorId: String
        /// The rule expression.
        public let expression: String
        /// The language of the rule.
        public let language: Language
        /// The outcome or outcomes returned when the rule expression matches.
        public let outcomes: [String]
        /// The rule ID.
        public let ruleId: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, detectorId: String, expression: String, language: Language, outcomes: [String], ruleId: String, tags: [Tag]? = nil) {
            self.description = description
            self.detectorId = detectorId
            self.expression = expression
            self.language = language
            self.outcomes = outcomes
            self.ruleId = ruleId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.outcomes, name: "outcomes", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 64)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case detectorId = "detectorId"
            case expression = "expression"
            case language = "language"
            case outcomes = "outcomes"
            case ruleId = "ruleId"
            case tags = "tags"
        }
    }

    public struct CreateRuleResult: AWSDecodableShape {
        /// The created rule.
        public let rule: Rule?

        @inlinable
        public init(rule: Rule? = nil) {
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "rule"
        }
    }

    public struct CreateVariableRequest: AWSEncodableShape {
        /// The source of the data.
        public let dataSource: DataSource
        /// The data type of the variable.
        public let dataType: DataType
        /// The default value for the variable when no value is received.
        public let defaultValue: String
        /// The description.
        public let description: String?
        /// The name of the variable.
        public let name: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?
        /// The variable type. For more information see Variable types.
        /// 				 Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        public let variableType: String?

        @inlinable
        public init(dataSource: DataSource, dataType: DataType, defaultValue: String, description: String? = nil, name: String, tags: [Tag]? = nil, variableType: String? = nil) {
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.tags = tags
            self.variableType = variableType
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
            case dataType = "dataType"
            case defaultValue = "defaultValue"
            case description = "description"
            case name = "name"
            case tags = "tags"
            case variableType = "variableType"
        }
    }

    public struct CreateVariableResult: AWSDecodableShape {
        public init() {}
    }

    public struct DataValidationMetrics: AWSDecodableShape {
        /// The field-specific model training validation messages.
        public let fieldLevelMessages: [FieldValidationMessage]?
        /// The file-specific model training data validation messages.
        public let fileLevelMessages: [FileValidationMessage]?

        @inlinable
        public init(fieldLevelMessages: [FieldValidationMessage]? = nil, fileLevelMessages: [FileValidationMessage]? = nil) {
            self.fieldLevelMessages = fieldLevelMessages
            self.fileLevelMessages = fileLevelMessages
        }

        private enum CodingKeys: String, CodingKey {
            case fieldLevelMessages = "fieldLevelMessages"
            case fileLevelMessages = "fileLevelMessages"
        }
    }

    public struct DeleteBatchImportJobRequest: AWSEncodableShape {
        /// The ID of the batch import job to delete.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct DeleteBatchImportJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteBatchPredictionJobRequest: AWSEncodableShape {
        /// The ID of the batch prediction job to delete.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct DeleteBatchPredictionJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDetectorRequest: AWSEncodableShape {
        /// The ID of the detector to delete.
        public let detectorId: String

        @inlinable
        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
        }
    }

    public struct DeleteDetectorResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDetectorVersionRequest: AWSEncodableShape {
        /// The ID of the parent detector for the detector version to delete.
        public let detectorId: String
        /// The ID of the detector version to delete.
        public let detectorVersionId: String

        @inlinable
        public init(detectorId: String, detectorVersionId: String) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
        }
    }

    public struct DeleteDetectorVersionResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEntityTypeRequest: AWSEncodableShape {
        /// The name of the entity type to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteEntityTypeResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEventRequest: AWSEncodableShape {
        /// Specifies whether or not to delete any predictions associated with the event. If set to True,
        public let deleteAuditHistory: Bool?
        /// The ID of the event to delete.
        public let eventId: String
        /// The name of the event type.
        public let eventTypeName: String

        @inlinable
        public init(deleteAuditHistory: Bool? = nil, eventId: String, eventTypeName: String) {
            self.deleteAuditHistory = deleteAuditHistory
            self.eventId = eventId
            self.eventTypeName = eventTypeName
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 64)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 1)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAuditHistory = "deleteAuditHistory"
            case eventId = "eventId"
            case eventTypeName = "eventTypeName"
        }
    }

    public struct DeleteEventResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEventTypeRequest: AWSEncodableShape {
        /// The name of the event type to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteEventTypeResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEventsByEventTypeRequest: AWSEncodableShape {
        /// The name of the event type.
        public let eventTypeName: String

        @inlinable
        public init(eventTypeName: String) {
            self.eventTypeName = eventTypeName
        }

        public func validate(name: String) throws {
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTypeName = "eventTypeName"
        }
    }

    public struct DeleteEventsByEventTypeResult: AWSDecodableShape {
        /// The status of the delete request.
        public let eventsDeletionStatus: String?
        /// Name of event type for which to delete the events.
        public let eventTypeName: String?

        @inlinable
        public init(eventsDeletionStatus: String? = nil, eventTypeName: String? = nil) {
            self.eventsDeletionStatus = eventsDeletionStatus
            self.eventTypeName = eventTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case eventsDeletionStatus = "eventsDeletionStatus"
            case eventTypeName = "eventTypeName"
        }
    }

    public struct DeleteExternalModelRequest: AWSEncodableShape {
        /// The endpoint of the Amazon Sagemaker model to delete.
        public let modelEndpoint: String

        @inlinable
        public init(modelEndpoint: String) {
            self.modelEndpoint = modelEndpoint
        }

        public func validate(name: String) throws {
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, max: 63)
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, min: 1)
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, pattern: "^[0-9A-Za-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelEndpoint = "modelEndpoint"
        }
    }

    public struct DeleteExternalModelResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLabelRequest: AWSEncodableShape {
        /// The name of the label to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteLabelResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteListRequest: AWSEncodableShape {
        ///  The name of the list to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteListResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteModelRequest: AWSEncodableShape {
        /// The model ID of the model to delete.
        public let modelId: String
        /// The model type of the model to delete.
        public let modelType: ModelTypeEnum

        @inlinable
        public init(modelId: String, modelType: ModelTypeEnum) {
            self.modelId = modelId
            self.modelType = modelType
        }

        public func validate(name: String) throws {
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelId = "modelId"
            case modelType = "modelType"
        }
    }

    public struct DeleteModelResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteModelVersionRequest: AWSEncodableShape {
        /// The model ID of the model version to delete.
        public let modelId: String
        /// The model type of the model version to delete.
        public let modelType: ModelTypeEnum
        /// The model version number of the model version to delete.
        public let modelVersionNumber: String

        @inlinable
        public init(modelId: String, modelType: ModelTypeEnum, modelVersionNumber: String) {
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, max: 7)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, min: 3)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, pattern: "^[1-9][0-9]{0,3}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelId = "modelId"
            case modelType = "modelType"
            case modelVersionNumber = "modelVersionNumber"
        }
    }

    public struct DeleteModelVersionResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOutcomeRequest: AWSEncodableShape {
        /// The name of the outcome to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteOutcomeResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRuleRequest: AWSEncodableShape {
        public let rule: Rule

        @inlinable
        public init(rule: Rule) {
            self.rule = rule
        }

        public func validate(name: String) throws {
            try self.rule.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "rule"
        }
    }

    public struct DeleteRuleResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVariableRequest: AWSEncodableShape {
        /// The name of the variable to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DeleteVariableResult: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeDetectorRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The maximum number of results to return for the request.
        public let maxResults: Int?
        /// The next token from the previous response.
        public let nextToken: String?

        @inlinable
        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeDetectorResult: AWSDecodableShape {
        /// The detector ARN.
        public let arn: String?
        /// The detector ID.
        public let detectorId: String?
        /// The status and description for each detector version.
        public let detectorVersionSummaries: [DetectorVersionSummary]?
        /// The next token to be used for subsequent requests.
        public let nextToken: String?

        @inlinable
        public init(arn: String? = nil, detectorId: String? = nil, detectorVersionSummaries: [DetectorVersionSummary]? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.detectorId = detectorId
            self.detectorVersionSummaries = detectorVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case detectorId = "detectorId"
            case detectorVersionSummaries = "detectorVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeModelVersionsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The model version number.
        public let modelVersionNumber: String?
        /// The next token from the previous results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, modelId: String? = nil, modelType: ModelTypeEnum? = nil, modelVersionNumber: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, max: 7)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, min: 3)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, pattern: "^[1-9][0-9]{0,3}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case modelId = "modelId"
            case modelType = "modelType"
            case modelVersionNumber = "modelVersionNumber"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeModelVersionsResult: AWSDecodableShape {
        /// The model version details.
        public let modelVersionDetails: [ModelVersionDetail]?
        /// The next token.
        public let nextToken: String?

        @inlinable
        public init(modelVersionDetails: [ModelVersionDetail]? = nil, nextToken: String? = nil) {
            self.modelVersionDetails = modelVersionDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelVersionDetails = "modelVersionDetails"
            case nextToken = "nextToken"
        }
    }

    public struct Detector: AWSDecodableShape {
        /// The detector ARN.
        public let arn: String?
        /// Timestamp of when the detector was created.
        public let createdTime: String?
        /// The detector description.
        public let description: String?
        /// The detector ID.
        public let detectorId: String?
        /// The name of the event type.
        public let eventTypeName: String?
        /// Timestamp of when the detector was last updated.
        public let lastUpdatedTime: String?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, detectorId: String? = nil, eventTypeName: String? = nil, lastUpdatedTime: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.eventTypeName = eventTypeName
            self.lastUpdatedTime = lastUpdatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case description = "description"
            case detectorId = "detectorId"
            case eventTypeName = "eventTypeName"
            case lastUpdatedTime = "lastUpdatedTime"
        }
    }

    public struct DetectorVersionSummary: AWSDecodableShape {
        /// The detector version description.
        public let description: String?
        /// The detector version ID.
        public let detectorVersionId: String?
        /// Timestamp of when the detector version was last updated.
        public let lastUpdatedTime: String?
        /// The detector version status.
        public let status: DetectorVersionStatus?

        @inlinable
        public init(description: String? = nil, detectorVersionId: String? = nil, lastUpdatedTime: String? = nil, status: DetectorVersionStatus? = nil) {
            self.description = description
            self.detectorVersionId = detectorVersionId
            self.lastUpdatedTime = lastUpdatedTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case detectorVersionId = "detectorVersionId"
            case lastUpdatedTime = "lastUpdatedTime"
            case status = "status"
        }
    }

    public struct Entity: AWSEncodableShape & AWSDecodableShape {
        /// The entity ID. If you do not know the entityId, you can pass unknown, which is areserved string literal.
        public let entityId: String
        /// The entity type.
        public let entityType: String

        @inlinable
        public init(entityId: String, entityType: String) {
            self.entityId = entityId
            self.entityType = entityType
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9A-Za-z_.@+-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "entityId"
            case entityType = "entityType"
        }
    }

    public struct EntityType: AWSDecodableShape {
        /// The entity type ARN.
        public let arn: String?
        /// Timestamp of when the entity type was created.
        public let createdTime: String?
        /// The entity type description.
        public let description: String?
        /// Timestamp of when the entity type was last updated.
        public let lastUpdatedTime: String?
        /// The entity type name.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, lastUpdatedTime: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case description = "description"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct EvaluatedExternalModel: AWSDecodableShape {
        /// Input variables use for generating predictions.
        public let inputVariables: [String: String]?
        /// The endpoint of the external (Amazon Sagemaker) model.
        public let modelEndpoint: String?
        /// Output variables.
        public let outputVariables: [String: String]?
        /// Indicates whether event variables were used to generate predictions.
        public let useEventVariables: Bool?

        @inlinable
        public init(inputVariables: [String: String]? = nil, modelEndpoint: String? = nil, outputVariables: [String: String]? = nil, useEventVariables: Bool? = nil) {
            self.inputVariables = inputVariables
            self.modelEndpoint = modelEndpoint
            self.outputVariables = outputVariables
            self.useEventVariables = useEventVariables
        }

        private enum CodingKeys: String, CodingKey {
            case inputVariables = "inputVariables"
            case modelEndpoint = "modelEndpoint"
            case outputVariables = "outputVariables"
            case useEventVariables = "useEventVariables"
        }
    }

    public struct EvaluatedModelVersion: AWSDecodableShape {
        /// Evaluations generated for the model version.
        public let evaluations: [ModelVersionEvaluation]?
        /// The model ID.
        public let modelId: String?
        /// The model type.  Valid values: ONLINE_FRAUD_INSIGHTS | TRANSACTION_FRAUD_INSIGHTS
        public let modelType: String?
        /// The model version.
        public let modelVersion: String?

        @inlinable
        public init(evaluations: [ModelVersionEvaluation]? = nil, modelId: String? = nil, modelType: String? = nil, modelVersion: String? = nil) {
            self.evaluations = evaluations
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersion = modelVersion
        }

        private enum CodingKeys: String, CodingKey {
            case evaluations = "evaluations"
            case modelId = "modelId"
            case modelType = "modelType"
            case modelVersion = "modelVersion"
        }
    }

    public struct EvaluatedRule: AWSDecodableShape {
        /// Indicates whether the rule was evaluated.
        public let evaluated: Bool?
        /// The rule expression.
        public let expression: String?
        /// The rule expression value.
        public let expressionWithValues: String?
        /// Indicates whether the rule matched.
        public let matched: Bool?
        /// The rule outcome.
        public let outcomes: [String]?
        /// The rule ID.
        public let ruleId: String?
        /// The rule version.
        public let ruleVersion: String?

        @inlinable
        public init(evaluated: Bool? = nil, expression: String? = nil, expressionWithValues: String? = nil, matched: Bool? = nil, outcomes: [String]? = nil, ruleId: String? = nil, ruleVersion: String? = nil) {
            self.evaluated = evaluated
            self.expression = expression
            self.expressionWithValues = expressionWithValues
            self.matched = matched
            self.outcomes = outcomes
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }

        private enum CodingKeys: String, CodingKey {
            case evaluated = "evaluated"
            case expression = "expression"
            case expressionWithValues = "expressionWithValues"
            case matched = "matched"
            case outcomes = "outcomes"
            case ruleId = "ruleId"
            case ruleVersion = "ruleVersion"
        }
    }

    public struct Event: AWSDecodableShape {
        /// The label associated with the event.
        public let currentLabel: String?
        /// The event entities.
        public let entities: [Entity]?
        /// The event ID.
        public let eventId: String?
        /// The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
        public let eventTimestamp: String?
        /// The event type.
        public let eventTypeName: String?
        /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.
        public let eventVariables: [String: String]?
        /// The timestamp associated with the label to update. The timestamp must be specified using ISO 8601 standard in UTC.
        public let labelTimestamp: String?

        @inlinable
        public init(currentLabel: String? = nil, entities: [Entity]? = nil, eventId: String? = nil, eventTimestamp: String? = nil, eventTypeName: String? = nil, eventVariables: [String: String]? = nil, labelTimestamp: String? = nil) {
            self.currentLabel = currentLabel
            self.entities = entities
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.eventVariables = eventVariables
            self.labelTimestamp = labelTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case currentLabel = "currentLabel"
            case entities = "entities"
            case eventId = "eventId"
            case eventTimestamp = "eventTimestamp"
            case eventTypeName = "eventTypeName"
            case eventVariables = "eventVariables"
            case labelTimestamp = "labelTimestamp"
        }
    }

    public struct EventOrchestration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies if event orchestration is enabled through Amazon EventBridge.
        public let eventBridgeEnabled: Bool

        @inlinable
        public init(eventBridgeEnabled: Bool) {
            self.eventBridgeEnabled = eventBridgeEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case eventBridgeEnabled = "eventBridgeEnabled"
        }
    }

    public struct EventPredictionSummary: AWSDecodableShape {
        /// The detector ID.
        public let detectorId: String?
        /// The detector version ID.
        public let detectorVersionId: String?
        /// The event ID.
        public let eventId: String?
        /// The timestamp of the event.
        public let eventTimestamp: String?
        /// The event type.
        public let eventTypeName: String?
        /// The timestamp when the prediction was generated.
        public let predictionTimestamp: String?

        @inlinable
        public init(detectorId: String? = nil, detectorVersionId: String? = nil, eventId: String? = nil, eventTimestamp: String? = nil, eventTypeName: String? = nil, predictionTimestamp: String? = nil) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.predictionTimestamp = predictionTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
            case eventId = "eventId"
            case eventTimestamp = "eventTimestamp"
            case eventTypeName = "eventTypeName"
            case predictionTimestamp = "predictionTimestamp"
        }
    }

    public struct EventType: AWSDecodableShape {
        /// The entity type ARN.
        public let arn: String?
        /// Timestamp of when the event type was created.
        public let createdTime: String?
        /// The event type description.
        public let description: String?
        /// The event type entity types.
        public let entityTypes: [String]?
        /// If Enabled, Amazon Fraud Detector stores event data when you generate a prediction and uses that data to update calculated variables in near real-time. Amazon Fraud Detector uses this data, known as INGESTED_EVENTS, to train your model and  improve fraud predictions.
        public let eventIngestion: EventIngestion?
        /// The event orchestration status.
        public let eventOrchestration: EventOrchestration?
        /// The event type event variables.
        public let eventVariables: [String]?
        /// Data about the stored events.
        public let ingestedEventStatistics: IngestedEventStatistics?
        /// The event type labels.
        public let labels: [String]?
        /// Timestamp of when the event type was last updated.
        public let lastUpdatedTime: String?
        /// The event type name.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, entityTypes: [String]? = nil, eventIngestion: EventIngestion? = nil, eventOrchestration: EventOrchestration? = nil, eventVariables: [String]? = nil, ingestedEventStatistics: IngestedEventStatistics? = nil, labels: [String]? = nil, lastUpdatedTime: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.entityTypes = entityTypes
            self.eventIngestion = eventIngestion
            self.eventOrchestration = eventOrchestration
            self.eventVariables = eventVariables
            self.ingestedEventStatistics = ingestedEventStatistics
            self.labels = labels
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case description = "description"
            case entityTypes = "entityTypes"
            case eventIngestion = "eventIngestion"
            case eventOrchestration = "eventOrchestration"
            case eventVariables = "eventVariables"
            case ingestedEventStatistics = "ingestedEventStatistics"
            case labels = "labels"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct EventVariableSummary: AWSDecodableShape {
        /// The event variable name.
        public let name: String?
        /// The event variable source.
        public let source: String?
        /// The value of the event variable.
        public let value: String?

        @inlinable
        public init(name: String? = nil, source: String? = nil, value: String? = nil) {
            self.name = name
            self.source = source
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case source = "source"
            case value = "value"
        }
    }

    public struct ExternalEventsDetail: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the role that provides Amazon Fraud Detector access to the data location.
        public let dataAccessRoleArn: String
        /// The Amazon S3 bucket location for the data.
        public let dataLocation: String

        @inlinable
        public init(dataAccessRoleArn: String, dataLocation: String) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.dataLocation = dataLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 256)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 1)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:iam\\:\\:[0-9]{12}\\:role\\/[^\\s]{2,64}$")
            try self.validate(self.dataLocation, name: "dataLocation", parent: name, max: 512)
            try self.validate(self.dataLocation, name: "dataLocation", parent: name, min: 1)
            try self.validate(self.dataLocation, name: "dataLocation", parent: name, pattern: "^s3:\\/\\/(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn = "dataAccessRoleArn"
            case dataLocation = "dataLocation"
        }
    }

    public struct ExternalModel: AWSDecodableShape {
        /// The model ARN.
        public let arn: String?
        /// Timestamp of when the model was last created.
        public let createdTime: String?
        /// The input configuration.
        public let inputConfiguration: ModelInputConfiguration?
        /// The role used to invoke the model.
        public let invokeModelEndpointRoleArn: String?
        /// Timestamp of when the model was last updated.
        public let lastUpdatedTime: String?
        /// The Amazon SageMaker model endpoints.
        public let modelEndpoint: String?
        /// The Amazon Fraud Detector status for the external model endpoint
        public let modelEndpointStatus: ModelEndpointStatus?
        /// The source of the model.
        public let modelSource: ModelSource?
        /// The output configuration.
        public let outputConfiguration: ModelOutputConfiguration?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, inputConfiguration: ModelInputConfiguration? = nil, invokeModelEndpointRoleArn: String? = nil, lastUpdatedTime: String? = nil, modelEndpoint: String? = nil, modelEndpointStatus: ModelEndpointStatus? = nil, modelSource: ModelSource? = nil, outputConfiguration: ModelOutputConfiguration? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.inputConfiguration = inputConfiguration
            self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
            self.lastUpdatedTime = lastUpdatedTime
            self.modelEndpoint = modelEndpoint
            self.modelEndpointStatus = modelEndpointStatus
            self.modelSource = modelSource
            self.outputConfiguration = outputConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case inputConfiguration = "inputConfiguration"
            case invokeModelEndpointRoleArn = "invokeModelEndpointRoleArn"
            case lastUpdatedTime = "lastUpdatedTime"
            case modelEndpoint = "modelEndpoint"
            case modelEndpointStatus = "modelEndpointStatus"
            case modelSource = "modelSource"
            case outputConfiguration = "outputConfiguration"
        }
    }

    public struct ExternalModelOutputs: AWSDecodableShape {
        /// The Amazon SageMaker model.
        public let externalModel: ExternalModelSummary?
        /// The fraud prediction scores from Amazon SageMaker model.
        public let outputs: [String: String]?

        @inlinable
        public init(externalModel: ExternalModelSummary? = nil, outputs: [String: String]? = nil) {
            self.externalModel = externalModel
            self.outputs = outputs
        }

        private enum CodingKeys: String, CodingKey {
            case externalModel = "externalModel"
            case outputs = "outputs"
        }
    }

    public struct ExternalModelSummary: AWSDecodableShape {
        /// The endpoint of the Amazon SageMaker model.
        public let modelEndpoint: String?
        /// The source of the model.
        public let modelSource: ModelSource?

        @inlinable
        public init(modelEndpoint: String? = nil, modelSource: ModelSource? = nil) {
            self.modelEndpoint = modelEndpoint
            self.modelSource = modelSource
        }

        private enum CodingKeys: String, CodingKey {
            case modelEndpoint = "modelEndpoint"
            case modelSource = "modelSource"
        }
    }

    public struct FieldValidationMessage: AWSDecodableShape {
        /// The message content.
        public let content: String?
        /// The field name.
        public let fieldName: String?
        /// The message ID.
        public let identifier: String?
        /// The message title.
        public let title: String?
        /// The message type.
        public let type: String?

        @inlinable
        public init(content: String? = nil, fieldName: String? = nil, identifier: String? = nil, title: String? = nil, type: String? = nil) {
            self.content = content
            self.fieldName = fieldName
            self.identifier = identifier
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case fieldName = "fieldName"
            case identifier = "identifier"
            case title = "title"
            case type = "type"
        }
    }

    public struct FileValidationMessage: AWSDecodableShape {
        /// The message content.
        public let content: String?
        /// The message title.
        public let title: String?
        /// The message type.
        public let type: String?

        @inlinable
        public init(content: String? = nil, title: String? = nil, type: String? = nil) {
            self.content = content
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case title = "title"
            case type = "type"
        }
    }

    public struct FilterCondition: AWSEncodableShape {
        /// A statement containing a resource property and a value to specify filter condition.
        public let value: String?

        @inlinable
        public init(value: String? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[0-9A-Za-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct GetBatchImportJobsRequest: AWSEncodableShape {
        /// The ID of the batch import job to get.
        public let jobId: String?
        /// The maximum number of objects to return for request.
        public let maxResults: Int?
        /// The next token from the previous request.
        public let nextToken: String?

        @inlinable
        public init(jobId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetBatchImportJobsResult: AWSDecodableShape {
        /// An array containing the details of each batch import job.
        public let batchImports: [BatchImport]?
        /// The next token for the subsequent resquest.
        public let nextToken: String?

        @inlinable
        public init(batchImports: [BatchImport]? = nil, nextToken: String? = nil) {
            self.batchImports = batchImports
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchImports = "batchImports"
            case nextToken = "nextToken"
        }
    }

    public struct GetBatchPredictionJobsRequest: AWSEncodableShape {
        /// The batch prediction job for which to get the details.
        public let jobId: String?
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The next token from the previous request.
        public let nextToken: String?

        @inlinable
        public init(jobId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetBatchPredictionJobsResult: AWSDecodableShape {
        /// An array containing the details of each batch prediction job.
        public let batchPredictions: [BatchPrediction]?
        /// The next token for the subsequent request.
        public let nextToken: String?

        @inlinable
        public init(batchPredictions: [BatchPrediction]? = nil, nextToken: String? = nil) {
            self.batchPredictions = batchPredictions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchPredictions = "batchPredictions"
            case nextToken = "nextToken"
        }
    }

    public struct GetDeleteEventsByEventTypeStatusRequest: AWSEncodableShape {
        /// Name of event type for which to get the deletion status.
        public let eventTypeName: String

        @inlinable
        public init(eventTypeName: String) {
            self.eventTypeName = eventTypeName
        }

        public func validate(name: String) throws {
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTypeName = "eventTypeName"
        }
    }

    public struct GetDeleteEventsByEventTypeStatusResult: AWSDecodableShape {
        /// The deletion status.
        public let eventsDeletionStatus: AsyncJobStatus?
        /// The event type name.
        public let eventTypeName: String?

        @inlinable
        public init(eventsDeletionStatus: AsyncJobStatus? = nil, eventTypeName: String? = nil) {
            self.eventsDeletionStatus = eventsDeletionStatus
            self.eventTypeName = eventTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case eventsDeletionStatus = "eventsDeletionStatus"
            case eventTypeName = "eventTypeName"
        }
    }

    public struct GetDetectorVersionRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String

        @inlinable
        public init(detectorId: String, detectorVersionId: String) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
        }
    }

    public struct GetDetectorVersionResult: AWSDecodableShape {
        /// The detector version ARN.
        public let arn: String?
        /// The timestamp when the detector version was created.
        public let createdTime: String?
        /// The detector version description.
        public let description: String?
        /// The detector ID.
        public let detectorId: String?
        /// The detector version ID.
        public let detectorVersionId: String?
        /// The Amazon SageMaker model endpoints included in the detector version.
        public let externalModelEndpoints: [String]?
        /// The timestamp when the detector version was last updated.
        public let lastUpdatedTime: String?
        /// The model versions included in the detector version.
        public let modelVersions: [ModelVersion]?
        /// The execution mode of the rule in the dectector  FIRST_MATCHED indicates that Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule.  ALL_MATCHED indicates that Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status.
        public let ruleExecutionMode: RuleExecutionMode?
        /// The rules included in the detector version.
        public let rules: [Rule]?
        /// The status of the detector version.
        public let status: DetectorVersionStatus?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, detectorId: String? = nil, detectorVersionId: String? = nil, externalModelEndpoints: [String]? = nil, lastUpdatedTime: String? = nil, modelVersions: [ModelVersion]? = nil, ruleExecutionMode: RuleExecutionMode? = nil, rules: [Rule]? = nil, status: DetectorVersionStatus? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.externalModelEndpoints = externalModelEndpoints
            self.lastUpdatedTime = lastUpdatedTime
            self.modelVersions = modelVersions
            self.ruleExecutionMode = ruleExecutionMode
            self.rules = rules
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case description = "description"
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
            case externalModelEndpoints = "externalModelEndpoints"
            case lastUpdatedTime = "lastUpdatedTime"
            case modelVersions = "modelVersions"
            case ruleExecutionMode = "ruleExecutionMode"
            case rules = "rules"
            case status = "status"
        }
    }

    public struct GetDetectorsRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String?
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The next token for the subsequent request.
        public let nextToken: String?

        @inlinable
        public init(detectorId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetDetectorsResult: AWSDecodableShape {
        /// The detectors.
        public let detectors: [Detector]?
        /// The next page token.
        public let nextToken: String?

        @inlinable
        public init(detectors: [Detector]? = nil, nextToken: String? = nil) {
            self.detectors = detectors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case detectors = "detectors"
            case nextToken = "nextToken"
        }
    }

    public struct GetEntityTypesRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The name.
        public let name: String?
        /// The next token for the subsequent request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 5)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case name = "name"
            case nextToken = "nextToken"
        }
    }

    public struct GetEntityTypesResult: AWSDecodableShape {
        /// An array of entity types.
        public let entityTypes: [EntityType]?
        /// The next page token.
        public let nextToken: String?

        @inlinable
        public init(entityTypes: [EntityType]? = nil, nextToken: String? = nil) {
            self.entityTypes = entityTypes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entityTypes = "entityTypes"
            case nextToken = "nextToken"
        }
    }

    public struct GetEventPredictionMetadataRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String
        /// The event ID.
        public let eventId: String
        /// The event type associated with the detector specified for the prediction.
        public let eventTypeName: String
        ///  The timestamp that defines when the prediction was generated. The timestamp must be specified using ISO 8601 standard in UTC. We recommend calling ListEventPredictions first, and using the predictionTimestamp value in the response to provide an accurate prediction timestamp value.
        public let predictionTimestamp: String

        @inlinable
        public init(detectorId: String, detectorVersionId: String, eventId: String, eventTypeName: String, predictionTimestamp: String) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.eventId = eventId
            self.eventTypeName = eventTypeName
            self.predictionTimestamp = predictionTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
            try self.validate(self.eventId, name: "eventId", parent: name, max: 64)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 1)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.predictionTimestamp, name: "predictionTimestamp", parent: name, max: 30)
            try self.validate(self.predictionTimestamp, name: "predictionTimestamp", parent: name, min: 11)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
            case eventId = "eventId"
            case eventTypeName = "eventTypeName"
            case predictionTimestamp = "predictionTimestamp"
        }
    }

    public struct GetEventPredictionMetadataResult: AWSDecodableShape {
        /// The detector ID.
        public let detectorId: String?
        /// The detector version ID.
        public let detectorVersionId: String?
        /// The status of the detector version.
        public let detectorVersionStatus: String?
        /// The entity ID.
        public let entityId: String?
        /// The entity type.
        public let entityType: String?
        /// External (Amazon SageMaker) models that were evaluated for generating predictions.
        public let evaluatedExternalModels: [EvaluatedExternalModel]?
        /// Model versions that were evaluated for generating predictions.
        public let evaluatedModelVersions: [EvaluatedModelVersion]?
        /// The event ID.
        public let eventId: String?
        /// The timestamp for when the prediction was generated for the associated event ID.
        public let eventTimestamp: String?
        /// The event type associated with the detector specified for this prediction.
        public let eventTypeName: String?
        /// A list of event variables that influenced the prediction scores.
        public let eventVariables: [EventVariableSummary]?
        /// The outcomes of the matched rule, based on the rule execution mode.
        public let outcomes: [String]?
        /// The timestamp that defines when the prediction was generated.
        public let predictionTimestamp: String?
        /// The execution mode of the rule used for evaluating variable values.
        public let ruleExecutionMode: RuleExecutionMode?
        /// List of rules associated with the detector version that were used for evaluating variable values.
        public let rules: [EvaluatedRule]?

        @inlinable
        public init(detectorId: String? = nil, detectorVersionId: String? = nil, detectorVersionStatus: String? = nil, entityId: String? = nil, entityType: String? = nil, evaluatedExternalModels: [EvaluatedExternalModel]? = nil, evaluatedModelVersions: [EvaluatedModelVersion]? = nil, eventId: String? = nil, eventTimestamp: String? = nil, eventTypeName: String? = nil, eventVariables: [EventVariableSummary]? = nil, outcomes: [String]? = nil, predictionTimestamp: String? = nil, ruleExecutionMode: RuleExecutionMode? = nil, rules: [EvaluatedRule]? = nil) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.detectorVersionStatus = detectorVersionStatus
            self.entityId = entityId
            self.entityType = entityType
            self.evaluatedExternalModels = evaluatedExternalModels
            self.evaluatedModelVersions = evaluatedModelVersions
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.eventVariables = eventVariables
            self.outcomes = outcomes
            self.predictionTimestamp = predictionTimestamp
            self.ruleExecutionMode = ruleExecutionMode
            self.rules = rules
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
            case detectorVersionStatus = "detectorVersionStatus"
            case entityId = "entityId"
            case entityType = "entityType"
            case evaluatedExternalModels = "evaluatedExternalModels"
            case evaluatedModelVersions = "evaluatedModelVersions"
            case eventId = "eventId"
            case eventTimestamp = "eventTimestamp"
            case eventTypeName = "eventTypeName"
            case eventVariables = "eventVariables"
            case outcomes = "outcomes"
            case predictionTimestamp = "predictionTimestamp"
            case ruleExecutionMode = "ruleExecutionMode"
            case rules = "rules"
        }
    }

    public struct GetEventPredictionRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String?
        /// The entity type (associated with the detector's event type) and specific entity ID representing who performed the event. If an entity id is not available, use "UNKNOWN."
        public let entities: [Entity]
        /// The unique ID used to identify the event.
        public let eventId: String
        /// Timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
        public let eventTimestamp: String
        /// The event type associated with the detector specified for the prediction.
        public let eventTypeName: String
        /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and  their corresponding values for the event you are sending for evaluation.  You must provide at least one eventVariable  To ensure most accurate fraud prediction and to simplify your data preparation, Amazon Fraud Detector will replace all missing variables or values as follows:  For Amazon Fraud Detector trained models:  If a null value is provided explicitly for a variable or if a variable is missing, model will replace the null value or the missing variable (no variable name in the eventVariables map)  with calculated default mean/medians for numeric variables and with special values for categorical variables.  For imported SageMaker models:  If a null value is provided explicitly for a variable, the model and rules will use null as the value. If a variable is not provided (no variable name in the eventVariables map), model and rules  will use the default value that is provided for the variable.
        public let eventVariables: [String: String]
        /// The Amazon SageMaker model endpoint input data blobs.
        public let externalModelEndpointDataBlobs: [String: ModelEndpointDataBlob]?

        @inlinable
        public init(detectorId: String, detectorVersionId: String? = nil, entities: [Entity], eventId: String, eventTimestamp: String, eventTypeName: String, eventVariables: [String: String], externalModelEndpointDataBlobs: [String: ModelEndpointDataBlob]? = nil) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.entities = entities
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.eventVariables = eventVariables
            self.externalModelEndpointDataBlobs = externalModelEndpointDataBlobs
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
            try self.entities.forEach {
                try $0.validate(name: "\(name).entities[]")
            }
            try self.validate(self.eventTimestamp, name: "eventTimestamp", parent: name, max: 30)
            try self.validate(self.eventTimestamp, name: "eventTimestamp", parent: name, min: 10)
            try self.eventVariables.forEach {
                try validate($0.key, name: "eventVariables.key", parent: name, max: 64)
                try validate($0.key, name: "eventVariables.key", parent: name, min: 1)
                try validate($0.value, name: "eventVariables[\"\($0.key)\"]", parent: name, max: 8192)
                try validate($0.value, name: "eventVariables[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.eventVariables, name: "eventVariables", parent: name, min: 1)
            try self.externalModelEndpointDataBlobs?.forEach {
                try validate($0.key, name: "externalModelEndpointDataBlobs.key", parent: name, max: 63)
                try validate($0.key, name: "externalModelEndpointDataBlobs.key", parent: name, min: 1)
                try validate($0.key, name: "externalModelEndpointDataBlobs.key", parent: name, pattern: "^[0-9A-Za-z_-]+$")
                try $0.value.validate(name: "\(name).externalModelEndpointDataBlobs[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
            case entities = "entities"
            case eventId = "eventId"
            case eventTimestamp = "eventTimestamp"
            case eventTypeName = "eventTypeName"
            case eventVariables = "eventVariables"
            case externalModelEndpointDataBlobs = "externalModelEndpointDataBlobs"
        }
    }

    public struct GetEventPredictionResult: AWSDecodableShape {
        /// The model scores for Amazon SageMaker models.
        public let externalModelOutputs: [ExternalModelOutputs]?
        /// The model scores. Amazon Fraud Detector generates model scores between 0 and 1000, where 0 is low fraud risk and 1000 is high fraud risk. Model scores are directly related to the false positive rate (FPR). For example, a score of 600 corresponds to an estimated 10% false positive rate whereas a score of 900 corresponds to an estimated 2% false positive rate.
        public let modelScores: [ModelScores]?
        /// The results from the rules.
        public let ruleResults: [RuleResult]?

        @inlinable
        public init(externalModelOutputs: [ExternalModelOutputs]? = nil, modelScores: [ModelScores]? = nil, ruleResults: [RuleResult]? = nil) {
            self.externalModelOutputs = externalModelOutputs
            self.modelScores = modelScores
            self.ruleResults = ruleResults
        }

        private enum CodingKeys: String, CodingKey {
            case externalModelOutputs = "externalModelOutputs"
            case modelScores = "modelScores"
            case ruleResults = "ruleResults"
        }
    }

    public struct GetEventRequest: AWSEncodableShape {
        /// The ID of the event to retrieve.
        public let eventId: String
        /// The event type of the event to retrieve.
        public let eventTypeName: String

        @inlinable
        public init(eventId: String, eventTypeName: String) {
            self.eventId = eventId
            self.eventTypeName = eventTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case eventTypeName = "eventTypeName"
        }
    }

    public struct GetEventResult: AWSDecodableShape {
        /// The details of the event.
        public let event: Event?

        @inlinable
        public init(event: Event? = nil) {
            self.event = event
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
        }
    }

    public struct GetEventTypesRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The name.
        public let name: String?
        /// The next token for the subsequent request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 5)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case name = "name"
            case nextToken = "nextToken"
        }
    }

    public struct GetEventTypesResult: AWSDecodableShape {
        /// An array of event types.
        public let eventTypes: [EventType]?
        /// The next page token.
        public let nextToken: String?

        @inlinable
        public init(eventTypes: [EventType]? = nil, nextToken: String? = nil) {
            self.eventTypes = eventTypes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventTypes = "eventTypes"
            case nextToken = "nextToken"
        }
    }

    public struct GetExternalModelsRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The Amazon SageMaker model endpoint.
        public let modelEndpoint: String?
        /// The next page token for the request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, modelEndpoint: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.modelEndpoint = modelEndpoint
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case modelEndpoint = "modelEndpoint"
            case nextToken = "nextToken"
        }
    }

    public struct GetExternalModelsResult: AWSDecodableShape {
        /// Gets the Amazon SageMaker models.
        public let externalModels: [ExternalModel]?
        /// The next page token to be used in subsequent requests.
        public let nextToken: String?

        @inlinable
        public init(externalModels: [ExternalModel]? = nil, nextToken: String? = nil) {
            self.externalModels = externalModels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case externalModels = "externalModels"
            case nextToken = "nextToken"
        }
    }

    public struct GetKMSEncryptionKeyResult: AWSDecodableShape {
        /// The KMS encryption key.
        public let kmsKey: KMSKey?

        @inlinable
        public init(kmsKey: KMSKey? = nil) {
            self.kmsKey = kmsKey
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKey = "kmsKey"
        }
    }

    public struct GetLabelsRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The name of the label or labels to get.
        public let name: String?
        /// The next token for the subsequent request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 10)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case name = "name"
            case nextToken = "nextToken"
        }
    }

    public struct GetLabelsResult: AWSDecodableShape {
        /// An array of labels.
        public let labels: [Label]?
        /// The next page token.
        public let nextToken: String?

        @inlinable
        public init(labels: [Label]? = nil, nextToken: String? = nil) {
            self.labels = labels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case labels = "labels"
            case nextToken = "nextToken"
        }
    }

    public struct GetListElementsRequest: AWSEncodableShape {
        ///  The maximum number of objects to return for the request.
        public let maxResults: Int?
        ///  The name of the list.
        public let name: String
        ///  The next token for the subsequent request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 5000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 500)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case name = "name"
            case nextToken = "nextToken"
        }
    }

    public struct GetListElementsResult: AWSDecodableShape {
        ///  The list elements.
        public let elements: [String]?
        ///  The next page token.
        public let nextToken: String?

        @inlinable
        public init(elements: [String]? = nil, nextToken: String? = nil) {
            self.elements = elements
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case elements = "elements"
            case nextToken = "nextToken"
        }
    }

    public struct GetListsMetadataRequest: AWSEncodableShape {
        ///  The maximum number of objects to return for the request.
        public let maxResults: Int?
        ///  The name of the list.
        public let name: String?
        ///  The next token for the subsequent request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 5)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case name = "name"
            case nextToken = "nextToken"
        }
    }

    public struct GetListsMetadataResult: AWSDecodableShape {
        ///  The metadata of the specified list or all lists under the account.
        public let lists: [AllowDenyList]?
        ///  The next page token.
        public let nextToken: String?

        @inlinable
        public init(lists: [AllowDenyList]? = nil, nextToken: String? = nil) {
            self.lists = lists
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lists = "lists"
            case nextToken = "nextToken"
        }
    }

    public struct GetModelVersionRequest: AWSEncodableShape {
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// The model version number.
        public let modelVersionNumber: String

        @inlinable
        public init(modelId: String, modelType: ModelTypeEnum, modelVersionNumber: String) {
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, max: 7)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, min: 3)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, pattern: "^[1-9][0-9]{0,3}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelId = "modelId"
            case modelType = "modelType"
            case modelVersionNumber = "modelVersionNumber"
        }
    }

    public struct GetModelVersionResult: AWSDecodableShape {
        /// The model version ARN.
        public let arn: String?
        /// The details of the external events data used for training the model version.  This will be populated if the trainingDataSource is EXTERNAL_EVENTS
        public let externalEventsDetail: ExternalEventsDetail?
        /// The details of the ingested events data used for training the model version.  This will be populated if the trainingDataSource is INGESTED_EVENTS.
        public let ingestedEventsDetail: IngestedEventsDetail?
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The model version number.
        public let modelVersionNumber: String?
        /// The model version status. Possible values are:    TRAINING_IN_PROGRESS     TRAINING_COMPLETE     ACTIVATE_REQUESTED     ACTIVATE_IN_PROGRESS     ACTIVE     INACTIVATE_REQUESTED     INACTIVATE_IN_PROGRESS     INACTIVE     ERROR
        public let status: String?
        /// The training data schema.
        public let trainingDataSchema: TrainingDataSchema?
        /// The training data source.
        public let trainingDataSource: TrainingDataSourceEnum?

        @inlinable
        public init(arn: String? = nil, externalEventsDetail: ExternalEventsDetail? = nil, ingestedEventsDetail: IngestedEventsDetail? = nil, modelId: String? = nil, modelType: ModelTypeEnum? = nil, modelVersionNumber: String? = nil, status: String? = nil, trainingDataSchema: TrainingDataSchema? = nil, trainingDataSource: TrainingDataSourceEnum? = nil) {
            self.arn = arn
            self.externalEventsDetail = externalEventsDetail
            self.ingestedEventsDetail = ingestedEventsDetail
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
            self.trainingDataSchema = trainingDataSchema
            self.trainingDataSource = trainingDataSource
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case externalEventsDetail = "externalEventsDetail"
            case ingestedEventsDetail = "ingestedEventsDetail"
            case modelId = "modelId"
            case modelType = "modelType"
            case modelVersionNumber = "modelVersionNumber"
            case status = "status"
            case trainingDataSchema = "trainingDataSchema"
            case trainingDataSource = "trainingDataSource"
        }
    }

    public struct GetModelsRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The next token for the subsequent request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, modelId: String? = nil, modelType: ModelTypeEnum? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.modelId = modelId
            self.modelType = modelType
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case modelId = "modelId"
            case modelType = "modelType"
            case nextToken = "nextToken"
        }
    }

    public struct GetModelsResult: AWSDecodableShape {
        /// The array of models.
        public let models: [Model]?
        /// The next page token to be used in subsequent requests.
        public let nextToken: String?

        @inlinable
        public init(models: [Model]? = nil, nextToken: String? = nil) {
            self.models = models
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case models = "models"
            case nextToken = "nextToken"
        }
    }

    public struct GetOutcomesRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The name of the outcome or outcomes to get.
        public let name: String?
        /// The next page token for the request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 50)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case name = "name"
            case nextToken = "nextToken"
        }
    }

    public struct GetOutcomesResult: AWSDecodableShape {
        /// The next page token for subsequent requests.
        public let nextToken: String?
        /// The outcomes.
        public let outcomes: [Outcome]?

        @inlinable
        public init(nextToken: String? = nil, outcomes: [Outcome]? = nil) {
            self.nextToken = nextToken
            self.outcomes = outcomes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case outcomes = "outcomes"
        }
    }

    public struct GetRulesRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The maximum number of rules to return for the request.
        public let maxResults: Int?
        /// The next page token.
        public let nextToken: String?
        /// The rule ID.
        public let ruleId: String?
        /// The rule version.
        public let ruleVersion: String?

        @inlinable
        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil, ruleId: String? = nil, ruleVersion: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 50)
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 64)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, max: 5)
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, min: 1)
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case ruleId = "ruleId"
            case ruleVersion = "ruleVersion"
        }
    }

    public struct GetRulesResult: AWSDecodableShape {
        /// The next page token to be used in subsequent requests.
        public let nextToken: String?
        /// The details of the requested rule.
        public let ruleDetails: [RuleDetail]?

        @inlinable
        public init(nextToken: String? = nil, ruleDetails: [RuleDetail]? = nil) {
            self.nextToken = nextToken
            self.ruleDetails = ruleDetails
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case ruleDetails = "ruleDetails"
        }
    }

    public struct GetVariablesRequest: AWSEncodableShape {
        /// The max size per page determined for the get variable request.
        public let maxResults: Int?
        /// The name of the variable.
        public let name: String?
        /// The next page token of the get variable request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case name = "name"
            case nextToken = "nextToken"
        }
    }

    public struct GetVariablesResult: AWSDecodableShape {
        /// The next page token to be used in subsequent requests.
        public let nextToken: String?
        /// The names of the variables returned.
        public let variables: [Variable]?

        @inlinable
        public init(nextToken: String? = nil, variables: [Variable]? = nil) {
            self.nextToken = nextToken
            self.variables = variables
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case variables = "variables"
        }
    }

    public struct IngestedEventStatistics: AWSDecodableShape {
        /// The total size of the stored events.
        public let eventDataSizeInBytes: Int64?
        /// Timestamp of when the stored event was last updated.
        public let lastUpdatedTime: String?
        /// The oldest stored event.
        public let leastRecentEvent: String?
        /// The newest stored event.
        public let mostRecentEvent: String?
        /// The number of stored events.
        public let numberOfEvents: Int64?

        @inlinable
        public init(eventDataSizeInBytes: Int64? = nil, lastUpdatedTime: String? = nil, leastRecentEvent: String? = nil, mostRecentEvent: String? = nil, numberOfEvents: Int64? = nil) {
            self.eventDataSizeInBytes = eventDataSizeInBytes
            self.lastUpdatedTime = lastUpdatedTime
            self.leastRecentEvent = leastRecentEvent
            self.mostRecentEvent = mostRecentEvent
            self.numberOfEvents = numberOfEvents
        }

        private enum CodingKeys: String, CodingKey {
            case eventDataSizeInBytes = "eventDataSizeInBytes"
            case lastUpdatedTime = "lastUpdatedTime"
            case leastRecentEvent = "leastRecentEvent"
            case mostRecentEvent = "mostRecentEvent"
            case numberOfEvents = "numberOfEvents"
        }
    }

    public struct IngestedEventsDetail: AWSEncodableShape & AWSDecodableShape {
        /// The start and stop time of the ingested events.
        public let ingestedEventsTimeWindow: IngestedEventsTimeWindow

        @inlinable
        public init(ingestedEventsTimeWindow: IngestedEventsTimeWindow) {
            self.ingestedEventsTimeWindow = ingestedEventsTimeWindow
        }

        public func validate(name: String) throws {
            try self.ingestedEventsTimeWindow.validate(name: "\(name).ingestedEventsTimeWindow")
        }

        private enum CodingKeys: String, CodingKey {
            case ingestedEventsTimeWindow = "ingestedEventsTimeWindow"
        }
    }

    public struct IngestedEventsTimeWindow: AWSEncodableShape & AWSDecodableShape {
        /// Timestamp of the final ingested event.
        public let endTime: String
        /// Timestamp of the first ingensted event.
        public let startTime: String

        @inlinable
        public init(endTime: String, startTime: String) {
            self.endTime = endTime
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.endTime, name: "endTime", parent: name, max: 30)
            try self.validate(self.endTime, name: "endTime", parent: name, min: 11)
            try self.validate(self.startTime, name: "startTime", parent: name, max: 30)
            try self.validate(self.startTime, name: "startTime", parent: name, min: 11)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case startTime = "startTime"
        }
    }

    public struct KMSKey: AWSDecodableShape {
        /// The encryption key ARN.
        public let kmsEncryptionKeyArn: String?

        @inlinable
        public init(kmsEncryptionKeyArn: String? = nil) {
            self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case kmsEncryptionKeyArn = "kmsEncryptionKeyArn"
        }
    }

    public struct Label: AWSDecodableShape {
        /// The label ARN.
        public let arn: String?
        /// Timestamp of when the event type was created.
        public let createdTime: String?
        /// The label description.
        public let description: String?
        /// Timestamp of when the label was last updated.
        public let lastUpdatedTime: String?
        /// The label name.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, lastUpdatedTime: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case description = "description"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct LabelSchema: AWSEncodableShape & AWSDecodableShape {
        /// The label mapper maps the Amazon Fraud Detector supported model classification labels (FRAUD, LEGIT) to the appropriate event type labels. For example, if "FRAUD" and "LEGIT" are Amazon Fraud Detector supported labels, this mapper could be: {"FRAUD" => ["0"], "LEGIT" => ["1"]} or {"FRAUD" => ["false"], "LEGIT" => ["true"]} or {"FRAUD" => ["fraud", "abuse"], "LEGIT" => ["legit", "safe"]}. The value part of the mapper is a list, because you may have multiple label variants from your event type for a single Amazon Fraud Detector label.
        public let labelMapper: [String: [String]]?
        /// The action to take for unlabeled events.   Use IGNORE if you want the unlabeled events to be ignored. This is recommended when the majority of the events in the dataset are labeled.   Use FRAUD  if you want to categorize all unlabeled events as Fraud.  This is recommended when most of the events in your dataset are fraudulent.   Use LEGIT if you want to categorize all unlabeled events as Legit. This is recommended when most of the events in your dataset are legitimate.   Use AUTO if you want Amazon Fraud Detector to decide how to use the unlabeled data.  This is recommended when there is significant unlabeled events in the dataset.   By default, Amazon Fraud Detector ignores the unlabeled data.
        public let unlabeledEventsTreatment: UnlabeledEventsTreatment?

        @inlinable
        public init(labelMapper: [String: [String]]? = nil, unlabeledEventsTreatment: UnlabeledEventsTreatment? = nil) {
            self.labelMapper = labelMapper
            self.unlabeledEventsTreatment = unlabeledEventsTreatment
        }

        private enum CodingKeys: String, CodingKey {
            case labelMapper = "labelMapper"
            case unlabeledEventsTreatment = "unlabeledEventsTreatment"
        }
    }

    public struct ListEventPredictionsRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: FilterCondition?
        /// The detector version ID.
        public let detectorVersionId: FilterCondition?
        /// The event ID.
        public let eventId: FilterCondition?
        /// The event type associated with the detector.
        public let eventType: FilterCondition?
        /// The maximum number of predictions to return for the request.
        public let maxResults: Int?
        /// Identifies the next page of results to return. Use the token to make the call again to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
        public let nextToken: String?
        /// The time period for when the predictions were generated.
        public let predictionTimeRange: PredictionTimeRange?

        @inlinable
        public init(detectorId: FilterCondition? = nil, detectorVersionId: FilterCondition? = nil, eventId: FilterCondition? = nil, eventType: FilterCondition? = nil, maxResults: Int? = nil, nextToken: String? = nil, predictionTimeRange: PredictionTimeRange? = nil) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.eventId = eventId
            self.eventType = eventType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.predictionTimeRange = predictionTimeRange
        }

        public func validate(name: String) throws {
            try self.detectorId?.validate(name: "\(name).detectorId")
            try self.detectorVersionId?.validate(name: "\(name).detectorVersionId")
            try self.eventId?.validate(name: "\(name).eventId")
            try self.eventType?.validate(name: "\(name).eventType")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 50)
            try self.predictionTimeRange?.validate(name: "\(name).predictionTimeRange")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
            case eventId = "eventId"
            case eventType = "eventType"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case predictionTimeRange = "predictionTimeRange"
        }
    }

    public struct ListEventPredictionsResult: AWSDecodableShape {
        /// The summary of the past predictions.
        public let eventPredictionSummaries: [EventPredictionSummary]?
        /// Identifies the next page of results to return. Use the token to make the call again to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
        public let nextToken: String?

        @inlinable
        public init(eventPredictionSummaries: [EventPredictionSummary]? = nil, nextToken: String? = nil) {
            self.eventPredictionSummaries = eventPredictionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventPredictionSummaries = "eventPredictionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The next token from the previous results.
        public let nextToken: String?
        /// The ARN that specifies the resource whose tags you want to list.
        public let resourceARN: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceARN: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 50)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 256)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:frauddetector\\:[a-z0-9-]{3,20}\\:[0-9]{12}\\:[^\\s]{2,128}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resourceARN = "resourceARN"
        }
    }

    public struct ListTagsForResourceResult: AWSDecodableShape {
        /// The next token for subsequent requests.
        public let nextToken: String?
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tags = "tags"
        }
    }

    public struct LogOddsMetric: AWSDecodableShape {
        /// The relative importance of the variable. For more information, see Model variable importance.
        public let variableImportance: Float
        /// The name of the variable.
        public let variableName: String
        /// The type of variable.
        public let variableType: String

        @inlinable
        public init(variableImportance: Float, variableName: String, variableType: String) {
            self.variableImportance = variableImportance
            self.variableName = variableName
            self.variableType = variableType
        }

        private enum CodingKeys: String, CodingKey {
            case variableImportance = "variableImportance"
            case variableName = "variableName"
            case variableType = "variableType"
        }
    }

    public struct MetricDataPoint: AWSDecodableShape {
        /// The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.
        public let fpr: Float?
        /// The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.
        public let precision: Float?
        /// The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public let threshold: Float?
        /// The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.
        public let tpr: Float?

        @inlinable
        public init(fpr: Float? = nil, precision: Float? = nil, threshold: Float? = nil, tpr: Float? = nil) {
            self.fpr = fpr
            self.precision = precision
            self.threshold = threshold
            self.tpr = tpr
        }

        private enum CodingKeys: String, CodingKey {
            case fpr = "fpr"
            case precision = "precision"
            case threshold = "threshold"
            case tpr = "tpr"
        }
    }

    public struct Model: AWSDecodableShape {
        /// The ARN of the model.
        public let arn: String?
        /// Timestamp of when the model was created.
        public let createdTime: String?
        /// The model description.
        public let description: String?
        /// The name of the event type.
        public let eventTypeName: String?
        /// Timestamp of last time the model was updated.
        public let lastUpdatedTime: String?
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, eventTypeName: String? = nil, lastUpdatedTime: String? = nil, modelId: String? = nil, modelType: ModelTypeEnum? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.eventTypeName = eventTypeName
            self.lastUpdatedTime = lastUpdatedTime
            self.modelId = modelId
            self.modelType = modelType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case description = "description"
            case eventTypeName = "eventTypeName"
            case lastUpdatedTime = "lastUpdatedTime"
            case modelId = "modelId"
            case modelType = "modelType"
        }
    }

    public struct ModelEndpointDataBlob: AWSEncodableShape {
        /// The byte buffer of the Amazon SageMaker model endpoint input data blob.
        public let byteBuffer: AWSBase64Data?
        /// The content type of the Amazon SageMaker model endpoint input data blob.
        public let contentType: String?

        @inlinable
        public init(byteBuffer: AWSBase64Data? = nil, contentType: String? = nil) {
            self.byteBuffer = byteBuffer
            self.contentType = contentType
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, max: 1024)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case byteBuffer = "byteBuffer"
            case contentType = "contentType"
        }
    }

    public struct ModelInputConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  Template for constructing the CSV input-data sent to SageMaker. At event-evaluation, the placeholders for variable-names in the template will be replaced with the variable values before being sent to SageMaker.
        public let csvInputTemplate: String?
        /// The event type name.
        public let eventTypeName: String?
        ///  The format of the model input configuration. The format differs depending on if it is passed through to SageMaker or constructed by Amazon Fraud Detector.
        public let format: ModelInputDataFormat?
        ///  Template for constructing the JSON input-data sent to SageMaker. At event-evaluation, the placeholders for variable names in the template will be replaced with the variable values before being sent to SageMaker.
        public let jsonInputTemplate: String?
        /// The event variables.
        public let useEventVariables: Bool

        @inlinable
        public init(csvInputTemplate: String? = nil, eventTypeName: String? = nil, format: ModelInputDataFormat? = nil, jsonInputTemplate: String? = nil, useEventVariables: Bool) {
            self.csvInputTemplate = csvInputTemplate
            self.eventTypeName = eventTypeName
            self.format = format
            self.jsonInputTemplate = jsonInputTemplate
            self.useEventVariables = useEventVariables
        }

        public func validate(name: String) throws {
            try self.validate(self.csvInputTemplate, name: "csvInputTemplate", parent: name, max: 2000)
            try self.validate(self.csvInputTemplate, name: "csvInputTemplate", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.jsonInputTemplate, name: "jsonInputTemplate", parent: name, max: 2000)
            try self.validate(self.jsonInputTemplate, name: "jsonInputTemplate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case csvInputTemplate = "csvInputTemplate"
            case eventTypeName = "eventTypeName"
            case format = "format"
            case jsonInputTemplate = "jsonInputTemplate"
            case useEventVariables = "useEventVariables"
        }
    }

    public struct ModelOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A map of CSV index values in the SageMaker response to the Amazon Fraud Detector variables.
        public let csvIndexToVariableMap: [String: String]?
        /// The format of the model output configuration.
        public let format: ModelOutputDataFormat
        /// A map of JSON keys in response from SageMaker to the Amazon Fraud Detector variables.
        public let jsonKeyToVariableMap: [String: String]?

        @inlinable
        public init(csvIndexToVariableMap: [String: String]? = nil, format: ModelOutputDataFormat, jsonKeyToVariableMap: [String: String]? = nil) {
            self.csvIndexToVariableMap = csvIndexToVariableMap
            self.format = format
            self.jsonKeyToVariableMap = jsonKeyToVariableMap
        }

        private enum CodingKeys: String, CodingKey {
            case csvIndexToVariableMap = "csvIndexToVariableMap"
            case format = "format"
            case jsonKeyToVariableMap = "jsonKeyToVariableMap"
        }
    }

    public struct ModelScores: AWSDecodableShape {
        /// The model version.
        public let modelVersion: ModelVersion?
        /// The model's fraud prediction scores.
        public let scores: [String: Float]?

        @inlinable
        public init(modelVersion: ModelVersion? = nil, scores: [String: Float]? = nil) {
            self.modelVersion = modelVersion
            self.scores = scores
        }

        private enum CodingKeys: String, CodingKey {
            case modelVersion = "modelVersion"
            case scores = "scores"
        }
    }

    public struct ModelVersion: AWSEncodableShape & AWSDecodableShape {
        /// The model version ARN.
        public let arn: String?
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// The model version number.
        public let modelVersionNumber: String

        @inlinable
        public init(arn: String? = nil, modelId: String, modelType: ModelTypeEnum, modelVersionNumber: String) {
            self.arn = arn
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 256)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:frauddetector\\:[a-z0-9-]{3,20}\\:[0-9]{12}\\:[^\\s]{2,128}$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, max: 7)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, min: 3)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, pattern: "^[1-9][0-9]{0,3}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case modelId = "modelId"
            case modelType = "modelType"
            case modelVersionNumber = "modelVersionNumber"
        }
    }

    public struct ModelVersionDetail: AWSDecodableShape {
        /// The model version ARN.
        public let arn: String?
        /// The timestamp when the model was created.
        public let createdTime: String?
        /// The external events data details. This will be populated if the trainingDataSource for the model version is specified as  EXTERNAL_EVENTS.
        public let externalEventsDetail: ExternalEventsDetail?
        /// The ingested events data details. This will be populated if the trainingDataSource for the model version is specified as  INGESTED_EVENTS.
        public let ingestedEventsDetail: IngestedEventsDetail?
        /// The timestamp when the model was last updated.
        public let lastUpdatedTime: String?
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The model version number.
        public let modelVersionNumber: String?
        /// The status of the model version.
        public let status: String?
        /// The training data schema.
        public let trainingDataSchema: TrainingDataSchema?
        /// The model version training data source.
        public let trainingDataSource: TrainingDataSourceEnum?
        /// The training results.
        public let trainingResult: TrainingResult?
        ///  The training result details. The details include the relative importance of the variables.
        public let trainingResultV2: TrainingResultV2?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, externalEventsDetail: ExternalEventsDetail? = nil, ingestedEventsDetail: IngestedEventsDetail? = nil, lastUpdatedTime: String? = nil, modelId: String? = nil, modelType: ModelTypeEnum? = nil, modelVersionNumber: String? = nil, status: String? = nil, trainingDataSchema: TrainingDataSchema? = nil, trainingDataSource: TrainingDataSourceEnum? = nil, trainingResult: TrainingResult? = nil, trainingResultV2: TrainingResultV2? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.externalEventsDetail = externalEventsDetail
            self.ingestedEventsDetail = ingestedEventsDetail
            self.lastUpdatedTime = lastUpdatedTime
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
            self.trainingDataSchema = trainingDataSchema
            self.trainingDataSource = trainingDataSource
            self.trainingResult = trainingResult
            self.trainingResultV2 = trainingResultV2
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case externalEventsDetail = "externalEventsDetail"
            case ingestedEventsDetail = "ingestedEventsDetail"
            case lastUpdatedTime = "lastUpdatedTime"
            case modelId = "modelId"
            case modelType = "modelType"
            case modelVersionNumber = "modelVersionNumber"
            case status = "status"
            case trainingDataSchema = "trainingDataSchema"
            case trainingDataSource = "trainingDataSource"
            case trainingResult = "trainingResult"
            case trainingResultV2 = "trainingResultV2"
        }
    }

    public struct ModelVersionEvaluation: AWSDecodableShape {
        /// The evaluation score generated for the model version.
        public let evaluationScore: String?
        /// The output variable name.
        public let outputVariableName: String?
        /// The prediction explanations generated for the model version.
        public let predictionExplanations: PredictionExplanations?

        @inlinable
        public init(evaluationScore: String? = nil, outputVariableName: String? = nil, predictionExplanations: PredictionExplanations? = nil) {
            self.evaluationScore = evaluationScore
            self.outputVariableName = outputVariableName
            self.predictionExplanations = predictionExplanations
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationScore = "evaluationScore"
            case outputVariableName = "outputVariableName"
            case predictionExplanations = "predictionExplanations"
        }
    }

    public struct OFIMetricDataPoint: AWSDecodableShape {
        ///  The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.
        public let fpr: Float?
        ///  The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.
        public let precision: Float?
        ///  The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public let threshold: Float?
        ///  The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.
        public let tpr: Float?

        @inlinable
        public init(fpr: Float? = nil, precision: Float? = nil, threshold: Float? = nil, tpr: Float? = nil) {
            self.fpr = fpr
            self.precision = precision
            self.threshold = threshold
            self.tpr = tpr
        }

        private enum CodingKeys: String, CodingKey {
            case fpr = "fpr"
            case precision = "precision"
            case threshold = "threshold"
            case tpr = "tpr"
        }
    }

    public struct OFIModelPerformance: AWSDecodableShape {
        ///  The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds.
        public let auc: Float?
        ///  Indicates the range of area under curve (auc) expected from the OFI model. A range greater than 0.1 indicates higher model uncertainity.
        public let uncertaintyRange: UncertaintyRange?

        @inlinable
        public init(auc: Float? = nil, uncertaintyRange: UncertaintyRange? = nil) {
            self.auc = auc
            self.uncertaintyRange = uncertaintyRange
        }

        private enum CodingKeys: String, CodingKey {
            case auc = "auc"
            case uncertaintyRange = "uncertaintyRange"
        }
    }

    public struct OFITrainingMetricsValue: AWSDecodableShape {
        ///  The model's performance metrics data points.
        public let metricDataPoints: [OFIMetricDataPoint]?
        ///  The model's overall performance score.
        public let modelPerformance: OFIModelPerformance?

        @inlinable
        public init(metricDataPoints: [OFIMetricDataPoint]? = nil, modelPerformance: OFIModelPerformance? = nil) {
            self.metricDataPoints = metricDataPoints
            self.modelPerformance = modelPerformance
        }

        private enum CodingKeys: String, CodingKey {
            case metricDataPoints = "metricDataPoints"
            case modelPerformance = "modelPerformance"
        }
    }

    public struct Outcome: AWSDecodableShape {
        /// The outcome ARN.
        public let arn: String?
        /// The timestamp when the outcome was created.
        public let createdTime: String?
        /// The outcome description.
        public let description: String?
        /// The timestamp when the outcome was last updated.
        public let lastUpdatedTime: String?
        /// The outcome name.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, lastUpdatedTime: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case description = "description"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
        }
    }

    public struct PredictionExplanations: AWSDecodableShape {
        ///  The details of the aggregated variables impact on the prediction score.    Account Takeover Insights (ATI) model uses event variables from the login data you  provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address.  In this case, event variables used to derive the aggregated variables are IP address and user.
        public let aggregatedVariablesImpactExplanations: [AggregatedVariablesImpactExplanation]?
        /// The details of the event variable's impact on the prediction score.
        public let variableImpactExplanations: [VariableImpactExplanation]?

        @inlinable
        public init(aggregatedVariablesImpactExplanations: [AggregatedVariablesImpactExplanation]? = nil, variableImpactExplanations: [VariableImpactExplanation]? = nil) {
            self.aggregatedVariablesImpactExplanations = aggregatedVariablesImpactExplanations
            self.variableImpactExplanations = variableImpactExplanations
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedVariablesImpactExplanations = "aggregatedVariablesImpactExplanations"
            case variableImpactExplanations = "variableImpactExplanations"
        }
    }

    public struct PredictionTimeRange: AWSEncodableShape {
        /// The end time of the time period for when the predictions were generated.
        public let endTime: String
        /// The start time of the time period for when the predictions were generated.
        public let startTime: String

        @inlinable
        public init(endTime: String, startTime: String) {
            self.endTime = endTime
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.endTime, name: "endTime", parent: name, max: 30)
            try self.validate(self.endTime, name: "endTime", parent: name, min: 11)
            try self.validate(self.startTime, name: "startTime", parent: name, max: 30)
            try self.validate(self.startTime, name: "startTime", parent: name, min: 11)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case startTime = "startTime"
        }
    }

    public struct PutDetectorRequest: AWSEncodableShape {
        /// The description of the detector.
        public let description: String?
        /// The detector ID.
        public let detectorId: String
        /// The name of the event type.
        public let eventTypeName: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, detectorId: String, eventTypeName: String, tags: [Tag]? = nil) {
            self.description = description
            self.detectorId = detectorId
            self.eventTypeName = eventTypeName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case detectorId = "detectorId"
            case eventTypeName = "eventTypeName"
            case tags = "tags"
        }
    }

    public struct PutDetectorResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutEntityTypeRequest: AWSEncodableShape {
        /// The description.
        public let description: String?
        /// The name of the entity type.
        public let name: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, name: String, tags: [Tag]? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct PutEntityTypeResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutEventTypeRequest: AWSEncodableShape {
        /// The description of the event type.
        public let description: String?
        /// The entity type for the event type. Example entity types: customer, merchant, account.
        public let entityTypes: [String]
        /// Specifies if ingestion is enabled or disabled.
        public let eventIngestion: EventIngestion?
        /// Enables or disables event orchestration. If enabled, you can send event predictions to select AWS services for downstream processing of the events.
        public let eventOrchestration: EventOrchestration?
        /// The event type variables.
        public let eventVariables: [String]
        /// The event type labels.
        public let labels: [String]?
        /// The name.
        public let name: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, entityTypes: [String], eventIngestion: EventIngestion? = nil, eventOrchestration: EventOrchestration? = nil, eventVariables: [String], labels: [String]? = nil, name: String, tags: [Tag]? = nil) {
            self.description = description
            self.entityTypes = entityTypes
            self.eventIngestion = eventIngestion
            self.eventOrchestration = eventOrchestration
            self.eventVariables = eventVariables
            self.labels = labels
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.entityTypes, name: "entityTypes", parent: name, min: 1)
            try self.validate(self.eventVariables, name: "eventVariables", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case entityTypes = "entityTypes"
            case eventIngestion = "eventIngestion"
            case eventOrchestration = "eventOrchestration"
            case eventVariables = "eventVariables"
            case labels = "labels"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct PutEventTypeResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutExternalModelRequest: AWSEncodableShape {
        /// The model endpoint input configuration.
        public let inputConfiguration: ModelInputConfiguration
        /// The IAM role used to invoke the model endpoint.
        public let invokeModelEndpointRoleArn: String
        /// The model endpoints name.
        public let modelEndpoint: String
        /// The model endpoints status in Amazon Fraud Detector.
        public let modelEndpointStatus: ModelEndpointStatus
        /// The source of the model.
        public let modelSource: ModelSource
        /// The model endpoint output configuration.
        public let outputConfiguration: ModelOutputConfiguration
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(inputConfiguration: ModelInputConfiguration, invokeModelEndpointRoleArn: String, modelEndpoint: String, modelEndpointStatus: ModelEndpointStatus, modelSource: ModelSource, outputConfiguration: ModelOutputConfiguration, tags: [Tag]? = nil) {
            self.inputConfiguration = inputConfiguration
            self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
            self.modelEndpoint = modelEndpoint
            self.modelEndpointStatus = modelEndpointStatus
            self.modelSource = modelSource
            self.outputConfiguration = outputConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.inputConfiguration.validate(name: "\(name).inputConfiguration")
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, max: 63)
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, min: 1)
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, pattern: "^[0-9A-Za-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case inputConfiguration = "inputConfiguration"
            case invokeModelEndpointRoleArn = "invokeModelEndpointRoleArn"
            case modelEndpoint = "modelEndpoint"
            case modelEndpointStatus = "modelEndpointStatus"
            case modelSource = "modelSource"
            case outputConfiguration = "outputConfiguration"
            case tags = "tags"
        }
    }

    public struct PutExternalModelResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutKMSEncryptionKeyRequest: AWSEncodableShape {
        /// The KMS encryption key ARN. The KMS key must be single-Region key. Amazon Fraud Detector does not support multi-Region KMS key.
        public let kmsEncryptionKeyArn: String

        @inlinable
        public init(kmsEncryptionKeyArn: String) {
            self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsEncryptionKeyArn, name: "kmsEncryptionKeyArn", parent: name, max: 90)
            try self.validate(self.kmsEncryptionKeyArn, name: "kmsEncryptionKeyArn", parent: name, min: 7)
            try self.validate(self.kmsEncryptionKeyArn, name: "kmsEncryptionKeyArn", parent: name, pattern: "^DEFAULT|arn:[a-zA-Z0-9-]+:kms:[a-zA-Z0-9-]+:\\d{12}:key\\/\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsEncryptionKeyArn = "kmsEncryptionKeyArn"
        }
    }

    public struct PutKMSEncryptionKeyResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutLabelRequest: AWSEncodableShape {
        /// The label description.
        public let description: String?
        /// The label name.
        public let name: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, name: String, tags: [Tag]? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct PutLabelResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutOutcomeRequest: AWSEncodableShape {
        /// The outcome description.
        public let description: String?
        /// The name of the outcome.
        public let name: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, name: String, tags: [Tag]? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct PutOutcomeResult: AWSDecodableShape {
        public init() {}
    }

    public struct Rule: AWSEncodableShape & AWSDecodableShape {
        /// The detector for which the rule is associated.
        public let detectorId: String
        /// The rule ID.
        public let ruleId: String
        /// The rule version.
        public let ruleVersion: String

        @inlinable
        public init(detectorId: String, ruleId: String, ruleVersion: String) {
            self.detectorId = detectorId
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 64)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, max: 5)
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, min: 1)
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case ruleId = "ruleId"
            case ruleVersion = "ruleVersion"
        }
    }

    public struct RuleDetail: AWSDecodableShape {
        /// The rule ARN.
        public let arn: String?
        /// The timestamp of when the rule was created.
        public let createdTime: String?
        /// The rule description.
        public let description: String?
        /// The detector for which the rule is associated.
        public let detectorId: String?
        /// The rule expression.
        public let expression: String?
        /// The rule language.
        public let language: Language?
        /// Timestamp of the last time the rule was updated.
        public let lastUpdatedTime: String?
        /// The rule outcomes.
        public let outcomes: [String]?
        /// The rule ID.
        public let ruleId: String?
        /// The rule version.
        public let ruleVersion: String?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, detectorId: String? = nil, expression: String? = nil, language: Language? = nil, lastUpdatedTime: String? = nil, outcomes: [String]? = nil, ruleId: String? = nil, ruleVersion: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.expression = expression
            self.language = language
            self.lastUpdatedTime = lastUpdatedTime
            self.outcomes = outcomes
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case description = "description"
            case detectorId = "detectorId"
            case expression = "expression"
            case language = "language"
            case lastUpdatedTime = "lastUpdatedTime"
            case outcomes = "outcomes"
            case ruleId = "ruleId"
            case ruleVersion = "ruleVersion"
        }
    }

    public struct RuleResult: AWSDecodableShape {
        /// The outcomes of the matched rule, based on the rule execution mode.
        public let outcomes: [String]?
        /// The rule ID that was matched, based on the rule execution mode.
        public let ruleId: String?

        @inlinable
        public init(outcomes: [String]? = nil, ruleId: String? = nil) {
            self.outcomes = outcomes
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case outcomes = "outcomes"
            case ruleId = "ruleId"
        }
    }

    public struct SendEventRequest: AWSEncodableShape {
        /// The label to associate with the event. Required if specifying labelTimestamp.
        public let assignedLabel: String?
        /// An array of entities.
        public let entities: [Entity]
        /// The event ID to upload.
        public let eventId: String
        /// The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
        public let eventTimestamp: String
        /// The event type name of the event.
        public let eventTypeName: String
        /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.
        public let eventVariables: [String: String]
        /// The timestamp associated with the label. Required if specifying assignedLabel.
        public let labelTimestamp: String?

        @inlinable
        public init(assignedLabel: String? = nil, entities: [Entity], eventId: String, eventTimestamp: String, eventTypeName: String, eventVariables: [String: String], labelTimestamp: String? = nil) {
            self.assignedLabel = assignedLabel
            self.entities = entities
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.eventVariables = eventVariables
            self.labelTimestamp = labelTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, max: 64)
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, min: 1)
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.entities.forEach {
                try $0.validate(name: "\(name).entities[]")
            }
            try self.validate(self.eventId, name: "eventId", parent: name, max: 64)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 1)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventTimestamp, name: "eventTimestamp", parent: name, max: 30)
            try self.validate(self.eventTimestamp, name: "eventTimestamp", parent: name, min: 10)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.eventVariables.forEach {
                try validate($0.key, name: "eventVariables.key", parent: name, max: 64)
                try validate($0.key, name: "eventVariables.key", parent: name, min: 1)
                try validate($0.value, name: "eventVariables[\"\($0.key)\"]", parent: name, max: 8192)
                try validate($0.value, name: "eventVariables[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.eventVariables, name: "eventVariables", parent: name, min: 1)
            try self.validate(self.labelTimestamp, name: "labelTimestamp", parent: name, max: 30)
            try self.validate(self.labelTimestamp, name: "labelTimestamp", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case assignedLabel = "assignedLabel"
            case entities = "entities"
            case eventId = "eventId"
            case eventTimestamp = "eventTimestamp"
            case eventTypeName = "eventTypeName"
            case eventVariables = "eventVariables"
            case labelTimestamp = "labelTimestamp"
        }
    }

    public struct SendEventResult: AWSDecodableShape {
        public init() {}
    }

    public struct TFIMetricDataPoint: AWSDecodableShape {
        ///  The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.
        public let fpr: Float?
        ///  The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.
        public let precision: Float?
        ///  The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any  model score 500 or above is labeled as fraud.
        public let threshold: Float?
        ///  The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.
        public let tpr: Float?

        @inlinable
        public init(fpr: Float? = nil, precision: Float? = nil, threshold: Float? = nil, tpr: Float? = nil) {
            self.fpr = fpr
            self.precision = precision
            self.threshold = threshold
            self.tpr = tpr
        }

        private enum CodingKeys: String, CodingKey {
            case fpr = "fpr"
            case precision = "precision"
            case threshold = "threshold"
            case tpr = "tpr"
        }
    }

    public struct TFIModelPerformance: AWSDecodableShape {
        ///  The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds.
        public let auc: Float?
        ///  Indicates the range of area under curve (auc) expected from the TFI model. A range greater than 0.1 indicates higher model uncertainity.
        public let uncertaintyRange: UncertaintyRange?

        @inlinable
        public init(auc: Float? = nil, uncertaintyRange: UncertaintyRange? = nil) {
            self.auc = auc
            self.uncertaintyRange = uncertaintyRange
        }

        private enum CodingKeys: String, CodingKey {
            case auc = "auc"
            case uncertaintyRange = "uncertaintyRange"
        }
    }

    public struct TFITrainingMetricsValue: AWSDecodableShape {
        ///  The model's performance metrics data points.
        public let metricDataPoints: [TFIMetricDataPoint]?
        ///  The model performance score.
        public let modelPerformance: TFIModelPerformance?

        @inlinable
        public init(metricDataPoints: [TFIMetricDataPoint]? = nil, modelPerformance: TFIModelPerformance? = nil) {
            self.metricDataPoints = metricDataPoints
            self.modelPerformance = modelPerformance
        }

        private enum CodingKeys: String, CodingKey {
            case metricDataPoints = "metricDataPoints"
            case modelPerformance = "modelPerformance"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// A tag key.
        public let key: String
        /// A value assigned to a tag key.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource ARN.
        public let resourceARN: String
        /// The tags to assign to the resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 256)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:frauddetector\\:[a-z0-9-]{3,20}\\:[0-9]{12}\\:[^\\s]{2,128}$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
            case tags = "tags"
        }
    }

    public struct TagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct TrainingDataSchema: AWSEncodableShape & AWSDecodableShape {
        public let labelSchema: LabelSchema?
        /// The training data schema variables.
        public let modelVariables: [String]

        @inlinable
        public init(labelSchema: LabelSchema? = nil, modelVariables: [String]) {
            self.labelSchema = labelSchema
            self.modelVariables = modelVariables
        }

        private enum CodingKeys: String, CodingKey {
            case labelSchema = "labelSchema"
            case modelVariables = "modelVariables"
        }
    }

    public struct TrainingMetrics: AWSDecodableShape {
        /// The area under the curve. This summarizes true positive rate (TPR) and false positive rate (FPR) across all possible model score thresholds. A model with no predictive power has an AUC of 0.5, whereas a perfect model has a score of 1.0.
        public let auc: Float?
        /// The data points details.
        public let metricDataPoints: [MetricDataPoint]?

        @inlinable
        public init(auc: Float? = nil, metricDataPoints: [MetricDataPoint]? = nil) {
            self.auc = auc
            self.metricDataPoints = metricDataPoints
        }

        private enum CodingKeys: String, CodingKey {
            case auc = "auc"
            case metricDataPoints = "metricDataPoints"
        }
    }

    public struct TrainingMetricsV2: AWSDecodableShape {
        ///  The Account Takeover Insights (ATI) model training metric details.
        public let ati: ATITrainingMetricsValue?
        ///  The Online Fraud Insights (OFI) model training metric details.
        public let ofi: OFITrainingMetricsValue?
        ///  The Transaction Fraud Insights (TFI) model training metric details.
        public let tfi: TFITrainingMetricsValue?

        @inlinable
        public init(ati: ATITrainingMetricsValue? = nil, ofi: OFITrainingMetricsValue? = nil, tfi: TFITrainingMetricsValue? = nil) {
            self.ati = ati
            self.ofi = ofi
            self.tfi = tfi
        }

        private enum CodingKeys: String, CodingKey {
            case ati = "ati"
            case ofi = "ofi"
            case tfi = "tfi"
        }
    }

    public struct TrainingResult: AWSDecodableShape {
        /// The validation metrics.
        public let dataValidationMetrics: DataValidationMetrics?
        /// The training metric details.
        public let trainingMetrics: TrainingMetrics?
        /// The variable importance metrics.
        public let variableImportanceMetrics: VariableImportanceMetrics?

        @inlinable
        public init(dataValidationMetrics: DataValidationMetrics? = nil, trainingMetrics: TrainingMetrics? = nil, variableImportanceMetrics: VariableImportanceMetrics? = nil) {
            self.dataValidationMetrics = dataValidationMetrics
            self.trainingMetrics = trainingMetrics
            self.variableImportanceMetrics = variableImportanceMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case dataValidationMetrics = "dataValidationMetrics"
            case trainingMetrics = "trainingMetrics"
            case variableImportanceMetrics = "variableImportanceMetrics"
        }
    }

    public struct TrainingResultV2: AWSDecodableShape {
        ///  The variable importance metrics of the aggregated variables.  Account Takeover Insights (ATI) model uses event variables from the login data you  provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address.  In this case, event variables used to derive the aggregated variables are IP address and user.
        public let aggregatedVariablesImportanceMetrics: AggregatedVariablesImportanceMetrics?
        public let dataValidationMetrics: DataValidationMetrics?
        ///  The training metric details.
        public let trainingMetricsV2: TrainingMetricsV2?
        public let variableImportanceMetrics: VariableImportanceMetrics?

        @inlinable
        public init(aggregatedVariablesImportanceMetrics: AggregatedVariablesImportanceMetrics? = nil, dataValidationMetrics: DataValidationMetrics? = nil, trainingMetricsV2: TrainingMetricsV2? = nil, variableImportanceMetrics: VariableImportanceMetrics? = nil) {
            self.aggregatedVariablesImportanceMetrics = aggregatedVariablesImportanceMetrics
            self.dataValidationMetrics = dataValidationMetrics
            self.trainingMetricsV2 = trainingMetricsV2
            self.variableImportanceMetrics = variableImportanceMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedVariablesImportanceMetrics = "aggregatedVariablesImportanceMetrics"
            case dataValidationMetrics = "dataValidationMetrics"
            case trainingMetricsV2 = "trainingMetricsV2"
            case variableImportanceMetrics = "variableImportanceMetrics"
        }
    }

    public struct UncertaintyRange: AWSDecodableShape {
        ///  The lower bound value of the area under curve (auc).
        public let lowerBoundValue: Float
        ///  The upper bound value of the area under curve (auc).
        public let upperBoundValue: Float

        @inlinable
        public init(lowerBoundValue: Float, upperBoundValue: Float) {
            self.lowerBoundValue = lowerBoundValue
            self.upperBoundValue = upperBoundValue
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBoundValue = "lowerBoundValue"
            case upperBoundValue = "upperBoundValue"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource from which to remove the tag.
        public let resourceARN: String
        /// The resource ARN.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 256)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:frauddetector\\:[a-z0-9-]{3,20}\\:[0-9]{12}\\:[^\\s]{2,128}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDetectorVersionMetadataRequest: AWSEncodableShape {
        /// The description.
        public let description: String
        /// The detector ID.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String

        @inlinable
        public init(description: String, detectorId: String, detectorVersionId: String) {
            self.description = description
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
        }
    }

    public struct UpdateDetectorVersionMetadataResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDetectorVersionRequest: AWSEncodableShape {
        /// The detector version description.
        public let description: String?
        /// The parent detector ID for the detector version you want to update.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String
        /// The Amazon SageMaker model endpoints to include in the detector version.
        public let externalModelEndpoints: [String]
        /// The model versions to include in the detector version.
        public let modelVersions: [ModelVersion]?
        /// The rule execution mode to add to the detector. If you specify FIRST_MATCHED, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule. If you specifiy ALL_MATCHED, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status. The default behavior is FIRST_MATCHED.
        public let ruleExecutionMode: RuleExecutionMode?
        /// The rules to include in the detector version.
        public let rules: [Rule]

        @inlinable
        public init(description: String? = nil, detectorId: String, detectorVersionId: String, externalModelEndpoints: [String], modelVersions: [ModelVersion]? = nil, ruleExecutionMode: RuleExecutionMode? = nil, rules: [Rule]) {
            self.description = description
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.externalModelEndpoints = externalModelEndpoints
            self.modelVersions = modelVersions
            self.ruleExecutionMode = ruleExecutionMode
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
            try self.modelVersions?.forEach {
                try $0.validate(name: "\(name).modelVersions[]")
            }
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
            case externalModelEndpoints = "externalModelEndpoints"
            case modelVersions = "modelVersions"
            case ruleExecutionMode = "ruleExecutionMode"
            case rules = "rules"
        }
    }

    public struct UpdateDetectorVersionResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDetectorVersionStatusRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String
        /// The new status. The only supported values are ACTIVE and INACTIVE
        public let status: DetectorVersionStatus

        @inlinable
        public init(detectorId: String, detectorVersionId: String, status: DetectorVersionStatus) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case detectorVersionId = "detectorVersionId"
            case status = "status"
        }
    }

    public struct UpdateDetectorVersionStatusResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEventLabelRequest: AWSEncodableShape {
        /// The new label to assign to the event.
        public let assignedLabel: String
        /// The ID of the event associated with the label to update.
        public let eventId: String
        /// The event type of the event associated with the label to update.
        public let eventTypeName: String
        /// The timestamp associated with the label. The timestamp must be specified using ISO 8601 standard in UTC.
        public let labelTimestamp: String

        @inlinable
        public init(assignedLabel: String, eventId: String, eventTypeName: String, labelTimestamp: String) {
            self.assignedLabel = assignedLabel
            self.eventId = eventId
            self.eventTypeName = eventTypeName
            self.labelTimestamp = labelTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, max: 64)
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, min: 1)
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventId, name: "eventId", parent: name, max: 64)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 1)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.labelTimestamp, name: "labelTimestamp", parent: name, max: 30)
            try self.validate(self.labelTimestamp, name: "labelTimestamp", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case assignedLabel = "assignedLabel"
            case eventId = "eventId"
            case eventTypeName = "eventTypeName"
            case labelTimestamp = "labelTimestamp"
        }
    }

    public struct UpdateEventLabelResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateListRequest: AWSEncodableShape {
        ///  The new description.
        public let description: String?
        ///  One or more list elements to add or replace. If you are providing the elements, make sure to specify the updateMode to use.  If you are deleting all elements from the list, use REPLACE for the updateMode and provide an empty list (0 elements).
        public let elements: [String]?
        ///  The name of the list to update.
        public let name: String
        ///  The update mode (type).    Use APPEND if you are adding elements to the list.   Use REPLACE if you replacing existing elements in the list.   Use REMOVE if you are removing elements from the list.
        public let updateMode: ListUpdateMode?
        ///  The variable type you want to assign to the list.   You cannot update a variable type of a list that already has a variable type assigned to it. You can assign a variable type to a list only if the list does not already have a variable type.
        public let variableType: String?

        @inlinable
        public init(description: String? = nil, elements: [String]? = nil, name: String, updateMode: ListUpdateMode? = nil, variableType: String? = nil) {
            self.description = description
            self.elements = elements
            self.name = name
            self.updateMode = updateMode
            self.variableType = variableType
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.elements?.forEach {
                try validate($0, name: "elements[]", parent: name, max: 320)
                try validate($0, name: "elements[]", parent: name, min: 1)
                try validate($0, name: "elements[]", parent: name, pattern: "^\\S+( +\\S+)*$")
            }
            try self.validate(self.elements, name: "elements", parent: name, max: 100000)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.variableType, name: "variableType", parent: name, max: 64)
            try self.validate(self.variableType, name: "variableType", parent: name, min: 1)
            try self.validate(self.variableType, name: "variableType", parent: name, pattern: "^[A-Z_]{1,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case elements = "elements"
            case name = "name"
            case updateMode = "updateMode"
            case variableType = "variableType"
        }
    }

    public struct UpdateListResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateModelRequest: AWSEncodableShape {
        /// The new model description.
        public let description: String?
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum

        @inlinable
        public init(description: String? = nil, modelId: String, modelType: ModelTypeEnum) {
            self.description = description
            self.modelId = modelId
            self.modelType = modelType
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case modelId = "modelId"
            case modelType = "modelType"
        }
    }

    public struct UpdateModelResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateModelVersionRequest: AWSEncodableShape {
        /// The details of the external events data used for training the model version. Required if trainingDataSource is EXTERNAL_EVENTS.
        public let externalEventsDetail: ExternalEventsDetail?
        /// The details of the ingested event used for training the model version. Required if your trainingDataSource is INGESTED_EVENTS.
        public let ingestedEventsDetail: IngestedEventsDetail?
        /// The major version number.
        public let majorVersionNumber: String
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(externalEventsDetail: ExternalEventsDetail? = nil, ingestedEventsDetail: IngestedEventsDetail? = nil, majorVersionNumber: String, modelId: String, modelType: ModelTypeEnum, tags: [Tag]? = nil) {
            self.externalEventsDetail = externalEventsDetail
            self.ingestedEventsDetail = ingestedEventsDetail
            self.majorVersionNumber = majorVersionNumber
            self.modelId = modelId
            self.modelType = modelType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.externalEventsDetail?.validate(name: "\(name).externalEventsDetail")
            try self.ingestedEventsDetail?.validate(name: "\(name).ingestedEventsDetail")
            try self.validate(self.majorVersionNumber, name: "majorVersionNumber", parent: name, max: 5)
            try self.validate(self.majorVersionNumber, name: "majorVersionNumber", parent: name, min: 1)
            try self.validate(self.majorVersionNumber, name: "majorVersionNumber", parent: name, pattern: "^([1-9][0-9]*)$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case externalEventsDetail = "externalEventsDetail"
            case ingestedEventsDetail = "ingestedEventsDetail"
            case majorVersionNumber = "majorVersionNumber"
            case modelId = "modelId"
            case modelType = "modelType"
            case tags = "tags"
        }
    }

    public struct UpdateModelVersionResult: AWSDecodableShape {
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The model version number of the model version updated.
        public let modelVersionNumber: String?
        /// The status of the updated model version.
        public let status: String?

        @inlinable
        public init(modelId: String? = nil, modelType: ModelTypeEnum? = nil, modelVersionNumber: String? = nil, status: String? = nil) {
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case modelId = "modelId"
            case modelType = "modelType"
            case modelVersionNumber = "modelVersionNumber"
            case status = "status"
        }
    }

    public struct UpdateModelVersionStatusRequest: AWSEncodableShape {
        /// The model ID of the model version to update.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// The model version number.
        public let modelVersionNumber: String
        /// The model version status.
        public let status: ModelVersionStatus

        @inlinable
        public init(modelId: String, modelType: ModelTypeEnum, modelVersionNumber: String, status: ModelVersionStatus) {
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, max: 7)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, min: 3)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, pattern: "^[1-9][0-9]{0,3}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelId = "modelId"
            case modelType = "modelType"
            case modelVersionNumber = "modelVersionNumber"
            case status = "status"
        }
    }

    public struct UpdateModelVersionStatusResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRuleMetadataRequest: AWSEncodableShape {
        /// The rule description.
        public let description: String
        /// The rule to update.
        public let rule: Rule

        @inlinable
        public init(description: String, rule: Rule) {
            self.description = description
            self.rule = rule
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.rule.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case rule = "rule"
        }
    }

    public struct UpdateRuleMetadataResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRuleVersionRequest: AWSEncodableShape {
        /// The description.
        public let description: String?
        /// The rule expression.
        public let expression: String
        /// The language.
        public let language: Language
        /// The outcomes.
        public let outcomes: [String]
        /// The rule to update.
        public let rule: Rule
        /// The tags to assign to the rule version.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, expression: String, language: Language, outcomes: [String], rule: Rule, tags: [Tag]? = nil) {
            self.description = description
            self.expression = expression
            self.language = language
            self.outcomes = outcomes
            self.rule = rule
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.outcomes, name: "outcomes", parent: name, min: 1)
            try self.rule.validate(name: "\(name).rule")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case expression = "expression"
            case language = "language"
            case outcomes = "outcomes"
            case rule = "rule"
            case tags = "tags"
        }
    }

    public struct UpdateRuleVersionResult: AWSDecodableShape {
        /// The new rule version that was created.
        public let rule: Rule?

        @inlinable
        public init(rule: Rule? = nil) {
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "rule"
        }
    }

    public struct UpdateVariableRequest: AWSEncodableShape {
        /// The new default value of the variable.
        public let defaultValue: String?
        /// The new description.
        public let description: String?
        /// The name of the variable.
        public let name: String
        /// The variable type. For more information see Variable types.
        public let variableType: String?

        @inlinable
        public init(defaultValue: String? = nil, description: String? = nil, name: String, variableType: String? = nil) {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.variableType = variableType
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case description = "description"
            case name = "name"
            case variableType = "variableType"
        }
    }

    public struct UpdateVariableResult: AWSDecodableShape {
        public init() {}
    }

    public struct Variable: AWSDecodableShape {
        /// The ARN of the variable.
        public let arn: String?
        /// The time when the variable was created.
        public let createdTime: String?
        /// The data source of the variable.
        public let dataSource: DataSource?
        /// The data type of the variable. For more information see Variable types.
        public let dataType: DataType?
        /// The default value of the variable.
        public let defaultValue: String?
        /// The description of the variable.
        public let description: String?
        /// The time when variable was last updated.
        public let lastUpdatedTime: String?
        /// The name of the variable.
        public let name: String?
        /// The variable type of the variable. Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        public let variableType: String?

        @inlinable
        public init(arn: String? = nil, createdTime: String? = nil, dataSource: DataSource? = nil, dataType: DataType? = nil, defaultValue: String? = nil, description: String? = nil, lastUpdatedTime: String? = nil, name: String? = nil, variableType: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.variableType = variableType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case dataSource = "dataSource"
            case dataType = "dataType"
            case defaultValue = "defaultValue"
            case description = "description"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case variableType = "variableType"
        }
    }

    public struct VariableEntry: AWSEncodableShape {
        /// The data source of the variable.
        public let dataSource: String?
        /// The data type of the variable.
        public let dataType: String?
        /// The default value of the variable.
        public let defaultValue: String?
        /// The description of the variable.
        public let description: String?
        /// The name of the variable.
        public let name: String?
        /// The type of the variable. For more information see Variable types. Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        public let variableType: String?

        @inlinable
        public init(dataSource: String? = nil, dataType: String? = nil, defaultValue: String? = nil, description: String? = nil, name: String? = nil, variableType: String? = nil) {
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.variableType = variableType
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
            case dataType = "dataType"
            case defaultValue = "defaultValue"
            case description = "description"
            case name = "name"
            case variableType = "variableType"
        }
    }

    public struct VariableImpactExplanation: AWSDecodableShape {
        /// The event variable name.
        public let eventVariableName: String?
        ///  The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from - infinity to + infinity.   A positive value indicates that the variable drove the risk score up.   A negative value indicates that the variable drove the risk score down.
        public let logOddsImpact: Float?
        ///  The event variable's relative impact in terms of magnitude on the prediction scores.  The relative impact values consist of a numerical rating (0-5, 5 being the highest) and direction (increased/decreased) impact of the fraud risk.
        public let relativeImpact: String?

        @inlinable
        public init(eventVariableName: String? = nil, logOddsImpact: Float? = nil, relativeImpact: String? = nil) {
            self.eventVariableName = eventVariableName
            self.logOddsImpact = logOddsImpact
            self.relativeImpact = relativeImpact
        }

        private enum CodingKeys: String, CodingKey {
            case eventVariableName = "eventVariableName"
            case logOddsImpact = "logOddsImpact"
            case relativeImpact = "relativeImpact"
        }
    }

    public struct VariableImportanceMetrics: AWSDecodableShape {
        /// List of variable metrics.
        public let logOddsMetrics: [LogOddsMetric]?

        @inlinable
        public init(logOddsMetrics: [LogOddsMetric]? = nil) {
            self.logOddsMetrics = logOddsMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case logOddsMetrics = "logOddsMetrics"
        }
    }
}

// MARK: - Errors

/// Error enum for FraudDetector
public struct FraudDetectorErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceUnavailableException = "ResourceUnavailableException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize FraudDetector
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An exception indicating Amazon Fraud Detector does not have the needed permissions. This can occur if you submit a request, such as PutExternalModel, that specifies a role that is not in your account.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// An exception indicating there was a conflict during a delete operation.
    public static var conflictException: Self { .init(.conflictException) }
    /// An exception indicating an internal server error.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// An exception indicating the specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// An exception indicating that the attached customer-owned (external) model threw an exception when Amazon Fraud Detector invoked the model.
    public static var resourceUnavailableException: Self { .init(.resourceUnavailableException) }
    /// An exception indicating a throttling error.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// An exception indicating a specified value is not allowed.
    public static var validationException: Self { .init(.validationException) }
}

extension FraudDetectorErrorType: Equatable {
    public static func == (lhs: FraudDetectorErrorType, rhs: FraudDetectorErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension FraudDetectorErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
