//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension FraudDetector {
    // MARK: Enums

    public enum AsyncJobStatus: String, CustomStringConvertible, Codable {
        case canceled = "CANCELED"
        case cancelInProgress = "CANCEL_IN_PROGRESS"
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case inProgressInitializing = "IN_PROGRESS_INITIALIZING"
        public var description: String { return self.rawValue }
    }

    public enum DataSource: String, CustomStringConvertible, Codable {
        case event = "EVENT"
        case externalModelScore = "EXTERNAL_MODEL_SCORE"
        case modelScore = "MODEL_SCORE"
        public var description: String { return self.rawValue }
    }

    public enum DataType: String, CustomStringConvertible, Codable {
        case boolean = "BOOLEAN"
        case float = "FLOAT"
        case integer = "INTEGER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum DetectorVersionStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case draft = "DRAFT"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum EventIngestion: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Language: String, CustomStringConvertible, Codable {
        case detectorpl = "DETECTORPL"
        public var description: String { return self.rawValue }
    }

    public enum ModelEndpointStatus: String, CustomStringConvertible, Codable {
        case associated = "ASSOCIATED"
        case dissociated = "DISSOCIATED"
        public var description: String { return self.rawValue }
    }

    public enum ModelInputDataFormat: String, CustomStringConvertible, Codable {
        case applicationJson = "APPLICATION_JSON"
        case textCsv = "TEXT_CSV"
        public var description: String { return self.rawValue }
    }

    public enum ModelOutputDataFormat: String, CustomStringConvertible, Codable {
        case applicationJsonlines = "APPLICATION_JSONLINES"
        case textCsv = "TEXT_CSV"
        public var description: String { return self.rawValue }
    }

    public enum ModelSource: String, CustomStringConvertible, Codable {
        case sagemaker = "SAGEMAKER"
        public var description: String { return self.rawValue }
    }

    public enum ModelTypeEnum: String, CustomStringConvertible, Codable {
        case onlineFraudInsights = "ONLINE_FRAUD_INSIGHTS"
        case transactionFraudInsights = "TRANSACTION_FRAUD_INSIGHTS"
        public var description: String { return self.rawValue }
    }

    public enum ModelVersionStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        case trainingCancelled = "TRAINING_CANCELLED"
        public var description: String { return self.rawValue }
    }

    public enum RuleExecutionMode: String, CustomStringConvertible, Codable {
        case allMatched = "ALL_MATCHED"
        case firstMatched = "FIRST_MATCHED"
        public var description: String { return self.rawValue }
    }

    public enum TrainingDataSourceEnum: String, CustomStringConvertible, Codable {
        case externalEvents = "EXTERNAL_EVENTS"
        case ingestedEvents = "INGESTED_EVENTS"
        public var description: String { return self.rawValue }
    }

    public enum UnlabeledEventsTreatment: String, CustomStringConvertible, Codable {
        case fraud = "FRAUD"
        case ignore = "IGNORE"
        case legit = "LEGIT"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct BatchCreateVariableError: AWSDecodableShape {
        /// The error code.
        public let code: Int?
        /// The error message.
        public let message: String?
        /// The name.
        public let name: String?

        public init(code: Int? = nil, message: String? = nil, name: String? = nil) {
            self.code = code
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
            case name
        }
    }

    public struct BatchCreateVariableRequest: AWSEncodableShape {
        /// A collection of key and value pairs.
        public let tags: [Tag]?
        /// The list of variables for the batch create variable request.
        public let variableEntries: [VariableEntry]

        public init(tags: [Tag]? = nil, variableEntries: [VariableEntry]) {
            self.tags = tags
            self.variableEntries = variableEntries
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.variableEntries, name: "variableEntries", parent: name, max: 25)
            try self.validate(self.variableEntries, name: "variableEntries", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
            case variableEntries
        }
    }

    public struct BatchCreateVariableResult: AWSDecodableShape {
        /// Provides the errors for the BatchCreateVariable request.
        public let errors: [BatchCreateVariableError]?

        public init(errors: [BatchCreateVariableError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors
        }
    }

    public struct BatchGetVariableError: AWSDecodableShape {
        /// The error code.
        public let code: Int?
        /// The error message.
        public let message: String?
        /// The error name.
        public let name: String?

        public init(code: Int? = nil, message: String? = nil, name: String? = nil) {
            self.code = code
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
            case name
        }
    }

    public struct BatchGetVariableRequest: AWSEncodableShape {
        /// The list of variable names to get.
        public let names: [String]

        public init(names: [String]) {
            self.names = names
        }

        public func validate(name: String) throws {
            try self.validate(self.names, name: "names", parent: name, max: 100)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case names
        }
    }

    public struct BatchGetVariableResult: AWSDecodableShape {
        /// The errors from the request.
        public let errors: [BatchGetVariableError]?
        /// The returned variables.
        public let variables: [Variable]?

        public init(errors: [BatchGetVariableError]? = nil, variables: [Variable]? = nil) {
            self.errors = errors
            self.variables = variables
        }

        private enum CodingKeys: String, CodingKey {
            case errors
            case variables
        }
    }

    public struct BatchImport: AWSDecodableShape {
        /// The ARN of the batch import job.
        public let arn: String?
        /// Timestamp of when batch import job completed.
        public let completionTime: String?
        /// The name of the event type.
        public let eventTypeName: String?
        /// The number of records that failed to import.
        public let failedRecordsCount: Int?
        /// The reason batch import job failed.
        public let failureReason: String?
        /// The ARN of the IAM role to use for this job request.
        public let iamRoleArn: String?
        /// The Amazon S3 location of your data file for batch import.
        public let inputPath: String?
        /// The ID of the batch import job.
        public let jobId: String?
        /// The Amazon S3 location of your output file.
        public let outputPath: String?
        /// The number of records processed by batch import job.
        public let processedRecordsCount: Int?
        /// Timestamp of when the batch import job started.
        public let startTime: String?
        /// The status of the batch import job.
        public let status: AsyncJobStatus?
        /// The total number of records in the batch import job.
        public let totalRecordsCount: Int?

        public init(arn: String? = nil, completionTime: String? = nil, eventTypeName: String? = nil, failedRecordsCount: Int? = nil, failureReason: String? = nil, iamRoleArn: String? = nil, inputPath: String? = nil, jobId: String? = nil, outputPath: String? = nil, processedRecordsCount: Int? = nil, startTime: String? = nil, status: AsyncJobStatus? = nil, totalRecordsCount: Int? = nil) {
            self.arn = arn
            self.completionTime = completionTime
            self.eventTypeName = eventTypeName
            self.failedRecordsCount = failedRecordsCount
            self.failureReason = failureReason
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.outputPath = outputPath
            self.processedRecordsCount = processedRecordsCount
            self.startTime = startTime
            self.status = status
            self.totalRecordsCount = totalRecordsCount
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case completionTime
            case eventTypeName
            case failedRecordsCount
            case failureReason
            case iamRoleArn
            case inputPath
            case jobId
            case outputPath
            case processedRecordsCount
            case startTime
            case status
            case totalRecordsCount
        }
    }

    public struct BatchPrediction: AWSDecodableShape {
        /// The ARN of batch prediction job.
        public let arn: String?
        /// Timestamp of when the batch prediction job completed.
        public let completionTime: String?
        /// The name of the detector.
        public let detectorName: String?
        /// The detector version.
        public let detectorVersion: String?
        /// The name of the event type.
        public let eventTypeName: String?
        /// The reason a batch prediction job failed.
        public let failureReason: String?
        /// The ARN of the IAM role to use for this job request.
        public let iamRoleArn: String?
        /// The Amazon S3 location of your training file.
        public let inputPath: String?
        /// The job ID for the batch prediction.
        public let jobId: String?
        /// Timestamp of most recent heartbeat indicating the batch prediction job was making progress.
        public let lastHeartbeatTime: String?
        /// The Amazon S3 location of your output file.
        public let outputPath: String?
        /// The number of records processed by the batch prediction job.
        public let processedRecordsCount: Int?
        /// Timestamp of when the batch prediction job started.
        public let startTime: String?
        /// The batch prediction status.
        public let status: AsyncJobStatus?
        /// The total number of records in the batch prediction job.
        public let totalRecordsCount: Int?

        public init(arn: String? = nil, completionTime: String? = nil, detectorName: String? = nil, detectorVersion: String? = nil, eventTypeName: String? = nil, failureReason: String? = nil, iamRoleArn: String? = nil, inputPath: String? = nil, jobId: String? = nil, lastHeartbeatTime: String? = nil, outputPath: String? = nil, processedRecordsCount: Int? = nil, startTime: String? = nil, status: AsyncJobStatus? = nil, totalRecordsCount: Int? = nil) {
            self.arn = arn
            self.completionTime = completionTime
            self.detectorName = detectorName
            self.detectorVersion = detectorVersion
            self.eventTypeName = eventTypeName
            self.failureReason = failureReason
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.lastHeartbeatTime = lastHeartbeatTime
            self.outputPath = outputPath
            self.processedRecordsCount = processedRecordsCount
            self.startTime = startTime
            self.status = status
            self.totalRecordsCount = totalRecordsCount
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case completionTime
            case detectorName
            case detectorVersion
            case eventTypeName
            case failureReason
            case iamRoleArn
            case inputPath
            case jobId
            case lastHeartbeatTime
            case outputPath
            case processedRecordsCount
            case startTime
            case status
            case totalRecordsCount
        }
    }

    public struct CancelBatchImportJobRequest: AWSEncodableShape {
        ///  The ID of an in-progress batch import job to cancel.  Amazon Fraud Detector will throw an error if the batch import job is in FAILED, CANCELED, or  COMPLETED state.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
        }
    }

    public struct CancelBatchImportJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct CancelBatchPredictionJobRequest: AWSEncodableShape {
        /// The ID of the batch prediction job to cancel.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
        }
    }

    public struct CancelBatchPredictionJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct CreateBatchImportJobRequest: AWSEncodableShape {
        /// The name of the event type.
        public let eventTypeName: String
        /// The ARN of the IAM role created for Amazon S3 bucket that holds your data file.  The IAM role must have read and write permissions to both input and output S3 buckets.
        public let iamRoleArn: String
        /// The URI that points to the Amazon S3 location of your data file.
        public let inputPath: String
        /// The ID of the batch import job. The ID cannot be of a past job, unless the job exists in CREATE_FAILED state.
        public let jobId: String
        /// The URI that points to the Amazon S3 location for storing your results.
        public let outputPath: String
        /// A collection of key-value pairs associated with this request.
        public let tags: [Tag]?

        public init(eventTypeName: String, iamRoleArn: String, inputPath: String, jobId: String, outputPath: String, tags: [Tag]? = nil) {
            self.eventTypeName = eventTypeName
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.outputPath = outputPath
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, max: 256)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, min: 1)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:iam\\:\\:[0-9]{12}\\:role\\/[^\\s]{2,64}$")
            try self.validate(self.inputPath, name: "inputPath", parent: name, max: 512)
            try self.validate(self.inputPath, name: "inputPath", parent: name, min: 1)
            try self.validate(self.inputPath, name: "inputPath", parent: name, pattern: "^s3:\\/\\/(.+)$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.outputPath, name: "outputPath", parent: name, max: 512)
            try self.validate(self.outputPath, name: "outputPath", parent: name, min: 1)
            try self.validate(self.outputPath, name: "outputPath", parent: name, pattern: "^s3:\\/\\/(.+)$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case eventTypeName
            case iamRoleArn
            case inputPath
            case jobId
            case outputPath
            case tags
        }
    }

    public struct CreateBatchImportJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct CreateBatchPredictionJobRequest: AWSEncodableShape {
        /// The name of the detector.
        public let detectorName: String
        /// The detector version.
        public let detectorVersion: String?
        /// The name of the event type.
        public let eventTypeName: String
        /// The ARN of the IAM role to use for this job request.
        public let iamRoleArn: String
        /// The Amazon S3 location of your training file.
        public let inputPath: String
        /// The ID of the batch prediction job.
        public let jobId: String
        /// The Amazon S3 location of your output file.
        public let outputPath: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        public init(detectorName: String, detectorVersion: String? = nil, eventTypeName: String, iamRoleArn: String, inputPath: String, jobId: String, outputPath: String, tags: [Tag]? = nil) {
            self.detectorName = detectorName
            self.detectorVersion = detectorVersion
            self.eventTypeName = eventTypeName
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.outputPath = outputPath
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorName, name: "detectorName", parent: name, max: 64)
            try self.validate(self.detectorName, name: "detectorName", parent: name, min: 1)
            try self.validate(self.detectorName, name: "detectorName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersion, name: "detectorVersion", parent: name, max: 5)
            try self.validate(self.detectorVersion, name: "detectorVersion", parent: name, min: 1)
            try self.validate(self.detectorVersion, name: "detectorVersion", parent: name, pattern: "^([1-9][0-9]*)$")
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, max: 256)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, min: 1)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:iam\\:\\:[0-9]{12}\\:role\\/[^\\s]{2,64}$")
            try self.validate(self.inputPath, name: "inputPath", parent: name, max: 512)
            try self.validate(self.inputPath, name: "inputPath", parent: name, min: 1)
            try self.validate(self.inputPath, name: "inputPath", parent: name, pattern: "^s3:\\/\\/(.+)$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.outputPath, name: "outputPath", parent: name, max: 512)
            try self.validate(self.outputPath, name: "outputPath", parent: name, min: 1)
            try self.validate(self.outputPath, name: "outputPath", parent: name, pattern: "^s3:\\/\\/(.+)$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorName
            case detectorVersion
            case eventTypeName
            case iamRoleArn
            case inputPath
            case jobId
            case outputPath
            case tags
        }
    }

    public struct CreateBatchPredictionJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct CreateDetectorVersionRequest: AWSEncodableShape {
        /// The description of the detector version.
        public let description: String?
        /// The ID of the detector under which you want to create a new version.
        public let detectorId: String
        /// The Amazon Sagemaker model endpoints to include in the detector version.
        public let externalModelEndpoints: [String]?
        /// The model versions to include in the detector version.
        public let modelVersions: [ModelVersion]?
        /// The rule execution mode for the rules included in the detector version.
        /// 	        You can define and edit the rule mode at the detector version level, when it is in draft status.
        /// 	        If you specify FIRST_MATCHED, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule.
        /// 	        If you specifiy ALL_MATCHED, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules.  The default behavior is FIRST_MATCHED.
        public let ruleExecutionMode: RuleExecutionMode?
        /// The rules to include in the detector version.
        public let rules: [Rule]
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        public init(description: String? = nil, detectorId: String, externalModelEndpoints: [String]? = nil, modelVersions: [ModelVersion]? = nil, ruleExecutionMode: RuleExecutionMode? = nil, rules: [Rule], tags: [Tag]? = nil) {
            self.description = description
            self.detectorId = detectorId
            self.externalModelEndpoints = externalModelEndpoints
            self.modelVersions = modelVersions
            self.ruleExecutionMode = ruleExecutionMode
            self.rules = rules
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.modelVersions?.forEach {
                try $0.validate(name: "\(name).modelVersions[]")
            }
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case detectorId
            case externalModelEndpoints
            case modelVersions
            case ruleExecutionMode
            case rules
            case tags
        }
    }

    public struct CreateDetectorVersionResult: AWSDecodableShape {
        /// The ID for the created version's parent detector.
        public let detectorId: String?
        /// The ID for the created detector.
        public let detectorVersionId: String?
        /// The status of the detector version.
        public let status: DetectorVersionStatus?

        public init(detectorId: String? = nil, detectorVersionId: String? = nil, status: DetectorVersionStatus? = nil) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case detectorVersionId
            case status
        }
    }

    public struct CreateModelRequest: AWSEncodableShape {
        /// The model description.
        public let description: String?
        /// The name of the event type.
        public let eventTypeName: String
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        public init(description: String? = nil, eventTypeName: String, modelId: String, modelType: ModelTypeEnum, tags: [Tag]? = nil) {
            self.description = description
            self.eventTypeName = eventTypeName
            self.modelId = modelId
            self.modelType = modelType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case eventTypeName
            case modelId
            case modelType
            case tags
        }
    }

    public struct CreateModelResult: AWSDecodableShape {
        public init() {}
    }

    public struct CreateModelVersionRequest: AWSEncodableShape {
        /// Details of the external events data used for model version training. Required if trainingDataSource is EXTERNAL_EVENTS.
        public let externalEventsDetail: ExternalEventsDetail?
        /// Details of the ingested events data used for model version training. Required if trainingDataSource is INGESTED_EVENTS.
        public let ingestedEventsDetail: IngestedEventsDetail?
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// A collection of key and value pairs.
        public let tags: [Tag]?
        /// The training data schema.
        public let trainingDataSchema: TrainingDataSchema
        /// The training data source location in Amazon S3.
        public let trainingDataSource: TrainingDataSourceEnum

        public init(externalEventsDetail: ExternalEventsDetail? = nil, ingestedEventsDetail: IngestedEventsDetail? = nil, modelId: String, modelType: ModelTypeEnum, tags: [Tag]? = nil, trainingDataSchema: TrainingDataSchema, trainingDataSource: TrainingDataSourceEnum) {
            self.externalEventsDetail = externalEventsDetail
            self.ingestedEventsDetail = ingestedEventsDetail
            self.modelId = modelId
            self.modelType = modelType
            self.tags = tags
            self.trainingDataSchema = trainingDataSchema
            self.trainingDataSource = trainingDataSource
        }

        public func validate(name: String) throws {
            try self.externalEventsDetail?.validate(name: "\(name).externalEventsDetail")
            try self.ingestedEventsDetail?.validate(name: "\(name).ingestedEventsDetail")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.trainingDataSchema.validate(name: "\(name).trainingDataSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case externalEventsDetail
            case ingestedEventsDetail
            case modelId
            case modelType
            case tags
            case trainingDataSchema
            case trainingDataSource
        }
    }

    public struct CreateModelVersionResult: AWSDecodableShape {
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The model version number of the model version created.
        public let modelVersionNumber: String?
        /// The model version status.
        public let status: String?

        public init(modelId: String? = nil, modelType: ModelTypeEnum? = nil, modelVersionNumber: String? = nil, status: String? = nil) {
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case modelId
            case modelType
            case modelVersionNumber
            case status
        }
    }

    public struct CreateRuleRequest: AWSEncodableShape {
        /// The rule description.
        public let description: String?
        /// The detector ID for the rule's parent detector.
        public let detectorId: String
        /// The rule expression.
        public let expression: String
        /// The language of the rule.
        public let language: Language
        /// The outcome or outcomes returned when the rule expression matches.
        public let outcomes: [String]
        /// The rule ID.
        public let ruleId: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        public init(description: String? = nil, detectorId: String, expression: String, language: Language, outcomes: [String], ruleId: String, tags: [Tag]? = nil) {
            self.description = description
            self.detectorId = detectorId
            self.expression = expression
            self.language = language
            self.outcomes = outcomes
            self.ruleId = ruleId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.outcomes, name: "outcomes", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 64)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case detectorId
            case expression
            case language
            case outcomes
            case ruleId
            case tags
        }
    }

    public struct CreateRuleResult: AWSDecodableShape {
        /// The created rule.
        public let rule: Rule?

        public init(rule: Rule? = nil) {
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case rule
        }
    }

    public struct CreateVariableRequest: AWSEncodableShape {
        /// The source of the data.
        public let dataSource: DataSource
        /// The data type.
        public let dataType: DataType
        /// The default value for the variable when no value is received.
        public let defaultValue: String
        /// The description.
        public let description: String?
        /// The name of the variable.
        public let name: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?
        /// The variable type. For more information see Variable types.
        /// 				 Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        public let variableType: String?

        public init(dataSource: DataSource, dataType: DataType, defaultValue: String, description: String? = nil, name: String, tags: [Tag]? = nil, variableType: String? = nil) {
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.tags = tags
            self.variableType = variableType
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource
            case dataType
            case defaultValue
            case description
            case name
            case tags
            case variableType
        }
    }

    public struct CreateVariableResult: AWSDecodableShape {
        public init() {}
    }

    public struct DataValidationMetrics: AWSDecodableShape {
        /// The field-specific model training validation messages.
        public let fieldLevelMessages: [FieldValidationMessage]?
        /// The file-specific model training validation messages.
        public let fileLevelMessages: [FileValidationMessage]?

        public init(fieldLevelMessages: [FieldValidationMessage]? = nil, fileLevelMessages: [FileValidationMessage]? = nil) {
            self.fieldLevelMessages = fieldLevelMessages
            self.fileLevelMessages = fileLevelMessages
        }

        private enum CodingKeys: String, CodingKey {
            case fieldLevelMessages
            case fileLevelMessages
        }
    }

    public struct DeleteBatchImportJobRequest: AWSEncodableShape {
        /// The ID of the batch import job to delete.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
        }
    }

    public struct DeleteBatchImportJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteBatchPredictionJobRequest: AWSEncodableShape {
        /// The ID of the batch prediction job to delete.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
        }
    }

    public struct DeleteBatchPredictionJobResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDetectorRequest: AWSEncodableShape {
        /// The ID of the detector to delete.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
        }
    }

    public struct DeleteDetectorResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDetectorVersionRequest: AWSEncodableShape {
        /// The ID of the parent detector for the detector version to delete.
        public let detectorId: String
        /// The ID of the detector version to delete.
        public let detectorVersionId: String

        public init(detectorId: String, detectorVersionId: String) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case detectorVersionId
        }
    }

    public struct DeleteDetectorVersionResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEntityTypeRequest: AWSEncodableShape {
        /// The name of the entity type to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct DeleteEntityTypeResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEventRequest: AWSEncodableShape {
        /// Specifies whether or not to delete any predictions associated with the event.
        public let deleteAuditHistory: Bool?
        /// The ID of the event to delete.
        public let eventId: String
        /// The name of the event type.
        public let eventTypeName: String

        public init(deleteAuditHistory: Bool? = nil, eventId: String, eventTypeName: String) {
            self.deleteAuditHistory = deleteAuditHistory
            self.eventId = eventId
            self.eventTypeName = eventTypeName
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 64)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 1)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAuditHistory
            case eventId
            case eventTypeName
        }
    }

    public struct DeleteEventResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEventTypeRequest: AWSEncodableShape {
        /// The name of the event type to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct DeleteEventTypeResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEventsByEventTypeRequest: AWSEncodableShape {
        /// The name of the event type.
        public let eventTypeName: String

        public init(eventTypeName: String) {
            self.eventTypeName = eventTypeName
        }

        public func validate(name: String) throws {
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTypeName
        }
    }

    public struct DeleteEventsByEventTypeResult: AWSDecodableShape {
        /// The status of the delete request.
        public let eventsDeletionStatus: String?
        /// Name of event type for which to delete the events.
        public let eventTypeName: String?

        public init(eventsDeletionStatus: String? = nil, eventTypeName: String? = nil) {
            self.eventsDeletionStatus = eventsDeletionStatus
            self.eventTypeName = eventTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case eventsDeletionStatus
            case eventTypeName
        }
    }

    public struct DeleteExternalModelRequest: AWSEncodableShape {
        /// The endpoint of the Amazon Sagemaker model to delete.
        public let modelEndpoint: String

        public init(modelEndpoint: String) {
            self.modelEndpoint = modelEndpoint
        }

        public func validate(name: String) throws {
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, max: 63)
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, min: 1)
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, pattern: "^[0-9A-Za-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelEndpoint
        }
    }

    public struct DeleteExternalModelResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLabelRequest: AWSEncodableShape {
        /// The name of the label to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct DeleteLabelResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteModelRequest: AWSEncodableShape {
        /// The model ID of the model to delete.
        public let modelId: String
        /// The model type of the model to delete.
        public let modelType: ModelTypeEnum

        public init(modelId: String, modelType: ModelTypeEnum) {
            self.modelId = modelId
            self.modelType = modelType
        }

        public func validate(name: String) throws {
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelId
            case modelType
        }
    }

    public struct DeleteModelResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteModelVersionRequest: AWSEncodableShape {
        /// The model ID of the model version to delete.
        public let modelId: String
        /// The model type of the model version to delete.
        public let modelType: ModelTypeEnum
        /// The model version number of the model version to delete.
        public let modelVersionNumber: String

        public init(modelId: String, modelType: ModelTypeEnum, modelVersionNumber: String) {
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, max: 7)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, min: 3)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, pattern: "^[1-9][0-9]{0,3}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelId
            case modelType
            case modelVersionNumber
        }
    }

    public struct DeleteModelVersionResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOutcomeRequest: AWSEncodableShape {
        /// The name of the outcome to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct DeleteOutcomeResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRuleRequest: AWSEncodableShape {
        public let rule: Rule

        public init(rule: Rule) {
            self.rule = rule
        }

        public func validate(name: String) throws {
            try self.rule.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case rule
        }
    }

    public struct DeleteRuleResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVariableRequest: AWSEncodableShape {
        /// The name of the variable to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct DeleteVariableResult: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeDetectorRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The maximum number of results to return for the request.
        public let maxResults: Int?
        /// The next token from the previous response.
        public let nextToken: String?

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case maxResults
            case nextToken
        }
    }

    public struct DescribeDetectorResult: AWSDecodableShape {
        /// The detector ARN.
        public let arn: String?
        /// The detector ID.
        public let detectorId: String?
        /// The status and description for each detector version.
        public let detectorVersionSummaries: [DetectorVersionSummary]?
        /// The next token to be used for subsequent requests.
        public let nextToken: String?

        public init(arn: String? = nil, detectorId: String? = nil, detectorVersionSummaries: [DetectorVersionSummary]? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.detectorId = detectorId
            self.detectorVersionSummaries = detectorVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case detectorId
            case detectorVersionSummaries
            case nextToken
        }
    }

    public struct DescribeModelVersionsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The model version number.
        public let modelVersionNumber: String?
        /// The next token from the previous results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, modelId: String? = nil, modelType: ModelTypeEnum? = nil, modelVersionNumber: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, max: 7)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, min: 3)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, pattern: "^[1-9][0-9]{0,3}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case modelId
            case modelType
            case modelVersionNumber
            case nextToken
        }
    }

    public struct DescribeModelVersionsResult: AWSDecodableShape {
        /// The model version details.
        public let modelVersionDetails: [ModelVersionDetail]?
        /// The next token.
        public let nextToken: String?

        public init(modelVersionDetails: [ModelVersionDetail]? = nil, nextToken: String? = nil) {
            self.modelVersionDetails = modelVersionDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelVersionDetails
            case nextToken
        }
    }

    public struct Detector: AWSDecodableShape {
        /// The detector ARN.
        public let arn: String?
        /// Timestamp of when the detector was created.
        public let createdTime: String?
        /// The detector description.
        public let description: String?
        /// The detector ID.
        public let detectorId: String?
        /// The name of the event type.
        public let eventTypeName: String?
        /// Timestamp of when the detector was last updated.
        public let lastUpdatedTime: String?

        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, detectorId: String? = nil, eventTypeName: String? = nil, lastUpdatedTime: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.eventTypeName = eventTypeName
            self.lastUpdatedTime = lastUpdatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case description
            case detectorId
            case eventTypeName
            case lastUpdatedTime
        }
    }

    public struct DetectorVersionSummary: AWSDecodableShape {
        /// The detector version description.
        public let description: String?
        /// The detector version ID.
        public let detectorVersionId: String?
        /// Timestamp of when the detector version was last updated.
        public let lastUpdatedTime: String?
        /// The detector version status.
        public let status: DetectorVersionStatus?

        public init(description: String? = nil, detectorVersionId: String? = nil, lastUpdatedTime: String? = nil, status: DetectorVersionStatus? = nil) {
            self.description = description
            self.detectorVersionId = detectorVersionId
            self.lastUpdatedTime = lastUpdatedTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case detectorVersionId
            case lastUpdatedTime
            case status
        }
    }

    public struct Entity: AWSEncodableShape & AWSDecodableShape {
        /// The entity ID. If you do not know the entityId, you can pass unknown, which is areserved string literal.
        public let entityId: String
        /// The entity type.
        public let entityType: String

        public init(entityId: String, entityType: String) {
            self.entityId = entityId
            self.entityType = entityType
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 256)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9A-Za-z_.@+-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId
            case entityType
        }
    }

    public struct EntityType: AWSDecodableShape {
        /// The entity type ARN.
        public let arn: String?
        /// Timestamp of when the entity type was created.
        public let createdTime: String?
        /// The entity type description.
        public let description: String?
        /// Timestamp of when the entity type was last updated.
        public let lastUpdatedTime: String?
        /// The entity type name.
        public let name: String?

        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, lastUpdatedTime: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case description
            case lastUpdatedTime
            case name
        }
    }

    public struct EvaluatedExternalModel: AWSDecodableShape {
        /// Input variables use for generating predictions.
        public let inputVariables: [String: String]?
        /// The endpoint of the external (Amazon Sagemaker) model.
        public let modelEndpoint: String?
        /// Output variables.
        public let outputVariables: [String: String]?
        /// Indicates whether event variables were used to generate predictions.
        public let useEventVariables: Bool?

        public init(inputVariables: [String: String]? = nil, modelEndpoint: String? = nil, outputVariables: [String: String]? = nil, useEventVariables: Bool? = nil) {
            self.inputVariables = inputVariables
            self.modelEndpoint = modelEndpoint
            self.outputVariables = outputVariables
            self.useEventVariables = useEventVariables
        }

        private enum CodingKeys: String, CodingKey {
            case inputVariables
            case modelEndpoint
            case outputVariables
            case useEventVariables
        }
    }

    public struct EvaluatedModelVersion: AWSDecodableShape {
        /// Evaluations generated for the model version.
        public let evaluations: [ModelVersionEvaluation]?
        /// The model ID.
        public let modelId: String?
        /// The model type.  Valid values: ONLINE_FRAUD_INSIGHTS | TRANSACTION_FRAUD_INSIGHTS
        public let modelType: String?
        /// The model version.
        public let modelVersion: String?

        public init(evaluations: [ModelVersionEvaluation]? = nil, modelId: String? = nil, modelType: String? = nil, modelVersion: String? = nil) {
            self.evaluations = evaluations
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersion = modelVersion
        }

        private enum CodingKeys: String, CodingKey {
            case evaluations
            case modelId
            case modelType
            case modelVersion
        }
    }

    public struct EvaluatedRule: AWSDecodableShape {
        /// Indicates whether the rule was evaluated.
        public let evaluated: Bool?
        /// The rule expression.
        public let expression: String?
        /// The rule expression value.
        public let expressionWithValues: String?
        /// Indicates whether the rule matched.
        public let matched: Bool?
        /// The rule outcome.
        public let outcomes: [String]?
        /// The rule ID.
        public let ruleId: String?
        /// The rule version.
        public let ruleVersion: String?

        public init(evaluated: Bool? = nil, expression: String? = nil, expressionWithValues: String? = nil, matched: Bool? = nil, outcomes: [String]? = nil, ruleId: String? = nil, ruleVersion: String? = nil) {
            self.evaluated = evaluated
            self.expression = expression
            self.expressionWithValues = expressionWithValues
            self.matched = matched
            self.outcomes = outcomes
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }

        private enum CodingKeys: String, CodingKey {
            case evaluated
            case expression
            case expressionWithValues
            case matched
            case outcomes
            case ruleId
            case ruleVersion
        }
    }

    public struct Event: AWSDecodableShape {
        /// The label associated with the event.
        public let currentLabel: String?
        /// The event entities.
        public let entities: [Entity]?
        /// The event ID.
        public let eventId: String?
        /// The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
        public let eventTimestamp: String?
        /// The event type.
        public let eventTypeName: String?
        /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.
        public let eventVariables: [String: String]?
        /// The timestamp associated with the label to update. The timestamp must be specified using ISO 8601 standard in UTC.
        public let labelTimestamp: String?

        public init(currentLabel: String? = nil, entities: [Entity]? = nil, eventId: String? = nil, eventTimestamp: String? = nil, eventTypeName: String? = nil, eventVariables: [String: String]? = nil, labelTimestamp: String? = nil) {
            self.currentLabel = currentLabel
            self.entities = entities
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.eventVariables = eventVariables
            self.labelTimestamp = labelTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case currentLabel
            case entities
            case eventId
            case eventTimestamp
            case eventTypeName
            case eventVariables
            case labelTimestamp
        }
    }

    public struct EventPredictionSummary: AWSDecodableShape {
        /// The detector ID.
        public let detectorId: String?
        /// The detector version ID.
        public let detectorVersionId: String?
        /// The event ID.
        public let eventId: String?
        /// The timestamp of the event.
        public let eventTimestamp: String?
        /// The event type.
        public let eventTypeName: String?
        /// The timestamp when the prediction was generated.
        public let predictionTimestamp: String?

        public init(detectorId: String? = nil, detectorVersionId: String? = nil, eventId: String? = nil, eventTimestamp: String? = nil, eventTypeName: String? = nil, predictionTimestamp: String? = nil) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.predictionTimestamp = predictionTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case detectorVersionId
            case eventId
            case eventTimestamp
            case eventTypeName
            case predictionTimestamp
        }
    }

    public struct EventType: AWSDecodableShape {
        /// The entity type ARN.
        public let arn: String?
        /// Timestamp of when the event type was created.
        public let createdTime: String?
        /// The event type description.
        public let description: String?
        /// The event type entity types.
        public let entityTypes: [String]?
        /// If Enabled, Amazon Fraud Detector stores event data when you generate a prediction and uses that data to update calculated variables in near real-time. Amazon Fraud Detector uses this data, known as INGESTED_EVENTS, to train your model and  improve fraud predictions.
        public let eventIngestion: EventIngestion?
        /// The event type event variables.
        public let eventVariables: [String]?
        /// Data about the stored events.
        public let ingestedEventStatistics: IngestedEventStatistics?
        /// The event type labels.
        public let labels: [String]?
        /// Timestamp of when the event type was last updated.
        public let lastUpdatedTime: String?
        /// The event type name.
        public let name: String?

        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, entityTypes: [String]? = nil, eventIngestion: EventIngestion? = nil, eventVariables: [String]? = nil, ingestedEventStatistics: IngestedEventStatistics? = nil, labels: [String]? = nil, lastUpdatedTime: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.entityTypes = entityTypes
            self.eventIngestion = eventIngestion
            self.eventVariables = eventVariables
            self.ingestedEventStatistics = ingestedEventStatistics
            self.labels = labels
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case description
            case entityTypes
            case eventIngestion
            case eventVariables
            case ingestedEventStatistics
            case labels
            case lastUpdatedTime
            case name
        }
    }

    public struct EventVariableSummary: AWSDecodableShape {
        /// The event variable name.
        public let name: String?
        /// The event variable source.
        public let source: String?
        /// The value of the event variable.
        public let value: String?

        public init(name: String? = nil, source: String? = nil, value: String? = nil) {
            self.name = name
            self.source = source
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case source
            case value
        }
    }

    public struct ExternalEventsDetail: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the role that provides Amazon Fraud Detector access to the data location.
        public let dataAccessRoleArn: String
        /// The Amazon S3 bucket location for the data.
        public let dataLocation: String

        public init(dataAccessRoleArn: String, dataLocation: String) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.dataLocation = dataLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 256)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 1)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:iam\\:\\:[0-9]{12}\\:role\\/[^\\s]{2,64}$")
            try self.validate(self.dataLocation, name: "dataLocation", parent: name, max: 512)
            try self.validate(self.dataLocation, name: "dataLocation", parent: name, min: 1)
            try self.validate(self.dataLocation, name: "dataLocation", parent: name, pattern: "^s3:\\/\\/(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn
            case dataLocation
        }
    }

    public struct ExternalModel: AWSDecodableShape {
        /// The model ARN.
        public let arn: String?
        /// Timestamp of when the model was last created.
        public let createdTime: String?
        /// The input configuration.
        public let inputConfiguration: ModelInputConfiguration?
        /// The role used to invoke the model.
        public let invokeModelEndpointRoleArn: String?
        /// Timestamp of when the model was last updated.
        public let lastUpdatedTime: String?
        /// The Amazon SageMaker model endpoints.
        public let modelEndpoint: String?
        /// The Amazon Fraud Detector status for the external model endpoint
        public let modelEndpointStatus: ModelEndpointStatus?
        /// The source of the model.
        public let modelSource: ModelSource?
        /// The output configuration.
        public let outputConfiguration: ModelOutputConfiguration?

        public init(arn: String? = nil, createdTime: String? = nil, inputConfiguration: ModelInputConfiguration? = nil, invokeModelEndpointRoleArn: String? = nil, lastUpdatedTime: String? = nil, modelEndpoint: String? = nil, modelEndpointStatus: ModelEndpointStatus? = nil, modelSource: ModelSource? = nil, outputConfiguration: ModelOutputConfiguration? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.inputConfiguration = inputConfiguration
            self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
            self.lastUpdatedTime = lastUpdatedTime
            self.modelEndpoint = modelEndpoint
            self.modelEndpointStatus = modelEndpointStatus
            self.modelSource = modelSource
            self.outputConfiguration = outputConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case inputConfiguration
            case invokeModelEndpointRoleArn
            case lastUpdatedTime
            case modelEndpoint
            case modelEndpointStatus
            case modelSource
            case outputConfiguration
        }
    }

    public struct ExternalModelOutputs: AWSDecodableShape {
        /// The Amazon SageMaker model.
        public let externalModel: ExternalModelSummary?
        /// The fraud prediction scores from Amazon SageMaker model.
        public let outputs: [String: String]?

        public init(externalModel: ExternalModelSummary? = nil, outputs: [String: String]? = nil) {
            self.externalModel = externalModel
            self.outputs = outputs
        }

        private enum CodingKeys: String, CodingKey {
            case externalModel
            case outputs
        }
    }

    public struct ExternalModelSummary: AWSDecodableShape {
        /// The endpoint of the Amazon SageMaker model.
        public let modelEndpoint: String?
        /// The source of the model.
        public let modelSource: ModelSource?

        public init(modelEndpoint: String? = nil, modelSource: ModelSource? = nil) {
            self.modelEndpoint = modelEndpoint
            self.modelSource = modelSource
        }

        private enum CodingKeys: String, CodingKey {
            case modelEndpoint
            case modelSource
        }
    }

    public struct FieldValidationMessage: AWSDecodableShape {
        /// The message content.
        public let content: String?
        /// The field name.
        public let fieldName: String?
        /// The message ID.
        public let identifier: String?
        /// The message title.
        public let title: String?
        /// The message type.
        public let type: String?

        public init(content: String? = nil, fieldName: String? = nil, identifier: String? = nil, title: String? = nil, type: String? = nil) {
            self.content = content
            self.fieldName = fieldName
            self.identifier = identifier
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case fieldName
            case identifier
            case title
            case type
        }
    }

    public struct FileValidationMessage: AWSDecodableShape {
        /// The message content.
        public let content: String?
        /// The message title.
        public let title: String?
        /// The message type.
        public let type: String?

        public init(content: String? = nil, title: String? = nil, type: String? = nil) {
            self.content = content
            self.title = title
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case title
            case type
        }
    }

    public struct FilterCondition: AWSEncodableShape {
        /// A statement containing a resource property and a value to specify filter condition.
        public let value: String?

        public init(value: String? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[0-9A-Za-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case value
        }
    }

    public struct GetBatchImportJobsRequest: AWSEncodableShape {
        /// The ID of the batch import job to get.
        public let jobId: String?
        /// The maximum number of objects to return for request.
        public let maxResults: Int?
        /// The next token from the previous request.
        public let nextToken: String?

        public init(jobId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
            case maxResults
            case nextToken
        }
    }

    public struct GetBatchImportJobsResult: AWSDecodableShape {
        /// An array containing the details of each batch import job.
        public let batchImports: [BatchImport]?
        /// The next token for the subsequent resquest.
        public let nextToken: String?

        public init(batchImports: [BatchImport]? = nil, nextToken: String? = nil) {
            self.batchImports = batchImports
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchImports
            case nextToken
        }
    }

    public struct GetBatchPredictionJobsRequest: AWSEncodableShape {
        /// The batch prediction job for which to get the details.
        public let jobId: String?
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The next token from the previous request.
        public let nextToken: String?

        public init(jobId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
            case maxResults
            case nextToken
        }
    }

    public struct GetBatchPredictionJobsResult: AWSDecodableShape {
        /// An array containing the details of each batch prediction job.
        public let batchPredictions: [BatchPrediction]?
        /// The next token for the subsequent request.
        public let nextToken: String?

        public init(batchPredictions: [BatchPrediction]? = nil, nextToken: String? = nil) {
            self.batchPredictions = batchPredictions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchPredictions
            case nextToken
        }
    }

    public struct GetDeleteEventsByEventTypeStatusRequest: AWSEncodableShape {
        /// Name of event type for which to get the deletion status.
        public let eventTypeName: String

        public init(eventTypeName: String) {
            self.eventTypeName = eventTypeName
        }

        public func validate(name: String) throws {
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTypeName
        }
    }

    public struct GetDeleteEventsByEventTypeStatusResult: AWSDecodableShape {
        /// The deletion status.
        public let eventsDeletionStatus: AsyncJobStatus?
        /// The event type name.
        public let eventTypeName: String?

        public init(eventsDeletionStatus: AsyncJobStatus? = nil, eventTypeName: String? = nil) {
            self.eventsDeletionStatus = eventsDeletionStatus
            self.eventTypeName = eventTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case eventsDeletionStatus
            case eventTypeName
        }
    }

    public struct GetDetectorVersionRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String

        public init(detectorId: String, detectorVersionId: String) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case detectorVersionId
        }
    }

    public struct GetDetectorVersionResult: AWSDecodableShape {
        /// The detector version ARN.
        public let arn: String?
        /// The timestamp when the detector version was created.
        public let createdTime: String?
        /// The detector version description.
        public let description: String?
        /// The detector ID.
        public let detectorId: String?
        /// The detector version ID.
        public let detectorVersionId: String?
        /// The Amazon SageMaker model endpoints included in the detector version.
        public let externalModelEndpoints: [String]?
        /// The timestamp when the detector version was last updated.
        public let lastUpdatedTime: String?
        /// The model versions included in the detector version.
        public let modelVersions: [ModelVersion]?
        /// The execution mode of the rule in the dectector
        /// 	         FIRST_MATCHED indicates that Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule.
        /// 	         ALL_MATCHED indicates that Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status.
        public let ruleExecutionMode: RuleExecutionMode?
        /// The rules included in the detector version.
        public let rules: [Rule]?
        /// The status of the detector version.
        public let status: DetectorVersionStatus?

        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, detectorId: String? = nil, detectorVersionId: String? = nil, externalModelEndpoints: [String]? = nil, lastUpdatedTime: String? = nil, modelVersions: [ModelVersion]? = nil, ruleExecutionMode: RuleExecutionMode? = nil, rules: [Rule]? = nil, status: DetectorVersionStatus? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.externalModelEndpoints = externalModelEndpoints
            self.lastUpdatedTime = lastUpdatedTime
            self.modelVersions = modelVersions
            self.ruleExecutionMode = ruleExecutionMode
            self.rules = rules
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case description
            case detectorId
            case detectorVersionId
            case externalModelEndpoints
            case lastUpdatedTime
            case modelVersions
            case ruleExecutionMode
            case rules
            case status
        }
    }

    public struct GetDetectorsRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String?
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The next token for the subsequent request.
        public let nextToken: String?

        public init(detectorId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case maxResults
            case nextToken
        }
    }

    public struct GetDetectorsResult: AWSDecodableShape {
        /// The detectors.
        public let detectors: [Detector]?
        /// The next page token.
        public let nextToken: String?

        public init(detectors: [Detector]? = nil, nextToken: String? = nil) {
            self.detectors = detectors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case detectors
            case nextToken
        }
    }

    public struct GetEntityTypesRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The name.
        public let name: String?
        /// The next token for the subsequent request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 5)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case name
            case nextToken
        }
    }

    public struct GetEntityTypesResult: AWSDecodableShape {
        /// An array of entity types.
        public let entityTypes: [EntityType]?
        /// The next page token.
        public let nextToken: String?

        public init(entityTypes: [EntityType]? = nil, nextToken: String? = nil) {
            self.entityTypes = entityTypes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entityTypes
            case nextToken
        }
    }

    public struct GetEventPredictionMetadataRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String
        /// The event ID.
        public let eventId: String
        /// The event type associated with the detector specified for the prediction.
        public let eventTypeName: String
        /// The timestamp that defines when the prediction was generated.
        public let predictionTimestamp: String

        public init(detectorId: String, detectorVersionId: String, eventId: String, eventTypeName: String, predictionTimestamp: String) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.eventId = eventId
            self.eventTypeName = eventTypeName
            self.predictionTimestamp = predictionTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
            try self.validate(self.eventId, name: "eventId", parent: name, max: 64)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 1)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.predictionTimestamp, name: "predictionTimestamp", parent: name, max: 30)
            try self.validate(self.predictionTimestamp, name: "predictionTimestamp", parent: name, min: 11)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case detectorVersionId
            case eventId
            case eventTypeName
            case predictionTimestamp
        }
    }

    public struct GetEventPredictionMetadataResult: AWSDecodableShape {
        /// The detector ID.
        public let detectorId: String?
        /// The detector version ID.
        public let detectorVersionId: String?
        /// The status of the detector version.
        public let detectorVersionStatus: String?
        /// The entity ID.
        public let entityId: String?
        /// The entity type.
        public let entityType: String?
        /// External (Amazon SageMaker) models that were evaluated for generating predictions.
        public let evaluatedExternalModels: [EvaluatedExternalModel]?
        /// Model versions that were evaluated for generating predictions.
        public let evaluatedModelVersions: [EvaluatedModelVersion]?
        /// The event ID.
        public let eventId: String?
        /// The timestamp for when the prediction was generated for the associated event ID.
        public let eventTimestamp: String?
        /// The event type associated with the detector specified for this prediction.
        public let eventTypeName: String?
        /// A list of event variables that influenced the prediction scores.
        public let eventVariables: [EventVariableSummary]?
        /// The outcomes of the matched rule, based on the rule execution mode.
        public let outcomes: [String]?
        /// The timestamp that defines when the prediction was generated.
        public let predictionTimestamp: String?
        /// The execution mode of the rule used for evaluating variable values.
        public let ruleExecutionMode: RuleExecutionMode?
        /// List of rules associated with the detector version that were used for evaluating variable values.
        public let rules: [EvaluatedRule]?

        public init(detectorId: String? = nil, detectorVersionId: String? = nil, detectorVersionStatus: String? = nil, entityId: String? = nil, entityType: String? = nil, evaluatedExternalModels: [EvaluatedExternalModel]? = nil, evaluatedModelVersions: [EvaluatedModelVersion]? = nil, eventId: String? = nil, eventTimestamp: String? = nil, eventTypeName: String? = nil, eventVariables: [EventVariableSummary]? = nil, outcomes: [String]? = nil, predictionTimestamp: String? = nil, ruleExecutionMode: RuleExecutionMode? = nil, rules: [EvaluatedRule]? = nil) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.detectorVersionStatus = detectorVersionStatus
            self.entityId = entityId
            self.entityType = entityType
            self.evaluatedExternalModels = evaluatedExternalModels
            self.evaluatedModelVersions = evaluatedModelVersions
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.eventVariables = eventVariables
            self.outcomes = outcomes
            self.predictionTimestamp = predictionTimestamp
            self.ruleExecutionMode = ruleExecutionMode
            self.rules = rules
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case detectorVersionId
            case detectorVersionStatus
            case entityId
            case entityType
            case evaluatedExternalModels
            case evaluatedModelVersions
            case eventId
            case eventTimestamp
            case eventTypeName
            case eventVariables
            case outcomes
            case predictionTimestamp
            case ruleExecutionMode
            case rules
        }
    }

    public struct GetEventPredictionRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String?
        /// The entity type (associated with the detector's event type) and specific entity ID representing who performed the event. If an entity id is not available, use "UNKNOWN."
        public let entities: [Entity]
        /// The unique ID used to identify the event.
        public let eventId: String
        /// Timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
        public let eventTimestamp: String
        /// The event type associated with the detector specified for the prediction.
        public let eventTypeName: String
        /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and  their corresponding values for the event you are sending for evaluation.  You must provide at least one eventVariable           To ensure most accurate fraud prediction and to simplify your data preparation, Amazon Fraud Detector will replace all missing variables or values as follows:   For Amazon Fraud Detector trained models:  If a null value is provided explicitly for a variable or if a variable is missing, model will replace the null value or the missing variable (no variable name in the eventVariables map)  with calculated default mean/medians for numeric variables and with special values for categorical variables.   For imported SageMaker models:  If a null value is provided explicitly for a variable, the model and rules will use “null” as the value. If a variable is not provided (no variable name in the eventVariables map), model and rules  will use the default value that is provided for the variable.
        public let eventVariables: [String: String]
        /// The Amazon SageMaker model endpoint input data blobs.
        public let externalModelEndpointDataBlobs: [String: ModelEndpointDataBlob]?

        public init(detectorId: String, detectorVersionId: String? = nil, entities: [Entity], eventId: String, eventTimestamp: String, eventTypeName: String, eventVariables: [String: String], externalModelEndpointDataBlobs: [String: ModelEndpointDataBlob]? = nil) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.entities = entities
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.eventVariables = eventVariables
            self.externalModelEndpointDataBlobs = externalModelEndpointDataBlobs
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
            try self.entities.forEach {
                try $0.validate(name: "\(name).entities[]")
            }
            try self.validate(self.eventTimestamp, name: "eventTimestamp", parent: name, max: 30)
            try self.validate(self.eventTimestamp, name: "eventTimestamp", parent: name, min: 10)
            try self.eventVariables.forEach {
                try validate($0.key, name: "eventVariables.key", parent: name, max: 64)
                try validate($0.key, name: "eventVariables.key", parent: name, min: 1)
                try validate($0.value, name: "eventVariables[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "eventVariables[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.eventVariables, name: "eventVariables", parent: name, min: 1)
            try self.externalModelEndpointDataBlobs?.forEach {
                try validate($0.key, name: "externalModelEndpointDataBlobs.key", parent: name, max: 63)
                try validate($0.key, name: "externalModelEndpointDataBlobs.key", parent: name, min: 1)
                try validate($0.key, name: "externalModelEndpointDataBlobs.key", parent: name, pattern: "^[0-9A-Za-z_-]+$")
                try $0.value.validate(name: "\(name).externalModelEndpointDataBlobs[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case detectorVersionId
            case entities
            case eventId
            case eventTimestamp
            case eventTypeName
            case eventVariables
            case externalModelEndpointDataBlobs
        }
    }

    public struct GetEventPredictionResult: AWSDecodableShape {
        /// The model scores for Amazon SageMaker models.
        public let externalModelOutputs: [ExternalModelOutputs]?
        /// The model scores. Amazon Fraud Detector generates model scores between 0 and 1000, where 0 is low fraud risk and 1000 is high fraud risk. Model scores are directly related to the false positive rate (FPR). For example, a score of 600 corresponds to an estimated 10% false positive rate whereas a score of 900 corresponds to an estimated 2% false positive rate.
        public let modelScores: [ModelScores]?
        /// The results from the rules.
        public let ruleResults: [RuleResult]?

        public init(externalModelOutputs: [ExternalModelOutputs]? = nil, modelScores: [ModelScores]? = nil, ruleResults: [RuleResult]? = nil) {
            self.externalModelOutputs = externalModelOutputs
            self.modelScores = modelScores
            self.ruleResults = ruleResults
        }

        private enum CodingKeys: String, CodingKey {
            case externalModelOutputs
            case modelScores
            case ruleResults
        }
    }

    public struct GetEventRequest: AWSEncodableShape {
        /// The ID of the event to retrieve.
        public let eventId: String
        /// The event type of the event to retrieve.
        public let eventTypeName: String

        public init(eventId: String, eventTypeName: String) {
            self.eventId = eventId
            self.eventTypeName = eventTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case eventId
            case eventTypeName
        }
    }

    public struct GetEventResult: AWSDecodableShape {
        /// The details of the event.
        public let event: Event?

        public init(event: Event? = nil) {
            self.event = event
        }

        private enum CodingKeys: String, CodingKey {
            case event
        }
    }

    public struct GetEventTypesRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The name.
        public let name: String?
        /// The next token for the subsequent request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 5)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case name
            case nextToken
        }
    }

    public struct GetEventTypesResult: AWSDecodableShape {
        /// An array of event types.
        public let eventTypes: [EventType]?
        /// The next page token.
        public let nextToken: String?

        public init(eventTypes: [EventType]? = nil, nextToken: String? = nil) {
            self.eventTypes = eventTypes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventTypes
            case nextToken
        }
    }

    public struct GetExternalModelsRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The Amazon SageMaker model endpoint.
        public let modelEndpoint: String?
        /// The next page token for the request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, modelEndpoint: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.modelEndpoint = modelEndpoint
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case modelEndpoint
            case nextToken
        }
    }

    public struct GetExternalModelsResult: AWSDecodableShape {
        /// Gets the Amazon SageMaker models.
        public let externalModels: [ExternalModel]?
        /// The next page token to be used in subsequent requests.
        public let nextToken: String?

        public init(externalModels: [ExternalModel]? = nil, nextToken: String? = nil) {
            self.externalModels = externalModels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case externalModels
            case nextToken
        }
    }

    public struct GetKMSEncryptionKeyResult: AWSDecodableShape {
        /// The KMS encryption key.
        public let kmsKey: KMSKey?

        public init(kmsKey: KMSKey? = nil) {
            self.kmsKey = kmsKey
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKey
        }
    }

    public struct GetLabelsRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The name of the label or labels to get.
        public let name: String?
        /// The next token for the subsequent request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 10)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case name
            case nextToken
        }
    }

    public struct GetLabelsResult: AWSDecodableShape {
        /// An array of labels.
        public let labels: [Label]?
        /// The next page token.
        public let nextToken: String?

        public init(labels: [Label]? = nil, nextToken: String? = nil) {
            self.labels = labels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case labels
            case nextToken
        }
    }

    public struct GetModelVersionRequest: AWSEncodableShape {
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// The model version number.
        public let modelVersionNumber: String

        public init(modelId: String, modelType: ModelTypeEnum, modelVersionNumber: String) {
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, max: 7)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, min: 3)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, pattern: "^[1-9][0-9]{0,3}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelId
            case modelType
            case modelVersionNumber
        }
    }

    public struct GetModelVersionResult: AWSDecodableShape {
        /// The model version ARN.
        public let arn: String?
        /// The details of the external events data used for training the model version.  This will be populated if the trainingDataSource is EXTERNAL_EVENTS
        public let externalEventsDetail: ExternalEventsDetail?
        /// The details of the ingested events data used for training the model version.  This will be populated if the trainingDataSource is INGESTED_EVENTS.
        public let ingestedEventsDetail: IngestedEventsDetail?
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The model version number.
        public let modelVersionNumber: String?
        /// The model version status.
        /// 	        Possible values are:
        /// 	           TRAINING_IN_PROGRESS     TRAINING_COMPLETE     ACTIVATE_REQUESTED     ACTIVATE_IN_PROGRESS     ACTIVE     INACTIVATE_REQUESTED     INACTIVATE_IN_PROGRESS     INACTIVE     ERROR
        public let status: String?
        /// The training data schema.
        public let trainingDataSchema: TrainingDataSchema?
        /// The training data source.
        public let trainingDataSource: TrainingDataSourceEnum?

        public init(arn: String? = nil, externalEventsDetail: ExternalEventsDetail? = nil, ingestedEventsDetail: IngestedEventsDetail? = nil, modelId: String? = nil, modelType: ModelTypeEnum? = nil, modelVersionNumber: String? = nil, status: String? = nil, trainingDataSchema: TrainingDataSchema? = nil, trainingDataSource: TrainingDataSourceEnum? = nil) {
            self.arn = arn
            self.externalEventsDetail = externalEventsDetail
            self.ingestedEventsDetail = ingestedEventsDetail
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
            self.trainingDataSchema = trainingDataSchema
            self.trainingDataSource = trainingDataSource
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case externalEventsDetail
            case ingestedEventsDetail
            case modelId
            case modelType
            case modelVersionNumber
            case status
            case trainingDataSchema
            case trainingDataSource
        }
    }

    public struct GetModelsRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The next token for the subsequent request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, modelId: String? = nil, modelType: ModelTypeEnum? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.modelId = modelId
            self.modelType = modelType
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case modelId
            case modelType
            case nextToken
        }
    }

    public struct GetModelsResult: AWSDecodableShape {
        /// The array of models.
        public let models: [Model]?
        /// The next page token to be used in subsequent requests.
        public let nextToken: String?

        public init(models: [Model]? = nil, nextToken: String? = nil) {
            self.models = models
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case models
            case nextToken
        }
    }

    public struct GetOutcomesRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The name of the outcome or outcomes to get.
        public let name: String?
        /// The next page token for the request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 50)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case name
            case nextToken
        }
    }

    public struct GetOutcomesResult: AWSDecodableShape {
        /// The next page token for subsequent requests.
        public let nextToken: String?
        /// The outcomes.
        public let outcomes: [Outcome]?

        public init(nextToken: String? = nil, outcomes: [Outcome]? = nil) {
            self.nextToken = nextToken
            self.outcomes = outcomes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case outcomes
        }
    }

    public struct GetRulesRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The maximum number of rules to return for the request.
        public let maxResults: Int?
        /// The next page token.
        public let nextToken: String?
        /// The rule ID.
        public let ruleId: String?
        /// The rule version.
        public let ruleVersion: String?

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil, ruleId: String? = nil, ruleVersion: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 50)
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 64)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, max: 5)
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, min: 1)
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case maxResults
            case nextToken
            case ruleId
            case ruleVersion
        }
    }

    public struct GetRulesResult: AWSDecodableShape {
        /// The next page token to be used in subsequent requests.
        public let nextToken: String?
        /// The details of the requested rule.
        public let ruleDetails: [RuleDetail]?

        public init(nextToken: String? = nil, ruleDetails: [RuleDetail]? = nil) {
            self.nextToken = nextToken
            self.ruleDetails = ruleDetails
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case ruleDetails
        }
    }

    public struct GetVariablesRequest: AWSEncodableShape {
        /// The max size per page determined for the get variable request.
        public let maxResults: Int?
        /// The name of the variable.
        public let name: String?
        /// The next page token of the get variable request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case name
            case nextToken
        }
    }

    public struct GetVariablesResult: AWSDecodableShape {
        /// The next page token to be used in subsequent requests.
        public let nextToken: String?
        /// The names of the variables returned.
        public let variables: [Variable]?

        public init(nextToken: String? = nil, variables: [Variable]? = nil) {
            self.nextToken = nextToken
            self.variables = variables
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case variables
        }
    }

    public struct IngestedEventStatistics: AWSDecodableShape {
        /// The total size of the stored events.
        public let eventDataSizeInBytes: Int64?
        /// Timestamp of when the stored event was last updated.
        public let lastUpdatedTime: String?
        /// The oldest stored event.
        public let leastRecentEvent: String?
        /// The newest stored event.
        public let mostRecentEvent: String?
        /// The number of stored events.
        public let numberOfEvents: Int64?

        public init(eventDataSizeInBytes: Int64? = nil, lastUpdatedTime: String? = nil, leastRecentEvent: String? = nil, mostRecentEvent: String? = nil, numberOfEvents: Int64? = nil) {
            self.eventDataSizeInBytes = eventDataSizeInBytes
            self.lastUpdatedTime = lastUpdatedTime
            self.leastRecentEvent = leastRecentEvent
            self.mostRecentEvent = mostRecentEvent
            self.numberOfEvents = numberOfEvents
        }

        private enum CodingKeys: String, CodingKey {
            case eventDataSizeInBytes
            case lastUpdatedTime
            case leastRecentEvent
            case mostRecentEvent
            case numberOfEvents
        }
    }

    public struct IngestedEventsDetail: AWSEncodableShape & AWSDecodableShape {
        /// The start and stop time of the ingested events.
        public let ingestedEventsTimeWindow: IngestedEventsTimeWindow

        public init(ingestedEventsTimeWindow: IngestedEventsTimeWindow) {
            self.ingestedEventsTimeWindow = ingestedEventsTimeWindow
        }

        public func validate(name: String) throws {
            try self.ingestedEventsTimeWindow.validate(name: "\(name).ingestedEventsTimeWindow")
        }

        private enum CodingKeys: String, CodingKey {
            case ingestedEventsTimeWindow
        }
    }

    public struct IngestedEventsTimeWindow: AWSEncodableShape & AWSDecodableShape {
        /// Timestamp of the final ingested event.
        public let endTime: String
        /// Timestamp of the first ingensted event.
        public let startTime: String

        public init(endTime: String, startTime: String) {
            self.endTime = endTime
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.endTime, name: "endTime", parent: name, max: 30)
            try self.validate(self.endTime, name: "endTime", parent: name, min: 11)
            try self.validate(self.startTime, name: "startTime", parent: name, max: 30)
            try self.validate(self.startTime, name: "startTime", parent: name, min: 11)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case startTime
        }
    }

    public struct KMSKey: AWSDecodableShape {
        /// The encryption key ARN.
        public let kmsEncryptionKeyArn: String?

        public init(kmsEncryptionKeyArn: String? = nil) {
            self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case kmsEncryptionKeyArn
        }
    }

    public struct Label: AWSDecodableShape {
        /// The label ARN.
        public let arn: String?
        /// Timestamp of when the event type was created.
        public let createdTime: String?
        /// The label description.
        public let description: String?
        /// Timestamp of when the label was last updated.
        public let lastUpdatedTime: String?
        /// The label name.
        public let name: String?

        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, lastUpdatedTime: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case description
            case lastUpdatedTime
            case name
        }
    }

    public struct LabelSchema: AWSEncodableShape & AWSDecodableShape {
        /// The label mapper maps the Amazon Fraud Detector supported model classification labels (FRAUD, LEGIT) to the appropriate event type labels. For example, if "FRAUD" and "LEGIT" are Amazon Fraud Detector supported labels, this mapper could be: {"FRAUD" => ["0"], "LEGIT" => ["1"]} or {"FRAUD" => ["false"], "LEGIT" => ["true"]} or {"FRAUD" => ["fraud", "abuse"], "LEGIT" => ["legit", "safe"]}. The value part of the mapper is a list, because you may have multiple label variants from your event type for a single Amazon Fraud Detector label.
        public let labelMapper: [String: [String]]
        /// The action to take for unlabeled events.
        public let unlabeledEventsTreatment: UnlabeledEventsTreatment?

        public init(labelMapper: [String: [String]], unlabeledEventsTreatment: UnlabeledEventsTreatment? = nil) {
            self.labelMapper = labelMapper
            self.unlabeledEventsTreatment = unlabeledEventsTreatment
        }

        public func validate(name: String) throws {
            try self.labelMapper.forEach {
                try validate($0.value, name: "labelMapper[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case labelMapper
            case unlabeledEventsTreatment
        }
    }

    public struct ListEventPredictionsRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: FilterCondition?
        /// The detector version ID.
        public let detectorVersionId: FilterCondition?
        /// The event ID.
        public let eventId: FilterCondition?
        /// The event type associated with the detector.
        public let eventType: FilterCondition?
        /// The maximum number of predictions to return for the request.
        public let maxResults: Int?
        /// Identifies the next page of results to return. Use the token to make the call again to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
        public let nextToken: String?
        /// The time period for when the predictions were generated.
        public let predictionTimeRange: PredictionTimeRange?

        public init(detectorId: FilterCondition? = nil, detectorVersionId: FilterCondition? = nil, eventId: FilterCondition? = nil, eventType: FilterCondition? = nil, maxResults: Int? = nil, nextToken: String? = nil, predictionTimeRange: PredictionTimeRange? = nil) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.eventId = eventId
            self.eventType = eventType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.predictionTimeRange = predictionTimeRange
        }

        public func validate(name: String) throws {
            try self.detectorId?.validate(name: "\(name).detectorId")
            try self.detectorVersionId?.validate(name: "\(name).detectorVersionId")
            try self.eventId?.validate(name: "\(name).eventId")
            try self.eventType?.validate(name: "\(name).eventType")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 50)
            try self.predictionTimeRange?.validate(name: "\(name).predictionTimeRange")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case detectorVersionId
            case eventId
            case eventType
            case maxResults
            case nextToken
            case predictionTimeRange
        }
    }

    public struct ListEventPredictionsResult: AWSDecodableShape {
        /// The summary of the past predictions.
        public let eventPredictionSummaries: [EventPredictionSummary]?
        /// Identifies the next page of results to return. Use the token to make the call again to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
        public let nextToken: String?

        public init(eventPredictionSummaries: [EventPredictionSummary]? = nil, nextToken: String? = nil) {
            self.eventPredictionSummaries = eventPredictionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventPredictionSummaries
            case nextToken
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The maximum number of objects to return for the request.
        public let maxResults: Int?
        /// The next token from the previous results.
        public let nextToken: String?
        /// The ARN that specifies the resource whose tags you want to list.
        public let resourceARN: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceARN: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 50)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 256)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:frauddetector\\:[a-z0-9-]{3,20}\\:[0-9]{12}\\:[^\\s]{2,128}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case resourceARN
        }
    }

    public struct ListTagsForResourceResult: AWSDecodableShape {
        /// The next token for subsequent requests.
        public let nextToken: String?
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case tags
        }
    }

    public struct LogOddsMetric: AWSDecodableShape {
        /// The relative importance of the variable. For more information, see Model variable importance.
        public let variableImportance: Float
        /// The name of the variable.
        public let variableName: String
        /// The type of variable.
        public let variableType: String

        public init(variableImportance: Float, variableName: String, variableType: String) {
            self.variableImportance = variableImportance
            self.variableName = variableName
            self.variableType = variableType
        }

        private enum CodingKeys: String, CodingKey {
            case variableImportance
            case variableName
            case variableType
        }
    }

    public struct MetricDataPoint: AWSDecodableShape {
        /// The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.
        public let fpr: Float?
        /// The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.
        public let precision: Float?
        /// The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public let threshold: Float?
        /// The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.
        public let tpr: Float?

        public init(fpr: Float? = nil, precision: Float? = nil, threshold: Float? = nil, tpr: Float? = nil) {
            self.fpr = fpr
            self.precision = precision
            self.threshold = threshold
            self.tpr = tpr
        }

        private enum CodingKeys: String, CodingKey {
            case fpr
            case precision
            case threshold
            case tpr
        }
    }

    public struct Model: AWSDecodableShape {
        /// The ARN of the model.
        public let arn: String?
        /// Timestamp of when the model was created.
        public let createdTime: String?
        /// The model description.
        public let description: String?
        /// The name of the event type.
        public let eventTypeName: String?
        /// Timestamp of last time the model was updated.
        public let lastUpdatedTime: String?
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?

        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, eventTypeName: String? = nil, lastUpdatedTime: String? = nil, modelId: String? = nil, modelType: ModelTypeEnum? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.eventTypeName = eventTypeName
            self.lastUpdatedTime = lastUpdatedTime
            self.modelId = modelId
            self.modelType = modelType
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case description
            case eventTypeName
            case lastUpdatedTime
            case modelId
            case modelType
        }
    }

    public struct ModelEndpointDataBlob: AWSEncodableShape {
        /// The byte buffer of the Amazon SageMaker model endpoint input data blob.
        public let byteBuffer: Data?
        /// The content type of the Amazon SageMaker model endpoint input data blob.
        public let contentType: String?

        public init(byteBuffer: Data? = nil, contentType: String? = nil) {
            self.byteBuffer = byteBuffer
            self.contentType = contentType
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, max: 1024)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case byteBuffer
            case contentType
        }
    }

    public struct ModelInputConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  Template for constructing the CSV input-data sent to SageMaker. At event-evaluation, the placeholders for variable-names in the template will be replaced with the variable values before being sent to SageMaker.
        public let csvInputTemplate: String?
        /// The event type name.
        public let eventTypeName: String?
        ///  The format of the model input configuration. The format differs depending on if it is passed through to SageMaker or constructed by Amazon Fraud Detector.
        public let format: ModelInputDataFormat?
        ///  Template for constructing the JSON input-data sent to SageMaker. At event-evaluation, the placeholders for variable names in the template will be replaced with the variable values before being sent to SageMaker.
        public let jsonInputTemplate: String?
        /// The event variables.
        public let useEventVariables: Bool

        public init(csvInputTemplate: String? = nil, eventTypeName: String? = nil, format: ModelInputDataFormat? = nil, jsonInputTemplate: String? = nil, useEventVariables: Bool) {
            self.csvInputTemplate = csvInputTemplate
            self.eventTypeName = eventTypeName
            self.format = format
            self.jsonInputTemplate = jsonInputTemplate
            self.useEventVariables = useEventVariables
        }

        public func validate(name: String) throws {
            try self.validate(self.csvInputTemplate, name: "csvInputTemplate", parent: name, max: 2000)
            try self.validate(self.csvInputTemplate, name: "csvInputTemplate", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.jsonInputTemplate, name: "jsonInputTemplate", parent: name, max: 2000)
            try self.validate(self.jsonInputTemplate, name: "jsonInputTemplate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case csvInputTemplate
            case eventTypeName
            case format
            case jsonInputTemplate
            case useEventVariables
        }
    }

    public struct ModelOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A map of CSV index values in the SageMaker response to the Amazon Fraud Detector variables.
        public let csvIndexToVariableMap: [String: String]?
        /// The format of the model output configuration.
        public let format: ModelOutputDataFormat
        /// A map of JSON keys in response from SageMaker to the Amazon Fraud Detector variables.
        public let jsonKeyToVariableMap: [String: String]?

        public init(csvIndexToVariableMap: [String: String]? = nil, format: ModelOutputDataFormat, jsonKeyToVariableMap: [String: String]? = nil) {
            self.csvIndexToVariableMap = csvIndexToVariableMap
            self.format = format
            self.jsonKeyToVariableMap = jsonKeyToVariableMap
        }

        private enum CodingKeys: String, CodingKey {
            case csvIndexToVariableMap
            case format
            case jsonKeyToVariableMap
        }
    }

    public struct ModelScores: AWSDecodableShape {
        /// The model version.
        public let modelVersion: ModelVersion?
        /// The model's fraud prediction scores.
        public let scores: [String: Float]?

        public init(modelVersion: ModelVersion? = nil, scores: [String: Float]? = nil) {
            self.modelVersion = modelVersion
            self.scores = scores
        }

        private enum CodingKeys: String, CodingKey {
            case modelVersion
            case scores
        }
    }

    public struct ModelVersion: AWSEncodableShape & AWSDecodableShape {
        /// The model version ARN.
        public let arn: String?
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// The model version number.
        public let modelVersionNumber: String

        public init(arn: String? = nil, modelId: String, modelType: ModelTypeEnum, modelVersionNumber: String) {
            self.arn = arn
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 256)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:frauddetector\\:[a-z0-9-]{3,20}\\:[0-9]{12}\\:[^\\s]{2,128}$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, max: 7)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, min: 3)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, pattern: "^[1-9][0-9]{0,3}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case modelId
            case modelType
            case modelVersionNumber
        }
    }

    public struct ModelVersionDetail: AWSDecodableShape {
        /// The model version ARN.
        public let arn: String?
        /// The timestamp when the model was created.
        public let createdTime: String?
        /// The external events data details. This will be populated if the trainingDataSource for the model version is specified as  EXTERNAL_EVENTS.
        public let externalEventsDetail: ExternalEventsDetail?
        /// The ingested events data details. This will be populated if the trainingDataSource for the model version is specified as  INGESTED_EVENTS.
        public let ingestedEventsDetail: IngestedEventsDetail?
        /// The timestamp when the model was last updated.
        public let lastUpdatedTime: String?
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The model version number.
        public let modelVersionNumber: String?
        /// The status of the model version.
        public let status: String?
        /// The training data schema.
        public let trainingDataSchema: TrainingDataSchema?
        /// The model version training data source.
        public let trainingDataSource: TrainingDataSourceEnum?
        /// The training results.
        public let trainingResult: TrainingResult?

        public init(arn: String? = nil, createdTime: String? = nil, externalEventsDetail: ExternalEventsDetail? = nil, ingestedEventsDetail: IngestedEventsDetail? = nil, lastUpdatedTime: String? = nil, modelId: String? = nil, modelType: ModelTypeEnum? = nil, modelVersionNumber: String? = nil, status: String? = nil, trainingDataSchema: TrainingDataSchema? = nil, trainingDataSource: TrainingDataSourceEnum? = nil, trainingResult: TrainingResult? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.externalEventsDetail = externalEventsDetail
            self.ingestedEventsDetail = ingestedEventsDetail
            self.lastUpdatedTime = lastUpdatedTime
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
            self.trainingDataSchema = trainingDataSchema
            self.trainingDataSource = trainingDataSource
            self.trainingResult = trainingResult
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case externalEventsDetail
            case ingestedEventsDetail
            case lastUpdatedTime
            case modelId
            case modelType
            case modelVersionNumber
            case status
            case trainingDataSchema
            case trainingDataSource
            case trainingResult
        }
    }

    public struct ModelVersionEvaluation: AWSDecodableShape {
        /// The evaluation score generated for the model version.
        public let evaluationScore: String?
        /// The output variable name.
        public let outputVariableName: String?
        /// The prediction explanations generated for the model version.
        public let predictionExplanations: PredictionExplanations?

        public init(evaluationScore: String? = nil, outputVariableName: String? = nil, predictionExplanations: PredictionExplanations? = nil) {
            self.evaluationScore = evaluationScore
            self.outputVariableName = outputVariableName
            self.predictionExplanations = predictionExplanations
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationScore
            case outputVariableName
            case predictionExplanations
        }
    }

    public struct Outcome: AWSDecodableShape {
        /// The outcome ARN.
        public let arn: String?
        /// The timestamp when the outcome was created.
        public let createdTime: String?
        /// The outcome description.
        public let description: String?
        /// The timestamp when the outcome was last updated.
        public let lastUpdatedTime: String?
        /// The outcome name.
        public let name: String?

        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, lastUpdatedTime: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case description
            case lastUpdatedTime
            case name
        }
    }

    public struct PredictionExplanations: AWSDecodableShape {
        /// The details of the event variable's impact on the prediction score.
        public let variableImpactExplanations: [VariableImpactExplanation]?

        public init(variableImpactExplanations: [VariableImpactExplanation]? = nil) {
            self.variableImpactExplanations = variableImpactExplanations
        }

        private enum CodingKeys: String, CodingKey {
            case variableImpactExplanations
        }
    }

    public struct PredictionTimeRange: AWSEncodableShape {
        /// The end time of the time period for when the predictions were generated.
        public let endTime: String
        /// The start time of the time period for when the predictions were generated.
        public let startTime: String

        public init(endTime: String, startTime: String) {
            self.endTime = endTime
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.endTime, name: "endTime", parent: name, max: 30)
            try self.validate(self.endTime, name: "endTime", parent: name, min: 11)
            try self.validate(self.startTime, name: "startTime", parent: name, max: 30)
            try self.validate(self.startTime, name: "startTime", parent: name, min: 11)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case startTime
        }
    }

    public struct PutDetectorRequest: AWSEncodableShape {
        /// The description of the detector.
        public let description: String?
        /// The detector ID.
        public let detectorId: String
        /// The name of the event type.
        public let eventTypeName: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        public init(description: String? = nil, detectorId: String, eventTypeName: String, tags: [Tag]? = nil) {
            self.description = description
            self.detectorId = detectorId
            self.eventTypeName = eventTypeName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case detectorId
            case eventTypeName
            case tags
        }
    }

    public struct PutDetectorResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutEntityTypeRequest: AWSEncodableShape {
        /// The description.
        public let description: String?
        /// The name of the entity type.
        public let name: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        public init(description: String? = nil, name: String, tags: [Tag]? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case tags
        }
    }

    public struct PutEntityTypeResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutEventTypeRequest: AWSEncodableShape {
        /// The description of the event type.
        public let description: String?
        /// The entity type for the event type. Example entity types: customer, merchant, account.
        public let entityTypes: [String]
        /// Specifies if ingenstion is enabled or disabled.
        public let eventIngestion: EventIngestion?
        /// The event type variables.
        public let eventVariables: [String]
        /// The event type labels.
        public let labels: [String]?
        /// The name.
        public let name: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        public init(description: String? = nil, entityTypes: [String], eventIngestion: EventIngestion? = nil, eventVariables: [String], labels: [String]? = nil, name: String, tags: [Tag]? = nil) {
            self.description = description
            self.entityTypes = entityTypes
            self.eventIngestion = eventIngestion
            self.eventVariables = eventVariables
            self.labels = labels
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.entityTypes, name: "entityTypes", parent: name, min: 1)
            try self.validate(self.eventVariables, name: "eventVariables", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case entityTypes
            case eventIngestion
            case eventVariables
            case labels
            case name
            case tags
        }
    }

    public struct PutEventTypeResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutExternalModelRequest: AWSEncodableShape {
        /// The model endpoint input configuration.
        public let inputConfiguration: ModelInputConfiguration
        /// The IAM role used to invoke the model endpoint.
        public let invokeModelEndpointRoleArn: String
        /// The model endpoints name.
        public let modelEndpoint: String
        /// The model endpoint’s status in Amazon Fraud Detector.
        public let modelEndpointStatus: ModelEndpointStatus
        /// The source of the model.
        public let modelSource: ModelSource
        /// The model endpoint output configuration.
        public let outputConfiguration: ModelOutputConfiguration
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        public init(inputConfiguration: ModelInputConfiguration, invokeModelEndpointRoleArn: String, modelEndpoint: String, modelEndpointStatus: ModelEndpointStatus, modelSource: ModelSource, outputConfiguration: ModelOutputConfiguration, tags: [Tag]? = nil) {
            self.inputConfiguration = inputConfiguration
            self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
            self.modelEndpoint = modelEndpoint
            self.modelEndpointStatus = modelEndpointStatus
            self.modelSource = modelSource
            self.outputConfiguration = outputConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.inputConfiguration.validate(name: "\(name).inputConfiguration")
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, max: 63)
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, min: 1)
            try self.validate(self.modelEndpoint, name: "modelEndpoint", parent: name, pattern: "^[0-9A-Za-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case inputConfiguration
            case invokeModelEndpointRoleArn
            case modelEndpoint
            case modelEndpointStatus
            case modelSource
            case outputConfiguration
            case tags
        }
    }

    public struct PutExternalModelResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutKMSEncryptionKeyRequest: AWSEncodableShape {
        /// The KMS encryption key ARN.
        public let kmsEncryptionKeyArn: String

        public init(kmsEncryptionKeyArn: String) {
            self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsEncryptionKeyArn, name: "kmsEncryptionKeyArn", parent: name, max: 90)
            try self.validate(self.kmsEncryptionKeyArn, name: "kmsEncryptionKeyArn", parent: name, min: 7)
            try self.validate(self.kmsEncryptionKeyArn, name: "kmsEncryptionKeyArn", parent: name, pattern: "^DEFAULT|arn:[a-zA-Z0-9-]+:kms:[a-zA-Z0-9-]+:\\d{12}:key\\/\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsEncryptionKeyArn
        }
    }

    public struct PutKMSEncryptionKeyResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutLabelRequest: AWSEncodableShape {
        /// The label description.
        public let description: String?
        /// The label name.
        public let name: String
        public let tags: [Tag]?

        public init(description: String? = nil, name: String, tags: [Tag]? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case tags
        }
    }

    public struct PutLabelResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutOutcomeRequest: AWSEncodableShape {
        /// The outcome description.
        public let description: String?
        /// The name of the outcome.
        public let name: String
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        public init(description: String? = nil, name: String, tags: [Tag]? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case tags
        }
    }

    public struct PutOutcomeResult: AWSDecodableShape {
        public init() {}
    }

    public struct Rule: AWSEncodableShape & AWSDecodableShape {
        /// The detector for which the rule is associated.
        public let detectorId: String
        /// The rule ID.
        public let ruleId: String
        /// The rule version.
        public let ruleVersion: String

        public init(detectorId: String, ruleId: String, ruleVersion: String) {
            self.detectorId = detectorId
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 64)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, max: 5)
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, min: 1)
            try self.validate(self.ruleVersion, name: "ruleVersion", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case ruleId
            case ruleVersion
        }
    }

    public struct RuleDetail: AWSDecodableShape {
        /// The rule ARN.
        public let arn: String?
        /// The timestamp of when the rule was created.
        public let createdTime: String?
        /// The rule description.
        public let description: String?
        /// The detector for which the rule is associated.
        public let detectorId: String?
        /// The rule expression.
        public let expression: String?
        /// The rule language.
        public let language: Language?
        /// Timestamp of the last time the rule was updated.
        public let lastUpdatedTime: String?
        /// The rule outcomes.
        public let outcomes: [String]?
        /// The rule ID.
        public let ruleId: String?
        /// The rule version.
        public let ruleVersion: String?

        public init(arn: String? = nil, createdTime: String? = nil, description: String? = nil, detectorId: String? = nil, expression: String? = nil, language: Language? = nil, lastUpdatedTime: String? = nil, outcomes: [String]? = nil, ruleId: String? = nil, ruleVersion: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.expression = expression
            self.language = language
            self.lastUpdatedTime = lastUpdatedTime
            self.outcomes = outcomes
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case description
            case detectorId
            case expression
            case language
            case lastUpdatedTime
            case outcomes
            case ruleId
            case ruleVersion
        }
    }

    public struct RuleResult: AWSDecodableShape {
        /// The outcomes of the matched rule, based on the rule execution mode.
        public let outcomes: [String]?
        /// The rule ID that was matched, based on the rule execution mode.
        public let ruleId: String?

        public init(outcomes: [String]? = nil, ruleId: String? = nil) {
            self.outcomes = outcomes
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case outcomes
            case ruleId
        }
    }

    public struct SendEventRequest: AWSEncodableShape {
        /// The label to associate with the event. Required if specifying labelTimestamp.
        public let assignedLabel: String?
        /// An array of entities.
        public let entities: [Entity]
        /// The event ID to upload.
        public let eventId: String
        /// The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
        public let eventTimestamp: String
        /// The event type name of the event.
        public let eventTypeName: String
        /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.
        public let eventVariables: [String: String]
        /// The timestamp associated with the label. Required if specifying assignedLabel.
        public let labelTimestamp: String?

        public init(assignedLabel: String? = nil, entities: [Entity], eventId: String, eventTimestamp: String, eventTypeName: String, eventVariables: [String: String], labelTimestamp: String? = nil) {
            self.assignedLabel = assignedLabel
            self.entities = entities
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.eventVariables = eventVariables
            self.labelTimestamp = labelTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, max: 64)
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, min: 1)
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.entities.forEach {
                try $0.validate(name: "\(name).entities[]")
            }
            try self.validate(self.eventId, name: "eventId", parent: name, max: 64)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 1)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventTimestamp, name: "eventTimestamp", parent: name, max: 30)
            try self.validate(self.eventTimestamp, name: "eventTimestamp", parent: name, min: 10)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.eventVariables.forEach {
                try validate($0.key, name: "eventVariables.key", parent: name, max: 64)
                try validate($0.key, name: "eventVariables.key", parent: name, min: 1)
                try validate($0.value, name: "eventVariables[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "eventVariables[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.eventVariables, name: "eventVariables", parent: name, min: 1)
            try self.validate(self.labelTimestamp, name: "labelTimestamp", parent: name, max: 30)
            try self.validate(self.labelTimestamp, name: "labelTimestamp", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case assignedLabel
            case entities
            case eventId
            case eventTimestamp
            case eventTypeName
            case eventVariables
            case labelTimestamp
        }
    }

    public struct SendEventResult: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// A tag key.
        public let key: String
        /// A value assigned to a tag key.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource ARN.
        public let resourceARN: String
        /// The tags to assign to the resource.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 256)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:frauddetector\\:[a-z0-9-]{3,20}\\:[0-9]{12}\\:[^\\s]{2,128}$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN
            case tags
        }
    }

    public struct TagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct TrainingDataSchema: AWSEncodableShape & AWSDecodableShape {
        public let labelSchema: LabelSchema
        /// The training data schema variables.
        public let modelVariables: [String]

        public init(labelSchema: LabelSchema, modelVariables: [String]) {
            self.labelSchema = labelSchema
            self.modelVariables = modelVariables
        }

        public func validate(name: String) throws {
            try self.labelSchema.validate(name: "\(name).labelSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case labelSchema
            case modelVariables
        }
    }

    public struct TrainingMetrics: AWSDecodableShape {
        /// The area under the curve. This summarizes true positive rate (TPR) and false positive rate (FPR) across all possible model score thresholds. A model with no predictive power has an AUC of 0.5, whereas a perfect model has a score of 1.0.
        public let auc: Float?
        /// The data points details.
        public let metricDataPoints: [MetricDataPoint]?

        public init(auc: Float? = nil, metricDataPoints: [MetricDataPoint]? = nil) {
            self.auc = auc
            self.metricDataPoints = metricDataPoints
        }

        private enum CodingKeys: String, CodingKey {
            case auc
            case metricDataPoints
        }
    }

    public struct TrainingResult: AWSDecodableShape {
        /// The validation metrics.
        public let dataValidationMetrics: DataValidationMetrics?
        /// The training metric details.
        public let trainingMetrics: TrainingMetrics?
        /// The variable importance metrics.
        public let variableImportanceMetrics: VariableImportanceMetrics?

        public init(dataValidationMetrics: DataValidationMetrics? = nil, trainingMetrics: TrainingMetrics? = nil, variableImportanceMetrics: VariableImportanceMetrics? = nil) {
            self.dataValidationMetrics = dataValidationMetrics
            self.trainingMetrics = trainingMetrics
            self.variableImportanceMetrics = variableImportanceMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case dataValidationMetrics
            case trainingMetrics
            case variableImportanceMetrics
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource from which to remove the tag.
        public let resourceARN: String
        /// The resource ARN.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 256)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn\\:aws[a-z-]{0,15}\\:frauddetector\\:[a-z0-9-]{3,20}\\:[0-9]{12}\\:[^\\s]{2,128}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN
            case tagKeys
        }
    }

    public struct UntagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDetectorVersionMetadataRequest: AWSEncodableShape {
        /// The description.
        public let description: String
        /// The detector ID.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String

        public init(description: String, detectorId: String, detectorVersionId: String) {
            self.description = description
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case detectorId
            case detectorVersionId
        }
    }

    public struct UpdateDetectorVersionMetadataResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDetectorVersionRequest: AWSEncodableShape {
        /// The detector version description.
        public let description: String?
        /// The parent detector ID for the detector version you want to update.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String
        /// The Amazon SageMaker model endpoints to include in the detector version.
        public let externalModelEndpoints: [String]
        /// The model versions to include in the detector version.
        public let modelVersions: [ModelVersion]?
        /// The rule execution mode to add to the detector.
        /// 	        If you specify FIRST_MATCHED, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule.
        /// 	        If you specifiy ALL_MATCHED, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status. The default behavior is FIRST_MATCHED.
        public let ruleExecutionMode: RuleExecutionMode?
        /// The rules to include in the detector version.
        public let rules: [Rule]

        public init(description: String? = nil, detectorId: String, detectorVersionId: String, externalModelEndpoints: [String], modelVersions: [ModelVersion]? = nil, ruleExecutionMode: RuleExecutionMode? = nil, rules: [Rule]) {
            self.description = description
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.externalModelEndpoints = externalModelEndpoints
            self.modelVersions = modelVersions
            self.ruleExecutionMode = ruleExecutionMode
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
            try self.modelVersions?.forEach {
                try $0.validate(name: "\(name).modelVersions[]")
            }
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case detectorId
            case detectorVersionId
            case externalModelEndpoints
            case modelVersions
            case ruleExecutionMode
            case rules
        }
    }

    public struct UpdateDetectorVersionResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDetectorVersionStatusRequest: AWSEncodableShape {
        /// The detector ID.
        public let detectorId: String
        /// The detector version ID.
        public let detectorVersionId: String
        /// The new status.
        public let status: DetectorVersionStatus

        public init(detectorId: String, detectorVersionId: String, status: DetectorVersionStatus) {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, max: 5)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, min: 1)
            try self.validate(self.detectorVersionId, name: "detectorVersionId", parent: name, pattern: "^([1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case detectorVersionId
            case status
        }
    }

    public struct UpdateDetectorVersionStatusResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEventLabelRequest: AWSEncodableShape {
        /// The new label to assign to the event.
        public let assignedLabel: String
        /// The ID of the event associated with the label to update.
        public let eventId: String
        /// The event type of the event associated with the label to update.
        public let eventTypeName: String
        /// The timestamp associated with the label. The timestamp must be specified using ISO 8601 standard in UTC.
        public let labelTimestamp: String

        public init(assignedLabel: String, eventId: String, eventTypeName: String, labelTimestamp: String) {
            self.assignedLabel = assignedLabel
            self.eventId = eventId
            self.eventTypeName = eventTypeName
            self.labelTimestamp = labelTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, max: 64)
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, min: 1)
            try self.validate(self.assignedLabel, name: "assignedLabel", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventId, name: "eventId", parent: name, max: 64)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 1)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, max: 64)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, min: 1)
            try self.validate(self.eventTypeName, name: "eventTypeName", parent: name, pattern: "^[0-9a-z_-]+$")
            try self.validate(self.labelTimestamp, name: "labelTimestamp", parent: name, max: 30)
            try self.validate(self.labelTimestamp, name: "labelTimestamp", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case assignedLabel
            case eventId
            case eventTypeName
            case labelTimestamp
        }
    }

    public struct UpdateEventLabelResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateModelRequest: AWSEncodableShape {
        /// The new model description.
        public let description: String?
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum

        public init(description: String? = nil, modelId: String, modelType: ModelTypeEnum) {
            self.description = description
            self.modelId = modelId
            self.modelType = modelType
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case modelId
            case modelType
        }
    }

    public struct UpdateModelResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateModelVersionRequest: AWSEncodableShape {
        /// The details of the external events data used for training the model version. Required if trainingDataSource is EXTERNAL_EVENTS.
        public let externalEventsDetail: ExternalEventsDetail?
        /// The details of the ingested event used for training the model version. Required if your trainingDataSource is INGESTED_EVENTS.
        public let ingestedEventsDetail: IngestedEventsDetail?
        /// The major version number.
        public let majorVersionNumber: String
        /// The model ID.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// A collection of key and value pairs.
        public let tags: [Tag]?

        public init(externalEventsDetail: ExternalEventsDetail? = nil, ingestedEventsDetail: IngestedEventsDetail? = nil, majorVersionNumber: String, modelId: String, modelType: ModelTypeEnum, tags: [Tag]? = nil) {
            self.externalEventsDetail = externalEventsDetail
            self.ingestedEventsDetail = ingestedEventsDetail
            self.majorVersionNumber = majorVersionNumber
            self.modelId = modelId
            self.modelType = modelType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.externalEventsDetail?.validate(name: "\(name).externalEventsDetail")
            try self.ingestedEventsDetail?.validate(name: "\(name).ingestedEventsDetail")
            try self.validate(self.majorVersionNumber, name: "majorVersionNumber", parent: name, max: 5)
            try self.validate(self.majorVersionNumber, name: "majorVersionNumber", parent: name, min: 1)
            try self.validate(self.majorVersionNumber, name: "majorVersionNumber", parent: name, pattern: "^([1-9][0-9]*)$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case externalEventsDetail
            case ingestedEventsDetail
            case majorVersionNumber
            case modelId
            case modelType
            case tags
        }
    }

    public struct UpdateModelVersionResult: AWSDecodableShape {
        /// The model ID.
        public let modelId: String?
        /// The model type.
        public let modelType: ModelTypeEnum?
        /// The model version number of the model version updated.
        public let modelVersionNumber: String?
        /// The status of the updated model version.
        public let status: String?

        public init(modelId: String? = nil, modelType: ModelTypeEnum? = nil, modelVersionNumber: String? = nil, status: String? = nil) {
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case modelId
            case modelType
            case modelVersionNumber
            case status
        }
    }

    public struct UpdateModelVersionStatusRequest: AWSEncodableShape {
        /// The model ID of the model version to update.
        public let modelId: String
        /// The model type.
        public let modelType: ModelTypeEnum
        /// The model version number.
        public let modelVersionNumber: String
        /// The model version status.
        public let status: ModelVersionStatus

        public init(modelId: String, modelType: ModelTypeEnum, modelVersionNumber: String, status: ModelVersionStatus) {
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.modelId, name: "modelId", parent: name, max: 64)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[0-9a-z_]+$")
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, max: 7)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, min: 3)
            try self.validate(self.modelVersionNumber, name: "modelVersionNumber", parent: name, pattern: "^[1-9][0-9]{0,3}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelId
            case modelType
            case modelVersionNumber
            case status
        }
    }

    public struct UpdateModelVersionStatusResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRuleMetadataRequest: AWSEncodableShape {
        /// The rule description.
        public let description: String
        /// The rule to update.
        public let rule: Rule

        public init(description: String, rule: Rule) {
            self.description = description
            self.rule = rule
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.rule.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case rule
        }
    }

    public struct UpdateRuleMetadataResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRuleVersionRequest: AWSEncodableShape {
        /// The description.
        public let description: String?
        /// The rule expression.
        public let expression: String
        /// The language.
        public let language: Language
        /// The outcomes.
        public let outcomes: [String]
        /// The rule to update.
        public let rule: Rule
        /// The tags to assign to the rule version.
        public let tags: [Tag]?

        public init(description: String? = nil, expression: String, language: Language, outcomes: [String], rule: Rule, tags: [Tag]? = nil) {
            self.description = description
            self.expression = expression
            self.language = language
            self.outcomes = outcomes
            self.rule = rule
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.outcomes, name: "outcomes", parent: name, min: 1)
            try self.rule.validate(name: "\(name).rule")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case expression
            case language
            case outcomes
            case rule
            case tags
        }
    }

    public struct UpdateRuleVersionResult: AWSDecodableShape {
        /// The new rule version that was created.
        public let rule: Rule?

        public init(rule: Rule? = nil) {
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case rule
        }
    }

    public struct UpdateVariableRequest: AWSEncodableShape {
        /// The new default value of the variable.
        public let defaultValue: String?
        /// The new description.
        public let description: String?
        /// The name of the variable.
        public let name: String
        /// The variable type. For more information see Variable types.
        public let variableType: String?

        public init(defaultValue: String? = nil, description: String? = nil, name: String, variableType: String? = nil) {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.variableType = variableType
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue
            case description
            case name
            case variableType
        }
    }

    public struct UpdateVariableResult: AWSDecodableShape {
        public init() {}
    }

    public struct Variable: AWSDecodableShape {
        /// The ARN of the variable.
        public let arn: String?
        /// The time when the variable was created.
        public let createdTime: String?
        /// The data source of the variable.
        public let dataSource: DataSource?
        /// The data type of the variable. For more information see Variable types.
        public let dataType: DataType?
        /// The default value of the variable.
        public let defaultValue: String?
        /// The description of the variable.
        public let description: String?
        /// The time when variable was last updated.
        public let lastUpdatedTime: String?
        /// The name of the variable.
        public let name: String?
        /// The variable type of the variable. Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        public let variableType: String?

        public init(arn: String? = nil, createdTime: String? = nil, dataSource: DataSource? = nil, dataType: DataType? = nil, defaultValue: String? = nil, description: String? = nil, lastUpdatedTime: String? = nil, name: String? = nil, variableType: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.variableType = variableType
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdTime
            case dataSource
            case dataType
            case defaultValue
            case description
            case lastUpdatedTime
            case name
            case variableType
        }
    }

    public struct VariableEntry: AWSEncodableShape {
        /// The data source of the variable.
        public let dataSource: String?
        /// The data type of the variable.
        public let dataType: String?
        /// The default value of the variable.
        public let defaultValue: String?
        /// The description of the variable.
        public let description: String?
        /// The name of the variable.
        public let name: String?
        /// The type of the variable. For more information see Variable types. Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        public let variableType: String?

        public init(dataSource: String? = nil, dataType: String? = nil, defaultValue: String? = nil, description: String? = nil, name: String? = nil, variableType: String? = nil) {
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.variableType = variableType
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource
            case dataType
            case defaultValue
            case description
            case name
            case variableType
        }
    }

    public struct VariableImpactExplanation: AWSDecodableShape {
        /// The event variable name.
        public let eventVariableName: String?
        ///  The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from - infinity to + infinity.   A positive value indicates that the variable drove the risk score up.   A negative value indicates that the variable drove the risk score down.
        public let logOddsImpact: Float?
        ///  The event variable's relative impact in terms of magnitude on the prediction scores.  The relative impact values consist of a numerical rating (0-5, 5 being the highest) and direction (increased/decreased) impact of the fraud risk.
        public let relativeImpact: String?

        public init(eventVariableName: String? = nil, logOddsImpact: Float? = nil, relativeImpact: String? = nil) {
            self.eventVariableName = eventVariableName
            self.logOddsImpact = logOddsImpact
            self.relativeImpact = relativeImpact
        }

        private enum CodingKeys: String, CodingKey {
            case eventVariableName
            case logOddsImpact
            case relativeImpact
        }
    }

    public struct VariableImportanceMetrics: AWSDecodableShape {
        /// List of variable metrics.
        public let logOddsMetrics: [LogOddsMetric]?

        public init(logOddsMetrics: [LogOddsMetric]? = nil) {
            self.logOddsMetrics = logOddsMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case logOddsMetrics
        }
    }
}
