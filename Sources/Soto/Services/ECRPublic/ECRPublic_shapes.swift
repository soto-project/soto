//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ECRPublic {
    // MARK: Enums

    public enum ImageFailureCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case imageNotFound = "ImageNotFound"
        case imageReferencedByManifestList = "ImageReferencedByManifestList"
        case imageTagDoesNotMatchDigest = "ImageTagDoesNotMatchDigest"
        case invalidImageDigest = "InvalidImageDigest"
        case invalidImageTag = "InvalidImageTag"
        case kmsError = "KmsError"
        case missingDigestAndTag = "MissingDigestAndTag"
        public var description: String { return self.rawValue }
    }

    public enum LayerAvailability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case unavailable = "UNAVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum LayerFailureCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case invalidLayerDigest = "InvalidLayerDigest"
        case missingLayerDigest = "MissingLayerDigest"
        public var description: String { return self.rawValue }
    }

    public enum RegistryAliasStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AuthorizationData: AWSDecodableShape {
        /// A base64-encoded string that contains authorization data for a public Amazon ECR registry. When the string is decoded, it's presented in the format user:password for public registry authentication using docker login.
        public let authorizationToken: String?
        /// The Unix time in seconds and milliseconds when the authorization token expires. Authorization tokens are valid for 12 hours.
        public let expiresAt: Date?

        public init(authorizationToken: String? = nil, expiresAt: Date? = nil) {
            self.authorizationToken = authorizationToken
            self.expiresAt = expiresAt
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationToken = "authorizationToken"
            case expiresAt = "expiresAt"
        }
    }

    public struct BatchCheckLayerAvailabilityRequest: AWSEncodableShape {
        /// The digests of the image layers to check.
        public let layerDigests: [String]
        /// The Amazon Web Services account ID, or registry alias, associated with the public registry that contains the image layers to check. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository that's associated with the image layers to check.
        public let repositoryName: String

        public init(layerDigests: [String], registryId: String? = nil, repositoryName: String) {
            self.layerDigests = layerDigests
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.layerDigests.forEach {
                try validate($0, name: "layerDigests[]", parent: name, max: 1000)
            }
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, max: 100)
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, max: 50)
            try self.validate(self.registryId, name: "registryId", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigests = "layerDigests"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct BatchCheckLayerAvailabilityResponse: AWSDecodableShape {
        /// Any failures associated with the call.
        public let failures: [LayerFailure]?
        /// A list of image layer objects that correspond to the image layer references in the request.
        public let layers: [Layer]?

        public init(failures: [LayerFailure]? = nil, layers: [Layer]? = nil) {
            self.failures = failures
            self.layers = layers
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "failures"
            case layers = "layers"
        }
    }

    public struct BatchDeleteImageRequest: AWSEncodableShape {
        /// A list of image ID references that correspond to images to delete. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
        public let imageIds: [ImageIdentifier]
        /// The Amazon Web Services account ID, or registry alias, that's associated with the registry that contains the image to delete. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The repository in a public registry that contains the image to delete.
        public let repositoryName: String

        public init(imageIds: [ImageIdentifier], registryId: String? = nil, repositoryName: String) {
            self.imageIds = imageIds
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageIds.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, max: 50)
            try self.validate(self.registryId, name: "registryId", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageIds = "imageIds"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct BatchDeleteImageResponse: AWSDecodableShape {
        /// Any failures associated with the call.
        public let failures: [ImageFailure]?
        /// The image IDs of the deleted images.
        public let imageIds: [ImageIdentifier]?

        public init(failures: [ImageFailure]? = nil, imageIds: [ImageIdentifier]? = nil) {
            self.failures = failures
            self.imageIds = imageIds
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "failures"
            case imageIds = "imageIds"
        }
    }

    public struct CompleteLayerUploadRequest: AWSEncodableShape {
        /// The sha256 digest of the image layer.
        public let layerDigests: [String]
        /// The Amazon Web Services account ID, or registry alias, associated with the registry where layers are uploaded. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository in a public registry to associate with the image layer.
        public let repositoryName: String
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the image layer.
        public let uploadId: String

        public init(layerDigests: [String], registryId: String? = nil, repositoryName: String, uploadId: String) {
            self.layerDigests = layerDigests
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        public func validate(name: String) throws {
            try self.layerDigests.forEach {
                try validate($0, name: "layerDigests[]", parent: name, pattern: "^[a-zA-Z0-9-_+.]+:[a-fA-F0-9]+$")
            }
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, max: 100)
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, max: 50)
            try self.validate(self.registryId, name: "registryId", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigests = "layerDigests"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case uploadId = "uploadId"
        }
    }

    public struct CompleteLayerUploadResponse: AWSDecodableShape {
        /// The sha256 digest of the image layer.
        public let layerDigest: String?
        /// The public registry ID that's associated with the request.
        public let registryId: String?
        /// The repository name that's associated with the request.
        public let repositoryName: String?
        /// The upload ID that's associated with the layer.
        public let uploadId: String?

        public init(layerDigest: String? = nil, registryId: String? = nil, repositoryName: String? = nil, uploadId: String? = nil) {
            self.layerDigest = layerDigest
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigest = "layerDigest"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case uploadId = "uploadId"
        }
    }

    public struct CreateRepositoryRequest: AWSEncodableShape {
        /// The details about the repository that are publicly visible in the Amazon ECR Public Gallery.
        public let catalogData: RepositoryCatalogDataInput?
        /// The name to use for the repository. This appears publicly in the Amazon ECR Public Gallery. The repository name can be specified on its own (for example nginx-web-app) or prepended with a namespace to group the repository into a category (for example project-a/nginx-web-app).
        public let repositoryName: String
        /// The metadata that you apply to each repository to help categorize and organize your repositories. Each tag consists of a key and an optional value. You define both of them. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [Tag]?

        public init(catalogData: RepositoryCatalogDataInput? = nil, repositoryName: String, tags: [Tag]? = nil) {
            self.catalogData = catalogData
            self.repositoryName = repositoryName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.catalogData?.validate(name: "\(name).catalogData")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogData = "catalogData"
            case repositoryName = "repositoryName"
            case tags = "tags"
        }
    }

    public struct CreateRepositoryResponse: AWSDecodableShape {
        public let catalogData: RepositoryCatalogData?
        /// The repository that was created.
        public let repository: Repository?

        public init(catalogData: RepositoryCatalogData? = nil, repository: Repository? = nil) {
            self.catalogData = catalogData
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case catalogData = "catalogData"
            case repository = "repository"
        }
    }

    public struct DeleteRepositoryPolicyRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID that's associated with the public registry that contains the repository policy to delete. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository that's associated with the repository policy to delete.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DeleteRepositoryPolicyResponse: AWSDecodableShape {
        /// The JSON repository policy that was deleted from the repository.
        public let policyText: String?
        /// The registry ID that's associated with the request.
        public let registryId: String?
        /// The repository name that's associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DeleteRepositoryRequest: AWSEncodableShape {
        ///  The force option can be used to delete a repository that contains images. If the force option is not used, the repository must be empty prior to deletion.
        public let force: Bool?
        /// The Amazon Web Services account ID that's associated with the public registry that contains the repository to delete. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository to delete.
        public let repositoryName: String

        public init(force: Bool? = nil, registryId: String? = nil, repositoryName: String) {
            self.force = force
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case force = "force"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DeleteRepositoryResponse: AWSDecodableShape {
        /// The repository that was deleted.
        public let repository: Repository?

        public init(repository: Repository? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct DescribeImageTagsRequest: AWSEncodableShape {
        /// The maximum number of repository results that's returned by DescribeImageTags in paginated output. When this parameter is used, DescribeImageTags only returns maxResults results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another DescribeImageTags request with the returned nextToken value. This value can be between 1 and 1000. If this parameter isn't used, then DescribeImageTags returns up to 100 results and a nextToken value, if applicable. If you specify images with imageIds, you can't use this option.
        public let maxResults: Int?
        /// The nextToken value that's returned from a previous paginated DescribeImageTags request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. If there are no more results to return, this value is null. If you specify images with imageIds, you can't use this option.
        public let nextToken: String?
        /// The Amazon Web Services account ID that's associated with the public registry that contains the repository where images are described. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository that contains the image tag details to describe.
        public let repositoryName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DescribeImageTagsResponse: AWSDecodableShape {
        /// The image tag details for the images in the requested repository.
        public let imageTagDetails: [ImageTagDetail]?
        /// The nextToken value to include in a future DescribeImageTags request. When the results of a DescribeImageTags request exceed maxResults, you can use this value to retrieve the next page of results. If there are no more results to return, this value is null.
        public let nextToken: String?

        public init(imageTagDetails: [ImageTagDetail]? = nil, nextToken: String? = nil) {
            self.imageTagDetails = imageTagDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case imageTagDetails = "imageTagDetails"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeImagesRequest: AWSEncodableShape {
        /// The list of image IDs for the requested repository.
        public let imageIds: [ImageIdentifier]?
        /// The maximum number of repository results that's returned by DescribeImages in paginated output. When this parameter is used, DescribeImages only returns maxResults results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another DescribeImages request with the returned nextToken value. This value can be between 1 and 1000. If this parameter isn't used, then DescribeImages returns up to 100 results and a nextToken value, if applicable. If you specify images with imageIds, you can't use this option.
        public let maxResults: Int?
        /// The nextToken value that's returned from a previous paginated DescribeImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. If there are no more results to return, this value is null. If you specify images with imageIds, you can't use this option.
        public let nextToken: String?
        /// The Amazon Web Services account ID that's associated with the public registry that contains the repository where images are described. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The repository that contains the images to describe.
        public let repositoryName: String

        public init(imageIds: [ImageIdentifier]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.imageIds = imageIds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageIds?.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageIds = "imageIds"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DescribeImagesResponse: AWSDecodableShape {
        /// A list of ImageDetail objects that contain data about the image.
        public let imageDetails: [ImageDetail]?
        /// The nextToken value to include in a future DescribeImages request. When the results of a DescribeImages request exceed maxResults, you can use this value to retrieve the next page of results. If there are no more results to return, this value is null.
        public let nextToken: String?

        public init(imageDetails: [ImageDetail]? = nil, nextToken: String? = nil) {
            self.imageDetails = imageDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case imageDetails = "imageDetails"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeRegistriesRequest: AWSEncodableShape {
        /// The maximum number of repository results that's returned by DescribeRegistries in paginated output. When this parameter is used, DescribeRegistries only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeRegistries request with the returned nextToken value. This value can be between 1 and 1000. If this parameter isn't used, then DescribeRegistries returns up to 100 results and a nextToken value, if applicable.
        public let maxResults: Int?
        /// The nextToken value that's returned from a previous paginated DescribeRegistries request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. If there are no more results to return, this value is null.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeRegistriesResponse: AWSDecodableShape {
        /// The nextToken value to include in a future DescribeRepositories request. If the results of a DescribeRepositories request exceed maxResults, you can use this value to retrieve the next page of results. If there are no more results, this value is null.
        public let nextToken: String?
        /// An object that contains the details for a public registry.
        public let registries: [Registry]

        public init(nextToken: String? = nil, registries: [Registry]) {
            self.nextToken = nextToken
            self.registries = registries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case registries = "registries"
        }
    }

    public struct DescribeRepositoriesRequest: AWSEncodableShape {
        /// The maximum number of repository results that's returned by DescribeRepositories in paginated output. When this parameter is used, DescribeRepositories only returns maxResults results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another DescribeRepositories request with the returned nextToken value. This value can be between 1 and 1000. If this parameter isn't used, then DescribeRepositories returns up to 100 results and a nextToken value, if applicable. If you specify repositories with repositoryNames, you can't use this option.
        public let maxResults: Int?
        /// The nextToken value that's returned from a previous paginated DescribeRepositories request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. If there are no more results to return, this value is null. If you specify repositories with repositoryNames, you can't use this option.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?
        /// The Amazon Web Services account ID that's associated with the registry that contains the repositories to be described. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// A list of repositories to describe. If this parameter is omitted, then all repositories in a registry are described.
        public let repositoryNames: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryNames: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryNames = repositoryNames
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.repositoryNames?.forEach {
                try validate($0, name: "repositoryNames[]", parent: name, max: 205)
                try validate($0, name: "repositoryNames[]", parent: name, min: 2)
                try validate($0, name: "repositoryNames[]", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
            }
            try self.validate(self.repositoryNames, name: "repositoryNames", parent: name, max: 100)
            try self.validate(self.repositoryNames, name: "repositoryNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case registryId = "registryId"
            case repositoryNames = "repositoryNames"
        }
    }

    public struct DescribeRepositoriesResponse: AWSDecodableShape {
        /// The nextToken value to include in a future DescribeRepositories request. When the results of a DescribeRepositories request exceed maxResults, this value can be used to retrieve the next page of results. If there are no more results to return, this value is null.
        public let nextToken: String?
        /// A list of repository objects corresponding to valid repositories.
        public let repositories: [Repository]?

        public init(nextToken: String? = nil, repositories: [Repository]? = nil) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case repositories = "repositories"
        }
    }

    public struct GetAuthorizationTokenRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAuthorizationTokenResponse: AWSDecodableShape {
        /// An authorization token data object that corresponds to a public registry.
        public let authorizationData: AuthorizationData?

        public init(authorizationData: AuthorizationData? = nil) {
            self.authorizationData = authorizationData
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationData = "authorizationData"
        }
    }

    public struct GetRegistryCatalogDataRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetRegistryCatalogDataResponse: AWSDecodableShape {
        /// The catalog metadata for the public registry.
        public let registryCatalogData: RegistryCatalogData

        public init(registryCatalogData: RegistryCatalogData) {
            self.registryCatalogData = registryCatalogData
        }

        private enum CodingKeys: String, CodingKey {
            case registryCatalogData = "registryCatalogData"
        }
    }

    public struct GetRepositoryCatalogDataRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID that's associated with the registry that contains the repositories to be described. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository to retrieve the catalog metadata for.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct GetRepositoryCatalogDataResponse: AWSDecodableShape {
        /// The catalog metadata for the repository.
        public let catalogData: RepositoryCatalogData?

        public init(catalogData: RepositoryCatalogData? = nil) {
            self.catalogData = catalogData
        }

        private enum CodingKeys: String, CodingKey {
            case catalogData = "catalogData"
        }
    }

    public struct GetRepositoryPolicyRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID that's associated with the public registry that contains the repository. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository with the policy to retrieve.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct GetRepositoryPolicyResponse: AWSDecodableShape {
        /// The repository policy text that's associated with the repository. The policy text will be in JSON format.
        public let policyText: String?
        /// The registry ID that's associated with the request.
        public let registryId: String?
        /// The repository name that's associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct Image: AWSDecodableShape {
        /// An object that contains the image tag and image digest associated with an image.
        public let imageId: ImageIdentifier?
        /// The image manifest that's associated with the image.
        public let imageManifest: String?
        /// The manifest media type of the image.
        public let imageManifestMediaType: String?
        /// The Amazon Web Services account ID that's associated with the registry containing the image.
        public let registryId: String?
        /// The name of the repository that's associated with the image.
        public let repositoryName: String?

        public init(imageId: ImageIdentifier? = nil, imageManifest: String? = nil, imageManifestMediaType: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageId = imageId
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "imageId"
            case imageManifest = "imageManifest"
            case imageManifestMediaType = "imageManifestMediaType"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct ImageDetail: AWSDecodableShape {
        /// The artifact media type of the image.
        public let artifactMediaType: String?
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The media type of the image manifest.
        public let imageManifestMediaType: String?
        /// The date and time, expressed in standard JavaScript date format, that the current image was pushed to the repository at.
        public let imagePushedAt: Date?
        /// The size, in bytes, of the image in the repository. If the image is a manifest list, this is the max size of all manifests in the list.  Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the docker images command shows the uncompressed image size, so it might return a larger image size than the image sizes that are returned by DescribeImages.
        public let imageSizeInBytes: Int64?
        /// The list of tags that's associated with this image.
        public let imageTags: [String]?
        /// The Amazon Web Services account ID that's associated with the public registry where this image belongs.
        public let registryId: String?
        /// The name of the repository where this image belongs.
        public let repositoryName: String?

        public init(artifactMediaType: String? = nil, imageDigest: String? = nil, imageManifestMediaType: String? = nil, imagePushedAt: Date? = nil, imageSizeInBytes: Int64? = nil, imageTags: [String]? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageSizeInBytes = imageSizeInBytes
            self.imageTags = imageTags
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case artifactMediaType = "artifactMediaType"
            case imageDigest = "imageDigest"
            case imageManifestMediaType = "imageManifestMediaType"
            case imagePushedAt = "imagePushedAt"
            case imageSizeInBytes = "imageSizeInBytes"
            case imageTags = "imageTags"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct ImageFailure: AWSDecodableShape {
        /// The code that's associated with the failure.
        public let failureCode: ImageFailureCode?
        /// The reason for the failure.
        public let failureReason: String?
        /// The image ID that's associated with the failure.
        public let imageId: ImageIdentifier?

        public init(failureCode: ImageFailureCode? = nil, failureReason: String? = nil, imageId: ImageIdentifier? = nil) {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.imageId = imageId
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case imageId = "imageId"
        }
    }

    public struct ImageIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The tag that's used for the image.
        public let imageTag: String?

        public init(imageDigest: String? = nil, imageTag: String? = nil) {
            self.imageDigest = imageDigest
            self.imageTag = imageTag
        }

        public func validate(name: String) throws {
            try self.validate(self.imageTag, name: "imageTag", parent: name, max: 300)
            try self.validate(self.imageTag, name: "imageTag", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageDigest = "imageDigest"
            case imageTag = "imageTag"
        }
    }

    public struct ImageTagDetail: AWSDecodableShape {
        /// The time stamp that indicates when the image tag was created.
        public let createdAt: Date?
        /// An object that describes the details of an image.
        public let imageDetail: ReferencedImageDetail?
        /// The tag that's associated with the image.
        public let imageTag: String?

        public init(createdAt: Date? = nil, imageDetail: ReferencedImageDetail? = nil, imageTag: String? = nil) {
            self.createdAt = createdAt
            self.imageDetail = imageDetail
            self.imageTag = imageTag
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case imageDetail = "imageDetail"
            case imageTag = "imageTag"
        }
    }

    public struct InitiateLayerUploadRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID, or registry alias, that's associated with the registry to which you intend to upload layers. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository that you want to upload layers to.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, max: 50)
            try self.validate(self.registryId, name: "registryId", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct InitiateLayerUploadResponse: AWSDecodableShape {
        /// The size, in bytes, that Amazon ECR expects future layer part uploads to be.
        public let partSize: Int64?
        /// The upload ID for the layer upload. This parameter is passed to further UploadLayerPart and CompleteLayerUpload operations.
        public let uploadId: String?

        public init(partSize: Int64? = nil, uploadId: String? = nil) {
            self.partSize = partSize
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case partSize = "partSize"
            case uploadId = "uploadId"
        }
    }

    public struct Layer: AWSDecodableShape {
        /// The availability status of the image layer.
        public let layerAvailability: LayerAvailability?
        /// The sha256 digest of the image layer.
        public let layerDigest: String?
        /// The size, in bytes, of the image layer.
        public let layerSize: Int64?
        /// The media type of the layer, such as application/vnd.docker.image.rootfs.diff.tar.gzip or application/vnd.oci.image.layer.v1.tar+gzip.
        public let mediaType: String?

        public init(layerAvailability: LayerAvailability? = nil, layerDigest: String? = nil, layerSize: Int64? = nil, mediaType: String? = nil) {
            self.layerAvailability = layerAvailability
            self.layerDigest = layerDigest
            self.layerSize = layerSize
            self.mediaType = mediaType
        }

        private enum CodingKeys: String, CodingKey {
            case layerAvailability = "layerAvailability"
            case layerDigest = "layerDigest"
            case layerSize = "layerSize"
            case mediaType = "mediaType"
        }
    }

    public struct LayerFailure: AWSDecodableShape {
        /// The failure code that's associated with the failure.
        public let failureCode: LayerFailureCode?
        /// The reason for the failure.
        public let failureReason: String?
        /// The layer digest that's associated with the failure.
        public let layerDigest: String?

        public init(failureCode: LayerFailureCode? = nil, failureReason: String? = nil, layerDigest: String? = nil) {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.layerDigest = layerDigest
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case layerDigest = "layerDigest"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for. Currently, the supported resource is an Amazon ECR Public repository.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct PutImageRequest: AWSEncodableShape {
        /// The image digest of the image manifest that corresponds to the image.
        public let imageDigest: String?
        /// The image manifest that corresponds to the image to be uploaded.
        public let imageManifest: String
        /// The media type of the image manifest. If you push an image manifest that doesn't contain the mediaType field, you must specify the imageManifestMediaType in the request.
        public let imageManifestMediaType: String?
        /// The tag to associate with the image. This parameter is required for images that use the Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.
        public let imageTag: String?
        /// The Amazon Web Services account ID, or registry alias, that's associated with the public registry that contains the repository where the image is put. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository where the image is put.
        public let repositoryName: String

        public init(imageDigest: String? = nil, imageManifest: String, imageManifestMediaType: String? = nil, imageTag: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.imageDigest = imageDigest
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.imageTag = imageTag
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.imageManifest, name: "imageManifest", parent: name, max: 4194304)
            try self.validate(self.imageManifest, name: "imageManifest", parent: name, min: 1)
            try self.validate(self.imageTag, name: "imageTag", parent: name, max: 300)
            try self.validate(self.imageTag, name: "imageTag", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, max: 50)
            try self.validate(self.registryId, name: "registryId", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageDigest = "imageDigest"
            case imageManifest = "imageManifest"
            case imageManifestMediaType = "imageManifestMediaType"
            case imageTag = "imageTag"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct PutImageResponse: AWSDecodableShape {
        /// Details of the image uploaded.
        public let image: Image?

        public init(image: Image? = nil) {
            self.image = image
        }

        private enum CodingKeys: String, CodingKey {
            case image = "image"
        }
    }

    public struct PutRegistryCatalogDataRequest: AWSEncodableShape {
        /// The display name for a public registry. The display name is shown as the repository author in the Amazon ECR Public Gallery.  The registry display name is only publicly visible in the Amazon ECR Public Gallery for verified accounts.
        public let displayName: String?

        public init(displayName: String? = nil) {
            self.displayName = displayName
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
        }
    }

    public struct PutRegistryCatalogDataResponse: AWSDecodableShape {
        /// The catalog data for the public registry.
        public let registryCatalogData: RegistryCatalogData

        public init(registryCatalogData: RegistryCatalogData) {
            self.registryCatalogData = registryCatalogData
        }

        private enum CodingKeys: String, CodingKey {
            case registryCatalogData = "registryCatalogData"
        }
    }

    public struct PutRepositoryCatalogDataRequest: AWSEncodableShape {
        /// An object containing the catalog data for a repository. This data is publicly visible in the Amazon ECR Public Gallery.
        public let catalogData: RepositoryCatalogDataInput
        /// The Amazon Web Services account ID that's associated with the public registry the repository is in. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository to create or update the catalog data for.
        public let repositoryName: String

        public init(catalogData: RepositoryCatalogDataInput, registryId: String? = nil, repositoryName: String) {
            self.catalogData = catalogData
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.catalogData.validate(name: "\(name).catalogData")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogData = "catalogData"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct PutRepositoryCatalogDataResponse: AWSDecodableShape {
        /// The catalog data for the repository.
        public let catalogData: RepositoryCatalogData?

        public init(catalogData: RepositoryCatalogData? = nil) {
            self.catalogData = catalogData
        }

        private enum CodingKeys: String, CodingKey {
            case catalogData = "catalogData"
        }
    }

    public struct ReferencedImageDetail: AWSDecodableShape {
        /// The artifact media type of the image.
        public let artifactMediaType: String?
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The media type of the image manifest.
        public let imageManifestMediaType: String?
        /// The date and time, expressed in standard JavaScript date format, which the current image tag was pushed to the repository at.
        public let imagePushedAt: Date?
        /// The size, in bytes, of the image in the repository. If the image is a manifest list, this is the max size of all manifests in the list.  Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the docker images command shows the uncompressed image size, so it might return a larger image size than the image sizes that are returned by DescribeImages.
        public let imageSizeInBytes: Int64?

        public init(artifactMediaType: String? = nil, imageDigest: String? = nil, imageManifestMediaType: String? = nil, imagePushedAt: Date? = nil, imageSizeInBytes: Int64? = nil) {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageSizeInBytes = imageSizeInBytes
        }

        private enum CodingKeys: String, CodingKey {
            case artifactMediaType = "artifactMediaType"
            case imageDigest = "imageDigest"
            case imageManifestMediaType = "imageManifestMediaType"
            case imagePushedAt = "imagePushedAt"
            case imageSizeInBytes = "imageSizeInBytes"
        }
    }

    public struct Registry: AWSDecodableShape {
        /// An array of objects that represents the aliases for a public registry.
        public let aliases: [RegistryAlias]
        /// The Amazon Resource Name (ARN) of the public registry.
        public let registryArn: String
        /// The Amazon Web Services account ID that's associated with the registry. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String
        /// The URI of a public registry. The URI contains a universal prefix and the registry alias.
        public let registryUri: String
        /// Indicates whether the account is a verified Amazon Web Services Marketplace vendor. If an account is verified, each public repository receives a verified account badge on the Amazon ECR Public Gallery.
        public let verified: Bool

        public init(aliases: [RegistryAlias], registryArn: String, registryId: String, registryUri: String, verified: Bool) {
            self.aliases = aliases
            self.registryArn = registryArn
            self.registryId = registryId
            self.registryUri = registryUri
            self.verified = verified
        }

        private enum CodingKeys: String, CodingKey {
            case aliases = "aliases"
            case registryArn = "registryArn"
            case registryId = "registryId"
            case registryUri = "registryUri"
            case verified = "verified"
        }
    }

    public struct RegistryAlias: AWSDecodableShape {
        /// Indicates whether the registry alias is the default alias for the registry. When the first public repository is created, your public registry is assigned a default registry alias.
        public let defaultRegistryAlias: Bool
        /// The name of the registry alias.
        public let name: String
        /// Indicates whether the registry alias is the primary alias for the registry. If true, the alias is the primary registry alias and is displayed in both the repository URL and the image URI used in the docker pull commands on the Amazon ECR Public Gallery.  A registry alias that isn't the primary registry alias can be used in the repository URI in a docker pull command.
        public let primaryRegistryAlias: Bool
        /// The status of the registry alias.
        public let status: RegistryAliasStatus

        public init(defaultRegistryAlias: Bool, name: String, primaryRegistryAlias: Bool, status: RegistryAliasStatus) {
            self.defaultRegistryAlias = defaultRegistryAlias
            self.name = name
            self.primaryRegistryAlias = primaryRegistryAlias
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case defaultRegistryAlias = "defaultRegistryAlias"
            case name = "name"
            case primaryRegistryAlias = "primaryRegistryAlias"
            case status = "status"
        }
    }

    public struct RegistryCatalogData: AWSDecodableShape {
        /// The display name for a public registry. This appears on the Amazon ECR Public Gallery.  Only accounts that have the verified account badge can have a registry display name.
        public let displayName: String?

        public init(displayName: String? = nil) {
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
        }
    }

    public struct Repository: AWSDecodableShape {
        /// The date and time, in JavaScript date format, when the repository was created.
        public let createdAt: Date?
        /// The Amazon Web Services account ID that's associated with the public registry that contains the repository.
        public let registryId: String?
        /// The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the arn:aws:ecr namespace, followed by the region of the repository, Amazon Web Services account ID of the repository owner, repository namespace, and repository name. For example, arn:aws:ecr:region:012345678910:repository/test.
        public let repositoryArn: String?
        /// The name of the repository.
        public let repositoryName: String?
        /// The URI for the repository. You can use this URI for container image push and pull operations.
        public let repositoryUri: String?

        public init(createdAt: Date? = nil, registryId: String? = nil, repositoryArn: String? = nil, repositoryName: String? = nil, repositoryUri: String? = nil) {
            self.createdAt = createdAt
            self.registryId = registryId
            self.repositoryArn = repositoryArn
            self.repositoryName = repositoryName
            self.repositoryUri = repositoryUri
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case registryId = "registryId"
            case repositoryArn = "repositoryArn"
            case repositoryName = "repositoryName"
            case repositoryUri = "repositoryUri"
        }
    }

    public struct RepositoryCatalogData: AWSDecodableShape {
        /// The longform description of the contents of the repository. This text appears in the repository details on the Amazon ECR Public Gallery.
        public let aboutText: String?
        /// The architecture tags that are associated with the repository.  Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For more information, see RepositoryCatalogDataInput.
        public let architectures: [String]?
        /// The short description of the repository.
        public let description: String?
        /// The URL that contains the logo that's associated with the repository.
        public let logoUrl: String?
        /// Indicates whether the repository is certified by Amazon Web Services Marketplace.
        public let marketplaceCertified: Bool?
        /// The operating system tags that are associated with the repository.  Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For more information, see RepositoryCatalogDataInput.
        public let operatingSystems: [String]?
        /// The longform usage details of the contents of the repository. The usage text provides context for users of the repository.
        public let usageText: String?

        public init(aboutText: String? = nil, architectures: [String]? = nil, description: String? = nil, logoUrl: String? = nil, marketplaceCertified: Bool? = nil, operatingSystems: [String]? = nil, usageText: String? = nil) {
            self.aboutText = aboutText
            self.architectures = architectures
            self.description = description
            self.logoUrl = logoUrl
            self.marketplaceCertified = marketplaceCertified
            self.operatingSystems = operatingSystems
            self.usageText = usageText
        }

        private enum CodingKeys: String, CodingKey {
            case aboutText = "aboutText"
            case architectures = "architectures"
            case description = "description"
            case logoUrl = "logoUrl"
            case marketplaceCertified = "marketplaceCertified"
            case operatingSystems = "operatingSystems"
            case usageText = "usageText"
        }
    }

    public struct RepositoryCatalogDataInput: AWSEncodableShape {
        /// A detailed description of the contents of the repository. It's publicly visible in the Amazon ECR Public Gallery. The text must be in markdown format.
        public let aboutText: String?
        /// The system architecture that the images in the repository are compatible with. On the Amazon ECR Public Gallery, the following supported architectures appear as badges on the repository and are used as search filters.  If an unsupported tag is added to your repository catalog data, it's associated with the repository and can be retrieved using the API but isn't discoverable in the Amazon ECR Public Gallery.     ARM     ARM 64     x86     x86-64
        public let architectures: [String]?
        /// A short description of the contents of the repository. This text appears in both the image details and also when searching for repositories on the Amazon ECR Public Gallery.
        public let description: String?
        /// The base64-encoded repository logo payload.  The repository logo is only publicly visible in the Amazon ECR Public Gallery for verified accounts.
        public let logoImageBlob: AWSBase64Data?
        /// The operating systems that the images in the repository are compatible with. On the Amazon ECR Public Gallery, the following supported operating systems appear as badges on the repository and are used as search filters.  If an unsupported tag is added to your repository catalog data, it's associated with the repository and can be retrieved using the API but isn't discoverable in the Amazon ECR Public Gallery.     Linux     Windows
        public let operatingSystems: [String]?
        /// Detailed information about how to use the contents of the repository. It's publicly visible in the Amazon ECR Public Gallery. The usage text provides context, support information, and additional usage details for users of the repository. The text must be in markdown format.
        public let usageText: String?

        public init(aboutText: String? = nil, architectures: [String]? = nil, description: String? = nil, logoImageBlob: AWSBase64Data? = nil, operatingSystems: [String]? = nil, usageText: String? = nil) {
            self.aboutText = aboutText
            self.architectures = architectures
            self.description = description
            self.logoImageBlob = logoImageBlob
            self.operatingSystems = operatingSystems
            self.usageText = usageText
        }

        public func validate(name: String) throws {
            try self.validate(self.aboutText, name: "aboutText", parent: name, max: 25600)
            try self.architectures?.forEach {
                try validate($0, name: "architectures[]", parent: name, max: 50)
                try validate($0, name: "architectures[]", parent: name, min: 1)
            }
            try self.validate(self.architectures, name: "architectures", parent: name, max: 50)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.logoImageBlob, name: "logoImageBlob", parent: name, max: 512000)
            try self.operatingSystems?.forEach {
                try validate($0, name: "operatingSystems[]", parent: name, max: 50)
                try validate($0, name: "operatingSystems[]", parent: name, min: 1)
            }
            try self.validate(self.operatingSystems, name: "operatingSystems", parent: name, max: 50)
            try self.validate(self.usageText, name: "usageText", parent: name, max: 25600)
        }

        private enum CodingKeys: String, CodingKey {
            case aboutText = "aboutText"
            case architectures = "architectures"
            case description = "description"
            case logoImageBlob = "logoImageBlob"
            case operatingSystems = "operatingSystems"
            case usageText = "usageText"
        }
    }

    public struct SetRepositoryPolicyRequest: AWSEncodableShape {
        /// If the policy that you want to set on a repository policy would prevent you from setting another policy in the future, you must force the SetRepositoryPolicy operation. This prevents accidental repository lockouts.
        public let force: Bool?
        /// The JSON repository policy text to apply to the repository. For more information, see Amazon ECR Repository Policies in the Amazon Elastic Container Registry User Guide.
        public let policyText: String
        /// The Amazon Web Services account ID that's associated with the registry that contains the repository. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository to receive the policy.
        public let repositoryName: String

        public init(force: Bool? = nil, policyText: String, registryId: String? = nil, repositoryName: String) {
            self.force = force
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyText, name: "policyText", parent: name, max: 10240)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case force = "force"
            case policyText = "policyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct SetRepositoryPolicyResponse: AWSDecodableShape {
        /// The JSON repository policy text that's applied to the repository.
        public let policyText: String?
        /// The registry ID that's associated with the request.
        public let registryId: String?
        /// The repository name that's associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let key: String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to add tags to. Currently, the supported resource is an Amazon ECR Public repository.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to delete tags from. Currently, the supported resource is an Amazon ECR Public repository.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UploadLayerPartRequest: AWSEncodableShape {
        /// The base64-encoded layer part payload.
        public let layerPartBlob: AWSBase64Data
        /// The position of the first byte of the layer part witin the overall image layer.
        public let partFirstByte: Int64
        /// The position of the last byte of the layer part within the overall image layer.
        public let partLastByte: Int64
        /// The Amazon Web Services account ID, or registry alias, that's associated with the registry that you're uploading layer parts to. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository that you're uploading layer parts to.
        public let repositoryName: String
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the layer part upload.
        public let uploadId: String

        public init(layerPartBlob: AWSBase64Data, partFirstByte: Int64, partLastByte: Int64, registryId: String? = nil, repositoryName: String, uploadId: String) {
            self.layerPartBlob = layerPartBlob
            self.partFirstByte = partFirstByte
            self.partLastByte = partLastByte
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        public func validate(name: String) throws {
            try self.validate(self.layerPartBlob, name: "layerPartBlob", parent: name, max: 20971520)
            try self.validate(self.partFirstByte, name: "partFirstByte", parent: name, min: 0)
            try self.validate(self.partLastByte, name: "partLastByte", parent: name, min: 0)
            try self.validate(self.registryId, name: "registryId", parent: name, max: 50)
            try self.validate(self.registryId, name: "registryId", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case layerPartBlob = "layerPartBlob"
            case partFirstByte = "partFirstByte"
            case partLastByte = "partLastByte"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case uploadId = "uploadId"
        }
    }

    public struct UploadLayerPartResponse: AWSDecodableShape {
        /// The integer value of the last byte that's received in the request.
        public let lastByteReceived: Int64?
        /// The registry ID that's associated with the request.
        public let registryId: String?
        /// The repository name that's associated with the request.
        public let repositoryName: String?
        /// The upload ID that's associated with the request.
        public let uploadId: String?

        public init(lastByteReceived: Int64? = nil, registryId: String? = nil, repositoryName: String? = nil, uploadId: String? = nil) {
            self.lastByteReceived = lastByteReceived
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case lastByteReceived = "lastByteReceived"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case uploadId = "uploadId"
        }
    }
}

// MARK: - Errors

/// Error enum for ECRPublic
public struct ECRPublicErrorType: AWSErrorType {
    enum Code: String {
        case emptyUploadException = "EmptyUploadException"
        case imageAlreadyExistsException = "ImageAlreadyExistsException"
        case imageDigestDoesNotMatchException = "ImageDigestDoesNotMatchException"
        case imageNotFoundException = "ImageNotFoundException"
        case imageTagAlreadyExistsException = "ImageTagAlreadyExistsException"
        case invalidLayerException = "InvalidLayerException"
        case invalidLayerPartException = "InvalidLayerPartException"
        case invalidParameterException = "InvalidParameterException"
        case invalidTagParameterException = "InvalidTagParameterException"
        case layerAlreadyExistsException = "LayerAlreadyExistsException"
        case layerPartTooSmallException = "LayerPartTooSmallException"
        case layersNotFoundException = "LayersNotFoundException"
        case limitExceededException = "LimitExceededException"
        case referencedImagesNotFoundException = "ReferencedImagesNotFoundException"
        case registryNotFoundException = "RegistryNotFoundException"
        case repositoryAlreadyExistsException = "RepositoryAlreadyExistsException"
        case repositoryCatalogDataNotFoundException = "RepositoryCatalogDataNotFoundException"
        case repositoryNotEmptyException = "RepositoryNotEmptyException"
        case repositoryNotFoundException = "RepositoryNotFoundException"
        case repositoryPolicyNotFoundException = "RepositoryPolicyNotFoundException"
        case serverException = "ServerException"
        case tooManyTagsException = "TooManyTagsException"
        case unsupportedCommandException = "UnsupportedCommandException"
        case uploadNotFoundException = "UploadNotFoundException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ECRPublic
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The specified layer upload doesn't contain any layer parts.
    public static var emptyUploadException: Self { .init(.emptyUploadException) }
    /// The specified image has already been pushed, and there were no changes to the manifest or image tag after the last push.
    public static var imageAlreadyExistsException: Self { .init(.imageAlreadyExistsException) }
    /// The specified image digest doesn't match the digest that Amazon ECR calculated for the image.
    public static var imageDigestDoesNotMatchException: Self { .init(.imageDigestDoesNotMatchException) }
    /// The image requested doesn't exist in the specified repository.
    public static var imageNotFoundException: Self { .init(.imageNotFoundException) }
    /// The specified image is tagged with a tag that already exists. The repository is configured for tag immutability.
    public static var imageTagAlreadyExistsException: Self { .init(.imageTagAlreadyExistsException) }
    /// The layer digest calculation performed by Amazon ECR when the image layer doesn't match the digest specified.
    public static var invalidLayerException: Self { .init(.invalidLayerException) }
    /// The layer part size isn't valid, or the first byte specified isn't consecutive to the last byte of a previous layer part upload.
    public static var invalidLayerPartException: Self { .init(.invalidLayerPartException) }
    /// The specified parameter is invalid. Review the available parameters for the API request.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// An invalid parameter has been specified. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public static var invalidTagParameterException: Self { .init(.invalidTagParameterException) }
    /// The image layer already exists in the associated repository.
    public static var layerAlreadyExistsException: Self { .init(.layerAlreadyExistsException) }
    /// Layer parts must be at least 5 MiB in size.
    public static var layerPartTooSmallException: Self { .init(.layerPartTooSmallException) }
    /// The specified layers can't be found, or the specified layer isn't valid for this repository.
    public static var layersNotFoundException: Self { .init(.layersNotFoundException) }
    /// The operation didn't succeed because it would have exceeded a service limit for your account. For more information, see Amazon ECR Service Quotas in the Amazon Elastic Container Registry User Guide.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The manifest list is referencing an image that doesn't exist.
    public static var referencedImagesNotFoundException: Self { .init(.referencedImagesNotFoundException) }
    /// The registry doesn't exist.
    public static var registryNotFoundException: Self { .init(.registryNotFoundException) }
    /// The specified repository already exists in the specified registry.
    public static var repositoryAlreadyExistsException: Self { .init(.repositoryAlreadyExistsException) }
    /// The repository catalog data doesn't exist.
    public static var repositoryCatalogDataNotFoundException: Self { .init(.repositoryCatalogDataNotFoundException) }
    /// The specified repository contains images. To delete a repository that contains images, you must force the deletion with the force parameter.
    public static var repositoryNotEmptyException: Self { .init(.repositoryNotEmptyException) }
    /// The specified repository can't be found. Check the spelling of the specified repository and ensure that you're performing operations on the correct registry.
    public static var repositoryNotFoundException: Self { .init(.repositoryNotFoundException) }
    /// The specified repository and registry combination doesn't have an associated repository policy.
    public static var repositoryPolicyNotFoundException: Self { .init(.repositoryPolicyNotFoundException) }
    /// These errors are usually caused by a server-side issue.
    public static var serverException: Self { .init(.serverException) }
    /// The list of tags on the repository is over the limit. The maximum number of tags that can be applied to a repository is 50.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The action isn't supported in this Region.
    public static var unsupportedCommandException: Self { .init(.unsupportedCommandException) }
    /// The upload can't be found, or the specified upload ID isn't valid for this repository.
    public static var uploadNotFoundException: Self { .init(.uploadNotFoundException) }
}

extension ECRPublicErrorType: Equatable {
    public static func == (lhs: ECRPublicErrorType, rhs: ECRPublicErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ECRPublicErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
