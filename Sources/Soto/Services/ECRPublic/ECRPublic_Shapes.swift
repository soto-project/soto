//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension ECRPublic {
    // MARK: Enums

    public enum ImageFailureCode: String, CustomStringConvertible, Codable {
        case imagenotfound = "ImageNotFound"
        case imagereferencedbymanifestlist = "ImageReferencedByManifestList"
        case imagetagdoesnotmatchdigest = "ImageTagDoesNotMatchDigest"
        case invalidimagedigest = "InvalidImageDigest"
        case invalidimagetag = "InvalidImageTag"
        case kmserror = "KmsError"
        case missingdigestandtag = "MissingDigestAndTag"
        public var description: String { return self.rawValue }
    }

    public enum LayerAvailability: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case unavailable = "UNAVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum LayerFailureCode: String, CustomStringConvertible, Codable {
        case invalidlayerdigest = "InvalidLayerDigest"
        case missinglayerdigest = "MissingLayerDigest"
        public var description: String { return self.rawValue }
    }

    public enum RegistryAliasStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AuthorizationData: AWSDecodableShape {
        /// A base64-encoded string that contains authorization data for a public Amazon ECR registry. When the string is decoded, it is presented in the format user:password for public registry authentication using docker login.
        public let authorizationToken: String?
        /// The Unix time in seconds and milliseconds when the authorization token expires. Authorization tokens are valid for 12 hours.
        public let expiresAt: Date?

        public init(authorizationToken: String? = nil, expiresAt: Date? = nil) {
            self.authorizationToken = authorizationToken
            self.expiresAt = expiresAt
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationToken
            case expiresAt
        }
    }

    public struct BatchCheckLayerAvailabilityRequest: AWSEncodableShape {
        /// The digests of the image layers to check.
        public let layerDigests: [String]
        /// The AWS account ID associated with the public registry that contains the image layers to check. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository that is associated with the image layers to check.
        public let repositoryName: String

        public init(layerDigests: [String], registryId: String? = nil, repositoryName: String) {
            self.layerDigests = layerDigests
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.layerDigests.forEach {
                try validate($0, name: "layerDigests[]", parent: name, max: 1000)
                try validate($0, name: "layerDigests[]", parent: name, min: 0)
            }
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, max: 100)
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, max: 256)
            try self.validate(self.registryId, name: "registryId", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigests
            case registryId
            case repositoryName
        }
    }

    public struct BatchCheckLayerAvailabilityResponse: AWSDecodableShape {
        /// Any failures associated with the call.
        public let failures: [LayerFailure]?
        /// A list of image layer objects corresponding to the image layer references in the request.
        public let layers: [Layer]?

        public init(failures: [LayerFailure]? = nil, layers: [Layer]? = nil) {
            self.failures = failures
            self.layers = layers
        }

        private enum CodingKeys: String, CodingKey {
            case failures
            case layers
        }
    }

    public struct BatchDeleteImageRequest: AWSEncodableShape {
        /// A list of image ID references that correspond to images to delete. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
        public let imageIds: [ImageIdentifier]
        /// The AWS account ID associated with the registry that contains the image to delete. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The repository in a public registry that contains the image to delete.
        public let repositoryName: String

        public init(imageIds: [ImageIdentifier], registryId: String? = nil, repositoryName: String) {
            self.imageIds = imageIds
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageIds.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case imageIds
            case registryId
            case repositoryName
        }
    }

    public struct BatchDeleteImageResponse: AWSDecodableShape {
        /// Any failures associated with the call.
        public let failures: [ImageFailure]?
        /// The image IDs of the deleted images.
        public let imageIds: [ImageIdentifier]?

        public init(failures: [ImageFailure]? = nil, imageIds: [ImageIdentifier]? = nil) {
            self.failures = failures
            self.imageIds = imageIds
        }

        private enum CodingKeys: String, CodingKey {
            case failures
            case imageIds
        }
    }

    public struct CompleteLayerUploadRequest: AWSEncodableShape {
        /// The sha256 digest of the image layer.
        public let layerDigests: [String]
        /// The AWS account ID associated with the registry to which to upload layers. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository in a public registry to associate with the image layer.
        public let repositoryName: String
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the image layer.
        public let uploadId: String

        public init(layerDigests: [String], registryId: String? = nil, repositoryName: String, uploadId: String) {
            self.layerDigests = layerDigests
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        public func validate(name: String) throws {
            try self.layerDigests.forEach {
                try validate($0, name: "layerDigests[]", parent: name, pattern: "[a-zA-Z0-9-_+.]+:[a-fA-F0-9]+")
            }
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, max: 100)
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, max: 256)
            try self.validate(self.registryId, name: "registryId", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigests
            case registryId
            case repositoryName
            case uploadId
        }
    }

    public struct CompleteLayerUploadResponse: AWSDecodableShape {
        /// The sha256 digest of the image layer.
        public let layerDigest: String?
        /// The public registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The upload ID associated with the layer.
        public let uploadId: String?

        public init(layerDigest: String? = nil, registryId: String? = nil, repositoryName: String? = nil, uploadId: String? = nil) {
            self.layerDigest = layerDigest
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigest
            case registryId
            case repositoryName
            case uploadId
        }
    }

    public struct CreateRepositoryRequest: AWSEncodableShape {
        /// The details about the repository that are publicly visible in the Amazon ECR Public Gallery.
        public let catalogData: RepositoryCatalogDataInput?
        /// The name to use for the repository. This appears publicly in the Amazon ECR Public Gallery. The repository name may be specified on its own (such as nginx-web-app) or it can be prepended with a namespace to group the repository into a category (such as project-a/nginx-web-app).
        public let repositoryName: String
        /// The metadata that you apply to the repository to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [Tag]?

        public init(catalogData: RepositoryCatalogDataInput? = nil, repositoryName: String, tags: [Tag]? = nil) {
            self.catalogData = catalogData
            self.repositoryName = repositoryName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.catalogData?.validate(name: "\(name).catalogData")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogData
            case repositoryName
            case tags
        }
    }

    public struct CreateRepositoryResponse: AWSDecodableShape {
        public let catalogData: RepositoryCatalogData?
        /// The repository that was created.
        public let repository: Repository?

        public init(catalogData: RepositoryCatalogData? = nil, repository: Repository? = nil) {
            self.catalogData = catalogData
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case catalogData
            case repository
        }
    }

    public struct DeleteRepositoryPolicyRequest: AWSEncodableShape {
        /// The AWS account ID associated with the public registry that contains the repository policy to delete. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository that is associated with the repository policy to delete.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId
            case repositoryName
        }
    }

    public struct DeleteRepositoryPolicyResponse: AWSDecodableShape {
        /// The JSON repository policy that was deleted from the repository.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText
            case registryId
            case repositoryName
        }
    }

    public struct DeleteRepositoryRequest: AWSEncodableShape {
        ///  If a repository contains images, forces the deletion.
        public let force: Bool?
        /// The AWS account ID associated with the public registry that contains the repository to delete. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository to delete.
        public let repositoryName: String

        public init(force: Bool? = nil, registryId: String? = nil, repositoryName: String) {
            self.force = force
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case force
            case registryId
            case repositoryName
        }
    }

    public struct DeleteRepositoryResponse: AWSDecodableShape {
        /// The repository that was deleted.
        public let repository: Repository?

        public init(repository: Repository? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository
        }
    }

    public struct DescribeImageTagsRequest: AWSEncodableShape {
        /// The maximum number of repository results returned by DescribeImageTags in paginated output. When this parameter is used, DescribeImageTags only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImageTags request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeImageTags returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify images with imageIds.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeImageTags request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify images with imageIds.
        public let nextToken: String?
        /// The AWS account ID associated with the public registry that contains the repository in which to describe images. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository that contains the image tag details to describe.
        public let repositoryName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case registryId
            case repositoryName
        }
    }

    public struct DescribeImageTagsResponse: AWSDecodableShape {
        /// The image tag details for the images in the requested repository.
        public let imageTagDetails: [ImageTagDetail]?
        /// The nextToken value to include in a future DescribeImageTags request. When the results of a DescribeImageTags request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(imageTagDetails: [ImageTagDetail]? = nil, nextToken: String? = nil) {
            self.imageTagDetails = imageTagDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case imageTagDetails
            case nextToken
        }
    }

    public struct DescribeImagesRequest: AWSEncodableShape {
        /// The list of image IDs for the requested repository.
        public let imageIds: [ImageIdentifier]?
        /// The maximum number of repository results returned by DescribeImages in paginated output. When this parameter is used, DescribeImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImages request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeImages returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify images with imageIds.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify images with imageIds.
        public let nextToken: String?
        /// The AWS account ID associated with the public registry that contains the repository in which to describe images. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The repository that contains the images to describe.
        public let repositoryName: String

        public init(imageIds: [ImageIdentifier]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.imageIds = imageIds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageIds?.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case imageIds
            case maxResults
            case nextToken
            case registryId
            case repositoryName
        }
    }

    public struct DescribeImagesResponse: AWSDecodableShape {
        /// A list of ImageDetail objects that contain data about the image.
        public let imageDetails: [ImageDetail]?
        /// The nextToken value to include in a future DescribeImages request. When the results of a DescribeImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(imageDetails: [ImageDetail]? = nil, nextToken: String? = nil) {
            self.imageDetails = imageDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case imageDetails
            case nextToken
        }
    }

    public struct DescribeRegistriesRequest: AWSEncodableShape {
        /// The maximum number of repository results returned by DescribeRegistries in paginated output. When this parameter is used, DescribeRegistries only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeRegistries request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeRegistries returns up to 100 results and a nextToken value, if applicable.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeRegistries request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct DescribeRegistriesResponse: AWSDecodableShape {
        /// The nextToken value to include in a future DescribeRepositories request. When the results of a DescribeRepositories request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// An object containing the details for a public registry.
        public let registries: [Registry]

        public init(nextToken: String? = nil, registries: [Registry]) {
            self.nextToken = nextToken
            self.registries = registries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case registries
        }
    }

    public struct DescribeRepositoriesRequest: AWSEncodableShape {
        /// The maximum number of repository results returned by DescribeRepositories in paginated output. When this parameter is used, DescribeRepositories only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeRepositories request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeRepositories returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify repositories with repositoryNames.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeRepositories request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify repositories with repositoryNames.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?
        /// The AWS account ID associated with the registry that contains the repositories to be described. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// A list of repositories to describe. If this parameter is omitted, then all repositories in a registry are described.
        public let repositoryNames: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryNames: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryNames = repositoryNames
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.repositoryNames?.forEach {
                try validate($0, name: "repositoryNames[]", parent: name, max: 205)
                try validate($0, name: "repositoryNames[]", parent: name, min: 2)
                try validate($0, name: "repositoryNames[]", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
            }
            try self.validate(self.repositoryNames, name: "repositoryNames", parent: name, max: 100)
            try self.validate(self.repositoryNames, name: "repositoryNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case registryId
            case repositoryNames
        }
    }

    public struct DescribeRepositoriesResponse: AWSDecodableShape {
        /// The nextToken value to include in a future DescribeRepositories request. When the results of a DescribeRepositories request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// A list of repository objects corresponding to valid repositories.
        public let repositories: [Repository]?

        public init(nextToken: String? = nil, repositories: [Repository]? = nil) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case repositories
        }
    }

    public struct GetAuthorizationTokenRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAuthorizationTokenResponse: AWSDecodableShape {
        /// An authorization token data object that corresponds to a public registry.
        public let authorizationData: AuthorizationData?

        public init(authorizationData: AuthorizationData? = nil) {
            self.authorizationData = authorizationData
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationData
        }
    }

    public struct GetRegistryCatalogDataRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetRegistryCatalogDataResponse: AWSDecodableShape {
        /// The catalog metadata for the public registry.
        public let registryCatalogData: RegistryCatalogData

        public init(registryCatalogData: RegistryCatalogData) {
            self.registryCatalogData = registryCatalogData
        }

        private enum CodingKeys: String, CodingKey {
            case registryCatalogData
        }
    }

    public struct GetRepositoryCatalogDataRequest: AWSEncodableShape {
        /// The AWS account ID associated with the registry that contains the repositories to be described. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository to retrieve the catalog metadata for.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId
            case repositoryName
        }
    }

    public struct GetRepositoryCatalogDataResponse: AWSDecodableShape {
        /// The catalog metadata for the repository.
        public let catalogData: RepositoryCatalogData?

        public init(catalogData: RepositoryCatalogData? = nil) {
            self.catalogData = catalogData
        }

        private enum CodingKeys: String, CodingKey {
            case catalogData
        }
    }

    public struct GetRepositoryPolicyRequest: AWSEncodableShape {
        /// The AWS account ID associated with the public registry that contains the repository. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository with the policy to retrieve.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId
            case repositoryName
        }
    }

    public struct GetRepositoryPolicyResponse: AWSDecodableShape {
        /// The repository policy text associated with the repository. The policy text will be in JSON format.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText
            case registryId
            case repositoryName
        }
    }

    public struct Image: AWSDecodableShape {
        /// An object containing the image tag and image digest associated with an image.
        public let imageId: ImageIdentifier?
        /// The image manifest associated with the image.
        public let imageManifest: String?
        /// The manifest media type of the image.
        public let imageManifestMediaType: String?
        /// The AWS account ID associated with the registry containing the image.
        public let registryId: String?
        /// The name of the repository associated with the image.
        public let repositoryName: String?

        public init(imageId: ImageIdentifier? = nil, imageManifest: String? = nil, imageManifestMediaType: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageId = imageId
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageId
            case imageManifest
            case imageManifestMediaType
            case registryId
            case repositoryName
        }
    }

    public struct ImageDetail: AWSDecodableShape {
        /// The artifact media type of the image.
        public let artifactMediaType: String?
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The media type of the image manifest.
        public let imageManifestMediaType: String?
        /// The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository.
        public let imagePushedAt: Date?
        /// The size, in bytes, of the image in the repository. If the image is a manifest list, this will be the max size of all manifests in the list.  Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the docker images command shows the uncompressed image size, so it may return a larger image size than the image sizes returned by DescribeImages.
        public let imageSizeInBytes: Int64?
        /// The list of tags associated with this image.
        public let imageTags: [String]?
        /// The AWS account ID associated with the public registry to which this image belongs.
        public let registryId: String?
        /// The name of the repository to which this image belongs.
        public let repositoryName: String?

        public init(artifactMediaType: String? = nil, imageDigest: String? = nil, imageManifestMediaType: String? = nil, imagePushedAt: Date? = nil, imageSizeInBytes: Int64? = nil, imageTags: [String]? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageSizeInBytes = imageSizeInBytes
            self.imageTags = imageTags
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case artifactMediaType
            case imageDigest
            case imageManifestMediaType
            case imagePushedAt
            case imageSizeInBytes
            case imageTags
            case registryId
            case repositoryName
        }
    }

    public struct ImageFailure: AWSDecodableShape {
        /// The code associated with the failure.
        public let failureCode: ImageFailureCode?
        /// The reason for the failure.
        public let failureReason: String?
        /// The image ID associated with the failure.
        public let imageId: ImageIdentifier?

        public init(failureCode: ImageFailureCode? = nil, failureReason: String? = nil, imageId: ImageIdentifier? = nil) {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.imageId = imageId
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode
            case failureReason
            case imageId
        }
    }

    public struct ImageIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The tag used for the image.
        public let imageTag: String?

        public init(imageDigest: String? = nil, imageTag: String? = nil) {
            self.imageDigest = imageDigest
            self.imageTag = imageTag
        }

        public func validate(name: String) throws {
            try self.validate(self.imageTag, name: "imageTag", parent: name, max: 300)
            try self.validate(self.imageTag, name: "imageTag", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageDigest
            case imageTag
        }
    }

    public struct ImageTagDetail: AWSDecodableShape {
        /// The time stamp indicating when the image tag was created.
        public let createdAt: Date?
        /// An object that describes the details of an image.
        public let imageDetail: ReferencedImageDetail?
        /// The tag associated with the image.
        public let imageTag: String?

        public init(createdAt: Date? = nil, imageDetail: ReferencedImageDetail? = nil, imageTag: String? = nil) {
            self.createdAt = createdAt
            self.imageDetail = imageDetail
            self.imageTag = imageTag
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case imageDetail
            case imageTag
        }
    }

    public struct InitiateLayerUploadRequest: AWSEncodableShape {
        /// The AWS account ID associated with the registry to which you intend to upload layers. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository to which you intend to upload layers.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, max: 256)
            try self.validate(self.registryId, name: "registryId", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId
            case repositoryName
        }
    }

    public struct InitiateLayerUploadResponse: AWSDecodableShape {
        /// The size, in bytes, that Amazon ECR expects future layer part uploads to be.
        public let partSize: Int64?
        /// The upload ID for the layer upload. This parameter is passed to further UploadLayerPart and CompleteLayerUpload operations.
        public let uploadId: String?

        public init(partSize: Int64? = nil, uploadId: String? = nil) {
            self.partSize = partSize
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case partSize
            case uploadId
        }
    }

    public struct Layer: AWSDecodableShape {
        /// The availability status of the image layer.
        public let layerAvailability: LayerAvailability?
        /// The sha256 digest of the image layer.
        public let layerDigest: String?
        /// The size, in bytes, of the image layer.
        public let layerSize: Int64?
        /// The media type of the layer, such as application/vnd.docker.image.rootfs.diff.tar.gzip or application/vnd.oci.image.layer.v1.tar+gzip.
        public let mediaType: String?

        public init(layerAvailability: LayerAvailability? = nil, layerDigest: String? = nil, layerSize: Int64? = nil, mediaType: String? = nil) {
            self.layerAvailability = layerAvailability
            self.layerDigest = layerDigest
            self.layerSize = layerSize
            self.mediaType = mediaType
        }

        private enum CodingKeys: String, CodingKey {
            case layerAvailability
            case layerDigest
            case layerSize
            case mediaType
        }
    }

    public struct LayerFailure: AWSDecodableShape {
        /// The failure code associated with the failure.
        public let failureCode: LayerFailureCode?
        /// The reason for the failure.
        public let failureReason: String?
        /// The layer digest associated with the failure.
        public let layerDigest: String?

        public init(failureCode: LayerFailureCode? = nil, failureReason: String? = nil, layerDigest: String? = nil) {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.layerDigest = layerDigest
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode
            case failureReason
            case layerDigest
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resource is an Amazon ECR Public repository.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct PutImageRequest: AWSEncodableShape {
        /// The image digest of the image manifest corresponding to the image.
        public let imageDigest: String?
        /// The image manifest corresponding to the image to be uploaded.
        public let imageManifest: String
        /// The media type of the image manifest. If you push an image manifest that does not contain the mediaType field, you must specify the imageManifestMediaType in the request.
        public let imageManifestMediaType: String?
        /// The tag to associate with the image. This parameter is required for images that use the Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.
        public let imageTag: String?
        /// The AWS account ID associated with the public registry that contains the repository in which to put the image. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository in which to put the image.
        public let repositoryName: String

        public init(imageDigest: String? = nil, imageManifest: String, imageManifestMediaType: String? = nil, imageTag: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.imageDigest = imageDigest
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.imageTag = imageTag
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.imageManifest, name: "imageManifest", parent: name, max: 4_194_304)
            try self.validate(self.imageManifest, name: "imageManifest", parent: name, min: 1)
            try self.validate(self.imageTag, name: "imageTag", parent: name, max: 300)
            try self.validate(self.imageTag, name: "imageTag", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, max: 256)
            try self.validate(self.registryId, name: "registryId", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case imageDigest
            case imageManifest
            case imageManifestMediaType
            case imageTag
            case registryId
            case repositoryName
        }
    }

    public struct PutImageResponse: AWSDecodableShape {
        /// Details of the image uploaded.
        public let image: Image?

        public init(image: Image? = nil) {
            self.image = image
        }

        private enum CodingKeys: String, CodingKey {
            case image
        }
    }

    public struct PutRegistryCatalogDataRequest: AWSEncodableShape {
        /// The display name for a public registry. The display name is shown as the repository author in the Amazon ECR Public Gallery.  The registry display name is only publicly visible in the Amazon ECR Public Gallery for verified accounts.
        public let displayName: String?

        public init(displayName: String? = nil) {
            self.displayName = displayName
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName
        }
    }

    public struct PutRegistryCatalogDataResponse: AWSDecodableShape {
        /// The catalog data for the public registry.
        public let registryCatalogData: RegistryCatalogData

        public init(registryCatalogData: RegistryCatalogData) {
            self.registryCatalogData = registryCatalogData
        }

        private enum CodingKeys: String, CodingKey {
            case registryCatalogData
        }
    }

    public struct PutRepositoryCatalogDataRequest: AWSEncodableShape {
        /// An object containing the catalog data for a repository. This data is publicly visible in the Amazon ECR Public Gallery.
        public let catalogData: RepositoryCatalogDataInput
        /// The AWS account ID associated with the public registry the repository is in. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository to create or update the catalog data for.
        public let repositoryName: String

        public init(catalogData: RepositoryCatalogDataInput, registryId: String? = nil, repositoryName: String) {
            self.catalogData = catalogData
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.catalogData.validate(name: "\(name).catalogData")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogData
            case registryId
            case repositoryName
        }
    }

    public struct PutRepositoryCatalogDataResponse: AWSDecodableShape {
        /// The catalog data for the repository.
        public let catalogData: RepositoryCatalogData?

        public init(catalogData: RepositoryCatalogData? = nil) {
            self.catalogData = catalogData
        }

        private enum CodingKeys: String, CodingKey {
            case catalogData
        }
    }

    public struct ReferencedImageDetail: AWSDecodableShape {
        /// The artifact media type of the image.
        public let artifactMediaType: String?
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The media type of the image manifest.
        public let imageManifestMediaType: String?
        /// The date and time, expressed in standard JavaScript date format, at which the current image tag was pushed to the repository.
        public let imagePushedAt: Date?
        /// The size, in bytes, of the image in the repository. If the image is a manifest list, this will be the max size of all manifests in the list.  Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the docker images command shows the uncompressed image size, so it may return a larger image size than the image sizes returned by DescribeImages.
        public let imageSizeInBytes: Int64?

        public init(artifactMediaType: String? = nil, imageDigest: String? = nil, imageManifestMediaType: String? = nil, imagePushedAt: Date? = nil, imageSizeInBytes: Int64? = nil) {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageSizeInBytes = imageSizeInBytes
        }

        private enum CodingKeys: String, CodingKey {
            case artifactMediaType
            case imageDigest
            case imageManifestMediaType
            case imagePushedAt
            case imageSizeInBytes
        }
    }

    public struct Registry: AWSDecodableShape {
        /// An array of objects representing the aliases for a public registry.
        public let aliases: [RegistryAlias]
        /// The Amazon Resource Name (ARN) of the public registry.
        public let registryArn: String
        /// The AWS account ID associated with the registry. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String
        /// The URI of a public registry. The URI contains a universal prefix and the registry alias.
        public let registryUri: String
        /// Whether the account is verified. This indicates whether the account is an AWS Marketplace vendor. If an account is verified, each public repository will received a verified account badge on the Amazon ECR Public Gallery.
        public let verified: Bool

        public init(aliases: [RegistryAlias], registryArn: String, registryId: String, registryUri: String, verified: Bool) {
            self.aliases = aliases
            self.registryArn = registryArn
            self.registryId = registryId
            self.registryUri = registryUri
            self.verified = verified
        }

        private enum CodingKeys: String, CodingKey {
            case aliases
            case registryArn
            case registryId
            case registryUri
            case verified
        }
    }

    public struct RegistryAlias: AWSDecodableShape {
        /// Whether or not the registry alias is the default alias for the registry. When the first public repository is created, your public registry is assigned a default registry alias.
        public let defaultRegistryAlias: Bool
        /// The name of the registry alias.
        public let name: String
        /// Whether or not the registry alias is the primary alias for the registry. If true, the alias is the primary registry alias and is displayed in both the repository URL and the image URI used in the docker pull commands on the Amazon ECR Public Gallery.  A registry alias that is not the primary registry alias can be used in the repository URI in a docker pull command.
        public let primaryRegistryAlias: Bool
        /// The status of the registry alias.
        public let status: RegistryAliasStatus

        public init(defaultRegistryAlias: Bool, name: String, primaryRegistryAlias: Bool, status: RegistryAliasStatus) {
            self.defaultRegistryAlias = defaultRegistryAlias
            self.name = name
            self.primaryRegistryAlias = primaryRegistryAlias
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case defaultRegistryAlias
            case name
            case primaryRegistryAlias
            case status
        }
    }

    public struct RegistryCatalogData: AWSDecodableShape {
        /// The display name for a public registry. This appears on the Amazon ECR Public Gallery.  Only accounts that have the verified account badge can have a registry display name.
        public let displayName: String?

        public init(displayName: String? = nil) {
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case displayName
        }
    }

    public struct Repository: AWSDecodableShape {
        /// The date and time, in JavaScript date format, when the repository was created.
        public let createdAt: Date?
        /// The AWS account ID associated with the public registry that contains the repository.
        public let registryId: String?
        /// The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the arn:aws:ecr namespace, followed by the region of the repository, AWS account ID of the repository owner, repository namespace, and repository name. For example, arn:aws:ecr:region:012345678910:repository/test.
        public let repositoryArn: String?
        /// The name of the repository.
        public let repositoryName: String?
        /// The URI for the repository. You can use this URI for container image push and pull operations.
        public let repositoryUri: String?

        public init(createdAt: Date? = nil, registryId: String? = nil, repositoryArn: String? = nil, repositoryName: String? = nil, repositoryUri: String? = nil) {
            self.createdAt = createdAt
            self.registryId = registryId
            self.repositoryArn = repositoryArn
            self.repositoryName = repositoryName
            self.repositoryUri = repositoryUri
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case registryId
            case repositoryArn
            case repositoryName
            case repositoryUri
        }
    }

    public struct RepositoryCatalogData: AWSDecodableShape {
        /// The longform description of the contents of the repository. This text appears in the repository details on the Amazon ECR Public Gallery.
        public let aboutText: String?
        /// The architecture tags that are associated with the repository.  Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For more information, see RepositoryCatalogDataInput.
        public let architectures: [String]?
        /// The short description of the repository.
        public let description: String?
        /// The URL containing the logo associated with the repository.
        public let logoUrl: String?
        /// Whether or not the repository is certified by AWS Marketplace.
        public let marketplaceCertified: Bool?
        /// The operating system tags that are associated with the repository.  Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For more information, see RepositoryCatalogDataInput.
        public let operatingSystems: [String]?
        /// The longform usage details of the contents of the repository. The usage text provides context for users of the repository.
        public let usageText: String?

        public init(aboutText: String? = nil, architectures: [String]? = nil, description: String? = nil, logoUrl: String? = nil, marketplaceCertified: Bool? = nil, operatingSystems: [String]? = nil, usageText: String? = nil) {
            self.aboutText = aboutText
            self.architectures = architectures
            self.description = description
            self.logoUrl = logoUrl
            self.marketplaceCertified = marketplaceCertified
            self.operatingSystems = operatingSystems
            self.usageText = usageText
        }

        private enum CodingKeys: String, CodingKey {
            case aboutText
            case architectures
            case description
            case logoUrl
            case marketplaceCertified
            case operatingSystems
            case usageText
        }
    }

    public struct RepositoryCatalogDataInput: AWSEncodableShape {
        /// A detailed description of the contents of the repository. It is publicly visible in the Amazon ECR Public Gallery. The text must be in markdown format.
        public let aboutText: String?
        /// The system architecture that the images in the repository are compatible with. On the Amazon ECR Public Gallery, the following supported architectures will appear as badges on the repository and are used as search filters.    Linux     Windows     If an unsupported tag is added to your repository catalog data, it will be associated with the repository and can be retrieved using the API but will not be discoverable in the Amazon ECR Public Gallery.
        public let architectures: [String]?
        /// A short description of the contents of the repository. This text appears in both the image details and also when searching for repositories on the Amazon ECR Public Gallery.
        public let description: String?
        /// The base64-encoded repository logo payload.  The repository logo is only publicly visible in the Amazon ECR Public Gallery for verified accounts.
        public let logoImageBlob: Data?
        /// The operating systems that the images in the repository are compatible with. On the Amazon ECR Public Gallery, the following supported operating systems will appear as badges on the repository and are used as search filters.    ARM     ARM 64     x86     x86-64     If an unsupported tag is added to your repository catalog data, it will be associated with the repository and can be retrieved using the API but will not be discoverable in the Amazon ECR Public Gallery.
        public let operatingSystems: [String]?
        /// Detailed information on how to use the contents of the repository. It is publicly visible in the Amazon ECR Public Gallery. The usage text provides context, support information, and additional usage details for users of the repository. The text must be in markdown format.
        public let usageText: String?

        public init(aboutText: String? = nil, architectures: [String]? = nil, description: String? = nil, logoImageBlob: Data? = nil, operatingSystems: [String]? = nil, usageText: String? = nil) {
            self.aboutText = aboutText
            self.architectures = architectures
            self.description = description
            self.logoImageBlob = logoImageBlob
            self.operatingSystems = operatingSystems
            self.usageText = usageText
        }

        public func validate(name: String) throws {
            try self.validate(self.aboutText, name: "aboutText", parent: name, max: 10240)
            try self.architectures?.forEach {
                try validate($0, name: "architectures[]", parent: name, max: 50)
                try validate($0, name: "architectures[]", parent: name, min: 1)
            }
            try self.validate(self.architectures, name: "architectures", parent: name, max: 50)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.logoImageBlob, name: "logoImageBlob", parent: name, max: 512_000)
            try self.validate(self.logoImageBlob, name: "logoImageBlob", parent: name, min: 0)
            try self.operatingSystems?.forEach {
                try validate($0, name: "operatingSystems[]", parent: name, max: 50)
                try validate($0, name: "operatingSystems[]", parent: name, min: 1)
            }
            try self.validate(self.operatingSystems, name: "operatingSystems", parent: name, max: 50)
            try self.validate(self.usageText, name: "usageText", parent: name, max: 10240)
        }

        private enum CodingKeys: String, CodingKey {
            case aboutText
            case architectures
            case description
            case logoImageBlob
            case operatingSystems
            case usageText
        }
    }

    public struct SetRepositoryPolicyRequest: AWSEncodableShape {
        /// If the policy you are attempting to set on a repository policy would prevent you from setting another policy in the future, you must force the SetRepositoryPolicy operation. This is intended to prevent accidental repository lock outs.
        public let force: Bool?
        /// The JSON repository policy text to apply to the repository. For more information, see Amazon ECR Repository Policies in the Amazon Elastic Container Registry User Guide.
        public let policyText: String
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository to receive the policy.
        public let repositoryName: String

        public init(force: Bool? = nil, policyText: String, registryId: String? = nil, repositoryName: String) {
            self.force = force
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyText, name: "policyText", parent: name, max: 10240)
            try self.validate(self.policyText, name: "policyText", parent: name, min: 0)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case force
            case policyText
            case registryId
            case repositoryName
        }
    }

    public struct SetRepositoryPolicyResponse: AWSDecodableShape {
        /// The JSON repository policy text applied to the repository.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText
            case registryId
            case repositoryName
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let key: String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to which to add tags. Currently, the supported resource is an Amazon ECR Public repository.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource from which to delete tags. Currently, the supported resource is an Amazon ECR Public repository.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn
            case tagKeys
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UploadLayerPartRequest: AWSEncodableShape {
        /// The base64-encoded layer part payload.
        public let layerPartBlob: Data
        /// The position of the first byte of the layer part witin the overall image layer.
        public let partFirstByte: Int64
        /// The position of the last byte of the layer part within the overall image layer.
        public let partLastByte: Int64
        /// The AWS account ID associated with the registry to which you are uploading layer parts. If you do not specify a registry, the default public registry is assumed.
        public let registryId: String?
        /// The name of the repository to which you are uploading layer parts.
        public let repositoryName: String
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the layer part upload.
        public let uploadId: String

        public init(layerPartBlob: Data, partFirstByte: Int64, partLastByte: Int64, registryId: String? = nil, repositoryName: String, uploadId: String) {
            self.layerPartBlob = layerPartBlob
            self.partFirstByte = partFirstByte
            self.partLastByte = partLastByte
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        public func validate(name: String) throws {
            try self.validate(self.layerPartBlob, name: "layerPartBlob", parent: name, max: 20_971_520)
            try self.validate(self.layerPartBlob, name: "layerPartBlob", parent: name, min: 0)
            try self.validate(self.partFirstByte, name: "partFirstByte", parent: name, min: 0)
            try self.validate(self.partLastByte, name: "partLastByte", parent: name, min: 0)
            try self.validate(self.registryId, name: "registryId", parent: name, max: 256)
            try self.validate(self.registryId, name: "registryId", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 205)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case layerPartBlob
            case partFirstByte
            case partLastByte
            case registryId
            case repositoryName
            case uploadId
        }
    }

    public struct UploadLayerPartResponse: AWSDecodableShape {
        /// The integer value of the last byte received in the request.
        public let lastByteReceived: Int64?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The upload ID associated with the request.
        public let uploadId: String?

        public init(lastByteReceived: Int64? = nil, registryId: String? = nil, repositoryName: String? = nil, uploadId: String? = nil) {
            self.lastByteReceived = lastByteReceived
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case lastByteReceived
            case registryId
            case repositoryName
            case uploadId
        }
    }
}
