//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockRuntime {
    // MARK: Enums

    public enum Trace: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ResponseStream: AWSDecodableShape, Sendable {
        /// Content included in the response.
        case chunk(PayloadPart)
        /// An internal server error occurred. Retry your request.
        case internalServerException(InternalServerException)
        /// An error occurred while streaming the response. Retry your request.
        case modelStreamErrorException(ModelStreamErrorException)
        /// The request took too long to process. Processing time exceeded the model timeout length.
        case modelTimeoutException(ModelTimeoutException)
        /// The number or frequency of requests exceeds the limit. Resubmit your request later.
        case throttlingException(ThrottlingException)
        /// Input validation failed. Check your request parameters and retry the request.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .chunk:
                let value = try container.decode(PayloadPart.self, forKey: .chunk)
                self = .chunk(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .modelStreamErrorException:
                let value = try container.decode(ModelStreamErrorException.self, forKey: .modelStreamErrorException)
                self = .modelStreamErrorException(value)
            case .modelTimeoutException:
                let value = try container.decode(ModelTimeoutException.self, forKey: .modelTimeoutException)
                self = .modelTimeoutException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case chunk = "chunk"
            case internalServerException = "internalServerException"
            case modelStreamErrorException = "modelStreamErrorException"
            case modelTimeoutException = "modelTimeoutException"
            case throttlingException = "throttlingException"
            case validationException = "validationException"
        }
    }

    // MARK: Shapes

    public struct InternalServerException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvokeModelRequest: AWSEncodableShape {
        /// The desired MIME type of the inference body in the response. The default value is application/json.
        public let accept: String?
        /// The prompt and inference parameters in the format specified in the contentType in the header. To see the format and content of the request and response bodies for different models, refer to Inference parameters. For more information, see Run inference in the Bedrock User Guide.
        public let body: AWSHTTPBody
        /// The MIME type of the input data in the request. The default value is application/json.
        public let contentType: String?
        /// The unique identifier of the guardrail that you want to use. If you don't provide a value, no guardrail is applied to the invocation. An error will be thrown in the following situations.   You don't provide a guardrail identifier but you specify the amazon-bedrock-guardrailConfig field in the request body.   You enable the guardrail but the contentType isn't application/json.   You provide a guardrail identifier, but guardrailVersion isn't specified.
        public let guardrailIdentifier: String?
        /// The version number for the guardrail. The value can also be DRAFT.
        public let guardrailVersion: String?
        /// The unique identifier of the model to invoke to run inference. The modelId to provide depends on the type of model that you use:   If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see Amazon Bedrock base model IDs (on-demand throughput) in the Amazon Bedrock User Guide.   If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see Run inference using a Provisioned Throughput in the Amazon Bedrock User Guide.   If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see Use a custom model in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let modelId: String
        /// Specifies whether to enable or disable the Bedrock trace. If enabled, you can see the full Bedrock trace.
        public let trace: Trace?

        public init(accept: String? = nil, body: AWSHTTPBody, contentType: String? = nil, guardrailIdentifier: String? = nil, guardrailVersion: String? = nil, modelId: String, trace: Trace? = nil) {
            self.accept = accept
            self.body = body
            self.contentType = contentType
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
            self.modelId = modelId
            self.trace = trace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.accept, key: "Accept")
            try container.encode(self.body)
            request.encodeHeader(self.contentType, key: "Content-Type")
            request.encodeHeader(self.guardrailIdentifier, key: "X-Amzn-Bedrock-GuardrailIdentifier")
            request.encodeHeader(self.guardrailVersion, key: "X-Amzn-Bedrock-GuardrailVersion")
            request.encodePath(self.modelId, key: "modelId")
            request.encodeHeader(self.trace, key: "X-Amzn-Bedrock-Trace")
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 25000000)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^(([1-9][0-9]{0,7})|(DRAFT))$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:provisioned-model/[a-z0-9]{12})))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeModelResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Inference response from the model in the format specified in the contentType header. To see the format and content of the request and response bodies for different models, refer to Inference parameters.
        public let body: AWSHTTPBody
        /// The MIME type of the inference result.
        public let contentType: String

        public init(body: AWSHTTPBody, contentType: String) {
            self.body = body
            self.contentType = contentType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.body = try container.decode(AWSHTTPBody.self)
            self.contentType = try response.decodeHeader(String.self, key: "Content-Type")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeModelWithResponseStreamRequest: AWSEncodableShape {
        /// The desired MIME type of the inference body in the response. The default value is application/json.
        public let accept: String?
        /// The prompt and inference parameters in the format specified in the contentType in the header. To see the format and content of the request and response bodies for different models, refer to Inference parameters. For more information, see Run inference in the Bedrock User Guide.
        public let body: AWSHTTPBody
        /// The MIME type of the input data in the request. The default value is application/json.
        public let contentType: String?
        /// The unique identifier of the guardrail that you want to use. If you don't provide a value, no guardrail is applied to the invocation. An error is thrown in the following situations.   You don't provide a guardrail identifier but you specify the amazon-bedrock-guardrailConfig field in the request body.   You enable the guardrail but the contentType isn't application/json.   You provide a guardrail identifier, but guardrailVersion isn't specified.
        public let guardrailIdentifier: String?
        /// The version number for the guardrail. The value can also be DRAFT.
        public let guardrailVersion: String?
        /// The unique identifier of the model to invoke to run inference. The modelId to provide depends on the type of model that you use:   If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see Amazon Bedrock base model IDs (on-demand throughput) in the Amazon Bedrock User Guide.   If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see Run inference using a Provisioned Throughput in the Amazon Bedrock User Guide.   If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see Use a custom model in Amazon Bedrock in the Amazon Bedrock User Guide.
        public let modelId: String
        /// Specifies whether to enable or disable the Bedrock trace. If enabled, you can see the full Bedrock trace.
        public let trace: Trace?

        public init(accept: String? = nil, body: AWSHTTPBody, contentType: String? = nil, guardrailIdentifier: String? = nil, guardrailVersion: String? = nil, modelId: String, trace: Trace? = nil) {
            self.accept = accept
            self.body = body
            self.contentType = contentType
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
            self.modelId = modelId
            self.trace = trace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.accept, key: "X-Amzn-Bedrock-Accept")
            try container.encode(self.body)
            request.encodeHeader(self.contentType, key: "Content-Type")
            request.encodeHeader(self.guardrailIdentifier, key: "X-Amzn-Bedrock-GuardrailIdentifier")
            request.encodeHeader(self.guardrailVersion, key: "X-Amzn-Bedrock-GuardrailVersion")
            request.encodePath(self.modelId, key: "modelId")
            request.encodeHeader(self.trace, key: "X-Amzn-Bedrock-Trace")
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 25000000)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^(([1-9][0-9]{0,7})|(DRAFT))$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:provisioned-model/[a-z0-9]{12})))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeModelWithResponseStreamResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Inference response from the model in the format specified by the contentType header. To see the format and content of this field for different models, refer to Inference parameters.
        public let body: AWSEventStream<ResponseStream>
        /// The MIME type of the inference result.
        public let contentType: String

        public init(body: AWSEventStream<ResponseStream>, contentType: String) {
            self.body = body
            self.contentType = contentType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.body = try container.decode(AWSEventStream<ResponseStream>.self)
            self.contentType = try response.decodeHeader(String.self, key: "X-Amzn-Bedrock-Content-Type")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ModelStreamErrorException: AWSDecodableShape {
        public let message: String?
        /// The original message.
        public let originalMessage: String?
        /// The original status code.
        public let originalStatusCode: Int?

        public init(message: String? = nil, originalMessage: String? = nil, originalStatusCode: Int? = nil) {
            self.message = message
            self.originalMessage = originalMessage
            self.originalStatusCode = originalStatusCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case originalMessage = "originalMessage"
            case originalStatusCode = "originalStatusCode"
        }
    }

    public struct ModelTimeoutException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct PayloadPart: AWSDecodableShape {
        /// Base64-encoded bytes of payload data.
        public let bytes: AWSBase64Data?

        public init(bytes: AWSBase64Data? = nil) {
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
        }
    }

    public struct ThrottlingException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ValidationException: AWSDecodableShape {
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockRuntime
public struct BedrockRuntimeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case modelErrorException = "ModelErrorException"
        case modelNotReadyException = "ModelNotReadyException"
        case modelStreamErrorException = "ModelStreamErrorException"
        case modelTimeoutException = "ModelTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockRuntime
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request is denied because of missing access permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// An internal server error occurred. Retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request failed due to an error while processing the model.
    public static var modelErrorException: Self { .init(.modelErrorException) }
    /// The model specified in the request is not ready to serve inference requests.
    public static var modelNotReadyException: Self { .init(.modelNotReadyException) }
    /// An error occurred while streaming the response. Retry your request.
    public static var modelStreamErrorException: Self { .init(.modelStreamErrorException) }
    /// The request took too long to process. Processing time exceeded the model timeout length.
    public static var modelTimeoutException: Self { .init(.modelTimeoutException) }
    /// The specified resource ARN was not found. Check the ARN and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The number of requests exceeds the service quota. Resubmit your request later.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The number of requests exceeds the limit. Resubmit your request later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Input validation failed. Check your request parameters and retry the request.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockRuntimeErrorType: Equatable {
    public static func == (lhs: BedrockRuntimeErrorType, rhs: BedrockRuntimeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockRuntimeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
