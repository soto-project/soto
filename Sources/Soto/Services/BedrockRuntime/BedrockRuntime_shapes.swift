//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockRuntime {
    // MARK: Enums

    public enum AsyncInvokeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        public var description: String { return self.rawValue }
    }

    public enum CachePointType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "default"
        public var description: String { return self.rawValue }
    }

    public enum ConversationRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assistant = "assistant"
        case user = "user"
        public var description: String { return self.rawValue }
    }

    public enum DocumentFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "csv"
        case doc = "doc"
        case docx = "docx"
        case html = "html"
        case md = "md"
        case pdf = "pdf"
        case txt = "txt"
        case xls = "xls"
        case xlsx = "xlsx"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case guardrailIntervened = "GUARDRAIL_INTERVENED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentFilterConfidence: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentFilterStrength: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hate = "HATE"
        case insults = "INSULTS"
        case misconduct = "MISCONDUCT"
        case promptAttack = "PROMPT_ATTACK"
        case sexual = "SEXUAL"
        case violence = "VIOLENCE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blocked = "BLOCKED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentQualifier: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case groundingSource = "grounding_source"
        case guardContent = "guard_content"
        case query = "query"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case input = "INPUT"
        case output = "OUTPUT"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContextualGroundingFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case grounding = "GROUNDING"
        case relevance = "RELEVANCE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContextualGroundingPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blocked = "BLOCKED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailConverseContentQualifier: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case groundingSource = "grounding_source"
        case guardContent = "guard_content"
        case query = "query"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailConverseImageFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jpeg = "jpeg"
        case png = "png"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailImageFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jpeg = "jpeg"
        case png = "png"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailManagedWordType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case profanity = "PROFANITY"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailOutputScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case full = "FULL"
        case interventions = "INTERVENTIONS"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailPiiEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case address = "ADDRESS"
        case age = "AGE"
        case awsAccessKey = "AWS_ACCESS_KEY"
        case awsSecretKey = "AWS_SECRET_KEY"
        case caHealthNumber = "CA_HEALTH_NUMBER"
        case caSocialInsuranceNumber = "CA_SOCIAL_INSURANCE_NUMBER"
        case creditDebitCardCvv = "CREDIT_DEBIT_CARD_CVV"
        case creditDebitCardExpiry = "CREDIT_DEBIT_CARD_EXPIRY"
        case creditDebitCardNumber = "CREDIT_DEBIT_CARD_NUMBER"
        case driverId = "DRIVER_ID"
        case email = "EMAIL"
        case internationalBankAccountNumber = "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
        case ipAddress = "IP_ADDRESS"
        case licensePlate = "LICENSE_PLATE"
        case macAddress = "MAC_ADDRESS"
        case name = "NAME"
        case password = "PASSWORD"
        case phone = "PHONE"
        case pin = "PIN"
        case swiftCode = "SWIFT_CODE"
        case ukNationalHealthServiceNumber = "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
        case ukNationalInsuranceNumber = "UK_NATIONAL_INSURANCE_NUMBER"
        case ukUniqueTaxpayerReferenceNumber = "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
        case url = "URL"
        case usBankAccountNumber = "US_BANK_ACCOUNT_NUMBER"
        case usBankRoutingNumber = "US_BANK_ROUTING_NUMBER"
        case usIndividualTaxIdentificationNumber = "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
        case usPassportNumber = "US_PASSPORT_NUMBER"
        case usSocialSecurityNumber = "US_SOCIAL_SECURITY_NUMBER"
        case username = "USERNAME"
        case vehicleIdentificationNumber = "VEHICLE_IDENTIFICATION_NUMBER"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailSensitiveInformationPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anonymized = "ANONYMIZED"
        case blocked = "BLOCKED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailStreamProcessingMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `async` = "async"
        case sync = "sync"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailTopicPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blocked = "BLOCKED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailTopicType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailTrace: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "disabled"
        case enabled = "enabled"
        case enabledFull = "enabled_full"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailWordPolicyAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blocked = "BLOCKED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ImageFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gif = "gif"
        case jpeg = "jpeg"
        case png = "png"
        case webp = "webp"
        public var description: String { return self.rawValue }
    }

    public enum PerformanceConfigLatency: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case optimized = "optimized"
        case standard = "standard"
        public var description: String { return self.rawValue }
    }

    public enum SortAsyncInvocationBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case submissionTime = "SubmissionTime"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum StopReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contentFiltered = "content_filtered"
        case endTurn = "end_turn"
        case guardrailIntervened = "guardrail_intervened"
        case maxTokens = "max_tokens"
        case stopSequence = "stop_sequence"
        case toolUse = "tool_use"
        public var description: String { return self.rawValue }
    }

    public enum ToolResultStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "error"
        case success = "success"
        public var description: String { return self.rawValue }
    }

    public enum Trace: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        case enabledFull = "ENABLED_FULL"
        public var description: String { return self.rawValue }
    }

    public enum VideoFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case flv = "flv"
        case mkv = "mkv"
        case mov = "mov"
        case mp4 = "mp4"
        case mpeg = "mpeg"
        case mpg = "mpg"
        case threeGp = "three_gp"
        case webm = "webm"
        case wmv = "wmv"
        public var description: String { return self.rawValue }
    }

    public enum ContentBlock: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// CachePoint to include in the message.
        case cachePoint(CachePointBlock)
        /// A document to include in the message.
        case document(DocumentBlock)
        /// Contains the content to assess with the guardrail. If you don't specify guardContent in a call to the Converse API, the guardrail (if passed in the Converse API) assesses the entire message. For more information, see  Use a guardrail with the Converse API in the Amazon Bedrock User Guide.
        ///
        case guardContent(GuardrailConverseContentBlock)
        /// Image to include in the message.   This field is only supported by Anthropic Claude 3 models.
        case image(ImageBlock)
        /// Contains content regarding the reasoning that is carried out by the model. Reasoning refers to a Chain of Thought (CoT) that the model generates to enhance the accuracy of its final response.
        case reasoningContent(ReasoningContentBlock)
        /// Text to include in the message.
        case text(String)
        /// The result for a tool request that a model makes.
        case toolResult(ToolResultBlock)
        /// Information about a tool use request from a model.
        case toolUse(ToolUseBlock)
        /// Video to include in the message.
        case video(VideoBlock)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .cachePoint:
                let value = try container.decode(CachePointBlock.self, forKey: .cachePoint)
                self = .cachePoint(value)
            case .document:
                let value = try container.decode(DocumentBlock.self, forKey: .document)
                self = .document(value)
            case .guardContent:
                let value = try container.decode(GuardrailConverseContentBlock.self, forKey: .guardContent)
                self = .guardContent(value)
            case .image:
                let value = try container.decode(ImageBlock.self, forKey: .image)
                self = .image(value)
            case .reasoningContent:
                let value = try container.decode(ReasoningContentBlock.self, forKey: .reasoningContent)
                self = .reasoningContent(value)
            case .text:
                let value = try container.decode(String.self, forKey: .text)
                self = .text(value)
            case .toolResult:
                let value = try container.decode(ToolResultBlock.self, forKey: .toolResult)
                self = .toolResult(value)
            case .toolUse:
                let value = try container.decode(ToolUseBlock.self, forKey: .toolUse)
                self = .toolUse(value)
            case .video:
                let value = try container.decode(VideoBlock.self, forKey: .video)
                self = .video(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .cachePoint(let value):
                try container.encode(value, forKey: .cachePoint)
            case .document(let value):
                try container.encode(value, forKey: .document)
            case .guardContent(let value):
                try container.encode(value, forKey: .guardContent)
            case .image(let value):
                try container.encode(value, forKey: .image)
            case .reasoningContent(let value):
                try container.encode(value, forKey: .reasoningContent)
            case .text(let value):
                try container.encode(value, forKey: .text)
            case .toolResult(let value):
                try container.encode(value, forKey: .toolResult)
            case .toolUse(let value):
                try container.encode(value, forKey: .toolUse)
            case .video(let value):
                try container.encode(value, forKey: .video)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .toolResult(let value):
                try value.validate(name: "\(name).toolResult")
            case .toolUse(let value):
                try value.validate(name: "\(name).toolUse")
            case .video(let value):
                try value.validate(name: "\(name).video")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cachePoint = "cachePoint"
            case document = "document"
            case guardContent = "guardContent"
            case image = "image"
            case reasoningContent = "reasoningContent"
            case text = "text"
            case toolResult = "toolResult"
            case toolUse = "toolUse"
            case video = "video"
        }
    }

    public enum ContentBlockDelta: AWSDecodableShape, Sendable {
        /// Contains content regarding the reasoning that is carried out by the model. Reasoning refers to a Chain of Thought (CoT) that the model generates to enhance the accuracy of its final response.
        case reasoningContent(ReasoningContentBlockDelta)
        /// The content text.
        case text(String)
        /// Information about a tool that the model is requesting to use.
        case toolUse(ToolUseBlockDelta)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .reasoningContent:
                let value = try container.decode(ReasoningContentBlockDelta.self, forKey: .reasoningContent)
                self = .reasoningContent(value)
            case .text:
                let value = try container.decode(String.self, forKey: .text)
                self = .text(value)
            case .toolUse:
                let value = try container.decode(ToolUseBlockDelta.self, forKey: .toolUse)
                self = .toolUse(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case reasoningContent = "reasoningContent"
            case text = "text"
            case toolUse = "toolUse"
        }
    }

    public enum ConverseStreamOutput: AWSDecodableShape, Sendable {
        /// The messages output content block delta.
        case contentBlockDelta(ContentBlockDeltaEvent)
        /// Start information for a content block.
        case contentBlockStart(ContentBlockStartEvent)
        /// Stop information for a content block.
        case contentBlockStop(ContentBlockStopEvent)
        /// An internal server error occurred. Retry your request.
        case internalServerException(InternalServerException)
        /// Message start information.
        case messageStart(MessageStartEvent)
        /// Message stop information.
        case messageStop(MessageStopEvent)
        /// Metadata for the converse output stream.
        case metadata(ConverseStreamMetadataEvent)
        /// A streaming error occurred. Retry your request.
        case modelStreamErrorException(ModelStreamErrorException)
        /// The service isn't currently available. For troubleshooting this error,  see ServiceUnavailable in the Amazon Bedrock User Guide
        case serviceUnavailableException(ServiceUnavailableException)
        /// Your request was denied due to exceeding the account quotas for Amazon Bedrock. For troubleshooting this error, see ThrottlingException in the Amazon Bedrock User Guide
        case throttlingException(ThrottlingException)
        /// The input fails to satisfy the constraints specified by Amazon Bedrock. For troubleshooting this error,  see ValidationError in the Amazon Bedrock User Guide
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .contentBlockDelta:
                let value = try container.decode(ContentBlockDeltaEvent.self, forKey: .contentBlockDelta)
                self = .contentBlockDelta(value)
            case .contentBlockStart:
                let value = try container.decode(ContentBlockStartEvent.self, forKey: .contentBlockStart)
                self = .contentBlockStart(value)
            case .contentBlockStop:
                let value = try container.decode(ContentBlockStopEvent.self, forKey: .contentBlockStop)
                self = .contentBlockStop(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .messageStart:
                let value = try container.decode(MessageStartEvent.self, forKey: .messageStart)
                self = .messageStart(value)
            case .messageStop:
                let value = try container.decode(MessageStopEvent.self, forKey: .messageStop)
                self = .messageStop(value)
            case .metadata:
                let value = try container.decode(ConverseStreamMetadataEvent.self, forKey: .metadata)
                self = .metadata(value)
            case .modelStreamErrorException:
                let value = try container.decode(ModelStreamErrorException.self, forKey: .modelStreamErrorException)
                self = .modelStreamErrorException(value)
            case .serviceUnavailableException:
                let value = try container.decode(ServiceUnavailableException.self, forKey: .serviceUnavailableException)
                self = .serviceUnavailableException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contentBlockDelta = "contentBlockDelta"
            case contentBlockStart = "contentBlockStart"
            case contentBlockStop = "contentBlockStop"
            case internalServerException = "internalServerException"
            case messageStart = "messageStart"
            case messageStop = "messageStop"
            case metadata = "metadata"
            case modelStreamErrorException = "modelStreamErrorException"
            case serviceUnavailableException = "serviceUnavailableException"
            case throttlingException = "throttlingException"
            case validationException = "validationException"
        }
    }

    public enum GuardrailContentBlock: AWSEncodableShape, Sendable {
        /// Image within guardrail content block to be evaluated by the guardrail.
        case image(GuardrailImageBlock)
        /// Text within content block to be evaluated by the guardrail.
        case text(GuardrailTextBlock)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .image(let value):
                try container.encode(value, forKey: .image)
            case .text(let value):
                try container.encode(value, forKey: .text)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case image = "image"
            case text = "text"
        }
    }

    public enum GuardrailConverseContentBlock: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Image within converse content block to be evaluated by the guardrail.
        case image(GuardrailConverseImageBlock)
        /// The text to guard.
        case text(GuardrailConverseTextBlock)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .image:
                let value = try container.decode(GuardrailConverseImageBlock.self, forKey: .image)
                self = .image(value)
            case .text:
                let value = try container.decode(GuardrailConverseTextBlock.self, forKey: .text)
                self = .text(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .image(let value):
                try container.encode(value, forKey: .image)
            case .text(let value):
                try container.encode(value, forKey: .text)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case image = "image"
            case text = "text"
        }
    }

    public enum InvokeModelWithBidirectionalStreamOutput: AWSDecodableShape, Sendable {
        /// The speech chunk that was provided as output from the invocation step.
        case chunk(BidirectionalOutputPayloadPart)
        /// The request encountered an unknown internal error.
        case internalServerException(InternalServerException)
        /// The request encountered an error with the model stream.
        case modelStreamErrorException(ModelStreamErrorException)
        /// The connection was closed because a request was not received within the timeout period.
        case modelTimeoutException(ModelTimeoutException)
        /// The request has failed due to a temporary failure of the server.
        case serviceUnavailableException(ServiceUnavailableException)
        /// The request was denied due to request throttling.
        case throttlingException(ThrottlingException)
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .chunk:
                let value = try container.decode(BidirectionalOutputPayloadPart.self, forKey: .chunk)
                self = .chunk(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .modelStreamErrorException:
                let value = try container.decode(ModelStreamErrorException.self, forKey: .modelStreamErrorException)
                self = .modelStreamErrorException(value)
            case .modelTimeoutException:
                let value = try container.decode(ModelTimeoutException.self, forKey: .modelTimeoutException)
                self = .modelTimeoutException(value)
            case .serviceUnavailableException:
                let value = try container.decode(ServiceUnavailableException.self, forKey: .serviceUnavailableException)
                self = .serviceUnavailableException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case chunk = "chunk"
            case internalServerException = "internalServerException"
            case modelStreamErrorException = "modelStreamErrorException"
            case modelTimeoutException = "modelTimeoutException"
            case serviceUnavailableException = "serviceUnavailableException"
            case throttlingException = "throttlingException"
            case validationException = "validationException"
        }
    }

    public enum ReasoningContentBlock: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The reasoning that the model used to return the output.
        case reasoningText(ReasoningTextBlock)
        /// The content in the reasoning that was encrypted by the model provider for safety reasons. The encryption doesn't affect the quality of responses.
        case redactedContent(AWSBase64Data)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .reasoningText:
                let value = try container.decode(ReasoningTextBlock.self, forKey: .reasoningText)
                self = .reasoningText(value)
            case .redactedContent:
                let value = try container.decode(AWSBase64Data.self, forKey: .redactedContent)
                self = .redactedContent(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .reasoningText(let value):
                try container.encode(value, forKey: .reasoningText)
            case .redactedContent(let value):
                try container.encode(value, forKey: .redactedContent)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case reasoningText = "reasoningText"
            case redactedContent = "redactedContent"
        }
    }

    public enum ReasoningContentBlockDelta: AWSDecodableShape, Sendable {
        /// The content in the reasoning that was encrypted by the model provider for safety reasons. The encryption doesn't affect the quality of responses.
        case redactedContent(AWSBase64Data)
        /// A token that verifies that the reasoning text was generated by the model. If you pass a reasoning block back to the API in a multi-turn conversation, include the text and its signature unmodified.
        case signature(String)
        /// The reasoning that the model used to return the output.
        case text(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .redactedContent:
                let value = try container.decode(AWSBase64Data.self, forKey: .redactedContent)
                self = .redactedContent(value)
            case .signature:
                let value = try container.decode(String.self, forKey: .signature)
                self = .signature(value)
            case .text:
                let value = try container.decode(String.self, forKey: .text)
                self = .text(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case redactedContent = "redactedContent"
            case signature = "signature"
            case text = "text"
        }
    }

    public enum ResponseStream: AWSDecodableShape, Sendable {
        /// Content included in the response.
        case chunk(PayloadPart)
        /// An internal server error occurred. Retry your request.
        case internalServerException(InternalServerException)
        /// An error occurred while streaming the response. Retry your request.
        case modelStreamErrorException(ModelStreamErrorException)
        /// The request took too long to process. Processing time exceeded the model timeout length.
        case modelTimeoutException(ModelTimeoutException)
        /// The service isn't available. Try again later.
        case serviceUnavailableException(ServiceUnavailableException)
        /// Your request was throttled because of service-wide limitations. Resubmit your request later or in a different region. You can also purchase Provisioned Throughput to increase the rate or number of tokens you can process.
        case throttlingException(ThrottlingException)
        /// Input validation failed. Check your request parameters and retry the request.
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .chunk:
                let value = try container.decode(PayloadPart.self, forKey: .chunk)
                self = .chunk(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .modelStreamErrorException:
                let value = try container.decode(ModelStreamErrorException.self, forKey: .modelStreamErrorException)
                self = .modelStreamErrorException(value)
            case .modelTimeoutException:
                let value = try container.decode(ModelTimeoutException.self, forKey: .modelTimeoutException)
                self = .modelTimeoutException(value)
            case .serviceUnavailableException:
                let value = try container.decode(ServiceUnavailableException.self, forKey: .serviceUnavailableException)
                self = .serviceUnavailableException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case chunk = "chunk"
            case internalServerException = "internalServerException"
            case modelStreamErrorException = "modelStreamErrorException"
            case modelTimeoutException = "modelTimeoutException"
            case serviceUnavailableException = "serviceUnavailableException"
            case throttlingException = "throttlingException"
            case validationException = "validationException"
        }
    }

    public enum SystemContentBlock: AWSEncodableShape, Sendable {
        /// CachePoint to include in the system prompt.
        case cachePoint(CachePointBlock)
        /// A content block to assess with the guardrail. Use with the Converse or ConverseStream API operations.  For more information, see Use a guardrail with the Converse API in the Amazon Bedrock User Guide.
        case guardContent(GuardrailConverseContentBlock)
        /// A system prompt for the model.
        case text(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .cachePoint(let value):
                try container.encode(value, forKey: .cachePoint)
            case .guardContent(let value):
                try container.encode(value, forKey: .guardContent)
            case .text(let value):
                try container.encode(value, forKey: .text)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .text(let value):
                try self.validate(value, name: "text", parent: name, min: 1)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cachePoint = "cachePoint"
            case guardContent = "guardContent"
            case text = "text"
        }
    }

    public enum Tool: AWSEncodableShape, Sendable {
        /// CachePoint to include in the tool configuration.
        case cachePoint(CachePointBlock)
        /// The specfication for the tool.
        case toolSpec(ToolSpecification)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .cachePoint(let value):
                try container.encode(value, forKey: .cachePoint)
            case .toolSpec(let value):
                try container.encode(value, forKey: .toolSpec)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .toolSpec(let value):
                try value.validate(name: "\(name).toolSpec")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cachePoint = "cachePoint"
            case toolSpec = "toolSpec"
        }
    }

    public enum ToolChoice: AWSEncodableShape, Sendable {
        /// The model must request at least one tool (no text is generated).
        case any(AnyToolChoice)
        /// (Default). The Model automatically decides if a tool should be called or whether to generate text instead.
        case auto(AutoToolChoice)
        /// The Model must request the specified tool.  Only supported by Anthropic Claude 3 models.
        case tool(SpecificToolChoice)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .any(let value):
                try container.encode(value, forKey: .any)
            case .auto(let value):
                try container.encode(value, forKey: .auto)
            case .tool(let value):
                try container.encode(value, forKey: .tool)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .tool(let value):
                try value.validate(name: "\(name).tool")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case any = "any"
            case auto = "auto"
            case tool = "tool"
        }
    }

    public enum ToolResultContentBlock: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A tool result that is a document.
        case document(DocumentBlock)
        /// A tool result that is an image.  This field is only supported by Anthropic Claude 3 models.
        case image(ImageBlock)
        /// A tool result that is JSON format data.
        case json(AWSDocument)
        /// A tool result that is text.
        case text(String)
        /// A tool result that is video.
        case video(VideoBlock)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .document:
                let value = try container.decode(DocumentBlock.self, forKey: .document)
                self = .document(value)
            case .image:
                let value = try container.decode(ImageBlock.self, forKey: .image)
                self = .image(value)
            case .json:
                let value = try container.decode(AWSDocument.self, forKey: .json)
                self = .json(value)
            case .text:
                let value = try container.decode(String.self, forKey: .text)
                self = .text(value)
            case .video:
                let value = try container.decode(VideoBlock.self, forKey: .video)
                self = .video(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .document(let value):
                try container.encode(value, forKey: .document)
            case .image(let value):
                try container.encode(value, forKey: .image)
            case .json(let value):
                try container.encode(value, forKey: .json)
            case .text(let value):
                try container.encode(value, forKey: .text)
            case .video(let value):
                try container.encode(value, forKey: .video)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .video(let value):
                try value.validate(name: "\(name).video")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
            case image = "image"
            case json = "json"
            case text = "text"
            case video = "video"
        }
    }

    public enum VideoSource: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Video content encoded in base64.
        case bytes(AWSBase64Data)
        /// The location of a video object in an S3 bucket.
        case s3Location(S3Location)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .bytes:
                let value = try container.decode(AWSBase64Data.self, forKey: .bytes)
                self = .bytes(value)
            case .s3Location:
                let value = try container.decode(S3Location.self, forKey: .s3Location)
                self = .s3Location(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .bytes(let value):
                try container.encode(value, forKey: .bytes)
            case .s3Location(let value):
                try container.encode(value, forKey: .s3Location)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3Location(let value):
                try value.validate(name: "\(name).s3Location")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
            case s3Location = "s3Location"
        }
    }

    // MARK: Shapes

    public struct AnyToolChoice: AWSEncodableShape {
        public init() {}
    }

    public struct ApplyGuardrailRequest: AWSEncodableShape {
        /// The content details used in the request to apply the guardrail.
        public let content: [GuardrailContentBlock]
        /// The guardrail identifier used in the request to apply the guardrail.
        public let guardrailIdentifier: String
        /// The guardrail version used in the request to apply the guardrail.
        public let guardrailVersion: String
        /// Specifies the scope of the output that you get in the response. Set to FULL to return the entire output, including any detected and non-detected entries in the response for enhanced debugging. Note that the full output scope doesn't apply to word filters or regex in sensitive information filters. It does apply to all other filtering policies, including sensitive information with filters that can detect personally identifiable information (PII).
        public let outputScope: GuardrailOutputScope?
        /// The source of data used in the request to apply the guardrail.
        public let source: GuardrailContentSource

        @inlinable
        public init(content: [GuardrailContentBlock], guardrailIdentifier: String, guardrailVersion: String, outputScope: GuardrailOutputScope? = nil, source: GuardrailContentSource) {
            self.content = content
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
            self.outputScope = outputScope
            self.source = source
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.content, forKey: .content)
            request.encodePath(self.guardrailIdentifier, key: "guardrailIdentifier")
            request.encodePath(self.guardrailVersion, key: "guardrailVersion")
            try container.encodeIfPresent(self.outputScope, forKey: .outputScope)
            try container.encode(self.source, forKey: .source)
        }

        public func validate(name: String) throws {
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^(([1-9][0-9]{0,7})|(DRAFT))$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case outputScope = "outputScope"
            case source = "source"
        }
    }

    public struct ApplyGuardrailResponse: AWSDecodableShape {
        /// The action taken in the response from the guardrail.
        public let action: GuardrailAction
        /// The reason for the action taken when harmful content is detected.
        public let actionReason: String?
        /// The assessment details in the response from the guardrail.
        public let assessments: [GuardrailAssessment]
        /// The guardrail coverage details in the apply guardrail response.
        public let guardrailCoverage: GuardrailCoverage?
        /// The output details in the response from the guardrail.
        public let outputs: [GuardrailOutputContent]
        /// The usage details in the response from the guardrail.
        public let usage: GuardrailUsage

        @inlinable
        public init(action: GuardrailAction, actionReason: String? = nil, assessments: [GuardrailAssessment], guardrailCoverage: GuardrailCoverage? = nil, outputs: [GuardrailOutputContent], usage: GuardrailUsage) {
            self.action = action
            self.actionReason = actionReason
            self.assessments = assessments
            self.guardrailCoverage = guardrailCoverage
            self.outputs = outputs
            self.usage = usage
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case actionReason = "actionReason"
            case assessments = "assessments"
            case guardrailCoverage = "guardrailCoverage"
            case outputs = "outputs"
            case usage = "usage"
        }
    }

    public struct AsyncInvokeS3OutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// If the bucket belongs to another AWS account, specify that account's ID.
        public let bucketOwner: String?
        /// A KMS encryption key ID.
        public let kmsKeyId: String?
        /// An object URI starting with s3://.
        public let s3Uri: String

        @inlinable
        public init(bucketOwner: String? = nil, kmsKeyId: String? = nil, s3Uri: String) {
            self.bucketOwner = bucketOwner
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketOwner, name: "bucketOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^arn:aws(-[^:]+)?:kms:[a-zA-Z0-9-]*:[0-9]{12}:((key/[a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+))$")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketOwner = "bucketOwner"
            case kmsKeyId = "kmsKeyId"
            case s3Uri = "s3Uri"
        }
    }

    public struct AsyncInvokeSummary: AWSDecodableShape {
        /// The invocation's idempotency token.
        public let clientRequestToken: String?
        /// When the invocation ended.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// An error message.
        public let failureMessage: String?
        /// The invocation's ARN.
        public let invocationArn: String
        /// When the invocation was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// The invoked model's ARN.
        public let modelArn: String
        /// The invocation's output data settings.
        public let outputDataConfig: AsyncInvokeOutputDataConfig
        /// The invocation's status.
        public let status: AsyncInvokeStatus?
        /// When the invocation was submitted.
        @CustomCoding<ISO8601DateCoder>
        public var submitTime: Date

        @inlinable
        public init(clientRequestToken: String? = nil, endTime: Date? = nil, failureMessage: String? = nil, invocationArn: String, lastModifiedTime: Date? = nil, modelArn: String, outputDataConfig: AsyncInvokeOutputDataConfig, status: AsyncInvokeStatus? = nil, submitTime: Date) {
            self.clientRequestToken = clientRequestToken
            self.endTime = endTime
            self.failureMessage = failureMessage
            self.invocationArn = invocationArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArn = modelArn
            self.outputDataConfig = outputDataConfig
            self.status = status
            self.submitTime = submitTime
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case endTime = "endTime"
            case failureMessage = "failureMessage"
            case invocationArn = "invocationArn"
            case lastModifiedTime = "lastModifiedTime"
            case modelArn = "modelArn"
            case outputDataConfig = "outputDataConfig"
            case status = "status"
            case submitTime = "submitTime"
        }
    }

    public struct AutoToolChoice: AWSEncodableShape {
        public init() {}
    }

    public struct BidirectionalInputPayloadPart: AWSEncodableShape {
        /// The audio content for the bidirectional input.
        public let bytes: AWSBase64Data?

        @inlinable
        public init(bytes: AWSBase64Data? = nil) {
            self.bytes = bytes
        }

        public func validate(name: String) throws {
            try self.validate(self.bytes, name: "bytes", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
        }
    }

    public struct BidirectionalOutputPayloadPart: AWSDecodableShape {
        /// The speech output of the bidirectional stream.
        public let bytes: AWSBase64Data?

        @inlinable
        public init(bytes: AWSBase64Data? = nil) {
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
        }
    }

    public struct CachePointBlock: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the type of cache point within the CachePointBlock.
        public let type: CachePointType

        @inlinable
        public init(type: CachePointType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct ContentBlockDeltaEvent: AWSDecodableShape {
        /// The block index for a content block delta event.
        public let contentBlockIndex: Int
        /// The delta for a content block delta event.
        public let delta: ContentBlockDelta

        @inlinable
        public init(contentBlockIndex: Int, delta: ContentBlockDelta) {
            self.contentBlockIndex = contentBlockIndex
            self.delta = delta
        }

        private enum CodingKeys: String, CodingKey {
            case contentBlockIndex = "contentBlockIndex"
            case delta = "delta"
        }
    }

    public struct ContentBlockStartEvent: AWSDecodableShape {
        /// The index for a content block start event.
        public let contentBlockIndex: Int
        /// Start information about a content block start event.
        public let start: ContentBlockStart

        @inlinable
        public init(contentBlockIndex: Int, start: ContentBlockStart) {
            self.contentBlockIndex = contentBlockIndex
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case contentBlockIndex = "contentBlockIndex"
            case start = "start"
        }
    }

    public struct ContentBlockStopEvent: AWSDecodableShape {
        /// The index for a content block.
        public let contentBlockIndex: Int

        @inlinable
        public init(contentBlockIndex: Int) {
            self.contentBlockIndex = contentBlockIndex
        }

        private enum CodingKeys: String, CodingKey {
            case contentBlockIndex = "contentBlockIndex"
        }
    }

    public struct ConverseMetrics: AWSDecodableShape {
        /// The latency of the call to Converse, in milliseconds.
        public let latencyMs: Int64

        @inlinable
        public init(latencyMs: Int64) {
            self.latencyMs = latencyMs
        }

        private enum CodingKeys: String, CodingKey {
            case latencyMs = "latencyMs"
        }
    }

    public struct ConverseRequest: AWSEncodableShape {
        /// Additional inference parameters that the model supports, beyond the base set of inference parameters that Converse and ConverseStream support in the inferenceConfig field. For more information, see Model parameters.
        public let additionalModelRequestFields: AWSDocument?
        /// Additional model parameters field paths to return in the response. Converse and ConverseStream return the requested fields as a JSON Pointer object in the additionalModelResponseFields field. The following is example JSON for additionalModelResponseFieldPaths.  [ "/stop_sequence" ]  For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation.  Converse and ConverseStream reject an empty JSON Pointer or incorrectly structured JSON Pointer with a 400 error code. if the JSON Pointer is valid, but the requested field is not in the model response, it is ignored by Converse.
        public let additionalModelResponseFieldPaths: [String]?
        /// Configuration information for a guardrail that you want to use in the request. If you include guardContent blocks in the content field in the messages field, the guardrail operates only on those messages. If you include no guardContent blocks, the guardrail operates on all messages in the request body and in any included prompt resource.
        public let guardrailConfig: GuardrailConfiguration?
        /// Inference parameters to pass to the model. Converse and ConverseStream support a base set of inference parameters. If you need to pass additional parameters that the model supports, use the additionalModelRequestFields request field.
        public let inferenceConfig: InferenceConfiguration?
        /// The messages that you want to send to the model.
        public let messages: [Message]?
        /// Specifies the model or throughput with which to run inference, or the prompt resource to use in inference. The value depends on the resource that you use:   If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see Amazon Bedrock base model IDs (on-demand throughput) in the Amazon Bedrock User Guide.   If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see Supported Regions and models for cross-region inference in the Amazon Bedrock User Guide.   If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see Run inference using a Provisioned Throughput in the Amazon Bedrock User Guide.   If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see Use a custom model in Amazon Bedrock in the Amazon Bedrock User Guide.   To include a prompt that was defined in Prompt management, specify the ARN of the prompt version to use.   The Converse API doesn't support imported models.
        public let modelId: String
        /// Model performance settings for the request.
        public let performanceConfig: PerformanceConfiguration?
        /// Contains a map of variables in a prompt from Prompt management to objects containing the values to fill in for them when running model invocation. This field is ignored if you don't specify a prompt resource in the modelId field.
        public let promptVariables: [String: PromptVariableValues]?
        /// Key-value pairs that you can use to filter invocation logs.
        public let requestMetadata: [String: String]?
        /// A prompt that provides instructions or context to the model about the task it should perform, or the persona it should adopt during the conversation.
        public let system: [SystemContentBlock]?
        /// Configuration information for the tools that the model can use when generating a response.  For information about models that support tool use, see  Supported models and model features.
        public let toolConfig: ToolConfiguration?

        @inlinable
        public init(additionalModelRequestFields: AWSDocument? = nil, additionalModelResponseFieldPaths: [String]? = nil, guardrailConfig: GuardrailConfiguration? = nil, inferenceConfig: InferenceConfiguration? = nil, messages: [Message]? = nil, modelId: String, performanceConfig: PerformanceConfiguration? = nil, promptVariables: [String: PromptVariableValues]? = nil, requestMetadata: [String: String]? = nil, system: [SystemContentBlock]? = nil, toolConfig: ToolConfiguration? = nil) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.additionalModelResponseFieldPaths = additionalModelResponseFieldPaths
            self.guardrailConfig = guardrailConfig
            self.inferenceConfig = inferenceConfig
            self.messages = messages
            self.modelId = modelId
            self.performanceConfig = performanceConfig
            self.promptVariables = promptVariables
            self.requestMetadata = requestMetadata
            self.system = system
            self.toolConfig = toolConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalModelRequestFields, forKey: .additionalModelRequestFields)
            try container.encodeIfPresent(self.additionalModelResponseFieldPaths, forKey: .additionalModelResponseFieldPaths)
            try container.encodeIfPresent(self.guardrailConfig, forKey: .guardrailConfig)
            try container.encodeIfPresent(self.inferenceConfig, forKey: .inferenceConfig)
            try container.encodeIfPresent(self.messages, forKey: .messages)
            request.encodePath(self.modelId, key: "modelId")
            try container.encodeIfPresent(self.performanceConfig, forKey: .performanceConfig)
            try container.encodeIfPresent(self.promptVariables, forKey: .promptVariables)
            try container.encodeIfPresent(self.requestMetadata, forKey: .requestMetadata)
            try container.encodeIfPresent(self.system, forKey: .system)
            try container.encodeIfPresent(self.toolConfig, forKey: .toolConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalModelResponseFieldPaths, name: "additionalModelResponseFieldPaths", parent: name, max: 10)
            try self.guardrailConfig?.validate(name: "\(name).guardrailConfig")
            try self.inferenceConfig?.validate(name: "\(name).inferenceConfig")
            try self.messages?.forEach {
                try $0.validate(name: "\(name).messages[]")
            }
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:imported-model/[a-z0-9]{12})|([0-9]{12}:provisioned-model/[a-z0-9]{12})|([0-9]{12}:(inference-profile|application-inference-profile)/[a-zA-Z0-9-:.]+)))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)|([a-zA-Z0-9-:.]+)|(^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10}(?::[0-9]{1,5})?))$|(^arn:aws:sagemaker:[a-z0-9-]+:[0-9]{12}:endpoint/[a-zA-Z0-9-]+$)|(^arn:aws(-[^:]+)?:bedrock:([0-9a-z-]{1,20}):([0-9]{12}):(default-)?prompt-router/[a-zA-Z0-9-:.]+$)$")
            try self.validate(self.requestMetadata, name: "requestMetadata", parent: name, max: 16)
            try self.validate(self.requestMetadata, name: "requestMetadata", parent: name, min: 1)
            try self.system?.forEach {
                try $0.validate(name: "\(name).system[]")
            }
            try self.toolConfig?.validate(name: "\(name).toolConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case additionalModelResponseFieldPaths = "additionalModelResponseFieldPaths"
            case guardrailConfig = "guardrailConfig"
            case inferenceConfig = "inferenceConfig"
            case messages = "messages"
            case performanceConfig = "performanceConfig"
            case promptVariables = "promptVariables"
            case requestMetadata = "requestMetadata"
            case system = "system"
            case toolConfig = "toolConfig"
        }
    }

    public struct ConverseResponse: AWSDecodableShape {
        /// Additional fields in the response that are unique to the model.
        public let additionalModelResponseFields: AWSDocument?
        /// Metrics for the call to Converse.
        public let metrics: ConverseMetrics
        /// The result from the call to Converse.
        public let output: ConverseOutput
        /// Model performance settings for the request.
        public let performanceConfig: PerformanceConfiguration?
        /// The reason why the model stopped generating output.
        public let stopReason: StopReason
        /// A trace object that contains information about the Guardrail behavior.
        public let trace: ConverseTrace?
        /// The total number of tokens used in the call to Converse. The total includes the tokens input to the model and the tokens generated by the model.
        public let usage: TokenUsage

        @inlinable
        public init(additionalModelResponseFields: AWSDocument? = nil, metrics: ConverseMetrics, output: ConverseOutput, performanceConfig: PerformanceConfiguration? = nil, stopReason: StopReason, trace: ConverseTrace? = nil, usage: TokenUsage) {
            self.additionalModelResponseFields = additionalModelResponseFields
            self.metrics = metrics
            self.output = output
            self.performanceConfig = performanceConfig
            self.stopReason = stopReason
            self.trace = trace
            self.usage = usage
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelResponseFields = "additionalModelResponseFields"
            case metrics = "metrics"
            case output = "output"
            case performanceConfig = "performanceConfig"
            case stopReason = "stopReason"
            case trace = "trace"
            case usage = "usage"
        }
    }

    public struct ConverseStreamMetadataEvent: AWSDecodableShape {
        /// The metrics for the conversation stream metadata event.
        public let metrics: ConverseStreamMetrics
        /// Model performance configuration metadata for the conversation stream event.
        public let performanceConfig: PerformanceConfiguration?
        /// The trace object in the response from ConverseStream that contains information about the guardrail behavior.
        public let trace: ConverseStreamTrace?
        /// Usage information for the conversation stream event.
        public let usage: TokenUsage

        @inlinable
        public init(metrics: ConverseStreamMetrics, performanceConfig: PerformanceConfiguration? = nil, trace: ConverseStreamTrace? = nil, usage: TokenUsage) {
            self.metrics = metrics
            self.performanceConfig = performanceConfig
            self.trace = trace
            self.usage = usage
        }

        private enum CodingKeys: String, CodingKey {
            case metrics = "metrics"
            case performanceConfig = "performanceConfig"
            case trace = "trace"
            case usage = "usage"
        }
    }

    public struct ConverseStreamMetrics: AWSDecodableShape {
        /// The latency for the streaming request, in milliseconds.
        public let latencyMs: Int64

        @inlinable
        public init(latencyMs: Int64) {
            self.latencyMs = latencyMs
        }

        private enum CodingKeys: String, CodingKey {
            case latencyMs = "latencyMs"
        }
    }

    public struct ConverseStreamRequest: AWSEncodableShape {
        /// Additional inference parameters that the model supports, beyond the base set of inference parameters that Converse and ConverseStream support in the inferenceConfig field. For more information, see Model parameters.
        public let additionalModelRequestFields: AWSDocument?
        /// Additional model parameters field paths to return in the response. Converse and ConverseStream return the requested fields as a JSON Pointer object in the additionalModelResponseFields field. The following is example JSON for additionalModelResponseFieldPaths.  [ "/stop_sequence" ]  For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation.  Converse and ConverseStream reject an empty JSON Pointer or incorrectly structured JSON Pointer with a 400 error code. if the JSON Pointer is valid, but the requested field is not in the model response, it is ignored by Converse.
        public let additionalModelResponseFieldPaths: [String]?
        /// Configuration information for a guardrail that you want to use in the request. If you include guardContent blocks in the content field in the messages field, the guardrail operates only on those messages. If you include no guardContent blocks, the guardrail operates on all messages in the request body and in any included prompt resource.
        public let guardrailConfig: GuardrailStreamConfiguration?
        /// Inference parameters to pass to the model. Converse and ConverseStream support a base set of inference parameters. If you need to pass additional parameters that the model supports, use the additionalModelRequestFields request field.
        public let inferenceConfig: InferenceConfiguration?
        /// The messages that you want to send to the model.
        public let messages: [Message]?
        /// Specifies the model or throughput with which to run inference, or the prompt resource to use in inference. The value depends on the resource that you use:   If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see Amazon Bedrock base model IDs (on-demand throughput) in the Amazon Bedrock User Guide.   If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see Supported Regions and models for cross-region inference in the Amazon Bedrock User Guide.   If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see Run inference using a Provisioned Throughput in the Amazon Bedrock User Guide.   If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see Use a custom model in Amazon Bedrock in the Amazon Bedrock User Guide.   To include a prompt that was defined in Prompt management, specify the ARN of the prompt version to use.   The Converse API doesn't support imported models.
        public let modelId: String
        /// Model performance settings for the request.
        public let performanceConfig: PerformanceConfiguration?
        /// Contains a map of variables in a prompt from Prompt management to objects containing the values to fill in for them when running model invocation. This field is ignored if you don't specify a prompt resource in the modelId field.
        public let promptVariables: [String: PromptVariableValues]?
        /// Key-value pairs that you can use to filter invocation logs.
        public let requestMetadata: [String: String]?
        /// A prompt that provides instructions or context to the model about the task it should perform, or the persona it should adopt during the conversation.
        public let system: [SystemContentBlock]?
        /// Configuration information for the tools that the model can use when generating a response. For information about models that support streaming tool use, see  Supported models and model features.
        public let toolConfig: ToolConfiguration?

        @inlinable
        public init(additionalModelRequestFields: AWSDocument? = nil, additionalModelResponseFieldPaths: [String]? = nil, guardrailConfig: GuardrailStreamConfiguration? = nil, inferenceConfig: InferenceConfiguration? = nil, messages: [Message]? = nil, modelId: String, performanceConfig: PerformanceConfiguration? = nil, promptVariables: [String: PromptVariableValues]? = nil, requestMetadata: [String: String]? = nil, system: [SystemContentBlock]? = nil, toolConfig: ToolConfiguration? = nil) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.additionalModelResponseFieldPaths = additionalModelResponseFieldPaths
            self.guardrailConfig = guardrailConfig
            self.inferenceConfig = inferenceConfig
            self.messages = messages
            self.modelId = modelId
            self.performanceConfig = performanceConfig
            self.promptVariables = promptVariables
            self.requestMetadata = requestMetadata
            self.system = system
            self.toolConfig = toolConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalModelRequestFields, forKey: .additionalModelRequestFields)
            try container.encodeIfPresent(self.additionalModelResponseFieldPaths, forKey: .additionalModelResponseFieldPaths)
            try container.encodeIfPresent(self.guardrailConfig, forKey: .guardrailConfig)
            try container.encodeIfPresent(self.inferenceConfig, forKey: .inferenceConfig)
            try container.encodeIfPresent(self.messages, forKey: .messages)
            request.encodePath(self.modelId, key: "modelId")
            try container.encodeIfPresent(self.performanceConfig, forKey: .performanceConfig)
            try container.encodeIfPresent(self.promptVariables, forKey: .promptVariables)
            try container.encodeIfPresent(self.requestMetadata, forKey: .requestMetadata)
            try container.encodeIfPresent(self.system, forKey: .system)
            try container.encodeIfPresent(self.toolConfig, forKey: .toolConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalModelResponseFieldPaths, name: "additionalModelResponseFieldPaths", parent: name, max: 10)
            try self.guardrailConfig?.validate(name: "\(name).guardrailConfig")
            try self.inferenceConfig?.validate(name: "\(name).inferenceConfig")
            try self.messages?.forEach {
                try $0.validate(name: "\(name).messages[]")
            }
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:imported-model/[a-z0-9]{12})|([0-9]{12}:provisioned-model/[a-z0-9]{12})|([0-9]{12}:(inference-profile|application-inference-profile)/[a-zA-Z0-9-:.]+)))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)|([a-zA-Z0-9-:.]+)|(^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10}(?::[0-9]{1,5})?))$|(^arn:aws:sagemaker:[a-z0-9-]+:[0-9]{12}:endpoint/[a-zA-Z0-9-]+$)|(^arn:aws(-[^:]+)?:bedrock:([0-9a-z-]{1,20}):([0-9]{12}):(default-)?prompt-router/[a-zA-Z0-9-:.]+$)$")
            try self.validate(self.requestMetadata, name: "requestMetadata", parent: name, max: 16)
            try self.validate(self.requestMetadata, name: "requestMetadata", parent: name, min: 1)
            try self.system?.forEach {
                try $0.validate(name: "\(name).system[]")
            }
            try self.toolConfig?.validate(name: "\(name).toolConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case additionalModelResponseFieldPaths = "additionalModelResponseFieldPaths"
            case guardrailConfig = "guardrailConfig"
            case inferenceConfig = "inferenceConfig"
            case messages = "messages"
            case performanceConfig = "performanceConfig"
            case promptVariables = "promptVariables"
            case requestMetadata = "requestMetadata"
            case system = "system"
            case toolConfig = "toolConfig"
        }
    }

    public struct ConverseStreamResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The output stream that the model generated.
        public let stream: AWSEventStream<ConverseStreamOutput>

        @inlinable
        public init(stream: AWSEventStream<ConverseStreamOutput>) {
            self.stream = stream
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.stream = try container.decode(AWSEventStream<ConverseStreamOutput>.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ConverseStreamTrace: AWSDecodableShape {
        /// The guardrail trace object.
        public let guardrail: GuardrailTraceAssessment?
        /// The request's prompt router.
        public let promptRouter: PromptRouterTrace?

        @inlinable
        public init(guardrail: GuardrailTraceAssessment? = nil, promptRouter: PromptRouterTrace? = nil) {
            self.guardrail = guardrail
            self.promptRouter = promptRouter
        }

        private enum CodingKeys: String, CodingKey {
            case guardrail = "guardrail"
            case promptRouter = "promptRouter"
        }
    }

    public struct ConverseTrace: AWSDecodableShape {
        /// The guardrail trace object.
        public let guardrail: GuardrailTraceAssessment?
        /// The request's prompt router.
        public let promptRouter: PromptRouterTrace?

        @inlinable
        public init(guardrail: GuardrailTraceAssessment? = nil, promptRouter: PromptRouterTrace? = nil) {
            self.guardrail = guardrail
            self.promptRouter = promptRouter
        }

        private enum CodingKeys: String, CodingKey {
            case guardrail = "guardrail"
            case promptRouter = "promptRouter"
        }
    }

    public struct DocumentBlock: AWSEncodableShape & AWSDecodableShape {
        /// The format of a document, or its extension.
        public let format: DocumentFormat
        /// A name for the document. The name can only contain the following characters:   Alphanumeric characters   Whitespace characters (no more than one in a row)   Hyphens   Parentheses   Square brackets    This field is vulnerable to prompt injections, because the model might inadvertently interpret it as instructions. Therefore, we recommend that you specify a neutral name.
        public let name: String
        /// Contains the content of the document.
        public let source: DocumentSource

        @inlinable
        public init(format: DocumentFormat, name: String, source: DocumentSource) {
            self.format = format
            self.name = name
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case name = "name"
            case source = "source"
        }
    }

    public struct GetAsyncInvokeRequest: AWSEncodableShape {
        /// The invocation's ARN.
        public let invocationArn: String

        @inlinable
        public init(invocationArn: String) {
            self.invocationArn = invocationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.invocationArn, key: "invocationArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.invocationArn, name: "invocationArn", parent: name, max: 2048)
            try self.validate(self.invocationArn, name: "invocationArn", parent: name, min: 1)
            try self.validate(self.invocationArn, name: "invocationArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:async-invoke/[a-z0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAsyncInvokeResponse: AWSDecodableShape {
        /// The invocation's idempotency token.
        public let clientRequestToken: String?
        /// When the invocation ended.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// An error message.
        public let failureMessage: String?
        /// The invocation's ARN.
        public let invocationArn: String
        /// The invocation's last modified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// The invocation's model ARN.
        public let modelArn: String
        /// Output data settings.
        public let outputDataConfig: AsyncInvokeOutputDataConfig
        /// The invocation's status.
        public let status: AsyncInvokeStatus
        /// When the invocation request was submitted.
        @CustomCoding<ISO8601DateCoder>
        public var submitTime: Date

        @inlinable
        public init(clientRequestToken: String? = nil, endTime: Date? = nil, failureMessage: String? = nil, invocationArn: String, lastModifiedTime: Date? = nil, modelArn: String, outputDataConfig: AsyncInvokeOutputDataConfig, status: AsyncInvokeStatus, submitTime: Date) {
            self.clientRequestToken = clientRequestToken
            self.endTime = endTime
            self.failureMessage = failureMessage
            self.invocationArn = invocationArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArn = modelArn
            self.outputDataConfig = outputDataConfig
            self.status = status
            self.submitTime = submitTime
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case endTime = "endTime"
            case failureMessage = "failureMessage"
            case invocationArn = "invocationArn"
            case lastModifiedTime = "lastModifiedTime"
            case modelArn = "modelArn"
            case outputDataConfig = "outputDataConfig"
            case status = "status"
            case submitTime = "submitTime"
        }
    }

    public struct GuardrailAssessment: AWSDecodableShape {
        /// The content policy.
        public let contentPolicy: GuardrailContentPolicyAssessment?
        /// The contextual grounding policy used for the guardrail assessment.
        public let contextualGroundingPolicy: GuardrailContextualGroundingPolicyAssessment?
        /// The invocation metrics for the guardrail assessment.
        public let invocationMetrics: GuardrailInvocationMetrics?
        /// The sensitive information policy.
        public let sensitiveInformationPolicy: GuardrailSensitiveInformationPolicyAssessment?
        /// The topic policy.
        public let topicPolicy: GuardrailTopicPolicyAssessment?
        /// The word policy.
        public let wordPolicy: GuardrailWordPolicyAssessment?

        @inlinable
        public init(contentPolicy: GuardrailContentPolicyAssessment? = nil, contextualGroundingPolicy: GuardrailContextualGroundingPolicyAssessment? = nil, invocationMetrics: GuardrailInvocationMetrics? = nil, sensitiveInformationPolicy: GuardrailSensitiveInformationPolicyAssessment? = nil, topicPolicy: GuardrailTopicPolicyAssessment? = nil, wordPolicy: GuardrailWordPolicyAssessment? = nil) {
            self.contentPolicy = contentPolicy
            self.contextualGroundingPolicy = contextualGroundingPolicy
            self.invocationMetrics = invocationMetrics
            self.sensitiveInformationPolicy = sensitiveInformationPolicy
            self.topicPolicy = topicPolicy
            self.wordPolicy = wordPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case contentPolicy = "contentPolicy"
            case contextualGroundingPolicy = "contextualGroundingPolicy"
            case invocationMetrics = "invocationMetrics"
            case sensitiveInformationPolicy = "sensitiveInformationPolicy"
            case topicPolicy = "topicPolicy"
            case wordPolicy = "wordPolicy"
        }
    }

    public struct GuardrailConfiguration: AWSEncodableShape {
        /// The identifier for the guardrail.
        public let guardrailIdentifier: String
        /// The version of the guardrail.
        public let guardrailVersion: String
        /// The trace behavior for the guardrail.
        public let trace: GuardrailTrace?

        @inlinable
        public init(guardrailIdentifier: String, guardrailVersion: String, trace: GuardrailTrace? = nil) {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
            self.trace = trace
        }

        public func validate(name: String) throws {
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^(([1-9][0-9]{0,7})|(DRAFT))$")
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailIdentifier = "guardrailIdentifier"
            case guardrailVersion = "guardrailVersion"
            case trace = "trace"
        }
    }

    public struct GuardrailContentFilter: AWSDecodableShape {
        /// The guardrail action.
        public let action: GuardrailContentPolicyAction
        /// The guardrail confidence.
        public let confidence: GuardrailContentFilterConfidence
        /// Indicates whether content that breaches the guardrail configuration is detected.
        public let detected: Bool?
        /// The filter strength setting for the guardrail content filter.
        public let filterStrength: GuardrailContentFilterStrength?
        /// The guardrail type.
        public let type: GuardrailContentFilterType

        @inlinable
        public init(action: GuardrailContentPolicyAction, confidence: GuardrailContentFilterConfidence, detected: Bool? = nil, filterStrength: GuardrailContentFilterStrength? = nil, type: GuardrailContentFilterType) {
            self.action = action
            self.confidence = confidence
            self.detected = detected
            self.filterStrength = filterStrength
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case confidence = "confidence"
            case detected = "detected"
            case filterStrength = "filterStrength"
            case type = "type"
        }
    }

    public struct GuardrailContentPolicyAssessment: AWSDecodableShape {
        /// The content policy filters.
        public let filters: [GuardrailContentFilter]

        @inlinable
        public init(filters: [GuardrailContentFilter]) {
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct GuardrailContextualGroundingFilter: AWSDecodableShape {
        /// The action performed by the guardrails contextual grounding filter.
        public let action: GuardrailContextualGroundingPolicyAction
        /// Indicates whether content that fails the contextual grounding evaluation (grounding or relevance score less than the corresponding threshold) was detected.
        public let detected: Bool?
        /// The score generated by contextual grounding filter.
        public let score: Double
        /// The threshold used by contextual grounding filter to determine whether the content is grounded or not.
        public let threshold: Double
        /// The contextual grounding filter type.
        public let type: GuardrailContextualGroundingFilterType

        @inlinable
        public init(action: GuardrailContextualGroundingPolicyAction, detected: Bool? = nil, score: Double, threshold: Double, type: GuardrailContextualGroundingFilterType) {
            self.action = action
            self.detected = detected
            self.score = score
            self.threshold = threshold
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case detected = "detected"
            case score = "score"
            case threshold = "threshold"
            case type = "type"
        }
    }

    public struct GuardrailContextualGroundingPolicyAssessment: AWSDecodableShape {
        /// The filter details for the guardrails contextual grounding filter.
        public let filters: [GuardrailContextualGroundingFilter]?

        @inlinable
        public init(filters: [GuardrailContextualGroundingFilter]? = nil) {
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct GuardrailConverseImageBlock: AWSEncodableShape & AWSDecodableShape {
        /// The format details for the image type of the guardrail converse image block.
        public let format: GuardrailConverseImageFormat
        /// The image source (image bytes) of the guardrail converse image block.
        public let source: GuardrailConverseImageSource

        @inlinable
        public init(format: GuardrailConverseImageFormat, source: GuardrailConverseImageSource) {
            self.format = format
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case source = "source"
        }
    }

    public struct GuardrailConverseTextBlock: AWSEncodableShape & AWSDecodableShape {
        /// The qualifier details for the guardrails contextual grounding filter.
        public let qualifiers: [GuardrailConverseContentQualifier]?
        /// The text that you want to guard.
        public let text: String

        @inlinable
        public init(qualifiers: [GuardrailConverseContentQualifier]? = nil, text: String) {
            self.qualifiers = qualifiers
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case qualifiers = "qualifiers"
            case text = "text"
        }
    }

    public struct GuardrailCoverage: AWSDecodableShape {
        /// The guardrail coverage for images (the number of images that guardrails guarded).
        public let images: GuardrailImageCoverage?
        /// The text characters of the guardrail coverage details.
        public let textCharacters: GuardrailTextCharactersCoverage?

        @inlinable
        public init(images: GuardrailImageCoverage? = nil, textCharacters: GuardrailTextCharactersCoverage? = nil) {
            self.images = images
            self.textCharacters = textCharacters
        }

        private enum CodingKeys: String, CodingKey {
            case images = "images"
            case textCharacters = "textCharacters"
        }
    }

    public struct GuardrailCustomWord: AWSDecodableShape {
        /// The action for the custom word.
        public let action: GuardrailWordPolicyAction
        /// Indicates whether custom word content that breaches the guardrail configuration is detected.
        public let detected: Bool?
        /// The match for the custom word.
        public let match: String

        @inlinable
        public init(action: GuardrailWordPolicyAction, detected: Bool? = nil, match: String) {
            self.action = action
            self.detected = detected
            self.match = match
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case detected = "detected"
            case match = "match"
        }
    }

    public struct GuardrailImageBlock: AWSEncodableShape {
        /// The format details for the file type of the image blocked by the guardrail.
        public let format: GuardrailImageFormat
        /// The image source (image bytes) details of the image blocked by the guardrail.
        public let source: GuardrailImageSource

        @inlinable
        public init(format: GuardrailImageFormat, source: GuardrailImageSource) {
            self.format = format
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case source = "source"
        }
    }

    public struct GuardrailImageCoverage: AWSDecodableShape {
        /// The count (integer) of images guardrails guarded.
        public let guarded: Int?
        /// Represents the total number of images (integer) that were in the request (guarded and unguarded).
        public let total: Int?

        @inlinable
        public init(guarded: Int? = nil, total: Int? = nil) {
            self.guarded = guarded
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case guarded = "guarded"
            case total = "total"
        }
    }

    public struct GuardrailInvocationMetrics: AWSDecodableShape {
        /// The coverage details for the guardrail invocation metrics.
        public let guardrailCoverage: GuardrailCoverage?
        /// The processing latency details for the guardrail invocation metrics.
        public let guardrailProcessingLatency: Int64?
        /// The usage details for the guardrail invocation metrics.
        public let usage: GuardrailUsage?

        @inlinable
        public init(guardrailCoverage: GuardrailCoverage? = nil, guardrailProcessingLatency: Int64? = nil, usage: GuardrailUsage? = nil) {
            self.guardrailCoverage = guardrailCoverage
            self.guardrailProcessingLatency = guardrailProcessingLatency
            self.usage = usage
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailCoverage = "guardrailCoverage"
            case guardrailProcessingLatency = "guardrailProcessingLatency"
            case usage = "usage"
        }
    }

    public struct GuardrailManagedWord: AWSDecodableShape {
        /// The action for the managed word.
        public let action: GuardrailWordPolicyAction
        /// Indicates whether managed word content that breaches the guardrail configuration is detected.
        public let detected: Bool?
        /// The match for the managed word.
        public let match: String
        /// The type for the managed word.
        public let type: GuardrailManagedWordType

        @inlinable
        public init(action: GuardrailWordPolicyAction, detected: Bool? = nil, match: String, type: GuardrailManagedWordType) {
            self.action = action
            self.detected = detected
            self.match = match
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case detected = "detected"
            case match = "match"
            case type = "type"
        }
    }

    public struct GuardrailOutputContent: AWSDecodableShape {
        /// The specific text for the output content produced by the guardrail.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct GuardrailPiiEntityFilter: AWSDecodableShape {
        /// The PII entity filter action.
        public let action: GuardrailSensitiveInformationPolicyAction
        /// Indicates whether personally identifiable information (PII) that breaches the guardrail configuration is detected.
        public let detected: Bool?
        /// The PII entity filter match.
        public let match: String
        /// The PII entity filter type.
        public let type: GuardrailPiiEntityType

        @inlinable
        public init(action: GuardrailSensitiveInformationPolicyAction, detected: Bool? = nil, match: String, type: GuardrailPiiEntityType) {
            self.action = action
            self.detected = detected
            self.match = match
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case detected = "detected"
            case match = "match"
            case type = "type"
        }
    }

    public struct GuardrailRegexFilter: AWSDecodableShape {
        /// The region filter action.
        public let action: GuardrailSensitiveInformationPolicyAction
        /// Indicates whether custom regex entities that breach the guardrail configuration are detected.
        public let detected: Bool?
        /// The regesx filter match.
        public let match: String?
        /// The regex filter name.
        public let name: String?
        /// The regex query.
        public let regex: String?

        @inlinable
        public init(action: GuardrailSensitiveInformationPolicyAction, detected: Bool? = nil, match: String? = nil, name: String? = nil, regex: String? = nil) {
            self.action = action
            self.detected = detected
            self.match = match
            self.name = name
            self.regex = regex
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case detected = "detected"
            case match = "match"
            case name = "name"
            case regex = "regex"
        }
    }

    public struct GuardrailSensitiveInformationPolicyAssessment: AWSDecodableShape {
        /// The PII entities in the assessment.
        public let piiEntities: [GuardrailPiiEntityFilter]
        /// The regex queries in the assessment.
        public let regexes: [GuardrailRegexFilter]

        @inlinable
        public init(piiEntities: [GuardrailPiiEntityFilter], regexes: [GuardrailRegexFilter]) {
            self.piiEntities = piiEntities
            self.regexes = regexes
        }

        private enum CodingKeys: String, CodingKey {
            case piiEntities = "piiEntities"
            case regexes = "regexes"
        }
    }

    public struct GuardrailStreamConfiguration: AWSEncodableShape {
        /// The identifier for the guardrail.
        public let guardrailIdentifier: String
        /// The version of the guardrail.
        public let guardrailVersion: String
        /// The processing mode.  The processing mode. For more information, see Configure streaming response behavior in the Amazon Bedrock User Guide.
        public let streamProcessingMode: GuardrailStreamProcessingMode?
        /// The trace behavior for the guardrail.
        public let trace: GuardrailTrace?

        @inlinable
        public init(guardrailIdentifier: String, guardrailVersion: String, streamProcessingMode: GuardrailStreamProcessingMode? = nil, trace: GuardrailTrace? = nil) {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
            self.streamProcessingMode = streamProcessingMode
            self.trace = trace
        }

        public func validate(name: String) throws {
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^(([1-9][0-9]{0,7})|(DRAFT))$")
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailIdentifier = "guardrailIdentifier"
            case guardrailVersion = "guardrailVersion"
            case streamProcessingMode = "streamProcessingMode"
            case trace = "trace"
        }
    }

    public struct GuardrailTextBlock: AWSEncodableShape {
        /// The qualifiers describing the text block.
        public let qualifiers: [GuardrailContentQualifier]?
        /// The input text details to be evaluated by the guardrail.
        public let text: String

        @inlinable
        public init(qualifiers: [GuardrailContentQualifier]? = nil, text: String) {
            self.qualifiers = qualifiers
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case qualifiers = "qualifiers"
            case text = "text"
        }
    }

    public struct GuardrailTextCharactersCoverage: AWSDecodableShape {
        /// The text characters that were guarded by the guardrail coverage.
        public let guarded: Int?
        /// The total text characters by the guardrail coverage.
        public let total: Int?

        @inlinable
        public init(guarded: Int? = nil, total: Int? = nil) {
            self.guarded = guarded
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case guarded = "guarded"
            case total = "total"
        }
    }

    public struct GuardrailTopic: AWSDecodableShape {
        /// The action the guardrail should take when it intervenes on a topic.
        public let action: GuardrailTopicPolicyAction
        /// Indicates whether topic content that breaches the guardrail configuration is detected.
        public let detected: Bool?
        /// The name for the guardrail.
        public let name: String
        /// The type behavior that the guardrail should perform when the model detects the topic.
        public let type: GuardrailTopicType

        @inlinable
        public init(action: GuardrailTopicPolicyAction, detected: Bool? = nil, name: String, type: GuardrailTopicType) {
            self.action = action
            self.detected = detected
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case detected = "detected"
            case name = "name"
            case type = "type"
        }
    }

    public struct GuardrailTopicPolicyAssessment: AWSDecodableShape {
        /// The topics in the assessment.
        public let topics: [GuardrailTopic]

        @inlinable
        public init(topics: [GuardrailTopic]) {
            self.topics = topics
        }

        private enum CodingKeys: String, CodingKey {
            case topics = "topics"
        }
    }

    public struct GuardrailTraceAssessment: AWSDecodableShape {
        /// Provides the reason for the action taken when harmful content is detected.
        public let actionReason: String?
        /// The input assessment.
        public let inputAssessment: [String: GuardrailAssessment]?
        /// The output from the model.
        public let modelOutput: [String]?
        /// the output assessments.
        public let outputAssessments: [String: [GuardrailAssessment]]?

        @inlinable
        public init(actionReason: String? = nil, inputAssessment: [String: GuardrailAssessment]? = nil, modelOutput: [String]? = nil, outputAssessments: [String: [GuardrailAssessment]]? = nil) {
            self.actionReason = actionReason
            self.inputAssessment = inputAssessment
            self.modelOutput = modelOutput
            self.outputAssessments = outputAssessments
        }

        private enum CodingKeys: String, CodingKey {
            case actionReason = "actionReason"
            case inputAssessment = "inputAssessment"
            case modelOutput = "modelOutput"
            case outputAssessments = "outputAssessments"
        }
    }

    public struct GuardrailUsage: AWSDecodableShape {
        /// The content policy image units processed by the guardrail.
        public let contentPolicyImageUnits: Int?
        /// The content policy units processed by the guardrail.
        public let contentPolicyUnits: Int
        /// The contextual grounding policy units processed by the guardrail.
        public let contextualGroundingPolicyUnits: Int
        /// The sensitive information policy free units processed by the guardrail.
        public let sensitiveInformationPolicyFreeUnits: Int
        /// The sensitive information policy units processed by the guardrail.
        public let sensitiveInformationPolicyUnits: Int
        /// The topic policy units processed by the guardrail.
        public let topicPolicyUnits: Int
        /// The word policy units processed by the guardrail.
        public let wordPolicyUnits: Int

        @inlinable
        public init(contentPolicyImageUnits: Int? = nil, contentPolicyUnits: Int, contextualGroundingPolicyUnits: Int, sensitiveInformationPolicyFreeUnits: Int, sensitiveInformationPolicyUnits: Int, topicPolicyUnits: Int, wordPolicyUnits: Int) {
            self.contentPolicyImageUnits = contentPolicyImageUnits
            self.contentPolicyUnits = contentPolicyUnits
            self.contextualGroundingPolicyUnits = contextualGroundingPolicyUnits
            self.sensitiveInformationPolicyFreeUnits = sensitiveInformationPolicyFreeUnits
            self.sensitiveInformationPolicyUnits = sensitiveInformationPolicyUnits
            self.topicPolicyUnits = topicPolicyUnits
            self.wordPolicyUnits = wordPolicyUnits
        }

        private enum CodingKeys: String, CodingKey {
            case contentPolicyImageUnits = "contentPolicyImageUnits"
            case contentPolicyUnits = "contentPolicyUnits"
            case contextualGroundingPolicyUnits = "contextualGroundingPolicyUnits"
            case sensitiveInformationPolicyFreeUnits = "sensitiveInformationPolicyFreeUnits"
            case sensitiveInformationPolicyUnits = "sensitiveInformationPolicyUnits"
            case topicPolicyUnits = "topicPolicyUnits"
            case wordPolicyUnits = "wordPolicyUnits"
        }
    }

    public struct GuardrailWordPolicyAssessment: AWSDecodableShape {
        /// Custom words in the assessment.
        public let customWords: [GuardrailCustomWord]
        /// Managed word lists in the assessment.
        public let managedWordLists: [GuardrailManagedWord]

        @inlinable
        public init(customWords: [GuardrailCustomWord], managedWordLists: [GuardrailManagedWord]) {
            self.customWords = customWords
            self.managedWordLists = managedWordLists
        }

        private enum CodingKeys: String, CodingKey {
            case customWords = "customWords"
            case managedWordLists = "managedWordLists"
        }
    }

    public struct ImageBlock: AWSEncodableShape & AWSDecodableShape {
        /// The format of the image.
        public let format: ImageFormat
        /// The source for the image.
        public let source: ImageSource

        @inlinable
        public init(format: ImageFormat, source: ImageSource) {
            self.format = format
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case source = "source"
        }
    }

    public struct InferenceConfiguration: AWSEncodableShape {
        /// The maximum number of tokens to allow in the generated response. The default value is the maximum allowed value for the model that you are using. For more information, see Inference parameters for foundation models.
        public let maxTokens: Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public let stopSequences: [String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options. The default value is the default value for the model that you are using. For more information, see Inference parameters for foundation models.
        public let temperature: Float?
        /// The percentage of most-likely candidates that the model considers for the next token. For example, if you choose a value of 0.8 for topP, the model selects from the top 80% of the probability distribution of tokens that could be next in the sequence. The default value is the default value for the model that you are using. For more information, see Inference parameters for foundation models.
        public let topP: Float?

        @inlinable
        public init(maxTokens: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topP: Float? = nil) {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topP = topP
        }

        public func validate(name: String) throws {
            try self.stopSequences?.forEach {
                try validate($0, name: "stopSequences[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topP = "topP"
        }
    }

    public struct InternalServerException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvokeModelRequest: AWSEncodableShape {
        /// The desired MIME type of the inference body in the response. The default value is application/json.
        public let accept: String?
        /// The prompt and inference parameters in the format specified in the contentType in the header. You must provide the body in JSON format. To see the format and content of the request and response bodies for different models, refer to Inference parameters. For more information, see Run inference in the Bedrock User Guide.
        public let body: AWSHTTPBody?
        /// The MIME type of the input data in the request. You must specify application/json.
        public let contentType: String?
        /// The unique identifier of the guardrail that you want to use. If you don't provide a value, no guardrail is applied to the invocation. An error will be thrown in the following situations.   You don't provide a guardrail identifier but you specify the amazon-bedrock-guardrailConfig field in the request body.   You enable the guardrail but the contentType isn't application/json.   You provide a guardrail identifier, but guardrailVersion isn't specified.
        public let guardrailIdentifier: String?
        /// The version number for the guardrail. The value can also be DRAFT.
        public let guardrailVersion: String?
        /// The unique identifier of the model to invoke to run inference. The modelId to provide depends on the type of model or throughput that you use:   If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see Amazon Bedrock base model IDs (on-demand throughput) in the Amazon Bedrock User Guide.   If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see Supported Regions and models for cross-region inference in the Amazon Bedrock User Guide.   If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see Run inference using a Provisioned Throughput in the Amazon Bedrock User Guide.   If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see Use a custom model in Amazon Bedrock in the Amazon Bedrock User Guide.   If you use an imported model, specify the ARN of the imported model. You can get the model ARN from a successful call to CreateModelImportJob or from the Imported models page in the Amazon Bedrock console.
        public let modelId: String
        /// Model performance settings for the request.
        public let performanceConfigLatency: PerformanceConfigLatency?
        /// Specifies whether to enable or disable the Bedrock trace. If enabled, you can see the full Bedrock trace.
        public let trace: Trace?

        @inlinable
        public init(accept: String? = nil, body: AWSHTTPBody? = nil, contentType: String? = nil, guardrailIdentifier: String? = nil, guardrailVersion: String? = nil, modelId: String, performanceConfigLatency: PerformanceConfigLatency? = nil, trace: Trace? = nil) {
            self.accept = accept
            self.body = body
            self.contentType = contentType
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
            self.modelId = modelId
            self.performanceConfigLatency = performanceConfigLatency
            self.trace = trace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.accept, key: "Accept")
            try container.encode(self.body)
            request.encodeHeader(self.contentType, key: "Content-Type")
            request.encodeHeader(self.guardrailIdentifier, key: "X-Amzn-Bedrock-GuardrailIdentifier")
            request.encodeHeader(self.guardrailVersion, key: "X-Amzn-Bedrock-GuardrailVersion")
            request.encodePath(self.modelId, key: "modelId")
            request.encodeHeader(self.performanceConfigLatency, key: "X-Amzn-Bedrock-PerformanceConfig-Latency")
            request.encodeHeader(self.trace, key: "X-Amzn-Bedrock-Trace")
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 25000000)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^(([1-9][0-9]{0,7})|(DRAFT))$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:imported-model/[a-z0-9]{12})|([0-9]{12}:provisioned-model/[a-z0-9]{12})|([0-9]{12}:(inference-profile|application-inference-profile)/[a-zA-Z0-9-:.]+)))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)|([a-zA-Z0-9-:.]+)$|(^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10}(?::[0-9]{1,5})?))$|(^arn:aws:sagemaker:[a-z0-9-]+:[0-9]{12}:endpoint/[a-zA-Z0-9-]+$)|(^arn:aws(-[^:]+)?:bedrock:([0-9a-z-]{1,20}):([0-9]{12}):(default-)?prompt-router/[a-zA-Z0-9-:.]+$)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeModelResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Inference response from the model in the format specified in the contentType header. To see the format and content of the request and response bodies for different models, refer to Inference parameters.
        public let body: AWSHTTPBody
        /// The MIME type of the inference result.
        public let contentType: String
        /// Model performance settings for the request.
        public let performanceConfigLatency: PerformanceConfigLatency?

        @inlinable
        public init(body: AWSHTTPBody, contentType: String, performanceConfigLatency: PerformanceConfigLatency? = nil) {
            self.body = body
            self.contentType = contentType
            self.performanceConfigLatency = performanceConfigLatency
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.body = try container.decode(AWSHTTPBody.self)
            self.contentType = try response.decodeHeader(String.self, key: "Content-Type")
            self.performanceConfigLatency = try response.decodeHeaderIfPresent(PerformanceConfigLatency.self, key: "X-Amzn-Bedrock-PerformanceConfig-Latency")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeModelWithBidirectionalStreamRequest: AWSEncodableShape {
        /// The prompt and inference parameters in the format specified in the BidirectionalInputPayloadPart in the header. You must provide the body in JSON format. To see the format and content of the request and response bodies for different models, refer to Inference parameters. For more information, see Run inference in the Bedrock User Guide.
        public let body: AWSEventStream<InvokeModelWithBidirectionalStreamInput>
        /// The model ID or ARN of the model ID to use. Currently, only amazon.nova-sonic-v1:0 is supported.
        public let modelId: String

        @inlinable
        public init(body: AWSEventStream<InvokeModelWithBidirectionalStreamInput>, modelId: String) {
            self.body = body
            self.modelId = modelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            try container.encode(self.body)
            request.encodePath(self.modelId, key: "modelId")
        }

        public func validate(name: String) throws {
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:imported-model/[a-z0-9]{12})|([0-9]{12}:provisioned-model/[a-z0-9]{12})|([0-9]{12}:(inference-profile|application-inference-profile)/[a-zA-Z0-9-:.]+)))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)|([a-zA-Z0-9-:.]+)$|(^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10}(?::[0-9]{1,5})?))$|(^arn:aws:sagemaker:[a-z0-9-]+:[0-9]{12}:endpoint/[a-zA-Z0-9-]+$)|(^arn:aws(-[^:]+)?:bedrock:([0-9a-z-]{1,20}):([0-9]{12}):(default-)?prompt-router/[a-zA-Z0-9-:.]+$)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeModelWithBidirectionalStreamResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Streaming response from the model in the format specified by the BidirectionalOutputPayloadPart header.
        public let body: AWSEventStream<InvokeModelWithBidirectionalStreamOutput>

        @inlinable
        public init(body: AWSEventStream<InvokeModelWithBidirectionalStreamOutput>) {
            self.body = body
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.body = try container.decode(AWSEventStream<InvokeModelWithBidirectionalStreamOutput>.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeModelWithResponseStreamRequest: AWSEncodableShape {
        /// The desired MIME type of the inference body in the response. The default value is application/json.
        public let accept: String?
        /// The prompt and inference parameters in the format specified in the contentType in the header. You must provide the body in JSON format. To see the format and content of the request and response bodies for different models, refer to Inference parameters. For more information, see Run inference in the Bedrock User Guide.
        public let body: AWSHTTPBody?
        /// The MIME type of the input data in the request. You must specify application/json.
        public let contentType: String?
        /// The unique identifier of the guardrail that you want to use. If you don't provide a value, no guardrail is applied to the invocation. An error is thrown in the following situations.   You don't provide a guardrail identifier but you specify the amazon-bedrock-guardrailConfig field in the request body.   You enable the guardrail but the contentType isn't application/json.   You provide a guardrail identifier, but guardrailVersion isn't specified.
        public let guardrailIdentifier: String?
        /// The version number for the guardrail. The value can also be DRAFT.
        public let guardrailVersion: String?
        /// The unique identifier of the model to invoke to run inference. The modelId to provide depends on the type of model or throughput that you use:   If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see Amazon Bedrock base model IDs (on-demand throughput) in the Amazon Bedrock User Guide.   If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see Supported Regions and models for cross-region inference in the Amazon Bedrock User Guide.   If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see Run inference using a Provisioned Throughput in the Amazon Bedrock User Guide.   If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see Use a custom model in Amazon Bedrock in the Amazon Bedrock User Guide.   If you use an imported model, specify the ARN of the imported model. You can get the model ARN from a successful call to CreateModelImportJob or from the Imported models page in the Amazon Bedrock console.
        public let modelId: String
        /// Model performance settings for the request.
        public let performanceConfigLatency: PerformanceConfigLatency?
        /// Specifies whether to enable or disable the Bedrock trace. If enabled, you can see the full Bedrock trace.
        public let trace: Trace?

        @inlinable
        public init(accept: String? = nil, body: AWSHTTPBody? = nil, contentType: String? = nil, guardrailIdentifier: String? = nil, guardrailVersion: String? = nil, modelId: String, performanceConfigLatency: PerformanceConfigLatency? = nil, trace: Trace? = nil) {
            self.accept = accept
            self.body = body
            self.contentType = contentType
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
            self.modelId = modelId
            self.performanceConfigLatency = performanceConfigLatency
            self.trace = trace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.accept, key: "X-Amzn-Bedrock-Accept")
            try container.encode(self.body)
            request.encodeHeader(self.contentType, key: "Content-Type")
            request.encodeHeader(self.guardrailIdentifier, key: "X-Amzn-Bedrock-GuardrailIdentifier")
            request.encodeHeader(self.guardrailVersion, key: "X-Amzn-Bedrock-GuardrailVersion")
            request.encodePath(self.modelId, key: "modelId")
            request.encodeHeader(self.performanceConfigLatency, key: "X-Amzn-Bedrock-PerformanceConfig-Latency")
            request.encodeHeader(self.trace, key: "X-Amzn-Bedrock-Trace")
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 25000000)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^(([1-9][0-9]{0,7})|(DRAFT))$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:imported-model/[a-z0-9]{12})|([0-9]{12}:provisioned-model/[a-z0-9]{12})|([0-9]{12}:(inference-profile|application-inference-profile)/[a-zA-Z0-9-:.]+)))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)|([a-zA-Z0-9-:.]+)$|(^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:prompt/[0-9a-zA-Z]{10}(?::[0-9]{1,5})?))$|(^arn:aws:sagemaker:[a-z0-9-]+:[0-9]{12}:endpoint/[a-zA-Z0-9-]+$)|(^arn:aws(-[^:]+)?:bedrock:([0-9a-z-]{1,20}):([0-9]{12}):(default-)?prompt-router/[a-zA-Z0-9-:.]+$)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeModelWithResponseStreamResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Inference response from the model in the format specified by the contentType header. To see the format and content of this field for different models, refer to Inference parameters.
        public let body: AWSEventStream<ResponseStream>
        /// The MIME type of the inference result.
        public let contentType: String
        /// Model performance settings for the request.
        public let performanceConfigLatency: PerformanceConfigLatency?

        @inlinable
        public init(body: AWSEventStream<ResponseStream>, contentType: String, performanceConfigLatency: PerformanceConfigLatency? = nil) {
            self.body = body
            self.contentType = contentType
            self.performanceConfigLatency = performanceConfigLatency
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.body = try container.decode(AWSEventStream<ResponseStream>.self)
            self.contentType = try response.decodeHeader(String.self, key: "X-Amzn-Bedrock-Content-Type")
            self.performanceConfigLatency = try response.decodeHeaderIfPresent(PerformanceConfigLatency.self, key: "X-Amzn-Bedrock-PerformanceConfig-Latency")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAsyncInvokesRequest: AWSEncodableShape {
        /// The maximum number of invocations to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// How to sort the response.
        public let sortBy: SortAsyncInvocationBy?
        /// The sorting order for the response.
        public let sortOrder: SortOrder?
        /// Filter invocations by status.
        public let statusEquals: AsyncInvokeStatus?
        /// Include invocations submitted after this time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var submitTimeAfter: Date?
        /// Include invocations submitted before this time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var submitTimeBefore: Date?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortAsyncInvocationBy? = nil, sortOrder: SortOrder? = nil, statusEquals: AsyncInvokeStatus? = nil, submitTimeAfter: Date? = nil, submitTimeBefore: Date? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
            self.submitTimeAfter = submitTimeAfter
            self.submitTimeBefore = submitTimeBefore
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.statusEquals, key: "statusEquals")
            request.encodeQuery(self._submitTimeAfter, key: "submitTimeAfter")
            request.encodeQuery(self._submitTimeBefore, key: "submitTimeBefore")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAsyncInvokesResponse: AWSDecodableShape {
        /// A list of invocation summaries.
        public let asyncInvokeSummaries: [AsyncInvokeSummary]?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(asyncInvokeSummaries: [AsyncInvokeSummary]? = nil, nextToken: String? = nil) {
            self.asyncInvokeSummaries = asyncInvokeSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case asyncInvokeSummaries = "asyncInvokeSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct Message: AWSEncodableShape & AWSDecodableShape {
        /// The message content. Note the following restrictions:   You can include up to 20 images. Each image's size, height, and width must be no more than 3.75 MB, 8000 px, and 8000 px, respectively.   You can include up to five documents. Each document's size must be no more than 4.5 MB.   If you include a ContentBlock with a document field in the array, you must also include a ContentBlock with a text field.   You can only include images and documents if the role is user.
        public let content: [ContentBlock]
        /// The role that the message plays in the message.
        public let role: ConversationRole

        @inlinable
        public init(content: [ContentBlock], role: ConversationRole) {
            self.content = content
            self.role = role
        }

        public func validate(name: String) throws {
            try self.content.forEach {
                try $0.validate(name: "\(name).content[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case role = "role"
        }
    }

    public struct MessageStartEvent: AWSDecodableShape {
        /// The role for the message.
        public let role: ConversationRole

        @inlinable
        public init(role: ConversationRole) {
            self.role = role
        }

        private enum CodingKeys: String, CodingKey {
            case role = "role"
        }
    }

    public struct MessageStopEvent: AWSDecodableShape {
        /// The additional model response fields.
        public let additionalModelResponseFields: AWSDocument?
        /// The reason why the model stopped generating output.
        public let stopReason: StopReason

        @inlinable
        public init(additionalModelResponseFields: AWSDocument? = nil, stopReason: StopReason) {
            self.additionalModelResponseFields = additionalModelResponseFields
            self.stopReason = stopReason
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelResponseFields = "additionalModelResponseFields"
            case stopReason = "stopReason"
        }
    }

    public struct ModelErrorException: AWSErrorShape {
        public let message: String?
        /// The original status code.
        public let originalStatusCode: Int?
        /// The resource name.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, originalStatusCode: Int? = nil, resourceName: String? = nil) {
            self.message = message
            self.originalStatusCode = originalStatusCode
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case originalStatusCode = "originalStatusCode"
            case resourceName = "resourceName"
        }
    }

    public struct ModelStreamErrorException: AWSErrorShape {
        public let message: String?
        /// The original message.
        public let originalMessage: String?
        /// The original status code.
        public let originalStatusCode: Int?

        @inlinable
        public init(message: String? = nil, originalMessage: String? = nil, originalStatusCode: Int? = nil) {
            self.message = message
            self.originalMessage = originalMessage
            self.originalStatusCode = originalStatusCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case originalMessage = "originalMessage"
            case originalStatusCode = "originalStatusCode"
        }
    }

    public struct ModelTimeoutException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct PayloadPart: AWSDecodableShape {
        /// Base64-encoded bytes of payload data.
        public let bytes: AWSBase64Data?

        @inlinable
        public init(bytes: AWSBase64Data? = nil) {
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
        }
    }

    public struct PerformanceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// To use a latency-optimized version of the model, set to optimized.
        public let latency: PerformanceConfigLatency?

        @inlinable
        public init(latency: PerformanceConfigLatency? = nil) {
            self.latency = latency
        }

        private enum CodingKeys: String, CodingKey {
            case latency = "latency"
        }
    }

    public struct PromptRouterTrace: AWSDecodableShape {
        /// The ID of the invoked model.
        public let invokedModelId: String?

        @inlinable
        public init(invokedModelId: String? = nil) {
            self.invokedModelId = invokedModelId
        }

        private enum CodingKeys: String, CodingKey {
            case invokedModelId = "invokedModelId"
        }
    }

    public struct ReasoningTextBlock: AWSEncodableShape & AWSDecodableShape {
        /// A token that verifies that the reasoning text was generated by the model. If you pass a reasoning block back to the API in a multi-turn conversation, include the text and its signature unmodified.
        public let signature: String?
        /// The reasoning that the model used to return the output.
        public let text: String

        @inlinable
        public init(signature: String? = nil, text: String) {
            self.signature = signature
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case signature = "signature"
            case text = "text"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// If the bucket belongs to another AWS account, specify that account's ID.
        public let bucketOwner: String?
        /// An object URI starting with s3://.
        public let uri: String

        @inlinable
        public init(bucketOwner: String? = nil, uri: String) {
            self.bucketOwner = bucketOwner
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketOwner, name: "bucketOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.uri, name: "uri", parent: name, max: 1024)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketOwner = "bucketOwner"
            case uri = "uri"
        }
    }

    public struct ServiceUnavailableException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct SpecificToolChoice: AWSEncodableShape {
        /// The name of the tool that the model must request.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct StartAsyncInvokeRequest: AWSEncodableShape {
        /// Specify idempotency token to ensure that requests are not duplicated.
        public let clientRequestToken: String?
        /// The model to invoke.
        public let modelId: String
        /// Input to send to the model.
        public let modelInput: AWSDocument
        /// Where to store the output.
        public let outputDataConfig: AsyncInvokeOutputDataConfig
        /// Tags to apply to the invocation.
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = StartAsyncInvokeRequest.idempotencyToken(), modelId: String, modelInput: AWSDocument, outputDataConfig: AsyncInvokeOutputDataConfig, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.modelId = modelId
            self.modelInput = modelInput
            self.outputDataConfig = outputDataConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[!-~]*$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 256)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^[a-zA-Z_\\.\\-/0-9:]+$")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case modelId = "modelId"
            case modelInput = "modelInput"
            case outputDataConfig = "outputDataConfig"
            case tags = "tags"
        }
    }

    public struct StartAsyncInvokeResponse: AWSDecodableShape {
        /// The ARN of the invocation.
        public let invocationArn: String

        @inlinable
        public init(invocationArn: String) {
            self.invocationArn = invocationArn
        }

        private enum CodingKeys: String, CodingKey {
            case invocationArn = "invocationArn"
        }
    }

    public struct Tag: AWSEncodableShape {
        /// The tag's key.
        public let key: String
        /// The tag's value.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct ThrottlingException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct TokenUsage: AWSDecodableShape {
        /// The number of input tokens read from the cache for the request.
        public let cacheReadInputTokens: Int?
        /// The number of input tokens written to the cache for the request.
        public let cacheWriteInputTokens: Int?
        /// The number of tokens sent in the request to the model.
        public let inputTokens: Int
        /// The number of tokens that the model generated for the request.
        public let outputTokens: Int
        /// The total of input tokens and tokens generated by the model.
        public let totalTokens: Int

        @inlinable
        public init(cacheReadInputTokens: Int? = nil, cacheWriteInputTokens: Int? = nil, inputTokens: Int, outputTokens: Int, totalTokens: Int) {
            self.cacheReadInputTokens = cacheReadInputTokens
            self.cacheWriteInputTokens = cacheWriteInputTokens
            self.inputTokens = inputTokens
            self.outputTokens = outputTokens
            self.totalTokens = totalTokens
        }

        private enum CodingKeys: String, CodingKey {
            case cacheReadInputTokens = "cacheReadInputTokens"
            case cacheWriteInputTokens = "cacheWriteInputTokens"
            case inputTokens = "inputTokens"
            case outputTokens = "outputTokens"
            case totalTokens = "totalTokens"
        }
    }

    public struct ToolConfiguration: AWSEncodableShape {
        /// If supported by model, forces the model to request a tool.
        public let toolChoice: ToolChoice?
        /// An array of tools that you want to pass to a model.
        public let tools: [Tool]

        @inlinable
        public init(toolChoice: ToolChoice? = nil, tools: [Tool]) {
            self.toolChoice = toolChoice
            self.tools = tools
        }

        public func validate(name: String) throws {
            try self.toolChoice?.validate(name: "\(name).toolChoice")
            try self.tools.forEach {
                try $0.validate(name: "\(name).tools[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case toolChoice = "toolChoice"
            case tools = "tools"
        }
    }

    public struct ToolResultBlock: AWSEncodableShape & AWSDecodableShape {
        /// The content for tool result content block.
        public let content: [ToolResultContentBlock]
        /// The status for the tool result content block.  This field is only supported Anthropic Claude 3 models.
        public let status: ToolResultStatus?
        /// The ID of the tool request that this is the result for.
        public let toolUseId: String

        @inlinable
        public init(content: [ToolResultContentBlock], status: ToolResultStatus? = nil, toolUseId: String) {
            self.content = content
            self.status = status
            self.toolUseId = toolUseId
        }

        public func validate(name: String) throws {
            try self.content.forEach {
                try $0.validate(name: "\(name).content[]")
            }
            try self.validate(self.toolUseId, name: "toolUseId", parent: name, max: 64)
            try self.validate(self.toolUseId, name: "toolUseId", parent: name, min: 1)
            try self.validate(self.toolUseId, name: "toolUseId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case status = "status"
            case toolUseId = "toolUseId"
        }
    }

    public struct ToolSpecification: AWSEncodableShape {
        /// The description for the tool.
        public let description: String?
        /// The input schema for the tool in JSON format.
        public let inputSchema: ToolInputSchema
        /// The name for the tool.
        public let name: String

        @inlinable
        public init(description: String? = nil, inputSchema: ToolInputSchema, name: String) {
            self.description = description
            self.inputSchema = inputSchema
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case inputSchema = "inputSchema"
            case name = "name"
        }
    }

    public struct ToolUseBlock: AWSEncodableShape & AWSDecodableShape {
        /// The input to pass to the tool.
        public let input: AWSDocument
        /// The name of the tool that the model wants to use.
        public let name: String
        /// The ID for the tool request.
        public let toolUseId: String

        @inlinable
        public init(input: AWSDocument, name: String, toolUseId: String) {
            self.input = input
            self.name = name
            self.toolUseId = toolUseId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.toolUseId, name: "toolUseId", parent: name, max: 64)
            try self.validate(self.toolUseId, name: "toolUseId", parent: name, min: 1)
            try self.validate(self.toolUseId, name: "toolUseId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case name = "name"
            case toolUseId = "toolUseId"
        }
    }

    public struct ToolUseBlockDelta: AWSDecodableShape {
        /// The input for a requested tool.
        public let input: String

        @inlinable
        public init(input: String) {
            self.input = input
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
        }
    }

    public struct ToolUseBlockStart: AWSDecodableShape {
        /// The name of the tool that the model is requesting to use.
        public let name: String
        /// The ID for the tool request.
        public let toolUseId: String

        @inlinable
        public init(name: String, toolUseId: String) {
            self.name = name
            self.toolUseId = toolUseId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case toolUseId = "toolUseId"
        }
    }

    public struct ValidationException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct VideoBlock: AWSEncodableShape & AWSDecodableShape {
        /// The block's format.
        public let format: VideoFormat
        /// The block's source.
        public let source: VideoSource

        @inlinable
        public init(format: VideoFormat, source: VideoSource) {
            self.format = format
            self.source = source
        }

        public func validate(name: String) throws {
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case source = "source"
        }
    }

    public struct AsyncInvokeOutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// A storage location for the output data in an S3 bucket
        public let s3OutputDataConfig: AsyncInvokeS3OutputDataConfig?

        @inlinable
        public init(s3OutputDataConfig: AsyncInvokeS3OutputDataConfig? = nil) {
            self.s3OutputDataConfig = s3OutputDataConfig
        }

        public func validate(name: String) throws {
            try self.s3OutputDataConfig?.validate(name: "\(name).s3OutputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case s3OutputDataConfig = "s3OutputDataConfig"
        }
    }

    public struct ContentBlockStart: AWSDecodableShape {
        /// Information about a tool that the model is requesting to use.
        public let toolUse: ToolUseBlockStart?

        @inlinable
        public init(toolUse: ToolUseBlockStart? = nil) {
            self.toolUse = toolUse
        }

        private enum CodingKeys: String, CodingKey {
            case toolUse = "toolUse"
        }
    }

    public struct ConverseOutput: AWSDecodableShape {
        /// The message that the model generates.
        public let message: Message?

        @inlinable
        public init(message: Message? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DocumentSource: AWSEncodableShape & AWSDecodableShape {
        /// The raw bytes for the document. If you use an Amazon Web Services SDK, you don't need to encode the bytes in base64.
        public let bytes: AWSBase64Data?

        @inlinable
        public init(bytes: AWSBase64Data? = nil) {
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
        }
    }

    public struct GuardrailConverseImageSource: AWSEncodableShape & AWSDecodableShape {
        /// The raw image bytes for the image.
        public let bytes: AWSBase64Data?

        @inlinable
        public init(bytes: AWSBase64Data? = nil) {
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
        }
    }

    public struct GuardrailImageSource: AWSEncodableShape {
        /// The bytes details of the guardrail image source. Object used in independent api.
        public let bytes: AWSBase64Data?

        @inlinable
        public init(bytes: AWSBase64Data? = nil) {
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
        }
    }

    public struct ImageSource: AWSEncodableShape & AWSDecodableShape {
        /// The raw image bytes for the image. If you use an AWS SDK, you don't need to encode the image bytes in base64.
        public let bytes: AWSBase64Data?

        @inlinable
        public init(bytes: AWSBase64Data? = nil) {
            self.bytes = bytes
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "bytes"
        }
    }

    public struct InvokeModelWithBidirectionalStreamInput: AWSEncodableShape {
        /// The audio chunk that is used as input for the invocation step.
        public let chunk: BidirectionalInputPayloadPart?

        @inlinable
        public init(chunk: BidirectionalInputPayloadPart? = nil) {
            self.chunk = chunk
        }

        public func validate(name: String) throws {
            try self.chunk?.validate(name: "\(name).chunk")
        }

        private enum CodingKeys: String, CodingKey {
            case chunk = "chunk"
        }
    }

    public struct PromptVariableValues: AWSEncodableShape {
        /// The text value that the variable maps to.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct ToolInputSchema: AWSEncodableShape {
        /// The JSON schema for the tool. For more information, see JSON Schema Reference.
        public let json: AWSDocument?

        @inlinable
        public init(json: AWSDocument? = nil) {
            self.json = json
        }

        private enum CodingKeys: String, CodingKey {
            case json = "json"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockRuntime
public struct BedrockRuntimeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case modelErrorException = "ModelErrorException"
        case modelNotReadyException = "ModelNotReadyException"
        case modelStreamErrorException = "ModelStreamErrorException"
        case modelTimeoutException = "ModelTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockRuntime
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request is denied because you do not have sufficient permissions to perform the requested action. For troubleshooting this error,  see AccessDeniedException in the Amazon Bedrock User Guide
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Error occurred because of a conflict while performing an operation.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error occurred. For troubleshooting this error,  see InternalFailure in the Amazon Bedrock User Guide
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request failed due to an error while processing the model.
    public static var modelErrorException: Self { .init(.modelErrorException) }
    /// The model specified in the request is not ready to serve inference requests. The AWS SDK will automatically retry the operation up to 5 times. For information about configuring automatic retries, see Retry behavior in the AWS SDKs and Tools reference guide.
    public static var modelNotReadyException: Self { .init(.modelNotReadyException) }
    /// An error occurred while streaming the response. Retry your request.
    public static var modelStreamErrorException: Self { .init(.modelStreamErrorException) }
    /// The request took too long to process. Processing time exceeded the model timeout length.
    public static var modelTimeoutException: Self { .init(.modelTimeoutException) }
    /// The specified resource ARN was not found. For troubleshooting this error,  see ResourceNotFound in the Amazon Bedrock User Guide
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Your request exceeds the service quota for your account. You can view your quotas at Viewing service quotas. You can resubmit your request later.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The service isn't currently available. For troubleshooting this error,  see ServiceUnavailable in the Amazon Bedrock User Guide
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// Your request was denied due to exceeding the account quotas for Amazon Bedrock. For troubleshooting this error, see ThrottlingException in the Amazon Bedrock User Guide
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by Amazon Bedrock. For troubleshooting this error,  see ValidationError in the Amazon Bedrock User Guide
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockRuntimeErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ModelErrorException": BedrockRuntime.ModelErrorException.self,
        "ModelStreamErrorException": BedrockRuntime.ModelStreamErrorException.self
    ]
}

extension BedrockRuntimeErrorType: Equatable {
    public static func == (lhs: BedrockRuntimeErrorType, rhs: BedrockRuntimeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockRuntimeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
