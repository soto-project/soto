//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Tnb {
    // MARK: Enums

    public enum DescriptorContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case textPlain = "text/plain"
        public var description: String { return self.rawValue }
    }

    public enum LcmOperationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case instantiate = "INSTANTIATE"
        case terminate = "TERMINATE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum NsLcmOperationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case processing = "PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum NsState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case impaired = "IMPAIRED"
        case instantiateInProgress = "INSTANTIATE_IN_PROGRESS"
        case instantiated = "INSTANTIATED"
        case intentToUpdateInProgress = "INTENT_TO_UPDATE_IN_PROGRESS"
        case notInstantiated = "NOT_INSTANTIATED"
        case stopped = "STOPPED"
        case terminateInProgress = "TERMINATE_IN_PROGRESS"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updated = "UPDATED"
        public var description: String { return self.rawValue }
    }

    public enum NsdOnboardingState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case error = "ERROR"
        case onboarded = "ONBOARDED"
        public var description: String { return self.rawValue }
    }

    public enum NsdOperationalState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum NsdUsageState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inUse = "IN_USE"
        case notInUse = "NOT_IN_USE"
        public var description: String { return self.rawValue }
    }

    public enum OnboardingState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case error = "ERROR"
        case onboarded = "ONBOARDED"
        public var description: String { return self.rawValue }
    }

    public enum OperationalState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PackageContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case applicationZip = "application/zip"
        public var description: String { return self.rawValue }
    }

    public enum TaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case error = "ERROR"
        case inProgress = "IN_PROGRESS"
        case scheduled = "SCHEDULED"
        case skipped = "SKIPPED"
        case started = "STARTED"
        public var description: String { return self.rawValue }
    }

    public enum UpdateSolNetworkType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case modifyVnfInformation = "MODIFY_VNF_INFORMATION"
        case updateNs = "UPDATE_NS"
        public var description: String { return self.rawValue }
    }

    public enum UsageState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inUse = "IN_USE"
        case notInUse = "NOT_IN_USE"
        public var description: String { return self.rawValue }
    }

    public enum VnfInstantiationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case instantiated = "INSTANTIATED"
        case notInstantiated = "NOT_INSTANTIATED"
        public var description: String { return self.rawValue }
    }

    public enum VnfOperationalState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case started = "STARTED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CancelSolNetworkOperationInput: AWSEncodableShape {
        /// The identifier of the network operation.
        public let nsLcmOpOccId: String

        @inlinable
        public init(nsLcmOpOccId: String) {
            self.nsLcmOpOccId = nsLcmOpOccId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.nsLcmOpOccId, key: "nsLcmOpOccId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nsLcmOpOccId, name: "nsLcmOpOccId", parent: name, pattern: "^no-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateSolFunctionPackageInput: AWSEncodableShape {
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct CreateSolFunctionPackageOutput: AWSDecodableShape {
        /// Function package ARN.
        public let arn: String
        /// ID of the function package.
        public let id: String
        /// Onboarding state of the function package.
        public let onboardingState: OnboardingState
        /// Operational state of the function package.
        public let operationalState: OperationalState
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?
        /// Usage state of the function package.
        public let usageState: UsageState

        @inlinable
        public init(arn: String, id: String, onboardingState: OnboardingState, operationalState: OperationalState, tags: [String: String]? = nil, usageState: UsageState) {
            self.arn = arn
            self.id = id
            self.onboardingState = onboardingState
            self.operationalState = operationalState
            self.tags = tags
            self.usageState = usageState
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case onboardingState = "onboardingState"
            case operationalState = "operationalState"
            case tags = "tags"
            case usageState = "usageState"
        }
    }

    public struct CreateSolNetworkInstanceInput: AWSEncodableShape {
        /// Network instance description.
        public let nsDescription: String?
        /// ID for network service descriptor.
        public let nsdInfoId: String
        /// Network instance name.
        public let nsName: String
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?

        @inlinable
        public init(nsDescription: String? = nil, nsdInfoId: String, nsName: String, tags: [String: String]? = nil) {
            self.nsDescription = nsDescription
            self.nsdInfoId = nsdInfoId
            self.nsName = nsName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.nsdInfoId, name: "nsdInfoId", parent: name, pattern: "^np-[a-f0-9]{17}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case nsDescription = "nsDescription"
            case nsdInfoId = "nsdInfoId"
            case nsName = "nsName"
            case tags = "tags"
        }
    }

    public struct CreateSolNetworkInstanceOutput: AWSDecodableShape {
        /// Network instance ARN.
        public let arn: String
        /// Network instance ID.
        public let id: String
        /// Network service descriptor ID.
        public let nsdInfoId: String
        /// Network instance name.
        public let nsInstanceName: String
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, id: String, nsdInfoId: String, nsInstanceName: String, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.nsdInfoId = nsdInfoId
            self.nsInstanceName = nsInstanceName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case nsdInfoId = "nsdInfoId"
            case nsInstanceName = "nsInstanceName"
            case tags = "tags"
        }
    }

    public struct CreateSolNetworkPackageInput: AWSEncodableShape {
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct CreateSolNetworkPackageOutput: AWSDecodableShape {
        /// Network package ARN.
        public let arn: String
        /// ID of the network package.
        public let id: String
        /// Onboarding state of the network service descriptor in the network package.
        public let nsdOnboardingState: NsdOnboardingState
        /// Operational state of the network service descriptor in the network package.
        public let nsdOperationalState: NsdOperationalState
        /// Usage state of the network service descriptor in the network package.
        public let nsdUsageState: NsdUsageState
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, id: String, nsdOnboardingState: NsdOnboardingState, nsdOperationalState: NsdOperationalState, nsdUsageState: NsdUsageState, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.nsdOnboardingState = nsdOnboardingState
            self.nsdOperationalState = nsdOperationalState
            self.nsdUsageState = nsdUsageState
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case nsdOnboardingState = "nsdOnboardingState"
            case nsdOperationalState = "nsdOperationalState"
            case nsdUsageState = "nsdUsageState"
            case tags = "tags"
        }
    }

    public struct DeleteSolFunctionPackageInput: AWSEncodableShape {
        /// ID of the function package.
        public let vnfPkgId: String

        @inlinable
        public init(vnfPkgId: String) {
            self.vnfPkgId = vnfPkgId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.vnfPkgId, key: "vnfPkgId")
        }

        public func validate(name: String) throws {
            try self.validate(self.vnfPkgId, name: "vnfPkgId", parent: name, pattern: "^fp-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSolNetworkInstanceInput: AWSEncodableShape {
        /// Network instance ID.
        public let nsInstanceId: String

        @inlinable
        public init(nsInstanceId: String) {
            self.nsInstanceId = nsInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.nsInstanceId, key: "nsInstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nsInstanceId, name: "nsInstanceId", parent: name, pattern: "^ni-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSolNetworkPackageInput: AWSEncodableShape {
        /// ID of the network service descriptor in the network package.
        public let nsdInfoId: String

        @inlinable
        public init(nsdInfoId: String) {
            self.nsdInfoId = nsdInfoId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.nsdInfoId, key: "nsdInfoId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nsdInfoId, name: "nsdInfoId", parent: name, pattern: "^np-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ErrorInfo: AWSDecodableShape {
        /// Error cause.
        public let cause: String?
        /// Error details.
        public let details: String?

        @inlinable
        public init(cause: String? = nil, details: String? = nil) {
            self.cause = cause
            self.details = details
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case details = "details"
        }
    }

    public struct FunctionArtifactMeta: AWSDecodableShape {
        /// Lists of function package overrides.
        public let overrides: [ToscaOverride]?

        @inlinable
        public init(overrides: [ToscaOverride]? = nil) {
            self.overrides = overrides
        }

        private enum CodingKeys: String, CodingKey {
            case overrides = "overrides"
        }
    }

    public struct GetSolFunctionInstanceInput: AWSEncodableShape {
        /// ID of the network function.
        public let vnfInstanceId: String

        @inlinable
        public init(vnfInstanceId: String) {
            self.vnfInstanceId = vnfInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.vnfInstanceId, key: "vnfInstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.vnfInstanceId, name: "vnfInstanceId", parent: name, pattern: "^fi-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolFunctionInstanceMetadata: AWSDecodableShape {
        /// The date that the resource was created.
        public let createdAt: Date
        /// The date that the resource was last modified.
        public let lastModified: Date

        @inlinable
        public init(createdAt: Date, lastModified: Date) {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastModified = "lastModified"
        }
    }

    public struct GetSolFunctionInstanceOutput: AWSDecodableShape {
        /// Network function instance ARN.
        public let arn: String
        /// Network function instance ID.
        public let id: String
        public let instantiatedVnfInfo: GetSolVnfInfo?
        /// Network function instantiation state.
        public let instantiationState: VnfInstantiationState
        public let metadata: GetSolFunctionInstanceMetadata
        /// Network instance ID.
        public let nsInstanceId: String
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?
        /// Function package descriptor ID.
        public let vnfdId: String
        /// Function package descriptor version.
        public let vnfdVersion: String?
        /// Function package ID.
        public let vnfPkgId: String
        /// Network function product name.
        public let vnfProductName: String?
        /// Network function provider.
        public let vnfProvider: String?

        @inlinable
        public init(arn: String, id: String, instantiatedVnfInfo: GetSolVnfInfo? = nil, instantiationState: VnfInstantiationState, metadata: GetSolFunctionInstanceMetadata, nsInstanceId: String, tags: [String: String]? = nil, vnfdId: String, vnfdVersion: String? = nil, vnfPkgId: String, vnfProductName: String? = nil, vnfProvider: String? = nil) {
            self.arn = arn
            self.id = id
            self.instantiatedVnfInfo = instantiatedVnfInfo
            self.instantiationState = instantiationState
            self.metadata = metadata
            self.nsInstanceId = nsInstanceId
            self.tags = tags
            self.vnfdId = vnfdId
            self.vnfdVersion = vnfdVersion
            self.vnfPkgId = vnfPkgId
            self.vnfProductName = vnfProductName
            self.vnfProvider = vnfProvider
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case instantiatedVnfInfo = "instantiatedVnfInfo"
            case instantiationState = "instantiationState"
            case metadata = "metadata"
            case nsInstanceId = "nsInstanceId"
            case tags = "tags"
            case vnfdId = "vnfdId"
            case vnfdVersion = "vnfdVersion"
            case vnfPkgId = "vnfPkgId"
            case vnfProductName = "vnfProductName"
            case vnfProvider = "vnfProvider"
        }
    }

    public struct GetSolFunctionPackageContentInput: AWSEncodableShape {
        /// The format of the package that you want to download from the function packages.
        public let accept: PackageContentType
        /// ID of the function package.
        public let vnfPkgId: String

        @inlinable
        public init(accept: PackageContentType, vnfPkgId: String) {
            self.accept = accept
            self.vnfPkgId = vnfPkgId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.accept, key: "Accept")
            request.encodePath(self.vnfPkgId, key: "vnfPkgId")
        }

        public func validate(name: String) throws {
            try self.validate(self.vnfPkgId, name: "vnfPkgId", parent: name, pattern: "^fp-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolFunctionPackageContentOutput: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Indicates the media type of the resource.
        public let contentType: PackageContentType?
        /// Contents of the function package.
        public let packageContent: AWSHTTPBody

        @inlinable
        public init(contentType: PackageContentType? = nil, packageContent: AWSHTTPBody) {
            self.contentType = contentType
            self.packageContent = packageContent
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.contentType = try response.decodeHeaderIfPresent(PackageContentType.self, key: "Content-Type")
            self.packageContent = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolFunctionPackageDescriptorInput: AWSEncodableShape {
        /// Indicates which content types, expressed as MIME types, the client is able to understand.
        public let accept: DescriptorContentType
        /// ID of the function package.
        public let vnfPkgId: String

        @inlinable
        public init(accept: DescriptorContentType, vnfPkgId: String) {
            self.accept = accept
            self.vnfPkgId = vnfPkgId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.accept, key: "Accept")
            request.encodePath(self.vnfPkgId, key: "vnfPkgId")
        }

        public func validate(name: String) throws {
            try self.validate(self.vnfPkgId, name: "vnfPkgId", parent: name, pattern: "^fp-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolFunctionPackageDescriptorOutput: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Indicates the media type of the resource.
        public let contentType: DescriptorContentType?
        /// Contents of the function package descriptor.
        public let vnfd: AWSHTTPBody

        @inlinable
        public init(contentType: DescriptorContentType? = nil, vnfd: AWSHTTPBody) {
            self.contentType = contentType
            self.vnfd = vnfd
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.contentType = try response.decodeHeaderIfPresent(DescriptorContentType.self, key: "Content-Type")
            self.vnfd = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolFunctionPackageInput: AWSEncodableShape {
        /// ID of the function package.
        public let vnfPkgId: String

        @inlinable
        public init(vnfPkgId: String) {
            self.vnfPkgId = vnfPkgId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.vnfPkgId, key: "vnfPkgId")
        }

        public func validate(name: String) throws {
            try self.validate(self.vnfPkgId, name: "vnfPkgId", parent: name, pattern: "^fp-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolFunctionPackageMetadata: AWSDecodableShape {
        /// The date that the resource was created.
        public let createdAt: Date
        /// The date that the resource was last modified.
        public let lastModified: Date
        /// Metadata related to the function package descriptor of the function package.
        public let vnfd: FunctionArtifactMeta?

        @inlinable
        public init(createdAt: Date, lastModified: Date, vnfd: FunctionArtifactMeta? = nil) {
            self.createdAt = createdAt
            self.lastModified = lastModified
            self.vnfd = vnfd
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastModified = "lastModified"
            case vnfd = "vnfd"
        }
    }

    public struct GetSolFunctionPackageOutput: AWSDecodableShape {
        /// Function package ARN.
        public let arn: String
        /// Function package ID.
        public let id: String
        public let metadata: GetSolFunctionPackageMetadata?
        /// Function package onboarding state.
        public let onboardingState: OnboardingState
        /// Function package operational state.
        public let operationalState: OperationalState
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?
        /// Function package usage state.
        public let usageState: UsageState
        /// Function package descriptor ID.
        public let vnfdId: String?
        /// Function package descriptor version.
        public let vnfdVersion: String?
        /// Network function product name.
        public let vnfProductName: String?
        /// Network function provider.
        public let vnfProvider: String?

        @inlinable
        public init(arn: String, id: String, metadata: GetSolFunctionPackageMetadata? = nil, onboardingState: OnboardingState, operationalState: OperationalState, tags: [String: String]? = nil, usageState: UsageState, vnfdId: String? = nil, vnfdVersion: String? = nil, vnfProductName: String? = nil, vnfProvider: String? = nil) {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.onboardingState = onboardingState
            self.operationalState = operationalState
            self.tags = tags
            self.usageState = usageState
            self.vnfdId = vnfdId
            self.vnfdVersion = vnfdVersion
            self.vnfProductName = vnfProductName
            self.vnfProvider = vnfProvider
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case metadata = "metadata"
            case onboardingState = "onboardingState"
            case operationalState = "operationalState"
            case tags = "tags"
            case usageState = "usageState"
            case vnfdId = "vnfdId"
            case vnfdVersion = "vnfdVersion"
            case vnfProductName = "vnfProductName"
            case vnfProvider = "vnfProvider"
        }
    }

    public struct GetSolInstantiatedVnfInfo: AWSDecodableShape {
        /// State of the network function.
        public let vnfState: VnfOperationalState?

        @inlinable
        public init(vnfState: VnfOperationalState? = nil) {
            self.vnfState = vnfState
        }

        private enum CodingKeys: String, CodingKey {
            case vnfState = "vnfState"
        }
    }

    public struct GetSolNetworkInstanceInput: AWSEncodableShape {
        /// ID of the network instance.
        public let nsInstanceId: String

        @inlinable
        public init(nsInstanceId: String) {
            self.nsInstanceId = nsInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.nsInstanceId, key: "nsInstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nsInstanceId, name: "nsInstanceId", parent: name, pattern: "^ni-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolNetworkInstanceMetadata: AWSDecodableShape {
        /// The date that the resource was created.
        public let createdAt: Date
        /// The date that the resource was last modified.
        public let lastModified: Date

        @inlinable
        public init(createdAt: Date, lastModified: Date) {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastModified = "lastModified"
        }
    }

    public struct GetSolNetworkInstanceOutput: AWSDecodableShape {
        /// Network instance ARN.
        public let arn: String
        /// Network instance ID.
        public let id: String
        public let lcmOpInfo: LcmOperationInfo?
        public let metadata: GetSolNetworkInstanceMetadata
        /// Network service descriptor ID.
        public let nsdId: String
        /// Network service descriptor info ID.
        public let nsdInfoId: String
        /// Network instance description.
        public let nsInstanceDescription: String
        /// Network instance name.
        public let nsInstanceName: String
        /// Network instance state.
        public let nsState: NsState?
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, id: String, lcmOpInfo: LcmOperationInfo? = nil, metadata: GetSolNetworkInstanceMetadata, nsdId: String, nsdInfoId: String, nsInstanceDescription: String, nsInstanceName: String, nsState: NsState? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.lcmOpInfo = lcmOpInfo
            self.metadata = metadata
            self.nsdId = nsdId
            self.nsdInfoId = nsdInfoId
            self.nsInstanceDescription = nsInstanceDescription
            self.nsInstanceName = nsInstanceName
            self.nsState = nsState
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case lcmOpInfo = "lcmOpInfo"
            case metadata = "metadata"
            case nsdId = "nsdId"
            case nsdInfoId = "nsdInfoId"
            case nsInstanceDescription = "nsInstanceDescription"
            case nsInstanceName = "nsInstanceName"
            case nsState = "nsState"
            case tags = "tags"
        }
    }

    public struct GetSolNetworkOperationInput: AWSEncodableShape {
        /// The identifier of the network operation.
        public let nsLcmOpOccId: String

        @inlinable
        public init(nsLcmOpOccId: String) {
            self.nsLcmOpOccId = nsLcmOpOccId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.nsLcmOpOccId, key: "nsLcmOpOccId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nsLcmOpOccId, name: "nsLcmOpOccId", parent: name, pattern: "^no-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolNetworkOperationMetadata: AWSDecodableShape {
        /// The date that the resource was created.
        public let createdAt: Date
        /// Metadata related to the network operation occurrence for network instantiation. This is populated only if the lcmOperationType is INSTANTIATE.
        public let instantiateMetadata: InstantiateMetadata?
        /// The date that the resource was last modified.
        public let lastModified: Date
        /// Metadata related to the network operation occurrence for network function updates in a network instance. This is populated only if the lcmOperationType is UPDATE and the updateType is MODIFY_VNF_INFORMATION.
        public let modifyVnfInfoMetadata: ModifyVnfInfoMetadata?
        /// Metadata related to the network operation occurrence for network instance updates. This is populated only if the lcmOperationType is UPDATE and the updateType is UPDATE_NS.
        public let updateNsMetadata: UpdateNsMetadata?

        @inlinable
        public init(createdAt: Date, instantiateMetadata: InstantiateMetadata? = nil, lastModified: Date, modifyVnfInfoMetadata: ModifyVnfInfoMetadata? = nil, updateNsMetadata: UpdateNsMetadata? = nil) {
            self.createdAt = createdAt
            self.instantiateMetadata = instantiateMetadata
            self.lastModified = lastModified
            self.modifyVnfInfoMetadata = modifyVnfInfoMetadata
            self.updateNsMetadata = updateNsMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case instantiateMetadata = "instantiateMetadata"
            case lastModified = "lastModified"
            case modifyVnfInfoMetadata = "modifyVnfInfoMetadata"
            case updateNsMetadata = "updateNsMetadata"
        }
    }

    public struct GetSolNetworkOperationOutput: AWSDecodableShape {
        /// Network operation ARN.
        public let arn: String
        /// Error related to this specific network operation occurrence.
        public let error: ProblemDetails?
        /// ID of this network operation occurrence.
        public let id: String?
        /// Type of the operation represented by this occurrence.
        public let lcmOperationType: LcmOperationType?
        /// Metadata of this network operation occurrence.
        public let metadata: GetSolNetworkOperationMetadata?
        /// ID of the network operation instance.
        public let nsInstanceId: String?
        /// The state of the network operation.
        public let operationState: NsLcmOperationState?
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?
        /// All tasks associated with this operation occurrence.
        public let tasks: [GetSolNetworkOperationTaskDetails]?
        /// Type of the update. Only present if the network operation lcmOperationType is UPDATE.
        public let updateType: UpdateSolNetworkType?

        @inlinable
        public init(arn: String, error: ProblemDetails? = nil, id: String? = nil, lcmOperationType: LcmOperationType? = nil, metadata: GetSolNetworkOperationMetadata? = nil, nsInstanceId: String? = nil, operationState: NsLcmOperationState? = nil, tags: [String: String]? = nil, tasks: [GetSolNetworkOperationTaskDetails]? = nil, updateType: UpdateSolNetworkType? = nil) {
            self.arn = arn
            self.error = error
            self.id = id
            self.lcmOperationType = lcmOperationType
            self.metadata = metadata
            self.nsInstanceId = nsInstanceId
            self.operationState = operationState
            self.tags = tags
            self.tasks = tasks
            self.updateType = updateType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case error = "error"
            case id = "id"
            case lcmOperationType = "lcmOperationType"
            case metadata = "metadata"
            case nsInstanceId = "nsInstanceId"
            case operationState = "operationState"
            case tags = "tags"
            case tasks = "tasks"
            case updateType = "updateType"
        }
    }

    public struct GetSolNetworkOperationTaskDetails: AWSDecodableShape {
        /// Context for the network operation task.
        public let taskContext: [String: String]?
        /// Task end time.
        public let taskEndTime: Date?
        /// Task error details.
        public let taskErrorDetails: ErrorInfo?
        /// Task name.
        public let taskName: String?
        /// Task start time.
        public let taskStartTime: Date?
        /// Task status.
        public let taskStatus: TaskStatus?

        @inlinable
        public init(taskContext: [String: String]? = nil, taskEndTime: Date? = nil, taskErrorDetails: ErrorInfo? = nil, taskName: String? = nil, taskStartTime: Date? = nil, taskStatus: TaskStatus? = nil) {
            self.taskContext = taskContext
            self.taskEndTime = taskEndTime
            self.taskErrorDetails = taskErrorDetails
            self.taskName = taskName
            self.taskStartTime = taskStartTime
            self.taskStatus = taskStatus
        }

        private enum CodingKeys: String, CodingKey {
            case taskContext = "taskContext"
            case taskEndTime = "taskEndTime"
            case taskErrorDetails = "taskErrorDetails"
            case taskName = "taskName"
            case taskStartTime = "taskStartTime"
            case taskStatus = "taskStatus"
        }
    }

    public struct GetSolNetworkPackageContentInput: AWSEncodableShape {
        /// The format of the package you want to download from the network package.
        public let accept: PackageContentType
        /// ID of the network service descriptor in the network package.
        public let nsdInfoId: String

        @inlinable
        public init(accept: PackageContentType, nsdInfoId: String) {
            self.accept = accept
            self.nsdInfoId = nsdInfoId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.accept, key: "Accept")
            request.encodePath(self.nsdInfoId, key: "nsdInfoId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nsdInfoId, name: "nsdInfoId", parent: name, pattern: "^np-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolNetworkPackageContentOutput: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Indicates the media type of the resource.
        public let contentType: PackageContentType?
        /// Content of the network service descriptor in the network package.
        public let nsdContent: AWSHTTPBody

        @inlinable
        public init(contentType: PackageContentType? = nil, nsdContent: AWSHTTPBody) {
            self.contentType = contentType
            self.nsdContent = nsdContent
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.contentType = try response.decodeHeaderIfPresent(PackageContentType.self, key: "Content-Type")
            self.nsdContent = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolNetworkPackageDescriptorInput: AWSEncodableShape {
        /// ID of the network service descriptor in the network package.
        public let nsdInfoId: String

        @inlinable
        public init(nsdInfoId: String) {
            self.nsdInfoId = nsdInfoId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.nsdInfoId, key: "nsdInfoId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nsdInfoId, name: "nsdInfoId", parent: name, pattern: "^np-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolNetworkPackageDescriptorOutput: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Indicates the media type of the resource.
        public let contentType: DescriptorContentType?
        /// Contents of the network service descriptor in the network package.
        public let nsd: AWSHTTPBody

        @inlinable
        public init(contentType: DescriptorContentType? = nil, nsd: AWSHTTPBody) {
            self.contentType = contentType
            self.nsd = nsd
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.contentType = try response.decodeHeaderIfPresent(DescriptorContentType.self, key: "Content-Type")
            self.nsd = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolNetworkPackageInput: AWSEncodableShape {
        /// ID of the network service descriptor in the network package.
        public let nsdInfoId: String

        @inlinable
        public init(nsdInfoId: String) {
            self.nsdInfoId = nsdInfoId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.nsdInfoId, key: "nsdInfoId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nsdInfoId, name: "nsdInfoId", parent: name, pattern: "^np-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSolNetworkPackageMetadata: AWSDecodableShape {
        /// The date that the resource was created.
        public let createdAt: Date
        /// The date that the resource was last modified.
        public let lastModified: Date
        /// Metadata related to the onboarded network service descriptor in the network package.
        public let nsd: NetworkArtifactMeta?

        @inlinable
        public init(createdAt: Date, lastModified: Date, nsd: NetworkArtifactMeta? = nil) {
            self.createdAt = createdAt
            self.lastModified = lastModified
            self.nsd = nsd
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastModified = "lastModified"
            case nsd = "nsd"
        }
    }

    public struct GetSolNetworkPackageOutput: AWSDecodableShape {
        /// Network package ARN.
        public let arn: String
        /// Network package ID.
        public let id: String
        public let metadata: GetSolNetworkPackageMetadata
        /// Network service descriptor ID.
        public let nsdId: String
        /// Network service descriptor name.
        public let nsdName: String
        /// Network service descriptor onboarding state.
        public let nsdOnboardingState: NsdOnboardingState
        /// Network service descriptor operational state.
        public let nsdOperationalState: NsdOperationalState
        /// Network service descriptor usage state.
        public let nsdUsageState: NsdUsageState
        /// Network service descriptor version.
        public let nsdVersion: String
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?
        /// Identifies the function package for the function package descriptor referenced by the onboarded network package.
        public let vnfPkgIds: [String]

        @inlinable
        public init(arn: String, id: String, metadata: GetSolNetworkPackageMetadata, nsdId: String, nsdName: String, nsdOnboardingState: NsdOnboardingState, nsdOperationalState: NsdOperationalState, nsdUsageState: NsdUsageState, nsdVersion: String, tags: [String: String]? = nil, vnfPkgIds: [String]) {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.nsdId = nsdId
            self.nsdName = nsdName
            self.nsdOnboardingState = nsdOnboardingState
            self.nsdOperationalState = nsdOperationalState
            self.nsdUsageState = nsdUsageState
            self.nsdVersion = nsdVersion
            self.tags = tags
            self.vnfPkgIds = vnfPkgIds
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case metadata = "metadata"
            case nsdId = "nsdId"
            case nsdName = "nsdName"
            case nsdOnboardingState = "nsdOnboardingState"
            case nsdOperationalState = "nsdOperationalState"
            case nsdUsageState = "nsdUsageState"
            case nsdVersion = "nsdVersion"
            case tags = "tags"
            case vnfPkgIds = "vnfPkgIds"
        }
    }

    public struct GetSolVnfInfo: AWSDecodableShape {
        /// Compute info used by the network function instance.
        public let vnfcResourceInfo: [GetSolVnfcResourceInfo]?
        /// State of the network function instance.
        public let vnfState: VnfOperationalState?

        @inlinable
        public init(vnfcResourceInfo: [GetSolVnfcResourceInfo]? = nil, vnfState: VnfOperationalState? = nil) {
            self.vnfcResourceInfo = vnfcResourceInfo
            self.vnfState = vnfState
        }

        private enum CodingKeys: String, CodingKey {
            case vnfcResourceInfo = "vnfcResourceInfo"
            case vnfState = "vnfState"
        }
    }

    public struct GetSolVnfcResourceInfo: AWSDecodableShape {
        /// The metadata of the network function compute.
        public let metadata: GetSolVnfcResourceInfoMetadata?

        @inlinable
        public init(metadata: GetSolVnfcResourceInfoMetadata? = nil) {
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
        }
    }

    public struct GetSolVnfcResourceInfoMetadata: AWSDecodableShape {
        /// Information about the cluster.
        public let cluster: String?
        /// Information about the helm chart.
        public let helmChart: String?
        /// Information about the node group.
        public let nodeGroup: String?

        @inlinable
        public init(cluster: String? = nil, helmChart: String? = nil, nodeGroup: String? = nil) {
            self.cluster = cluster
            self.helmChart = helmChart
            self.nodeGroup = nodeGroup
        }

        private enum CodingKeys: String, CodingKey {
            case cluster = "cluster"
            case helmChart = "helmChart"
            case nodeGroup = "nodeGroup"
        }
    }

    public struct InstantiateMetadata: AWSDecodableShape {
        /// The configurable properties used during instantiation.
        public let additionalParamsForNs: AWSDocument?
        /// The network service descriptor used for instantiating the network instance.
        public let nsdInfoId: String

        @inlinable
        public init(additionalParamsForNs: AWSDocument? = nil, nsdInfoId: String) {
            self.additionalParamsForNs = additionalParamsForNs
            self.nsdInfoId = nsdInfoId
        }

        private enum CodingKeys: String, CodingKey {
            case additionalParamsForNs = "additionalParamsForNs"
            case nsdInfoId = "nsdInfoId"
        }
    }

    public struct InstantiateSolNetworkInstanceInput: AWSEncodableShape {
        /// Provides values for the configurable properties.
        public let additionalParamsForNs: AWSDocument?
        /// A check for whether you have the required permissions for the action without actually making the request  and provides an error response. If you have the required permissions, the error response is DryRunOperation.  Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// ID of the network instance.
        public let nsInstanceId: String
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?

        @inlinable
        public init(additionalParamsForNs: AWSDocument? = nil, dryRun: Bool? = nil, nsInstanceId: String, tags: [String: String]? = nil) {
            self.additionalParamsForNs = additionalParamsForNs
            self.dryRun = dryRun
            self.nsInstanceId = nsInstanceId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalParamsForNs, forKey: .additionalParamsForNs)
            request.encodeQuery(self.dryRun, key: "dry_run")
            request.encodePath(self.nsInstanceId, key: "nsInstanceId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.nsInstanceId, name: "nsInstanceId", parent: name, pattern: "^ni-[a-f0-9]{17}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalParamsForNs = "additionalParamsForNs"
            case tags = "tags"
        }
    }

    public struct InstantiateSolNetworkInstanceOutput: AWSDecodableShape {
        /// The identifier of the network operation.
        public let nsLcmOpOccId: String
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?

        @inlinable
        public init(nsLcmOpOccId: String, tags: [String: String]? = nil) {
            self.nsLcmOpOccId = nsLcmOpOccId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nsLcmOpOccId = "nsLcmOpOccId"
            case tags = "tags"
        }
    }

    public struct LcmOperationInfo: AWSDecodableShape {
        /// The identifier of the network operation.
        public let nsLcmOpOccId: String

        @inlinable
        public init(nsLcmOpOccId: String) {
            self.nsLcmOpOccId = nsLcmOpOccId
        }

        private enum CodingKeys: String, CodingKey {
            case nsLcmOpOccId = "nsLcmOpOccId"
        }
    }

    public struct ListSolFunctionInstanceInfo: AWSDecodableShape {
        /// Network function instance ARN.
        public let arn: String
        /// Network function instance ID.
        public let id: String
        public let instantiatedVnfInfo: GetSolInstantiatedVnfInfo?
        /// Network function instance instantiation state.
        public let instantiationState: VnfInstantiationState
        /// Network function instance metadata.
        public let metadata: ListSolFunctionInstanceMetadata
        /// Network instance ID.
        public let nsInstanceId: String
        /// Function package ID.
        public let vnfPkgId: String
        /// Function package name.
        public let vnfPkgName: String?

        @inlinable
        public init(arn: String, id: String, instantiatedVnfInfo: GetSolInstantiatedVnfInfo? = nil, instantiationState: VnfInstantiationState, metadata: ListSolFunctionInstanceMetadata, nsInstanceId: String, vnfPkgId: String, vnfPkgName: String? = nil) {
            self.arn = arn
            self.id = id
            self.instantiatedVnfInfo = instantiatedVnfInfo
            self.instantiationState = instantiationState
            self.metadata = metadata
            self.nsInstanceId = nsInstanceId
            self.vnfPkgId = vnfPkgId
            self.vnfPkgName = vnfPkgName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case instantiatedVnfInfo = "instantiatedVnfInfo"
            case instantiationState = "instantiationState"
            case metadata = "metadata"
            case nsInstanceId = "nsInstanceId"
            case vnfPkgId = "vnfPkgId"
            case vnfPkgName = "vnfPkgName"
        }
    }

    public struct ListSolFunctionInstanceMetadata: AWSDecodableShape {
        /// When the network function instance was created.
        public let createdAt: Date
        /// When the network function instance was last modified.
        public let lastModified: Date

        @inlinable
        public init(createdAt: Date, lastModified: Date) {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastModified = "lastModified"
        }
    }

    public struct ListSolFunctionInstancesInput: AWSEncodableShape {
        /// The maximum number of results to include in the response.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "nextpage_opaque_marker")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSolFunctionInstancesOutput: AWSDecodableShape {
        /// Network function instances.
        public let functionInstances: [ListSolFunctionInstanceInfo]?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(functionInstances: [ListSolFunctionInstanceInfo]? = nil, nextToken: String? = nil) {
            self.functionInstances = functionInstances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case functionInstances = "functionInstances"
            case nextToken = "nextToken"
        }
    }

    public struct ListSolFunctionPackageInfo: AWSDecodableShape {
        /// Function package ARN.
        public let arn: String
        /// ID of the function package.
        public let id: String
        /// The metadata of the function package.
        public let metadata: ListSolFunctionPackageMetadata?
        /// Onboarding state of the function package.
        public let onboardingState: OnboardingState
        /// Operational state of the function package.
        public let operationalState: OperationalState
        /// Usage state of the function package.
        public let usageState: UsageState
        /// Identifies the function package and the function package descriptor.
        public let vnfdId: String?
        /// Identifies the version of the function package descriptor.
        public let vnfdVersion: String?
        /// The product name for the network function.
        public let vnfProductName: String?
        /// Provider of the function package and the function package descriptor.
        public let vnfProvider: String?

        @inlinable
        public init(arn: String, id: String, metadata: ListSolFunctionPackageMetadata? = nil, onboardingState: OnboardingState, operationalState: OperationalState, usageState: UsageState, vnfdId: String? = nil, vnfdVersion: String? = nil, vnfProductName: String? = nil, vnfProvider: String? = nil) {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.onboardingState = onboardingState
            self.operationalState = operationalState
            self.usageState = usageState
            self.vnfdId = vnfdId
            self.vnfdVersion = vnfdVersion
            self.vnfProductName = vnfProductName
            self.vnfProvider = vnfProvider
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case metadata = "metadata"
            case onboardingState = "onboardingState"
            case operationalState = "operationalState"
            case usageState = "usageState"
            case vnfdId = "vnfdId"
            case vnfdVersion = "vnfdVersion"
            case vnfProductName = "vnfProductName"
            case vnfProvider = "vnfProvider"
        }
    }

    public struct ListSolFunctionPackageMetadata: AWSDecodableShape {
        /// The date that the resource was created.
        public let createdAt: Date
        /// The date that the resource was last modified.
        public let lastModified: Date

        @inlinable
        public init(createdAt: Date, lastModified: Date) {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastModified = "lastModified"
        }
    }

    public struct ListSolFunctionPackagesInput: AWSEncodableShape {
        /// The maximum number of results to include in the response.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "nextpage_opaque_marker")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSolFunctionPackagesOutput: AWSDecodableShape {
        /// Function packages. A function package is a .zip file in CSAR (Cloud Service Archive) format that contains a network function (an ETSI standard telecommunication application) and function package descriptor that uses the TOSCA standard to describe how the network functions should run on your network.
        public let functionPackages: [ListSolFunctionPackageInfo]
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(functionPackages: [ListSolFunctionPackageInfo], nextToken: String? = nil) {
            self.functionPackages = functionPackages
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case functionPackages = "functionPackages"
            case nextToken = "nextToken"
        }
    }

    public struct ListSolNetworkInstanceInfo: AWSDecodableShape {
        /// Network instance ARN.
        public let arn: String
        /// ID of the network instance.
        public let id: String
        /// The metadata of the network instance.
        public let metadata: ListSolNetworkInstanceMetadata
        /// ID of the network service descriptor in the network package.
        public let nsdId: String
        /// ID of the network service descriptor in the network package.
        public let nsdInfoId: String
        /// Human-readable description of the network instance.
        public let nsInstanceDescription: String
        /// Human-readable name of the network instance.
        public let nsInstanceName: String
        /// The state of the network instance.
        public let nsState: NsState

        @inlinable
        public init(arn: String, id: String, metadata: ListSolNetworkInstanceMetadata, nsdId: String, nsdInfoId: String, nsInstanceDescription: String, nsInstanceName: String, nsState: NsState) {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.nsdId = nsdId
            self.nsdInfoId = nsdInfoId
            self.nsInstanceDescription = nsInstanceDescription
            self.nsInstanceName = nsInstanceName
            self.nsState = nsState
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case metadata = "metadata"
            case nsdId = "nsdId"
            case nsdInfoId = "nsdInfoId"
            case nsInstanceDescription = "nsInstanceDescription"
            case nsInstanceName = "nsInstanceName"
            case nsState = "nsState"
        }
    }

    public struct ListSolNetworkInstanceMetadata: AWSDecodableShape {
        /// The date that the resource was created.
        public let createdAt: Date
        /// The date that the resource was last modified.
        public let lastModified: Date

        @inlinable
        public init(createdAt: Date, lastModified: Date) {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastModified = "lastModified"
        }
    }

    public struct ListSolNetworkInstancesInput: AWSEncodableShape {
        /// The maximum number of results to include in the response.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "nextpage_opaque_marker")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSolNetworkInstancesOutput: AWSDecodableShape {
        /// Lists network instances.
        public let networkInstances: [ListSolNetworkInstanceInfo]?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(networkInstances: [ListSolNetworkInstanceInfo]? = nil, nextToken: String? = nil) {
            self.networkInstances = networkInstances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkInstances = "networkInstances"
            case nextToken = "nextToken"
        }
    }

    public struct ListSolNetworkOperationsInfo: AWSDecodableShape {
        /// Network operation ARN.
        public let arn: String
        /// Error related to this specific network operation.
        public let error: ProblemDetails?
        /// ID of this network operation.
        public let id: String
        /// Type of lifecycle management network operation.
        public let lcmOperationType: LcmOperationType
        /// Metadata related to this network operation.
        public let metadata: ListSolNetworkOperationsMetadata?
        /// ID of the network instance related to this operation.
        public let nsInstanceId: String
        /// The state of the network operation.
        public let operationState: NsLcmOperationState
        /// Type of the update. Only present if the network operation lcmOperationType is UPDATE.
        public let updateType: UpdateSolNetworkType?

        @inlinable
        public init(arn: String, error: ProblemDetails? = nil, id: String, lcmOperationType: LcmOperationType, metadata: ListSolNetworkOperationsMetadata? = nil, nsInstanceId: String, operationState: NsLcmOperationState, updateType: UpdateSolNetworkType? = nil) {
            self.arn = arn
            self.error = error
            self.id = id
            self.lcmOperationType = lcmOperationType
            self.metadata = metadata
            self.nsInstanceId = nsInstanceId
            self.operationState = operationState
            self.updateType = updateType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case error = "error"
            case id = "id"
            case lcmOperationType = "lcmOperationType"
            case metadata = "metadata"
            case nsInstanceId = "nsInstanceId"
            case operationState = "operationState"
            case updateType = "updateType"
        }
    }

    public struct ListSolNetworkOperationsInput: AWSEncodableShape {
        /// The maximum number of results to include in the response.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// Network instance id filter, to retrieve network operations associated to a network instance.
        public let nsInstanceId: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, nsInstanceId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.nsInstanceId = nsInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "nextpage_opaque_marker")
            request.encodeQuery(self.nsInstanceId, key: "nsInstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nsInstanceId, name: "nsInstanceId", parent: name, pattern: "^ni-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSolNetworkOperationsMetadata: AWSDecodableShape {
        /// The date that the resource was created.
        public let createdAt: Date
        /// The date that the resource was last modified.
        public let lastModified: Date
        /// The network service descriptor id used for the operation. Only present if the updateType is UPDATE_NS.
        public let nsdInfoId: String?
        /// The network function id used for the operation. Only present if the updateType is MODIFY_VNF_INFO.
        public let vnfInstanceId: String?

        @inlinable
        public init(createdAt: Date, lastModified: Date, nsdInfoId: String? = nil, vnfInstanceId: String? = nil) {
            self.createdAt = createdAt
            self.lastModified = lastModified
            self.nsdInfoId = nsdInfoId
            self.vnfInstanceId = vnfInstanceId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastModified = "lastModified"
            case nsdInfoId = "nsdInfoId"
            case vnfInstanceId = "vnfInstanceId"
        }
    }

    public struct ListSolNetworkOperationsOutput: AWSDecodableShape {
        /// Lists network operation occurrences. Lifecycle management operations are deploy, update, or delete operations.
        public let networkOperations: [ListSolNetworkOperationsInfo]?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(networkOperations: [ListSolNetworkOperationsInfo]? = nil, nextToken: String? = nil) {
            self.networkOperations = networkOperations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkOperations = "networkOperations"
            case nextToken = "nextToken"
        }
    }

    public struct ListSolNetworkPackageInfo: AWSDecodableShape {
        /// Network package ARN.
        public let arn: String
        /// ID of the individual network package.
        public let id: String
        /// The metadata of the network package.
        public let metadata: ListSolNetworkPackageMetadata
        /// Designer of the onboarded network service descriptor in the network package.
        public let nsdDesigner: String?
        /// ID of the network service descriptor on which the network package is based.
        public let nsdId: String?
        /// Identifies a network service descriptor in a version independent manner.
        public let nsdInvariantId: String?
        /// Name of the onboarded network service descriptor in the network package.
        public let nsdName: String?
        /// Onboarding state of the network service descriptor in the network package.
        public let nsdOnboardingState: NsdOnboardingState
        /// Operational state of the network service descriptor in the network package.
        public let nsdOperationalState: NsdOperationalState
        /// Usage state of the network service descriptor in the network package.
        public let nsdUsageState: NsdUsageState
        /// Version of the onboarded network service descriptor in the network package.
        public let nsdVersion: String?
        /// Identifies the function package for the function package descriptor referenced by the onboarded network package.
        public let vnfPkgIds: [String]?

        @inlinable
        public init(arn: String, id: String, metadata: ListSolNetworkPackageMetadata, nsdDesigner: String? = nil, nsdId: String? = nil, nsdInvariantId: String? = nil, nsdName: String? = nil, nsdOnboardingState: NsdOnboardingState, nsdOperationalState: NsdOperationalState, nsdUsageState: NsdUsageState, nsdVersion: String? = nil, vnfPkgIds: [String]? = nil) {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.nsdDesigner = nsdDesigner
            self.nsdId = nsdId
            self.nsdInvariantId = nsdInvariantId
            self.nsdName = nsdName
            self.nsdOnboardingState = nsdOnboardingState
            self.nsdOperationalState = nsdOperationalState
            self.nsdUsageState = nsdUsageState
            self.nsdVersion = nsdVersion
            self.vnfPkgIds = vnfPkgIds
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case metadata = "metadata"
            case nsdDesigner = "nsdDesigner"
            case nsdId = "nsdId"
            case nsdInvariantId = "nsdInvariantId"
            case nsdName = "nsdName"
            case nsdOnboardingState = "nsdOnboardingState"
            case nsdOperationalState = "nsdOperationalState"
            case nsdUsageState = "nsdUsageState"
            case nsdVersion = "nsdVersion"
            case vnfPkgIds = "vnfPkgIds"
        }
    }

    public struct ListSolNetworkPackageMetadata: AWSDecodableShape {
        /// The date that the resource was created.
        public let createdAt: Date
        /// The date that the resource was last modified.
        public let lastModified: Date

        @inlinable
        public init(createdAt: Date, lastModified: Date) {
            self.createdAt = createdAt
            self.lastModified = lastModified
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastModified = "lastModified"
        }
    }

    public struct ListSolNetworkPackagesInput: AWSEncodableShape {
        /// The maximum number of results to include in the response.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "nextpage_opaque_marker")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSolNetworkPackagesOutput: AWSDecodableShape {
        /// Network packages. A network package is a .zip file in CSAR (Cloud Service Archive) format defines the function packages you want to deploy and the Amazon Web Services infrastructure you want to deploy them on.
        public let networkPackages: [ListSolNetworkPackageInfo]
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(networkPackages: [ListSolNetworkPackageInfo], nextToken: String? = nil) {
            self.networkPackages = networkPackages
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkPackages = "networkPackages"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// Resource ARN.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:tnb:[a-z0-9-]+:[^:]*:.*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]

        @inlinable
        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ModifyVnfInfoMetadata: AWSDecodableShape {
        /// The configurable properties used during update of the network function instance.
        public let vnfConfigurableProperties: AWSDocument
        /// The network function instance that was updated in the network instance.
        public let vnfInstanceId: String

        @inlinable
        public init(vnfConfigurableProperties: AWSDocument, vnfInstanceId: String) {
            self.vnfConfigurableProperties = vnfConfigurableProperties
            self.vnfInstanceId = vnfInstanceId
        }

        private enum CodingKeys: String, CodingKey {
            case vnfConfigurableProperties = "vnfConfigurableProperties"
            case vnfInstanceId = "vnfInstanceId"
        }
    }

    public struct NetworkArtifactMeta: AWSDecodableShape {
        /// Lists network package overrides.
        public let overrides: [ToscaOverride]?

        @inlinable
        public init(overrides: [ToscaOverride]? = nil) {
            self.overrides = overrides
        }

        private enum CodingKeys: String, CodingKey {
            case overrides = "overrides"
        }
    }

    public struct ProblemDetails: AWSDecodableShape {
        /// A human-readable explanation specific to this occurrence of the problem.
        public let detail: String
        /// A human-readable title of the problem type.
        public let title: String?

        @inlinable
        public init(detail: String, title: String? = nil) {
            self.detail = detail
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case detail = "detail"
            case title = "title"
        }
    }

    public struct PutSolFunctionPackageContentInput: AWSEncodableShape {
        /// Function package content type.
        public let contentType: PackageContentType?
        /// Function package file.
        public let file: AWSHTTPBody
        /// Function package ID.
        public let vnfPkgId: String

        @inlinable
        public init(contentType: PackageContentType? = nil, file: AWSHTTPBody, vnfPkgId: String) {
            self.contentType = contentType
            self.file = file
            self.vnfPkgId = vnfPkgId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.contentType, key: "Content-Type")
            try container.encode(self.file)
            request.encodePath(self.vnfPkgId, key: "vnfPkgId")
        }

        public func validate(name: String) throws {
            try self.validate(self.vnfPkgId, name: "vnfPkgId", parent: name, pattern: "^fp-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PutSolFunctionPackageContentMetadata: AWSDecodableShape {
        public let vnfd: FunctionArtifactMeta?

        @inlinable
        public init(vnfd: FunctionArtifactMeta? = nil) {
            self.vnfd = vnfd
        }

        private enum CodingKeys: String, CodingKey {
            case vnfd = "vnfd"
        }
    }

    public struct PutSolFunctionPackageContentOutput: AWSDecodableShape {
        /// Function package ID.
        public let id: String
        /// Function package metadata.
        public let metadata: PutSolFunctionPackageContentMetadata
        /// Function package descriptor ID.
        public let vnfdId: String
        /// Function package descriptor version.
        public let vnfdVersion: String
        /// Function product name.
        public let vnfProductName: String
        /// Function provider.
        public let vnfProvider: String

        @inlinable
        public init(id: String, metadata: PutSolFunctionPackageContentMetadata, vnfdId: String, vnfdVersion: String, vnfProductName: String, vnfProvider: String) {
            self.id = id
            self.metadata = metadata
            self.vnfdId = vnfdId
            self.vnfdVersion = vnfdVersion
            self.vnfProductName = vnfProductName
            self.vnfProvider = vnfProvider
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case metadata = "metadata"
            case vnfdId = "vnfdId"
            case vnfdVersion = "vnfdVersion"
            case vnfProductName = "vnfProductName"
            case vnfProvider = "vnfProvider"
        }
    }

    public struct PutSolNetworkPackageContentInput: AWSEncodableShape {
        /// Network package content type.
        public let contentType: PackageContentType?
        /// Network package file.
        public let file: AWSHTTPBody
        /// Network service descriptor info ID.
        public let nsdInfoId: String

        @inlinable
        public init(contentType: PackageContentType? = nil, file: AWSHTTPBody, nsdInfoId: String) {
            self.contentType = contentType
            self.file = file
            self.nsdInfoId = nsdInfoId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.contentType, key: "Content-Type")
            try container.encode(self.file)
            request.encodePath(self.nsdInfoId, key: "nsdInfoId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nsdInfoId, name: "nsdInfoId", parent: name, pattern: "^np-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PutSolNetworkPackageContentMetadata: AWSDecodableShape {
        public let nsd: NetworkArtifactMeta?

        @inlinable
        public init(nsd: NetworkArtifactMeta? = nil) {
            self.nsd = nsd
        }

        private enum CodingKeys: String, CodingKey {
            case nsd = "nsd"
        }
    }

    public struct PutSolNetworkPackageContentOutput: AWSDecodableShape {
        /// Network package ARN.
        public let arn: String
        /// Network package ID.
        public let id: String
        /// Network package metadata.
        public let metadata: PutSolNetworkPackageContentMetadata
        /// Network service descriptor ID.
        public let nsdId: String
        /// Network service descriptor name.
        public let nsdName: String
        /// Network service descriptor version.
        public let nsdVersion: String
        /// Function package IDs.
        public let vnfPkgIds: [String]

        @inlinable
        public init(arn: String, id: String, metadata: PutSolNetworkPackageContentMetadata, nsdId: String, nsdName: String, nsdVersion: String, vnfPkgIds: [String]) {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.nsdId = nsdId
            self.nsdName = nsdName
            self.nsdVersion = nsdVersion
            self.vnfPkgIds = vnfPkgIds
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case metadata = "metadata"
            case nsdId = "nsdId"
            case nsdName = "nsdName"
            case nsdVersion = "nsdVersion"
            case vnfPkgIds = "vnfPkgIds"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// Resource ARN.
        public let resourceArn: String
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:tnb:[a-z0-9-]+:[^:]*:.*$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct TerminateSolNetworkInstanceInput: AWSEncodableShape {
        /// ID of the network instance.
        public let nsInstanceId: String
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?

        @inlinable
        public init(nsInstanceId: String, tags: [String: String]? = nil) {
            self.nsInstanceId = nsInstanceId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.nsInstanceId, key: "nsInstanceId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.nsInstanceId, name: "nsInstanceId", parent: name, pattern: "^ni-[a-f0-9]{17}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TerminateSolNetworkInstanceOutput: AWSDecodableShape {
        /// The identifier of the network operation.
        public let nsLcmOpOccId: String?
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?

        @inlinable
        public init(nsLcmOpOccId: String? = nil, tags: [String: String]? = nil) {
            self.nsLcmOpOccId = nsLcmOpOccId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nsLcmOpOccId = "nsLcmOpOccId"
            case tags = "tags"
        }
    }

    public struct ToscaOverride: AWSDecodableShape {
        /// Default value for the override.
        public let defaultValue: String?
        /// Name of the TOSCA override.
        public let name: String?

        @inlinable
        public init(defaultValue: String? = nil, name: String? = nil) {
            self.defaultValue = defaultValue
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case name = "name"
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// Resource ARN.
        public let resourceArn: String
        /// Tag keys.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:tnb:[a-z0-9-]+:[^:]*:.*$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:).{1,128}$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateNsMetadata: AWSDecodableShape {
        /// The configurable properties used during update.
        public let additionalParamsForNs: AWSDocument?
        /// The network service descriptor used for updating the network instance.
        public let nsdInfoId: String

        @inlinable
        public init(additionalParamsForNs: AWSDocument? = nil, nsdInfoId: String) {
            self.additionalParamsForNs = additionalParamsForNs
            self.nsdInfoId = nsdInfoId
        }

        private enum CodingKeys: String, CodingKey {
            case additionalParamsForNs = "additionalParamsForNs"
            case nsdInfoId = "nsdInfoId"
        }
    }

    public struct UpdateSolFunctionPackageInput: AWSEncodableShape {
        /// Operational state of the function package.
        public let operationalState: OperationalState
        /// ID of the function package.
        public let vnfPkgId: String

        @inlinable
        public init(operationalState: OperationalState, vnfPkgId: String) {
            self.operationalState = operationalState
            self.vnfPkgId = vnfPkgId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.operationalState, forKey: .operationalState)
            request.encodePath(self.vnfPkgId, key: "vnfPkgId")
        }

        public func validate(name: String) throws {
            try self.validate(self.vnfPkgId, name: "vnfPkgId", parent: name, pattern: "^fp-[a-f0-9]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case operationalState = "operationalState"
        }
    }

    public struct UpdateSolFunctionPackageOutput: AWSDecodableShape {
        /// Operational state of the function package.
        public let operationalState: OperationalState

        @inlinable
        public init(operationalState: OperationalState) {
            self.operationalState = operationalState
        }

        private enum CodingKeys: String, CodingKey {
            case operationalState = "operationalState"
        }
    }

    public struct UpdateSolNetworkInstanceInput: AWSEncodableShape {
        /// Identifies the network function information parameters and/or the configurable properties of the network function to be modified. Include this property only if the update type is MODIFY_VNF_INFORMATION.
        public let modifyVnfInfoData: UpdateSolNetworkModify?
        /// ID of the network instance.
        public let nsInstanceId: String
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?
        /// Identifies the network service descriptor and the configurable properties of the descriptor, to be used for the update. Include this property only if the update type is UPDATE_NS.
        public let updateNs: UpdateSolNetworkServiceData?
        /// The type of update.   Use the MODIFY_VNF_INFORMATION update type, to update a specific network function configuration, in the network instance.   Use the UPDATE_NS update type, to update the network instance to a new network service descriptor.
        public let updateType: UpdateSolNetworkType

        @inlinable
        public init(modifyVnfInfoData: UpdateSolNetworkModify? = nil, nsInstanceId: String, tags: [String: String]? = nil, updateNs: UpdateSolNetworkServiceData? = nil, updateType: UpdateSolNetworkType) {
            self.modifyVnfInfoData = modifyVnfInfoData
            self.nsInstanceId = nsInstanceId
            self.tags = tags
            self.updateNs = updateNs
            self.updateType = updateType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.modifyVnfInfoData, forKey: .modifyVnfInfoData)
            request.encodePath(self.nsInstanceId, key: "nsInstanceId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.updateNs, forKey: .updateNs)
            try container.encode(self.updateType, forKey: .updateType)
        }

        public func validate(name: String) throws {
            try self.modifyVnfInfoData?.validate(name: "\(name).modifyVnfInfoData")
            try self.validate(self.nsInstanceId, name: "nsInstanceId", parent: name, pattern: "^ni-[a-f0-9]{17}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.updateNs?.validate(name: "\(name).updateNs")
        }

        private enum CodingKeys: String, CodingKey {
            case modifyVnfInfoData = "modifyVnfInfoData"
            case tags = "tags"
            case updateNs = "updateNs"
            case updateType = "updateType"
        }
    }

    public struct UpdateSolNetworkInstanceOutput: AWSDecodableShape {
        /// The identifier of the network operation.
        public let nsLcmOpOccId: String?
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value. When you use this API, the tags are only applied to the network operation that is created. These tags are not applied to the network instance. Use tags to search and filter your resources or track your Amazon Web Services costs.
        public let tags: [String: String]?

        @inlinable
        public init(nsLcmOpOccId: String? = nil, tags: [String: String]? = nil) {
            self.nsLcmOpOccId = nsLcmOpOccId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nsLcmOpOccId = "nsLcmOpOccId"
            case tags = "tags"
        }
    }

    public struct UpdateSolNetworkModify: AWSEncodableShape {
        /// Provides values for the configurable properties declared in the function package descriptor.
        public let vnfConfigurableProperties: AWSDocument
        /// ID of the network function instance. A network function instance is a function in a function package .
        public let vnfInstanceId: String

        @inlinable
        public init(vnfConfigurableProperties: AWSDocument, vnfInstanceId: String) {
            self.vnfConfigurableProperties = vnfConfigurableProperties
            self.vnfInstanceId = vnfInstanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.vnfInstanceId, name: "vnfInstanceId", parent: name, pattern: "^fi-[a-f0-9]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case vnfConfigurableProperties = "vnfConfigurableProperties"
            case vnfInstanceId = "vnfInstanceId"
        }
    }

    public struct UpdateSolNetworkPackageInput: AWSEncodableShape {
        /// ID of the network service descriptor in the network package.
        public let nsdInfoId: String
        /// Operational state of the network service descriptor in the network package.
        public let nsdOperationalState: NsdOperationalState

        @inlinable
        public init(nsdInfoId: String, nsdOperationalState: NsdOperationalState) {
            self.nsdInfoId = nsdInfoId
            self.nsdOperationalState = nsdOperationalState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.nsdInfoId, key: "nsdInfoId")
            try container.encode(self.nsdOperationalState, forKey: .nsdOperationalState)
        }

        public func validate(name: String) throws {
            try self.validate(self.nsdInfoId, name: "nsdInfoId", parent: name, pattern: "^np-[a-f0-9]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case nsdOperationalState = "nsdOperationalState"
        }
    }

    public struct UpdateSolNetworkPackageOutput: AWSDecodableShape {
        /// Operational state of the network service descriptor in the network package.
        public let nsdOperationalState: NsdOperationalState

        @inlinable
        public init(nsdOperationalState: NsdOperationalState) {
            self.nsdOperationalState = nsdOperationalState
        }

        private enum CodingKeys: String, CodingKey {
            case nsdOperationalState = "nsdOperationalState"
        }
    }

    public struct UpdateSolNetworkServiceData: AWSEncodableShape {
        /// Values for the configurable properties declared in the network service descriptor.
        public let additionalParamsForNs: AWSDocument?
        /// ID of the network service descriptor.
        public let nsdInfoId: String

        @inlinable
        public init(additionalParamsForNs: AWSDocument? = nil, nsdInfoId: String) {
            self.additionalParamsForNs = additionalParamsForNs
            self.nsdInfoId = nsdInfoId
        }

        public func validate(name: String) throws {
            try self.validate(self.nsdInfoId, name: "nsdInfoId", parent: name, pattern: "^np-[a-f0-9]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalParamsForNs = "additionalParamsForNs"
            case nsdInfoId = "nsdInfoId"
        }
    }

    public struct ValidateSolFunctionPackageContentInput: AWSEncodableShape {
        /// Function package content type.
        public let contentType: PackageContentType?
        /// Function package file.
        public let file: AWSHTTPBody
        /// Function package ID.
        public let vnfPkgId: String

        @inlinable
        public init(contentType: PackageContentType? = nil, file: AWSHTTPBody, vnfPkgId: String) {
            self.contentType = contentType
            self.file = file
            self.vnfPkgId = vnfPkgId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.contentType, key: "Content-Type")
            try container.encode(self.file)
            request.encodePath(self.vnfPkgId, key: "vnfPkgId")
        }

        public func validate(name: String) throws {
            try self.validate(self.vnfPkgId, name: "vnfPkgId", parent: name, pattern: "^fp-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ValidateSolFunctionPackageContentMetadata: AWSDecodableShape {
        public let vnfd: FunctionArtifactMeta?

        @inlinable
        public init(vnfd: FunctionArtifactMeta? = nil) {
            self.vnfd = vnfd
        }

        private enum CodingKeys: String, CodingKey {
            case vnfd = "vnfd"
        }
    }

    public struct ValidateSolFunctionPackageContentOutput: AWSDecodableShape {
        /// Function package ID.
        public let id: String
        /// Function package metadata.
        public let metadata: ValidateSolFunctionPackageContentMetadata
        /// Function package descriptor ID.
        public let vnfdId: String
        /// Function package descriptor version.
        public let vnfdVersion: String
        /// Network function product name.
        public let vnfProductName: String
        /// Network function provider.
        public let vnfProvider: String

        @inlinable
        public init(id: String, metadata: ValidateSolFunctionPackageContentMetadata, vnfdId: String, vnfdVersion: String, vnfProductName: String, vnfProvider: String) {
            self.id = id
            self.metadata = metadata
            self.vnfdId = vnfdId
            self.vnfdVersion = vnfdVersion
            self.vnfProductName = vnfProductName
            self.vnfProvider = vnfProvider
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case metadata = "metadata"
            case vnfdId = "vnfdId"
            case vnfdVersion = "vnfdVersion"
            case vnfProductName = "vnfProductName"
            case vnfProvider = "vnfProvider"
        }
    }

    public struct ValidateSolNetworkPackageContentInput: AWSEncodableShape {
        /// Network package content type.
        public let contentType: PackageContentType?
        /// Network package file.
        public let file: AWSHTTPBody
        /// Network service descriptor file.
        public let nsdInfoId: String

        @inlinable
        public init(contentType: PackageContentType? = nil, file: AWSHTTPBody, nsdInfoId: String) {
            self.contentType = contentType
            self.file = file
            self.nsdInfoId = nsdInfoId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.contentType, key: "Content-Type")
            try container.encode(self.file)
            request.encodePath(self.nsdInfoId, key: "nsdInfoId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nsdInfoId, name: "nsdInfoId", parent: name, pattern: "^np-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ValidateSolNetworkPackageContentMetadata: AWSDecodableShape {
        public let nsd: NetworkArtifactMeta?

        @inlinable
        public init(nsd: NetworkArtifactMeta? = nil) {
            self.nsd = nsd
        }

        private enum CodingKeys: String, CodingKey {
            case nsd = "nsd"
        }
    }

    public struct ValidateSolNetworkPackageContentOutput: AWSDecodableShape {
        /// Network package ARN.
        public let arn: String
        /// Network package ID.
        public let id: String
        /// Network package metadata.
        public let metadata: ValidateSolNetworkPackageContentMetadata
        /// Network service descriptor ID.
        public let nsdId: String
        /// Network service descriptor name.
        public let nsdName: String
        /// Network service descriptor version.
        public let nsdVersion: String
        /// Function package IDs.
        public let vnfPkgIds: [String]

        @inlinable
        public init(arn: String, id: String, metadata: ValidateSolNetworkPackageContentMetadata, nsdId: String, nsdName: String, nsdVersion: String, vnfPkgIds: [String]) {
            self.arn = arn
            self.id = id
            self.metadata = metadata
            self.nsdId = nsdId
            self.nsdName = nsdName
            self.nsdVersion = nsdVersion
            self.vnfPkgIds = vnfPkgIds
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case metadata = "metadata"
            case nsdId = "nsdId"
            case nsdName = "nsdName"
            case nsdVersion = "nsdVersion"
            case vnfPkgIds = "vnfPkgIds"
        }
    }
}

// MARK: - Errors

/// Error enum for Tnb
public struct TnbErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Tnb
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Insufficient permissions to make request.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Unexpected error occurred. Problem on the server.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource that doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Service quotas have been exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Exception caused by throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Unable to process the request because the client provided input failed to satisfy request constraints.
    public static var validationException: Self { .init(.validationException) }
}

extension TnbErrorType: Equatable {
    public static func == (lhs: TnbErrorType, rhs: TnbErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension TnbErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
