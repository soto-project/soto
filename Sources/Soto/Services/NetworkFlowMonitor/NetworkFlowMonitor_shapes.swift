//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension NetworkFlowMonitor {
    // MARK: Enums

    public enum DestinationCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonDynamodb = "AMAZON_DYNAMODB"
        case amazonS3 = "AMAZON_S3"
        case interAz = "INTER_AZ"
        case interVpc = "INTER_VPC"
        case intraAz = "INTRA_AZ"
        case unclassified = "UNCLASSIFIED"
        public var description: String { return self.rawValue }
    }

    public enum MetricUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bits = "Bits"
        case bitsPerSecond = "Bits/Second"
        case bytes = "Bytes"
        case bytesPerSecond = "Bytes/Second"
        case count = "Count"
        case countPerSecond = "Count/Second"
        case gigabits = "Gigabits"
        case gigabitsPerSecond = "Gigabits/Second"
        case gigabytes = "Gigabytes"
        case gigabytesPerSecond = "Gigabytes/Second"
        case kilobits = "Kilobits"
        case kilobitsPerSecond = "Kilobits/Second"
        case kilobytes = "Kilobytes"
        case kilobytesPerSecond = "Kilobytes/Second"
        case megabits = "Megabits"
        case megabitsPerSecond = "Megabits/Second"
        case megabytes = "Megabytes"
        case megabytesPerSecond = "Megabytes/Second"
        case microseconds = "Microseconds"
        case milliseconds = "Milliseconds"
        case none = "None"
        case percent = "Percent"
        case seconds = "Seconds"
        case terabits = "Terabits"
        case terabitsPerSecond = "Terabits/Second"
        case terabytes = "Terabytes"
        case terabytesPerSecond = "Terabytes/Second"
        public var description: String { return self.rawValue }
    }

    public enum MonitorLocalResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsAz = "AWS::AvailabilityZone"
        case awsSubnet = "AWS::EC2::Subnet"
        case awsVpc = "AWS::EC2::VPC"
        public var description: String { return self.rawValue }
    }

    public enum MonitorMetric: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dataTransferred = "DATA_TRANSFERRED"
        case retransmissions = "RETRANSMISSIONS"
        case roundTripTime = "ROUND_TRIP_TIME"
        case timeouts = "TIMEOUTS"
        public var description: String { return self.rawValue }
    }

    public enum MonitorRemoteResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsAz = "AWS::AvailabilityZone"
        case awsService = "AWS::AWSService"
        case awsSubnet = "AWS::EC2::Subnet"
        case awsVpc = "AWS::EC2::VPC"
        public var description: String { return self.rawValue }
    }

    public enum MonitorStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        case error = "ERROR"
        case inactive = "INACTIVE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum QueryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case queued = "QUEUED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ScopeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum TargetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case account = "ACCOUNT"
        public var description: String { return self.rawValue }
    }

    public enum WorkloadInsightsMetric: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dataTransferred = "DATA_TRANSFERRED"
        case retransmissions = "RETRANSMISSIONS"
        case timeouts = "TIMEOUTS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateMonitorInput: AWSEncodableShape {
        /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. Don't reuse the same client token for 		other API requests.
        public let clientToken: String?
        /// The local resources to monitor. A local resource, in a bi-directional flow of a workload,  		is the host where the agent is installed. For example, if a workload consists of an interaction  		between a web service and a backend database (for example, Amazon Relational Database Service (RDS)),  		the EC2 instance hosting the web service, which also runs the agent, is the local resource.
        public let localResources: [MonitorLocalResource]
        /// The name of the monitor.
        public let monitorName: String
        /// The remote resources to monitor. A remote resource is the other endpoint in the bi-directional  		flow of a workload, with a local resource. For example, Amazon Relational Database Service (RDS) can be a remote resource.
        public let remoteResources: [MonitorRemoteResource]?
        /// The Amazon Resource Name (ARN) of the scope for the monitor.
        public let scopeArn: String
        /// The tags for a monitor. You can add a maximum of 200 tags.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateMonitorInput.idempotencyToken(), localResources: [MonitorLocalResource], monitorName: String, remoteResources: [MonitorRemoteResource]? = nil, scopeArn: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.localResources = localResources
            self.monitorName = monitorName
            self.remoteResources = remoteResources
            self.scopeArn = scopeArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.scopeArn, name: "scopeArn", parent: name, max: 2048)
            try self.validate(self.scopeArn, name: "scopeArn", parent: name, min: 20)
            try self.validate(self.scopeArn, name: "scopeArn", parent: name, pattern: "^arn:.*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case localResources = "localResources"
            case monitorName = "monitorName"
            case remoteResources = "remoteResources"
            case scopeArn = "scopeArn"
            case tags = "tags"
        }
    }

    public struct CreateMonitorOutput: AWSDecodableShape {
        /// The date and time when the monitor was created.
        public let createdAt: Date
        /// The local resources to monitor. A local resource, in a bi-directional flow of a workload,  	is the host where the agent is installed.
        public let localResources: [MonitorLocalResource]
        /// The last date and time that the monitor was modified.
        public let modifiedAt: Date
        /// The Amazon Resource Name (ARN) of the monitor.
        public let monitorArn: String
        /// The name of the monitor.
        public let monitorName: String
        /// The status of a monitor. The status can be one of the following    PENDING: The monitor is in the process of being created.    ACTIVE: The monitor is active.    INACTIVE: The monitor is inactive.    ERROR: Monitor creation failed due to an error.    DELETING: The monitor is in the process of being deleted.
        public let monitorStatus: MonitorStatus
        /// The remote resources to monitor. A remote resource is the other endpoint in the bi-directional  		flow of a workload, with a local resource. For example, Amazon Relational Database Service (RDS) can  		be a remote resource. The remote resource is identified by its ARN or an identifier.
        public let remoteResources: [MonitorRemoteResource]
        /// The tags for a monitor.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date, localResources: [MonitorLocalResource], modifiedAt: Date, monitorArn: String, monitorName: String, monitorStatus: MonitorStatus, remoteResources: [MonitorRemoteResource], tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.localResources = localResources
            self.modifiedAt = modifiedAt
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.monitorStatus = monitorStatus
            self.remoteResources = remoteResources
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case localResources = "localResources"
            case modifiedAt = "modifiedAt"
            case monitorArn = "monitorArn"
            case monitorName = "monitorName"
            case monitorStatus = "monitorStatus"
            case remoteResources = "remoteResources"
            case tags = "tags"
        }
    }

    public struct CreateScopeInput: AWSEncodableShape {
        /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent  		API request. Don't reuse the same client token for other API requests.
        public let clientToken: String?
        /// The tags for a scope. You can add a maximum of 200 tags.
        public let tags: [String: String]?
        /// The targets to define the scope to be monitored. Currently, a target is an Amazon Web Services account.
        public let targets: [TargetResource]

        @inlinable
        public init(clientToken: String? = CreateScopeInput.idempotencyToken(), tags: [String: String]? = nil, targets: [TargetResource]) {
            self.clientToken = clientToken
            self.tags = tags
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.targets.forEach {
                try $0.validate(name: "\(name).targets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case tags = "tags"
            case targets = "targets"
        }
    }

    public struct CreateScopeOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the scope.
        public let scopeArn: String
        /// The identifier for the scope that includes the resources you want to get metrics for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account.
        public let scopeId: String
        /// The status for a call to create a scope. The status can be one of the following:  		SUCCEEDED, IN_PROGRESS, or FAILED.
        public let status: ScopeStatus
        /// The tags for a scope.
        public let tags: [String: String]?

        @inlinable
        public init(scopeArn: String, scopeId: String, status: ScopeStatus, tags: [String: String]? = nil) {
            self.scopeArn = scopeArn
            self.scopeId = scopeId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case scopeArn = "scopeArn"
            case scopeId = "scopeId"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct DeleteMonitorInput: AWSEncodableShape {
        /// The name of the monitor to delete.
        public let monitorName: String

        @inlinable
        public init(monitorName: String) {
            self.monitorName = monitorName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.monitorName, key: "monitorName")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMonitorOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteScopeInput: AWSEncodableShape {
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account.
        public let scopeId: String

        @inlinable
        public init(scopeId: String) {
            self.scopeId = scopeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.scopeId, key: "scopeId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteScopeOutput: AWSDecodableShape {
        public init() {}
    }

    public struct GetMonitorInput: AWSEncodableShape {
        /// The name of the monitor.
        public let monitorName: String

        @inlinable
        public init(monitorName: String) {
            self.monitorName = monitorName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.monitorName, key: "monitorName")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMonitorOutput: AWSDecodableShape {
        /// The date and time when the monitor was created.
        public let createdAt: Date
        /// The local resources for this monitor.
        public let localResources: [MonitorLocalResource]
        /// The date and time when the monitor was last modified.
        public let modifiedAt: Date
        /// The Amazon Resource Name (ARN) of the monitor.
        public let monitorArn: String
        /// The name of the monitor.
        public let monitorName: String
        /// The status of a monitor. The status can be one of the following    PENDING: The monitor is in the process of being created.    ACTIVE: The monitor is active.    INACTIVE: The monitor is inactive.    ERROR: Monitor creation failed due to an error.    DELETING: The monitor is in the process of being deleted.
        public let monitorStatus: MonitorStatus
        /// The remote resources for this monitor.
        public let remoteResources: [MonitorRemoteResource]
        /// The tags for a monitor.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date, localResources: [MonitorLocalResource], modifiedAt: Date, monitorArn: String, monitorName: String, monitorStatus: MonitorStatus, remoteResources: [MonitorRemoteResource], tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.localResources = localResources
            self.modifiedAt = modifiedAt
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.monitorStatus = monitorStatus
            self.remoteResources = remoteResources
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case localResources = "localResources"
            case modifiedAt = "modifiedAt"
            case monitorArn = "monitorArn"
            case monitorName = "monitorName"
            case monitorStatus = "monitorStatus"
            case remoteResources = "remoteResources"
            case tags = "tags"
        }
    }

    public struct GetQueryResultsMonitorTopContributorsInput: AWSEncodableShape {
        /// The number of query results that you want to return with this call.
        public let maxResults: Int?
        /// The name of the monitor.
        public let monitorName: String
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String

        @inlinable
        public init(maxResults: Int? = nil, monitorName: String, nextToken: String? = nil, queryId: String) {
            self.maxResults = maxResults
            self.monitorName = monitorName
            self.nextToken = nextToken
            self.queryId = queryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.monitorName, key: "monitorName")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queryId, key: "queryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueryResultsMonitorTopContributorsOutput: AWSDecodableShape {
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?
        /// The top contributor network flows overall for a specific metric type, for example, the  		number of retransmissions.
        public let topContributors: [MonitorTopContributorsRow]?
        /// The units for a metric returned by the query.
        public let unit: MetricUnit?

        @inlinable
        public init(nextToken: String? = nil, topContributors: [MonitorTopContributorsRow]? = nil, unit: MetricUnit? = nil) {
            self.nextToken = nextToken
            self.topContributors = topContributors
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case topContributors = "topContributors"
            case unit = "unit"
        }
    }

    public struct GetQueryResultsWorkloadInsightsTopContributorsDataInput: AWSEncodableShape {
        /// The number of query results that you want to return with this call.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account.
        public let scopeId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, queryId: String, scopeId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryId = queryId
            self.scopeId = scopeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queryId, key: "queryId")
            request.encodePath(self.scopeId, key: "scopeId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueryResultsWorkloadInsightsTopContributorsDataOutput: AWSDecodableShape {
        /// The datapoints returned by the query.
        public let datapoints: [WorkloadInsightsTopContributorsDataPoint]
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?
        /// The units for a metric returned by the query.
        public let unit: MetricUnit

        @inlinable
        public init(datapoints: [WorkloadInsightsTopContributorsDataPoint], nextToken: String? = nil, unit: MetricUnit) {
            self.datapoints = datapoints
            self.nextToken = nextToken
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case datapoints = "datapoints"
            case nextToken = "nextToken"
            case unit = "unit"
        }
    }

    public struct GetQueryResultsWorkloadInsightsTopContributorsInput: AWSEncodableShape {
        /// The number of query results that you want to return with this call.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account.
        public let scopeId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, queryId: String, scopeId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryId = queryId
            self.scopeId = scopeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queryId, key: "queryId")
            request.encodePath(self.scopeId, key: "scopeId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueryResultsWorkloadInsightsTopContributorsOutput: AWSDecodableShape {
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?
        /// The top contributor network flows overall for a specific metric type, for example, the  		number of retransmissions.
        public let topContributors: [WorkloadInsightsTopContributorsRow]?

        @inlinable
        public init(nextToken: String? = nil, topContributors: [WorkloadInsightsTopContributorsRow]? = nil) {
            self.nextToken = nextToken
            self.topContributors = topContributors
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case topContributors = "topContributors"
        }
    }

    public struct GetQueryStatusMonitorTopContributorsInput: AWSEncodableShape {
        /// The name of the monitor.
        public let monitorName: String
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String

        @inlinable
        public init(monitorName: String, queryId: String) {
            self.monitorName = monitorName
            self.queryId = queryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.monitorName, key: "monitorName")
            request.encodePath(self.queryId, key: "queryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueryStatusMonitorTopContributorsOutput: AWSDecodableShape {
        /// When you run a query, use this call to check the status of the query to make sure that the query  		has SUCCEEDED before you review the results.    QUEUED: The query is scheduled to run.    RUNNING: The query is in progress but not complete.    SUCCEEDED: The query completed sucessfully.    FAILED: The query failed due to an error.    CANCELED: The query was canceled.
        public let status: QueryStatus

        @inlinable
        public init(status: QueryStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct GetQueryStatusWorkloadInsightsTopContributorsDataInput: AWSEncodableShape {
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account. A scope ID is returned from a CreateScope API call.
        public let scopeId: String

        @inlinable
        public init(queryId: String, scopeId: String) {
            self.queryId = queryId
            self.scopeId = scopeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.queryId, key: "queryId")
            request.encodePath(self.scopeId, key: "scopeId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueryStatusWorkloadInsightsTopContributorsDataOutput: AWSDecodableShape {
        /// The status of a query for top contributors data.    QUEUED: The query is scheduled to run.    RUNNING: The query is in progress but not complete.    SUCCEEDED: The query completed sucessfully.    FAILED: The query failed due to an error.    CANCELED: The query was canceled.
        public let status: QueryStatus

        @inlinable
        public init(status: QueryStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct GetQueryStatusWorkloadInsightsTopContributorsInput: AWSEncodableShape {
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account.
        public let scopeId: String

        @inlinable
        public init(queryId: String, scopeId: String) {
            self.queryId = queryId
            self.scopeId = scopeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.queryId, key: "queryId")
            request.encodePath(self.scopeId, key: "scopeId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueryStatusWorkloadInsightsTopContributorsOutput: AWSDecodableShape {
        /// When you run a query, use this call to check the status of the query to make sure that the query  		has SUCCEEDED before you review the results.    QUEUED: The query is scheduled to run.    RUNNING: The query is in progress but not complete.    SUCCEEDED: The query completed sucessfully.    FAILED: The query failed due to an error.    CANCELED: The query was canceled.
        public let status: QueryStatus

        @inlinable
        public init(status: QueryStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct GetScopeInput: AWSEncodableShape {
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account. A scope ID is returned from a CreateScope API call.
        public let scopeId: String

        @inlinable
        public init(scopeId: String) {
            self.scopeId = scopeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.scopeId, key: "scopeId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetScopeOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the scope.
        public let scopeArn: String
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account. A scope ID is returned from a CreateScope API call.
        public let scopeId: String
        /// The status of a scope. The status can be one of the following:  		SUCCEEDED, IN_PROGRESS, or FAILED.
        public let status: ScopeStatus
        /// The tags for a scope.
        public let tags: [String: String]?
        /// The targets for a scope
        public let targets: [TargetResource]

        @inlinable
        public init(scopeArn: String, scopeId: String, status: ScopeStatus, tags: [String: String]? = nil, targets: [TargetResource]) {
            self.scopeArn = scopeArn
            self.scopeId = scopeId
            self.status = status
            self.tags = tags
            self.targets = targets
        }

        private enum CodingKeys: String, CodingKey {
            case scopeArn = "scopeArn"
            case scopeId = "scopeId"
            case status = "status"
            case tags = "tags"
            case targets = "targets"
        }
    }

    public struct KubernetesMetadata: AWSDecodableShape {
        /// The name of the pod for a local resource.
        public let localPodName: String?
        /// The namespace of the pod for a local resource.
        public let localPodNamespace: String?
        /// The service name for a local resource.
        public let localServiceName: String?
        /// The name of the pod for a remote resource.
        public let remotePodName: String?
        /// The namespace of the pod for a remote resource.
        public let remotePodNamespace: String?
        /// The service name for a remote resource.
        public let remoteServiceName: String?

        @inlinable
        public init(localPodName: String? = nil, localPodNamespace: String? = nil, localServiceName: String? = nil, remotePodName: String? = nil, remotePodNamespace: String? = nil, remoteServiceName: String? = nil) {
            self.localPodName = localPodName
            self.localPodNamespace = localPodNamespace
            self.localServiceName = localServiceName
            self.remotePodName = remotePodName
            self.remotePodNamespace = remotePodNamespace
            self.remoteServiceName = remoteServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case localPodName = "localPodName"
            case localPodNamespace = "localPodNamespace"
            case localServiceName = "localServiceName"
            case remotePodName = "remotePodName"
            case remotePodNamespace = "remotePodNamespace"
            case remoteServiceName = "remoteServiceName"
        }
    }

    public struct ListMonitorsInput: AWSEncodableShape {
        /// The number of query results that you want to return with this call.
        public let maxResults: Int?
        /// The status of a monitor. The status can be one of the following    PENDING: The monitor is in the process of being created.    ACTIVE: The monitor is active.    INACTIVE: The monitor is inactive.    ERROR: Monitor creation failed due to an error.    DELETING: The monitor is in the process of being deleted.
        public let monitorStatus: MonitorStatus?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, monitorStatus: MonitorStatus? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.monitorStatus = monitorStatus
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.monitorStatus, key: "monitorStatus")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMonitorsOutput: AWSDecodableShape {
        /// The monitors that are in an account.
        public let monitors: [MonitorSummary]
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        @inlinable
        public init(monitors: [MonitorSummary], nextToken: String? = nil) {
            self.monitors = monitors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case monitors = "monitors"
            case nextToken = "nextToken"
        }
    }

    public struct ListScopesInput: AWSEncodableShape {
        /// The number of query results that you want to return with this call.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListScopesOutput: AWSDecodableShape {
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?
        /// The scopes returned by the call.
        public let scopes: [ScopeSummary]

        @inlinable
        public init(nextToken: String? = nil, scopes: [ScopeSummary]) {
            self.nextToken = nextToken
            self.scopes = scopes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case scopes = "scopes"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The tags for a resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MonitorLocalResource: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the local resource, such as an ARN.
        public let identifier: String
        /// The type of the local resource. Valid values are AWS::EC2::VPC AWS::AvailabilityZone or AWS::EC2::Subnet.
        public let type: MonitorLocalResourceType

        @inlinable
        public init(identifier: String, type: MonitorLocalResourceType) {
            self.identifier = identifier
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
            case type = "type"
        }
    }

    public struct MonitorRemoteResource: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the remote resource, such as an ARN.
        public let identifier: String
        /// The type of the remote resource. Valid values are AWS::EC2::VPC AWS::AvailabilityZone, AWS::EC2::Subnet, or 		AWS::AWSService.
        public let type: MonitorRemoteResourceType

        @inlinable
        public init(identifier: String, type: MonitorRemoteResourceType) {
            self.identifier = identifier
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
            case type = "type"
        }
    }

    public struct MonitorSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the monitor.
        public let monitorArn: String
        /// The name of the monitor.
        public let monitorName: String
        /// The status of a monitor. The status can be one of the following    PENDING: The monitor is in the process of being created.    ACTIVE: The monitor is active.    INACTIVE: The monitor is inactive.    ERROR: Monitor creation failed due to an error.    DELETING: The monitor is in the process of being deleted.
        public let monitorStatus: MonitorStatus

        @inlinable
        public init(monitorArn: String, monitorName: String, monitorStatus: MonitorStatus) {
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.monitorStatus = monitorStatus
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "monitorArn"
            case monitorName = "monitorName"
            case monitorStatus = "monitorStatus"
        }
    }

    public struct MonitorTopContributorsRow: AWSDecodableShape {
        /// The destination category for a top contributors row. Destination categories can be one of the following:     INTRA_AZ: Top contributor network flows within a single Availability Zone    INTER_AZ: Top contributor network flows between Availability Zones    INTER_VPC: Top contributor network flows between VPCs    AWS_SERVICES: Top contributor network flows to or from Amazon Web Services services    UNCLASSIFIED: Top contributor network flows that do not have a bucket classification
        public let destinationCategory: DestinationCategory?
        /// The destination network address translation (DNAT) IP address for a top contributor network flow.
        public let dnatIp: String?
        /// Meta data about Kubernetes resources.
        public let kubernetesMetadata: KubernetesMetadata?
        /// The Availability Zone for the local resource for a top contributor network flow.
        public let localAz: String?
        /// The Amazon Resource Name (ARN) of a local resource.
        public let localInstanceArn: String?
        /// The instance identifier for the local resource for a top contributor network flow.
        public let localInstanceId: String?
        /// The IP address of the local resource for a top contributor network flow.
        public let localIp: String?
        /// The Amazon Web Services Region for the local resource for a top contributor network flow.
        public let localRegion: String?
        /// The Amazon Resource Name (ARN) of a local subnet.
        public let localSubnetArn: String?
        /// The subnet ID for the local resource for a top contributor network flow.
        public let localSubnetId: String?
        /// The Amazon Resource Name (ARN) of a local VPC.
        public let localVpcArn: String?
        /// The VPC ID for a top contributor network flow for the local resource.
        public let localVpcId: String?
        /// The Availability Zone for the remote resource for a top contributor network flow.
        public let remoteAz: String?
        /// The Amazon Resource Name (ARN) of a remote resource.
        public let remoteInstanceArn: String?
        /// The instance identifier for the remote resource for a top contributor network flow.
        public let remoteInstanceId: String?
        /// The IP address of the remote resource for a top contributor network flow.
        public let remoteIp: String?
        /// The Amazon Web Services Region for the remote resource for a top contributor network flow.
        public let remoteRegion: String?
        /// The Amazon Resource Name (ARN) of a remote subnet.
        public let remoteSubnetArn: String?
        /// The subnet ID for the remote resource for a top contributor network flow.
        public let remoteSubnetId: String?
        /// The Amazon Resource Name (ARN) of a remote VPC.
        public let remoteVpcArn: String?
        /// The VPC ID for a top contributor network flow for the remote resource.
        public let remoteVpcId: String?
        /// The secure network address translation (SNAT) IP address for a top contributor network flow.
        public let snatIp: String?
        /// The target port.
        public let targetPort: Int?
        /// The constructs traversed by a network flow.
        public let traversedConstructs: [TraversedComponent]?
        /// The value of the metric for a top contributor network flow.
        public let value: Int64?

        @inlinable
        public init(destinationCategory: DestinationCategory? = nil, dnatIp: String? = nil, kubernetesMetadata: KubernetesMetadata? = nil, localAz: String? = nil, localInstanceArn: String? = nil, localInstanceId: String? = nil, localIp: String? = nil, localRegion: String? = nil, localSubnetArn: String? = nil, localSubnetId: String? = nil, localVpcArn: String? = nil, localVpcId: String? = nil, remoteAz: String? = nil, remoteInstanceArn: String? = nil, remoteInstanceId: String? = nil, remoteIp: String? = nil, remoteRegion: String? = nil, remoteSubnetArn: String? = nil, remoteSubnetId: String? = nil, remoteVpcArn: String? = nil, remoteVpcId: String? = nil, snatIp: String? = nil, targetPort: Int? = nil, traversedConstructs: [TraversedComponent]? = nil, value: Int64? = nil) {
            self.destinationCategory = destinationCategory
            self.dnatIp = dnatIp
            self.kubernetesMetadata = kubernetesMetadata
            self.localAz = localAz
            self.localInstanceArn = localInstanceArn
            self.localInstanceId = localInstanceId
            self.localIp = localIp
            self.localRegion = localRegion
            self.localSubnetArn = localSubnetArn
            self.localSubnetId = localSubnetId
            self.localVpcArn = localVpcArn
            self.localVpcId = localVpcId
            self.remoteAz = remoteAz
            self.remoteInstanceArn = remoteInstanceArn
            self.remoteInstanceId = remoteInstanceId
            self.remoteIp = remoteIp
            self.remoteRegion = remoteRegion
            self.remoteSubnetArn = remoteSubnetArn
            self.remoteSubnetId = remoteSubnetId
            self.remoteVpcArn = remoteVpcArn
            self.remoteVpcId = remoteVpcId
            self.snatIp = snatIp
            self.targetPort = targetPort
            self.traversedConstructs = traversedConstructs
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case destinationCategory = "destinationCategory"
            case dnatIp = "dnatIp"
            case kubernetesMetadata = "kubernetesMetadata"
            case localAz = "localAz"
            case localInstanceArn = "localInstanceArn"
            case localInstanceId = "localInstanceId"
            case localIp = "localIp"
            case localRegion = "localRegion"
            case localSubnetArn = "localSubnetArn"
            case localSubnetId = "localSubnetId"
            case localVpcArn = "localVpcArn"
            case localVpcId = "localVpcId"
            case remoteAz = "remoteAz"
            case remoteInstanceArn = "remoteInstanceArn"
            case remoteInstanceId = "remoteInstanceId"
            case remoteIp = "remoteIp"
            case remoteRegion = "remoteRegion"
            case remoteSubnetArn = "remoteSubnetArn"
            case remoteSubnetId = "remoteSubnetId"
            case remoteVpcArn = "remoteVpcArn"
            case remoteVpcId = "remoteVpcId"
            case snatIp = "snatIp"
            case targetPort = "targetPort"
            case traversedConstructs = "traversedConstructs"
            case value = "value"
        }
    }

    public struct ScopeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the scope.
        public let scopeArn: String
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account.
        public let scopeId: String
        /// The status of a scope. The status can be one of the following, depending on the 		state of scope creation: SUCCEEDED, IN_PROGRESS, or FAILED.
        public let status: ScopeStatus

        @inlinable
        public init(scopeArn: String, scopeId: String, status: ScopeStatus) {
            self.scopeArn = scopeArn
            self.scopeId = scopeId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case scopeArn = "scopeArn"
            case scopeId = "scopeId"
            case status = "status"
        }
    }

    public struct StartQueryMonitorTopContributorsInput: AWSEncodableShape {
        /// The category that you want to query top contributors for, for a specific monitor. Destination 		categories can be one of the following:     INTRA_AZ: Top contributor network flows within a single Availability Zone    INTER_AZ: Top contributor network flows between Availability Zones    INTER_VPC: Top contributor network flows between VPCs    AWS_SERVICES: Top contributor network flows to or from Amazon Web Services services    UNCLASSIFIED: Top contributor network flows that do not have a bucket classification
        public let destinationCategory: DestinationCategory
        /// The timestamp that is the date and time end of the period that you want to retrieve  		results for with your query.
        public let endTime: Date
        /// The maximum number of top contributors to return.
        public let limit: Int?
        /// The metric that you want to query top contributors for. That is, you can specify this metric to  		return the top contributor network flows, for this type of metric, for a monitor and (optionally) within  		a specific category, such as network flows between Availability Zones.
        public let metricName: MonitorMetric
        /// The name of the monitor.
        public let monitorName: String
        /// The timestamp that is the date and time beginning of the period that you want to retrieve  		results for with your query.
        public let startTime: Date

        @inlinable
        public init(destinationCategory: DestinationCategory, endTime: Date, limit: Int? = nil, metricName: MonitorMetric, monitorName: String, startTime: Date) {
            self.destinationCategory = destinationCategory
            self.endTime = endTime
            self.limit = limit
            self.metricName = metricName
            self.monitorName = monitorName
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.destinationCategory, forKey: .destinationCategory)
            try container.encode(self.endTime, forKey: .endTime)
            try container.encodeIfPresent(self.limit, forKey: .limit)
            try container.encode(self.metricName, forKey: .metricName)
            request.encodePath(self.monitorName, key: "monitorName")
            try container.encode(self.startTime, forKey: .startTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 500)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationCategory = "destinationCategory"
            case endTime = "endTime"
            case limit = "limit"
            case metricName = "metricName"
            case startTime = "startTime"
        }
    }

    public struct StartQueryMonitorTopContributorsOutput: AWSDecodableShape {
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String

        @inlinable
        public init(queryId: String) {
            self.queryId = queryId
        }

        private enum CodingKeys: String, CodingKey {
            case queryId = "queryId"
        }
    }

    public struct StartQueryWorkloadInsightsTopContributorsDataInput: AWSEncodableShape {
        /// The destination category for a top contributors. Destination categories can be one of the following:     INTRA_AZ: Top contributor network flows within a single Availability Zone    INTER_AZ: Top contributor network flows between Availability Zones    INTER_VPC: Top contributor network flows between VPCs    AWS_SERVICES: Top contributor network flows to or from Amazon Web Services services    UNCLASSIFIED: Top contributor network flows that do not have a bucket classification
        public let destinationCategory: DestinationCategory
        /// The timestamp that is the date and time end of the period that you want to retrieve  		results for with your query.
        public let endTime: Date
        /// The metric that you want to query top contributors for. That is, you can specify this metric to  		return the top contributor network flows, for this type of metric, for a monitor and (optionally)  		within a specific category, such as network flows between Availability Zones.
        public let metricName: WorkloadInsightsMetric
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account.
        public let scopeId: String
        /// The timestamp that is the date and time beginning of the period that you want to retrieve  		results for with your query.
        public let startTime: Date

        @inlinable
        public init(destinationCategory: DestinationCategory, endTime: Date, metricName: WorkloadInsightsMetric, scopeId: String, startTime: Date) {
            self.destinationCategory = destinationCategory
            self.endTime = endTime
            self.metricName = metricName
            self.scopeId = scopeId
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.destinationCategory, forKey: .destinationCategory)
            try container.encode(self.endTime, forKey: .endTime)
            try container.encode(self.metricName, forKey: .metricName)
            request.encodePath(self.scopeId, key: "scopeId")
            try container.encode(self.startTime, forKey: .startTime)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationCategory = "destinationCategory"
            case endTime = "endTime"
            case metricName = "metricName"
            case startTime = "startTime"
        }
    }

    public struct StartQueryWorkloadInsightsTopContributorsDataOutput: AWSDecodableShape {
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String

        @inlinable
        public init(queryId: String) {
            self.queryId = queryId
        }

        private enum CodingKeys: String, CodingKey {
            case queryId = "queryId"
        }
    }

    public struct StartQueryWorkloadInsightsTopContributorsInput: AWSEncodableShape {
        /// The destination category for a top contributors row. Destination categories can be one of the following:     INTRA_AZ: Top contributor network flows within a single Availability Zone    INTER_AZ: Top contributor network flows between Availability Zones    INTER_VPC: Top contributor network flows between VPCs    AWS_SERVICES: Top contributor network flows to or from Amazon Web Services services    UNCLASSIFIED: Top contributor network flows that do not have a bucket classification
        public let destinationCategory: DestinationCategory
        /// The timestamp that is the date and time end of the period that you want to retrieve  		results for with your query.
        public let endTime: Date
        /// The maximum number of top contributors to return.
        public let limit: Int?
        /// The metric that you want to query top contributors for. That is, you can specify this metric to  		return the top contributor network flows, for this type of metric, for a monitor and (optionally)  		within a specific category, such as network flows between Availability Zones.
        public let metricName: WorkloadInsightsMetric
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account. A scope ID is returned from a CreateScope API call.
        public let scopeId: String
        /// The timestamp that is the date and time beginning of the period that you want to retrieve  		results for with your query.
        public let startTime: Date

        @inlinable
        public init(destinationCategory: DestinationCategory, endTime: Date, limit: Int? = nil, metricName: WorkloadInsightsMetric, scopeId: String, startTime: Date) {
            self.destinationCategory = destinationCategory
            self.endTime = endTime
            self.limit = limit
            self.metricName = metricName
            self.scopeId = scopeId
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.destinationCategory, forKey: .destinationCategory)
            try container.encode(self.endTime, forKey: .endTime)
            try container.encodeIfPresent(self.limit, forKey: .limit)
            try container.encode(self.metricName, forKey: .metricName)
            request.encodePath(self.scopeId, key: "scopeId")
            try container.encode(self.startTime, forKey: .startTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 500)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationCategory = "destinationCategory"
            case endTime = "endTime"
            case limit = "limit"
            case metricName = "metricName"
            case startTime = "startTime"
        }
    }

    public struct StartQueryWorkloadInsightsTopContributorsOutput: AWSDecodableShape {
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String

        @inlinable
        public init(queryId: String) {
            self.queryId = queryId
        }

        private enum CodingKeys: String, CodingKey {
            case queryId = "queryId"
        }
    }

    public struct StopQueryMonitorTopContributorsInput: AWSEncodableShape {
        /// The name of the monitor.
        public let monitorName: String
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String

        @inlinable
        public init(monitorName: String, queryId: String) {
            self.monitorName = monitorName
            self.queryId = queryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.monitorName, key: "monitorName")
            request.encodePath(self.queryId, key: "queryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopQueryMonitorTopContributorsOutput: AWSDecodableShape {
        public init() {}
    }

    public struct StopQueryWorkloadInsightsTopContributorsDataInput: AWSEncodableShape {
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account.
        public let scopeId: String

        @inlinable
        public init(queryId: String, scopeId: String) {
            self.queryId = queryId
            self.scopeId = scopeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.queryId, key: "queryId")
            request.encodePath(self.scopeId, key: "scopeId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopQueryWorkloadInsightsTopContributorsDataOutput: AWSDecodableShape {
        public init() {}
    }

    public struct StopQueryWorkloadInsightsTopContributorsInput: AWSEncodableShape {
        /// The identifier for the query. A query ID is an internally-generated  		identifier for a specific query returned from an API call to start a query.
        public let queryId: String
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account.
        public let scopeId: String

        @inlinable
        public init(queryId: String, scopeId: String) {
            self.queryId = queryId
            self.scopeId = scopeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.queryId, key: "queryId")
            request.encodePath(self.scopeId, key: "scopeId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopQueryWorkloadInsightsTopContributorsOutput: AWSDecodableShape {
        public init() {}
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags for a resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct TargetIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The identifier for a target.
        public let targetId: TargetId
        /// The type of a target. A target type is currently always ACCOUNT 		because a target is currently a single Amazon Web Services account.
        public let targetType: TargetType

        @inlinable
        public init(targetId: TargetId, targetType: TargetType) {
            self.targetId = targetId
            self.targetType = targetType
        }

        public func validate(name: String) throws {
            try self.targetId.validate(name: "\(name).targetId")
        }

        private enum CodingKeys: String, CodingKey {
            case targetId = "targetId"
            case targetType = "targetType"
        }
    }

    public struct TargetResource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Region where the target resource is located.
        public let region: String
        /// A target identifier is a pair of identifying information for a resource that 		is included in a target. A target identifier includes the target ID and  		the target type.
        public let targetIdentifier: TargetIdentifier

        @inlinable
        public init(region: String, targetIdentifier: TargetIdentifier) {
            self.region = region
            self.targetIdentifier = targetIdentifier
        }

        public func validate(name: String) throws {
            try self.targetIdentifier.validate(name: "\(name).targetIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case region = "region"
            case targetIdentifier = "targetIdentifier"
        }
    }

    public struct TraversedComponent: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a tranversed component.
        public let componentArn: String?
        /// The identifier for the traversed component.
        public let componentId: String?
        /// The type of component that was traversed.
        public let componentType: String?
        /// The service name for the traversed component.
        public let serviceName: String?

        @inlinable
        public init(componentArn: String? = nil, componentId: String? = nil, componentType: String? = nil, serviceName: String? = nil) {
            self.componentArn = componentArn
            self.componentId = componentId
            self.componentType = componentType
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn = "componentArn"
            case componentId = "componentId"
            case componentType = "componentType"
            case serviceName = "serviceName"
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// Keys that you specified when you tagged a resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMonitorInput: AWSEncodableShape {
        /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. Don't reuse the same client token for 		other API requests.
        public let clientToken: String?
        /// The local resources to add, as an array of resources with identifiers and types.
        public let localResourcesToAdd: [MonitorLocalResource]?
        /// The local resources to remove, as an array of resources with identifiers and types.
        public let localResourcesToRemove: [MonitorLocalResource]?
        /// The name of the monitor.
        public let monitorName: String
        /// The remove resources to add, as an array of resources with identifiers and types.
        public let remoteResourcesToAdd: [MonitorRemoteResource]?
        /// The remove resources to remove, as an array of resources with identifiers and types.
        public let remoteResourcesToRemove: [MonitorRemoteResource]?

        @inlinable
        public init(clientToken: String? = UpdateMonitorInput.idempotencyToken(), localResourcesToAdd: [MonitorLocalResource]? = nil, localResourcesToRemove: [MonitorLocalResource]? = nil, monitorName: String, remoteResourcesToAdd: [MonitorRemoteResource]? = nil, remoteResourcesToRemove: [MonitorRemoteResource]? = nil) {
            self.clientToken = clientToken
            self.localResourcesToAdd = localResourcesToAdd
            self.localResourcesToRemove = localResourcesToRemove
            self.monitorName = monitorName
            self.remoteResourcesToAdd = remoteResourcesToAdd
            self.remoteResourcesToRemove = remoteResourcesToRemove
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.localResourcesToAdd, forKey: .localResourcesToAdd)
            try container.encodeIfPresent(self.localResourcesToRemove, forKey: .localResourcesToRemove)
            request.encodePath(self.monitorName, key: "monitorName")
            try container.encodeIfPresent(self.remoteResourcesToAdd, forKey: .remoteResourcesToAdd)
            try container.encodeIfPresent(self.remoteResourcesToRemove, forKey: .remoteResourcesToRemove)
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case localResourcesToAdd = "localResourcesToAdd"
            case localResourcesToRemove = "localResourcesToRemove"
            case remoteResourcesToAdd = "remoteResourcesToAdd"
            case remoteResourcesToRemove = "remoteResourcesToRemove"
        }
    }

    public struct UpdateMonitorOutput: AWSDecodableShape {
        /// The date and time when the monitor was created.
        public let createdAt: Date
        /// The local resources updated for a monitor, as an array of resources with identifiers and types.
        public let localResources: [MonitorLocalResource]
        /// The last date and time that the monitor was modified.
        public let modifiedAt: Date
        /// The Amazon Resource Name (ARN) of the monitor.
        public let monitorArn: String
        /// The name of the monitor.
        public let monitorName: String
        /// The status of a monitor. The status can be one of the following    PENDING: The monitor is in the process of being created.    ACTIVE: The monitor is active.    INACTIVE: The monitor is inactive.    ERROR: Monitor creation failed due to an error.    DELETING: The monitor is in the process of being deleted.
        public let monitorStatus: MonitorStatus
        /// The remote resources updated for a monitor, as an array of resources with identifiers and types.
        public let remoteResources: [MonitorRemoteResource]
        /// The tags for a monitor.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date, localResources: [MonitorLocalResource], modifiedAt: Date, monitorArn: String, monitorName: String, monitorStatus: MonitorStatus, remoteResources: [MonitorRemoteResource], tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.localResources = localResources
            self.modifiedAt = modifiedAt
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.monitorStatus = monitorStatus
            self.remoteResources = remoteResources
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case localResources = "localResources"
            case modifiedAt = "modifiedAt"
            case monitorArn = "monitorArn"
            case monitorName = "monitorName"
            case monitorStatus = "monitorStatus"
            case remoteResources = "remoteResources"
            case tags = "tags"
        }
    }

    public struct UpdateScopeInput: AWSEncodableShape {
        /// A list of resources to add to a scope.
        public let resourcesToAdd: [TargetResource]?
        /// A list of resources to delete from a scope.
        public let resourcesToDelete: [TargetResource]?
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account.
        public let scopeId: String

        @inlinable
        public init(resourcesToAdd: [TargetResource]? = nil, resourcesToDelete: [TargetResource]? = nil, scopeId: String) {
            self.resourcesToAdd = resourcesToAdd
            self.resourcesToDelete = resourcesToDelete
            self.scopeId = scopeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.resourcesToAdd, forKey: .resourcesToAdd)
            try container.encodeIfPresent(self.resourcesToDelete, forKey: .resourcesToDelete)
            request.encodePath(self.scopeId, key: "scopeId")
        }

        public func validate(name: String) throws {
            try self.resourcesToAdd?.forEach {
                try $0.validate(name: "\(name).resourcesToAdd[]")
            }
            try self.resourcesToDelete?.forEach {
                try $0.validate(name: "\(name).resourcesToDelete[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourcesToAdd = "resourcesToAdd"
            case resourcesToDelete = "resourcesToDelete"
        }
    }

    public struct UpdateScopeOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the scope.
        public let scopeArn: String
        /// The identifier for the scope that includes the resources you want to get data results for. 		A scope ID is an internally-generated identifier that includes all the resources  		for a specific root account.
        public let scopeId: String
        /// The status for a call to update a scope. The status can be one of the following:  		SUCCEEDED, IN_PROGRESS, or FAILED.
        public let status: ScopeStatus
        /// The tags for a scope.
        public let tags: [String: String]?

        @inlinable
        public init(scopeArn: String, scopeId: String, status: ScopeStatus, tags: [String: String]? = nil) {
            self.scopeArn = scopeArn
            self.scopeId = scopeId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case scopeArn = "scopeArn"
            case scopeId = "scopeId"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct WorkloadInsightsTopContributorsDataPoint: AWSDecodableShape {
        /// The label identifying the data point.
        public let label: String
        /// An array of the timestamps for the data point.
        public let timestamps: [Date]
        /// The values for the data point.
        public let values: [Double]

        @inlinable
        public init(label: String, timestamps: [Date], values: [Double]) {
            self.label = label
            self.timestamps = timestamps
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case label = "label"
            case timestamps = "timestamps"
            case values = "values"
        }
    }

    public struct WorkloadInsightsTopContributorsRow: AWSDecodableShape {
        /// The account ID for a specific row of data.
        public let accountId: String?
        /// The identifier for the Availability Zone where the local resource is located.
        public let localAz: String?
        /// The Amazon Web Services Region where the local resource is located.
        public let localRegion: String?
        /// The Amazon Resource Name (ARN) of a local subnet.
        public let localSubnetArn: String?
        /// The subnet identifier for the local resource.
        public let localSubnetId: String?
        /// The Amazon Resource Name (ARN) of a local VPC.
        public let localVpcArn: String?
        /// The identifier for the VPC for the local resource.
        public let localVpcId: String?
        /// The identifier of a remote resource.
        public let remoteIdentifier: String?
        /// The value for a metric.
        public let value: Int64?

        @inlinable
        public init(accountId: String? = nil, localAz: String? = nil, localRegion: String? = nil, localSubnetArn: String? = nil, localSubnetId: String? = nil, localVpcArn: String? = nil, localVpcId: String? = nil, remoteIdentifier: String? = nil, value: Int64? = nil) {
            self.accountId = accountId
            self.localAz = localAz
            self.localRegion = localRegion
            self.localSubnetArn = localSubnetArn
            self.localSubnetId = localSubnetId
            self.localVpcArn = localVpcArn
            self.localVpcId = localVpcId
            self.remoteIdentifier = remoteIdentifier
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case localAz = "localAz"
            case localRegion = "localRegion"
            case localSubnetArn = "localSubnetArn"
            case localSubnetId = "localSubnetId"
            case localVpcArn = "localVpcArn"
            case localVpcId = "localVpcId"
            case remoteIdentifier = "remoteIdentifier"
            case value = "value"
        }
    }

    public struct TargetId: AWSEncodableShape & AWSDecodableShape {
        /// The identifier for the account for a target.
        public let accountId: String?

        @inlinable
        public init(accountId: String? = nil) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 1)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }
}

// MARK: - Errors

/// Error enum for NetworkFlowMonitor
public struct NetworkFlowMonitorErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize NetworkFlowMonitor
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient permission to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The requested resource is in use.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal error occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request specifies a resource that doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request exceeded a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Invalid request.
    public static var validationException: Self { .init(.validationException) }
}

extension NetworkFlowMonitorErrorType: Equatable {
    public static func == (lhs: NetworkFlowMonitorErrorType, rhs: NetworkFlowMonitorErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension NetworkFlowMonitorErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
