//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension CostExplorer {
    // MARK: Enums

    public enum AccountScope: String, CustomStringConvertible, Codable, _SotoSendable {
        case linked = "LINKED"
        case payer = "PAYER"
        public var description: String { return self.rawValue }
    }

    public enum AnomalyFeedbackType: String, CustomStringConvertible, Codable, _SotoSendable {
        case no = "NO"
        case plannedActivity = "PLANNED_ACTIVITY"
        case yes = "YES"
        public var description: String { return self.rawValue }
    }

    public enum AnomalySubscriptionFrequency: String, CustomStringConvertible, Codable, _SotoSendable {
        case daily = "DAILY"
        case immediate = "IMMEDIATE"
        case weekly = "WEEKLY"
        public var description: String { return self.rawValue }
    }

    public enum Context: String, CustomStringConvertible, Codable, _SotoSendable {
        case costAndUsage = "COST_AND_USAGE"
        case reservations = "RESERVATIONS"
        case savingsPlans = "SAVINGS_PLANS"
        public var description: String { return self.rawValue }
    }

    public enum CostAllocationTagStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public enum CostAllocationTagType: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsGenerated = "AWSGenerated"
        case userDefined = "UserDefined"
        public var description: String { return self.rawValue }
    }

    public enum CostCategoryInheritedValueDimensionName: String, CustomStringConvertible, Codable, _SotoSendable {
        case linkedAccountName = "LINKED_ACCOUNT_NAME"
        case tag = "TAG"
        public var description: String { return self.rawValue }
    }

    public enum CostCategoryRuleType: String, CustomStringConvertible, Codable, _SotoSendable {
        case inheritedValue = "INHERITED_VALUE"
        case regular = "REGULAR"
        public var description: String { return self.rawValue }
    }

    public enum CostCategoryRuleVersion: String, CustomStringConvertible, Codable, _SotoSendable {
        case costCategoryExpressionV1 = "CostCategoryExpression.v1"
        public var description: String { return self.rawValue }
    }

    public enum CostCategorySplitChargeMethod: String, CustomStringConvertible, Codable, _SotoSendable {
        case even = "EVEN"
        case fixed = "FIXED"
        case proportional = "PROPORTIONAL"
        public var description: String { return self.rawValue }
    }

    public enum CostCategorySplitChargeRuleParameterType: String, CustomStringConvertible, Codable, _SotoSendable {
        case allocationPercentages = "ALLOCATION_PERCENTAGES"
        public var description: String { return self.rawValue }
    }

    public enum CostCategoryStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case applied = "APPLIED"
        case processing = "PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum CostCategoryStatusComponent: String, CustomStringConvertible, Codable, _SotoSendable {
        case costExplorer = "COST_EXPLORER"
        public var description: String { return self.rawValue }
    }

    public enum Dimension: String, CustomStringConvertible, Codable, _SotoSendable {
        case agreementEndDateTimeAfter = "AGREEMENT_END_DATE_TIME_AFTER"
        case agreementEndDateTimeBefore = "AGREEMENT_END_DATE_TIME_BEFORE"
        case anomalyTotalImpactAbsolute = "ANOMALY_TOTAL_IMPACT_ABSOLUTE"
        case anomalyTotalImpactPercentage = "ANOMALY_TOTAL_IMPACT_PERCENTAGE"
        case az = "AZ"
        case billingEntity = "BILLING_ENTITY"
        case cacheEngine = "CACHE_ENGINE"
        case databaseEngine = "DATABASE_ENGINE"
        case deploymentOption = "DEPLOYMENT_OPTION"
        case instanceType = "INSTANCE_TYPE"
        case instanceTypeFamily = "INSTANCE_TYPE_FAMILY"
        case invoicingEntity = "INVOICING_ENTITY"
        case legalEntityName = "LEGAL_ENTITY_NAME"
        case linkedAccount = "LINKED_ACCOUNT"
        case linkedAccountName = "LINKED_ACCOUNT_NAME"
        case operatingSystem = "OPERATING_SYSTEM"
        case operation = "OPERATION"
        case paymentOption = "PAYMENT_OPTION"
        case platform = "PLATFORM"
        case purchaseType = "PURCHASE_TYPE"
        case recordType = "RECORD_TYPE"
        case region = "REGION"
        case reservationId = "RESERVATION_ID"
        case resourceId = "RESOURCE_ID"
        case rightsizingType = "RIGHTSIZING_TYPE"
        case savingsPlanArn = "SAVINGS_PLAN_ARN"
        case savingsPlansType = "SAVINGS_PLANS_TYPE"
        case scope = "SCOPE"
        case service = "SERVICE"
        case serviceCode = "SERVICE_CODE"
        case subscriptionId = "SUBSCRIPTION_ID"
        case tenancy = "TENANCY"
        case usageType = "USAGE_TYPE"
        case usageTypeGroup = "USAGE_TYPE_GROUP"
        public var description: String { return self.rawValue }
    }

    public enum FindingReasonCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case cpuOverProvisioned = "CPU_OVER_PROVISIONED"
        case cpuUnderProvisioned = "CPU_UNDER_PROVISIONED"
        case diskIopsOverProvisioned = "DISK_IOPS_OVER_PROVISIONED"
        case diskIopsUnderProvisioned = "DISK_IOPS_UNDER_PROVISIONED"
        case diskThroughputOverProvisioned = "DISK_THROUGHPUT_OVER_PROVISIONED"
        case diskThroughputUnderProvisioned = "DISK_THROUGHPUT_UNDER_PROVISIONED"
        case ebsIopsOverProvisioned = "EBS_IOPS_OVER_PROVISIONED"
        case ebsIopsUnderProvisioned = "EBS_IOPS_UNDER_PROVISIONED"
        case ebsThroughputOverProvisioned = "EBS_THROUGHPUT_OVER_PROVISIONED"
        case ebsThroughputUnderProvisioned = "EBS_THROUGHPUT_UNDER_PROVISIONED"
        case memoryOverProvisioned = "MEMORY_OVER_PROVISIONED"
        case memoryUnderProvisioned = "MEMORY_UNDER_PROVISIONED"
        case networkBandwidthOverProvisioned = "NETWORK_BANDWIDTH_OVER_PROVISIONED"
        case networkBandwidthUnderProvisioned = "NETWORK_BANDWIDTH_UNDER_PROVISIONED"
        case networkPpsOverProvisioned = "NETWORK_PPS_OVER_PROVISIONED"
        case networkPpsUnderProvisioned = "NETWORK_PPS_UNDER_PROVISIONED"
        public var description: String { return self.rawValue }
    }

    public enum GenerationStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case processing = "PROCESSING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum Granularity: String, CustomStringConvertible, Codable, _SotoSendable {
        case daily = "DAILY"
        case hourly = "HOURLY"
        case monthly = "MONTHLY"
        public var description: String { return self.rawValue }
    }

    public enum GroupDefinitionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case costCategory = "COST_CATEGORY"
        case dimension = "DIMENSION"
        case tag = "TAG"
        public var description: String { return self.rawValue }
    }

    public enum LookbackPeriodInDays: String, CustomStringConvertible, Codable, _SotoSendable {
        case sevenDays = "SEVEN_DAYS"
        case sixtyDays = "SIXTY_DAYS"
        case thirtyDays = "THIRTY_DAYS"
        public var description: String { return self.rawValue }
    }

    public enum MatchOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case absent = "ABSENT"
        case caseInsensitive = "CASE_INSENSITIVE"
        case caseSensitive = "CASE_SENSITIVE"
        case contains = "CONTAINS"
        case endsWith = "ENDS_WITH"
        case equals = "EQUALS"
        case greaterThanOrEqual = "GREATER_THAN_OR_EQUAL"
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    public enum Metric: String, CustomStringConvertible, Codable, _SotoSendable {
        case amortizedCost = "AMORTIZED_COST"
        case blendedCost = "BLENDED_COST"
        case netAmortizedCost = "NET_AMORTIZED_COST"
        case netUnblendedCost = "NET_UNBLENDED_COST"
        case normalizedUsageAmount = "NORMALIZED_USAGE_AMOUNT"
        case unblendedCost = "UNBLENDED_COST"
        case usageQuantity = "USAGE_QUANTITY"
        public var description: String { return self.rawValue }
    }

    public enum MonitorDimension: String, CustomStringConvertible, Codable, _SotoSendable {
        case service = "SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum MonitorType: String, CustomStringConvertible, Codable, _SotoSendable {
        case custom = "CUSTOM"
        case dimensional = "DIMENSIONAL"
        public var description: String { return self.rawValue }
    }

    public enum NumericOperator: String, CustomStringConvertible, Codable, _SotoSendable {
        case between = "BETWEEN"
        case equal = "EQUAL"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqual = "GREATER_THAN_OR_EQUAL"
        case lessThan = "LESS_THAN"
        case lessThanOrEqual = "LESS_THAN_OR_EQUAL"
        public var description: String { return self.rawValue }
    }

    public enum OfferingClass: String, CustomStringConvertible, Codable, _SotoSendable {
        case convertible = "CONVERTIBLE"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum PaymentOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case allUpfront = "ALL_UPFRONT"
        case heavyUtilization = "HEAVY_UTILIZATION"
        case lightUtilization = "LIGHT_UTILIZATION"
        case mediumUtilization = "MEDIUM_UTILIZATION"
        case noUpfront = "NO_UPFRONT"
        case partialUpfront = "PARTIAL_UPFRONT"
        public var description: String { return self.rawValue }
    }

    public enum PlatformDifference: String, CustomStringConvertible, Codable, _SotoSendable {
        case hypervisor = "HYPERVISOR"
        case instanceStoreAvailability = "INSTANCE_STORE_AVAILABILITY"
        case networkInterface = "NETWORK_INTERFACE"
        case storageInterface = "STORAGE_INTERFACE"
        case virtualizationType = "VIRTUALIZATION_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationTarget: String, CustomStringConvertible, Codable, _SotoSendable {
        case crossInstanceFamily = "CROSS_INSTANCE_FAMILY"
        case sameInstanceFamily = "SAME_INSTANCE_FAMILY"
        public var description: String { return self.rawValue }
    }

    public enum RightsizingType: String, CustomStringConvertible, Codable, _SotoSendable {
        case modify = "MODIFY"
        case terminate = "TERMINATE"
        public var description: String { return self.rawValue }
    }

    public enum SavingsPlansDataType: String, CustomStringConvertible, Codable, _SotoSendable {
        case amortizedCommitment = "AMORTIZED_COMMITMENT"
        case attributes = "ATTRIBUTES"
        case savings = "SAVINGS"
        case utilization = "UTILIZATION"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum SubscriberStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case confirmed = "CONFIRMED"
        case declined = "DECLINED"
        public var description: String { return self.rawValue }
    }

    public enum SubscriberType: String, CustomStringConvertible, Codable, _SotoSendable {
        case email = "EMAIL"
        case sns = "SNS"
        public var description: String { return self.rawValue }
    }

    public enum SupportedSavingsPlansType: String, CustomStringConvertible, Codable, _SotoSendable {
        case computeSp = "COMPUTE_SP"
        case ec2InstanceSp = "EC2_INSTANCE_SP"
        case sagemakerSp = "SAGEMAKER_SP"
        public var description: String { return self.rawValue }
    }

    public enum TermInYears: String, CustomStringConvertible, Codable, _SotoSendable {
        case oneYear = "ONE_YEAR"
        case threeYears = "THREE_YEARS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Anomaly: AWSDecodableShape {
        /// The last day the anomaly is detected.
        public let anomalyEndDate: String?
        /// The unique identifier for the anomaly.
        public let anomalyId: String
        /// The latest and maximum score for the anomaly.
        public let anomalyScore: AnomalyScore
        /// The first day the anomaly is detected.
        public let anomalyStartDate: String?
        /// The dimension for the anomaly (for example, an Amazon Web Service in a service monitor).
        public let dimensionValue: String?
        /// The feedback value.
        public let feedback: AnomalyFeedbackType?
        /// The dollar impact for the anomaly.
        public let impact: Impact
        /// The Amazon Resource Name (ARN) for the cost monitor that generated this anomaly.
        public let monitorArn: String
        /// The list of identified root causes for the anomaly.
        public let rootCauses: [RootCause]?

        public init(anomalyEndDate: String? = nil, anomalyId: String, anomalyScore: AnomalyScore, anomalyStartDate: String? = nil, dimensionValue: String? = nil, feedback: AnomalyFeedbackType? = nil, impact: Impact, monitorArn: String, rootCauses: [RootCause]? = nil) {
            self.anomalyEndDate = anomalyEndDate
            self.anomalyId = anomalyId
            self.anomalyScore = anomalyScore
            self.anomalyStartDate = anomalyStartDate
            self.dimensionValue = dimensionValue
            self.feedback = feedback
            self.impact = impact
            self.monitorArn = monitorArn
            self.rootCauses = rootCauses
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyEndDate = "AnomalyEndDate"
            case anomalyId = "AnomalyId"
            case anomalyScore = "AnomalyScore"
            case anomalyStartDate = "AnomalyStartDate"
            case dimensionValue = "DimensionValue"
            case feedback = "Feedback"
            case impact = "Impact"
            case monitorArn = "MonitorArn"
            case rootCauses = "RootCauses"
        }
    }

    public struct AnomalyDateInterval: AWSEncodableShape {
        /// The last date an anomaly was observed.
        public let endDate: String?
        /// The first date an anomaly was observed.
        public let startDate: String

        public init(endDate: String? = nil, startDate: String) {
            self.endDate = endDate
            self.startDate = startDate
        }

        public func validate(name: String) throws {
            try self.validate(self.endDate, name: "endDate", parent: name, max: 40)
            try self.validate(self.endDate, name: "endDate", parent: name, pattern: "^(\\d{4}-\\d{2}-\\d{2})(T\\d{2}:\\d{2}:\\d{2}Z)?$")
            try self.validate(self.startDate, name: "startDate", parent: name, max: 40)
            try self.validate(self.startDate, name: "startDate", parent: name, pattern: "^(\\d{4}-\\d{2}-\\d{2})(T\\d{2}:\\d{2}:\\d{2}Z)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "EndDate"
            case startDate = "StartDate"
        }
    }

    public struct AnomalyMonitor: AWSEncodableShape & AWSDecodableShape {
        /// The date when the monitor was created.
        public let creationDate: String?
        /// The value for evaluated dimensions.
        public let dimensionalValueCount: Int?
        /// The date when the monitor last evaluated for anomalies.
        public let lastEvaluatedDate: String?
        /// The date when the monitor was last updated.
        public let lastUpdatedDate: String?
        /// The Amazon Resource Name (ARN) value.
        public let monitorArn: String?
        /// The dimensions to evaluate.
        public let monitorDimension: MonitorDimension?
        /// The name of the monitor.
        public let monitorName: String
        public let monitorSpecification: Expression?
        /// The possible type values.
        public let monitorType: MonitorType

        public init(creationDate: String? = nil, dimensionalValueCount: Int? = nil, lastEvaluatedDate: String? = nil, lastUpdatedDate: String? = nil, monitorArn: String? = nil, monitorDimension: MonitorDimension? = nil, monitorName: String, monitorSpecification: Expression? = nil, monitorType: MonitorType) {
            self.creationDate = creationDate
            self.dimensionalValueCount = dimensionalValueCount
            self.lastEvaluatedDate = lastEvaluatedDate
            self.lastUpdatedDate = lastUpdatedDate
            self.monitorArn = monitorArn
            self.monitorDimension = monitorDimension
            self.monitorName = monitorName
            self.monitorSpecification = monitorSpecification
            self.monitorType = monitorType
        }

        public func validate(name: String) throws {
            try self.validate(self.creationDate, name: "creationDate", parent: name, max: 40)
            try self.validate(self.creationDate, name: "creationDate", parent: name, pattern: "^(\\d{4}-\\d{2}-\\d{2})(T\\d{2}:\\d{2}:\\d{2}Z)?$")
            try self.validate(self.dimensionalValueCount, name: "dimensionalValueCount", parent: name, min: 0)
            try self.validate(self.lastEvaluatedDate, name: "lastEvaluatedDate", parent: name, max: 40)
            try self.validate(self.lastEvaluatedDate, name: "lastEvaluatedDate", parent: name, pattern: "^(\\d{4}-\\d{2}-\\d{2})(T\\d{2}:\\d{2}:\\d{2}Z)?$")
            try self.validate(self.lastUpdatedDate, name: "lastUpdatedDate", parent: name, max: 40)
            try self.validate(self.lastUpdatedDate, name: "lastUpdatedDate", parent: name, pattern: "^(\\d{4}-\\d{2}-\\d{2})(T\\d{2}:\\d{2}:\\d{2}Z)?$")
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, max: 1024)
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 1024)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[\\S\\s]*$")
            try self.monitorSpecification?.validate(name: "\(name).monitorSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case dimensionalValueCount = "DimensionalValueCount"
            case lastEvaluatedDate = "LastEvaluatedDate"
            case lastUpdatedDate = "LastUpdatedDate"
            case monitorArn = "MonitorArn"
            case monitorDimension = "MonitorDimension"
            case monitorName = "MonitorName"
            case monitorSpecification = "MonitorSpecification"
            case monitorType = "MonitorType"
        }
    }

    public struct AnomalyScore: AWSDecodableShape {
        /// The last observed score.
        public let currentScore: Double
        /// The maximum score that's observed during the AnomalyDateInterval.
        public let maxScore: Double

        public init(currentScore: Double, maxScore: Double) {
            self.currentScore = currentScore
            self.maxScore = maxScore
        }

        private enum CodingKeys: String, CodingKey {
            case currentScore = "CurrentScore"
            case maxScore = "MaxScore"
        }
    }

    public struct AnomalySubscription: AWSEncodableShape & AWSDecodableShape {
        /// Your unique account identifier.
        public let accountId: String?
        /// The frequency that anomaly reports are sent over email.
        public let frequency: AnomalySubscriptionFrequency
        /// A list of cost anomaly monitors.
        public let monitorArnList: [String]
        /// A list of subscribers to notify.
        public let subscribers: [Subscriber]
        /// The AnomalySubscription Amazon Resource Name (ARN).
        public let subscriptionArn: String?
        /// The name for the subscription.
        public let subscriptionName: String
        /// (deprecated) The dollar value that triggers a notification if the threshold is exceeded.  This field has been deprecated. To specify a threshold, use ThresholdExpression. Continued use of Threshold will be treated as shorthand syntax for a ThresholdExpression. One of Threshold or ThresholdExpression is required for this resource.
        public let threshold: Double?
        /// An Expression object used to specify the anomalies that you want to generate alerts for. This supports dimensions and nested expressions. The supported dimensions are ANOMALY_TOTAL_IMPACT_ABSOLUTE and ANOMALY_TOTAL_IMPACT_PERCENTAGE. The supported nested expression types are AND and OR. The match option GREATER_THAN_OR_EQUAL is required. Values must be numbers between 0 and 10,000,000,000. One of Threshold or ThresholdExpression is required for this resource. The following are examples of valid ThresholdExpressions:   Absolute threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }    Percentage threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }     AND two thresholds together: { "And": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }     OR two thresholds together: { "Or": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }
        public let thresholdExpression: Expression?

        public init(accountId: String? = nil, frequency: AnomalySubscriptionFrequency, monitorArnList: [String], subscribers: [Subscriber], subscriptionArn: String? = nil, subscriptionName: String, thresholdExpression: Expression? = nil) {
            self.accountId = accountId
            self.frequency = frequency
            self.monitorArnList = monitorArnList
            self.subscribers = subscribers
            self.subscriptionArn = subscriptionArn
            self.subscriptionName = subscriptionName
            self.threshold = nil
            self.thresholdExpression = thresholdExpression
        }

        @available(*, deprecated, message: "Members threshold have been deprecated")
        public init(accountId: String? = nil, frequency: AnomalySubscriptionFrequency, monitorArnList: [String], subscribers: [Subscriber], subscriptionArn: String? = nil, subscriptionName: String, threshold: Double? = nil, thresholdExpression: Expression? = nil) {
            self.accountId = accountId
            self.frequency = frequency
            self.monitorArnList = monitorArnList
            self.subscribers = subscribers
            self.subscriptionArn = subscriptionArn
            self.subscriptionName = subscriptionName
            self.threshold = threshold
            self.thresholdExpression = thresholdExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 1024)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\S\\s]*$")
            try self.monitorArnList.forEach {
                try validate($0, name: "monitorArnList[]", parent: name, max: 2048)
                try validate($0, name: "monitorArnList[]", parent: name, min: 20)
                try validate($0, name: "monitorArnList[]", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            }
            try self.subscribers.forEach {
                try $0.validate(name: "\(name).subscribers[]")
            }
            try self.validate(self.subscriptionArn, name: "subscriptionArn", parent: name, max: 1024)
            try self.validate(self.subscriptionArn, name: "subscriptionArn", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.subscriptionName, name: "subscriptionName", parent: name, max: 1024)
            try self.validate(self.subscriptionName, name: "subscriptionName", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.threshold, name: "threshold", parent: name, min: 0.0)
            try self.thresholdExpression?.validate(name: "\(name).thresholdExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case frequency = "Frequency"
            case monitorArnList = "MonitorArnList"
            case subscribers = "Subscribers"
            case subscriptionArn = "SubscriptionArn"
            case subscriptionName = "SubscriptionName"
            case threshold = "Threshold"
            case thresholdExpression = "ThresholdExpression"
        }
    }

    public struct CostAllocationTag: AWSDecodableShape {
        /// The status of a cost allocation tag.
        public let status: CostAllocationTagStatus
        /// The key for the cost allocation tag.
        public let tagKey: String
        /// The type of cost allocation tag. You can use AWSGenerated or UserDefined type tags. AWSGenerated type tags are tags that Amazon Web Services defines and applies to support Amazon Web Services resources for cost allocation purposes. UserDefined type tags are tags that you define, create, and apply to resources.
        public let type: CostAllocationTagType

        public init(status: CostAllocationTagStatus, tagKey: String, type: CostAllocationTagType) {
            self.status = status
            self.tagKey = tagKey
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case tagKey = "TagKey"
            case type = "Type"
        }
    }

    public struct CostAllocationTagStatusEntry: AWSEncodableShape {
        /// The status of a cost allocation tag.
        public let status: CostAllocationTagStatus
        /// The key for the cost allocation tag.
        public let tagKey: String

        public init(status: CostAllocationTagStatus, tagKey: String) {
            self.status = status
            self.tagKey = tagKey
        }

        public func validate(name: String) throws {
            try self.validate(self.tagKey, name: "tagKey", parent: name, max: 1024)
            try self.validate(self.tagKey, name: "tagKey", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case tagKey = "TagKey"
        }
    }

    public struct CostCategory: AWSDecodableShape {
        /// The unique identifier for your Cost Category.
        public let costCategoryArn: String
        public let defaultValue: String?
        /// The effective end date of your Cost Category.
        public let effectiveEnd: String?
        /// The effective start date of your Cost Category.
        public let effectiveStart: String
        public let name: String
        /// The list of processing statuses for Cost Management products for a specific cost category.
        public let processingStatus: [CostCategoryProcessingStatus]?
        /// The rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.
        public let rules: [CostCategoryRule]
        public let ruleVersion: CostCategoryRuleVersion
        ///  The split charge rules that are used to allocate your charges between your Cost Category values.
        public let splitChargeRules: [CostCategorySplitChargeRule]?

        public init(costCategoryArn: String, defaultValue: String? = nil, effectiveEnd: String? = nil, effectiveStart: String, name: String, processingStatus: [CostCategoryProcessingStatus]? = nil, rules: [CostCategoryRule], ruleVersion: CostCategoryRuleVersion, splitChargeRules: [CostCategorySplitChargeRule]? = nil) {
            self.costCategoryArn = costCategoryArn
            self.defaultValue = defaultValue
            self.effectiveEnd = effectiveEnd
            self.effectiveStart = effectiveStart
            self.name = name
            self.processingStatus = processingStatus
            self.rules = rules
            self.ruleVersion = ruleVersion
            self.splitChargeRules = splitChargeRules
        }

        private enum CodingKeys: String, CodingKey {
            case costCategoryArn = "CostCategoryArn"
            case defaultValue = "DefaultValue"
            case effectiveEnd = "EffectiveEnd"
            case effectiveStart = "EffectiveStart"
            case name = "Name"
            case processingStatus = "ProcessingStatus"
            case rules = "Rules"
            case ruleVersion = "RuleVersion"
            case splitChargeRules = "SplitChargeRules"
        }
    }

    public struct CostCategoryInheritedValueDimension: AWSEncodableShape & AWSDecodableShape {
        /// The key to extract cost category values.
        public let dimensionKey: String?
        /// The name of the dimension that's used to group costs. If you specify LINKED_ACCOUNT_NAME, the cost category value is based on account name. If you specify TAG, the cost category value is based on the value of the specified tag key.
        public let dimensionName: CostCategoryInheritedValueDimensionName?

        public init(dimensionKey: String? = nil, dimensionName: CostCategoryInheritedValueDimensionName? = nil) {
            self.dimensionKey = dimensionKey
            self.dimensionName = dimensionName
        }

        public func validate(name: String) throws {
            try self.validate(self.dimensionKey, name: "dimensionKey", parent: name, max: 1024)
            try self.validate(self.dimensionKey, name: "dimensionKey", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionKey = "DimensionKey"
            case dimensionName = "DimensionName"
        }
    }

    public struct CostCategoryProcessingStatus: AWSDecodableShape {
        /// The Cost Management product name of the applied status.
        public let component: CostCategoryStatusComponent?
        /// The process status for a specific cost category.
        public let status: CostCategoryStatus?

        public init(component: CostCategoryStatusComponent? = nil, status: CostCategoryStatus? = nil) {
            self.component = component
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case component = "Component"
            case status = "Status"
        }
    }

    public struct CostCategoryReference: AWSDecodableShape {
        /// The unique identifier for your Cost Category.
        public let costCategoryArn: String?
        public let defaultValue: String?
        /// The Cost Category's effective end date.
        public let effectiveEnd: String?
        /// The Cost Category's effective start date.
        public let effectiveStart: String?
        public let name: String?
        /// The number of rules that are associated with a specific Cost Category.
        public let numberOfRules: Int?
        /// The list of processing statuses for Cost Management products for a specific cost category.
        public let processingStatus: [CostCategoryProcessingStatus]?
        /// A list of unique cost category values in a specific cost category.
        public let values: [String]?

        public init(costCategoryArn: String? = nil, defaultValue: String? = nil, effectiveEnd: String? = nil, effectiveStart: String? = nil, name: String? = nil, numberOfRules: Int? = nil, processingStatus: [CostCategoryProcessingStatus]? = nil, values: [String]? = nil) {
            self.costCategoryArn = costCategoryArn
            self.defaultValue = defaultValue
            self.effectiveEnd = effectiveEnd
            self.effectiveStart = effectiveStart
            self.name = name
            self.numberOfRules = numberOfRules
            self.processingStatus = processingStatus
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case costCategoryArn = "CostCategoryArn"
            case defaultValue = "DefaultValue"
            case effectiveEnd = "EffectiveEnd"
            case effectiveStart = "EffectiveStart"
            case name = "Name"
            case numberOfRules = "NumberOfRules"
            case processingStatus = "ProcessingStatus"
            case values = "Values"
        }
    }

    public struct CostCategoryRule: AWSEncodableShape & AWSDecodableShape {
        /// The value the line item is categorized as if the line item contains the matched dimension.
        public let inheritedValue: CostCategoryInheritedValueDimension?
        /// An Expression object used to categorize costs. This supports dimensions, tags, and nested expressions. Currently the only dimensions supported are LINKED_ACCOUNT, SERVICE_CODE, RECORD_TYPE, and LINKED_ACCOUNT_NAME. Root level OR isn't supported. We recommend that you create a separate rule instead.  RECORD_TYPE is a dimension used for Cost Explorer APIs, and is also supported for Cost Category expressions. This dimension uses different terms, depending on whether you're using the console or API/JSON editor. For a detailed comparison, see Term Comparisons in the Billing and Cost Management User Guide.
        public let rule: Expression?
        /// You can define the CostCategoryRule rule type as either REGULAR or INHERITED_VALUE. The INHERITED_VALUE rule type adds the flexibility to define a rule that dynamically inherits the cost category value. This value is from the dimension value that's defined by CostCategoryInheritedValueDimension. For example, suppose that you want to costs to be dynamically grouped based on the value of a specific tag key. First, choose an inherited value rule type, and then choose the tag dimension and specify the tag key to use.
        public let type: CostCategoryRuleType?
        public let value: String?

        public init(inheritedValue: CostCategoryInheritedValueDimension? = nil, rule: Expression? = nil, type: CostCategoryRuleType? = nil, value: String? = nil) {
            self.inheritedValue = inheritedValue
            self.rule = rule
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.inheritedValue?.validate(name: "\(name).inheritedValue")
            try self.rule?.validate(name: "\(name).rule")
            try self.validate(self.value, name: "value", parent: name, max: 50)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^(?! )[\\p{L}\\p{N}\\p{Z}-_]*(?<! )$")
        }

        private enum CodingKeys: String, CodingKey {
            case inheritedValue = "InheritedValue"
            case rule = "Rule"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct CostCategorySplitChargeRule: AWSEncodableShape & AWSDecodableShape {
        /// The method that's used to define how to split your source costs across your targets.   Proportional - Allocates charges across your targets based on the proportional weighted cost of each target.  Fixed - Allocates charges across your targets based on your defined allocation percentage. >Even - Allocates costs evenly across all targets.
        public let method: CostCategorySplitChargeMethod
        /// The parameters for a split charge method. This is only required for the FIXED method.
        public let parameters: [CostCategorySplitChargeRuleParameter]?
        /// The Cost Category value that you want to split. That value can't be used as a source or a target in other split charge rules. To indicate uncategorized costs, you can use an empty string as the source.
        public let source: String
        /// The Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        public let targets: [String]

        public init(method: CostCategorySplitChargeMethod, parameters: [CostCategorySplitChargeRuleParameter]? = nil, source: String, targets: [String]) {
            self.method = method
            self.parameters = parameters
            self.source = source
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.parameters?.forEach {
                try $0.validate(name: "\(name).parameters[]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 10)
            try self.validate(self.parameters, name: "parameters", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, max: 1024)
            try self.validate(self.source, name: "source", parent: name, pattern: "^[\\S\\s]*$")
            try self.targets.forEach {
                try validate($0, name: "targets[]", parent: name, max: 1024)
                try validate($0, name: "targets[]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.targets, name: "targets", parent: name, max: 500)
            try self.validate(self.targets, name: "targets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case method = "Method"
            case parameters = "Parameters"
            case source = "Source"
            case targets = "Targets"
        }
    }

    public struct CostCategorySplitChargeRuleParameter: AWSEncodableShape & AWSDecodableShape {
        /// The parameter type.
        public let type: CostCategorySplitChargeRuleParameterType
        /// The parameter values.
        public let values: [String]

        public init(type: CostCategorySplitChargeRuleParameterType, values: [String]) {
            self.type = type
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 500)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case values = "Values"
        }
    }

    public struct CostCategoryValues: AWSEncodableShape & AWSDecodableShape {
        public let key: String?
        /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is EQUALS and CASE_SENSITIVE.
        public let matchOptions: [MatchOption]?
        /// The specific value of the Cost Category.
        public let values: [String]?

        public init(key: String? = nil, matchOptions: [MatchOption]? = nil, values: [String]? = nil) {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 50)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^(?! )[\\p{L}\\p{N}\\p{Z}-_]*(?<! )$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\S\\s]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case matchOptions = "MatchOptions"
            case values = "Values"
        }
    }

    public struct Coverage: AWSDecodableShape {
        /// The amount of cost that the reservation covered.
        public let coverageCost: CoverageCost?
        /// The amount of instance usage that the reservation covered, in hours.
        public let coverageHours: CoverageHours?
        /// The amount of instance usage that the reservation covered, in normalized units.
        public let coverageNormalizedUnits: CoverageNormalizedUnits?

        public init(coverageCost: CoverageCost? = nil, coverageHours: CoverageHours? = nil, coverageNormalizedUnits: CoverageNormalizedUnits? = nil) {
            self.coverageCost = coverageCost
            self.coverageHours = coverageHours
            self.coverageNormalizedUnits = coverageNormalizedUnits
        }

        private enum CodingKeys: String, CodingKey {
            case coverageCost = "CoverageCost"
            case coverageHours = "CoverageHours"
            case coverageNormalizedUnits = "CoverageNormalizedUnits"
        }
    }

    public struct CoverageByTime: AWSDecodableShape {
        /// The groups of instances that the reservation covered.
        public let groups: [ReservationCoverageGroup]?
        /// The period that this coverage was used over.
        public let timePeriod: DateInterval?
        /// The total reservation coverage, in hours.
        public let total: Coverage?

        public init(groups: [ReservationCoverageGroup]? = nil, timePeriod: DateInterval? = nil, total: Coverage? = nil) {
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case timePeriod = "TimePeriod"
            case total = "Total"
        }
    }

    public struct CoverageCost: AWSDecodableShape {
        /// How much an On-Demand Instance costs.
        public let onDemandCost: String?

        public init(onDemandCost: String? = nil) {
            self.onDemandCost = onDemandCost
        }

        private enum CodingKeys: String, CodingKey {
            case onDemandCost = "OnDemandCost"
        }
    }

    public struct CoverageHours: AWSDecodableShape {
        /// The percentage of instance hours that a reservation covered.
        public let coverageHoursPercentage: String?
        /// The number of instance running hours that On-Demand Instances covered.
        public let onDemandHours: String?
        /// The number of instance running hours that reservations covered.
        public let reservedHours: String?
        /// The total instance usage, in hours.
        public let totalRunningHours: String?

        public init(coverageHoursPercentage: String? = nil, onDemandHours: String? = nil, reservedHours: String? = nil, totalRunningHours: String? = nil) {
            self.coverageHoursPercentage = coverageHoursPercentage
            self.onDemandHours = onDemandHours
            self.reservedHours = reservedHours
            self.totalRunningHours = totalRunningHours
        }

        private enum CodingKeys: String, CodingKey {
            case coverageHoursPercentage = "CoverageHoursPercentage"
            case onDemandHours = "OnDemandHours"
            case reservedHours = "ReservedHours"
            case totalRunningHours = "TotalRunningHours"
        }
    }

    public struct CoverageNormalizedUnits: AWSDecodableShape {
        /// The percentage of your used instance normalized units that a reservation covers.
        public let coverageNormalizedUnitsPercentage: String?
        /// The number of normalized units that are covered by On-Demand Instances instead of a reservation.
        public let onDemandNormalizedUnits: String?
        /// The number of normalized units that a reservation covers.
        public let reservedNormalizedUnits: String?
        /// The total number of normalized units that you used.
        public let totalRunningNormalizedUnits: String?

        public init(coverageNormalizedUnitsPercentage: String? = nil, onDemandNormalizedUnits: String? = nil, reservedNormalizedUnits: String? = nil, totalRunningNormalizedUnits: String? = nil) {
            self.coverageNormalizedUnitsPercentage = coverageNormalizedUnitsPercentage
            self.onDemandNormalizedUnits = onDemandNormalizedUnits
            self.reservedNormalizedUnits = reservedNormalizedUnits
            self.totalRunningNormalizedUnits = totalRunningNormalizedUnits
        }

        private enum CodingKeys: String, CodingKey {
            case coverageNormalizedUnitsPercentage = "CoverageNormalizedUnitsPercentage"
            case onDemandNormalizedUnits = "OnDemandNormalizedUnits"
            case reservedNormalizedUnits = "ReservedNormalizedUnits"
            case totalRunningNormalizedUnits = "TotalRunningNormalizedUnits"
        }
    }

    public struct CreateAnomalyMonitorRequest: AWSEncodableShape {
        /// The cost anomaly detection monitor object that you want to create.
        public let anomalyMonitor: AnomalyMonitor
        /// An optional list of tags to associate with the specified  AnomalyMonitor . You can use resource tags to control access to your monitor using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:   Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use   The maximum length of a key is 128 characters   The maximum length of a value is 256 characters   Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-    Keys and values are case sensitive   Keys and values are trimmed for any leading or trailing whitespaces   Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
        public let resourceTags: [ResourceTag]?

        public init(anomalyMonitor: AnomalyMonitor, resourceTags: [ResourceTag]? = nil) {
            self.anomalyMonitor = anomalyMonitor
            self.resourceTags = resourceTags
        }

        public func validate(name: String) throws {
            try self.anomalyMonitor.validate(name: "\(name).anomalyMonitor")
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyMonitor = "AnomalyMonitor"
            case resourceTags = "ResourceTags"
        }
    }

    public struct CreateAnomalyMonitorResponse: AWSDecodableShape {
        /// The unique identifier of your newly created cost anomaly detection monitor.
        public let monitorArn: String

        public init(monitorArn: String) {
            self.monitorArn = monitorArn
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
        }
    }

    public struct CreateAnomalySubscriptionRequest: AWSEncodableShape {
        /// The cost anomaly subscription object that you want to create.
        public let anomalySubscription: AnomalySubscription
        /// An optional list of tags to associate with the specified  AnomalySubscription . You can use resource tags to control access to your subscription using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:   Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use   The maximum length of a key is 128 characters   The maximum length of a value is 256 characters   Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-    Keys and values are case sensitive   Keys and values are trimmed for any leading or trailing whitespaces   Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
        public let resourceTags: [ResourceTag]?

        public init(anomalySubscription: AnomalySubscription, resourceTags: [ResourceTag]? = nil) {
            self.anomalySubscription = anomalySubscription
            self.resourceTags = resourceTags
        }

        public func validate(name: String) throws {
            try self.anomalySubscription.validate(name: "\(name).anomalySubscription")
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case anomalySubscription = "AnomalySubscription"
            case resourceTags = "ResourceTags"
        }
    }

    public struct CreateAnomalySubscriptionResponse: AWSDecodableShape {
        /// The unique identifier of your newly created cost anomaly subscription.
        public let subscriptionArn: String

        public init(subscriptionArn: String) {
            self.subscriptionArn = subscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionArn = "SubscriptionArn"
        }
    }

    public struct CreateCostCategoryDefinitionRequest: AWSEncodableShape {
        public let defaultValue: String?
        /// The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.
        public let effectiveStart: String?
        public let name: String
        /// An optional list of tags to associate with the specified  CostCategory . You can use resource tags to control access to your cost category using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:   Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use   The maximum length of a key is 128 characters   The maximum length of a value is 256 characters   Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-    Keys and values are case sensitive   Keys and values are trimmed for any leading or trailing whitespaces   Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
        public let resourceTags: [ResourceTag]?
        /// The Cost Category rules used to categorize costs. For more information, see CostCategoryRule.
        public let rules: [CostCategoryRule]
        public let ruleVersion: CostCategoryRuleVersion
        ///  The split charge rules used to allocate your charges between your Cost Category values.
        public let splitChargeRules: [CostCategorySplitChargeRule]?

        public init(defaultValue: String? = nil, effectiveStart: String? = nil, name: String, resourceTags: [ResourceTag]? = nil, rules: [CostCategoryRule], ruleVersion: CostCategoryRuleVersion, splitChargeRules: [CostCategorySplitChargeRule]? = nil) {
            self.defaultValue = defaultValue
            self.effectiveStart = effectiveStart
            self.name = name
            self.resourceTags = resourceTags
            self.rules = rules
            self.ruleVersion = ruleVersion
            self.splitChargeRules = splitChargeRules
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 50)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, min: 1)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, pattern: "^(?! )[\\p{L}\\p{N}\\p{Z}-_]*(?<! )$")
            try self.validate(self.effectiveStart, name: "effectiveStart", parent: name, max: 25)
            try self.validate(self.effectiveStart, name: "effectiveStart", parent: name, min: 20)
            try self.validate(self.effectiveStart, name: "effectiveStart", parent: name, pattern: "^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(([+-]\\d\\d:\\d\\d)|Z)$")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?! )[\\p{L}\\p{N}\\p{Z}-_]*(?<! )$")
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 200)
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 500)
            try self.validate(self.rules, name: "rules", parent: name, min: 1)
            try self.splitChargeRules?.forEach {
                try $0.validate(name: "\(name).splitChargeRules[]")
            }
            try self.validate(self.splitChargeRules, name: "splitChargeRules", parent: name, max: 10)
            try self.validate(self.splitChargeRules, name: "splitChargeRules", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case effectiveStart = "EffectiveStart"
            case name = "Name"
            case resourceTags = "ResourceTags"
            case rules = "Rules"
            case ruleVersion = "RuleVersion"
            case splitChargeRules = "SplitChargeRules"
        }
    }

    public struct CreateCostCategoryDefinitionResponse: AWSDecodableShape {
        /// The unique identifier for your newly created Cost Category.
        public let costCategoryArn: String?
        /// The Cost Category's effective start date. It can only be a billing start date (first day of the month).
        public let effectiveStart: String?

        public init(costCategoryArn: String? = nil, effectiveStart: String? = nil) {
            self.costCategoryArn = costCategoryArn
            self.effectiveStart = effectiveStart
        }

        private enum CodingKeys: String, CodingKey {
            case costCategoryArn = "CostCategoryArn"
            case effectiveStart = "EffectiveStart"
        }
    }

    public struct CurrentInstance: AWSDecodableShape {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public let currencyCode: String?
        /// The name that you given an instance. This field shows as blank if you haven't given the instance a name.
        public let instanceName: String?
        /// The current On-Demand cost of operating this instance on a monthly basis.
        public let monthlyCost: String?
        /// The number of hours during the lookback period that's billed at On-Demand rates.
        public let onDemandHoursInLookbackPeriod: String?
        /// The number of hours during the lookback period that's covered by reservations.
        public let reservationCoveredHoursInLookbackPeriod: String?
        /// Details about the resource and utilization.
        public let resourceDetails: ResourceDetails?
        /// Resource ID of the current instance.
        public let resourceId: String?
        /// Utilization information of the current instance during the lookback period.
        public let resourceUtilization: ResourceUtilization?
        /// The number of hours during the lookback period that's covered by Savings Plans.
        public let savingsPlansCoveredHoursInLookbackPeriod: String?
        /// Cost allocation resource tags that are applied to the instance.
        public let tags: [TagValues]?
        /// The total number of hours that the instance ran during the lookback period.
        public let totalRunningHoursInLookbackPeriod: String?

        public init(currencyCode: String? = nil, instanceName: String? = nil, monthlyCost: String? = nil, onDemandHoursInLookbackPeriod: String? = nil, reservationCoveredHoursInLookbackPeriod: String? = nil, resourceDetails: ResourceDetails? = nil, resourceId: String? = nil, resourceUtilization: ResourceUtilization? = nil, savingsPlansCoveredHoursInLookbackPeriod: String? = nil, tags: [TagValues]? = nil, totalRunningHoursInLookbackPeriod: String? = nil) {
            self.currencyCode = currencyCode
            self.instanceName = instanceName
            self.monthlyCost = monthlyCost
            self.onDemandHoursInLookbackPeriod = onDemandHoursInLookbackPeriod
            self.reservationCoveredHoursInLookbackPeriod = reservationCoveredHoursInLookbackPeriod
            self.resourceDetails = resourceDetails
            self.resourceId = resourceId
            self.resourceUtilization = resourceUtilization
            self.savingsPlansCoveredHoursInLookbackPeriod = savingsPlansCoveredHoursInLookbackPeriod
            self.tags = tags
            self.totalRunningHoursInLookbackPeriod = totalRunningHoursInLookbackPeriod
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "CurrencyCode"
            case instanceName = "InstanceName"
            case monthlyCost = "MonthlyCost"
            case onDemandHoursInLookbackPeriod = "OnDemandHoursInLookbackPeriod"
            case reservationCoveredHoursInLookbackPeriod = "ReservationCoveredHoursInLookbackPeriod"
            case resourceDetails = "ResourceDetails"
            case resourceId = "ResourceId"
            case resourceUtilization = "ResourceUtilization"
            case savingsPlansCoveredHoursInLookbackPeriod = "SavingsPlansCoveredHoursInLookbackPeriod"
            case tags = "Tags"
            case totalRunningHoursInLookbackPeriod = "TotalRunningHoursInLookbackPeriod"
        }
    }

    public struct DateInterval: AWSEncodableShape & AWSDecodableShape {
        /// The end of the time period. The end date is exclusive. For example, if end is 2017-05-01, Amazon Web Services retrieves cost and usage data from the start date up to, but not including, 2017-05-01.
        public let end: String
        /// The beginning of the time period. The start date is inclusive. For example, if start is 2017-01-01, Amazon Web Services retrieves cost and usage data starting at 2017-01-01 up to the end date. The start date must be equal to or no later than the current date to avoid a validation error.
        public let start: String

        public init(end: String, start: String) {
            self.end = end
            self.start = start
        }

        public func validate(name: String) throws {
            try self.validate(self.end, name: "end", parent: name, max: 40)
            try self.validate(self.end, name: "end", parent: name, pattern: "^(\\d{4}-\\d{2}-\\d{2})(T\\d{2}:\\d{2}:\\d{2}Z)?$")
            try self.validate(self.start, name: "start", parent: name, max: 40)
            try self.validate(self.start, name: "start", parent: name, pattern: "^(\\d{4}-\\d{2}-\\d{2})(T\\d{2}:\\d{2}:\\d{2}Z)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case end = "End"
            case start = "Start"
        }
    }

    public struct DeleteAnomalyMonitorRequest: AWSEncodableShape {
        /// The unique identifier of the cost anomaly monitor that you want to delete.
        public let monitorArn: String

        public init(monitorArn: String) {
            self.monitorArn = monitorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, max: 1024)
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
        }
    }

    public struct DeleteAnomalyMonitorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAnomalySubscriptionRequest: AWSEncodableShape {
        /// The unique identifier of the cost anomaly subscription that you want to delete.
        public let subscriptionArn: String

        public init(subscriptionArn: String) {
            self.subscriptionArn = subscriptionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.subscriptionArn, name: "subscriptionArn", parent: name, max: 1024)
            try self.validate(self.subscriptionArn, name: "subscriptionArn", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionArn = "SubscriptionArn"
        }
    }

    public struct DeleteAnomalySubscriptionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCostCategoryDefinitionRequest: AWSEncodableShape {
        /// The unique identifier for your Cost Category.
        public let costCategoryArn: String

        public init(costCategoryArn: String) {
            self.costCategoryArn = costCategoryArn
        }

        public func validate(name: String) throws {
            try self.validate(self.costCategoryArn, name: "costCategoryArn", parent: name, max: 2048)
            try self.validate(self.costCategoryArn, name: "costCategoryArn", parent: name, min: 20)
            try self.validate(self.costCategoryArn, name: "costCategoryArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case costCategoryArn = "CostCategoryArn"
        }
    }

    public struct DeleteCostCategoryDefinitionResponse: AWSDecodableShape {
        /// The unique identifier for your Cost Category.
        public let costCategoryArn: String?
        /// The effective end date of the Cost Category as a result of deleting it. No costs after this date is categorized by the deleted Cost Category.
        public let effectiveEnd: String?

        public init(costCategoryArn: String? = nil, effectiveEnd: String? = nil) {
            self.costCategoryArn = costCategoryArn
            self.effectiveEnd = effectiveEnd
        }

        private enum CodingKeys: String, CodingKey {
            case costCategoryArn = "CostCategoryArn"
            case effectiveEnd = "EffectiveEnd"
        }
    }

    public struct DescribeCostCategoryDefinitionRequest: AWSEncodableShape {
        /// The unique identifier for your Cost Category.
        public let costCategoryArn: String
        /// The date when the Cost Category was effective.
        public let effectiveOn: String?

        public init(costCategoryArn: String, effectiveOn: String? = nil) {
            self.costCategoryArn = costCategoryArn
            self.effectiveOn = effectiveOn
        }

        public func validate(name: String) throws {
            try self.validate(self.costCategoryArn, name: "costCategoryArn", parent: name, max: 2048)
            try self.validate(self.costCategoryArn, name: "costCategoryArn", parent: name, min: 20)
            try self.validate(self.costCategoryArn, name: "costCategoryArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            try self.validate(self.effectiveOn, name: "effectiveOn", parent: name, max: 25)
            try self.validate(self.effectiveOn, name: "effectiveOn", parent: name, min: 20)
            try self.validate(self.effectiveOn, name: "effectiveOn", parent: name, pattern: "^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(([+-]\\d\\d:\\d\\d)|Z)$")
        }

        private enum CodingKeys: String, CodingKey {
            case costCategoryArn = "CostCategoryArn"
            case effectiveOn = "EffectiveOn"
        }
    }

    public struct DescribeCostCategoryDefinitionResponse: AWSDecodableShape {
        public let costCategory: CostCategory?

        public init(costCategory: CostCategory? = nil) {
            self.costCategory = costCategory
        }

        private enum CodingKeys: String, CodingKey {
            case costCategory = "CostCategory"
        }
    }

    public struct DimensionValues: AWSEncodableShape & AWSDecodableShape {
        /// The names of the metadata types that you can use to filter and group your results. For example, AZ returns a list of Availability Zones. Not all dimensions are supported in each API. Refer to the documentation for each specific API to see what is supported.  LINK_ACCOUNT_NAME and SERVICE_CODE can only be used in CostCategoryRule.  ANOMALY_TOTAL_IMPACT_ABSOLUTE and ANOMALY_TOTAL_IMPACT_PERCENTAGE can only be used in AnomalySubscriptions.
        public let key: Dimension?
        /// The match options that you can use to filter your results.  MatchOptions is only applicable for actions related to Cost Category and Anomaly Subscriptions. Refer to the documentation for each specific API to see what is supported. The default values for MatchOptions are EQUALS and CASE_SENSITIVE.
        public let matchOptions: [MatchOption]?
        /// The metadata values that you can use to filter and group your results. You can use GetDimensionValues to find specific values.
        public let values: [String]?

        public init(key: Dimension? = nil, matchOptions: [MatchOption]? = nil, values: [String]? = nil) {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\S\\s]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case matchOptions = "MatchOptions"
            case values = "Values"
        }
    }

    public struct DimensionValuesWithAttributes: AWSDecodableShape {
        /// The attribute that applies to a specific Dimension.
        public let attributes: [String: String]?
        /// The value of a dimension with a specific attribute.
        public let value: String?

        public init(attributes: [String: String]? = nil, value: String? = nil) {
            self.attributes = attributes
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case value = "Value"
        }
    }

    public struct DiskResourceUtilization: AWSDecodableShape {
        /// The maximum read throughput operations per second.
        public let diskReadBytesPerSecond: String?
        /// The maximum number of read operations per second.
        public let diskReadOpsPerSecond: String?
        /// The maximum write throughput operations per second.
        public let diskWriteBytesPerSecond: String?
        /// The maximum number of write operations per second.
        public let diskWriteOpsPerSecond: String?

        public init(diskReadBytesPerSecond: String? = nil, diskReadOpsPerSecond: String? = nil, diskWriteBytesPerSecond: String? = nil, diskWriteOpsPerSecond: String? = nil) {
            self.diskReadBytesPerSecond = diskReadBytesPerSecond
            self.diskReadOpsPerSecond = diskReadOpsPerSecond
            self.diskWriteBytesPerSecond = diskWriteBytesPerSecond
            self.diskWriteOpsPerSecond = diskWriteOpsPerSecond
        }

        private enum CodingKeys: String, CodingKey {
            case diskReadBytesPerSecond = "DiskReadBytesPerSecond"
            case diskReadOpsPerSecond = "DiskReadOpsPerSecond"
            case diskWriteBytesPerSecond = "DiskWriteBytesPerSecond"
            case diskWriteOpsPerSecond = "DiskWriteOpsPerSecond"
        }
    }

    public struct EBSResourceUtilization: AWSDecodableShape {
        /// The maximum size of read operations per second
        public let ebsReadBytesPerSecond: String?
        /// The maximum number of read operations per second.
        public let ebsReadOpsPerSecond: String?
        /// The maximum size of write operations per second.
        public let ebsWriteBytesPerSecond: String?
        /// The maximum number of write operations per second.
        public let ebsWriteOpsPerSecond: String?

        public init(ebsReadBytesPerSecond: String? = nil, ebsReadOpsPerSecond: String? = nil, ebsWriteBytesPerSecond: String? = nil, ebsWriteOpsPerSecond: String? = nil) {
            self.ebsReadBytesPerSecond = ebsReadBytesPerSecond
            self.ebsReadOpsPerSecond = ebsReadOpsPerSecond
            self.ebsWriteBytesPerSecond = ebsWriteBytesPerSecond
            self.ebsWriteOpsPerSecond = ebsWriteOpsPerSecond
        }

        private enum CodingKeys: String, CodingKey {
            case ebsReadBytesPerSecond = "EbsReadBytesPerSecond"
            case ebsReadOpsPerSecond = "EbsReadOpsPerSecond"
            case ebsWriteBytesPerSecond = "EbsWriteBytesPerSecond"
            case ebsWriteOpsPerSecond = "EbsWriteOpsPerSecond"
        }
    }

    public struct EC2InstanceDetails: AWSDecodableShape {
        /// The Availability Zone of the recommended reservation.
        public let availabilityZone: String?
        /// Determines whether the recommendation is for a current-generation instance.
        public let currentGeneration: Bool?
        /// The instance family of the recommended reservation.
        public let family: String?
        /// The type of instance that Amazon Web Services recommends.
        public let instanceType: String?
        /// The platform of the recommended reservation. The platform is the specific combination of operating system, license model, and software on an instance.
        public let platform: String?
        /// The Amazon Web Services Region of the recommended reservation.
        public let region: String?
        /// Determines whether the recommended reservation is size flexible.
        public let sizeFlexEligible: Bool?
        /// Determines whether the recommended reservation is dedicated or shared.
        public let tenancy: String?

        public init(availabilityZone: String? = nil, currentGeneration: Bool? = nil, family: String? = nil, instanceType: String? = nil, platform: String? = nil, region: String? = nil, sizeFlexEligible: Bool? = nil, tenancy: String? = nil) {
            self.availabilityZone = availabilityZone
            self.currentGeneration = currentGeneration
            self.family = family
            self.instanceType = instanceType
            self.platform = platform
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
            self.tenancy = tenancy
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case currentGeneration = "CurrentGeneration"
            case family = "Family"
            case instanceType = "InstanceType"
            case platform = "Platform"
            case region = "Region"
            case sizeFlexEligible = "SizeFlexEligible"
            case tenancy = "Tenancy"
        }
    }

    public struct EC2ResourceDetails: AWSDecodableShape {
        /// The hourly public On-Demand rate for the instance type.
        public let hourlyOnDemandRate: String?
        /// The type of Amazon Web Services instance.
        public let instanceType: String?
        /// The memory capacity of the Amazon Web Services instance.
        public let memory: String?
        /// The network performance capacity of the Amazon Web Services instance.
        public let networkPerformance: String?
        /// The platform of the Amazon Web Services instance. The platform is the specific combination of operating system, license model, and software on an instance.
        public let platform: String?
        /// The Amazon Web Services Region of the instance.
        public let region: String?
        /// The SKU of the product.
        public let sku: String?
        /// The disk storage of the Amazon Web Services instance. This doesn't include EBS storage.
        public let storage: String?
        /// The number of VCPU cores in the Amazon Web Services instance type.
        public let vcpu: String?

        public init(hourlyOnDemandRate: String? = nil, instanceType: String? = nil, memory: String? = nil, networkPerformance: String? = nil, platform: String? = nil, region: String? = nil, sku: String? = nil, storage: String? = nil, vcpu: String? = nil) {
            self.hourlyOnDemandRate = hourlyOnDemandRate
            self.instanceType = instanceType
            self.memory = memory
            self.networkPerformance = networkPerformance
            self.platform = platform
            self.region = region
            self.sku = sku
            self.storage = storage
            self.vcpu = vcpu
        }

        private enum CodingKeys: String, CodingKey {
            case hourlyOnDemandRate = "HourlyOnDemandRate"
            case instanceType = "InstanceType"
            case memory = "Memory"
            case networkPerformance = "NetworkPerformance"
            case platform = "Platform"
            case region = "Region"
            case sku = "Sku"
            case storage = "Storage"
            case vcpu = "Vcpu"
        }
    }

    public struct EC2ResourceUtilization: AWSDecodableShape {
        /// The field that contains a list of disk (local storage) metrics that are associated with the current instance.
        public let diskResourceUtilization: DiskResourceUtilization?
        /// The EBS field that contains a list of EBS metrics that are associated with the current instance.
        public let ebsResourceUtilization: EBSResourceUtilization?
        /// The maximum observed or expected CPU utilization of the instance.
        public let maxCpuUtilizationPercentage: String?
        /// The maximum observed or expected memory utilization of the instance.
        public let maxMemoryUtilizationPercentage: String?
        /// The maximum observed or expected storage utilization of the instance. This doesn't include EBS storage.
        public let maxStorageUtilizationPercentage: String?
        /// The network field that contains a list of network metrics that are associated with the current instance.
        public let networkResourceUtilization: NetworkResourceUtilization?

        public init(diskResourceUtilization: DiskResourceUtilization? = nil, ebsResourceUtilization: EBSResourceUtilization? = nil, maxCpuUtilizationPercentage: String? = nil, maxMemoryUtilizationPercentage: String? = nil, maxStorageUtilizationPercentage: String? = nil, networkResourceUtilization: NetworkResourceUtilization? = nil) {
            self.diskResourceUtilization = diskResourceUtilization
            self.ebsResourceUtilization = ebsResourceUtilization
            self.maxCpuUtilizationPercentage = maxCpuUtilizationPercentage
            self.maxMemoryUtilizationPercentage = maxMemoryUtilizationPercentage
            self.maxStorageUtilizationPercentage = maxStorageUtilizationPercentage
            self.networkResourceUtilization = networkResourceUtilization
        }

        private enum CodingKeys: String, CodingKey {
            case diskResourceUtilization = "DiskResourceUtilization"
            case ebsResourceUtilization = "EBSResourceUtilization"
            case maxCpuUtilizationPercentage = "MaxCpuUtilizationPercentage"
            case maxMemoryUtilizationPercentage = "MaxMemoryUtilizationPercentage"
            case maxStorageUtilizationPercentage = "MaxStorageUtilizationPercentage"
            case networkResourceUtilization = "NetworkResourceUtilization"
        }
    }

    public struct EC2Specification: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether you want a recommendation for standard or convertible reservations.
        public let offeringClass: OfferingClass?

        public init(offeringClass: OfferingClass? = nil) {
            self.offeringClass = offeringClass
        }

        private enum CodingKeys: String, CodingKey {
            case offeringClass = "OfferingClass"
        }
    }

    public struct ESInstanceDetails: AWSDecodableShape {
        /// Determines whether the recommendation is for a current-generation instance.
        public let currentGeneration: Bool?
        /// The class of instance that Amazon Web Services recommends.
        public let instanceClass: String?
        /// The size of instance that Amazon Web Services recommends.
        public let instanceSize: String?
        /// The Amazon Web Services Region of the recommended reservation.
        public let region: String?
        /// Determines whether the recommended reservation is size flexible.
        public let sizeFlexEligible: Bool?

        public init(currentGeneration: Bool? = nil, instanceClass: String? = nil, instanceSize: String? = nil, region: String? = nil, sizeFlexEligible: Bool? = nil) {
            self.currentGeneration = currentGeneration
            self.instanceClass = instanceClass
            self.instanceSize = instanceSize
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }

        private enum CodingKeys: String, CodingKey {
            case currentGeneration = "CurrentGeneration"
            case instanceClass = "InstanceClass"
            case instanceSize = "InstanceSize"
            case region = "Region"
            case sizeFlexEligible = "SizeFlexEligible"
        }
    }

    public struct ElastiCacheInstanceDetails: AWSDecodableShape {
        /// Determines whether the recommendation is for a current generation instance.
        public let currentGeneration: Bool?
        /// The instance family of the recommended reservation.
        public let family: String?
        /// The type of node that Amazon Web Services recommends.
        public let nodeType: String?
        /// The description of the recommended reservation.
        public let productDescription: String?
        /// The Amazon Web Services Region of the recommended reservation.
        public let region: String?
        /// Determines whether the recommended reservation is size flexible.
        public let sizeFlexEligible: Bool?

        public init(currentGeneration: Bool? = nil, family: String? = nil, nodeType: String? = nil, productDescription: String? = nil, region: String? = nil, sizeFlexEligible: Bool? = nil) {
            self.currentGeneration = currentGeneration
            self.family = family
            self.nodeType = nodeType
            self.productDescription = productDescription
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }

        private enum CodingKeys: String, CodingKey {
            case currentGeneration = "CurrentGeneration"
            case family = "Family"
            case nodeType = "NodeType"
            case productDescription = "ProductDescription"
            case region = "Region"
            case sizeFlexEligible = "SizeFlexEligible"
        }
    }

    public final class Expression: AWSEncodableShape & AWSDecodableShape {
        /// Return results that match both Dimension objects.
        public let and: [Expression]?
        /// The filter that's based on CostCategory values.
        public let costCategories: CostCategoryValues?
        /// The specific Dimension to use for Expression.
        public let dimensions: DimensionValues?
        /// Return results that don't match a Dimension object.
        public let not: Expression?
        /// Return results that match either Dimension object.
        public let or: [Expression]?
        /// The specific Tag to use for Expression.
        public let tags: TagValues?

        public init(and: [Expression]? = nil, costCategories: CostCategoryValues? = nil, dimensions: DimensionValues? = nil, not: Expression? = nil, or: [Expression]? = nil, tags: TagValues? = nil) {
            self.and = and
            self.costCategories = costCategories
            self.dimensions = dimensions
            self.not = not
            self.or = or
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.and?.forEach {
                try $0.validate(name: "\(name).and[]")
            }
            try self.costCategories?.validate(name: "\(name).costCategories")
            try self.dimensions?.validate(name: "\(name).dimensions")
            try self.not?.validate(name: "\(name).not")
            try self.or?.forEach {
                try $0.validate(name: "\(name).or[]")
            }
            try self.tags?.validate(name: "\(name).tags")
        }

        private enum CodingKeys: String, CodingKey {
            case and = "And"
            case costCategories = "CostCategories"
            case dimensions = "Dimensions"
            case not = "Not"
            case or = "Or"
            case tags = "Tags"
        }
    }

    public struct ForecastResult: AWSDecodableShape {
        /// The mean value of the forecast.
        public let meanValue: String?
        /// The lower limit for the prediction interval.
        public let predictionIntervalLowerBound: String?
        /// The upper limit for the prediction interval.
        public let predictionIntervalUpperBound: String?
        /// The period of time that the forecast covers.
        public let timePeriod: DateInterval?

        public init(meanValue: String? = nil, predictionIntervalLowerBound: String? = nil, predictionIntervalUpperBound: String? = nil, timePeriod: DateInterval? = nil) {
            self.meanValue = meanValue
            self.predictionIntervalLowerBound = predictionIntervalLowerBound
            self.predictionIntervalUpperBound = predictionIntervalUpperBound
            self.timePeriod = timePeriod
        }

        private enum CodingKeys: String, CodingKey {
            case meanValue = "MeanValue"
            case predictionIntervalLowerBound = "PredictionIntervalLowerBound"
            case predictionIntervalUpperBound = "PredictionIntervalUpperBound"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GenerationSummary: AWSDecodableShape {
        /// Indicates the estimated time for when the recommendation generation will complete.
        public let estimatedCompletionTime: String?
        /// Indicates the completion time of the recommendation generation.
        public let generationCompletionTime: String?
        /// Indicates the start time of the recommendation generation.
        public let generationStartedTime: String?
        /// Indicates whether the recommendation generation succeeded, is processing, or failed.
        public let generationStatus: GenerationStatus?
        /// Indicates the ID for this specific recommendation.
        public let recommendationId: String?

        public init(estimatedCompletionTime: String? = nil, generationCompletionTime: String? = nil, generationStartedTime: String? = nil, generationStatus: GenerationStatus? = nil, recommendationId: String? = nil) {
            self.estimatedCompletionTime = estimatedCompletionTime
            self.generationCompletionTime = generationCompletionTime
            self.generationStartedTime = generationStartedTime
            self.generationStatus = generationStatus
            self.recommendationId = recommendationId
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedCompletionTime = "EstimatedCompletionTime"
            case generationCompletionTime = "GenerationCompletionTime"
            case generationStartedTime = "GenerationStartedTime"
            case generationStatus = "GenerationStatus"
            case recommendationId = "RecommendationId"
        }
    }

    public struct GetAnomaliesRequest: AWSEncodableShape {
        /// Assigns the start and end dates for retrieving cost anomalies. The returned anomaly object will have an AnomalyEndDate in the specified time range.
        public let dateInterval: AnomalyDateInterval
        /// Filters anomaly results by the feedback field on the anomaly object.
        public let feedback: AnomalyFeedbackType?
        /// The number of entries a paginated response contains.
        public let maxResults: Int?
        /// Retrieves all of the cost anomalies detected for a specific cost anomaly monitor Amazon Resource Name (ARN).
        public let monitorArn: String?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// Filters anomaly results by the total impact field on the anomaly object. For example, you can filter anomalies GREATER_THAN 200.00 to retrieve anomalies, with an estimated dollar impact greater than 200.
        public let totalImpact: TotalImpactFilter?

        public init(dateInterval: AnomalyDateInterval, feedback: AnomalyFeedbackType? = nil, maxResults: Int? = nil, monitorArn: String? = nil, nextPageToken: String? = nil, totalImpact: TotalImpactFilter? = nil) {
            self.dateInterval = dateInterval
            self.feedback = feedback
            self.maxResults = maxResults
            self.monitorArn = monitorArn
            self.nextPageToken = nextPageToken
            self.totalImpact = totalImpact
        }

        public func validate(name: String) throws {
            try self.dateInterval.validate(name: "\(name).dateInterval")
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, max: 1024)
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dateInterval = "DateInterval"
            case feedback = "Feedback"
            case maxResults = "MaxResults"
            case monitorArn = "MonitorArn"
            case nextPageToken = "NextPageToken"
            case totalImpact = "TotalImpact"
        }
    }

    public struct GetAnomaliesResponse: AWSDecodableShape {
        /// A list of cost anomalies.
        public let anomalies: [Anomaly]
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(anomalies: [Anomaly], nextPageToken: String? = nil) {
            self.anomalies = anomalies
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case anomalies = "Anomalies"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct GetAnomalyMonitorsRequest: AWSEncodableShape {
        /// The number of entries that a paginated response contains.
        public let maxResults: Int?
        /// A list of cost anomaly monitor ARNs.
        public let monitorArnList: [String]?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(maxResults: Int? = nil, monitorArnList: [String]? = nil, nextPageToken: String? = nil) {
            self.maxResults = maxResults
            self.monitorArnList = monitorArnList
            self.nextPageToken = nextPageToken
        }

        public func validate(name: String) throws {
            try self.monitorArnList?.forEach {
                try validate($0, name: "monitorArnList[]", parent: name, max: 1024)
                try validate($0, name: "monitorArnList[]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case monitorArnList = "MonitorArnList"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct GetAnomalyMonitorsResponse: AWSDecodableShape {
        /// A list of cost anomaly monitors that includes the detailed metadata for each monitor.
        public let anomalyMonitors: [AnomalyMonitor]
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(anomalyMonitors: [AnomalyMonitor], nextPageToken: String? = nil) {
            self.anomalyMonitors = anomalyMonitors
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyMonitors = "AnomalyMonitors"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct GetAnomalySubscriptionsRequest: AWSEncodableShape {
        /// The number of entries a paginated response contains.
        public let maxResults: Int?
        /// Cost anomaly monitor ARNs.
        public let monitorArn: String?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// A list of cost anomaly subscription ARNs.
        public let subscriptionArnList: [String]?

        public init(maxResults: Int? = nil, monitorArn: String? = nil, nextPageToken: String? = nil, subscriptionArnList: [String]? = nil) {
            self.maxResults = maxResults
            self.monitorArn = monitorArn
            self.nextPageToken = nextPageToken
            self.subscriptionArnList = subscriptionArnList
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, max: 1024)
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.subscriptionArnList?.forEach {
                try validate($0, name: "subscriptionArnList[]", parent: name, max: 1024)
                try validate($0, name: "subscriptionArnList[]", parent: name, pattern: "^[\\S\\s]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case monitorArn = "MonitorArn"
            case nextPageToken = "NextPageToken"
            case subscriptionArnList = "SubscriptionArnList"
        }
    }

    public struct GetAnomalySubscriptionsResponse: AWSDecodableShape {
        /// A list of cost anomaly subscriptions that includes the detailed metadata for each one.
        public let anomalySubscriptions: [AnomalySubscription]
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(anomalySubscriptions: [AnomalySubscription], nextPageToken: String? = nil) {
            self.anomalySubscriptions = anomalySubscriptions
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case anomalySubscriptions = "AnomalySubscriptions"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct GetCostAndUsageRequest: AWSEncodableShape {
        /// Filters Amazon Web Services costs by different dimensions. For example, you can specify SERVICE and LINKED_ACCOUNT and get the costs that are associated with that account's usage of that service. You can nest Expression objects to define any combination of dimension filters. For more information, see Expression.  Valid values for MatchOptions for Dimensions are EQUALS and CASE_SENSITIVE. Valid values for MatchOptions for CostCategories and Tags are EQUALS, ABSENT, and CASE_SENSITIVE. Default values are EQUALS and CASE_SENSITIVE.
        public let filter: Expression?
        /// Sets the Amazon Web Services cost granularity to MONTHLY or DAILY, or HOURLY. If Granularity isn't set, the response object doesn't include the Granularity, either MONTHLY or DAILY, or HOURLY.
        public let granularity: Granularity
        /// You can group Amazon Web Services costs using up to two different groups, either dimensions, tag keys, cost categories, or any two group by types. Valid values for the DIMENSION type are AZ, INSTANCE_TYPE, LEGAL_ENTITY_NAME, INVOICING_ENTITY, LINKED_ACCOUNT, OPERATION, PLATFORM, PURCHASE_TYPE, SERVICE, TENANCY, RECORD_TYPE, and USAGE_TYPE. When you group by the TAG type and include a valid tag key, you get all tag values, including empty strings.
        public let groupBy: [GroupDefinition]?
        /// Which metrics are returned in the query. For more information about blended and unblended rates, see Why does the "blended" annotation appear on some line items in my bill?.  Valid values are AmortizedCost, BlendedCost, NetAmortizedCost, NetUnblendedCost, NormalizedUsageAmount, UnblendedCost, and UsageQuantity.   If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours and GB). To get more meaningful UsageQuantity metrics, filter by UsageType or UsageTypeGroups.    Metrics is required for GetCostAndUsage requests.
        public let metrics: [String]
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// Sets the start date and end date for retrieving Amazon Web Services costs. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
        public let timePeriod: DateInterval

        public init(filter: Expression? = nil, granularity: Granularity, groupBy: [GroupDefinition]? = nil, metrics: [String], nextPageToken: String? = nil, timePeriod: DateInterval) {
            self.filter = filter
            self.granularity = granularity
            self.groupBy = groupBy
            self.metrics = metrics
            self.nextPageToken = nextPageToken
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.groupBy?.forEach {
                try $0.validate(name: "\(name).groupBy[]")
            }
            try self.metrics.forEach {
                try validate($0, name: "metrics[]", parent: name, max: 1024)
                try validate($0, name: "metrics[]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case granularity = "Granularity"
            case groupBy = "GroupBy"
            case metrics = "Metrics"
            case nextPageToken = "NextPageToken"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetCostAndUsageResponse: AWSDecodableShape {
        /// The attributes that apply to a specific dimension value. For example, if the value is a linked account, the attribute is that account name.
        public let dimensionValueAttributes: [DimensionValuesWithAttributes]?
        /// The groups that are specified by the Filter or GroupBy parameters in the request.
        public let groupDefinitions: [GroupDefinition]?
        /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// The time period that's covered by the results in the response.
        public let resultsByTime: [ResultByTime]?

        public init(dimensionValueAttributes: [DimensionValuesWithAttributes]? = nil, groupDefinitions: [GroupDefinition]? = nil, nextPageToken: String? = nil, resultsByTime: [ResultByTime]? = nil) {
            self.dimensionValueAttributes = dimensionValueAttributes
            self.groupDefinitions = groupDefinitions
            self.nextPageToken = nextPageToken
            self.resultsByTime = resultsByTime
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionValueAttributes = "DimensionValueAttributes"
            case groupDefinitions = "GroupDefinitions"
            case nextPageToken = "NextPageToken"
            case resultsByTime = "ResultsByTime"
        }
    }

    public struct GetCostAndUsageWithResourcesRequest: AWSEncodableShape {
        /// Filters Amazon Web Services costs by different dimensions. For example, you can specify SERVICE and LINKED_ACCOUNT and get the costs that are associated with that account's usage of that service. You can nest Expression objects to define any combination of dimension filters. For more information, see Expression.  The GetCostAndUsageWithResources operation requires that you either group by or filter by a ResourceId. It requires the Expression "SERVICE = Amazon Elastic Compute Cloud - Compute" in the filter. Valid values for MatchOptions for Dimensions are EQUALS and CASE_SENSITIVE. Valid values for MatchOptions for CostCategories and Tags are EQUALS, ABSENT, and CASE_SENSITIVE. Default values are EQUALS and CASE_SENSITIVE.
        public let filter: Expression
        /// Sets the Amazon Web Services cost granularity to MONTHLY, DAILY, or HOURLY. If Granularity isn't set, the response object doesn't include the Granularity, MONTHLY, DAILY, or HOURLY.
        public let granularity: Granularity
        /// You can group Amazon Web Services costs using up to two different groups: DIMENSION, TAG, COST_CATEGORY.
        public let groupBy: [GroupDefinition]?
        /// Which metrics are returned in the query. For more information about blended and unblended rates, see Why does the "blended" annotation appear on some line items in my bill?.  Valid values are AmortizedCost, BlendedCost, NetAmortizedCost, NetUnblendedCost, NormalizedUsageAmount, UnblendedCost, and UsageQuantity.   If you return the UsageQuantity metric, the service aggregates all usage numbers without taking the units into account. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hour or GB). To get more meaningful UsageQuantity metrics, filter by UsageType or UsageTypeGroups.    Metrics is required for GetCostAndUsageWithResources requests.
        public let metrics: [String]?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// Sets the start and end dates for retrieving Amazon Web Services costs. The range must be within the last 14 days (the start date cannot be earlier than 14 days ago). The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
        public let timePeriod: DateInterval

        public init(filter: Expression, granularity: Granularity, groupBy: [GroupDefinition]? = nil, metrics: [String]? = nil, nextPageToken: String? = nil, timePeriod: DateInterval) {
            self.filter = filter
            self.granularity = granularity
            self.groupBy = groupBy
            self.metrics = metrics
            self.nextPageToken = nextPageToken
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.filter.validate(name: "\(name).filter")
            try self.groupBy?.forEach {
                try $0.validate(name: "\(name).groupBy[]")
            }
            try self.metrics?.forEach {
                try validate($0, name: "metrics[]", parent: name, max: 1024)
                try validate($0, name: "metrics[]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case granularity = "Granularity"
            case groupBy = "GroupBy"
            case metrics = "Metrics"
            case nextPageToken = "NextPageToken"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetCostAndUsageWithResourcesResponse: AWSDecodableShape {
        /// The attributes that apply to a specific dimension value. For example, if the value is a linked account, the attribute is that account name.
        public let dimensionValueAttributes: [DimensionValuesWithAttributes]?
        /// The groups that are specified by the Filter or GroupBy parameters in the request.
        public let groupDefinitions: [GroupDefinition]?
        /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// The time period that's covered by the results in the response.
        public let resultsByTime: [ResultByTime]?

        public init(dimensionValueAttributes: [DimensionValuesWithAttributes]? = nil, groupDefinitions: [GroupDefinition]? = nil, nextPageToken: String? = nil, resultsByTime: [ResultByTime]? = nil) {
            self.dimensionValueAttributes = dimensionValueAttributes
            self.groupDefinitions = groupDefinitions
            self.nextPageToken = nextPageToken
            self.resultsByTime = resultsByTime
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionValueAttributes = "DimensionValueAttributes"
            case groupDefinitions = "GroupDefinitions"
            case nextPageToken = "NextPageToken"
            case resultsByTime = "ResultsByTime"
        }
    }

    public struct GetCostCategoriesRequest: AWSEncodableShape {
        public let costCategoryName: String?
        public let filter: Expression?
        /// This field is only used when the SortBy value is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with the SortBy value, the request returns 1000 results as the default value for this parameter. For GetCostCategories, MaxResults has an upper quota of 1000.
        public let maxResults: Int?
        /// If the number of objects that are still available for retrieval exceeds the quota, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the NextPageToken from the previous call in your next request.
        public let nextPageToken: String?
        /// The value that you want to search the filter values for. If you don't specify a CostCategoryName, SearchString is used to filter Cost Category names that match the SearchString pattern. If you specify a CostCategoryName, SearchString is used to filter Cost Category values that match the SearchString pattern.
        public let searchString: String?
        /// The value that you sort the data by. The key represents the cost and usage metrics. The following values are supported:    BlendedCost     UnblendedCost     AmortizedCost     NetAmortizedCost     NetUnblendedCost     UsageQuantity     NormalizedUsageAmount    The supported key values for the SortOrder value are ASCENDING and DESCENDING. When you use the SortBy value, the NextPageToken and SearchString key values aren't supported.
        public let sortBy: [SortDefinition]?
        public let timePeriod: DateInterval

        public init(costCategoryName: String? = nil, filter: Expression? = nil, maxResults: Int? = nil, nextPageToken: String? = nil, searchString: String? = nil, sortBy: [SortDefinition]? = nil, timePeriod: DateInterval) {
            self.costCategoryName = costCategoryName
            self.filter = filter
            self.maxResults = maxResults
            self.nextPageToken = nextPageToken
            self.searchString = searchString
            self.sortBy = sortBy
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.validate(self.costCategoryName, name: "costCategoryName", parent: name, max: 50)
            try self.validate(self.costCategoryName, name: "costCategoryName", parent: name, min: 1)
            try self.validate(self.costCategoryName, name: "costCategoryName", parent: name, pattern: "^(?! )[\\p{L}\\p{N}\\p{Z}-_]*(?<! )$")
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.searchString, name: "searchString", parent: name, max: 1024)
            try self.validate(self.searchString, name: "searchString", parent: name, pattern: "^[\\S\\s]*$")
            try self.sortBy?.forEach {
                try $0.validate(name: "\(name).sortBy[]")
            }
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case costCategoryName = "CostCategoryName"
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextPageToken = "NextPageToken"
            case searchString = "SearchString"
            case sortBy = "SortBy"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetCostCategoriesResponse: AWSDecodableShape {
        /// The names of the Cost Categories.
        public let costCategoryNames: [String]?
        /// The Cost Category values. If the CostCategoryName key isn't specified in the request, the CostCategoryValues fields aren't returned.
        public let costCategoryValues: [String]?
        /// If the number of objects that are still available for retrieval exceeds the quota, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.
        public let nextPageToken: String?
        /// The number of objects that are returned.
        public let returnSize: Int
        /// The total number of objects.
        public let totalSize: Int

        public init(costCategoryNames: [String]? = nil, costCategoryValues: [String]? = nil, nextPageToken: String? = nil, returnSize: Int, totalSize: Int) {
            self.costCategoryNames = costCategoryNames
            self.costCategoryValues = costCategoryValues
            self.nextPageToken = nextPageToken
            self.returnSize = returnSize
            self.totalSize = totalSize
        }

        private enum CodingKeys: String, CodingKey {
            case costCategoryNames = "CostCategoryNames"
            case costCategoryValues = "CostCategoryValues"
            case nextPageToken = "NextPageToken"
            case returnSize = "ReturnSize"
            case totalSize = "TotalSize"
        }
    }

    public struct GetCostForecastRequest: AWSEncodableShape {
        /// The filters that you want to use to filter your forecast. The GetCostForecast API supports filtering by the following dimensions:    AZ     INSTANCE_TYPE     LINKED_ACCOUNT     LINKED_ACCOUNT_NAME     OPERATION     PURCHASE_TYPE     REGION     SERVICE     USAGE_TYPE     USAGE_TYPE_GROUP     RECORD_TYPE     OPERATING_SYSTEM     TENANCY     SCOPE     PLATFORM     SUBSCRIPTION_ID     LEGAL_ENTITY_NAME     DEPLOYMENT_OPTION     DATABASE_ENGINE     INSTANCE_TYPE_FAMILY     BILLING_ENTITY     RESERVATION_ID     SAVINGS_PLAN_ARN
        public let filter: Expression?
        /// How granular you want the forecast to be. You can get 3 months of DAILY forecasts or 12 months of MONTHLY forecasts. The GetCostForecast operation supports only DAILY and MONTHLY granularities.
        public let granularity: Granularity
        /// Which metric Cost Explorer uses to create your forecast. For more information about blended and unblended rates, see Why does the "blended" annotation appear on some line items in my bill?.  Valid values for a GetCostForecast call are the following:   AMORTIZED_COST   BLENDED_COST   NET_AMORTIZED_COST   NET_UNBLENDED_COST   UNBLENDED_COST
        public let metric: Metric
        /// Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.
        public let predictionIntervalLevel: Int?
        /// The period of time that you want the forecast to cover. The start date must be equal to or no later than the current date to avoid a validation error.
        public let timePeriod: DateInterval

        public init(filter: Expression? = nil, granularity: Granularity, metric: Metric, predictionIntervalLevel: Int? = nil, timePeriod: DateInterval) {
            self.filter = filter
            self.granularity = granularity
            self.metric = metric
            self.predictionIntervalLevel = predictionIntervalLevel
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.predictionIntervalLevel, name: "predictionIntervalLevel", parent: name, max: 99)
            try self.validate(self.predictionIntervalLevel, name: "predictionIntervalLevel", parent: name, min: 51)
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case granularity = "Granularity"
            case metric = "Metric"
            case predictionIntervalLevel = "PredictionIntervalLevel"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetCostForecastResponse: AWSDecodableShape {
        /// The forecasts for your query, in order. For DAILY forecasts, this is a list of days. For MONTHLY forecasts, this is a list of months.
        public let forecastResultsByTime: [ForecastResult]?
        /// How much you are forecasted to spend over the forecast period, in USD.
        public let total: MetricValue?

        public init(forecastResultsByTime: [ForecastResult]? = nil, total: MetricValue? = nil) {
            self.forecastResultsByTime = forecastResultsByTime
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case forecastResultsByTime = "ForecastResultsByTime"
            case total = "Total"
        }
    }

    public struct GetDimensionValuesRequest: AWSEncodableShape {
        /// The context for the call to GetDimensionValues. This can be RESERVATIONS or COST_AND_USAGE. The default value is COST_AND_USAGE. If the context is set to RESERVATIONS, the resulting dimension values can be used in the GetReservationUtilization operation. If the context is set to COST_AND_USAGE, the resulting dimension values can be used in the GetCostAndUsage operation. If you set the context to COST_AND_USAGE, you can use the following dimensions for searching:   AZ - The Availability Zone. An example is us-east-1a.   BILLING_ENTITY - The Amazon Web Services seller that your account is with. Possible values are the following: - Amazon Web Services(Amazon Web Services): The entity that sells Amazon Web Services. - AISPL (Amazon Internet Services Pvt. Ltd.): The local Indian entity that's an acting reseller for Amazon Web Services in India. - Amazon Web Services Marketplace: The entity that supports the sale of solutions that are built on Amazon Web Services by third-party software providers.   CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.   DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are SingleAZ and MultiAZ.   DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.   INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.   INSTANCE_TYPE_FAMILY - A family of instance types optimized to fit different use cases. Examples are Compute Optimized (for example, C4, C5, C6g, and C7g), Memory Optimization (for example, R4, R5n, R5b, and R6g).   INVOICING_ENTITY - The name of the entity that issues the Amazon Web Services invoice.   LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.   LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.   OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.   OPERATION - The action performed. Examples include RunInstance and CreateBucket.   PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.   PURCHASE_TYPE - The reservation type of the purchase that this usage is related to. Examples include On-Demand Instances and Standard Reserved Instances.   RESERVATION_ID - The unique identifier for an Amazon Web Services Reservation Instance.   SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.   SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute).   SERVICE - The Amazon Web Services service such as Amazon DynamoDB.   TENANCY - The tenancy of a resource. Examples are shared or dedicated.   USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the GetDimensionValues operation includes a unit attribute. Examples include GB and Hrs.   USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.   REGION - The Amazon Web Services Region.   RECORD_TYPE - The different types of charges such as Reserved Instance (RI) fees, usage costs, tax refunds, and credits.   RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.   If you set the context to RESERVATIONS, you can use the following dimensions for searching:   AZ - The Availability Zone. An example is us-east-1a.   CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.   DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are SingleAZ and MultiAZ.   INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.   LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.   PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.   REGION - The Amazon Web Services Region.   SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.   TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).   TENANCY - The tenancy of a resource. Examples are shared or dedicated.   If you set the context to SAVINGS_PLANS, you can use the following dimensions for searching:   SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)   PAYMENT_OPTION - The payment option for the given Savings Plans (for example, All Upfront)   REGION - The Amazon Web Services Region.   INSTANCE_TYPE_FAMILY - The family of instances (For example, m5)   LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.   SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.
        public let context: Context?
        /// The name of the dimension. Each Dimension is available for a different Context. For more information, see Context. LINK_ACCOUNT_NAME and SERVICE_CODE can only be used in CostCategoryRule.
        public let dimension: Dimension
        public let filter: Expression?
        /// This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter. For GetDimensionValues, MaxResults has an upper limit of 1000.
        public let maxResults: Int?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// The value that you want to search the filter values for.
        public let searchString: String?
        /// The value that you want to sort the data by. The key represents cost and usage metrics. The following values are supported:    BlendedCost     UnblendedCost     AmortizedCost     NetAmortizedCost     NetUnblendedCost     UsageQuantity     NormalizedUsageAmount    The supported values for the SortOrder key are ASCENDING or DESCENDING. When you specify a SortBy paramater, the context must be COST_AND_USAGE. Further, when using SortBy, NextPageToken and SearchString aren't supported.
        public let sortBy: [SortDefinition]?
        /// The start date and end date for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
        public let timePeriod: DateInterval

        public init(context: Context? = nil, dimension: Dimension, filter: Expression? = nil, maxResults: Int? = nil, nextPageToken: String? = nil, searchString: String? = nil, sortBy: [SortDefinition]? = nil, timePeriod: DateInterval) {
            self.context = context
            self.dimension = dimension
            self.filter = filter
            self.maxResults = maxResults
            self.nextPageToken = nextPageToken
            self.searchString = searchString
            self.sortBy = sortBy
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.searchString, name: "searchString", parent: name, max: 1024)
            try self.validate(self.searchString, name: "searchString", parent: name, pattern: "^[\\S\\s]*$")
            try self.sortBy?.forEach {
                try $0.validate(name: "\(name).sortBy[]")
            }
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case context = "Context"
            case dimension = "Dimension"
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextPageToken = "NextPageToken"
            case searchString = "SearchString"
            case sortBy = "SortBy"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetDimensionValuesResponse: AWSDecodableShape {
        /// The filters that you used to filter your request. Some dimensions are available only for a specific context. If you set the context to COST_AND_USAGE, you can use the following dimensions for searching:   AZ - The Availability Zone. An example is us-east-1a.   DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.   INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.   LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.   LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.   OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.   OPERATION - The action performed. Examples include RunInstance and CreateBucket.   PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.   PURCHASE_TYPE - The reservation type of the purchase to which this usage is related. Examples include On-Demand Instances and Standard Reserved Instances.   SERVICE - The Amazon Web Services service such as Amazon DynamoDB.   USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the GetDimensionValues operation includes a unit attribute. Examples include GB and Hrs.   USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.   RECORD_TYPE - The different types of charges such as RI fees, usage costs, tax refunds, and credits.   RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service. You can opt-in by enabling Hourly and Resource Level Data in Cost Management Console preferences.   If you set the context to RESERVATIONS, you can use the following dimensions for searching:   AZ - The Availability Zone. An example is us-east-1a.   CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.   DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are SingleAZ and MultiAZ.   INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.   LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.   PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.   REGION - The Amazon Web Services Region.   SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.   TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).   TENANCY - The tenancy of a resource. Examples are shared or dedicated.   If you set the context to SAVINGS_PLANS, you can use the following dimensions for searching:   SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)   PAYMENT_OPTION - Payment option for the given Savings Plans (for example, All Upfront)   REGION - The Amazon Web Services Region.   INSTANCE_TYPE_FAMILY - The family of instances (For example, m5)   LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.   SAVINGS_PLAN_ARN - The unique identifier for your Savings Plan
        public let dimensionValues: [DimensionValuesWithAttributes]
        /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// The number of results that Amazon Web Services returned at one time.
        public let returnSize: Int
        /// The total number of search results.
        public let totalSize: Int

        public init(dimensionValues: [DimensionValuesWithAttributes], nextPageToken: String? = nil, returnSize: Int, totalSize: Int) {
            self.dimensionValues = dimensionValues
            self.nextPageToken = nextPageToken
            self.returnSize = returnSize
            self.totalSize = totalSize
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionValues = "DimensionValues"
            case nextPageToken = "NextPageToken"
            case returnSize = "ReturnSize"
            case totalSize = "TotalSize"
        }
    }

    public struct GetReservationCoverageRequest: AWSEncodableShape {
        /// Filters utilization data by dimensions. You can filter by the following dimensions:   AZ   CACHE_ENGINE   DATABASE_ENGINE   DEPLOYMENT_OPTION   INSTANCE_TYPE   LINKED_ACCOUNT   OPERATING_SYSTEM   PLATFORM   REGION   SERVICE   TAG   TENANCY    GetReservationCoverage uses the same Expression object as the other operations, but only AND is supported among each dimension. You can nest only one level deep. If there are multiple values for a dimension, they are OR'd together. If you don't provide a SERVICE filter, Cost Explorer defaults to EC2. Cost category is also supported.
        public let filter: Expression?
        /// The granularity of the Amazon Web Services cost data for the reservation. Valid values are MONTHLY and DAILY. If GroupBy is set, Granularity can't be set. If Granularity isn't set, the response object doesn't include Granularity, either MONTHLY or DAILY. The GetReservationCoverage operation supports only DAILY and MONTHLY granularities.
        public let granularity: Granularity?
        /// You can group the data by the following attributes:   AZ   CACHE_ENGINE   DATABASE_ENGINE   DEPLOYMENT_OPTION   INSTANCE_TYPE   INVOICING_ENTITY   LINKED_ACCOUNT   OPERATING_SYSTEM   PLATFORM   REGION   TENANCY
        public let groupBy: [GroupDefinition]?
        /// The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.
        public let maxResults: Int?
        /// The measurement that you want your reservation coverage reported in. Valid values are Hour, Unit, and Cost. You can use multiple values in a request.
        public let metrics: [String]?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// The value by which you want to sort the data. The following values are supported for Key:    OnDemandCost     CoverageHoursPercentage     OnDemandHours     ReservedHours     TotalRunningHours     CoverageNormalizedUnitsPercentage     OnDemandNormalizedUnits     ReservedNormalizedUnits     TotalRunningNormalizedUnits     Time    Supported values for SortOrder are ASCENDING or DESCENDING.
        public let sortBy: SortDefinition?
        /// The start and end dates of the period that you want to retrieve data about reservation coverage for. You can retrieve data for a maximum of 13 months: the last 12 months and the current month. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
        public let timePeriod: DateInterval

        public init(filter: Expression? = nil, granularity: Granularity? = nil, groupBy: [GroupDefinition]? = nil, maxResults: Int? = nil, metrics: [String]? = nil, nextPageToken: String? = nil, sortBy: SortDefinition? = nil, timePeriod: DateInterval) {
            self.filter = filter
            self.granularity = granularity
            self.groupBy = groupBy
            self.maxResults = maxResults
            self.metrics = metrics
            self.nextPageToken = nextPageToken
            self.sortBy = sortBy
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.groupBy?.forEach {
                try $0.validate(name: "\(name).groupBy[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.metrics?.forEach {
                try validate($0, name: "metrics[]", parent: name, max: 1024)
                try validate($0, name: "metrics[]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.sortBy?.validate(name: "\(name).sortBy")
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case granularity = "Granularity"
            case groupBy = "GroupBy"
            case maxResults = "MaxResults"
            case metrics = "Metrics"
            case nextPageToken = "NextPageToken"
            case sortBy = "SortBy"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetReservationCoverageResponse: AWSDecodableShape {
        /// The amount of time that your reservations covered.
        public let coveragesByTime: [CoverageByTime]
        /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// The total amount of instance usage that a reservation covered.
        public let total: Coverage?

        public init(coveragesByTime: [CoverageByTime], nextPageToken: String? = nil, total: Coverage? = nil) {
            self.coveragesByTime = coveragesByTime
            self.nextPageToken = nextPageToken
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case coveragesByTime = "CoveragesByTime"
            case nextPageToken = "NextPageToken"
            case total = "Total"
        }
    }

    public struct GetReservationPurchaseRecommendationRequest: AWSEncodableShape {
        /// The account ID that's associated with the recommendation.
        public let accountId: String?
        /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
        public let accountScope: AccountScope?
        public let filter: Expression?
        /// The number of previous days that you want Amazon Web Services to consider when it calculates your recommendations.
        public let lookbackPeriodInDays: LookbackPeriodInDays?
        /// The pagination token that indicates the next set of results that you want to retrieve.
        public let nextPageToken: String?
        /// The number of recommendations that you want returned in a single response object.
        public let pageSize: Int?
        /// The reservation purchase option that you want recommendations for.
        public let paymentOption: PaymentOption?
        /// The specific service that you want recommendations for.
        public let service: String
        /// The hardware specifications for the service instances that you want recommendations for, such as standard or convertible Amazon EC2 instances.
        public let serviceSpecification: ServiceSpecification?
        /// The reservation term that you want recommendations for.
        public let termInYears: TermInYears?

        public init(accountId: String? = nil, accountScope: AccountScope? = nil, filter: Expression? = nil, lookbackPeriodInDays: LookbackPeriodInDays? = nil, nextPageToken: String? = nil, pageSize: Int? = nil, paymentOption: PaymentOption? = nil, service: String, serviceSpecification: ServiceSpecification? = nil, termInYears: TermInYears? = nil) {
            self.accountId = accountId
            self.accountScope = accountScope
            self.filter = filter
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.nextPageToken = nextPageToken
            self.pageSize = pageSize
            self.paymentOption = paymentOption
            self.service = service
            self.serviceSpecification = serviceSpecification
            self.termInYears = termInYears
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 1024)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\S\\s]*$")
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.service, name: "service", parent: name, max: 1024)
            try self.validate(self.service, name: "service", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case accountScope = "AccountScope"
            case filter = "Filter"
            case lookbackPeriodInDays = "LookbackPeriodInDays"
            case nextPageToken = "NextPageToken"
            case pageSize = "PageSize"
            case paymentOption = "PaymentOption"
            case service = "Service"
            case serviceSpecification = "ServiceSpecification"
            case termInYears = "TermInYears"
        }
    }

    public struct GetReservationPurchaseRecommendationResponse: AWSDecodableShape {
        /// Information about this specific recommendation call, such as the time stamp for when Cost Explorer generated this recommendation.
        public let metadata: ReservationPurchaseRecommendationMetadata?
        /// The pagination token for the next set of retrievable results.
        public let nextPageToken: String?
        /// Recommendations for reservations to purchase.
        public let recommendations: [ReservationPurchaseRecommendation]?

        public init(metadata: ReservationPurchaseRecommendationMetadata? = nil, nextPageToken: String? = nil, recommendations: [ReservationPurchaseRecommendation]? = nil) {
            self.metadata = metadata
            self.nextPageToken = nextPageToken
            self.recommendations = recommendations
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
            case nextPageToken = "NextPageToken"
            case recommendations = "Recommendations"
        }
    }

    public struct GetReservationUtilizationRequest: AWSEncodableShape {
        /// Filters utilization data by dimensions. You can filter by the following dimensions:   AZ   CACHE_ENGINE   DEPLOYMENT_OPTION   INSTANCE_TYPE   LINKED_ACCOUNT   OPERATING_SYSTEM   PLATFORM   REGION   SERVICE   SCOPE   TENANCY    GetReservationUtilization uses the same Expression object as the other operations, but only AND is supported among each dimension, and nesting is supported up to only one level deep. If there are multiple values for a dimension, they are OR'd together.
        public let filter: Expression?
        /// If GroupBy is set, Granularity can't be set. If Granularity isn't set, the response object doesn't include Granularity, either MONTHLY or DAILY. If both GroupBy and Granularity aren't set, GetReservationUtilization defaults to DAILY. The GetReservationUtilization operation supports only DAILY and MONTHLY granularities.
        public let granularity: Granularity?
        /// Groups only by SUBSCRIPTION_ID. Metadata is included.
        public let groupBy: [GroupDefinition]?
        /// The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.
        public let maxResults: Int?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// The value that you want to sort the data by. The following values are supported for Key:    UtilizationPercentage     UtilizationPercentageInUnits     PurchasedHours     PurchasedUnits     TotalActualHours     TotalActualUnits     UnusedHours     UnusedUnits     OnDemandCostOfRIHoursUsed     NetRISavings     TotalPotentialRISavings     AmortizedUpfrontFee     AmortizedRecurringFee     TotalAmortizedFee     RICostForUnusedHours     RealizedSavings     UnrealizedSavings    The supported values for SortOrder are ASCENDING and DESCENDING.
        public let sortBy: SortDefinition?
        /// Sets the start and end dates for retrieving Reserved Instance (RI) utilization. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
        public let timePeriod: DateInterval

        public init(filter: Expression? = nil, granularity: Granularity? = nil, groupBy: [GroupDefinition]? = nil, maxResults: Int? = nil, nextPageToken: String? = nil, sortBy: SortDefinition? = nil, timePeriod: DateInterval) {
            self.filter = filter
            self.granularity = granularity
            self.groupBy = groupBy
            self.maxResults = maxResults
            self.nextPageToken = nextPageToken
            self.sortBy = sortBy
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.groupBy?.forEach {
                try $0.validate(name: "\(name).groupBy[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.sortBy?.validate(name: "\(name).sortBy")
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case granularity = "Granularity"
            case groupBy = "GroupBy"
            case maxResults = "MaxResults"
            case nextPageToken = "NextPageToken"
            case sortBy = "SortBy"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetReservationUtilizationResponse: AWSDecodableShape {
        /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// The total amount of time that you used your Reserved Instances (RIs).
        public let total: ReservationAggregates?
        /// The amount of time that you used your Reserved Instances (RIs).
        public let utilizationsByTime: [UtilizationByTime]

        public init(nextPageToken: String? = nil, total: ReservationAggregates? = nil, utilizationsByTime: [UtilizationByTime]) {
            self.nextPageToken = nextPageToken
            self.total = total
            self.utilizationsByTime = utilizationsByTime
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case total = "Total"
            case utilizationsByTime = "UtilizationsByTime"
        }
    }

    public struct GetRightsizingRecommendationRequest: AWSEncodableShape {
        /// You can use Configuration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither.
        public let configuration: RightsizingRecommendationConfiguration?
        public let filter: Expression?
        /// The pagination token that indicates the next set of results that you want to retrieve.
        public let nextPageToken: String?
        /// The number of recommendations that you want returned in a single response object.
        public let pageSize: Int?
        /// The specific service that you want recommendations for. The only valid value for GetRightsizingRecommendation is "AmazonEC2".
        public let service: String

        public init(configuration: RightsizingRecommendationConfiguration? = nil, filter: Expression? = nil, nextPageToken: String? = nil, pageSize: Int? = nil, service: String) {
            self.configuration = configuration
            self.filter = filter
            self.nextPageToken = nextPageToken
            self.pageSize = pageSize
            self.service = service
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.service, name: "service", parent: name, max: 1024)
            try self.validate(self.service, name: "service", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case filter = "Filter"
            case nextPageToken = "NextPageToken"
            case pageSize = "PageSize"
            case service = "Service"
        }
    }

    public struct GetRightsizingRecommendationResponse: AWSDecodableShape {
        /// You can use Configuration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither.
        public let configuration: RightsizingRecommendationConfiguration?
        /// Information regarding this specific recommendation set.
        public let metadata: RightsizingRecommendationMetadata?
        /// The token to retrieve the next set of results.
        public let nextPageToken: String?
        /// Recommendations to rightsize resources.
        public let rightsizingRecommendations: [RightsizingRecommendation]?
        /// Summary of this recommendation set.
        public let summary: RightsizingRecommendationSummary?

        public init(configuration: RightsizingRecommendationConfiguration? = nil, metadata: RightsizingRecommendationMetadata? = nil, nextPageToken: String? = nil, rightsizingRecommendations: [RightsizingRecommendation]? = nil, summary: RightsizingRecommendationSummary? = nil) {
            self.configuration = configuration
            self.metadata = metadata
            self.nextPageToken = nextPageToken
            self.rightsizingRecommendations = rightsizingRecommendations
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case metadata = "Metadata"
            case nextPageToken = "NextPageToken"
            case rightsizingRecommendations = "RightsizingRecommendations"
            case summary = "Summary"
        }
    }

    public struct GetSavingsPlansCoverageRequest: AWSEncodableShape {
        /// Filters Savings Plans coverage data by dimensions. You can filter data for Savings Plans usage with the following dimensions:    LINKED_ACCOUNT     REGION     SERVICE     INSTANCE_FAMILY     GetSavingsPlansCoverage uses the same Expression object as the other operations, but only AND is supported among each dimension. If there are multiple values for a dimension, they are OR'd together. Cost category is also supported.
        public let filter: Expression?
        /// The granularity of the Amazon Web Services cost data for your Savings Plans. Granularity can't be set if GroupBy is set. The GetSavingsPlansCoverage operation supports only DAILY and MONTHLY granularities.
        public let granularity: Granularity?
        /// You can group the data using the attributes INSTANCE_FAMILY, REGION, or SERVICE.
        public let groupBy: [GroupDefinition]?
        /// The number of items to be returned in a response. The default is 20, with a minimum value of 1.
        public let maxResults: Int?
        /// The measurement that you want your Savings Plans coverage reported in. The only valid value is SpendCoveredBySavingsPlans.
        public let metrics: [String]?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextToken: String?
        /// The value that you want to sort the data by. The following values are supported for Key:    SpendCoveredBySavingsPlan     OnDemandCost     CoveragePercentage     TotalCost     InstanceFamily     Region     Service    The supported values for SortOrder are ASCENDING and DESCENDING.
        public let sortBy: SortDefinition?
        /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
        public let timePeriod: DateInterval

        public init(filter: Expression? = nil, granularity: Granularity? = nil, groupBy: [GroupDefinition]? = nil, maxResults: Int? = nil, metrics: [String]? = nil, nextToken: String? = nil, sortBy: SortDefinition? = nil, timePeriod: DateInterval) {
            self.filter = filter
            self.granularity = granularity
            self.groupBy = groupBy
            self.maxResults = maxResults
            self.metrics = metrics
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.groupBy?.forEach {
                try $0.validate(name: "\(name).groupBy[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.metrics?.forEach {
                try validate($0, name: "metrics[]", parent: name, max: 1024)
                try validate($0, name: "metrics[]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.sortBy?.validate(name: "\(name).sortBy")
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case granularity = "Granularity"
            case groupBy = "GroupBy"
            case maxResults = "MaxResults"
            case metrics = "Metrics"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetSavingsPlansCoverageResponse: AWSDecodableShape {
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextToken: String?
        /// The amount of spend that your Savings Plans covered.
        public let savingsPlansCoverages: [SavingsPlansCoverage]

        public init(nextToken: String? = nil, savingsPlansCoverages: [SavingsPlansCoverage]) {
            self.nextToken = nextToken
            self.savingsPlansCoverages = savingsPlansCoverages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case savingsPlansCoverages = "SavingsPlansCoverages"
        }
    }

    public struct GetSavingsPlansPurchaseRecommendationRequest: AWSEncodableShape {
        /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
        public let accountScope: AccountScope?
        /// You can filter your recommendations by Account ID with the LINKED_ACCOUNT dimension. To filter your recommendations by Account ID, specify Key as LINKED_ACCOUNT and Value as the comma-separated Acount ID(s) that you want to see Savings Plans purchase recommendations for. For GetSavingsPlansPurchaseRecommendation, the Filter doesn't include CostCategories or Tags. It only includes Dimensions. With Dimensions, Key must be LINKED_ACCOUNT and Value can be a single Account ID or multiple comma-separated Account IDs that you want to see Savings Plans Purchase Recommendations for. AND and OR operators are not supported.
        public let filter: Expression?
        /// The lookback period that's used to generate the recommendation.
        public let lookbackPeriodInDays: LookbackPeriodInDays
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// The number of recommendations that you want returned in a single response object.
        public let pageSize: Int?
        /// The payment option that's used to generate these recommendations.
        public let paymentOption: PaymentOption
        /// The Savings Plans recommendation type that's requested.
        public let savingsPlansType: SupportedSavingsPlansType
        /// The savings plan recommendation term that's used to generate these recommendations.
        public let termInYears: TermInYears

        public init(accountScope: AccountScope? = nil, filter: Expression? = nil, lookbackPeriodInDays: LookbackPeriodInDays, nextPageToken: String? = nil, pageSize: Int? = nil, paymentOption: PaymentOption, savingsPlansType: SupportedSavingsPlansType, termInYears: TermInYears) {
            self.accountScope = accountScope
            self.filter = filter
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.nextPageToken = nextPageToken
            self.pageSize = pageSize
            self.paymentOption = paymentOption
            self.savingsPlansType = savingsPlansType
            self.termInYears = termInYears
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "AccountScope"
            case filter = "Filter"
            case lookbackPeriodInDays = "LookbackPeriodInDays"
            case nextPageToken = "NextPageToken"
            case pageSize = "PageSize"
            case paymentOption = "PaymentOption"
            case savingsPlansType = "SavingsPlansType"
            case termInYears = "TermInYears"
        }
    }

    public struct GetSavingsPlansPurchaseRecommendationResponse: AWSDecodableShape {
        /// Information that regards this specific recommendation set.
        public let metadata: SavingsPlansPurchaseRecommendationMetadata?
        /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// Contains your request parameters, Savings Plan Recommendations Summary, and Details.
        public let savingsPlansPurchaseRecommendation: SavingsPlansPurchaseRecommendation?

        public init(metadata: SavingsPlansPurchaseRecommendationMetadata? = nil, nextPageToken: String? = nil, savingsPlansPurchaseRecommendation: SavingsPlansPurchaseRecommendation? = nil) {
            self.metadata = metadata
            self.nextPageToken = nextPageToken
            self.savingsPlansPurchaseRecommendation = savingsPlansPurchaseRecommendation
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
            case nextPageToken = "NextPageToken"
            case savingsPlansPurchaseRecommendation = "SavingsPlansPurchaseRecommendation"
        }
    }

    public struct GetSavingsPlansUtilizationDetailsRequest: AWSEncodableShape {
        /// The data type.
        public let dataType: [SavingsPlansDataType]?
        /// Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:    LINKED_ACCOUNT     SAVINGS_PLAN_ARN     REGION     PAYMENT_OPTION     INSTANCE_TYPE_FAMILY     GetSavingsPlansUtilizationDetails uses the same Expression object as the other operations, but only AND is supported among each dimension.
        public let filter: Expression?
        /// The number of items to be returned in a response. The default is 20, with a minimum value of 1.
        public let maxResults: Int?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextToken: String?
        /// The value that you want to sort the data by. The following values are supported for Key:    UtilizationPercentage     TotalCommitment     UsedCommitment     UnusedCommitment     NetSavings     AmortizedRecurringCommitment     AmortizedUpfrontCommitment    The supported values for SortOrder are ASCENDING and DESCENDING.
        public let sortBy: SortDefinition?
        /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
        public let timePeriod: DateInterval

        public init(dataType: [SavingsPlansDataType]? = nil, filter: Expression? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortDefinition? = nil, timePeriod: DateInterval) {
            self.dataType = dataType
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.sortBy?.validate(name: "\(name).sortBy")
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "DataType"
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetSavingsPlansUtilizationDetailsResponse: AWSDecodableShape {
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextToken: String?
        /// Retrieves a single daily or monthly Savings Plans utilization rate and details for your account.
        public let savingsPlansUtilizationDetails: [SavingsPlansUtilizationDetail]
        public let timePeriod: DateInterval
        /// The total Savings Plans utilization, regardless of time period.
        public let total: SavingsPlansUtilizationAggregates?

        public init(nextToken: String? = nil, savingsPlansUtilizationDetails: [SavingsPlansUtilizationDetail], timePeriod: DateInterval, total: SavingsPlansUtilizationAggregates? = nil) {
            self.nextToken = nextToken
            self.savingsPlansUtilizationDetails = savingsPlansUtilizationDetails
            self.timePeriod = timePeriod
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case savingsPlansUtilizationDetails = "SavingsPlansUtilizationDetails"
            case timePeriod = "TimePeriod"
            case total = "Total"
        }
    }

    public struct GetSavingsPlansUtilizationRequest: AWSEncodableShape {
        /// Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:    LINKED_ACCOUNT     SAVINGS_PLAN_ARN     SAVINGS_PLANS_TYPE     REGION     PAYMENT_OPTION     INSTANCE_TYPE_FAMILY     GetSavingsPlansUtilization uses the same Expression object as the other operations, but only AND is supported among each dimension.
        public let filter: Expression?
        /// The granularity of the Amazon Web Services utillization data for your Savings Plans. The GetSavingsPlansUtilization operation supports only DAILY and MONTHLY granularities.
        public let granularity: Granularity?
        /// The value that you want to sort the data by. The following values are supported for Key:    UtilizationPercentage     TotalCommitment     UsedCommitment     UnusedCommitment     NetSavings    The supported values for SortOrder are ASCENDING and DESCENDING.
        public let sortBy: SortDefinition?
        /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
        public let timePeriod: DateInterval

        public init(filter: Expression? = nil, granularity: Granularity? = nil, sortBy: SortDefinition? = nil, timePeriod: DateInterval) {
            self.filter = filter
            self.granularity = granularity
            self.sortBy = sortBy
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.sortBy?.validate(name: "\(name).sortBy")
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case granularity = "Granularity"
            case sortBy = "SortBy"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetSavingsPlansUtilizationResponse: AWSDecodableShape {
        /// The amount of cost/commitment that you used your Savings Plans. You can use it to specify date ranges.
        public let savingsPlansUtilizationsByTime: [SavingsPlansUtilizationByTime]?
        /// The total amount of cost/commitment that you used your Savings Plans, regardless of date ranges.
        public let total: SavingsPlansUtilizationAggregates

        public init(savingsPlansUtilizationsByTime: [SavingsPlansUtilizationByTime]? = nil, total: SavingsPlansUtilizationAggregates) {
            self.savingsPlansUtilizationsByTime = savingsPlansUtilizationsByTime
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case savingsPlansUtilizationsByTime = "SavingsPlansUtilizationsByTime"
            case total = "Total"
        }
    }

    public struct GetTagsRequest: AWSEncodableShape {
        public let filter: Expression?
        /// This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter. For GetTags, MaxResults has an upper quota of 1000.
        public let maxResults: Int?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// The value that you want to search for.
        public let searchString: String?
        /// The value that you want to sort the data by. The key represents cost and usage metrics. The following values are supported:    BlendedCost     UnblendedCost     AmortizedCost     NetAmortizedCost     NetUnblendedCost     UsageQuantity     NormalizedUsageAmount    The supported values for SortOrder are ASCENDING and DESCENDING. When you use SortBy, NextPageToken and SearchString aren't supported.
        public let sortBy: [SortDefinition]?
        /// The key of the tag that you want to return values for.
        public let tagKey: String?
        /// The start and end dates for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
        public let timePeriod: DateInterval

        public init(filter: Expression? = nil, maxResults: Int? = nil, nextPageToken: String? = nil, searchString: String? = nil, sortBy: [SortDefinition]? = nil, tagKey: String? = nil, timePeriod: DateInterval) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextPageToken = nextPageToken
            self.searchString = searchString
            self.sortBy = sortBy
            self.tagKey = tagKey
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.searchString, name: "searchString", parent: name, max: 1024)
            try self.validate(self.searchString, name: "searchString", parent: name, pattern: "^[\\S\\s]*$")
            try self.sortBy?.forEach {
                try $0.validate(name: "\(name).sortBy[]")
            }
            try self.validate(self.tagKey, name: "tagKey", parent: name, max: 1024)
            try self.validate(self.tagKey, name: "tagKey", parent: name, pattern: "^[\\S\\s]*$")
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextPageToken = "NextPageToken"
            case searchString = "SearchString"
            case sortBy = "SortBy"
            case tagKey = "TagKey"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetTagsResponse: AWSDecodableShape {
        /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?
        /// The number of query results that Amazon Web Services returns at a time.
        public let returnSize: Int
        /// The tags that match your request.
        public let tags: [String]
        /// The total number of query results.
        public let totalSize: Int

        public init(nextPageToken: String? = nil, returnSize: Int, tags: [String], totalSize: Int) {
            self.nextPageToken = nextPageToken
            self.returnSize = returnSize
            self.tags = tags
            self.totalSize = totalSize
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case returnSize = "ReturnSize"
            case tags = "Tags"
            case totalSize = "TotalSize"
        }
    }

    public struct GetUsageForecastRequest: AWSEncodableShape {
        /// The filters that you want to use to filter your forecast. The GetUsageForecast API supports filtering by the following dimensions:    AZ     INSTANCE_TYPE     LINKED_ACCOUNT     LINKED_ACCOUNT_NAME     OPERATION     PURCHASE_TYPE     REGION     SERVICE     USAGE_TYPE     USAGE_TYPE_GROUP     RECORD_TYPE     OPERATING_SYSTEM     TENANCY     SCOPE     PLATFORM     SUBSCRIPTION_ID     LEGAL_ENTITY_NAME     DEPLOYMENT_OPTION     DATABASE_ENGINE     INSTANCE_TYPE_FAMILY     BILLING_ENTITY     RESERVATION_ID     SAVINGS_PLAN_ARN
        public let filter: Expression?
        /// How granular you want the forecast to be. You can get 3 months of DAILY forecasts or 12 months of MONTHLY forecasts. The GetUsageForecast operation supports only DAILY and MONTHLY granularities.
        public let granularity: Granularity
        /// Which metric Cost Explorer uses to create your forecast. Valid values for a GetUsageForecast call are the following:   USAGE_QUANTITY   NORMALIZED_USAGE_AMOUNT
        public let metric: Metric
        /// Amazon Web Services Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.
        public let predictionIntervalLevel: Int?
        /// The start and end dates of the period that you want to retrieve usage forecast for. The start date is included in the period, but the end date isn't included in the period. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01. The start date must be equal to or later than the current date to avoid a validation error.
        public let timePeriod: DateInterval

        public init(filter: Expression? = nil, granularity: Granularity, metric: Metric, predictionIntervalLevel: Int? = nil, timePeriod: DateInterval) {
            self.filter = filter
            self.granularity = granularity
            self.metric = metric
            self.predictionIntervalLevel = predictionIntervalLevel
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.predictionIntervalLevel, name: "predictionIntervalLevel", parent: name, max: 99)
            try self.validate(self.predictionIntervalLevel, name: "predictionIntervalLevel", parent: name, min: 51)
            try self.timePeriod.validate(name: "\(name).timePeriod")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case granularity = "Granularity"
            case metric = "Metric"
            case predictionIntervalLevel = "PredictionIntervalLevel"
            case timePeriod = "TimePeriod"
        }
    }

    public struct GetUsageForecastResponse: AWSDecodableShape {
        /// The forecasts for your query, in order. For DAILY forecasts, this is a list of days. For MONTHLY forecasts, this is a list of months.
        public let forecastResultsByTime: [ForecastResult]?
        /// How much you're forecasted to use over the forecast period.
        public let total: MetricValue?

        public init(forecastResultsByTime: [ForecastResult]? = nil, total: MetricValue? = nil) {
            self.forecastResultsByTime = forecastResultsByTime
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case forecastResultsByTime = "ForecastResultsByTime"
            case total = "Total"
        }
    }

    public struct Group: AWSDecodableShape {
        /// The keys that are included in this group.
        public let keys: [String]?
        /// The metrics that are included in this group.
        public let metrics: [String: MetricValue]?

        public init(keys: [String]? = nil, metrics: [String: MetricValue]? = nil) {
            self.keys = keys
            self.metrics = metrics
        }

        private enum CodingKeys: String, CodingKey {
            case keys = "Keys"
            case metrics = "Metrics"
        }
    }

    public struct GroupDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The string that represents a key for a specified group.
        public let key: String?
        /// The string that represents the type of group.
        public let type: GroupDefinitionType?

        public init(key: String? = nil, type: GroupDefinitionType? = nil) {
            self.key = key
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case type = "Type"
        }
    }

    public struct Impact: AWSDecodableShape {
        /// The maximum dollar value that's observed for an anomaly.
        public let maxImpact: Double
        /// The cumulative dollar amount that was actually spent during the anomaly.
        public let totalActualSpend: Double?
        /// The cumulative dollar amount that was expected to be spent during the anomaly. It is calculated using advanced machine learning models to determine the typical spending pattern based on historical data for a customer.
        public let totalExpectedSpend: Double?
        /// The cumulative dollar difference between the total actual spend and total expected spend. It is calculated as TotalActualSpend - TotalExpectedSpend.
        public let totalImpact: Double?
        /// The cumulative percentage difference between the total actual spend and total expected spend. It is calculated as (TotalImpact / TotalExpectedSpend) * 100. When TotalExpectedSpend is zero, this field is omitted. Expected spend can be zero in situations such as when you start to use a service for the first time.
        public let totalImpactPercentage: Double?

        public init(maxImpact: Double, totalActualSpend: Double? = nil, totalExpectedSpend: Double? = nil, totalImpact: Double? = nil, totalImpactPercentage: Double? = nil) {
            self.maxImpact = maxImpact
            self.totalActualSpend = totalActualSpend
            self.totalExpectedSpend = totalExpectedSpend
            self.totalImpact = totalImpact
            self.totalImpactPercentage = totalImpactPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case maxImpact = "MaxImpact"
            case totalActualSpend = "TotalActualSpend"
            case totalExpectedSpend = "TotalExpectedSpend"
            case totalImpact = "TotalImpact"
            case totalImpactPercentage = "TotalImpactPercentage"
        }
    }

    public struct InstanceDetails: AWSDecodableShape {
        /// The Amazon EC2 instances that Amazon Web Services recommends that you purchase.
        public let ec2InstanceDetails: EC2InstanceDetails?
        /// The ElastiCache instances that Amazon Web Services recommends that you purchase.
        public let elastiCacheInstanceDetails: ElastiCacheInstanceDetails?
        /// The Amazon OpenSearch Service instances that Amazon Web Services recommends that you purchase.
        public let esInstanceDetails: ESInstanceDetails?
        /// The Amazon RDS instances that Amazon Web Services recommends that you purchase.
        public let rdsInstanceDetails: RDSInstanceDetails?
        /// The Amazon Redshift instances that Amazon Web Services recommends that you purchase.
        public let redshiftInstanceDetails: RedshiftInstanceDetails?

        public init(ec2InstanceDetails: EC2InstanceDetails? = nil, elastiCacheInstanceDetails: ElastiCacheInstanceDetails? = nil, esInstanceDetails: ESInstanceDetails? = nil, rdsInstanceDetails: RDSInstanceDetails? = nil, redshiftInstanceDetails: RedshiftInstanceDetails? = nil) {
            self.ec2InstanceDetails = ec2InstanceDetails
            self.elastiCacheInstanceDetails = elastiCacheInstanceDetails
            self.esInstanceDetails = esInstanceDetails
            self.rdsInstanceDetails = rdsInstanceDetails
            self.redshiftInstanceDetails = redshiftInstanceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceDetails = "EC2InstanceDetails"
            case elastiCacheInstanceDetails = "ElastiCacheInstanceDetails"
            case esInstanceDetails = "ESInstanceDetails"
            case rdsInstanceDetails = "RDSInstanceDetails"
            case redshiftInstanceDetails = "RedshiftInstanceDetails"
        }
    }

    public struct ListCostAllocationTagsRequest: AWSEncodableShape {
        /// The maximum number of objects that are returned for this request. By default, the request returns 100 results.
        public let maxResults: Int?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextToken: String?
        /// The status of cost allocation tag keys that are returned for this request.
        public let status: CostAllocationTagStatus?
        /// The list of cost allocation tag keys that are returned for this request.
        public let tagKeys: [String]?
        /// The type of CostAllocationTag object that are returned for this request. The AWSGenerated type tags are tags that Amazon Web Services defines and applies to support Amazon Web Services resources for cost allocation purposes. The UserDefined type tags are tags that you define, create, and apply to resources.
        public let type: CostAllocationTagType?

        public init(maxResults: Int? = nil, nextToken: String? = nil, status: CostAllocationTagStatus? = nil, tagKeys: [String]? = nil, type: CostAllocationTagType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
            self.tagKeys = tagKeys
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.tagKeys?.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 1024)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[\\S\\s]*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 100)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case status = "Status"
            case tagKeys = "TagKeys"
            case type = "Type"
        }
    }

    public struct ListCostAllocationTagsResponse: AWSDecodableShape {
        /// A list of cost allocation tags that includes the detailed metadata for each one.
        public let costAllocationTags: [CostAllocationTag]?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextToken: String?

        public init(costAllocationTags: [CostAllocationTag]? = nil, nextToken: String? = nil) {
            self.costAllocationTags = costAllocationTags
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case costAllocationTags = "CostAllocationTags"
            case nextToken = "NextToken"
        }
    }

    public struct ListCostCategoryDefinitionsRequest: AWSEncodableShape {
        /// The date when the Cost Category was effective.
        public let effectiveOn: String?
        /// The number of entries a paginated response contains.
        public let maxResults: Int?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextToken: String?

        public init(effectiveOn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.effectiveOn = effectiveOn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.effectiveOn, name: "effectiveOn", parent: name, max: 25)
            try self.validate(self.effectiveOn, name: "effectiveOn", parent: name, min: 20)
            try self.validate(self.effectiveOn, name: "effectiveOn", parent: name, pattern: "^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(([+-]\\d\\d:\\d\\d)|Z)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case effectiveOn = "EffectiveOn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCostCategoryDefinitionsResponse: AWSDecodableShape {
        /// A reference to a Cost Category that contains enough information to identify the Cost Category.
        public let costCategoryReferences: [CostCategoryReference]?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextToken: String?

        public init(costCategoryReferences: [CostCategoryReference]? = nil, nextToken: String? = nil) {
            self.costCategoryReferences = costCategoryReferences
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case costCategoryReferences = "CostCategoryReferences"
            case nextToken = "NextToken"
        }
    }

    public struct ListSavingsPlansPurchaseRecommendationGenerationRequest: AWSEncodableShape {
        /// The status of the recommendation generation.
        public let generationStatus: GenerationStatus?
        /// The token to retrieve the next set of results.
        public let nextPageToken: String?
        /// The number of recommendations that you want returned in a single response object.
        public let pageSize: Int?
        /// The IDs for each specific recommendation.
        public let recommendationIds: [String]?

        public init(generationStatus: GenerationStatus? = nil, nextPageToken: String? = nil, pageSize: Int? = nil, recommendationIds: [String]? = nil) {
            self.generationStatus = generationStatus
            self.nextPageToken = nextPageToken
            self.pageSize = pageSize
            self.recommendationIds = recommendationIds
        }

        public func validate(name: String) throws {
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, max: 8192)
            try self.validate(self.nextPageToken, name: "nextPageToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.recommendationIds?.forEach {
                try validate($0, name: "recommendationIds[]", parent: name, max: 36)
                try validate($0, name: "recommendationIds[]", parent: name, min: 36)
                try validate($0, name: "recommendationIds[]", parent: name, pattern: "^[\\S\\s]{8}-[\\S\\s]{4}-[\\S\\s]{4}-[\\S\\s]{4}-[\\S\\s]{12}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case generationStatus = "GenerationStatus"
            case nextPageToken = "NextPageToken"
            case pageSize = "PageSize"
            case recommendationIds = "RecommendationIds"
        }
    }

    public struct ListSavingsPlansPurchaseRecommendationGenerationResponse: AWSDecodableShape {
        /// The list of historical recommendation generations.
        public let generationSummaryList: [GenerationSummary]?
        /// The token to retrieve the next set of results.
        public let nextPageToken: String?

        public init(generationSummaryList: [GenerationSummary]? = nil, nextPageToken: String? = nil) {
            self.generationSummaryList = generationSummaryList
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case generationSummaryList = "GenerationSummaryList"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see ResourceTag.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tag key value pairs that are associated with the resource.
        public let resourceTags: [ResourceTag]?

        public init(resourceTags: [ResourceTag]? = nil) {
            self.resourceTags = resourceTags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTags = "ResourceTags"
        }
    }

    public struct MetricValue: AWSDecodableShape {
        /// The actual number that represents the metric.
        public let amount: String?
        /// The unit that the metric is given in.
        public let unit: String?

        public init(amount: String? = nil, unit: String? = nil) {
            self.amount = amount
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "Amount"
            case unit = "Unit"
        }
    }

    public struct ModifyRecommendationDetail: AWSDecodableShape {
        /// Determines whether this instance type is the Amazon Web Services default recommendation.
        public let targetInstances: [TargetInstance]?

        public init(targetInstances: [TargetInstance]? = nil) {
            self.targetInstances = targetInstances
        }

        private enum CodingKeys: String, CodingKey {
            case targetInstances = "TargetInstances"
        }
    }

    public struct NetworkResourceUtilization: AWSDecodableShape {
        /// The network inbound throughput utilization measured in Bytes per second (Bps).
        public let networkInBytesPerSecond: String?
        /// The network outbound throughput utilization measured in Bytes per second (Bps).
        public let networkOutBytesPerSecond: String?
        /// The network inbound packets that are measured in packets per second.
        public let networkPacketsInPerSecond: String?
        /// The network outbound packets that are measured in packets per second.
        public let networkPacketsOutPerSecond: String?

        public init(networkInBytesPerSecond: String? = nil, networkOutBytesPerSecond: String? = nil, networkPacketsInPerSecond: String? = nil, networkPacketsOutPerSecond: String? = nil) {
            self.networkInBytesPerSecond = networkInBytesPerSecond
            self.networkOutBytesPerSecond = networkOutBytesPerSecond
            self.networkPacketsInPerSecond = networkPacketsInPerSecond
            self.networkPacketsOutPerSecond = networkPacketsOutPerSecond
        }

        private enum CodingKeys: String, CodingKey {
            case networkInBytesPerSecond = "NetworkInBytesPerSecond"
            case networkOutBytesPerSecond = "NetworkOutBytesPerSecond"
            case networkPacketsInPerSecond = "NetworkPacketsInPerSecond"
            case networkPacketsOutPerSecond = "NetworkPacketsOutPerSecond"
        }
    }

    public struct ProvideAnomalyFeedbackRequest: AWSEncodableShape {
        /// A cost anomaly ID.
        public let anomalyId: String
        /// Describes whether the cost anomaly was a planned activity or you considered it an anomaly.
        public let feedback: AnomalyFeedbackType

        public init(anomalyId: String, feedback: AnomalyFeedbackType) {
            self.anomalyId = anomalyId
            self.feedback = feedback
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyId, name: "anomalyId", parent: name, max: 1024)
            try self.validate(self.anomalyId, name: "anomalyId", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyId = "AnomalyId"
            case feedback = "Feedback"
        }
    }

    public struct ProvideAnomalyFeedbackResponse: AWSDecodableShape {
        /// The ID of the modified cost anomaly.
        public let anomalyId: String

        public init(anomalyId: String) {
            self.anomalyId = anomalyId
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyId = "AnomalyId"
        }
    }

    public struct RDSInstanceDetails: AWSDecodableShape {
        /// Determines whether the recommendation is for a current-generation instance.
        public let currentGeneration: Bool?
        /// The database edition that the recommended reservation supports.
        public let databaseEdition: String?
        /// The database engine that the recommended reservation supports.
        public let databaseEngine: String?
        /// Determines whether the recommendation is for a reservation in a single Availability Zone or a reservation with a backup in a second Availability Zone.
        public let deploymentOption: String?
        /// The instance family of the recommended reservation.
        public let family: String?
        /// The type of instance that Amazon Web Services recommends.
        public let instanceType: String?
        /// The license model that the recommended reservation supports.
        public let licenseModel: String?
        /// The Amazon Web Services Region of the recommended reservation.
        public let region: String?
        /// Determines whether the recommended reservation is size flexible.
        public let sizeFlexEligible: Bool?

        public init(currentGeneration: Bool? = nil, databaseEdition: String? = nil, databaseEngine: String? = nil, deploymentOption: String? = nil, family: String? = nil, instanceType: String? = nil, licenseModel: String? = nil, region: String? = nil, sizeFlexEligible: Bool? = nil) {
            self.currentGeneration = currentGeneration
            self.databaseEdition = databaseEdition
            self.databaseEngine = databaseEngine
            self.deploymentOption = deploymentOption
            self.family = family
            self.instanceType = instanceType
            self.licenseModel = licenseModel
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }

        private enum CodingKeys: String, CodingKey {
            case currentGeneration = "CurrentGeneration"
            case databaseEdition = "DatabaseEdition"
            case databaseEngine = "DatabaseEngine"
            case deploymentOption = "DeploymentOption"
            case family = "Family"
            case instanceType = "InstanceType"
            case licenseModel = "LicenseModel"
            case region = "Region"
            case sizeFlexEligible = "SizeFlexEligible"
        }
    }

    public struct RedshiftInstanceDetails: AWSDecodableShape {
        /// Determines whether the recommendation is for a current-generation instance.
        public let currentGeneration: Bool?
        /// The instance family of the recommended reservation.
        public let family: String?
        /// The type of node that Amazon Web Services recommends.
        public let nodeType: String?
        /// The Amazon Web Services Region of the recommended reservation.
        public let region: String?
        /// Determines whether the recommended reservation is size flexible.
        public let sizeFlexEligible: Bool?

        public init(currentGeneration: Bool? = nil, family: String? = nil, nodeType: String? = nil, region: String? = nil, sizeFlexEligible: Bool? = nil) {
            self.currentGeneration = currentGeneration
            self.family = family
            self.nodeType = nodeType
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }

        private enum CodingKeys: String, CodingKey {
            case currentGeneration = "CurrentGeneration"
            case family = "Family"
            case nodeType = "NodeType"
            case region = "Region"
            case sizeFlexEligible = "SizeFlexEligible"
        }
    }

    public struct ReservationAggregates: AWSDecodableShape {
        /// The monthly cost of your reservation. It's amortized over the reservation period.
        public let amortizedRecurringFee: String?
        /// The upfront cost of your reservation. It's amortized over the reservation period.
        public let amortizedUpfrontFee: String?
        /// How much you saved due to purchasing and utilizing reservation. Amazon Web Services calculates this by subtracting TotalAmortizedFee from OnDemandCostOfRIHoursUsed.
        public let netRISavings: String?
        /// How much your reservation costs if charged On-Demand rates.
        public let onDemandCostOfRIHoursUsed: String?
        /// How many reservation hours that you purchased.
        public let purchasedHours: String?
        /// The number of Amazon EC2 reservation hours that you purchased. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public let purchasedUnits: String?
        /// The realized savings because of purchasing and using a reservation.
        public let realizedSavings: String?
        /// The cost of unused hours for your reservation.
        public let riCostForUnusedHours: String?
        /// The total number of reservation hours that you used.
        public let totalActualHours: String?
        /// The total number of Amazon EC2 reservation hours that you used. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public let totalActualUnits: String?
        /// The total cost of your reservation. It's amortized over the reservation period.
        public let totalAmortizedFee: String?
        /// How much you might save if you use your entire reservation.
        public let totalPotentialRISavings: String?
        /// The unrealized savings because of purchasing and using a reservation.
        public let unrealizedSavings: String?
        /// The number of reservation hours that you didn't use.
        public let unusedHours: String?
        /// The number of Amazon EC2 reservation hours that you didn't use. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public let unusedUnits: String?
        /// The percentage of reservation time that you used.
        public let utilizationPercentage: String?
        /// The percentage of Amazon EC2 reservation time that you used. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public let utilizationPercentageInUnits: String?

        public init(amortizedRecurringFee: String? = nil, amortizedUpfrontFee: String? = nil, netRISavings: String? = nil, onDemandCostOfRIHoursUsed: String? = nil, purchasedHours: String? = nil, purchasedUnits: String? = nil, realizedSavings: String? = nil, riCostForUnusedHours: String? = nil, totalActualHours: String? = nil, totalActualUnits: String? = nil, totalAmortizedFee: String? = nil, totalPotentialRISavings: String? = nil, unrealizedSavings: String? = nil, unusedHours: String? = nil, unusedUnits: String? = nil, utilizationPercentage: String? = nil, utilizationPercentageInUnits: String? = nil) {
            self.amortizedRecurringFee = amortizedRecurringFee
            self.amortizedUpfrontFee = amortizedUpfrontFee
            self.netRISavings = netRISavings
            self.onDemandCostOfRIHoursUsed = onDemandCostOfRIHoursUsed
            self.purchasedHours = purchasedHours
            self.purchasedUnits = purchasedUnits
            self.realizedSavings = realizedSavings
            self.riCostForUnusedHours = riCostForUnusedHours
            self.totalActualHours = totalActualHours
            self.totalActualUnits = totalActualUnits
            self.totalAmortizedFee = totalAmortizedFee
            self.totalPotentialRISavings = totalPotentialRISavings
            self.unrealizedSavings = unrealizedSavings
            self.unusedHours = unusedHours
            self.unusedUnits = unusedUnits
            self.utilizationPercentage = utilizationPercentage
            self.utilizationPercentageInUnits = utilizationPercentageInUnits
        }

        private enum CodingKeys: String, CodingKey {
            case amortizedRecurringFee = "AmortizedRecurringFee"
            case amortizedUpfrontFee = "AmortizedUpfrontFee"
            case netRISavings = "NetRISavings"
            case onDemandCostOfRIHoursUsed = "OnDemandCostOfRIHoursUsed"
            case purchasedHours = "PurchasedHours"
            case purchasedUnits = "PurchasedUnits"
            case realizedSavings = "RealizedSavings"
            case riCostForUnusedHours = "RICostForUnusedHours"
            case totalActualHours = "TotalActualHours"
            case totalActualUnits = "TotalActualUnits"
            case totalAmortizedFee = "TotalAmortizedFee"
            case totalPotentialRISavings = "TotalPotentialRISavings"
            case unrealizedSavings = "UnrealizedSavings"
            case unusedHours = "UnusedHours"
            case unusedUnits = "UnusedUnits"
            case utilizationPercentage = "UtilizationPercentage"
            case utilizationPercentageInUnits = "UtilizationPercentageInUnits"
        }
    }

    public struct ReservationCoverageGroup: AWSDecodableShape {
        /// The attributes for this group of reservations.
        public let attributes: [String: String]?
        /// How much instance usage this group of reservations covered.
        public let coverage: Coverage?

        public init(attributes: [String: String]? = nil, coverage: Coverage? = nil) {
            self.attributes = attributes
            self.coverage = coverage
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case coverage = "Coverage"
        }
    }

    public struct ReservationPurchaseRecommendation: AWSDecodableShape {
        /// The account scope that Amazon Web Services recommends that you purchase this instance for. For example, you can purchase this reservation for an entire organization in Amazon Web Services Organizations.
        public let accountScope: AccountScope?
        /// How many days of previous usage that Amazon Web Services considers when making this recommendation.
        public let lookbackPeriodInDays: LookbackPeriodInDays?
        /// The payment option for the reservation (for example, AllUpfront or NoUpfront).
        public let paymentOption: PaymentOption?
        /// Details about the recommended purchases.
        public let recommendationDetails: [ReservationPurchaseRecommendationDetail]?
        /// A summary about the recommended purchase.
        public let recommendationSummary: ReservationPurchaseRecommendationSummary?
        /// Hardware specifications for the service that you want recommendations for.
        public let serviceSpecification: ServiceSpecification?
        /// The term of the reservation that you want recommendations for, in years.
        public let termInYears: TermInYears?

        public init(accountScope: AccountScope? = nil, lookbackPeriodInDays: LookbackPeriodInDays? = nil, paymentOption: PaymentOption? = nil, recommendationDetails: [ReservationPurchaseRecommendationDetail]? = nil, recommendationSummary: ReservationPurchaseRecommendationSummary? = nil, serviceSpecification: ServiceSpecification? = nil, termInYears: TermInYears? = nil) {
            self.accountScope = accountScope
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.paymentOption = paymentOption
            self.recommendationDetails = recommendationDetails
            self.recommendationSummary = recommendationSummary
            self.serviceSpecification = serviceSpecification
            self.termInYears = termInYears
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "AccountScope"
            case lookbackPeriodInDays = "LookbackPeriodInDays"
            case paymentOption = "PaymentOption"
            case recommendationDetails = "RecommendationDetails"
            case recommendationSummary = "RecommendationSummary"
            case serviceSpecification = "ServiceSpecification"
            case termInYears = "TermInYears"
        }
    }

    public struct ReservationPurchaseRecommendationDetail: AWSDecodableShape {
        /// The account that this Reserved Instance (RI) recommendation is for.
        public let accountId: String?
        /// The average number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public let averageNormalizedUnitsUsedPerHour: String?
        /// The average number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public let averageNumberOfInstancesUsedPerHour: String?
        /// The average utilization of your instances. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public let averageUtilization: String?
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public let currencyCode: String?
        /// How long Amazon Web Services estimates that it takes for this instance to start saving you money, in months.
        public let estimatedBreakEvenInMonths: String?
        /// How much Amazon Web Services estimates that you spend on On-Demand Instances in a month.
        public let estimatedMonthlyOnDemandCost: String?
        /// How much Amazon Web Services estimates that this specific recommendation might save you in a month.
        public let estimatedMonthlySavingsAmount: String?
        /// How much Amazon Web Services estimates that this specific recommendation might save you in a month, as a percentage of your overall costs.
        public let estimatedMonthlySavingsPercentage: String?
        /// How much Amazon Web Services estimates that you might spend for all usage during the specified historical period if you had a reservation.
        public let estimatedReservationCostForLookbackPeriod: String?
        /// Details about the instances that Amazon Web Services recommends that you purchase.
        public let instanceDetails: InstanceDetails?
        /// The maximum number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public let maximumNormalizedUnitsUsedPerHour: String?
        /// The maximum number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public let maximumNumberOfInstancesUsedPerHour: String?
        /// The minimum number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public let minimumNormalizedUnitsUsedPerHour: String?
        /// The minimum number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public let minimumNumberOfInstancesUsedPerHour: String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public let recommendedNormalizedUnitsToPurchase: String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public let recommendedNumberOfInstancesToPurchase: String?
        /// How much purchasing this instance costs you on a monthly basis.
        public let recurringStandardMonthlyCost: String?
        /// How much purchasing this instance costs you upfront.
        public let upfrontCost: String?

        public init(accountId: String? = nil, averageNormalizedUnitsUsedPerHour: String? = nil, averageNumberOfInstancesUsedPerHour: String? = nil, averageUtilization: String? = nil, currencyCode: String? = nil, estimatedBreakEvenInMonths: String? = nil, estimatedMonthlyOnDemandCost: String? = nil, estimatedMonthlySavingsAmount: String? = nil, estimatedMonthlySavingsPercentage: String? = nil, estimatedReservationCostForLookbackPeriod: String? = nil, instanceDetails: InstanceDetails? = nil, maximumNormalizedUnitsUsedPerHour: String? = nil, maximumNumberOfInstancesUsedPerHour: String? = nil, minimumNormalizedUnitsUsedPerHour: String? = nil, minimumNumberOfInstancesUsedPerHour: String? = nil, recommendedNormalizedUnitsToPurchase: String? = nil, recommendedNumberOfInstancesToPurchase: String? = nil, recurringStandardMonthlyCost: String? = nil, upfrontCost: String? = nil) {
            self.accountId = accountId
            self.averageNormalizedUnitsUsedPerHour = averageNormalizedUnitsUsedPerHour
            self.averageNumberOfInstancesUsedPerHour = averageNumberOfInstancesUsedPerHour
            self.averageUtilization = averageUtilization
            self.currencyCode = currencyCode
            self.estimatedBreakEvenInMonths = estimatedBreakEvenInMonths
            self.estimatedMonthlyOnDemandCost = estimatedMonthlyOnDemandCost
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedMonthlySavingsPercentage = estimatedMonthlySavingsPercentage
            self.estimatedReservationCostForLookbackPeriod = estimatedReservationCostForLookbackPeriod
            self.instanceDetails = instanceDetails
            self.maximumNormalizedUnitsUsedPerHour = maximumNormalizedUnitsUsedPerHour
            self.maximumNumberOfInstancesUsedPerHour = maximumNumberOfInstancesUsedPerHour
            self.minimumNormalizedUnitsUsedPerHour = minimumNormalizedUnitsUsedPerHour
            self.minimumNumberOfInstancesUsedPerHour = minimumNumberOfInstancesUsedPerHour
            self.recommendedNormalizedUnitsToPurchase = recommendedNormalizedUnitsToPurchase
            self.recommendedNumberOfInstancesToPurchase = recommendedNumberOfInstancesToPurchase
            self.recurringStandardMonthlyCost = recurringStandardMonthlyCost
            self.upfrontCost = upfrontCost
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case averageNormalizedUnitsUsedPerHour = "AverageNormalizedUnitsUsedPerHour"
            case averageNumberOfInstancesUsedPerHour = "AverageNumberOfInstancesUsedPerHour"
            case averageUtilization = "AverageUtilization"
            case currencyCode = "CurrencyCode"
            case estimatedBreakEvenInMonths = "EstimatedBreakEvenInMonths"
            case estimatedMonthlyOnDemandCost = "EstimatedMonthlyOnDemandCost"
            case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
            case estimatedMonthlySavingsPercentage = "EstimatedMonthlySavingsPercentage"
            case estimatedReservationCostForLookbackPeriod = "EstimatedReservationCostForLookbackPeriod"
            case instanceDetails = "InstanceDetails"
            case maximumNormalizedUnitsUsedPerHour = "MaximumNormalizedUnitsUsedPerHour"
            case maximumNumberOfInstancesUsedPerHour = "MaximumNumberOfInstancesUsedPerHour"
            case minimumNormalizedUnitsUsedPerHour = "MinimumNormalizedUnitsUsedPerHour"
            case minimumNumberOfInstancesUsedPerHour = "MinimumNumberOfInstancesUsedPerHour"
            case recommendedNormalizedUnitsToPurchase = "RecommendedNormalizedUnitsToPurchase"
            case recommendedNumberOfInstancesToPurchase = "RecommendedNumberOfInstancesToPurchase"
            case recurringStandardMonthlyCost = "RecurringStandardMonthlyCost"
            case upfrontCost = "UpfrontCost"
        }
    }

    public struct ReservationPurchaseRecommendationMetadata: AWSDecodableShape {
        /// The timestamp for when Amazon Web Services made this recommendation.
        public let generationTimestamp: String?
        /// The ID for this specific recommendation.
        public let recommendationId: String?

        public init(generationTimestamp: String? = nil, recommendationId: String? = nil) {
            self.generationTimestamp = generationTimestamp
            self.recommendationId = recommendationId
        }

        private enum CodingKeys: String, CodingKey {
            case generationTimestamp = "GenerationTimestamp"
            case recommendationId = "RecommendationId"
        }
    }

    public struct ReservationPurchaseRecommendationSummary: AWSDecodableShape {
        /// The currency code used for this recommendation.
        public let currencyCode: String?
        /// The total amount that Amazon Web Services estimates that this recommendation could save you in a month.
        public let totalEstimatedMonthlySavingsAmount: String?
        /// The total amount that Amazon Web Services estimates that this recommendation could save you in a month, as a percentage of your costs.
        public let totalEstimatedMonthlySavingsPercentage: String?

        public init(currencyCode: String? = nil, totalEstimatedMonthlySavingsAmount: String? = nil, totalEstimatedMonthlySavingsPercentage: String? = nil) {
            self.currencyCode = currencyCode
            self.totalEstimatedMonthlySavingsAmount = totalEstimatedMonthlySavingsAmount
            self.totalEstimatedMonthlySavingsPercentage = totalEstimatedMonthlySavingsPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "CurrencyCode"
            case totalEstimatedMonthlySavingsAmount = "TotalEstimatedMonthlySavingsAmount"
            case totalEstimatedMonthlySavingsPercentage = "TotalEstimatedMonthlySavingsPercentage"
        }
    }

    public struct ReservationUtilizationGroup: AWSDecodableShape {
        /// The attributes for this group of reservations.
        public let attributes: [String: String]?
        /// The key for a specific reservation attribute.
        public let key: String?
        /// How much you used this group of reservations.
        public let utilization: ReservationAggregates?
        /// The value of a specific reservation attribute.
        public let value: String?

        public init(attributes: [String: String]? = nil, key: String? = nil, utilization: ReservationAggregates? = nil, value: String? = nil) {
            self.attributes = attributes
            self.key = key
            self.utilization = utilization
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case key = "Key"
            case utilization = "Utilization"
            case value = "Value"
        }
    }

    public struct ResourceDetails: AWSDecodableShape {
        /// Details for the Amazon EC2 resource.
        public let ec2ResourceDetails: EC2ResourceDetails?

        public init(ec2ResourceDetails: EC2ResourceDetails? = nil) {
            self.ec2ResourceDetails = ec2ResourceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case ec2ResourceDetails = "EC2ResourceDetails"
        }
    }

    public struct ResourceTag: AWSEncodableShape & AWSDecodableShape {
        /// The key that's associated with the tag.
        public let key: String
        /// The value that's associated with the tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct ResourceUtilization: AWSDecodableShape {
        /// The utilization of current Amazon EC2 instance.
        public let ec2ResourceUtilization: EC2ResourceUtilization?

        public init(ec2ResourceUtilization: EC2ResourceUtilization? = nil) {
            self.ec2ResourceUtilization = ec2ResourceUtilization
        }

        private enum CodingKeys: String, CodingKey {
            case ec2ResourceUtilization = "EC2ResourceUtilization"
        }
    }

    public struct ResultByTime: AWSDecodableShape {
        /// Determines whether the result is estimated.
        public let estimated: Bool?
        /// The groups that this time period includes.
        public let groups: [Group]?
        /// The time period that the result covers.
        public let timePeriod: DateInterval?
        /// The total amount of cost or usage accrued during the time period.
        public let total: [String: MetricValue]?

        public init(estimated: Bool? = nil, groups: [Group]? = nil, timePeriod: DateInterval? = nil, total: [String: MetricValue]? = nil) {
            self.estimated = estimated
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case estimated = "Estimated"
            case groups = "Groups"
            case timePeriod = "TimePeriod"
            case total = "Total"
        }
    }

    public struct RightsizingRecommendation: AWSDecodableShape {
        /// The account that this recommendation is for.
        public let accountId: String?
        /// Context regarding the current instance.
        public let currentInstance: CurrentInstance?
        /// The list of possible reasons why the recommendation is generated, such as under- or over-utilization of specific metrics (for example, CPU, Memory, Network).
        public let findingReasonCodes: [FindingReasonCode]?
        /// The details for the modification recommendations.
        public let modifyRecommendationDetail: ModifyRecommendationDetail?
        /// A recommendation to either terminate or modify the resource.
        public let rightsizingType: RightsizingType?
        /// The details for termination recommendations.
        public let terminateRecommendationDetail: TerminateRecommendationDetail?

        public init(accountId: String? = nil, currentInstance: CurrentInstance? = nil, findingReasonCodes: [FindingReasonCode]? = nil, modifyRecommendationDetail: ModifyRecommendationDetail? = nil, rightsizingType: RightsizingType? = nil, terminateRecommendationDetail: TerminateRecommendationDetail? = nil) {
            self.accountId = accountId
            self.currentInstance = currentInstance
            self.findingReasonCodes = findingReasonCodes
            self.modifyRecommendationDetail = modifyRecommendationDetail
            self.rightsizingType = rightsizingType
            self.terminateRecommendationDetail = terminateRecommendationDetail
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case currentInstance = "CurrentInstance"
            case findingReasonCodes = "FindingReasonCodes"
            case modifyRecommendationDetail = "ModifyRecommendationDetail"
            case rightsizingType = "RightsizingType"
            case terminateRecommendationDetail = "TerminateRecommendationDetail"
        }
    }

    public struct RightsizingRecommendationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The option to consider RI or Savings Plans discount benefits in your savings calculation. The default value is TRUE.
        public let benefitsConsidered: Bool
        /// The option to see recommendations within the same instance family or recommendations for instances across other families. The default value is SAME_INSTANCE_FAMILY.
        public let recommendationTarget: RecommendationTarget

        public init(benefitsConsidered: Bool, recommendationTarget: RecommendationTarget) {
            self.benefitsConsidered = benefitsConsidered
            self.recommendationTarget = recommendationTarget
        }

        private enum CodingKeys: String, CodingKey {
            case benefitsConsidered = "BenefitsConsidered"
            case recommendationTarget = "RecommendationTarget"
        }
    }

    public struct RightsizingRecommendationMetadata: AWSDecodableShape {
        /// Additional metadata that might be applicable to the recommendation.
        public let additionalMetadata: String?
        /// The timestamp for when Amazon Web Services made this recommendation.
        public let generationTimestamp: String?
        /// The number of days of previous usage that Amazon Web Services considers when making this recommendation.
        public let lookbackPeriodInDays: LookbackPeriodInDays?
        /// The ID for this specific recommendation.
        public let recommendationId: String?

        public init(additionalMetadata: String? = nil, generationTimestamp: String? = nil, lookbackPeriodInDays: LookbackPeriodInDays? = nil, recommendationId: String? = nil) {
            self.additionalMetadata = additionalMetadata
            self.generationTimestamp = generationTimestamp
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.recommendationId = recommendationId
        }

        private enum CodingKeys: String, CodingKey {
            case additionalMetadata = "AdditionalMetadata"
            case generationTimestamp = "GenerationTimestamp"
            case lookbackPeriodInDays = "LookbackPeriodInDays"
            case recommendationId = "RecommendationId"
        }
    }

    public struct RightsizingRecommendationSummary: AWSDecodableShape {
        /// The estimated total savings resulting from modifications, on a monthly basis.
        public let estimatedTotalMonthlySavingsAmount: String?
        /// The currency code that Amazon Web Services used to calculate the savings.
        public let savingsCurrencyCode: String?
        ///  The savings percentage based on the recommended modifications. It's relative to the total On-Demand costs that are associated with these instances.
        public let savingsPercentage: String?
        /// The total number of instance recommendations.
        public let totalRecommendationCount: String?

        public init(estimatedTotalMonthlySavingsAmount: String? = nil, savingsCurrencyCode: String? = nil, savingsPercentage: String? = nil, totalRecommendationCount: String? = nil) {
            self.estimatedTotalMonthlySavingsAmount = estimatedTotalMonthlySavingsAmount
            self.savingsCurrencyCode = savingsCurrencyCode
            self.savingsPercentage = savingsPercentage
            self.totalRecommendationCount = totalRecommendationCount
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedTotalMonthlySavingsAmount = "EstimatedTotalMonthlySavingsAmount"
            case savingsCurrencyCode = "SavingsCurrencyCode"
            case savingsPercentage = "SavingsPercentage"
            case totalRecommendationCount = "TotalRecommendationCount"
        }
    }

    public struct RootCause: AWSDecodableShape {
        /// The member account value that's associated with the cost anomaly.
        public let linkedAccount: String?
        /// The member account name value that's associated with the cost anomaly.
        public let linkedAccountName: String?
        /// The Amazon Web Services Region that's associated with the cost anomaly.
        public let region: String?
        /// The Amazon Web Service name that's associated with the cost anomaly.
        public let service: String?
        /// The UsageType value that's associated with the cost anomaly.
        public let usageType: String?

        public init(linkedAccount: String? = nil, linkedAccountName: String? = nil, region: String? = nil, service: String? = nil, usageType: String? = nil) {
            self.linkedAccount = linkedAccount
            self.linkedAccountName = linkedAccountName
            self.region = region
            self.service = service
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case linkedAccount = "LinkedAccount"
            case linkedAccountName = "LinkedAccountName"
            case region = "Region"
            case service = "Service"
            case usageType = "UsageType"
        }
    }

    public struct SavingsPlansAmortizedCommitment: AWSDecodableShape {
        /// The amortized amount of your Savings Plans commitment that was purchased with either a Partial or a NoUpfront.
        public let amortizedRecurringCommitment: String?
        /// The amortized amount of your Savings Plans commitment that was purchased with an Upfront or PartialUpfront Savings Plans.
        public let amortizedUpfrontCommitment: String?
        /// The total amortized amount of your Savings Plans commitment, regardless of your Savings Plans purchase method.
        public let totalAmortizedCommitment: String?

        public init(amortizedRecurringCommitment: String? = nil, amortizedUpfrontCommitment: String? = nil, totalAmortizedCommitment: String? = nil) {
            self.amortizedRecurringCommitment = amortizedRecurringCommitment
            self.amortizedUpfrontCommitment = amortizedUpfrontCommitment
            self.totalAmortizedCommitment = totalAmortizedCommitment
        }

        private enum CodingKeys: String, CodingKey {
            case amortizedRecurringCommitment = "AmortizedRecurringCommitment"
            case amortizedUpfrontCommitment = "AmortizedUpfrontCommitment"
            case totalAmortizedCommitment = "TotalAmortizedCommitment"
        }
    }

    public struct SavingsPlansCoverage: AWSDecodableShape {
        /// The attribute that applies to a specific Dimension.
        public let attributes: [String: String]?
        /// The amount of Savings Plans eligible usage that the Savings Plans covered.
        public let coverage: SavingsPlansCoverageData?
        public let timePeriod: DateInterval?

        public init(attributes: [String: String]? = nil, coverage: SavingsPlansCoverageData? = nil, timePeriod: DateInterval? = nil) {
            self.attributes = attributes
            self.coverage = coverage
            self.timePeriod = timePeriod
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case coverage = "Coverage"
            case timePeriod = "TimePeriod"
        }
    }

    public struct SavingsPlansCoverageData: AWSDecodableShape {
        /// The percentage of your existing Savings Plans covered usage, divided by all of your eligible Savings Plans usage in an account (or set of accounts).
        public let coveragePercentage: String?
        /// The cost of your Amazon Web Services usage at the public On-Demand rate.
        public let onDemandCost: String?
        /// The amount of your Amazon Web Services usage that's covered by a Savings Plans.
        public let spendCoveredBySavingsPlans: String?
        /// The total cost of your Amazon Web Services usage, regardless of your purchase option.
        public let totalCost: String?

        public init(coveragePercentage: String? = nil, onDemandCost: String? = nil, spendCoveredBySavingsPlans: String? = nil, totalCost: String? = nil) {
            self.coveragePercentage = coveragePercentage
            self.onDemandCost = onDemandCost
            self.spendCoveredBySavingsPlans = spendCoveredBySavingsPlans
            self.totalCost = totalCost
        }

        private enum CodingKeys: String, CodingKey {
            case coveragePercentage = "CoveragePercentage"
            case onDemandCost = "OnDemandCost"
            case spendCoveredBySavingsPlans = "SpendCoveredBySavingsPlans"
            case totalCost = "TotalCost"
        }
    }

    public struct SavingsPlansDetails: AWSDecodableShape {
        /// A group of instance types that Savings Plans applies to.
        public let instanceFamily: String?
        /// The unique ID that's used to distinguish Savings Plans from one another.
        public let offeringId: String?
        /// A collection of Amazon Web Services resources in a geographic area. Each Amazon Web Services Region is isolated and independent of the other Regions.
        public let region: String?

        public init(instanceFamily: String? = nil, offeringId: String? = nil, region: String? = nil) {
            self.instanceFamily = instanceFamily
            self.offeringId = offeringId
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case instanceFamily = "InstanceFamily"
            case offeringId = "OfferingId"
            case region = "Region"
        }
    }

    public struct SavingsPlansPurchaseRecommendation: AWSDecodableShape {
        /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations that include the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
        public let accountScope: AccountScope?
        /// The lookback period in days that's used to generate the recommendation.
        public let lookbackPeriodInDays: LookbackPeriodInDays?
        /// The payment option that's used to generate the recommendation.
        public let paymentOption: PaymentOption?
        /// Details for the Savings Plans that we recommend that you purchase to cover existing Savings Plans eligible workloads.
        public let savingsPlansPurchaseRecommendationDetails: [SavingsPlansPurchaseRecommendationDetail]?
        /// Summary metrics for your Savings Plans Recommendations.
        public let savingsPlansPurchaseRecommendationSummary: SavingsPlansPurchaseRecommendationSummary?
        /// The requested Savings Plans recommendation type.
        public let savingsPlansType: SupportedSavingsPlansType?
        /// The Savings Plans recommendation term in years. It's used to generate the recommendation.
        public let termInYears: TermInYears?

        public init(accountScope: AccountScope? = nil, lookbackPeriodInDays: LookbackPeriodInDays? = nil, paymentOption: PaymentOption? = nil, savingsPlansPurchaseRecommendationDetails: [SavingsPlansPurchaseRecommendationDetail]? = nil, savingsPlansPurchaseRecommendationSummary: SavingsPlansPurchaseRecommendationSummary? = nil, savingsPlansType: SupportedSavingsPlansType? = nil, termInYears: TermInYears? = nil) {
            self.accountScope = accountScope
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.paymentOption = paymentOption
            self.savingsPlansPurchaseRecommendationDetails = savingsPlansPurchaseRecommendationDetails
            self.savingsPlansPurchaseRecommendationSummary = savingsPlansPurchaseRecommendationSummary
            self.savingsPlansType = savingsPlansType
            self.termInYears = termInYears
        }

        private enum CodingKeys: String, CodingKey {
            case accountScope = "AccountScope"
            case lookbackPeriodInDays = "LookbackPeriodInDays"
            case paymentOption = "PaymentOption"
            case savingsPlansPurchaseRecommendationDetails = "SavingsPlansPurchaseRecommendationDetails"
            case savingsPlansPurchaseRecommendationSummary = "SavingsPlansPurchaseRecommendationSummary"
            case savingsPlansType = "SavingsPlansType"
            case termInYears = "TermInYears"
        }
    }

    public struct SavingsPlansPurchaseRecommendationDetail: AWSDecodableShape {
        /// The AccountID the recommendation is generated for.
        public let accountId: String?
        /// The currency code that Amazon Web Services used to generate the recommendations and present potential savings.
        public let currencyCode: String?
        /// The average value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public let currentAverageHourlyOnDemandSpend: String?
        /// The highest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public let currentMaximumHourlyOnDemandSpend: String?
        /// The lowest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public let currentMinimumHourlyOnDemandSpend: String?
        /// The estimated utilization of the recommended Savings Plans.
        public let estimatedAverageUtilization: String?
        /// The estimated monthly savings amount based on the recommended Savings Plans.
        public let estimatedMonthlySavingsAmount: String?
        /// The remaining On-Demand cost estimated to not be covered by the recommended Savings Plans, over the length of the lookback period.
        public let estimatedOnDemandCost: String?
        ///  The estimated On-Demand costs you expect with no additional commitment, based on your usage of the selected time period and the Savings Plans you own.
        public let estimatedOnDemandCostWithCurrentCommitment: String?
        /// The estimated return on investment that's based on the recommended Savings Plans that you purchased. This is calculated as estimatedSavingsAmount/ estimatedSPCost*100.
        public let estimatedROI: String?
        /// The estimated savings amount that's based on the recommended Savings Plans over the length of the lookback period.
        public let estimatedSavingsAmount: String?
        /// The estimated savings percentage relative to the total cost of applicable On-Demand usage over the lookback period.
        public let estimatedSavingsPercentage: String?
        /// The cost of the recommended Savings Plans over the length of the lookback period.
        public let estimatedSPCost: String?
        /// The recommended hourly commitment level for the Savings Plans type and the configuration that's based on the usage during the lookback period.
        public let hourlyCommitmentToPurchase: String?
        /// Details for your recommended Savings Plans.
        public let savingsPlansDetails: SavingsPlansDetails?
        /// The upfront cost of the recommended Savings Plans, based on the selected payment option.
        public let upfrontCost: String?

        public init(accountId: String? = nil, currencyCode: String? = nil, currentAverageHourlyOnDemandSpend: String? = nil, currentMaximumHourlyOnDemandSpend: String? = nil, currentMinimumHourlyOnDemandSpend: String? = nil, estimatedAverageUtilization: String? = nil, estimatedMonthlySavingsAmount: String? = nil, estimatedOnDemandCost: String? = nil, estimatedOnDemandCostWithCurrentCommitment: String? = nil, estimatedROI: String? = nil, estimatedSavingsAmount: String? = nil, estimatedSavingsPercentage: String? = nil, estimatedSPCost: String? = nil, hourlyCommitmentToPurchase: String? = nil, savingsPlansDetails: SavingsPlansDetails? = nil, upfrontCost: String? = nil) {
            self.accountId = accountId
            self.currencyCode = currencyCode
            self.currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpend
            self.currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpend
            self.currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpend
            self.estimatedAverageUtilization = estimatedAverageUtilization
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
            self.estimatedROI = estimatedROI
            self.estimatedSavingsAmount = estimatedSavingsAmount
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.estimatedSPCost = estimatedSPCost
            self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
            self.savingsPlansDetails = savingsPlansDetails
            self.upfrontCost = upfrontCost
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case currencyCode = "CurrencyCode"
            case currentAverageHourlyOnDemandSpend = "CurrentAverageHourlyOnDemandSpend"
            case currentMaximumHourlyOnDemandSpend = "CurrentMaximumHourlyOnDemandSpend"
            case currentMinimumHourlyOnDemandSpend = "CurrentMinimumHourlyOnDemandSpend"
            case estimatedAverageUtilization = "EstimatedAverageUtilization"
            case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
            case estimatedOnDemandCost = "EstimatedOnDemandCost"
            case estimatedOnDemandCostWithCurrentCommitment = "EstimatedOnDemandCostWithCurrentCommitment"
            case estimatedROI = "EstimatedROI"
            case estimatedSavingsAmount = "EstimatedSavingsAmount"
            case estimatedSavingsPercentage = "EstimatedSavingsPercentage"
            case estimatedSPCost = "EstimatedSPCost"
            case hourlyCommitmentToPurchase = "HourlyCommitmentToPurchase"
            case savingsPlansDetails = "SavingsPlansDetails"
            case upfrontCost = "UpfrontCost"
        }
    }

    public struct SavingsPlansPurchaseRecommendationMetadata: AWSDecodableShape {
        /// Additional metadata that might be applicable to the recommendation.
        public let additionalMetadata: String?
        /// The timestamp that shows when the recommendations were generated.
        public let generationTimestamp: String?
        /// The unique identifier for the recommendation set.
        public let recommendationId: String?

        public init(additionalMetadata: String? = nil, generationTimestamp: String? = nil, recommendationId: String? = nil) {
            self.additionalMetadata = additionalMetadata
            self.generationTimestamp = generationTimestamp
            self.recommendationId = recommendationId
        }

        private enum CodingKeys: String, CodingKey {
            case additionalMetadata = "AdditionalMetadata"
            case generationTimestamp = "GenerationTimestamp"
            case recommendationId = "RecommendationId"
        }
    }

    public struct SavingsPlansPurchaseRecommendationSummary: AWSDecodableShape {
        /// The currency code that Amazon Web Services used to generate the recommendations and present potential savings.
        public let currencyCode: String?
        /// The current total on demand spend of the applicable usage types over the lookback period.
        public let currentOnDemandSpend: String?
        /// The recommended Savings Plans cost on a daily (24 hourly) basis.
        public let dailyCommitmentToPurchase: String?
        /// The estimated monthly savings amount that's based on the recommended Savings Plans purchase.
        public let estimatedMonthlySavingsAmount: String?
        /// The estimated On-Demand costs you expect with no additional commitment. It's based on your usage of the selected time period and the Savings Plans you own.
        public let estimatedOnDemandCostWithCurrentCommitment: String?
        /// The estimated return on investment that's based on the recommended Savings Plans and estimated savings.
        public let estimatedROI: String?
        /// The estimated total savings over the lookback period, based on the purchase of the recommended Savings Plans.
        public let estimatedSavingsAmount: String?
        /// The estimated savings relative to the total cost of On-Demand usage, over the lookback period. This is calculated as estimatedSavingsAmount/ CurrentOnDemandSpend*100.
        public let estimatedSavingsPercentage: String?
        /// The estimated total cost of the usage after purchasing the recommended Savings Plans. This is a sum of the cost of Savings Plans during this term, and the remaining On-Demand usage.
        public let estimatedTotalCost: String?
        /// The recommended hourly commitment that's based on the recommendation parameters.
        public let hourlyCommitmentToPurchase: String?
        /// The aggregate number of Savings Plans recommendations that exist for your account.
        public let totalRecommendationCount: String?

        public init(currencyCode: String? = nil, currentOnDemandSpend: String? = nil, dailyCommitmentToPurchase: String? = nil, estimatedMonthlySavingsAmount: String? = nil, estimatedOnDemandCostWithCurrentCommitment: String? = nil, estimatedROI: String? = nil, estimatedSavingsAmount: String? = nil, estimatedSavingsPercentage: String? = nil, estimatedTotalCost: String? = nil, hourlyCommitmentToPurchase: String? = nil, totalRecommendationCount: String? = nil) {
            self.currencyCode = currencyCode
            self.currentOnDemandSpend = currentOnDemandSpend
            self.dailyCommitmentToPurchase = dailyCommitmentToPurchase
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
            self.estimatedROI = estimatedROI
            self.estimatedSavingsAmount = estimatedSavingsAmount
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.estimatedTotalCost = estimatedTotalCost
            self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
            self.totalRecommendationCount = totalRecommendationCount
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "CurrencyCode"
            case currentOnDemandSpend = "CurrentOnDemandSpend"
            case dailyCommitmentToPurchase = "DailyCommitmentToPurchase"
            case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
            case estimatedOnDemandCostWithCurrentCommitment = "EstimatedOnDemandCostWithCurrentCommitment"
            case estimatedROI = "EstimatedROI"
            case estimatedSavingsAmount = "EstimatedSavingsAmount"
            case estimatedSavingsPercentage = "EstimatedSavingsPercentage"
            case estimatedTotalCost = "EstimatedTotalCost"
            case hourlyCommitmentToPurchase = "HourlyCommitmentToPurchase"
            case totalRecommendationCount = "TotalRecommendationCount"
        }
    }

    public struct SavingsPlansSavings: AWSDecodableShape {
        /// The savings amount that you're accumulating for the usage that's covered by a Savings Plans, when compared to the On-Demand equivalent of the same usage.
        public let netSavings: String?
        /// How much the amount that the usage would have cost if it was accrued at the On-Demand rate.
        public let onDemandCostEquivalent: String?

        public init(netSavings: String? = nil, onDemandCostEquivalent: String? = nil) {
            self.netSavings = netSavings
            self.onDemandCostEquivalent = onDemandCostEquivalent
        }

        private enum CodingKeys: String, CodingKey {
            case netSavings = "NetSavings"
            case onDemandCostEquivalent = "OnDemandCostEquivalent"
        }
    }

    public struct SavingsPlansUtilization: AWSDecodableShape {
        /// The total amount of Savings Plans commitment that's been purchased in an account (or set of accounts).
        public let totalCommitment: String?
        /// The amount of your Savings Plans commitment that wasn't consumed from Savings Plans eligible usage in a specific period.
        public let unusedCommitment: String?
        /// The amount of your Savings Plans commitment that was consumed from Savings Plans eligible usage in a specific period.
        public let usedCommitment: String?
        /// The amount of UsedCommitment divided by the TotalCommitment for your Savings Plans.
        public let utilizationPercentage: String?

        public init(totalCommitment: String? = nil, unusedCommitment: String? = nil, usedCommitment: String? = nil, utilizationPercentage: String? = nil) {
            self.totalCommitment = totalCommitment
            self.unusedCommitment = unusedCommitment
            self.usedCommitment = usedCommitment
            self.utilizationPercentage = utilizationPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case totalCommitment = "TotalCommitment"
            case unusedCommitment = "UnusedCommitment"
            case usedCommitment = "UsedCommitment"
            case utilizationPercentage = "UtilizationPercentage"
        }
    }

    public struct SavingsPlansUtilizationAggregates: AWSDecodableShape {
        /// The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.
        public let amortizedCommitment: SavingsPlansAmortizedCommitment?
        /// The amount that's saved by using existing Savings Plans. Savings returns both net savings from Savings Plans and also the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public let savings: SavingsPlansSavings?
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        public let utilization: SavingsPlansUtilization

        public init(amortizedCommitment: SavingsPlansAmortizedCommitment? = nil, savings: SavingsPlansSavings? = nil, utilization: SavingsPlansUtilization) {
            self.amortizedCommitment = amortizedCommitment
            self.savings = savings
            self.utilization = utilization
        }

        private enum CodingKeys: String, CodingKey {
            case amortizedCommitment = "AmortizedCommitment"
            case savings = "Savings"
            case utilization = "Utilization"
        }
    }

    public struct SavingsPlansUtilizationByTime: AWSDecodableShape {
        /// The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.
        public let amortizedCommitment: SavingsPlansAmortizedCommitment?
        /// The amount that's saved by using existing Savings Plans. Savings returns both net savings from Savings Plans and also the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public let savings: SavingsPlansSavings?
        public let timePeriod: DateInterval
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        public let utilization: SavingsPlansUtilization

        public init(amortizedCommitment: SavingsPlansAmortizedCommitment? = nil, savings: SavingsPlansSavings? = nil, timePeriod: DateInterval, utilization: SavingsPlansUtilization) {
            self.amortizedCommitment = amortizedCommitment
            self.savings = savings
            self.timePeriod = timePeriod
            self.utilization = utilization
        }

        private enum CodingKeys: String, CodingKey {
            case amortizedCommitment = "AmortizedCommitment"
            case savings = "Savings"
            case timePeriod = "TimePeriod"
            case utilization = "Utilization"
        }
    }

    public struct SavingsPlansUtilizationDetail: AWSDecodableShape {
        /// The total amortized commitment for a Savings Plans. Includes the sum of the upfront and recurring Savings Plans fees.
        public let amortizedCommitment: SavingsPlansAmortizedCommitment?
        /// The attribute that applies to a specific Dimension.
        public let attributes: [String: String]?
        /// The amount saved by using existing Savings Plans. Savings returns both net savings from savings plans and also the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public let savings: SavingsPlansSavings?
        /// The unique Amazon Resource Name (ARN) for a particular Savings Plan.
        public let savingsPlanArn: String?
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        public let utilization: SavingsPlansUtilization?

        public init(amortizedCommitment: SavingsPlansAmortizedCommitment? = nil, attributes: [String: String]? = nil, savings: SavingsPlansSavings? = nil, savingsPlanArn: String? = nil, utilization: SavingsPlansUtilization? = nil) {
            self.amortizedCommitment = amortizedCommitment
            self.attributes = attributes
            self.savings = savings
            self.savingsPlanArn = savingsPlanArn
            self.utilization = utilization
        }

        private enum CodingKeys: String, CodingKey {
            case amortizedCommitment = "AmortizedCommitment"
            case attributes = "Attributes"
            case savings = "Savings"
            case savingsPlanArn = "SavingsPlanArn"
            case utilization = "Utilization"
        }
    }

    public struct ServiceSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon EC2 hardware specifications that you want Amazon Web Services to provide recommendations for.
        public let ec2Specification: EC2Specification?

        public init(ec2Specification: EC2Specification? = nil) {
            self.ec2Specification = ec2Specification
        }

        private enum CodingKeys: String, CodingKey {
            case ec2Specification = "EC2Specification"
        }
    }

    public struct SortDefinition: AWSEncodableShape {
        /// The key that's used to sort the data.
        public let key: String
        /// The order that's used to sort the data.
        public let sortOrder: SortOrder?

        public init(key: String, sortOrder: SortOrder? = nil) {
            self.key = key
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case sortOrder = "SortOrder"
        }
    }

    public struct StartSavingsPlansPurchaseRecommendationGenerationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct StartSavingsPlansPurchaseRecommendationGenerationResponse: AWSDecodableShape {
        /// The estimated time for when the recommendation generation will complete.
        public let estimatedCompletionTime: String?
        /// The start time of the recommendation generation.
        public let generationStartedTime: String?
        /// The ID for this specific recommendation.
        public let recommendationId: String?

        public init(estimatedCompletionTime: String? = nil, generationStartedTime: String? = nil, recommendationId: String? = nil) {
            self.estimatedCompletionTime = estimatedCompletionTime
            self.generationStartedTime = generationStartedTime
            self.recommendationId = recommendationId
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedCompletionTime = "EstimatedCompletionTime"
            case generationStartedTime = "GenerationStartedTime"
            case recommendationId = "RecommendationId"
        }
    }

    public struct Subscriber: AWSEncodableShape & AWSDecodableShape {
        /// The email address or SNS Amazon Resource Name (ARN). This depends on the Type.
        public let address: String?
        /// Indicates if the subscriber accepts the notifications.
        public let status: SubscriberStatus?
        /// The notification delivery channel.
        public let type: SubscriberType?

        public init(address: String? = nil, status: SubscriberStatus? = nil, type: SubscriberType? = nil) {
            self.address = address
            self.status = status
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, max: 302)
            try self.validate(self.address, name: "address", parent: name, min: 6)
            try self.validate(self.address, name: "address", parent: name, pattern: "^(^[a-zA-Z0-9.!#$%&'*+=?^_‘{|}~-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$)|(^arn:(aws[a-zA-Z-]*):sns:[a-zA-Z0-9-]+:[0-9]{12}:[a-zA-Z0-9_-]+(\\.fifo)?$)$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see ResourceTag.
        public let resourceArn: String
        ///  A list of tag key-value pairs to be added to the resource. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:   Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use   The maximum length of a key is 128 characters   The maximum length of a value is 256 characters   Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-    Keys and values are case sensitive   Keys and values are trimmed for any leading or trailing whitespaces   Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
        public let resourceTags: [ResourceTag]

        public init(resourceArn: String, resourceTags: [ResourceTag]) {
            self.resourceArn = resourceArn
            self.resourceTags = resourceTags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            try self.resourceTags.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case resourceTags = "ResourceTags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagValues: AWSEncodableShape & AWSDecodableShape {
        /// The key for the tag.
        public let key: String?
        /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to Cost Category. The default values for MatchOptions are EQUALS and CASE_SENSITIVE.
        public let matchOptions: [MatchOption]?
        /// The specific value of the tag.
        public let values: [String]?

        public init(key: String? = nil, matchOptions: [MatchOption]? = nil, values: [String]? = nil) {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[\\S\\s]*$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\S\\s]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case matchOptions = "MatchOptions"
            case values = "Values"
        }
    }

    public struct TargetInstance: AWSDecodableShape {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public let currencyCode: String?
        /// Determines whether this recommendation is the defaulted Amazon Web Services recommendation.
        public let defaultTargetInstance: Bool?
        /// The expected cost to operate this instance type on a monthly basis.
        public let estimatedMonthlyCost: String?
        /// The estimated savings that result from modification, on a monthly basis.
        public let estimatedMonthlySavings: String?
        /// The expected utilization metrics for target instance type.
        public let expectedResourceUtilization: ResourceUtilization?
        /// Explains the actions that you might need to take to successfully migrate your workloads from the current instance type to the recommended instance type.
        public let platformDifferences: [PlatformDifference]?
        /// Details on the target instance type.
        public let resourceDetails: ResourceDetails?

        public init(currencyCode: String? = nil, defaultTargetInstance: Bool? = nil, estimatedMonthlyCost: String? = nil, estimatedMonthlySavings: String? = nil, expectedResourceUtilization: ResourceUtilization? = nil, platformDifferences: [PlatformDifference]? = nil, resourceDetails: ResourceDetails? = nil) {
            self.currencyCode = currencyCode
            self.defaultTargetInstance = defaultTargetInstance
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.expectedResourceUtilization = expectedResourceUtilization
            self.platformDifferences = platformDifferences
            self.resourceDetails = resourceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "CurrencyCode"
            case defaultTargetInstance = "DefaultTargetInstance"
            case estimatedMonthlyCost = "EstimatedMonthlyCost"
            case estimatedMonthlySavings = "EstimatedMonthlySavings"
            case expectedResourceUtilization = "ExpectedResourceUtilization"
            case platformDifferences = "PlatformDifferences"
            case resourceDetails = "ResourceDetails"
        }
    }

    public struct TerminateRecommendationDetail: AWSDecodableShape {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public let currencyCode: String?
        /// The estimated savings that result from modification, on a monthly basis.
        public let estimatedMonthlySavings: String?

        public init(currencyCode: String? = nil, estimatedMonthlySavings: String? = nil) {
            self.currencyCode = currencyCode
            self.estimatedMonthlySavings = estimatedMonthlySavings
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "CurrencyCode"
            case estimatedMonthlySavings = "EstimatedMonthlySavings"
        }
    }

    public struct TotalImpactFilter: AWSEncodableShape {
        /// The upper bound dollar value that's used in the filter.
        public let endValue: Double?
        /// The comparing value that's used in the filter.
        public let numericOperator: NumericOperator
        /// The lower bound dollar value that's used in the filter.
        public let startValue: Double

        public init(endValue: Double? = nil, numericOperator: NumericOperator, startValue: Double = 0) {
            self.endValue = endValue
            self.numericOperator = numericOperator
            self.startValue = startValue
        }

        private enum CodingKeys: String, CodingKey {
            case endValue = "EndValue"
            case numericOperator = "NumericOperator"
            case startValue = "StartValue"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see ResourceTag.
        public let resourceArn: String
        /// A list of tag keys associated with tags that need to be removed from the resource. If you specify a tag key that doesn't exist, it's ignored. Although the maximum number of array members is 200, user-tag maximum is 50. The remaining are reserved for Amazon Web Services use.
        public let resourceTagKeys: [String]

        public init(resourceArn: String, resourceTagKeys: [String]) {
            self.resourceArn = resourceArn
            self.resourceTagKeys = resourceTagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            try self.resourceTagKeys.forEach {
                try validate($0, name: "resourceTagKeys[]", parent: name, max: 128)
                try validate($0, name: "resourceTagKeys[]", parent: name, min: 1)
                try validate($0, name: "resourceTagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.resourceTagKeys, name: "resourceTagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case resourceTagKeys = "ResourceTagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAnomalyMonitorRequest: AWSEncodableShape {
        /// Cost anomaly monitor Amazon Resource Names (ARNs).
        public let monitorArn: String
        /// The new name for the cost anomaly monitor.
        public let monitorName: String?

        public init(monitorArn: String, monitorName: String? = nil) {
            self.monitorArn = monitorArn
            self.monitorName = monitorName
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, max: 1024)
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 1024)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
            case monitorName = "MonitorName"
        }
    }

    public struct UpdateAnomalyMonitorResponse: AWSDecodableShape {
        /// A cost anomaly monitor ARN.
        public let monitorArn: String

        public init(monitorArn: String) {
            self.monitorArn = monitorArn
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
        }
    }

    public struct UpdateAnomalySubscriptionRequest: AWSEncodableShape {
        /// The update to the frequency value that subscribers receive notifications.
        public let frequency: AnomalySubscriptionFrequency?
        /// A list of cost anomaly monitor ARNs.
        public let monitorArnList: [String]?
        /// The update to the subscriber list.
        public let subscribers: [Subscriber]?
        /// A cost anomaly subscription Amazon Resource Name (ARN).
        public let subscriptionArn: String
        /// The new name of the subscription.
        public let subscriptionName: String?
        /// (deprecated) The update to the threshold value for receiving notifications.  This field has been deprecated. To update a threshold, use ThresholdExpression. Continued use of Threshold will be treated as shorthand syntax for a ThresholdExpression.
        public let threshold: Double?
        /// The update to the Expression object used to specify the anomalies that you want to generate alerts for. This supports dimensions and nested expressions. The supported dimensions are ANOMALY_TOTAL_IMPACT_ABSOLUTE and ANOMALY_TOTAL_IMPACT_PERCENTAGE. The supported nested expression types are AND and OR. The match option GREATER_THAN_OR_EQUAL is required. Values must be numbers between 0 and 10,000,000,000. The following are examples of valid ThresholdExpressions:   Absolute threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }    Percentage threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }     AND two thresholds together: { "And": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }     OR two thresholds together: { "Or": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }
        public let thresholdExpression: Expression?

        public init(frequency: AnomalySubscriptionFrequency? = nil, monitorArnList: [String]? = nil, subscribers: [Subscriber]? = nil, subscriptionArn: String, subscriptionName: String? = nil, thresholdExpression: Expression? = nil) {
            self.frequency = frequency
            self.monitorArnList = monitorArnList
            self.subscribers = subscribers
            self.subscriptionArn = subscriptionArn
            self.subscriptionName = subscriptionName
            self.threshold = nil
            self.thresholdExpression = thresholdExpression
        }

        @available(*, deprecated, message: "Members threshold have been deprecated")
        public init(frequency: AnomalySubscriptionFrequency? = nil, monitorArnList: [String]? = nil, subscribers: [Subscriber]? = nil, subscriptionArn: String, subscriptionName: String? = nil, threshold: Double? = nil, thresholdExpression: Expression? = nil) {
            self.frequency = frequency
            self.monitorArnList = monitorArnList
            self.subscribers = subscribers
            self.subscriptionArn = subscriptionArn
            self.subscriptionName = subscriptionName
            self.threshold = threshold
            self.thresholdExpression = thresholdExpression
        }

        public func validate(name: String) throws {
            try self.monitorArnList?.forEach {
                try validate($0, name: "monitorArnList[]", parent: name, max: 2048)
                try validate($0, name: "monitorArnList[]", parent: name, min: 20)
                try validate($0, name: "monitorArnList[]", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            }
            try self.subscribers?.forEach {
                try $0.validate(name: "\(name).subscribers[]")
            }
            try self.validate(self.subscriptionArn, name: "subscriptionArn", parent: name, max: 1024)
            try self.validate(self.subscriptionArn, name: "subscriptionArn", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.subscriptionName, name: "subscriptionName", parent: name, max: 1024)
            try self.validate(self.subscriptionName, name: "subscriptionName", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.threshold, name: "threshold", parent: name, min: 0.0)
            try self.thresholdExpression?.validate(name: "\(name).thresholdExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case frequency = "Frequency"
            case monitorArnList = "MonitorArnList"
            case subscribers = "Subscribers"
            case subscriptionArn = "SubscriptionArn"
            case subscriptionName = "SubscriptionName"
            case threshold = "Threshold"
            case thresholdExpression = "ThresholdExpression"
        }
    }

    public struct UpdateAnomalySubscriptionResponse: AWSDecodableShape {
        /// A cost anomaly subscription ARN.
        public let subscriptionArn: String

        public init(subscriptionArn: String) {
            self.subscriptionArn = subscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionArn = "SubscriptionArn"
        }
    }

    public struct UpdateCostAllocationTagsStatusError: AWSDecodableShape {
        /// An error code representing why the action failed on this entry.
        public let code: String?
        /// A message explaining why the action failed on this entry.
        public let message: String?
        /// The key for the cost allocation tag.
        public let tagKey: String?

        public init(code: String? = nil, message: String? = nil, tagKey: String? = nil) {
            self.code = code
            self.message = message
            self.tagKey = tagKey
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
            case tagKey = "TagKey"
        }
    }

    public struct UpdateCostAllocationTagsStatusRequest: AWSEncodableShape {
        /// The list of CostAllocationTagStatusEntry objects that are used to update cost allocation tags status for this request.
        public let costAllocationTagsStatus: [CostAllocationTagStatusEntry]

        public init(costAllocationTagsStatus: [CostAllocationTagStatusEntry]) {
            self.costAllocationTagsStatus = costAllocationTagsStatus
        }

        public func validate(name: String) throws {
            try self.costAllocationTagsStatus.forEach {
                try $0.validate(name: "\(name).costAllocationTagsStatus[]")
            }
            try self.validate(self.costAllocationTagsStatus, name: "costAllocationTagsStatus", parent: name, max: 20)
            try self.validate(self.costAllocationTagsStatus, name: "costAllocationTagsStatus", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case costAllocationTagsStatus = "CostAllocationTagsStatus"
        }
    }

    public struct UpdateCostAllocationTagsStatusResponse: AWSDecodableShape {
        /// A list of UpdateCostAllocationTagsStatusError objects with error details about each cost allocation tag that can't be updated. If there's no failure, an empty array returns.
        public let errors: [UpdateCostAllocationTagsStatusError]?

        public init(errors: [UpdateCostAllocationTagsStatusError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct UpdateCostCategoryDefinitionRequest: AWSEncodableShape {
        /// The unique identifier for your Cost Category.
        public let costCategoryArn: String
        public let defaultValue: String?
        /// The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.
        public let effectiveStart: String?
        /// The Expression object used to categorize costs. For more information, see CostCategoryRule .
        public let rules: [CostCategoryRule]
        public let ruleVersion: CostCategoryRuleVersion
        ///  The split charge rules used to allocate your charges between your Cost Category values.
        public let splitChargeRules: [CostCategorySplitChargeRule]?

        public init(costCategoryArn: String, defaultValue: String? = nil, effectiveStart: String? = nil, rules: [CostCategoryRule], ruleVersion: CostCategoryRuleVersion, splitChargeRules: [CostCategorySplitChargeRule]? = nil) {
            self.costCategoryArn = costCategoryArn
            self.defaultValue = defaultValue
            self.effectiveStart = effectiveStart
            self.rules = rules
            self.ruleVersion = ruleVersion
            self.splitChargeRules = splitChargeRules
        }

        public func validate(name: String) throws {
            try self.validate(self.costCategoryArn, name: "costCategoryArn", parent: name, max: 2048)
            try self.validate(self.costCategoryArn, name: "costCategoryArn", parent: name, min: 20)
            try self.validate(self.costCategoryArn, name: "costCategoryArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 50)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, min: 1)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, pattern: "^(?! )[\\p{L}\\p{N}\\p{Z}-_]*(?<! )$")
            try self.validate(self.effectiveStart, name: "effectiveStart", parent: name, max: 25)
            try self.validate(self.effectiveStart, name: "effectiveStart", parent: name, min: 20)
            try self.validate(self.effectiveStart, name: "effectiveStart", parent: name, pattern: "^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(([+-]\\d\\d:\\d\\d)|Z)$")
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 500)
            try self.validate(self.rules, name: "rules", parent: name, min: 1)
            try self.splitChargeRules?.forEach {
                try $0.validate(name: "\(name).splitChargeRules[]")
            }
            try self.validate(self.splitChargeRules, name: "splitChargeRules", parent: name, max: 10)
            try self.validate(self.splitChargeRules, name: "splitChargeRules", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case costCategoryArn = "CostCategoryArn"
            case defaultValue = "DefaultValue"
            case effectiveStart = "EffectiveStart"
            case rules = "Rules"
            case ruleVersion = "RuleVersion"
            case splitChargeRules = "SplitChargeRules"
        }
    }

    public struct UpdateCostCategoryDefinitionResponse: AWSDecodableShape {
        /// The unique identifier for your Cost Category.
        public let costCategoryArn: String?
        /// The Cost Category's effective start date. It can only be a billing start date (first day of the month).
        public let effectiveStart: String?

        public init(costCategoryArn: String? = nil, effectiveStart: String? = nil) {
            self.costCategoryArn = costCategoryArn
            self.effectiveStart = effectiveStart
        }

        private enum CodingKeys: String, CodingKey {
            case costCategoryArn = "CostCategoryArn"
            case effectiveStart = "EffectiveStart"
        }
    }

    public struct UtilizationByTime: AWSDecodableShape {
        /// The groups that this utilization result uses.
        public let groups: [ReservationUtilizationGroup]?
        /// The period of time that this utilization was used for.
        public let timePeriod: DateInterval?
        /// The total number of reservation hours that were used.
        public let total: ReservationAggregates?

        public init(groups: [ReservationUtilizationGroup]? = nil, timePeriod: DateInterval? = nil, total: ReservationAggregates? = nil) {
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case timePeriod = "TimePeriod"
            case total = "Total"
        }
    }
}

// MARK: - Errors

/// Error enum for CostExplorer
public struct CostExplorerErrorType: AWSErrorType {
    enum Code: String {
        case billExpirationException = "BillExpirationException"
        case dataUnavailableException = "DataUnavailableException"
        case generationExistsException = "GenerationExistsException"
        case invalidNextTokenException = "InvalidNextTokenException"
        case limitExceededException = "LimitExceededException"
        case requestChangedException = "RequestChangedException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case tooManyTagsException = "TooManyTagsException"
        case unknownMonitorException = "UnknownMonitorException"
        case unknownSubscriptionException = "UnknownSubscriptionException"
        case unresolvableUsageUnitException = "UnresolvableUsageUnitException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CostExplorer
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The requested report expired. Update the date interval and try again.
    public static var billExpirationException: Self { .init(.billExpirationException) }
    /// The requested data is unavailable.
    public static var dataUnavailableException: Self { .init(.dataUnavailableException) }
    /// A request to generate a recommendation is already in progress.
    public static var generationExistsException: Self { .init(.generationExistsException) }
    /// The pagination token is invalid. Try again without a pagination token.
    public static var invalidNextTokenException: Self { .init(.invalidNextTokenException) }
    /// You made too many calls in a short period of time. Try again later.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// Your request parameters changed between pages. Try again with the old parameters or without a pagination token.
    public static var requestChangedException: Self { .init(.requestChangedException) }
    ///  The specified ARN in the request doesn&#39;t exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  You&#39;ve reached the limit on the number of resources you can create, or exceeded the size of an individual resource.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Can occur if you specify a number of tags for a resource greater than the maximum 50 user tags per resource.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The cost anomaly monitor does not exist for the account.
    public static var unknownMonitorException: Self { .init(.unknownMonitorException) }
    /// The cost anomaly subscription does not exist for the account.
    public static var unknownSubscriptionException: Self { .init(.unknownSubscriptionException) }
    /// Cost Explorer was unable to identify the usage unit. Provide UsageType/UsageTypeGroup filter selections that contain matching units, for example: hours.
    public static var unresolvableUsageUnitException: Self { .init(.unresolvableUsageUnitException) }
}

extension CostExplorerErrorType: Equatable {
    public static func == (lhs: CostExplorerErrorType, rhs: CostExplorerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CostExplorerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
