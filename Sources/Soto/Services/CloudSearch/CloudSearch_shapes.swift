//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension CloudSearch {
    // MARK: Enums

    public enum AlgorithmicStemming: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case full = "full"
        case light = "light"
        case minimal = "minimal"
        case none = "none"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisSchemeLanguage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ar = "ar"
        case bg = "bg"
        case ca = "ca"
        case cs = "cs"
        case da = "da"
        case de = "de"
        case el = "el"
        case en = "en"
        case es = "es"
        case eu = "eu"
        case fa = "fa"
        case fi = "fi"
        case fr = "fr"
        case ga = "ga"
        case gl = "gl"
        case he = "he"
        case hi = "hi"
        case hu = "hu"
        case hy = "hy"
        case id = "id"
        case it = "it"
        case ja = "ja"
        case ko = "ko"
        case lv = "lv"
        case mul = "mul"
        case nl = "nl"
        case no = "no"
        case pt = "pt"
        case ro = "ro"
        case ru = "ru"
        case sv = "sv"
        case th = "th"
        case tr = "tr"
        case zhHans = "zh-Hans"
        case zhHant = "zh-Hant"
        public var description: String { return self.rawValue }
    }

    public enum IndexFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case date = "date"
        case dateArray = "date-array"
        case double = "double"
        case doubleArray = "double-array"
        case int = "int"
        case intArray = "int-array"
        case latlon = "latlon"
        case literal = "literal"
        case literalArray = "literal-array"
        case text = "text"
        case textArray = "text-array"
        public var description: String { return self.rawValue }
    }

    public enum OptionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case failedToValidate = "FailedToValidate"
        case processing = "Processing"
        case requiresIndexDocuments = "RequiresIndexDocuments"
        public var description: String { return self.rawValue }
    }

    public enum PartitionInstanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case search2Xlarge = "search.2xlarge"
        case searchLarge = "search.large"
        case searchM1Large = "search.m1.large"
        case searchM1Small = "search.m1.small"
        case searchM22Xlarge = "search.m2.2xlarge"
        case searchM2Xlarge = "search.m2.xlarge"
        case searchM32Xlarge = "search.m3.2xlarge"
        case searchM3Large = "search.m3.large"
        case searchM3Medium = "search.m3.medium"
        case searchM3Xlarge = "search.m3.xlarge"
        case searchMedium = "search.medium"
        case searchPreviousgeneration2Xlarge = "search.previousgeneration.2xlarge"
        case searchPreviousgenerationLarge = "search.previousgeneration.large"
        case searchPreviousgenerationSmall = "search.previousgeneration.small"
        case searchPreviousgenerationXlarge = "search.previousgeneration.xlarge"
        case searchSmall = "search.small"
        case searchXlarge = "search.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum SuggesterFuzzyMatching: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "high"
        case low = "low"
        case none = "none"
        public var description: String { return self.rawValue }
    }

    public enum TLSSecurityPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case policyMinTls10201907 = "Policy-Min-TLS-1-0-2019-07"
        case policyMinTls12201907 = "Policy-Min-TLS-1-2-2019-07"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessPoliciesStatus: AWSDecodableShape {
        public let options: String
        public let status: OptionStatus

        @inlinable
        public init(options: String, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AnalysisOptions: AWSEncodableShape & AWSDecodableShape {
        /// The level of algorithmic stemming to perform: none, minimal, light, or full. The available levels vary depending on the language. For more information, see Language Specific Text Processing Settings in the Amazon CloudSearch Developer Guide
        public let algorithmicStemming: AlgorithmicStemming?
        /// A JSON array that contains a collection of terms, tokens, readings and part of speech for Japanese Tokenizaiton. The Japanese tokenization dictionary enables you to override the default tokenization for selected terms. This is only valid for Japanese language fields.
        public let japaneseTokenizationDictionary: String?
        /// A JSON object that contains a collection of string:value pairs that each map a term to its stem. For example, {"term1": "stem1", "term2": "stem2", "term3": "stem3"}. The stemming dictionary is applied in addition to any algorithmic stemming. This enables you to override the results of the algorithmic stemming to correct specific cases of overstemming or understemming. The maximum size of a stemming dictionary is 500 KB.
        public let stemmingDictionary: String?
        /// A  JSON array of terms to ignore during indexing and searching. For example, ["a", "an", "the", "of"]. The stopwords dictionary must explicitly list each word you want to ignore. Wildcards and regular expressions are not supported.
        public let stopwords: String?
        /// A JSON object that defines synonym groups and aliases. A synonym group is an array of arrays, where each sub-array is a group of terms where each term in the group is considered a synonym of every other term in the group. The aliases value is an object that contains a collection of string:value pairs where the string specifies a term and the array of values specifies each of the aliases for that term. An alias is considered a synonym of the specified term, but the term is not considered a synonym of the alias. For more information about specifying synonyms, see Synonyms in the Amazon CloudSearch Developer Guide.
        public let synonyms: String?

        @inlinable
        public init(algorithmicStemming: AlgorithmicStemming? = nil, japaneseTokenizationDictionary: String? = nil, stemmingDictionary: String? = nil, stopwords: String? = nil, synonyms: String? = nil) {
            self.algorithmicStemming = algorithmicStemming
            self.japaneseTokenizationDictionary = japaneseTokenizationDictionary
            self.stemmingDictionary = stemmingDictionary
            self.stopwords = stopwords
            self.synonyms = synonyms
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmicStemming = "AlgorithmicStemming"
            case japaneseTokenizationDictionary = "JapaneseTokenizationDictionary"
            case stemmingDictionary = "StemmingDictionary"
            case stopwords = "Stopwords"
            case synonyms = "Synonyms"
        }
    }

    public struct AnalysisScheme: AWSEncodableShape & AWSDecodableShape {
        public let analysisOptions: AnalysisOptions?
        public let analysisSchemeLanguage: AnalysisSchemeLanguage
        public let analysisSchemeName: String

        @inlinable
        public init(analysisOptions: AnalysisOptions? = nil, analysisSchemeLanguage: AnalysisSchemeLanguage, analysisSchemeName: String) {
            self.analysisOptions = analysisOptions
            self.analysisSchemeLanguage = analysisSchemeLanguage
            self.analysisSchemeName = analysisSchemeName
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisSchemeName, name: "analysisSchemeName", parent: name, max: 64)
            try self.validate(self.analysisSchemeName, name: "analysisSchemeName", parent: name, min: 1)
            try self.validate(self.analysisSchemeName, name: "analysisSchemeName", parent: name, pattern: "^[a-z][a-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisOptions = "AnalysisOptions"
            case analysisSchemeLanguage = "AnalysisSchemeLanguage"
            case analysisSchemeName = "AnalysisSchemeName"
        }
    }

    public struct AnalysisSchemeStatus: AWSDecodableShape {
        public let options: AnalysisScheme
        public let status: OptionStatus

        @inlinable
        public init(options: AnalysisScheme, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AvailabilityOptionsStatus: AWSDecodableShape {
        /// The availability options configured for the domain.
        public let options: Bool
        public let status: OptionStatus

        @inlinable
        public init(options: Bool, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct BaseException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct BuildSuggestersRequest: AWSEncodableShape {
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct BuildSuggestersResponse: AWSDecodableShape {
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var fieldNames: [String]?

        @inlinable
        public init(fieldNames: [String]? = nil) {
            self.fieldNames = fieldNames
        }

        private enum CodingKeys: String, CodingKey {
            case fieldNames = "FieldNames"
        }
    }

    public struct CreateDomainRequest: AWSEncodableShape {
        /// A name for the domain you are creating. Allowed characters are a-z (lower-case letters), 0-9, and hyphen (-). Domain names must start with a letter or number and be at least 3 and no more than 28 characters long.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct CreateDomainResponse: AWSDecodableShape {
        public let domainStatus: DomainStatus?

        @inlinable
        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatus = "DomainStatus"
        }
    }

    public struct DateArrayOptions: AWSEncodableShape & AWSDecodableShape {
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A list of source fields to map to the field.
        public let sourceFields: String?

        @inlinable
        public init(defaultValue: String? = nil, facetEnabled: Bool? = nil, returnEnabled: Bool? = nil, searchEnabled: Bool? = nil, sourceFields: String? = nil) {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 1024)
            try self.validate(self.sourceFields, name: "sourceFields", parent: name, pattern: "^\\s*[a-z*][a-z0-9_]*\\*?\\s*(,\\s*[a-z*][a-z0-9_]*\\*?\\s*)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case facetEnabled = "FacetEnabled"
            case returnEnabled = "ReturnEnabled"
            case searchEnabled = "SearchEnabled"
            case sourceFields = "SourceFields"
        }
    }

    public struct DateOptions: AWSEncodableShape & AWSDecodableShape {
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        public let sourceField: String?

        @inlinable
        public init(defaultValue: String? = nil, facetEnabled: Bool? = nil, returnEnabled: Bool? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, sourceField: String? = nil) {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 1024)
            try self.validate(self.sourceField, name: "sourceField", parent: name, max: 64)
            try self.validate(self.sourceField, name: "sourceField", parent: name, min: 1)
            try self.validate(self.sourceField, name: "sourceField", parent: name, pattern: "^[a-z][a-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case facetEnabled = "FacetEnabled"
            case returnEnabled = "ReturnEnabled"
            case searchEnabled = "SearchEnabled"
            case sortEnabled = "SortEnabled"
            case sourceField = "SourceField"
        }
    }

    public struct DefineAnalysisSchemeRequest: AWSEncodableShape {
        public let analysisScheme: AnalysisScheme
        public let domainName: String

        @inlinable
        public init(analysisScheme: AnalysisScheme, domainName: String) {
            self.analysisScheme = analysisScheme
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.analysisScheme.validate(name: "\(name).analysisScheme")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisScheme = "AnalysisScheme"
            case domainName = "DomainName"
        }
    }

    public struct DefineAnalysisSchemeResponse: AWSDecodableShape {
        public let analysisScheme: AnalysisSchemeStatus

        @inlinable
        public init(analysisScheme: AnalysisSchemeStatus) {
            self.analysisScheme = analysisScheme
        }

        private enum CodingKeys: String, CodingKey {
            case analysisScheme = "AnalysisScheme"
        }
    }

    public struct DefineExpressionRequest: AWSEncodableShape {
        public let domainName: String
        public let expression: Expression

        @inlinable
        public init(domainName: String, expression: Expression) {
            self.domainName = domainName
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.expression.validate(name: "\(name).expression")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case expression = "Expression"
        }
    }

    public struct DefineExpressionResponse: AWSDecodableShape {
        public let expression: ExpressionStatus

        @inlinable
        public init(expression: ExpressionStatus) {
            self.expression = expression
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
        }
    }

    public struct DefineIndexFieldRequest: AWSEncodableShape {
        public let domainName: String
        /// The index field and field options you want to configure.
        public let indexField: IndexField

        @inlinable
        public init(domainName: String, indexField: IndexField) {
            self.domainName = domainName
            self.indexField = indexField
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.indexField.validate(name: "\(name).indexField")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case indexField = "IndexField"
        }
    }

    public struct DefineIndexFieldResponse: AWSDecodableShape {
        public let indexField: IndexFieldStatus

        @inlinable
        public init(indexField: IndexFieldStatus) {
            self.indexField = indexField
        }

        private enum CodingKeys: String, CodingKey {
            case indexField = "IndexField"
        }
    }

    public struct DefineSuggesterRequest: AWSEncodableShape {
        public let domainName: String
        public let suggester: Suggester

        @inlinable
        public init(domainName: String, suggester: Suggester) {
            self.domainName = domainName
            self.suggester = suggester
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.suggester.validate(name: "\(name).suggester")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case suggester = "Suggester"
        }
    }

    public struct DefineSuggesterResponse: AWSDecodableShape {
        public let suggester: SuggesterStatus

        @inlinable
        public init(suggester: SuggesterStatus) {
            self.suggester = suggester
        }

        private enum CodingKeys: String, CodingKey {
            case suggester = "Suggester"
        }
    }

    public struct DeleteAnalysisSchemeRequest: AWSEncodableShape {
        /// The name of the analysis scheme you want to delete.
        public let analysisSchemeName: String
        public let domainName: String

        @inlinable
        public init(analysisSchemeName: String, domainName: String) {
            self.analysisSchemeName = analysisSchemeName
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisSchemeName, name: "analysisSchemeName", parent: name, max: 64)
            try self.validate(self.analysisSchemeName, name: "analysisSchemeName", parent: name, min: 1)
            try self.validate(self.analysisSchemeName, name: "analysisSchemeName", parent: name, pattern: "^[a-z][a-z0-9_]*$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSchemeName = "AnalysisSchemeName"
            case domainName = "DomainName"
        }
    }

    public struct DeleteAnalysisSchemeResponse: AWSDecodableShape {
        /// The status of the analysis scheme being deleted.
        public let analysisScheme: AnalysisSchemeStatus

        @inlinable
        public init(analysisScheme: AnalysisSchemeStatus) {
            self.analysisScheme = analysisScheme
        }

        private enum CodingKeys: String, CodingKey {
            case analysisScheme = "AnalysisScheme"
        }
    }

    public struct DeleteDomainRequest: AWSEncodableShape {
        /// The name of the domain you want to permanently delete.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct DeleteDomainResponse: AWSDecodableShape {
        public let domainStatus: DomainStatus?

        @inlinable
        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatus = "DomainStatus"
        }
    }

    public struct DeleteExpressionRequest: AWSEncodableShape {
        public let domainName: String
        /// The name of the Expression to delete.
        public let expressionName: String

        @inlinable
        public init(domainName: String, expressionName: String) {
            self.domainName = domainName
            self.expressionName = expressionName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.expressionName, name: "expressionName", parent: name, max: 64)
            try self.validate(self.expressionName, name: "expressionName", parent: name, min: 1)
            try self.validate(self.expressionName, name: "expressionName", parent: name, pattern: "^[a-z][a-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case expressionName = "ExpressionName"
        }
    }

    public struct DeleteExpressionResponse: AWSDecodableShape {
        /// The status of the expression being deleted.
        public let expression: ExpressionStatus

        @inlinable
        public init(expression: ExpressionStatus) {
            self.expression = expression
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
        }
    }

    public struct DeleteIndexFieldRequest: AWSEncodableShape {
        public let domainName: String
        /// The name of the index field your want to remove from the domain's indexing options.
        public let indexFieldName: String

        @inlinable
        public init(domainName: String, indexFieldName: String) {
            self.domainName = domainName
            self.indexFieldName = indexFieldName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.indexFieldName, name: "indexFieldName", parent: name, max: 64)
            try self.validate(self.indexFieldName, name: "indexFieldName", parent: name, min: 1)
            try self.validate(self.indexFieldName, name: "indexFieldName", parent: name, pattern: "^([a-z][a-z0-9_]*\\*?|\\*[a-z0-9_]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case indexFieldName = "IndexFieldName"
        }
    }

    public struct DeleteIndexFieldResponse: AWSDecodableShape {
        /// The status of the index field being deleted.
        public let indexField: IndexFieldStatus

        @inlinable
        public init(indexField: IndexFieldStatus) {
            self.indexField = indexField
        }

        private enum CodingKeys: String, CodingKey {
            case indexField = "IndexField"
        }
    }

    public struct DeleteSuggesterRequest: AWSEncodableShape {
        public let domainName: String
        /// Specifies the name of the suggester you want to delete.
        public let suggesterName: String

        @inlinable
        public init(domainName: String, suggesterName: String) {
            self.domainName = domainName
            self.suggesterName = suggesterName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.suggesterName, name: "suggesterName", parent: name, max: 64)
            try self.validate(self.suggesterName, name: "suggesterName", parent: name, min: 1)
            try self.validate(self.suggesterName, name: "suggesterName", parent: name, pattern: "^[a-z][a-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case suggesterName = "SuggesterName"
        }
    }

    public struct DeleteSuggesterResponse: AWSDecodableShape {
        /// The status of the suggester being deleted.
        public let suggester: SuggesterStatus

        @inlinable
        public init(suggester: SuggesterStatus) {
            self.suggester = suggester
        }

        private enum CodingKeys: String, CodingKey {
            case suggester = "Suggester"
        }
    }

    public struct DescribeAnalysisSchemesRequest: AWSEncodableShape {
        /// The analysis schemes you want to describe.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var analysisSchemeNames: [String]?
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String

        @inlinable
        public init(analysisSchemeNames: [String]? = nil, deployed: Bool? = nil, domainName: String) {
            self.analysisSchemeNames = analysisSchemeNames
            self.deployed = deployed
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.analysisSchemeNames?.forEach {
                try validate($0, name: "analysisSchemeNames[]", parent: name, max: 64)
                try validate($0, name: "analysisSchemeNames[]", parent: name, min: 1)
                try validate($0, name: "analysisSchemeNames[]", parent: name, pattern: "^[a-z][a-z0-9_]*$")
            }
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSchemeNames = "AnalysisSchemeNames"
            case deployed = "Deployed"
            case domainName = "DomainName"
        }
    }

    public struct DescribeAnalysisSchemesResponse: AWSDecodableShape {
        /// The analysis scheme descriptions.
        @CustomCoding<StandardArrayCoder<AnalysisSchemeStatus>>
        public var analysisSchemes: [AnalysisSchemeStatus]

        @inlinable
        public init(analysisSchemes: [AnalysisSchemeStatus]) {
            self.analysisSchemes = analysisSchemes
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSchemes = "AnalysisSchemes"
        }
    }

    public struct DescribeAvailabilityOptionsRequest: AWSEncodableShape {
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String

        @inlinable
        public init(deployed: Bool? = nil, domainName: String) {
            self.deployed = deployed
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deployed = "Deployed"
            case domainName = "DomainName"
        }
    }

    public struct DescribeAvailabilityOptionsResponse: AWSDecodableShape {
        /// The availability options configured for the domain. Indicates whether Multi-AZ is enabled for the domain.
        public let availabilityOptions: AvailabilityOptionsStatus?

        @inlinable
        public init(availabilityOptions: AvailabilityOptionsStatus? = nil) {
            self.availabilityOptions = availabilityOptions
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityOptions = "AvailabilityOptions"
        }
    }

    public struct DescribeDomainEndpointOptionsRequest: AWSEncodableShape {
        /// Whether to retrieve the latest configuration (which might be in a Processing state) or the current, active configuration. Defaults to false.
        public let deployed: Bool?
        /// A string that represents the name of a domain.
        public let domainName: String

        @inlinable
        public init(deployed: Bool? = nil, domainName: String) {
            self.deployed = deployed
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deployed = "Deployed"
            case domainName = "DomainName"
        }
    }

    public struct DescribeDomainEndpointOptionsResponse: AWSDecodableShape {
        /// The status and configuration of a search domain's endpoint options.
        public let domainEndpointOptions: DomainEndpointOptionsStatus?

        @inlinable
        public init(domainEndpointOptions: DomainEndpointOptionsStatus? = nil) {
            self.domainEndpointOptions = domainEndpointOptions
        }

        private enum CodingKeys: String, CodingKey {
            case domainEndpointOptions = "DomainEndpointOptions"
        }
    }

    public struct DescribeDomainsRequest: AWSEncodableShape {
        /// The names of the domains you want to include in the response.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var domainNames: [String]?

        @inlinable
        public init(domainNames: [String]? = nil) {
            self.domainNames = domainNames
        }

        public func validate(name: String) throws {
            try self.domainNames?.forEach {
                try validate($0, name: "domainNames[]", parent: name, max: 28)
                try validate($0, name: "domainNames[]", parent: name, min: 3)
                try validate($0, name: "domainNames[]", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domainNames = "DomainNames"
        }
    }

    public struct DescribeDomainsResponse: AWSDecodableShape {
        @CustomCoding<StandardArrayCoder<DomainStatus>>
        public var domainStatusList: [DomainStatus]

        @inlinable
        public init(domainStatusList: [DomainStatus]) {
            self.domainStatusList = domainStatusList
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatusList = "DomainStatusList"
        }
    }

    public struct DescribeExpressionsRequest: AWSEncodableShape {
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String
        /// Limits the DescribeExpressions response to the specified expressions. If not specified, all expressions are shown.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var expressionNames: [String]?

        @inlinable
        public init(deployed: Bool? = nil, domainName: String, expressionNames: [String]? = nil) {
            self.deployed = deployed
            self.domainName = domainName
            self.expressionNames = expressionNames
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.expressionNames?.forEach {
                try validate($0, name: "expressionNames[]", parent: name, max: 64)
                try validate($0, name: "expressionNames[]", parent: name, min: 1)
                try validate($0, name: "expressionNames[]", parent: name, pattern: "^[a-z][a-z0-9_]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deployed = "Deployed"
            case domainName = "DomainName"
            case expressionNames = "ExpressionNames"
        }
    }

    public struct DescribeExpressionsResponse: AWSDecodableShape {
        /// The expressions configured for the domain.
        @CustomCoding<StandardArrayCoder<ExpressionStatus>>
        public var expressions: [ExpressionStatus]

        @inlinable
        public init(expressions: [ExpressionStatus]) {
            self.expressions = expressions
        }

        private enum CodingKeys: String, CodingKey {
            case expressions = "Expressions"
        }
    }

    public struct DescribeIndexFieldsRequest: AWSEncodableShape {
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String
        /// A list of the index fields you want to describe. If not specified, information is returned for all configured index fields.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var fieldNames: [String]?

        @inlinable
        public init(deployed: Bool? = nil, domainName: String, fieldNames: [String]? = nil) {
            self.deployed = deployed
            self.domainName = domainName
            self.fieldNames = fieldNames
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.fieldNames?.forEach {
                try validate($0, name: "fieldNames[]", parent: name, max: 64)
                try validate($0, name: "fieldNames[]", parent: name, min: 1)
                try validate($0, name: "fieldNames[]", parent: name, pattern: "^([a-z][a-z0-9_]*\\*?|\\*[a-z0-9_]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deployed = "Deployed"
            case domainName = "DomainName"
            case fieldNames = "FieldNames"
        }
    }

    public struct DescribeIndexFieldsResponse: AWSDecodableShape {
        /// The index fields configured for the domain.
        @CustomCoding<StandardArrayCoder<IndexFieldStatus>>
        public var indexFields: [IndexFieldStatus]

        @inlinable
        public init(indexFields: [IndexFieldStatus]) {
            self.indexFields = indexFields
        }

        private enum CodingKeys: String, CodingKey {
            case indexFields = "IndexFields"
        }
    }

    public struct DescribeScalingParametersRequest: AWSEncodableShape {
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct DescribeScalingParametersResponse: AWSDecodableShape {
        public let scalingParameters: ScalingParametersStatus

        @inlinable
        public init(scalingParameters: ScalingParametersStatus) {
            self.scalingParameters = scalingParameters
        }

        private enum CodingKeys: String, CodingKey {
            case scalingParameters = "ScalingParameters"
        }
    }

    public struct DescribeServiceAccessPoliciesRequest: AWSEncodableShape {
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String

        @inlinable
        public init(deployed: Bool? = nil, domainName: String) {
            self.deployed = deployed
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deployed = "Deployed"
            case domainName = "DomainName"
        }
    }

    public struct DescribeServiceAccessPoliciesResponse: AWSDecodableShape {
        /// The access rules configured for the domain specified in the request.
        public let accessPolicies: AccessPoliciesStatus

        @inlinable
        public init(accessPolicies: AccessPoliciesStatus) {
            self.accessPolicies = accessPolicies
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
        }
    }

    public struct DescribeSuggestersRequest: AWSEncodableShape {
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String
        /// The suggesters you want to describe.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var suggesterNames: [String]?

        @inlinable
        public init(deployed: Bool? = nil, domainName: String, suggesterNames: [String]? = nil) {
            self.deployed = deployed
            self.domainName = domainName
            self.suggesterNames = suggesterNames
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.suggesterNames?.forEach {
                try validate($0, name: "suggesterNames[]", parent: name, max: 64)
                try validate($0, name: "suggesterNames[]", parent: name, min: 1)
                try validate($0, name: "suggesterNames[]", parent: name, pattern: "^[a-z][a-z0-9_]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deployed = "Deployed"
            case domainName = "DomainName"
            case suggesterNames = "SuggesterNames"
        }
    }

    public struct DescribeSuggestersResponse: AWSDecodableShape {
        /// The suggesters configured for the domain specified in the request.
        @CustomCoding<StandardArrayCoder<SuggesterStatus>>
        public var suggesters: [SuggesterStatus]

        @inlinable
        public init(suggesters: [SuggesterStatus]) {
            self.suggesters = suggesters
        }

        private enum CodingKeys: String, CodingKey {
            case suggesters = "Suggesters"
        }
    }

    public struct DisabledOperationException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct DocumentSuggesterOptions: AWSEncodableShape & AWSDecodableShape {
        /// The level of fuzziness allowed when suggesting matches for a string: none, low, or high. With none, the specified string is treated as an exact prefix. With low, suggestions must differ from the specified string by no more than one character. With high, suggestions can differ by up to two characters. The default is none.
        public let fuzzyMatching: SuggesterFuzzyMatching?
        /// An expression that computes a score for each suggestion to control how they are sorted. The scores are rounded to the nearest integer, with a floor of 0 and a ceiling of 2^31-1. A document's relevance score is not computed for suggestions, so sort expressions cannot reference the _score value. To sort suggestions using a numeric field or existing expression, simply specify the name of the field or expression. If no expression is configured for the suggester, the suggestions are sorted with the closest matches listed first.
        public let sortExpression: String?
        /// The name of the index field you want to use for suggestions.
        public let sourceField: String

        @inlinable
        public init(fuzzyMatching: SuggesterFuzzyMatching? = nil, sortExpression: String? = nil, sourceField: String) {
            self.fuzzyMatching = fuzzyMatching
            self.sortExpression = sortExpression
            self.sourceField = sourceField
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceField, name: "sourceField", parent: name, max: 64)
            try self.validate(self.sourceField, name: "sourceField", parent: name, min: 1)
            try self.validate(self.sourceField, name: "sourceField", parent: name, pattern: "^[a-z][a-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case fuzzyMatching = "FuzzyMatching"
            case sortExpression = "SortExpression"
            case sourceField = "SourceField"
        }
    }

    public struct DomainEndpointOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether the domain is HTTPS only enabled.
        public let enforceHTTPS: Bool?
        /// The minimum required TLS version
        public let tlsSecurityPolicy: TLSSecurityPolicy?

        @inlinable
        public init(enforceHTTPS: Bool? = nil, tlsSecurityPolicy: TLSSecurityPolicy? = nil) {
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case enforceHTTPS = "EnforceHTTPS"
            case tlsSecurityPolicy = "TLSSecurityPolicy"
        }
    }

    public struct DomainEndpointOptionsStatus: AWSDecodableShape {
        /// The domain endpoint options configured for the domain.
        public let options: DomainEndpointOptions
        /// The status of the configured domain endpoint options.
        public let status: OptionStatus

        @inlinable
        public init(options: DomainEndpointOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct DomainStatus: AWSDecodableShape {
        public let arn: String?
        /// True if the search domain is created. It can take several minutes to initialize a domain when CreateDomain is called. Newly created search domains are returned from DescribeDomains with a false value for Created until domain creation is complete.
        public let created: Bool?
        /// True if the search domain has been deleted.  The system must clean up resources dedicated to the search domain when DeleteDomain is called.  Newly deleted search domains are returned from DescribeDomains with a true value for IsDeleted for several minutes until resource cleanup is complete.
        public let deleted: Bool?
        /// The service endpoint for updating documents in a search domain.
        public let docService: ServiceEndpoint?
        public let domainId: String
        public let domainName: String
        public let limits: Limits?
        /// True if processing is being done to activate the current domain configuration.
        public let processing: Bool?
        /// True if IndexDocuments needs to be called to activate the current domain configuration.
        public let requiresIndexDocuments: Bool
        /// The number of search instances that are available to process search requests.
        public let searchInstanceCount: Int?
        /// The instance type that is being used to process search requests.
        public let searchInstanceType: String?
        /// The number of partitions across which the search index is spread.
        public let searchPartitionCount: Int?
        /// The service endpoint for requesting search results from a search domain.
        public let searchService: ServiceEndpoint?

        @inlinable
        public init(arn: String? = nil, created: Bool? = nil, deleted: Bool? = nil, docService: ServiceEndpoint? = nil, domainId: String, domainName: String, limits: Limits? = nil, processing: Bool? = nil, requiresIndexDocuments: Bool, searchInstanceCount: Int? = nil, searchInstanceType: String? = nil, searchPartitionCount: Int? = nil, searchService: ServiceEndpoint? = nil) {
            self.arn = arn
            self.created = created
            self.deleted = deleted
            self.docService = docService
            self.domainId = domainId
            self.domainName = domainName
            self.limits = limits
            self.processing = processing
            self.requiresIndexDocuments = requiresIndexDocuments
            self.searchInstanceCount = searchInstanceCount
            self.searchInstanceType = searchInstanceType
            self.searchPartitionCount = searchPartitionCount
            self.searchService = searchService
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "ARN"
            case created = "Created"
            case deleted = "Deleted"
            case docService = "DocService"
            case domainId = "DomainId"
            case domainName = "DomainName"
            case limits = "Limits"
            case processing = "Processing"
            case requiresIndexDocuments = "RequiresIndexDocuments"
            case searchInstanceCount = "SearchInstanceCount"
            case searchInstanceType = "SearchInstanceType"
            case searchPartitionCount = "SearchPartitionCount"
            case searchService = "SearchService"
        }
    }

    public struct DoubleArrayOptions: AWSEncodableShape & AWSDecodableShape {
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: Double?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A list of source fields to map to the field.
        public let sourceFields: String?

        @inlinable
        public init(defaultValue: Double? = nil, facetEnabled: Bool? = nil, returnEnabled: Bool? = nil, searchEnabled: Bool? = nil, sourceFields: String? = nil) {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceFields, name: "sourceFields", parent: name, pattern: "^\\s*[a-z*][a-z0-9_]*\\*?\\s*(,\\s*[a-z*][a-z0-9_]*\\*?\\s*)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case facetEnabled = "FacetEnabled"
            case returnEnabled = "ReturnEnabled"
            case searchEnabled = "SearchEnabled"
            case sourceFields = "SourceFields"
        }
    }

    public struct DoubleOptions: AWSEncodableShape & AWSDecodableShape {
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public let defaultValue: Double?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// The name of the source field to map to the field.
        public let sourceField: String?

        @inlinable
        public init(defaultValue: Double? = nil, facetEnabled: Bool? = nil, returnEnabled: Bool? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, sourceField: String? = nil) {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceField, name: "sourceField", parent: name, max: 64)
            try self.validate(self.sourceField, name: "sourceField", parent: name, min: 1)
            try self.validate(self.sourceField, name: "sourceField", parent: name, pattern: "^[a-z][a-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case facetEnabled = "FacetEnabled"
            case returnEnabled = "ReturnEnabled"
            case searchEnabled = "SearchEnabled"
            case sortEnabled = "SortEnabled"
            case sourceField = "SourceField"
        }
    }

    public struct Expression: AWSEncodableShape & AWSDecodableShape {
        public let expressionName: String
        public let expressionValue: String

        @inlinable
        public init(expressionName: String, expressionValue: String) {
            self.expressionName = expressionName
            self.expressionValue = expressionValue
        }

        public func validate(name: String) throws {
            try self.validate(self.expressionName, name: "expressionName", parent: name, max: 64)
            try self.validate(self.expressionName, name: "expressionName", parent: name, min: 1)
            try self.validate(self.expressionName, name: "expressionName", parent: name, pattern: "^[a-z][a-z0-9_]*$")
            try self.validate(self.expressionValue, name: "expressionValue", parent: name, max: 10240)
            try self.validate(self.expressionValue, name: "expressionValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case expressionName = "ExpressionName"
            case expressionValue = "ExpressionValue"
        }
    }

    public struct ExpressionStatus: AWSDecodableShape {
        /// The expression that is evaluated for sorting while processing a search request.
        public let options: Expression
        public let status: OptionStatus

        @inlinable
        public init(options: Expression, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct IndexDocumentsRequest: AWSEncodableShape {
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct IndexDocumentsResponse: AWSDecodableShape {
        /// The names of the fields that are currently being indexed.
        @OptionalCustomCoding<StandardArrayCoder<String>>
        public var fieldNames: [String]?

        @inlinable
        public init(fieldNames: [String]? = nil) {
            self.fieldNames = fieldNames
        }

        private enum CodingKeys: String, CodingKey {
            case fieldNames = "FieldNames"
        }
    }

    public struct IndexField: AWSEncodableShape & AWSDecodableShape {
        public let dateArrayOptions: DateArrayOptions?
        public let dateOptions: DateOptions?
        public let doubleArrayOptions: DoubleArrayOptions?
        public let doubleOptions: DoubleOptions?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a	 dynamic field's pattern are configured with the dynamic field's indexing options.  Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported.  The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public let indexFieldName: String
        public let indexFieldType: IndexFieldType
        public let intArrayOptions: IntArrayOptions?
        public let intOptions: IntOptions?
        public let latLonOptions: LatLonOptions?
        public let literalArrayOptions: LiteralArrayOptions?
        public let literalOptions: LiteralOptions?
        public let textArrayOptions: TextArrayOptions?
        public let textOptions: TextOptions?

        @inlinable
        public init(dateArrayOptions: DateArrayOptions? = nil, dateOptions: DateOptions? = nil, doubleArrayOptions: DoubleArrayOptions? = nil, doubleOptions: DoubleOptions? = nil, indexFieldName: String, indexFieldType: IndexFieldType, intArrayOptions: IntArrayOptions? = nil, intOptions: IntOptions? = nil, latLonOptions: LatLonOptions? = nil, literalArrayOptions: LiteralArrayOptions? = nil, literalOptions: LiteralOptions? = nil, textArrayOptions: TextArrayOptions? = nil, textOptions: TextOptions? = nil) {
            self.dateArrayOptions = dateArrayOptions
            self.dateOptions = dateOptions
            self.doubleArrayOptions = doubleArrayOptions
            self.doubleOptions = doubleOptions
            self.indexFieldName = indexFieldName
            self.indexFieldType = indexFieldType
            self.intArrayOptions = intArrayOptions
            self.intOptions = intOptions
            self.latLonOptions = latLonOptions
            self.literalArrayOptions = literalArrayOptions
            self.literalOptions = literalOptions
            self.textArrayOptions = textArrayOptions
            self.textOptions = textOptions
        }

        public func validate(name: String) throws {
            try self.dateArrayOptions?.validate(name: "\(name).dateArrayOptions")
            try self.dateOptions?.validate(name: "\(name).dateOptions")
            try self.doubleArrayOptions?.validate(name: "\(name).doubleArrayOptions")
            try self.doubleOptions?.validate(name: "\(name).doubleOptions")
            try self.validate(self.indexFieldName, name: "indexFieldName", parent: name, max: 64)
            try self.validate(self.indexFieldName, name: "indexFieldName", parent: name, min: 1)
            try self.validate(self.indexFieldName, name: "indexFieldName", parent: name, pattern: "^([a-z][a-z0-9_]*\\*?|\\*[a-z0-9_]*)$")
            try self.intArrayOptions?.validate(name: "\(name).intArrayOptions")
            try self.intOptions?.validate(name: "\(name).intOptions")
            try self.latLonOptions?.validate(name: "\(name).latLonOptions")
            try self.literalArrayOptions?.validate(name: "\(name).literalArrayOptions")
            try self.literalOptions?.validate(name: "\(name).literalOptions")
            try self.textArrayOptions?.validate(name: "\(name).textArrayOptions")
            try self.textOptions?.validate(name: "\(name).textOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case dateArrayOptions = "DateArrayOptions"
            case dateOptions = "DateOptions"
            case doubleArrayOptions = "DoubleArrayOptions"
            case doubleOptions = "DoubleOptions"
            case indexFieldName = "IndexFieldName"
            case indexFieldType = "IndexFieldType"
            case intArrayOptions = "IntArrayOptions"
            case intOptions = "IntOptions"
            case latLonOptions = "LatLonOptions"
            case literalArrayOptions = "LiteralArrayOptions"
            case literalOptions = "LiteralOptions"
            case textArrayOptions = "TextArrayOptions"
            case textOptions = "TextOptions"
        }
    }

    public struct IndexFieldStatus: AWSDecodableShape {
        public let options: IndexField
        public let status: OptionStatus

        @inlinable
        public init(options: IndexField, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct IntArrayOptions: AWSEncodableShape & AWSDecodableShape {
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: Int64?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A list of source fields to map to the field.
        public let sourceFields: String?

        @inlinable
        public init(defaultValue: Int64? = nil, facetEnabled: Bool? = nil, returnEnabled: Bool? = nil, searchEnabled: Bool? = nil, sourceFields: String? = nil) {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceFields, name: "sourceFields", parent: name, pattern: "^\\s*[a-z*][a-z0-9_]*\\*?\\s*(,\\s*[a-z*][a-z0-9_]*\\*?\\s*)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case facetEnabled = "FacetEnabled"
            case returnEnabled = "ReturnEnabled"
            case searchEnabled = "SearchEnabled"
            case sourceFields = "SourceFields"
        }
    }

    public struct IntOptions: AWSEncodableShape & AWSDecodableShape {
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public let defaultValue: Int64?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// The name of the source field to map to the field.
        public let sourceField: String?

        @inlinable
        public init(defaultValue: Int64? = nil, facetEnabled: Bool? = nil, returnEnabled: Bool? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, sourceField: String? = nil) {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceField, name: "sourceField", parent: name, max: 64)
            try self.validate(self.sourceField, name: "sourceField", parent: name, min: 1)
            try self.validate(self.sourceField, name: "sourceField", parent: name, pattern: "^[a-z][a-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case facetEnabled = "FacetEnabled"
            case returnEnabled = "ReturnEnabled"
            case searchEnabled = "SearchEnabled"
            case sortEnabled = "SortEnabled"
            case sourceField = "SourceField"
        }
    }

    public struct InternalException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct InvalidTypeException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct LatLonOptions: AWSEncodableShape & AWSDecodableShape {
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        public let sourceField: String?

        @inlinable
        public init(defaultValue: String? = nil, facetEnabled: Bool? = nil, returnEnabled: Bool? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, sourceField: String? = nil) {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 1024)
            try self.validate(self.sourceField, name: "sourceField", parent: name, max: 64)
            try self.validate(self.sourceField, name: "sourceField", parent: name, min: 1)
            try self.validate(self.sourceField, name: "sourceField", parent: name, pattern: "^[a-z][a-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case facetEnabled = "FacetEnabled"
            case returnEnabled = "ReturnEnabled"
            case searchEnabled = "SearchEnabled"
            case sortEnabled = "SortEnabled"
            case sourceField = "SourceField"
        }
    }

    public struct LimitExceededException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct Limits: AWSDecodableShape {
        public let maximumPartitionCount: Int
        public let maximumReplicationCount: Int

        @inlinable
        public init(maximumPartitionCount: Int, maximumReplicationCount: Int) {
            self.maximumPartitionCount = maximumPartitionCount
            self.maximumReplicationCount = maximumReplicationCount
        }

        private enum CodingKeys: String, CodingKey {
            case maximumPartitionCount = "MaximumPartitionCount"
            case maximumReplicationCount = "MaximumReplicationCount"
        }
    }

    public struct ListDomainNamesResponse: AWSDecodableShape {
        /// The names of the search domains owned by an account.
        @OptionalCustomCoding<StandardDictionaryCoder<String, String>>
        public var domainNames: [String: String]?

        @inlinable
        public init(domainNames: [String: String]? = nil) {
            self.domainNames = domainNames
        }

        private enum CodingKeys: String, CodingKey {
            case domainNames = "DomainNames"
        }
    }

    public struct LiteralArrayOptions: AWSEncodableShape & AWSDecodableShape {
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A list of source fields to map to the field.
        public let sourceFields: String?

        @inlinable
        public init(defaultValue: String? = nil, facetEnabled: Bool? = nil, returnEnabled: Bool? = nil, searchEnabled: Bool? = nil, sourceFields: String? = nil) {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 1024)
            try self.validate(self.sourceFields, name: "sourceFields", parent: name, pattern: "^\\s*[a-z*][a-z0-9_]*\\*?\\s*(,\\s*[a-z*][a-z0-9_]*\\*?\\s*)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case facetEnabled = "FacetEnabled"
            case returnEnabled = "ReturnEnabled"
            case searchEnabled = "SearchEnabled"
            case sourceFields = "SourceFields"
        }
    }

    public struct LiteralOptions: AWSEncodableShape & AWSDecodableShape {
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        public let sourceField: String?

        @inlinable
        public init(defaultValue: String? = nil, facetEnabled: Bool? = nil, returnEnabled: Bool? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, sourceField: String? = nil) {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 1024)
            try self.validate(self.sourceField, name: "sourceField", parent: name, max: 64)
            try self.validate(self.sourceField, name: "sourceField", parent: name, min: 1)
            try self.validate(self.sourceField, name: "sourceField", parent: name, pattern: "^[a-z][a-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case facetEnabled = "FacetEnabled"
            case returnEnabled = "ReturnEnabled"
            case searchEnabled = "SearchEnabled"
            case sortEnabled = "SortEnabled"
            case sourceField = "SourceField"
        }
    }

    public struct OptionStatus: AWSDecodableShape {
        /// A timestamp for when this option was created.
        public let creationDate: Date
        /// Indicates that the option will be deleted once processing is complete.
        public let pendingDeletion: Bool?
        /// The state of processing a change to an option.  Possible values: RequiresIndexDocuments: the option's latest value will not be deployed until  IndexDocuments has been called and indexing is complete. Processing: the option's latest value is in the process of being activated.   Active: the option's latest value is completely deployed. FailedToValidate: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.
        public let state: OptionState
        /// A timestamp for when this option was last updated.
        public let updateDate: Date
        /// A unique integer that indicates when this option was last updated.
        public let updateVersion: Int?

        @inlinable
        public init(creationDate: Date, pendingDeletion: Bool? = nil, state: OptionState, updateDate: Date, updateVersion: Int? = nil) {
            self.creationDate = creationDate
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case pendingDeletion = "PendingDeletion"
            case state = "State"
            case updateDate = "UpdateDate"
            case updateVersion = "UpdateVersion"
        }
    }

    public struct ResourceAlreadyExistsException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct ScalingParameters: AWSEncodableShape & AWSDecodableShape {
        /// The instance type that you want to preconfigure for your domain. For example, search.m1.small.
        public let desiredInstanceType: PartitionInstanceType?
        /// The number of partitions you want to preconfigure for your domain. Only valid when you select m2.2xlarge as the desired instance type.
        public let desiredPartitionCount: Int?
        /// The number of replicas you want to preconfigure for each index partition.
        public let desiredReplicationCount: Int?

        @inlinable
        public init(desiredInstanceType: PartitionInstanceType? = nil, desiredPartitionCount: Int? = nil, desiredReplicationCount: Int? = nil) {
            self.desiredInstanceType = desiredInstanceType
            self.desiredPartitionCount = desiredPartitionCount
            self.desiredReplicationCount = desiredReplicationCount
        }

        public func validate(name: String) throws {
            try self.validate(self.desiredPartitionCount, name: "desiredPartitionCount", parent: name, min: 0)
            try self.validate(self.desiredReplicationCount, name: "desiredReplicationCount", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case desiredInstanceType = "DesiredInstanceType"
            case desiredPartitionCount = "DesiredPartitionCount"
            case desiredReplicationCount = "DesiredReplicationCount"
        }
    }

    public struct ScalingParametersStatus: AWSDecodableShape {
        public let options: ScalingParameters
        public let status: OptionStatus

        @inlinable
        public init(options: ScalingParameters, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct ServiceEndpoint: AWSDecodableShape {
        public let endpoint: String?

        @inlinable
        public init(endpoint: String? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct Suggester: AWSEncodableShape & AWSDecodableShape {
        public let documentSuggesterOptions: DocumentSuggesterOptions
        public let suggesterName: String

        @inlinable
        public init(documentSuggesterOptions: DocumentSuggesterOptions, suggesterName: String) {
            self.documentSuggesterOptions = documentSuggesterOptions
            self.suggesterName = suggesterName
        }

        public func validate(name: String) throws {
            try self.documentSuggesterOptions.validate(name: "\(name).documentSuggesterOptions")
            try self.validate(self.suggesterName, name: "suggesterName", parent: name, max: 64)
            try self.validate(self.suggesterName, name: "suggesterName", parent: name, min: 1)
            try self.validate(self.suggesterName, name: "suggesterName", parent: name, pattern: "^[a-z][a-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case documentSuggesterOptions = "DocumentSuggesterOptions"
            case suggesterName = "SuggesterName"
        }
    }

    public struct SuggesterStatus: AWSDecodableShape {
        public let options: Suggester
        public let status: OptionStatus

        @inlinable
        public init(options: Suggester, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct TextArrayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The name of an analysis scheme for a  text-array field.
        public let analysisScheme: String?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?
        /// Whether highlights can be returned for the field.
        public let highlightEnabled: Bool?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// A list of source fields to map to the field.
        public let sourceFields: String?

        @inlinable
        public init(analysisScheme: String? = nil, defaultValue: String? = nil, highlightEnabled: Bool? = nil, returnEnabled: Bool? = nil, sourceFields: String? = nil) {
            self.analysisScheme = analysisScheme
            self.defaultValue = defaultValue
            self.highlightEnabled = highlightEnabled
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisScheme, name: "analysisScheme", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 1024)
            try self.validate(self.sourceFields, name: "sourceFields", parent: name, pattern: "^\\s*[a-z*][a-z0-9_]*\\*?\\s*(,\\s*[a-z*][a-z0-9_]*\\*?\\s*)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisScheme = "AnalysisScheme"
            case defaultValue = "DefaultValue"
            case highlightEnabled = "HighlightEnabled"
            case returnEnabled = "ReturnEnabled"
            case sourceFields = "SourceFields"
        }
    }

    public struct TextOptions: AWSEncodableShape & AWSDecodableShape {
        /// The name of an analysis scheme for a  text field.
        public let analysisScheme: String?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?
        /// Whether highlights can be returned for the field.
        public let highlightEnabled: Bool?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        public let sourceField: String?

        @inlinable
        public init(analysisScheme: String? = nil, defaultValue: String? = nil, highlightEnabled: Bool? = nil, returnEnabled: Bool? = nil, sortEnabled: Bool? = nil, sourceField: String? = nil) {
            self.analysisScheme = analysisScheme
            self.defaultValue = defaultValue
            self.highlightEnabled = highlightEnabled
            self.returnEnabled = returnEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisScheme, name: "analysisScheme", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 1024)
            try self.validate(self.sourceField, name: "sourceField", parent: name, max: 64)
            try self.validate(self.sourceField, name: "sourceField", parent: name, min: 1)
            try self.validate(self.sourceField, name: "sourceField", parent: name, pattern: "^[a-z][a-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisScheme = "AnalysisScheme"
            case defaultValue = "DefaultValue"
            case highlightEnabled = "HighlightEnabled"
            case returnEnabled = "ReturnEnabled"
            case sortEnabled = "SortEnabled"
            case sourceField = "SourceField"
        }
    }

    public struct UpdateAvailabilityOptionsRequest: AWSEncodableShape {
        public let domainName: String
        /// You expand an existing search domain to a second Availability Zone by setting the Multi-AZ option to true. Similarly, you can turn off the Multi-AZ option to downgrade the domain to a single Availability Zone by setting the Multi-AZ option to false.
        public let multiAZ: Bool

        @inlinable
        public init(domainName: String, multiAZ: Bool) {
            self.domainName = domainName
            self.multiAZ = multiAZ
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case multiAZ = "MultiAZ"
        }
    }

    public struct UpdateAvailabilityOptionsResponse: AWSDecodableShape {
        /// The newly-configured availability options. Indicates whether Multi-AZ is enabled for the domain.
        public let availabilityOptions: AvailabilityOptionsStatus?

        @inlinable
        public init(availabilityOptions: AvailabilityOptionsStatus? = nil) {
            self.availabilityOptions = availabilityOptions
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityOptions = "AvailabilityOptions"
        }
    }

    public struct UpdateDomainEndpointOptionsRequest: AWSEncodableShape {
        /// Whether to require that all requests to the domain arrive over HTTPS. We recommend Policy-Min-TLS-1-2-2019-07 for TLSSecurityPolicy. For compatibility with older clients, the default is Policy-Min-TLS-1-0-2019-07.
        public let domainEndpointOptions: DomainEndpointOptions
        /// A string that represents the name of a domain.
        public let domainName: String

        @inlinable
        public init(domainEndpointOptions: DomainEndpointOptions, domainName: String) {
            self.domainEndpointOptions = domainEndpointOptions
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainEndpointOptions = "DomainEndpointOptions"
            case domainName = "DomainName"
        }
    }

    public struct UpdateDomainEndpointOptionsResponse: AWSDecodableShape {
        /// The newly-configured domain endpoint options.
        public let domainEndpointOptions: DomainEndpointOptionsStatus?

        @inlinable
        public init(domainEndpointOptions: DomainEndpointOptionsStatus? = nil) {
            self.domainEndpointOptions = domainEndpointOptions
        }

        private enum CodingKeys: String, CodingKey {
            case domainEndpointOptions = "DomainEndpointOptions"
        }
    }

    public struct UpdateScalingParametersRequest: AWSEncodableShape {
        public let domainName: String
        public let scalingParameters: ScalingParameters

        @inlinable
        public init(domainName: String, scalingParameters: ScalingParameters) {
            self.domainName = domainName
            self.scalingParameters = scalingParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.scalingParameters.validate(name: "\(name).scalingParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case scalingParameters = "ScalingParameters"
        }
    }

    public struct UpdateScalingParametersResponse: AWSDecodableShape {
        public let scalingParameters: ScalingParametersStatus

        @inlinable
        public init(scalingParameters: ScalingParametersStatus) {
            self.scalingParameters = scalingParameters
        }

        private enum CodingKeys: String, CodingKey {
            case scalingParameters = "ScalingParameters"
        }
    }

    public struct UpdateServiceAccessPoliciesRequest: AWSEncodableShape {
        /// The access rules you want to configure. These rules replace any existing rules.
        public let accessPolicies: String
        public let domainName: String

        @inlinable
        public init(accessPolicies: String, domainName: String) {
            self.accessPolicies = accessPolicies
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case domainName = "DomainName"
        }
    }

    public struct UpdateServiceAccessPoliciesResponse: AWSDecodableShape {
        /// The access rules configured for the domain.
        public let accessPolicies: AccessPoliciesStatus

        @inlinable
        public init(accessPolicies: AccessPoliciesStatus) {
            self.accessPolicies = accessPolicies
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }
}

// MARK: - Errors

/// Error enum for CloudSearch
public struct CloudSearchErrorType: AWSErrorType {
    enum Code: String {
        case baseException = "BaseException"
        case disabledOperationException = "DisabledAction"
        case internalException = "InternalException"
        case invalidTypeException = "InvalidType"
        case limitExceededException = "LimitExceeded"
        case resourceAlreadyExistsException = "ResourceAlreadyExists"
        case resourceNotFoundException = "ResourceNotFound"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CloudSearch
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An error occurred while processing the request.
    public static var baseException: Self { .init(.baseException) }
    /// The request was rejected because it attempted an operation which is not enabled.
    public static var disabledOperationException: Self { .init(.disabledOperationException) }
    /// An internal error occurred while processing the request. If this problem persists, report an issue from the Service Health Dashboard.
    public static var internalException: Self { .init(.internalException) }
    /// The request was rejected because it specified an invalid type definition.
    public static var invalidTypeException: Self { .init(.invalidTypeException) }
    /// The request was rejected because a resource limit has already been met.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The request was rejected because it attempted to create a resource that already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// The request was rejected because it attempted to reference a resource that does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was rejected because it has invalid parameters.
    public static var validationException: Self { .init(.validationException) }
}

extension CloudSearchErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "BaseException": CloudSearch.BaseException.self,
        "DisabledAction": CloudSearch.DisabledOperationException.self,
        "InternalException": CloudSearch.InternalException.self,
        "InvalidType": CloudSearch.InvalidTypeException.self,
        "LimitExceeded": CloudSearch.LimitExceededException.self,
        "ResourceAlreadyExists": CloudSearch.ResourceAlreadyExistsException.self,
        "ResourceNotFound": CloudSearch.ResourceNotFoundException.self,
        "ValidationException": CloudSearch.ValidationException.self
    ]
}

extension CloudSearchErrorType: Equatable {
    public static func == (lhs: CloudSearchErrorType, rhs: CloudSearchErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CloudSearchErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
