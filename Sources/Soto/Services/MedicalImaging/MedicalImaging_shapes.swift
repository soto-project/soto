//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MedicalImaging {
    // MARK: Enums

    public enum DatastoreStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ImageSetState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case locked = "LOCKED"
        public var description: String { return self.rawValue }
    }

    public enum ImageSetWorkflowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case copied = "COPIED"
        case copyFailed = "COPY_FAILED"
        case copying = "COPYING"
        case copyingWithReadOnlyAccess = "COPYING_WITH_READ_ONLY_ACCESS"
        case created = "CREATED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updated = "UPDATED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum Operator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case between = "BETWEEN"
        case equal = "EQUAL"
        public var description: String { return self.rawValue }
    }

    public enum SortField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createdAt = "createdAt"
        case dicomStudyDateAndTime = "DICOMStudyDateAndTime"
        case updatedAt = "updatedAt"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum MetadataUpdates: AWSEncodableShape, Sendable {
        /// The object containing removableAttributes and updatableAttributes.
        case dicomUpdates(DICOMUpdates)
        /// Specifies the previous image set version ID to revert the current image set back to.  You must provide either revertToVersionId or DICOMUpdates in your request. A  ValidationException error is thrown if both parameters are provided at the same time.
        case revertToVersionId(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dicomUpdates(let value):
                try container.encode(value, forKey: .dicomUpdates)
            case .revertToVersionId(let value):
                try container.encode(value, forKey: .revertToVersionId)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .dicomUpdates(let value):
                try value.validate(name: "\(name).dicomUpdates")
            case .revertToVersionId(let value):
                try self.validate(value, name: "revertToVersionId", parent: name, pattern: "^\\d+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dicomUpdates = "DICOMUpdates"
            case revertToVersionId = "revertToVersionId"
        }
    }

    public enum SearchByAttributeValue: AWSEncodableShape, Sendable {
        /// The created at time of the image set provided for search.
        case createdAt(Date)
        /// The DICOM accession number for search.
        case dicomAccessionNumber(String)
        /// The patient ID input for search.
        case dicomPatientId(String)
        /// The Series Instance UID input for search.
        case dicomSeriesInstanceUID(String)
        /// The aggregated structure containing DICOM study date and study time for search.
        case dicomStudyDateAndTime(DICOMStudyDateAndTime)
        /// The DICOM study ID for search.
        case dicomStudyId(String)
        /// The DICOM study instance UID for search.
        case dicomStudyInstanceUID(String)
        /// The timestamp input for search.
        case updatedAt(Date)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .createdAt(let value):
                try container.encode(value, forKey: .createdAt)
            case .dicomAccessionNumber(let value):
                try container.encode(value, forKey: .dicomAccessionNumber)
            case .dicomPatientId(let value):
                try container.encode(value, forKey: .dicomPatientId)
            case .dicomSeriesInstanceUID(let value):
                try container.encode(value, forKey: .dicomSeriesInstanceUID)
            case .dicomStudyDateAndTime(let value):
                try container.encode(value, forKey: .dicomStudyDateAndTime)
            case .dicomStudyId(let value):
                try container.encode(value, forKey: .dicomStudyId)
            case .dicomStudyInstanceUID(let value):
                try container.encode(value, forKey: .dicomStudyInstanceUID)
            case .updatedAt(let value):
                try container.encode(value, forKey: .updatedAt)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .dicomAccessionNumber(let value):
                try self.validate(value, name: "dicomAccessionNumber", parent: name, max: 256)
            case .dicomPatientId(let value):
                try self.validate(value, name: "dicomPatientId", parent: name, max: 256)
            case .dicomSeriesInstanceUID(let value):
                try self.validate(value, name: "dicomSeriesInstanceUID", parent: name, max: 256)
                try self.validate(value, name: "dicomSeriesInstanceUID", parent: name, pattern: "^(?:[0-9][0-9]*|0)(\\.(?:[1-9][0-9]*|0))*$")
            case .dicomStudyDateAndTime(let value):
                try value.validate(name: "\(name).dicomStudyDateAndTime")
            case .dicomStudyId(let value):
                try self.validate(value, name: "dicomStudyId", parent: name, max: 16)
            case .dicomStudyInstanceUID(let value):
                try self.validate(value, name: "dicomStudyInstanceUID", parent: name, max: 256)
                try self.validate(value, name: "dicomStudyInstanceUID", parent: name, pattern: "^(?:[0-9][0-9]*|0)(\\.(?:[1-9][0-9]*|0))*$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dicomAccessionNumber = "DICOMAccessionNumber"
            case dicomPatientId = "DICOMPatientId"
            case dicomSeriesInstanceUID = "DICOMSeriesInstanceUID"
            case dicomStudyDateAndTime = "DICOMStudyDateAndTime"
            case dicomStudyId = "DICOMStudyId"
            case dicomStudyInstanceUID = "DICOMStudyInstanceUID"
            case updatedAt = "updatedAt"
        }
    }

    // MARK: Shapes

    public struct CopyDestinationImageSet: AWSEncodableShape {
        /// The image set identifier for the destination image set.
        public let imageSetId: String
        /// The latest version identifier for the destination image set.
        public let latestVersionId: String

        @inlinable
        public init(imageSetId: String, latestVersionId: String) {
            self.imageSetId = imageSetId
            self.latestVersionId = latestVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.latestVersionId, name: "latestVersionId", parent: name, pattern: "^\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageSetId = "imageSetId"
            case latestVersionId = "latestVersionId"
        }
    }

    public struct CopyDestinationImageSetProperties: AWSDecodableShape {
        /// The timestamp when the destination image set properties were created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) assigned to the destination image set.
        public let imageSetArn: String?
        /// The image set identifier of the copied image set properties.
        public let imageSetId: String
        /// The image set state of the destination image set properties.
        public let imageSetState: ImageSetState?
        /// The image set workflow status of the destination image set properties.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus?
        /// The latest version identifier for the destination image set properties.
        public let latestVersionId: String
        /// The timestamp when the destination image set properties were last updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, imageSetArn: String? = nil, imageSetId: String, imageSetState: ImageSetState? = nil, imageSetWorkflowStatus: ImageSetWorkflowStatus? = nil, latestVersionId: String, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.imageSetArn = imageSetArn
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.latestVersionId = latestVersionId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case imageSetArn = "imageSetArn"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "imageSetWorkflowStatus"
            case latestVersionId = "latestVersionId"
            case updatedAt = "updatedAt"
        }
    }

    public struct CopyImageSetInformation: AWSEncodableShape {
        /// The destination image set.
        public let destinationImageSet: CopyDestinationImageSet?
        /// The source image set.
        public let sourceImageSet: CopySourceImageSetInformation

        @inlinable
        public init(destinationImageSet: CopyDestinationImageSet? = nil, sourceImageSet: CopySourceImageSetInformation) {
            self.destinationImageSet = destinationImageSet
            self.sourceImageSet = sourceImageSet
        }

        public func validate(name: String) throws {
            try self.destinationImageSet?.validate(name: "\(name).destinationImageSet")
            try self.sourceImageSet.validate(name: "\(name).sourceImageSet")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationImageSet = "destinationImageSet"
            case sourceImageSet = "sourceImageSet"
        }
    }

    public struct CopyImageSetRequest: AWSEncodableShape {
        /// Copy image set information.
        public let copyImageSetInformation: CopyImageSetInformation
        /// The data store identifier.
        public let datastoreId: String
        /// Setting this flag will force the CopyImageSet operation, even if Patient, Study, or Series level metadata are mismatched across the sourceImageSet and destinationImageSet.
        public let force: Bool?
        /// The source image set identifier.
        public let sourceImageSetId: String

        @inlinable
        public init(copyImageSetInformation: CopyImageSetInformation, datastoreId: String, force: Bool? = nil, sourceImageSetId: String) {
            self.copyImageSetInformation = copyImageSetInformation
            self.datastoreId = datastoreId
            self.force = force
            self.sourceImageSetId = sourceImageSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            try container.encode(self.copyImageSetInformation)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodeQuery(self.force, key: "force")
            request.encodePath(self.sourceImageSetId, key: "sourceImageSetId")
        }

        public func validate(name: String) throws {
            try self.copyImageSetInformation.validate(name: "\(name).copyImageSetInformation")
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.sourceImageSetId, name: "sourceImageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CopyImageSetResponse: AWSDecodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The properties of the destination image set.
        public let destinationImageSetProperties: CopyDestinationImageSetProperties
        /// The properties of the source image set.
        public let sourceImageSetProperties: CopySourceImageSetProperties

        @inlinable
        public init(datastoreId: String, destinationImageSetProperties: CopyDestinationImageSetProperties, sourceImageSetProperties: CopySourceImageSetProperties) {
            self.datastoreId = datastoreId
            self.destinationImageSetProperties = destinationImageSetProperties
            self.sourceImageSetProperties = sourceImageSetProperties
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "datastoreId"
            case destinationImageSetProperties = "destinationImageSetProperties"
            case sourceImageSetProperties = "sourceImageSetProperties"
        }
    }

    public struct CopySourceImageSetInformation: AWSEncodableShape {
        /// Contains MetadataCopies structure and wraps information related to specific copy use cases. For example, when copying subsets.
        public let dicomCopies: MetadataCopies?
        /// The latest version identifier for the source image set.
        public let latestVersionId: String

        @inlinable
        public init(dicomCopies: MetadataCopies? = nil, latestVersionId: String) {
            self.dicomCopies = dicomCopies
            self.latestVersionId = latestVersionId
        }

        public func validate(name: String) throws {
            try self.dicomCopies?.validate(name: "\(name).dicomCopies")
            try self.validate(self.latestVersionId, name: "latestVersionId", parent: name, pattern: "^\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dicomCopies = "DICOMCopies"
            case latestVersionId = "latestVersionId"
        }
    }

    public struct CopySourceImageSetProperties: AWSDecodableShape {
        /// The timestamp when the source image set properties were created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) assigned to the source image set.
        public let imageSetArn: String?
        /// The image set identifier for the copied source image set.
        public let imageSetId: String
        /// The image set state of the copied source image set.
        public let imageSetState: ImageSetState?
        /// The workflow status of the copied source image set.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus?
        /// The latest version identifier for the copied source image set.
        public let latestVersionId: String
        /// The timestamp when the source image set properties were updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, imageSetArn: String? = nil, imageSetId: String, imageSetState: ImageSetState? = nil, imageSetWorkflowStatus: ImageSetWorkflowStatus? = nil, latestVersionId: String, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.imageSetArn = imageSetArn
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.latestVersionId = latestVersionId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case imageSetArn = "imageSetArn"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "imageSetWorkflowStatus"
            case latestVersionId = "latestVersionId"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateDatastoreRequest: AWSEncodableShape {
        /// A unique identifier for API idempotency.
        public let clientToken: String
        /// The data store name.
        public let datastoreName: String?
        /// The Amazon Resource Name (ARN) assigned to the Key Management Service (KMS) key for accessing encrypted data.
        public let kmsKeyArn: String?
        /// The tags provided when creating a data store.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String = CreateDatastoreRequest.idempotencyToken(), datastoreName: String? = nil, kmsKeyArn: String? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.datastoreName = datastoreName
            self.kmsKeyArn = kmsKeyArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9._-]+$")
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, max: 256)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, min: 1)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, pattern: "^[A-Za-z0-9._/#-]+$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 512)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws[a-zA-Z-]{0,16}:kms:[a-z]{2}(-[a-z]{1,16}){1,3}-\\d{1}:\\d{12}:((key/[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})|(alias/[a-zA-Z0-9:/_-]{1,256}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case datastoreName = "datastoreName"
            case kmsKeyArn = "kmsKeyArn"
            case tags = "tags"
        }
    }

    public struct CreateDatastoreResponse: AWSDecodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The data store status.
        public let datastoreStatus: DatastoreStatus

        @inlinable
        public init(datastoreId: String, datastoreStatus: DatastoreStatus) {
            self.datastoreId = datastoreId
            self.datastoreStatus = datastoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "datastoreId"
            case datastoreStatus = "datastoreStatus"
        }
    }

    public struct DICOMImportJobProperties: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that grants permissions to access medical imaging resources.
        public let dataAccessRoleArn: String
        /// The data store identifier.
        public let datastoreId: String
        /// The timestamp for when the import job was ended.
        public let endedAt: Date?
        /// The input prefix path for the S3 bucket that contains the DICOM P10 files to be imported.
        public let inputS3Uri: String
        /// The import job identifier.
        public let jobId: String
        /// The import job name.
        public let jobName: String
        /// The filters for listing import jobs based on status.
        public let jobStatus: JobStatus
        /// The error message thrown if an import job fails.
        public let message: String?
        /// The output prefix of the S3 bucket to upload the results of the DICOM import job.
        public let outputS3Uri: String
        /// The timestamp for when the import job was submitted.
        public let submittedAt: Date?

        @inlinable
        public init(dataAccessRoleArn: String, datastoreId: String, endedAt: Date? = nil, inputS3Uri: String, jobId: String, jobName: String, jobStatus: JobStatus, message: String? = nil, outputS3Uri: String, submittedAt: Date? = nil) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endedAt = endedAt
            self.inputS3Uri = inputS3Uri
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputS3Uri = outputS3Uri
            self.submittedAt = submittedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn = "dataAccessRoleArn"
            case datastoreId = "datastoreId"
            case endedAt = "endedAt"
            case inputS3Uri = "inputS3Uri"
            case jobId = "jobId"
            case jobName = "jobName"
            case jobStatus = "jobStatus"
            case message = "message"
            case outputS3Uri = "outputS3Uri"
            case submittedAt = "submittedAt"
        }
    }

    public struct DICOMImportJobSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that grants permissions to access medical imaging resources.
        public let dataAccessRoleArn: String?
        /// The data store identifier.
        public let datastoreId: String
        /// The timestamp when an import job ended.
        public let endedAt: Date?
        /// The import job identifier.
        public let jobId: String
        /// The import job name.
        public let jobName: String
        /// The filters for listing import jobs based on status.
        public let jobStatus: JobStatus
        /// The error message thrown if an import job fails.
        public let message: String?
        /// The timestamp when an import job was submitted.
        public let submittedAt: Date?

        @inlinable
        public init(dataAccessRoleArn: String? = nil, datastoreId: String, endedAt: Date? = nil, jobId: String, jobName: String, jobStatus: JobStatus, message: String? = nil, submittedAt: Date? = nil) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endedAt = endedAt
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.submittedAt = submittedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn = "dataAccessRoleArn"
            case datastoreId = "datastoreId"
            case endedAt = "endedAt"
            case jobId = "jobId"
            case jobName = "jobName"
            case jobStatus = "jobStatus"
            case message = "message"
            case submittedAt = "submittedAt"
        }
    }

    public struct DICOMStudyDateAndTime: AWSEncodableShape {
        /// The DICOM study date provided in yyMMdd format.
        public let dicomStudyDate: String
        /// The DICOM study time provided in HHmmss.FFFFFF format.
        public let dicomStudyTime: String?

        @inlinable
        public init(dicomStudyDate: String, dicomStudyTime: String? = nil) {
            self.dicomStudyDate = dicomStudyDate
            self.dicomStudyTime = dicomStudyTime
        }

        public func validate(name: String) throws {
            try self.validate(self.dicomStudyDate, name: "dicomStudyDate", parent: name, max: 18)
            try self.validate(self.dicomStudyTime, name: "dicomStudyTime", parent: name, max: 28)
        }

        private enum CodingKeys: String, CodingKey {
            case dicomStudyDate = "DICOMStudyDate"
            case dicomStudyTime = "DICOMStudyTime"
        }
    }

    public struct DICOMTags: AWSDecodableShape {
        /// The accession number for the DICOM study.
        public let dicomAccessionNumber: String?
        /// The total number of instances in the DICOM study.
        public let dicomNumberOfStudyRelatedInstances: Int?
        /// The total number of series in the DICOM study.
        public let dicomNumberOfStudyRelatedSeries: Int?
        /// The patient birth date.
        public let dicomPatientBirthDate: String?
        /// The unique identifier for a patient in a DICOM Study.
        public let dicomPatientId: String?
        /// The patient name.
        public let dicomPatientName: String?
        /// The patient sex.
        public let dicomPatientSex: String?
        /// The DICOM provided identifier for the series Body Part Examined.
        public let dicomSeriesBodyPart: String?
        /// The DICOM provided identifier for the Series Instance UID.
        public let dicomSeriesInstanceUID: String?
        /// The DICOM provided identifier for the series Modality.
        public let dicomSeriesModality: String?
        /// The DICOM provided identifier for the Series Number.
        public let dicomSeriesNumber: Int?
        /// The study date.
        public let dicomStudyDate: String?
        /// The DICOM provided Study Description.
        public let dicomStudyDescription: String?
        /// The DICOM provided identifier for the Study ID.
        public let dicomStudyId: String?
        /// The DICOM provided identifier for the Study Instance UID.
        public let dicomStudyInstanceUID: String?
        /// The study time.
        public let dicomStudyTime: String?

        @inlinable
        public init(dicomAccessionNumber: String? = nil, dicomNumberOfStudyRelatedInstances: Int? = nil, dicomNumberOfStudyRelatedSeries: Int? = nil, dicomPatientBirthDate: String? = nil, dicomPatientId: String? = nil, dicomPatientName: String? = nil, dicomPatientSex: String? = nil, dicomSeriesBodyPart: String? = nil, dicomSeriesInstanceUID: String? = nil, dicomSeriesModality: String? = nil, dicomSeriesNumber: Int? = nil, dicomStudyDate: String? = nil, dicomStudyDescription: String? = nil, dicomStudyId: String? = nil, dicomStudyInstanceUID: String? = nil, dicomStudyTime: String? = nil) {
            self.dicomAccessionNumber = dicomAccessionNumber
            self.dicomNumberOfStudyRelatedInstances = dicomNumberOfStudyRelatedInstances
            self.dicomNumberOfStudyRelatedSeries = dicomNumberOfStudyRelatedSeries
            self.dicomPatientBirthDate = dicomPatientBirthDate
            self.dicomPatientId = dicomPatientId
            self.dicomPatientName = dicomPatientName
            self.dicomPatientSex = dicomPatientSex
            self.dicomSeriesBodyPart = dicomSeriesBodyPart
            self.dicomSeriesInstanceUID = dicomSeriesInstanceUID
            self.dicomSeriesModality = dicomSeriesModality
            self.dicomSeriesNumber = dicomSeriesNumber
            self.dicomStudyDate = dicomStudyDate
            self.dicomStudyDescription = dicomStudyDescription
            self.dicomStudyId = dicomStudyId
            self.dicomStudyInstanceUID = dicomStudyInstanceUID
            self.dicomStudyTime = dicomStudyTime
        }

        private enum CodingKeys: String, CodingKey {
            case dicomAccessionNumber = "DICOMAccessionNumber"
            case dicomNumberOfStudyRelatedInstances = "DICOMNumberOfStudyRelatedInstances"
            case dicomNumberOfStudyRelatedSeries = "DICOMNumberOfStudyRelatedSeries"
            case dicomPatientBirthDate = "DICOMPatientBirthDate"
            case dicomPatientId = "DICOMPatientId"
            case dicomPatientName = "DICOMPatientName"
            case dicomPatientSex = "DICOMPatientSex"
            case dicomSeriesBodyPart = "DICOMSeriesBodyPart"
            case dicomSeriesInstanceUID = "DICOMSeriesInstanceUID"
            case dicomSeriesModality = "DICOMSeriesModality"
            case dicomSeriesNumber = "DICOMSeriesNumber"
            case dicomStudyDate = "DICOMStudyDate"
            case dicomStudyDescription = "DICOMStudyDescription"
            case dicomStudyId = "DICOMStudyId"
            case dicomStudyInstanceUID = "DICOMStudyInstanceUID"
            case dicomStudyTime = "DICOMStudyTime"
        }
    }

    public struct DICOMUpdates: AWSEncodableShape {
        /// The DICOM tags to be removed from ImageSetMetadata.
        public let removableAttributes: AWSBase64Data?
        /// The DICOM tags that need to be updated in ImageSetMetadata.
        public let updatableAttributes: AWSBase64Data?

        @inlinable
        public init(removableAttributes: AWSBase64Data? = nil, updatableAttributes: AWSBase64Data? = nil) {
            self.removableAttributes = removableAttributes
            self.updatableAttributes = updatableAttributes
        }

        public func validate(name: String) throws {
            try self.validate(self.removableAttributes, name: "removableAttributes", parent: name, max: 10000)
            try self.validate(self.removableAttributes, name: "removableAttributes", parent: name, min: 1)
            try self.validate(self.updatableAttributes, name: "updatableAttributes", parent: name, max: 10000)
            try self.validate(self.updatableAttributes, name: "updatableAttributes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case removableAttributes = "removableAttributes"
            case updatableAttributes = "updatableAttributes"
        }
    }

    public struct DatastoreProperties: AWSDecodableShape {
        /// The timestamp when the data store was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) for the data store.
        public let datastoreArn: String?
        /// The data store identifier.
        public let datastoreId: String
        /// The data store name.
        public let datastoreName: String
        /// The data store status.
        public let datastoreStatus: DatastoreStatus
        /// The Amazon Resource Name (ARN) assigned to the Key Management Service (KMS) key for accessing encrypted data.
        public let kmsKeyArn: String?
        /// The timestamp when the data store was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, datastoreArn: String? = nil, datastoreId: String, datastoreName: String, datastoreStatus: DatastoreStatus, kmsKeyArn: String? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.kmsKeyArn = kmsKeyArn
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case datastoreArn = "datastoreArn"
            case datastoreId = "datastoreId"
            case datastoreName = "datastoreName"
            case datastoreStatus = "datastoreStatus"
            case kmsKeyArn = "kmsKeyArn"
            case updatedAt = "updatedAt"
        }
    }

    public struct DatastoreSummary: AWSDecodableShape {
        /// The timestamp when the data store was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) for the data store.
        public let datastoreArn: String?
        /// The data store identifier.
        public let datastoreId: String
        /// The data store name.
        public let datastoreName: String
        /// The data store status.
        public let datastoreStatus: DatastoreStatus
        /// The timestamp when the data store was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, datastoreArn: String? = nil, datastoreId: String, datastoreName: String, datastoreStatus: DatastoreStatus, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case datastoreArn = "datastoreArn"
            case datastoreId = "datastoreId"
            case datastoreName = "datastoreName"
            case datastoreStatus = "datastoreStatus"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteDatastoreRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String

        @inlinable
        public init(datastoreId: String) {
            self.datastoreId = datastoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDatastoreResponse: AWSDecodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The data store status.
        public let datastoreStatus: DatastoreStatus

        @inlinable
        public init(datastoreId: String, datastoreStatus: DatastoreStatus) {
            self.datastoreId = datastoreId
            self.datastoreStatus = datastoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "datastoreId"
            case datastoreStatus = "datastoreStatus"
        }
    }

    public struct DeleteImageSetRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String

        @inlinable
        public init(datastoreId: String, imageSetId: String) {
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.imageSetId, key: "imageSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImageSetResponse: AWSDecodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String
        /// The image set state.
        public let imageSetState: ImageSetState
        /// The image set workflow status.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus

        @inlinable
        public init(datastoreId: String, imageSetId: String, imageSetState: ImageSetState, imageSetWorkflowStatus: ImageSetWorkflowStatus) {
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "datastoreId"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "imageSetWorkflowStatus"
        }
    }

    public struct GetDICOMImportJobRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The import job identifier.
        public let jobId: String

        @inlinable
        public init(datastoreId: String, jobId: String) {
            self.datastoreId = datastoreId
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDICOMImportJobResponse: AWSDecodableShape {
        /// The properties of the import job.
        public let jobProperties: DICOMImportJobProperties

        @inlinable
        public init(jobProperties: DICOMImportJobProperties) {
            self.jobProperties = jobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case jobProperties = "jobProperties"
        }
    }

    public struct GetDatastoreRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String

        @inlinable
        public init(datastoreId: String) {
            self.datastoreId = datastoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDatastoreResponse: AWSDecodableShape {
        /// The data store properties.
        public let datastoreProperties: DatastoreProperties

        @inlinable
        public init(datastoreProperties: DatastoreProperties) {
            self.datastoreProperties = datastoreProperties
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreProperties = "datastoreProperties"
        }
    }

    public struct GetImageFrameRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// Information about the image frame (pixel data) identifier.
        public let imageFrameInformation: ImageFrameInformation
        /// The image set identifier.
        public let imageSetId: String

        @inlinable
        public init(datastoreId: String, imageFrameInformation: ImageFrameInformation, imageSetId: String) {
            self.datastoreId = datastoreId
            self.imageFrameInformation = imageFrameInformation
            self.imageSetId = imageSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.datastoreId, key: "datastoreId")
            try container.encode(self.imageFrameInformation)
            request.encodePath(self.imageSetId, key: "imageSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.imageFrameInformation.validate(name: "\(name).imageFrameInformation")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageFrameResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The format in which the image frame information is returned to the customer. Default is  application/octet-stream.
        public let contentType: String?
        /// The blob containing the aggregated image frame information.
        public let imageFrameBlob: AWSHTTPBody

        @inlinable
        public init(contentType: String? = nil, imageFrameBlob: AWSHTTPBody) {
            self.contentType = contentType
            self.imageFrameBlob = imageFrameBlob
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.imageFrameBlob = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageSetMetadataRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String
        /// The image set version identifier.
        public let versionId: String?

        @inlinable
        public init(datastoreId: String, imageSetId: String, versionId: String? = nil) {
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.imageSetId, key: "imageSetId")
            request.encodeQuery(self.versionId, key: "version")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageSetMetadataResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The compression format in which image set metadata attributes are returned.
        public let contentEncoding: String?
        /// The format in which the study metadata is returned to the customer. Default is text/plain.
        public let contentType: String?
        /// The blob containing the aggregated metadata information for the image set.
        public let imageSetMetadataBlob: AWSHTTPBody

        @inlinable
        public init(contentEncoding: String? = nil, contentType: String? = nil, imageSetMetadataBlob: AWSHTTPBody) {
            self.contentEncoding = contentEncoding
            self.contentType = contentType
            self.imageSetMetadataBlob = imageSetMetadataBlob
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.contentEncoding = try response.decodeHeaderIfPresent(String.self, key: "Content-Encoding")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.imageSetMetadataBlob = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageSetRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String
        /// The image set version identifier.
        public let versionId: String?

        @inlinable
        public init(datastoreId: String, imageSetId: String, versionId: String? = nil) {
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.imageSetId, key: "imageSetId")
            request.encodeQuery(self.versionId, key: "version")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageSetResponse: AWSDecodableShape {
        /// The timestamp when image set properties were created.
        public let createdAt: Date?
        /// The data store identifier.
        public let datastoreId: String
        /// The timestamp when the image set properties were deleted.
        public let deletedAt: Date?
        /// The Amazon Resource Name (ARN) assigned to the image set.
        public let imageSetArn: String?
        /// The image set identifier.
        public let imageSetId: String
        /// The image set state.
        public let imageSetState: ImageSetState
        /// The image set workflow status.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus?
        /// The error message thrown if an image set action fails.
        public let message: String?
        /// This object contains the details of any overrides used while creating a specific image set version. If an image set was copied or updated using the force flag, this object will contain the forced flag.
        public let overrides: Overrides?
        /// The timestamp when image set properties were updated.
        public let updatedAt: Date?
        /// The image set version identifier.
        public let versionId: String

        @inlinable
        public init(createdAt: Date? = nil, datastoreId: String, deletedAt: Date? = nil, imageSetArn: String? = nil, imageSetId: String, imageSetState: ImageSetState, imageSetWorkflowStatus: ImageSetWorkflowStatus? = nil, message: String? = nil, overrides: Overrides? = nil, updatedAt: Date? = nil, versionId: String) {
            self.createdAt = createdAt
            self.datastoreId = datastoreId
            self.deletedAt = deletedAt
            self.imageSetArn = imageSetArn
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.message = message
            self.overrides = overrides
            self.updatedAt = updatedAt
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case datastoreId = "datastoreId"
            case deletedAt = "deletedAt"
            case imageSetArn = "imageSetArn"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "imageSetWorkflowStatus"
            case message = "message"
            case overrides = "overrides"
            case updatedAt = "updatedAt"
            case versionId = "versionId"
        }
    }

    public struct ImageFrameInformation: AWSEncodableShape {
        /// The image frame (pixel data) identifier.
        public let imageFrameId: String

        @inlinable
        public init(imageFrameId: String) {
            self.imageFrameId = imageFrameId
        }

        public func validate(name: String) throws {
            try self.validate(self.imageFrameId, name: "imageFrameId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageFrameId = "imageFrameId"
        }
    }

    public struct ImageSetProperties: AWSDecodableShape {
        /// The timestamp when the image set properties were created.
        public let createdAt: Date?
        /// The timestamp when the image set properties were deleted.
        public let deletedAt: Date?
        /// The image set identifier.
        public let imageSetId: String
        /// The image set state.
        public let imageSetState: ImageSetState
        /// The image set workflow status.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus?
        /// The error message thrown if an image set action fails.
        public let message: String?
        /// Contains details on overrides used when creating the returned version of an image set. For example, if forced exists, the forced flag was used when  creating the image set.
        public let overrides: Overrides?
        /// The timestamp when the image set properties were updated.
        public let updatedAt: Date?
        /// The image set version identifier.
        public let versionId: String

        @inlinable
        public init(createdAt: Date? = nil, deletedAt: Date? = nil, imageSetId: String, imageSetState: ImageSetState, imageSetWorkflowStatus: ImageSetWorkflowStatus? = nil, message: String? = nil, overrides: Overrides? = nil, updatedAt: Date? = nil, versionId: String) {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.message = message
            self.overrides = overrides
            self.updatedAt = updatedAt
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case deletedAt = "deletedAt"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "ImageSetWorkflowStatus"
            case message = "message"
            case overrides = "overrides"
            case updatedAt = "updatedAt"
            case versionId = "versionId"
        }
    }

    public struct ImageSetsMetadataSummary: AWSDecodableShape {
        /// The time an image set is created. Sample creation  date is provided in 1985-04-12T23:20:50.52Z format.
        public let createdAt: Date?
        /// The DICOM tags associated with the image set.
        public let dicomTags: DICOMTags?
        /// The image set identifier.
        public let imageSetId: String
        /// The time an image set was last updated.
        public let updatedAt: Date?
        /// The image set version.
        public let version: Int?

        @inlinable
        public init(createdAt: Date? = nil, dicomTags: DICOMTags? = nil, imageSetId: String, updatedAt: Date? = nil, version: Int? = nil) {
            self.createdAt = createdAt
            self.dicomTags = dicomTags
            self.imageSetId = imageSetId
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dicomTags = "DICOMTags"
            case imageSetId = "imageSetId"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct ListDICOMImportJobsRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The filters for listing import jobs based on status.
        public let jobStatus: JobStatus?
        /// The max results count. The upper bound is determined by load testing.
        public let maxResults: Int?
        /// The pagination token used to request the list of import jobs on the next page.
        public let nextToken: String?

        @inlinable
        public init(datastoreId: String, jobStatus: JobStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datastoreId = datastoreId
            self.jobStatus = jobStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodeQuery(self.jobStatus, key: "jobStatus")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDICOMImportJobsResponse: AWSDecodableShape {
        /// A list of job summaries.
        public let jobSummaries: [DICOMImportJobSummary]
        /// The pagination token used to retrieve the list of import jobs on the next page.
        public let nextToken: String?

        @inlinable
        public init(jobSummaries: [DICOMImportJobSummary], nextToken: String? = nil) {
            self.jobSummaries = jobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobSummaries = "jobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatastoresRequest: AWSEncodableShape {
        /// The data store status.
        public let datastoreStatus: DatastoreStatus?
        /// Valid Range: Minimum value of 1. Maximum value of 50.
        public let maxResults: Int?
        /// The pagination token used to request the list of data stores on the next page.
        public let nextToken: String?

        @inlinable
        public init(datastoreStatus: DatastoreStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datastoreStatus = datastoreStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.datastoreStatus, key: "datastoreStatus")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDatastoresResponse: AWSDecodableShape {
        /// The list of summaries of data stores.
        public let datastoreSummaries: [DatastoreSummary]?
        /// The pagination token used to retrieve the list of data stores on the next page.
        public let nextToken: String?

        @inlinable
        public init(datastoreSummaries: [DatastoreSummary]? = nil, nextToken: String? = nil) {
            self.datastoreSummaries = datastoreSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreSummaries = "datastoreSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListImageSetVersionsRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String
        /// The max results count.
        public let maxResults: Int?
        /// The pagination token used to request the list of image set versions on the next page.
        public let nextToken: String?

        @inlinable
        public init(datastoreId: String, imageSetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.imageSetId, key: "imageSetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListImageSetVersionsResponse: AWSDecodableShape {
        /// Lists all properties associated with an image set.
        public let imageSetPropertiesList: [ImageSetProperties]
        /// The pagination token used to retrieve the list of image set versions on the next page.
        public let nextToken: String?

        @inlinable
        public init(imageSetPropertiesList: [ImageSetProperties], nextToken: String? = nil) {
            self.imageSetPropertiesList = imageSetPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case imageSetPropertiesList = "imageSetPropertiesList"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the medical imaging resource to list tags for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:medical-imaging:[a-z0-9-]+:[0-9]{12}:datastore/[0-9a-z]{32}(/imageset/[0-9a-z]{32})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of all tags associated with a medical imaging resource.
        public let tags: [String: String]

        @inlinable
        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MetadataCopies: AWSEncodableShape {
        /// The JSON string used to specify a subset of SOP Instances to copy from source to destination image set.
        public let copiableAttributes: String

        @inlinable
        public init(copiableAttributes: String) {
            self.copiableAttributes = copiableAttributes
        }

        public func validate(name: String) throws {
            try self.validate(self.copiableAttributes, name: "copiableAttributes", parent: name, max: 260000)
            try self.validate(self.copiableAttributes, name: "copiableAttributes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case copiableAttributes = "copiableAttributes"
        }
    }

    public struct Overrides: AWSDecodableShape {
        /// Setting this flag will force the CopyImageSet and UpdateImageSetMetadata operations, even if Patient, Study, or Series level metadata are mismatched.
        public let forced: Bool?

        @inlinable
        public init(forced: Bool? = nil) {
            self.forced = forced
        }

        private enum CodingKeys: String, CodingKey {
            case forced = "forced"
        }
    }

    public struct SearchCriteria: AWSEncodableShape {
        /// The filters for the search criteria.
        public let filters: [SearchFilter]?
        /// The sort input for search criteria.
        public let sort: Sort?

        @inlinable
        public init(filters: [SearchFilter]? = nil, sort: Sort? = nil) {
            self.filters = filters
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case sort = "sort"
        }
    }

    public struct SearchFilter: AWSEncodableShape {
        /// The search filter operator for imageSetDateTime.
        public let `operator`: Operator
        /// The search filter values.
        public let values: [SearchByAttributeValue]

        @inlinable
        public init(operator: Operator, values: [SearchByAttributeValue]) {
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try $0.validate(name: "\(name).values[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct SearchImageSetsRequest: AWSEncodableShape {
        /// The identifier of the data store where the image sets reside.
        public let datastoreId: String
        /// The maximum number of results that can be returned in a search.
        public let maxResults: Int?
        /// The token used for pagination of results returned in the response. Use the token returned from the previous request to continue results where the previous request ended.
        public let nextToken: String?
        /// The search criteria that filters by applying a maximum of 1 item to SearchByAttribute.
        public let searchCriteria: SearchCriteria?

        @inlinable
        public init(datastoreId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: SearchCriteria? = nil) {
            self.datastoreId = datastoreId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchCriteria)
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
            try self.searchCriteria?.validate(name: "\(name).searchCriteria")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct SearchImageSetsResponse: AWSDecodableShape {
        /// The model containing the image set results.
        public let imageSetsMetadataSummaries: [ImageSetsMetadataSummary]
        /// The token for pagination results.
        public let nextToken: String?
        /// The sort order for image set search results.
        public let sort: Sort?

        @inlinable
        public init(imageSetsMetadataSummaries: [ImageSetsMetadataSummary], nextToken: String? = nil, sort: Sort? = nil) {
            self.imageSetsMetadataSummaries = imageSetsMetadataSummaries
            self.nextToken = nextToken
            self.sort = sort
        }

        private enum CodingKeys: String, CodingKey {
            case imageSetsMetadataSummaries = "imageSetsMetadataSummaries"
            case nextToken = "nextToken"
            case sort = "sort"
        }
    }

    public struct Sort: AWSEncodableShape & AWSDecodableShape {
        /// The sort field for search criteria.
        public let sortField: SortField
        /// The sort order for search criteria.
        public let sortOrder: SortOrder

        @inlinable
        public init(sortField: SortField, sortOrder: SortOrder) {
            self.sortField = sortField
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortField = "sortField"
            case sortOrder = "sortOrder"
        }
    }

    public struct StartDICOMImportJobRequest: AWSEncodableShape {
        /// A unique identifier for API idempotency.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the IAM role that grants permission to access medical imaging resources.
        public let dataAccessRoleArn: String
        /// The data store identifier.
        public let datastoreId: String
        /// The account ID of the source S3 bucket owner.
        public let inputOwnerAccountId: String?
        /// The input prefix path for the S3 bucket that contains the DICOM files to be imported.
        public let inputS3Uri: String
        /// The import job name.
        public let jobName: String?
        /// The output prefix of the S3 bucket to upload the results of the DICOM import job.
        public let outputS3Uri: String

        @inlinable
        public init(clientToken: String = StartDICOMImportJobRequest.idempotencyToken(), dataAccessRoleArn: String, datastoreId: String, inputOwnerAccountId: String? = nil, inputS3Uri: String, jobName: String? = nil, outputS3Uri: String) {
            self.clientToken = clientToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.inputOwnerAccountId = inputOwnerAccountId
            self.inputS3Uri = inputS3Uri
            self.jobName = jobName
            self.outputS3Uri = outputS3Uri
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.clientToken, forKey: .clientToken)
            try container.encode(self.dataAccessRoleArn, forKey: .dataAccessRoleArn)
            request.encodePath(self.datastoreId, key: "datastoreId")
            try container.encodeIfPresent(self.inputOwnerAccountId, forKey: .inputOwnerAccountId)
            try container.encode(self.inputS3Uri, forKey: .inputS3Uri)
            try container.encodeIfPresent(self.jobName, forKey: .jobName)
            try container.encode(self.outputS3Uri, forKey: .outputS3Uri)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9._-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+$")
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.inputOwnerAccountId, name: "inputOwnerAccountId", parent: name, max: 12)
            try self.validate(self.inputOwnerAccountId, name: "inputOwnerAccountId", parent: name, min: 12)
            try self.validate(self.inputOwnerAccountId, name: "inputOwnerAccountId", parent: name, pattern: "^\\d+$")
            try self.validate(self.inputS3Uri, name: "inputS3Uri", parent: name, max: 1024)
            try self.validate(self.inputS3Uri, name: "inputS3Uri", parent: name, min: 1)
            try self.validate(self.inputS3Uri, name: "inputS3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[A-Za-z0-9._/#-]+$")
            try self.validate(self.outputS3Uri, name: "outputS3Uri", parent: name, max: 1024)
            try self.validate(self.outputS3Uri, name: "outputS3Uri", parent: name, min: 1)
            try self.validate(self.outputS3Uri, name: "outputS3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dataAccessRoleArn = "dataAccessRoleArn"
            case inputOwnerAccountId = "inputOwnerAccountId"
            case inputS3Uri = "inputS3Uri"
            case jobName = "jobName"
            case outputS3Uri = "outputS3Uri"
        }
    }

    public struct StartDICOMImportJobResponse: AWSDecodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The import job identifier.
        public let jobId: String
        /// The import job status.
        public let jobStatus: JobStatus
        /// The timestamp when the import job was submitted.
        public let submittedAt: Date

        @inlinable
        public init(datastoreId: String, jobId: String, jobStatus: JobStatus, submittedAt: Date) {
            self.datastoreId = datastoreId
            self.jobId = jobId
            self.jobStatus = jobStatus
            self.submittedAt = submittedAt
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "datastoreId"
            case jobId = "jobId"
            case jobStatus = "jobStatus"
            case submittedAt = "submittedAt"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the medical imaging resource that tags are being added to.
        public let resourceArn: String
        /// The user-specified key and value tag pairs added to a medical imaging resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:medical-imaging:[a-z0-9-]+:[0-9]{12}:datastore/[0-9a-z]{32}(/imageset/[0-9a-z]{32})?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the medical imaging resource that tags are being removed from.
        public let resourceArn: String
        /// The keys for the tags to be removed from the medical imaging resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:medical-imaging:[a-z0-9-]+:[0-9]{12}:datastore/[0-9a-z]{32}(/imageset/[0-9a-z]{32})?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateImageSetMetadataRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// Setting this flag will force the UpdateImageSetMetadata operation for the following attributes:    Tag.StudyInstanceUID, Tag.SeriesInstanceUID, Tag.SOPInstanceUID, and Tag.StudyID    Adding, removing, or updating private tags for an individual SOP Instance
        public let force: Bool?
        /// The image set identifier.
        public let imageSetId: String
        /// The latest image set version identifier.
        public let latestVersionId: String
        /// Update image set metadata updates.
        public let updateImageSetMetadataUpdates: MetadataUpdates

        @inlinable
        public init(datastoreId: String, force: Bool? = nil, imageSetId: String, latestVersionId: String, updateImageSetMetadataUpdates: MetadataUpdates) {
            self.datastoreId = datastoreId
            self.force = force
            self.imageSetId = imageSetId
            self.latestVersionId = latestVersionId
            self.updateImageSetMetadataUpdates = updateImageSetMetadataUpdates
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodeQuery(self.force, key: "force")
            request.encodePath(self.imageSetId, key: "imageSetId")
            request.encodeQuery(self.latestVersionId, key: "latestVersion")
            try container.encode(self.updateImageSetMetadataUpdates)
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.latestVersionId, name: "latestVersionId", parent: name, pattern: "^\\d+$")
            try self.updateImageSetMetadataUpdates.validate(name: "\(name).updateImageSetMetadataUpdates")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateImageSetMetadataResponse: AWSDecodableShape {
        /// The timestamp when image set metadata was created.
        public let createdAt: Date?
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String
        /// The image set state.
        public let imageSetState: ImageSetState
        /// The image set workflow status.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus?
        /// The latest image set version identifier.
        public let latestVersionId: String
        /// The error message thrown if an update image set metadata action fails.
        public let message: String?
        /// The timestamp when image set metadata was updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, datastoreId: String, imageSetId: String, imageSetState: ImageSetState, imageSetWorkflowStatus: ImageSetWorkflowStatus? = nil, latestVersionId: String, message: String? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.latestVersionId = latestVersionId
            self.message = message
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case datastoreId = "datastoreId"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "imageSetWorkflowStatus"
            case latestVersionId = "latestVersionId"
            case message = "message"
            case updatedAt = "updatedAt"
        }
    }
}

// MARK: - Errors

/// Error enum for MedicalImaging
public struct MedicalImagingErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MedicalImaging
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The user does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred during processing of the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request caused a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints set by the service.
    public static var validationException: Self { .init(.validationException) }
}

extension MedicalImagingErrorType: Equatable {
    public static func == (lhs: MedicalImagingErrorType, rhs: MedicalImagingErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MedicalImagingErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
