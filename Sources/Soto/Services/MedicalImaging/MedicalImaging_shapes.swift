//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MedicalImaging {
    // MARK: Enums

    public enum DatastoreStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ImageSetState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case locked = "LOCKED"
        public var description: String { return self.rawValue }
    }

    public enum ImageSetWorkflowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case copied = "COPIED"
        case copyFailed = "COPY_FAILED"
        case copying = "COPYING"
        case copyingWithReadOnlyAccess = "COPYING_WITH_READ_ONLY_ACCESS"
        case created = "CREATED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updated = "UPDATED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum Operator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case between = "BETWEEN"
        case equal = "EQUAL"
        public var description: String { return self.rawValue }
    }

    public enum SortField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createdAt = "createdAt"
        case dicomStudyDateAndTime = "DICOMStudyDateAndTime"
        case updatedAt = "updatedAt"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum SearchByAttributeValue: AWSEncodableShape, Sendable {
        /// The created at time of the image set provided for search.
        case createdAt(Date)
        /// The DICOM accession number for search.
        case dicomAccessionNumber(String)
        /// The patient ID input for search.
        case dicomPatientId(String)
        /// The Series Instance UID input for search.
        case dicomSeriesInstanceUID(String)
        /// The aggregated structure containing DICOM study date and study time for search.
        case dicomStudyDateAndTime(DICOMStudyDateAndTime)
        /// The DICOM study ID for search.
        case dicomStudyId(String)
        /// The DICOM study instance UID for search.
        case dicomStudyInstanceUID(String)
        /// The timestamp input for search.
        case updatedAt(Date)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .createdAt(let value):
                try container.encode(value, forKey: .createdAt)
            case .dicomAccessionNumber(let value):
                try container.encode(value, forKey: .dicomAccessionNumber)
            case .dicomPatientId(let value):
                try container.encode(value, forKey: .dicomPatientId)
            case .dicomSeriesInstanceUID(let value):
                try container.encode(value, forKey: .dicomSeriesInstanceUID)
            case .dicomStudyDateAndTime(let value):
                try container.encode(value, forKey: .dicomStudyDateAndTime)
            case .dicomStudyId(let value):
                try container.encode(value, forKey: .dicomStudyId)
            case .dicomStudyInstanceUID(let value):
                try container.encode(value, forKey: .dicomStudyInstanceUID)
            case .updatedAt(let value):
                try container.encode(value, forKey: .updatedAt)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .dicomAccessionNumber(let value):
                try self.validate(value, name: "dicomAccessionNumber", parent: name, max: 16)
            case .dicomPatientId(let value):
                try self.validate(value, name: "dicomPatientId", parent: name, max: 64)
            case .dicomSeriesInstanceUID(let value):
                try self.validate(value, name: "dicomSeriesInstanceUID", parent: name, max: 64)
                try self.validate(value, name: "dicomSeriesInstanceUID", parent: name, pattern: "^(?:[1-9][0-9]*|0)(\\.(?:[1-9][0-9]*|0))*$")
            case .dicomStudyDateAndTime(let value):
                try value.validate(name: "\(name).dicomStudyDateAndTime")
            case .dicomStudyId(let value):
                try self.validate(value, name: "dicomStudyId", parent: name, max: 16)
            case .dicomStudyInstanceUID(let value):
                try self.validate(value, name: "dicomStudyInstanceUID", parent: name, max: 64)
                try self.validate(value, name: "dicomStudyInstanceUID", parent: name, pattern: "^(?:[1-9][0-9]*|0)(\\.(?:[1-9][0-9]*|0))*$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dicomAccessionNumber = "DICOMAccessionNumber"
            case dicomPatientId = "DICOMPatientId"
            case dicomSeriesInstanceUID = "DICOMSeriesInstanceUID"
            case dicomStudyDateAndTime = "DICOMStudyDateAndTime"
            case dicomStudyId = "DICOMStudyId"
            case dicomStudyInstanceUID = "DICOMStudyInstanceUID"
            case updatedAt = "updatedAt"
        }
    }

    // MARK: Shapes

    public struct CopyDestinationImageSet: AWSEncodableShape {
        /// The image set identifier for the destination image set.
        public let imageSetId: String
        /// The latest version identifier for the destination image set.
        public let latestVersionId: String

        public init(imageSetId: String, latestVersionId: String) {
            self.imageSetId = imageSetId
            self.latestVersionId = latestVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.latestVersionId, name: "latestVersionId", parent: name, pattern: "^\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageSetId = "imageSetId"
            case latestVersionId = "latestVersionId"
        }
    }

    public struct CopyDestinationImageSetProperties: AWSDecodableShape {
        /// The timestamp when the destination image set properties were created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) assigned to the destination image set.
        public let imageSetArn: String?
        /// The image set identifier of the copied image set properties.
        public let imageSetId: String
        /// The image set state of the destination image set properties.
        public let imageSetState: ImageSetState?
        /// The image set workflow status of the destination image set properties.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus?
        /// The latest version identifier for the destination image set properties.
        public let latestVersionId: String
        /// The timestamp when the destination image set properties were last updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, imageSetArn: String? = nil, imageSetId: String, imageSetState: ImageSetState? = nil, imageSetWorkflowStatus: ImageSetWorkflowStatus? = nil, latestVersionId: String, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.imageSetArn = imageSetArn
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.latestVersionId = latestVersionId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case imageSetArn = "imageSetArn"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "imageSetWorkflowStatus"
            case latestVersionId = "latestVersionId"
            case updatedAt = "updatedAt"
        }
    }

    public struct CopyImageSetInformation: AWSEncodableShape {
        /// The destination image set.
        public let destinationImageSet: CopyDestinationImageSet?
        /// The source image set.
        public let sourceImageSet: CopySourceImageSetInformation

        public init(destinationImageSet: CopyDestinationImageSet? = nil, sourceImageSet: CopySourceImageSetInformation) {
            self.destinationImageSet = destinationImageSet
            self.sourceImageSet = sourceImageSet
        }

        public func validate(name: String) throws {
            try self.destinationImageSet?.validate(name: "\(name).destinationImageSet")
            try self.sourceImageSet.validate(name: "\(name).sourceImageSet")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationImageSet = "destinationImageSet"
            case sourceImageSet = "sourceImageSet"
        }
    }

    public struct CopyImageSetRequest: AWSEncodableShape {
        /// Copy image set information.
        public let copyImageSetInformation: CopyImageSetInformation
        /// The data store identifier.
        public let datastoreId: String
        /// The source image set identifier.
        public let sourceImageSetId: String

        public init(copyImageSetInformation: CopyImageSetInformation, datastoreId: String, sourceImageSetId: String) {
            self.copyImageSetInformation = copyImageSetInformation
            self.datastoreId = datastoreId
            self.sourceImageSetId = sourceImageSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            try container.encode(self.copyImageSetInformation)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.sourceImageSetId, key: "sourceImageSetId")
        }

        public func validate(name: String) throws {
            try self.copyImageSetInformation.validate(name: "\(name).copyImageSetInformation")
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.sourceImageSetId, name: "sourceImageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CopyImageSetResponse: AWSDecodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The properties of the destination image set.
        public let destinationImageSetProperties: CopyDestinationImageSetProperties
        /// The properties of the source image set.
        public let sourceImageSetProperties: CopySourceImageSetProperties

        public init(datastoreId: String, destinationImageSetProperties: CopyDestinationImageSetProperties, sourceImageSetProperties: CopySourceImageSetProperties) {
            self.datastoreId = datastoreId
            self.destinationImageSetProperties = destinationImageSetProperties
            self.sourceImageSetProperties = sourceImageSetProperties
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "datastoreId"
            case destinationImageSetProperties = "destinationImageSetProperties"
            case sourceImageSetProperties = "sourceImageSetProperties"
        }
    }

    public struct CopySourceImageSetInformation: AWSEncodableShape {
        /// The latest version identifier for the source image set.
        public let latestVersionId: String

        public init(latestVersionId: String) {
            self.latestVersionId = latestVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.latestVersionId, name: "latestVersionId", parent: name, pattern: "^\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case latestVersionId = "latestVersionId"
        }
    }

    public struct CopySourceImageSetProperties: AWSDecodableShape {
        /// The timestamp when the source image set properties were created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) assigned to the source image set.
        public let imageSetArn: String?
        /// The image set identifier for the copied source image set.
        public let imageSetId: String
        /// The image set state of the copied source image set.
        public let imageSetState: ImageSetState?
        /// The workflow status of the copied source image set.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus?
        /// The latest version identifier for the copied source image set.
        public let latestVersionId: String
        /// The timestamp when the source image set properties were updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, imageSetArn: String? = nil, imageSetId: String, imageSetState: ImageSetState? = nil, imageSetWorkflowStatus: ImageSetWorkflowStatus? = nil, latestVersionId: String, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.imageSetArn = imageSetArn
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.latestVersionId = latestVersionId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case imageSetArn = "imageSetArn"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "imageSetWorkflowStatus"
            case latestVersionId = "latestVersionId"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateDatastoreRequest: AWSEncodableShape {
        /// A unique identifier for API idempotency.
        public let clientToken: String
        /// The data store name.
        public let datastoreName: String?
        /// The Amazon Resource Name (ARN) assigned to the Key Management Service (KMS) key for accessing encrypted data.
        public let kmsKeyArn: String?
        /// The tags provided when creating a data store.
        public let tags: [String: String]?

        public init(clientToken: String = CreateDatastoreRequest.idempotencyToken(), datastoreName: String? = nil, kmsKeyArn: String? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.datastoreName = datastoreName
            self.kmsKeyArn = kmsKeyArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9._-]+$")
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, max: 256)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, min: 1)
            try self.validate(self.datastoreName, name: "datastoreName", parent: name, pattern: "^[A-Za-z0-9._/#-]+$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 512)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws[a-zA-Z-]{0,16}:kms:[a-z]{2}(-[a-z]{1,16}){1,3}-\\d{1}:\\d{12}:((key/[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})|(alias/[a-zA-Z0-9:/_-]{1,256}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case datastoreName = "datastoreName"
            case kmsKeyArn = "kmsKeyArn"
            case tags = "tags"
        }
    }

    public struct CreateDatastoreResponse: AWSDecodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The data store status.
        public let datastoreStatus: DatastoreStatus

        public init(datastoreId: String, datastoreStatus: DatastoreStatus) {
            self.datastoreId = datastoreId
            self.datastoreStatus = datastoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "datastoreId"
            case datastoreStatus = "datastoreStatus"
        }
    }

    public struct DICOMImportJobProperties: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that grants permissions to access medical imaging resources.
        public let dataAccessRoleArn: String
        /// The data store identifier.
        public let datastoreId: String
        /// The timestamp for when the import job was ended.
        public let endedAt: Date?
        /// The input prefix path for the S3 bucket that contains the DICOM P10 files to be imported.
        public let inputS3Uri: String
        /// The import job identifier.
        public let jobId: String
        /// The import job name.
        public let jobName: String
        /// The filters for listing import jobs based on status.
        public let jobStatus: JobStatus
        /// The error message thrown if an import job fails.
        public let message: String?
        /// The output prefix of the S3 bucket to upload the results of the DICOM import job.
        public let outputS3Uri: String
        /// The timestamp for when the import job was submitted.
        public let submittedAt: Date?

        public init(dataAccessRoleArn: String, datastoreId: String, endedAt: Date? = nil, inputS3Uri: String, jobId: String, jobName: String, jobStatus: JobStatus, message: String? = nil, outputS3Uri: String, submittedAt: Date? = nil) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endedAt = endedAt
            self.inputS3Uri = inputS3Uri
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputS3Uri = outputS3Uri
            self.submittedAt = submittedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn = "dataAccessRoleArn"
            case datastoreId = "datastoreId"
            case endedAt = "endedAt"
            case inputS3Uri = "inputS3Uri"
            case jobId = "jobId"
            case jobName = "jobName"
            case jobStatus = "jobStatus"
            case message = "message"
            case outputS3Uri = "outputS3Uri"
            case submittedAt = "submittedAt"
        }
    }

    public struct DICOMImportJobSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that grants permissions to access medical imaging resources.
        public let dataAccessRoleArn: String?
        /// The data store identifier.
        public let datastoreId: String
        /// The timestamp when an import job ended.
        public let endedAt: Date?
        /// The import job identifier.
        public let jobId: String
        /// The import job name.
        public let jobName: String
        /// The filters for listing import jobs based on status.
        public let jobStatus: JobStatus
        /// The error message thrown if an import job fails.
        public let message: String?
        /// The timestamp when an import job was submitted.
        public let submittedAt: Date?

        public init(dataAccessRoleArn: String? = nil, datastoreId: String, endedAt: Date? = nil, jobId: String, jobName: String, jobStatus: JobStatus, message: String? = nil, submittedAt: Date? = nil) {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endedAt = endedAt
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.submittedAt = submittedAt
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRoleArn = "dataAccessRoleArn"
            case datastoreId = "datastoreId"
            case endedAt = "endedAt"
            case jobId = "jobId"
            case jobName = "jobName"
            case jobStatus = "jobStatus"
            case message = "message"
            case submittedAt = "submittedAt"
        }
    }

    public struct DICOMStudyDateAndTime: AWSEncodableShape {
        /// The DICOM study date provided in yyMMdd format.
        public let dicomStudyDate: String
        /// The DICOM study time provided in HHmmss.FFFFFF format.
        public let dicomStudyTime: String?

        public init(dicomStudyDate: String, dicomStudyTime: String? = nil) {
            self.dicomStudyDate = dicomStudyDate
            self.dicomStudyTime = dicomStudyTime
        }

        public func validate(name: String) throws {
            try self.validate(self.dicomStudyDate, name: "dicomStudyDate", parent: name, max: 18)
            try self.validate(self.dicomStudyTime, name: "dicomStudyTime", parent: name, max: 28)
        }

        private enum CodingKeys: String, CodingKey {
            case dicomStudyDate = "DICOMStudyDate"
            case dicomStudyTime = "DICOMStudyTime"
        }
    }

    public struct DICOMTags: AWSDecodableShape {
        /// The accession number for the DICOM study.
        public let dicomAccessionNumber: String?
        /// The total number of instances in the DICOM study.
        public let dicomNumberOfStudyRelatedInstances: Int?
        /// The total number of series in the DICOM study.
        public let dicomNumberOfStudyRelatedSeries: Int?
        /// The patient birth date.
        public let dicomPatientBirthDate: String?
        /// The unique identifier for a patient in a DICOM Study.
        public let dicomPatientId: String?
        /// The patient name.
        public let dicomPatientName: String?
        /// The patient sex.
        public let dicomPatientSex: String?
        /// The DICOM provided identifier for the series Body Part Examined.
        public let dicomSeriesBodyPart: String?
        /// The DICOM provided identifier for the Series Instance UID.
        public let dicomSeriesInstanceUID: String?
        /// The DICOM provided identifier for the series Modality.
        public let dicomSeriesModality: String?
        /// The DICOM provided identifier for the Series Number.
        public let dicomSeriesNumber: Int?
        /// The study date.
        public let dicomStudyDate: String?
        /// The DICOM provided Study Description.
        public let dicomStudyDescription: String?
        /// The DICOM provided identifier for the Study ID.
        public let dicomStudyId: String?
        /// The DICOM provided identifier for the Study Instance UID.
        public let dicomStudyInstanceUID: String?
        /// The study time.
        public let dicomStudyTime: String?

        public init(dicomAccessionNumber: String? = nil, dicomNumberOfStudyRelatedInstances: Int? = nil, dicomNumberOfStudyRelatedSeries: Int? = nil, dicomPatientBirthDate: String? = nil, dicomPatientId: String? = nil, dicomPatientName: String? = nil, dicomPatientSex: String? = nil, dicomSeriesBodyPart: String? = nil, dicomSeriesInstanceUID: String? = nil, dicomSeriesModality: String? = nil, dicomSeriesNumber: Int? = nil, dicomStudyDate: String? = nil, dicomStudyDescription: String? = nil, dicomStudyId: String? = nil, dicomStudyInstanceUID: String? = nil, dicomStudyTime: String? = nil) {
            self.dicomAccessionNumber = dicomAccessionNumber
            self.dicomNumberOfStudyRelatedInstances = dicomNumberOfStudyRelatedInstances
            self.dicomNumberOfStudyRelatedSeries = dicomNumberOfStudyRelatedSeries
            self.dicomPatientBirthDate = dicomPatientBirthDate
            self.dicomPatientId = dicomPatientId
            self.dicomPatientName = dicomPatientName
            self.dicomPatientSex = dicomPatientSex
            self.dicomSeriesBodyPart = dicomSeriesBodyPart
            self.dicomSeriesInstanceUID = dicomSeriesInstanceUID
            self.dicomSeriesModality = dicomSeriesModality
            self.dicomSeriesNumber = dicomSeriesNumber
            self.dicomStudyDate = dicomStudyDate
            self.dicomStudyDescription = dicomStudyDescription
            self.dicomStudyId = dicomStudyId
            self.dicomStudyInstanceUID = dicomStudyInstanceUID
            self.dicomStudyTime = dicomStudyTime
        }

        private enum CodingKeys: String, CodingKey {
            case dicomAccessionNumber = "DICOMAccessionNumber"
            case dicomNumberOfStudyRelatedInstances = "DICOMNumberOfStudyRelatedInstances"
            case dicomNumberOfStudyRelatedSeries = "DICOMNumberOfStudyRelatedSeries"
            case dicomPatientBirthDate = "DICOMPatientBirthDate"
            case dicomPatientId = "DICOMPatientId"
            case dicomPatientName = "DICOMPatientName"
            case dicomPatientSex = "DICOMPatientSex"
            case dicomSeriesBodyPart = "DICOMSeriesBodyPart"
            case dicomSeriesInstanceUID = "DICOMSeriesInstanceUID"
            case dicomSeriesModality = "DICOMSeriesModality"
            case dicomSeriesNumber = "DICOMSeriesNumber"
            case dicomStudyDate = "DICOMStudyDate"
            case dicomStudyDescription = "DICOMStudyDescription"
            case dicomStudyId = "DICOMStudyId"
            case dicomStudyInstanceUID = "DICOMStudyInstanceUID"
            case dicomStudyTime = "DICOMStudyTime"
        }
    }

    public struct DICOMUpdates: AWSEncodableShape {
        /// The DICOM tags to be removed from ImageSetMetadata.
        public let removableAttributes: AWSBase64Data?
        /// The DICOM tags that need to be updated in ImageSetMetadata.
        public let updatableAttributes: AWSBase64Data?

        public init(removableAttributes: AWSBase64Data? = nil, updatableAttributes: AWSBase64Data? = nil) {
            self.removableAttributes = removableAttributes
            self.updatableAttributes = updatableAttributes
        }

        public func validate(name: String) throws {
            try self.validate(self.removableAttributes, name: "removableAttributes", parent: name, max: 10000)
            try self.validate(self.removableAttributes, name: "removableAttributes", parent: name, min: 1)
            try self.validate(self.updatableAttributes, name: "updatableAttributes", parent: name, max: 10000)
            try self.validate(self.updatableAttributes, name: "updatableAttributes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case removableAttributes = "removableAttributes"
            case updatableAttributes = "updatableAttributes"
        }
    }

    public struct DatastoreProperties: AWSDecodableShape {
        /// The timestamp when the data store was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) for the data store.
        public let datastoreArn: String?
        /// The data store identifier.
        public let datastoreId: String
        /// The data store name.
        public let datastoreName: String
        /// The data store status.
        public let datastoreStatus: DatastoreStatus
        /// The Amazon Resource Name (ARN) assigned to the Key Management Service (KMS) key for accessing encrypted data.
        public let kmsKeyArn: String?
        /// The timestamp when the data store was last updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, datastoreArn: String? = nil, datastoreId: String, datastoreName: String, datastoreStatus: DatastoreStatus, kmsKeyArn: String? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.kmsKeyArn = kmsKeyArn
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case datastoreArn = "datastoreArn"
            case datastoreId = "datastoreId"
            case datastoreName = "datastoreName"
            case datastoreStatus = "datastoreStatus"
            case kmsKeyArn = "kmsKeyArn"
            case updatedAt = "updatedAt"
        }
    }

    public struct DatastoreSummary: AWSDecodableShape {
        /// The timestamp when the data store was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) for the data store.
        public let datastoreArn: String?
        /// The data store identifier.
        public let datastoreId: String
        /// The data store name.
        public let datastoreName: String
        /// The data store status.
        public let datastoreStatus: DatastoreStatus
        /// The timestamp when the data store was last updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, datastoreArn: String? = nil, datastoreId: String, datastoreName: String, datastoreStatus: DatastoreStatus, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case datastoreArn = "datastoreArn"
            case datastoreId = "datastoreId"
            case datastoreName = "datastoreName"
            case datastoreStatus = "datastoreStatus"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteDatastoreRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String

        public init(datastoreId: String) {
            self.datastoreId = datastoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDatastoreResponse: AWSDecodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The data store status.
        public let datastoreStatus: DatastoreStatus

        public init(datastoreId: String, datastoreStatus: DatastoreStatus) {
            self.datastoreId = datastoreId
            self.datastoreStatus = datastoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "datastoreId"
            case datastoreStatus = "datastoreStatus"
        }
    }

    public struct DeleteImageSetRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String

        public init(datastoreId: String, imageSetId: String) {
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.imageSetId, key: "imageSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImageSetResponse: AWSDecodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String
        /// The image set state.
        public let imageSetState: ImageSetState
        /// The image set workflow status.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus

        public init(datastoreId: String, imageSetId: String, imageSetState: ImageSetState, imageSetWorkflowStatus: ImageSetWorkflowStatus) {
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "datastoreId"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "imageSetWorkflowStatus"
        }
    }

    public struct GetDICOMImportJobRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The import job identifier.
        public let jobId: String

        public init(datastoreId: String, jobId: String) {
            self.datastoreId = datastoreId
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 32)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9a-z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDICOMImportJobResponse: AWSDecodableShape {
        /// The properties of the import job.
        public let jobProperties: DICOMImportJobProperties

        public init(jobProperties: DICOMImportJobProperties) {
            self.jobProperties = jobProperties
        }

        private enum CodingKeys: String, CodingKey {
            case jobProperties = "jobProperties"
        }
    }

    public struct GetDatastoreRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String

        public init(datastoreId: String) {
            self.datastoreId = datastoreId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDatastoreResponse: AWSDecodableShape {
        /// The data store properties.
        public let datastoreProperties: DatastoreProperties

        public init(datastoreProperties: DatastoreProperties) {
            self.datastoreProperties = datastoreProperties
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreProperties = "datastoreProperties"
        }
    }

    public struct GetImageFrameRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// Information about the image frame (pixel data) identifier.
        public let imageFrameInformation: ImageFrameInformation
        /// The image set identifier.
        public let imageSetId: String

        public init(datastoreId: String, imageFrameInformation: ImageFrameInformation, imageSetId: String) {
            self.datastoreId = datastoreId
            self.imageFrameInformation = imageFrameInformation
            self.imageSetId = imageSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.datastoreId, key: "datastoreId")
            try container.encode(self.imageFrameInformation)
            request.encodePath(self.imageSetId, key: "imageSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.imageFrameInformation.validate(name: "\(name).imageFrameInformation")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageFrameResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The format in which the image frame information is returned to the customer. Default is  application/octet-stream.
        public let contentType: String?
        /// The blob containing the aggregated image frame information.
        public let imageFrameBlob: AWSHTTPBody

        public init(contentType: String? = nil, imageFrameBlob: AWSHTTPBody) {
            self.contentType = contentType
            self.imageFrameBlob = imageFrameBlob
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.imageFrameBlob = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageSetMetadataRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String
        /// The image set version identifier.
        public let versionId: String?

        public init(datastoreId: String, imageSetId: String, versionId: String? = nil) {
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.imageSetId, key: "imageSetId")
            request.encodeQuery(self.versionId, key: "version")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageSetMetadataResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The compression format in which image set metadata attributes are returned.
        public let contentEncoding: String?
        /// The format in which the study metadata is returned to the customer. Default is text/plain.
        public let contentType: String?
        /// The blob containing the aggregated metadata information for the image set.
        public let imageSetMetadataBlob: AWSHTTPBody

        public init(contentEncoding: String? = nil, contentType: String? = nil, imageSetMetadataBlob: AWSHTTPBody) {
            self.contentEncoding = contentEncoding
            self.contentType = contentType
            self.imageSetMetadataBlob = imageSetMetadataBlob
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.contentEncoding = try response.decodeHeaderIfPresent(String.self, key: "Content-Encoding")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.imageSetMetadataBlob = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageSetRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String
        /// The image set version identifier.
        public let versionId: String?

        public init(datastoreId: String, imageSetId: String, versionId: String? = nil) {
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.imageSetId, key: "imageSetId")
            request.encodeQuery(self.versionId, key: "version")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageSetResponse: AWSDecodableShape {
        /// The timestamp when image set properties were created.
        public let createdAt: Date?
        /// The data store identifier.
        public let datastoreId: String
        /// The timestamp when the image set properties were deleted.
        public let deletedAt: Date?
        /// The Amazon Resource Name (ARN) assigned to the image set.
        public let imageSetArn: String?
        /// The image set identifier.
        public let imageSetId: String
        /// The image set state.
        public let imageSetState: ImageSetState
        /// The image set workflow status.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus?
        /// The error message thrown if an image set action fails.
        public let message: String?
        /// The timestamp when image set properties were updated.
        public let updatedAt: Date?
        /// The image set version identifier.
        public let versionId: String

        public init(createdAt: Date? = nil, datastoreId: String, deletedAt: Date? = nil, imageSetArn: String? = nil, imageSetId: String, imageSetState: ImageSetState, imageSetWorkflowStatus: ImageSetWorkflowStatus? = nil, message: String? = nil, updatedAt: Date? = nil, versionId: String) {
            self.createdAt = createdAt
            self.datastoreId = datastoreId
            self.deletedAt = deletedAt
            self.imageSetArn = imageSetArn
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.message = message
            self.updatedAt = updatedAt
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case datastoreId = "datastoreId"
            case deletedAt = "deletedAt"
            case imageSetArn = "imageSetArn"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "imageSetWorkflowStatus"
            case message = "message"
            case updatedAt = "updatedAt"
            case versionId = "versionId"
        }
    }

    public struct ImageFrameInformation: AWSEncodableShape {
        /// The image frame (pixel data) identifier.
        public let imageFrameId: String

        public init(imageFrameId: String) {
            self.imageFrameId = imageFrameId
        }

        public func validate(name: String) throws {
            try self.validate(self.imageFrameId, name: "imageFrameId", parent: name, pattern: "^[0-9a-z]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageFrameId = "imageFrameId"
        }
    }

    public struct ImageSetProperties: AWSDecodableShape {
        /// The timestamp when the image set properties were created.
        public let createdAt: Date?
        /// The timestamp when the image set properties were deleted.
        public let deletedAt: Date?
        /// The image set identifier.
        public let imageSetId: String
        /// The image set state.
        public let imageSetState: ImageSetState
        /// The image set workflow status.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus?
        /// The error message thrown if an image set action fails.
        public let message: String?
        /// The timestamp when the image set properties were updated.
        public let updatedAt: Date?
        /// The image set version identifier.
        public let versionId: String

        public init(createdAt: Date? = nil, deletedAt: Date? = nil, imageSetId: String, imageSetState: ImageSetState, imageSetWorkflowStatus: ImageSetWorkflowStatus? = nil, message: String? = nil, updatedAt: Date? = nil, versionId: String) {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.message = message
            self.updatedAt = updatedAt
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case deletedAt = "deletedAt"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "ImageSetWorkflowStatus"
            case message = "message"
            case updatedAt = "updatedAt"
            case versionId = "versionId"
        }
    }

    public struct ImageSetsMetadataSummary: AWSDecodableShape {
        /// The time an image set is created. Sample creation  date is provided in 1985-04-12T23:20:50.52Z format.
        public let createdAt: Date?
        /// The DICOM tags associated with the image set.
        public let dicomTags: DICOMTags?
        /// The image set identifier.
        public let imageSetId: String
        /// The time an image set was last updated.
        public let updatedAt: Date?
        /// The image set version.
        public let version: Int?

        public init(createdAt: Date? = nil, dicomTags: DICOMTags? = nil, imageSetId: String, updatedAt: Date? = nil, version: Int? = nil) {
            self.createdAt = createdAt
            self.dicomTags = dicomTags
            self.imageSetId = imageSetId
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dicomTags = "DICOMTags"
            case imageSetId = "imageSetId"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct ListDICOMImportJobsRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The filters for listing import jobs based on status.
        public let jobStatus: JobStatus?
        /// The max results count. The upper bound is determined by load testing.
        public let maxResults: Int?
        /// The pagination token used to request the list of import jobs on the next page.
        public let nextToken: String?

        public init(datastoreId: String, jobStatus: JobStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datastoreId = datastoreId
            self.jobStatus = jobStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodeQuery(self.jobStatus, key: "jobStatus")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDICOMImportJobsResponse: AWSDecodableShape {
        /// A list of job summaries.
        public let jobSummaries: [DICOMImportJobSummary]
        /// The pagination token used to retrieve the list of import jobs on the next page.
        public let nextToken: String?

        public init(jobSummaries: [DICOMImportJobSummary], nextToken: String? = nil) {
            self.jobSummaries = jobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobSummaries = "jobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatastoresRequest: AWSEncodableShape {
        /// The data store status.
        public let datastoreStatus: DatastoreStatus?
        /// Valid Range: Minimum value of 1. Maximum value of 50.
        public let maxResults: Int?
        /// The pagination token used to request the list of data stores on the next page.
        public let nextToken: String?

        public init(datastoreStatus: DatastoreStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datastoreStatus = datastoreStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.datastoreStatus, key: "datastoreStatus")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDatastoresResponse: AWSDecodableShape {
        /// The list of summaries of data stores.
        public let datastoreSummaries: [DatastoreSummary]?
        /// The pagination token used to retrieve the list of data stores on the next page.
        public let nextToken: String?

        public init(datastoreSummaries: [DatastoreSummary]? = nil, nextToken: String? = nil) {
            self.datastoreSummaries = datastoreSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreSummaries = "datastoreSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListImageSetVersionsRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String
        /// The max results count.
        public let maxResults: Int?
        /// The pagination token used to request the list of image set versions on the next page.
        public let nextToken: String?

        public init(datastoreId: String, imageSetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.imageSetId, key: "imageSetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListImageSetVersionsResponse: AWSDecodableShape {
        /// Lists all properties associated with an image set.
        public let imageSetPropertiesList: [ImageSetProperties]
        /// The pagination token used to retrieve the list of image set versions on the next page.
        public let nextToken: String?

        public init(imageSetPropertiesList: [ImageSetProperties], nextToken: String? = nil) {
            self.imageSetPropertiesList = imageSetPropertiesList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case imageSetPropertiesList = "imageSetPropertiesList"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the medical imaging resource to list tags for.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:medical-imaging:[a-z0-9-]+:[0-9]{12}:datastore/[0-9a-z]{32}(/imageset/[0-9a-z]{32})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of all tags associated with a medical imaging resource.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct SearchCriteria: AWSEncodableShape {
        /// The filters for the search criteria.
        public let filters: [SearchFilter]?
        /// The sort input for search criteria.
        public let sort: Sort?

        public init(filters: [SearchFilter]? = nil, sort: Sort? = nil) {
            self.filters = filters
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case sort = "sort"
        }
    }

    public struct SearchFilter: AWSEncodableShape {
        /// The search filter operator for imageSetDateTime.
        public let `operator`: Operator
        /// The search filter values.
        public let values: [SearchByAttributeValue]

        public init(operator: Operator, values: [SearchByAttributeValue]) {
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try $0.validate(name: "\(name).values[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct SearchImageSetsRequest: AWSEncodableShape {
        /// The identifier of the data store where the image sets reside.
        public let datastoreId: String
        /// The maximum number of results that can be returned in a search.
        public let maxResults: Int?
        /// The token used for pagination of results returned in the response. Use the token returned from the previous request to continue results where the previous request ended.
        public let nextToken: String?
        /// The search criteria that filters by applying a maximum of 1 item to SearchByAttribute.
        public let searchCriteria: SearchCriteria?

        public init(datastoreId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: SearchCriteria? = nil) {
            self.datastoreId = datastoreId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchCriteria)
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\p{ASCII}{0,8192}$")
            try self.searchCriteria?.validate(name: "\(name).searchCriteria")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct SearchImageSetsResponse: AWSDecodableShape {
        /// The model containing the image set results.
        public let imageSetsMetadataSummaries: [ImageSetsMetadataSummary]
        /// The token for pagination results.
        public let nextToken: String?
        /// The sort order for image set search results.
        public let sort: Sort?

        public init(imageSetsMetadataSummaries: [ImageSetsMetadataSummary], nextToken: String? = nil, sort: Sort? = nil) {
            self.imageSetsMetadataSummaries = imageSetsMetadataSummaries
            self.nextToken = nextToken
            self.sort = sort
        }

        private enum CodingKeys: String, CodingKey {
            case imageSetsMetadataSummaries = "imageSetsMetadataSummaries"
            case nextToken = "nextToken"
            case sort = "sort"
        }
    }

    public struct Sort: AWSEncodableShape & AWSDecodableShape {
        /// The sort field for search criteria.
        public let sortField: SortField
        /// The sort order for search criteria.
        public let sortOrder: SortOrder

        public init(sortField: SortField, sortOrder: SortOrder) {
            self.sortField = sortField
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortField = "sortField"
            case sortOrder = "sortOrder"
        }
    }

    public struct StartDICOMImportJobRequest: AWSEncodableShape {
        /// A unique identifier for API idempotency.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the IAM role that grants permission to access medical imaging resources.
        public let dataAccessRoleArn: String
        /// The data store identifier.
        public let datastoreId: String
        /// The input prefix path for the S3 bucket that contains the DICOM files to be imported.
        public let inputS3Uri: String
        /// The import job name.
        public let jobName: String?
        /// The output prefix of the S3 bucket to upload the results of the DICOM import job.
        public let outputS3Uri: String

        public init(clientToken: String = StartDICOMImportJobRequest.idempotencyToken(), dataAccessRoleArn: String, datastoreId: String, inputS3Uri: String, jobName: String? = nil, outputS3Uri: String) {
            self.clientToken = clientToken
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.inputS3Uri = inputS3Uri
            self.jobName = jobName
            self.outputS3Uri = outputS3Uri
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.clientToken, forKey: .clientToken)
            try container.encode(self.dataAccessRoleArn, forKey: .dataAccessRoleArn)
            request.encodePath(self.datastoreId, key: "datastoreId")
            try container.encode(self.inputS3Uri, forKey: .inputS3Uri)
            try container.encodeIfPresent(self.jobName, forKey: .jobName)
            try container.encode(self.outputS3Uri, forKey: .outputS3Uri)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9._-]+$")
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 2048)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, min: 20)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::[0-9]{12}:role/.+$")
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.inputS3Uri, name: "inputS3Uri", parent: name, max: 1024)
            try self.validate(self.inputS3Uri, name: "inputS3Uri", parent: name, min: 1)
            try self.validate(self.inputS3Uri, name: "inputS3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[A-Za-z0-9._/#-]+$")
            try self.validate(self.outputS3Uri, name: "outputS3Uri", parent: name, max: 1024)
            try self.validate(self.outputS3Uri, name: "outputS3Uri", parent: name, min: 1)
            try self.validate(self.outputS3Uri, name: "outputS3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dataAccessRoleArn = "dataAccessRoleArn"
            case inputS3Uri = "inputS3Uri"
            case jobName = "jobName"
            case outputS3Uri = "outputS3Uri"
        }
    }

    public struct StartDICOMImportJobResponse: AWSDecodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The import job identifier.
        public let jobId: String
        /// The import job status.
        public let jobStatus: JobStatus
        /// The timestamp when the import job was submitted.
        public let submittedAt: Date

        public init(datastoreId: String, jobId: String, jobStatus: JobStatus, submittedAt: Date) {
            self.datastoreId = datastoreId
            self.jobId = jobId
            self.jobStatus = jobStatus
            self.submittedAt = submittedAt
        }

        private enum CodingKeys: String, CodingKey {
            case datastoreId = "datastoreId"
            case jobId = "jobId"
            case jobStatus = "jobStatus"
            case submittedAt = "submittedAt"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the medical imaging resource that tags are being added to.
        public let resourceArn: String
        /// The user-specified key and value tag pairs added to a medical imaging resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:medical-imaging:[a-z0-9-]+:[0-9]{12}:datastore/[0-9a-z]{32}(/imageset/[0-9a-z]{32})?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the medical imaging resource that tags are being removed from.
        public let resourceArn: String
        /// The keys for the tags to be removed from the medical imaging resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws((-us-gov)|(-iso)|(-iso-b)|(-cn))?:medical-imaging:[a-z0-9-]+:[0-9]{12}:datastore/[0-9a-z]{32}(/imageset/[0-9a-z]{32})?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateImageSetMetadataRequest: AWSEncodableShape {
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String
        /// The latest image set version identifier.
        public let latestVersionId: String
        /// Update image set metadata updates.
        public let updateImageSetMetadataUpdates: MetadataUpdates

        public init(datastoreId: String, imageSetId: String, latestVersionId: String, updateImageSetMetadataUpdates: MetadataUpdates) {
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
            self.latestVersionId = latestVersionId
            self.updateImageSetMetadataUpdates = updateImageSetMetadataUpdates
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.datastoreId, key: "datastoreId")
            request.encodePath(self.imageSetId, key: "imageSetId")
            request.encodeQuery(self.latestVersionId, key: "latestVersion")
            try container.encode(self.updateImageSetMetadataUpdates)
        }

        public func validate(name: String) throws {
            try self.validate(self.datastoreId, name: "datastoreId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.imageSetId, name: "imageSetId", parent: name, pattern: "^[0-9a-z]{32}$")
            try self.validate(self.latestVersionId, name: "latestVersionId", parent: name, pattern: "^\\d+$")
            try self.updateImageSetMetadataUpdates.validate(name: "\(name).updateImageSetMetadataUpdates")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateImageSetMetadataResponse: AWSDecodableShape {
        /// The timestamp when image set metadata was created.
        public let createdAt: Date?
        /// The data store identifier.
        public let datastoreId: String
        /// The image set identifier.
        public let imageSetId: String
        /// The image set state.
        public let imageSetState: ImageSetState
        /// The image set workflow status.
        public let imageSetWorkflowStatus: ImageSetWorkflowStatus?
        /// The latest image set version identifier.
        public let latestVersionId: String
        /// The error message thrown if an update image set metadata action fails.
        public let message: String?
        /// The timestamp when image set metadata was updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, datastoreId: String, imageSetId: String, imageSetState: ImageSetState, imageSetWorkflowStatus: ImageSetWorkflowStatus? = nil, latestVersionId: String, message: String? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.datastoreId = datastoreId
            self.imageSetId = imageSetId
            self.imageSetState = imageSetState
            self.imageSetWorkflowStatus = imageSetWorkflowStatus
            self.latestVersionId = latestVersionId
            self.message = message
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case datastoreId = "datastoreId"
            case imageSetId = "imageSetId"
            case imageSetState = "imageSetState"
            case imageSetWorkflowStatus = "imageSetWorkflowStatus"
            case latestVersionId = "latestVersionId"
            case message = "message"
            case updatedAt = "updatedAt"
        }
    }

    public struct MetadataUpdates: AWSEncodableShape {
        /// The object containing removableAttributes and updatableAttributes.
        public let dicomUpdates: DICOMUpdates?

        public init(dicomUpdates: DICOMUpdates? = nil) {
            self.dicomUpdates = dicomUpdates
        }

        public func validate(name: String) throws {
            try self.dicomUpdates?.validate(name: "\(name).dicomUpdates")
        }

        private enum CodingKeys: String, CodingKey {
            case dicomUpdates = "DICOMUpdates"
        }
    }
}

// MARK: - Errors

/// Error enum for MedicalImaging
public struct MedicalImagingErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MedicalImaging
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The user does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred during processing of the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request caused a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints set by the service.
    public static var validationException: Self { .init(.validationException) }
}

extension MedicalImagingErrorType: Equatable {
    public static func == (lhs: MedicalImagingErrorType, rhs: MedicalImagingErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MedicalImagingErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
