//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS MedicalImaging service.
///
/// This is the AWS HealthImaging API Reference. AWS HealthImaging is an AWS service for storing, accessing, and analyzing medical images. For an introduction to the service, see the  AWS HealthImaging Developer Guide .  We recommend using one of the AWS Software Development Kits (SDKs) for your programming language, as they take care of request authentication, serialization, and connection management. For more information, see Tools to build on AWS. For information about using AWS HealthImaging API actions in one of the language-specific AWS SDKs, refer to the See Also link at the end of each section that describes an API action or data type.  The following sections list AWS HealthImaging API actions categorized according to functionality. Links are  provided to actions within this Reference, along with links back to corresponding sections in the  AWS HealthImaging Developer Guide so you can view console procedures and CLI/SDK code examples.  Data store actions     CreateDatastore – See  Creating a data store.    GetDatastore – See  Getting data store properties.    ListDatastores – See  Listing data stores.    DeleteDatastore – See  Deleting a data store.    Import job actions     StartDICOMImportJob – See  Starting an import job.    GetDICOMImportJob – See  Getting import job properties.    ListDICOMImportJobs – See  Listing import jobs.    Image set access actions     SearchImageSets – See  Searching image sets.    GetImageSet – See  Getting image set properties.    GetImageSetMetadata – See  Getting image set metadata.    GetImageFrame – See  Getting image set pixel data.    Image set modification actions     ListImageSetVersions – See  Listing image set versions.    UpdateImageSetMetadata – See  Updating image set metadata.    CopyImageSet – See  Copying an image set.    DeleteImageSet – See  Deleting an image set.    Tagging actions     TagResource – See  Tagging a data store and Tagging an image set.    ListTagsForResource – See  Tagging a data store and Tagging an image set.    UntagResource – See  Tagging a data store and Tagging an image set.
public struct MedicalImaging: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the MedicalImaging client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "medical-imaging",
            serviceProtocol: .restjson,
            apiVersion: "2023-07-19",
            endpoint: endpoint,
            errorType: MedicalImagingErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Copy an image set.
    public func copyImageSet(_ input: CopyImageSetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CopyImageSetResponse> {
        return self.client.execute(operation: "CopyImageSet", path: "/datastore/{datastoreId}/imageSet/{sourceImageSetId}/copyImageSet", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "runtime-", logger: logger, on: eventLoop)
    }

    /// Create a data store.
    public func createDatastore(_ input: CreateDatastoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDatastoreResponse> {
        return self.client.execute(operation: "CreateDatastore", path: "/datastore", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Delete a data store.  Before a data store can be deleted, you must first delete all image sets within it.
    public func deleteDatastore(_ input: DeleteDatastoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteDatastoreResponse> {
        return self.client.execute(operation: "DeleteDatastore", path: "/datastore/{datastoreId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Delete an image set.
    public func deleteImageSet(_ input: DeleteImageSetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteImageSetResponse> {
        return self.client.execute(operation: "DeleteImageSet", path: "/datastore/{datastoreId}/imageSet/{imageSetId}/deleteImageSet", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "runtime-", logger: logger, on: eventLoop)
    }

    /// Get the import job properties to learn more about the job or job progress.
    public func getDICOMImportJob(_ input: GetDICOMImportJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDICOMImportJobResponse> {
        return self.client.execute(operation: "GetDICOMImportJob", path: "/getDICOMImportJob/datastore/{datastoreId}/job/{jobId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get data store properties.
    public func getDatastore(_ input: GetDatastoreRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDatastoreResponse> {
        return self.client.execute(operation: "GetDatastore", path: "/datastore/{datastoreId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Get an image frame (pixel data) for an image set.
    public func getImageFrame(_ input: GetImageFrameRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetImageFrameResponse> {
        return self.client.execute(operation: "GetImageFrame", path: "/datastore/{datastoreId}/imageSet/{imageSetId}/getImageFrame", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "runtime-", logger: logger, on: eventLoop)
    }

    /// Get image set properties.
    public func getImageSet(_ input: GetImageSetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetImageSetResponse> {
        return self.client.execute(operation: "GetImageSet", path: "/datastore/{datastoreId}/imageSet/{imageSetId}/getImageSet", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "runtime-", logger: logger, on: eventLoop)
    }

    /// Get metadata attributes for an image set.
    public func getImageSetMetadata(_ input: GetImageSetMetadataRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetImageSetMetadataResponse> {
        return self.client.execute(operation: "GetImageSetMetadata", path: "/datastore/{datastoreId}/imageSet/{imageSetId}/getImageSetMetadata", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "runtime-", logger: logger, on: eventLoop)
    }

    /// List import jobs created by this AWS account for a specific data store.
    public func listDICOMImportJobs(_ input: ListDICOMImportJobsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDICOMImportJobsResponse> {
        return self.client.execute(operation: "ListDICOMImportJobs", path: "/listDICOMImportJobs/datastore/{datastoreId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List data stores created by this AWS account.
    public func listDatastores(_ input: ListDatastoresRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDatastoresResponse> {
        return self.client.execute(operation: "ListDatastores", path: "/datastore", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List image set versions.
    public func listImageSetVersions(_ input: ListImageSetVersionsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListImageSetVersionsResponse> {
        return self.client.execute(operation: "ListImageSetVersions", path: "/datastore/{datastoreId}/imageSet/{imageSetId}/listImageSetVersions", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "runtime-", logger: logger, on: eventLoop)
    }

    /// Lists all tags associated with a medical imaging resource.
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTagsForResourceResponse> {
        return self.client.execute(operation: "ListTagsForResource", path: "/tags/{resourceArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Search image sets based on defined input attributes.
    public func searchImageSets(_ input: SearchImageSetsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SearchImageSetsResponse> {
        return self.client.execute(operation: "SearchImageSets", path: "/datastore/{datastoreId}/searchImageSets", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "runtime-", logger: logger, on: eventLoop)
    }

    /// Start importing bulk data into an ACTIVE data store. The import job imports DICOM P10 files found in the S3 prefix specified by the inputS3Uri parameter. The import job stores processing results in the file specified by the outputS3Uri parameter.
    public func startDICOMImportJob(_ input: StartDICOMImportJobRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartDICOMImportJobResponse> {
        return self.client.execute(operation: "StartDICOMImportJob", path: "/startDICOMImportJob/datastore/{datastoreId}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds a user-specifed key and value tag to a medical imaging resource.
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TagResourceResponse> {
        return self.client.execute(operation: "TagResource", path: "/tags/{resourceArn}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes tags from a medical imaging resource.
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UntagResourceResponse> {
        return self.client.execute(operation: "UntagResource", path: "/tags/{resourceArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update image set metadata attributes.
    public func updateImageSetMetadata(_ input: UpdateImageSetMetadataRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateImageSetMetadataResponse> {
        return self.client.execute(operation: "UpdateImageSetMetadata", path: "/datastore/{datastoreId}/imageSet/{imageSetId}/updateImageSetMetadata", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "runtime-", logger: logger, on: eventLoop)
    }

    // MARK: Streaming API Calls

    /// Get an image frame (pixel data) for an image set.
    public func getImageFrameStreaming(_ input: GetImageFrameRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil, _ stream: @escaping (ByteBuffer, EventLoop) -> EventLoopFuture<Void>) -> EventLoopFuture<GetImageFrameResponse> {
        return self.client.execute(operation: "GetImageFrame", path: "/datastore/{datastoreId}/imageSet/{imageSetId}/getImageFrame", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "runtime-", logger: logger, on: eventLoop, stream: stream)
    }

    /// Get metadata attributes for an image set.
    public func getImageSetMetadataStreaming(_ input: GetImageSetMetadataRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil, _ stream: @escaping (ByteBuffer, EventLoop) -> EventLoopFuture<Void>) -> EventLoopFuture<GetImageSetMetadataResponse> {
        return self.client.execute(operation: "GetImageSetMetadata", path: "/datastore/{datastoreId}/imageSet/{imageSetId}/getImageSetMetadata", httpMethod: .POST, serviceConfig: self.config, input: input, hostPrefix: "runtime-", logger: logger, on: eventLoop, stream: stream)
    }
}

extension MedicalImaging {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: MedicalImaging, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension MedicalImaging {
    /// List import jobs created by this AWS account for a specific data store.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDICOMImportJobsPaginator<Result>(
        _ input: ListDICOMImportJobsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDICOMImportJobsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listDICOMImportJobs,
            inputKey: \ListDICOMImportJobsRequest.nextToken,
            outputKey: \ListDICOMImportJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDICOMImportJobsPaginator(
        _ input: ListDICOMImportJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDICOMImportJobsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listDICOMImportJobs,
            inputKey: \ListDICOMImportJobsRequest.nextToken,
            outputKey: \ListDICOMImportJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// List data stores created by this AWS account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDatastoresPaginator<Result>(
        _ input: ListDatastoresRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDatastoresResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listDatastores,
            inputKey: \ListDatastoresRequest.nextToken,
            outputKey: \ListDatastoresResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDatastoresPaginator(
        _ input: ListDatastoresRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDatastoresResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listDatastores,
            inputKey: \ListDatastoresRequest.nextToken,
            outputKey: \ListDatastoresResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// List image set versions.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listImageSetVersionsPaginator<Result>(
        _ input: ListImageSetVersionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListImageSetVersionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listImageSetVersions,
            inputKey: \ListImageSetVersionsRequest.nextToken,
            outputKey: \ListImageSetVersionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listImageSetVersionsPaginator(
        _ input: ListImageSetVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListImageSetVersionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listImageSetVersions,
            inputKey: \ListImageSetVersionsRequest.nextToken,
            outputKey: \ListImageSetVersionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Search image sets based on defined input attributes.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchImageSetsPaginator<Result>(
        _ input: SearchImageSetsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchImageSetsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.searchImageSets,
            inputKey: \SearchImageSetsRequest.nextToken,
            outputKey: \SearchImageSetsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchImageSetsPaginator(
        _ input: SearchImageSetsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchImageSetsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.searchImageSets,
            inputKey: \SearchImageSetsRequest.nextToken,
            outputKey: \SearchImageSetsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension MedicalImaging.ListDICOMImportJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> MedicalImaging.ListDICOMImportJobsRequest {
        return .init(
            datastoreId: self.datastoreId,
            jobStatus: self.jobStatus,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MedicalImaging.ListDatastoresRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> MedicalImaging.ListDatastoresRequest {
        return .init(
            datastoreStatus: self.datastoreStatus,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MedicalImaging.ListImageSetVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> MedicalImaging.ListImageSetVersionsRequest {
        return .init(
            datastoreId: self.datastoreId,
            imageSetId: self.imageSetId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MedicalImaging.SearchImageSetsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> MedicalImaging.SearchImageSetsRequest {
        return .init(
            datastoreId: self.datastoreId,
            maxResults: self.maxResults,
            nextToken: token,
            searchCriteria: self.searchCriteria
        )
    }
}
