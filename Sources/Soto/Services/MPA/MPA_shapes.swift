//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MPA {
    // MARK: Enums

    public enum ActionCompletionStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case autoCompletionUponApproval = "AUTO_COMPLETION_UPON_APPROVAL"
        public var description: String { return self.rawValue }
    }

    public enum ApprovalTeamStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        case inactive = "INACTIVE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ApprovalTeamStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleteFailedApproval = "DELETE_FAILED_APPROVAL"
        case deleteFailedValidation = "DELETE_FAILED_VALIDATION"
        case deletePendingApproval = "DELETE_PENDING_APPROVAL"
        case failedActivation = "FAILED_ACTIVATION"
        case failedValidation = "FAILED_VALIDATION"
        case pendingActivation = "PENDING_ACTIVATION"
        case updateFailedActivation = "UPDATE_FAILED_ACTIVATION"
        case updateFailedApproval = "UPDATE_FAILED_APPROVAL"
        case updateFailedValidation = "UPDATE_FAILED_VALIDATION"
        case updatePendingActivation = "UPDATE_PENDING_ACTIVATION"
        case updatePendingApproval = "UPDATE_PENDING_APPROVAL"
        case validating = "VALIDATING"
        public var description: String { return self.rawValue }
    }

    public enum FilterField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionName = "ActionName"
        case approvalTeamName = "ApprovalTeamName"
        case initiationTime = "InitiationTime"
        case sessionStatus = "SessionStatus"
        case vote = "Vote"
        case votingTime = "VotingTime"
        public var description: String { return self.rawValue }
    }

    public enum IdentitySourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case error = "ERROR"
        public var description: String { return self.rawValue }
    }

    public enum IdentitySourceStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case deletionFailed = "DELETION_FAILED"
        case idcInstanceNotFound = "IDC_INSTANCE_NOT_FOUND"
        case idcInstanceNotValid = "IDC_INSTANCE_NOT_VALID"
        public var description: String { return self.rawValue }
    }

    public enum IdentitySourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iamIdentityCenter = "IAM_IDENTITY_CENTER"
        public var description: String { return self.rawValue }
    }

    public enum IdentityStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accepted = "ACCEPTED"
        case invalid = "INVALID"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum Operator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case doesNotContain = "NOT_CONTAINS"
        case equals = "EQ"
        case greaterThan = "GT"
        case greaterThanOrEqualTo = "GTE"
        case lessThan = "LT"
        case lessThanOrEqualTo = "LTE"
        case notEquals = "NE"
        public var description: String { return self.rawValue }
    }

    public enum PolicyStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachable = "ATTACHABLE"
        case deprecated = "DEPRECATED"
        public var description: String { return self.rawValue }
    }

    public enum PolicyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsManaged = "AWS_MANAGED"
        case awsRam = "AWS_RAM"
        public var description: String { return self.rawValue }
    }

    public enum SessionExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case executed = "EXECUTED"
        case failed = "FAILED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum SessionResponse: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approved = "APPROVED"
        case noResponse = "NO_RESPONSE"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum SessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approved = "APPROVED"
        case cancelled = "CANCELLED"
        case creating = "CREATING"
        case failed = "FAILED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum SessionStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configurationChanged = "CONFIGURATION_CHANGED"
        case expired = "EXPIRED"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ApprovalTeamRequestApprover: AWSEncodableShape {
        /// ID for the user.
        public let primaryIdentityId: String
        /// Amazon Resource Name (ARN) for the identity source. The identity source manages the user authentication for approvers.
        public let primaryIdentitySourceArn: String

        @inlinable
        public init(primaryIdentityId: String, primaryIdentitySourceArn: String) {
            self.primaryIdentityId = primaryIdentityId
            self.primaryIdentitySourceArn = primaryIdentitySourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.primaryIdentityId, name: "primaryIdentityId", parent: name, max: 100)
            try self.validate(self.primaryIdentityId, name: "primaryIdentityId", parent: name, min: 1)
            try self.validate(self.primaryIdentitySourceArn, name: "primaryIdentitySourceArn", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case primaryIdentityId = "PrimaryIdentityId"
            case primaryIdentitySourceArn = "PrimaryIdentitySourceArn"
        }
    }

    public struct CancelSessionRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the session.
        public let sessionArn: String

        @inlinable
        public init(sessionArn: String) {
            self.sessionArn = sessionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sessionArn, key: "SessionArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, max: 2048)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, min: 20)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, pattern: "^arn:aws(-[^:]+)?:mpa:[a-z0-9-]{1,20}:[0-9]{12}:session/[a-zA-Z0-9._-]+/[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelSessionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateApprovalTeamRequest: AWSEncodableShape {
        /// An ApprovalStrategy object. Contains details for how the team grants approval.
        public let approvalStrategy: ApprovalStrategy
        /// An array of ApprovalTeamRequesterApprovers objects. Contains details for the approvers in the team.
        public let approvers: [ApprovalTeamRequestApprover]
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services populates this field.   What is idempotency?  When you make a mutating API request, the request typically returns a result before the operation's asynchronous workflows have completed. Operations might also time out or encounter other server issues before they complete, even though the request has already returned a result. This could make it difficult to determine whether the request succeeded or not, and could lead to multiple retries to ensure that the operation completes successfully. However, if the original request and the subsequent retries are successful, the operation is completed multiple times. This means that you might create more resources than you intended.  Idempotency ensures that an API request completes no more than one time. With an idempotent request, if the original request completes successfully, any subsequent retries complete successfully without performing any further actions.
        public let clientToken: String?
        /// Description for the team.
        public let description: String
        /// Name of the team.
        public let name: String
        /// An array of PolicyReference objects. Contains a list of policies that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see How other services work with Multi-party approval in the Multi-party approval User Guide.
        public let policies: [PolicyReference]
        /// Tags you want to attach to the team.
        public let tags: [String: String]?

        @inlinable
        public init(approvalStrategy: ApprovalStrategy, approvers: [ApprovalTeamRequestApprover], clientToken: String? = CreateApprovalTeamRequest.idempotencyToken(), description: String, name: String, policies: [PolicyReference], tags: [String: String]? = nil) {
            self.approvalStrategy = approvalStrategy
            self.approvers = approvers
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policies = policies
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.approvers.forEach {
                try $0.validate(name: "\(name).approvers[]")
            }
            try self.validate(self.approvers, name: "approvers", parent: name, max: 20)
            try self.validate(self.approvers, name: "approvers", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9._-]+$")
            try self.policies.forEach {
                try $0.validate(name: "\(name).policies[]")
            }
            try self.validate(self.policies, name: "policies", parent: name, max: 10)
            try self.validate(self.policies, name: "policies", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case approvalStrategy = "ApprovalStrategy"
            case approvers = "Approvers"
            case clientToken = "ClientToken"
            case description = "Description"
            case name = "Name"
            case policies = "Policies"
            case tags = "Tags"
        }
    }

    public struct CreateApprovalTeamResponse: AWSDecodableShape {
        /// Amazon Resource Name (ARN) for the team that was created.
        public let arn: String?
        /// Timestamp when the team was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Name of the team that was created.
        public let name: String?
        /// Version ID for the team that was created. When a team is updated, the version ID changes.
        public let versionId: String?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, name: String? = nil, versionId: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.name = name
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case name = "Name"
            case versionId = "VersionId"
        }
    }

    public struct CreateIdentitySourceRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services populates this field.   What is idempotency?  When you make a mutating API request, the request typically returns a result before the operation's asynchronous workflows have completed. Operations might also time out or encounter other server issues before they complete, even though the request has already returned a result. This could make it difficult to determine whether the request succeeded or not, and could lead to multiple retries to ensure that the operation completes successfully. However, if the original request and the subsequent retries are successful, the operation is completed multiple times. This means that you might create more resources than you intended.  Idempotency ensures that an API request completes no more than one time. With an idempotent request, if the original request completes successfully, any subsequent retries complete successfully without performing any further actions.
        public let clientToken: String?
        /// A  IdentitySourceParameters object. Contains details for the resource that provides identities to the identity source. For example, an IAM Identity Center instance.
        public let identitySourceParameters: IdentitySourceParameters
        /// Tag you want to attach to the identity source.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateIdentitySourceRequest.idempotencyToken(), identitySourceParameters: IdentitySourceParameters, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.identitySourceParameters = identitySourceParameters
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.identitySourceParameters.validate(name: "\(name).identitySourceParameters")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case identitySourceParameters = "IdentitySourceParameters"
            case tags = "Tags"
        }
    }

    public struct CreateIdentitySourceResponse: AWSDecodableShape {
        /// Timestamp when the identity source was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Amazon Resource Name (ARN) for the identity source that was created.
        public let identitySourceArn: String?
        /// The type of resource that provided identities to the identity source. For example, an IAM Identity Center instance.
        public let identitySourceType: IdentitySourceType?

        @inlinable
        public init(creationTime: Date? = nil, identitySourceArn: String? = nil, identitySourceType: IdentitySourceType? = nil) {
            self.creationTime = creationTime
            self.identitySourceArn = identitySourceArn
            self.identitySourceType = identitySourceType
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case identitySourceArn = "IdentitySourceArn"
            case identitySourceType = "IdentitySourceType"
        }
    }

    public struct DeleteIdentitySourceRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for identity source.
        public let identitySourceArn: String

        @inlinable
        public init(identitySourceArn: String) {
            self.identitySourceArn = identitySourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identitySourceArn, key: "IdentitySourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.identitySourceArn, name: "identitySourceArn", parent: name, max: 1000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInactiveApprovalTeamVersionRequest: AWSEncodableShape {
        /// Amaazon Resource Name (ARN) for the team.
        public let arn: String
        /// Version ID for the team.
        public let versionId: String

        @inlinable
        public init(arn: String, versionId: String) {
            self.arn = arn
            self.versionId = versionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
            request.encodePath(self.versionId, key: "VersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-[^:]+)?:mpa:[a-z0-9-]{1,20}:[0-9]{12}:approval-team/[a-zA-Z0-9._-]+$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 1000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInactiveApprovalTeamVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Filter: AWSEncodableShape {
        /// Name of the filter to use.   Supported filters  The supported filters for ListSessions are: ActionName, SessionStatus, and InitationTime.
        public let fieldName: FilterField?
        /// Operator to use for filtering.    EQ: Equal to the specified value    NE: Not equal to the specified value    GT: Greater than the specified value    LT: Less than the specified value    GTE: Greater than or equal to the specified value    LTE: Less than or equal to the specified value    CONTAINS: Contains the specified value    NOT_CONTAINS: Does not contain the specified value    BETWEEN: Between two values, inclusive of the specified values.     Supported operators for each filter:    ActionName: EQ | NE | CONTAINS | NOT_CONTAINS     SessionStatus: EQ | NE     InitiationTime: GT | LT | GTE | LTE | BETWEEN
        public let `operator`: Operator?
        /// Value to use for filtering. For the BETWEEN operator, specify values in the format a AND b (AND is case-insensitive).
        public let value: String?

        @inlinable
        public init(fieldName: FilterField? = nil, operator: Operator? = nil, value: String? = nil) {
            self.fieldName = fieldName
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "FieldName"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct GetApprovalTeamRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the team.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-[^:]+)?:mpa:[a-z0-9-]{1,20}:[0-9]{12}:approval-team/[a-zA-Z0-9._-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApprovalTeamResponse: AWSDecodableShape {
        /// An ApprovalStrategyResponse object. Contains details for how the team grants approval.
        public let approvalStrategy: ApprovalStrategyResponse?
        /// An array of GetApprovalTeamResponseApprover  objects. Contains details for the approvers in the team.
        public let approvers: [GetApprovalTeamResponseApprover]?
        /// Amazon Resource Name (ARN) for the team.
        public let arn: String?
        /// Timestamp when the team was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Description for the team.
        public let description: String?
        /// Timestamp when the team was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdateTime: Date?
        /// Name of the approval team.
        public let name: String?
        /// Total number of approvers in the team.
        public let numberOfApprovers: Int?
        /// A PendingUpdate object. Contains details for the pending updates for the team, if applicable.
        public let pendingUpdate: PendingUpdate?
        /// An array of PolicyReference objects. Contains a list of policies that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see How other services work with Multi-party approval in the Multi-party approval User Guide.
        public let policies: [PolicyReference]?
        /// Status for the team. For more information, see Team health in the Multi-party approval User Guide.
        public let status: ApprovalTeamStatus?
        /// Status code for the approval team. For more information, see Team health in the Multi-party approval User Guide.
        public let statusCode: ApprovalTeamStatusCode?
        /// Message describing the status for the team.
        public let statusMessage: String?
        /// Amazon Resource Name (ARN) for the session.
        public let updateSessionArn: String?
        /// Version ID for the team.
        public let versionId: String?

        @inlinable
        public init(approvalStrategy: ApprovalStrategyResponse? = nil, approvers: [GetApprovalTeamResponseApprover]? = nil, arn: String? = nil, creationTime: Date? = nil, description: String? = nil, lastUpdateTime: Date? = nil, name: String? = nil, numberOfApprovers: Int? = nil, pendingUpdate: PendingUpdate? = nil, policies: [PolicyReference]? = nil, status: ApprovalTeamStatus? = nil, statusCode: ApprovalTeamStatusCode? = nil, statusMessage: String? = nil, updateSessionArn: String? = nil, versionId: String? = nil) {
            self.approvalStrategy = approvalStrategy
            self.approvers = approvers
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.numberOfApprovers = numberOfApprovers
            self.pendingUpdate = pendingUpdate
            self.policies = policies
            self.status = status
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.updateSessionArn = updateSessionArn
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case approvalStrategy = "ApprovalStrategy"
            case approvers = "Approvers"
            case arn = "Arn"
            case creationTime = "CreationTime"
            case description = "Description"
            case lastUpdateTime = "LastUpdateTime"
            case name = "Name"
            case numberOfApprovers = "NumberOfApprovers"
            case pendingUpdate = "PendingUpdate"
            case policies = "Policies"
            case status = "Status"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
            case updateSessionArn = "UpdateSessionArn"
            case versionId = "VersionId"
        }
    }

    public struct GetApprovalTeamResponseApprover: AWSDecodableShape {
        /// ID for the approver.
        public let approverId: String?
        /// ID for the user.
        public let primaryIdentityId: String?
        /// Amazon Resource Name (ARN) for the identity source. The identity source manages the user authentication for approvers.
        public let primaryIdentitySourceArn: String?
        /// Status for the identity source. For example, if an approver has accepted a team invitation with a user authentication method managed by the identity source.
        public let primaryIdentityStatus: IdentityStatus?
        /// Timestamp when the approver responded to an approval team invitation.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var responseTime: Date?

        @inlinable
        public init(approverId: String? = nil, primaryIdentityId: String? = nil, primaryIdentitySourceArn: String? = nil, primaryIdentityStatus: IdentityStatus? = nil, responseTime: Date? = nil) {
            self.approverId = approverId
            self.primaryIdentityId = primaryIdentityId
            self.primaryIdentitySourceArn = primaryIdentitySourceArn
            self.primaryIdentityStatus = primaryIdentityStatus
            self.responseTime = responseTime
        }

        private enum CodingKeys: String, CodingKey {
            case approverId = "ApproverId"
            case primaryIdentityId = "PrimaryIdentityId"
            case primaryIdentitySourceArn = "PrimaryIdentitySourceArn"
            case primaryIdentityStatus = "PrimaryIdentityStatus"
            case responseTime = "ResponseTime"
        }
    }

    public struct GetIdentitySourceRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the identity source.
        public let identitySourceArn: String

        @inlinable
        public init(identitySourceArn: String) {
            self.identitySourceArn = identitySourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identitySourceArn, key: "IdentitySourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.identitySourceArn, name: "identitySourceArn", parent: name, max: 1000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIdentitySourceResponse: AWSDecodableShape {
        /// Timestamp when the identity source was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Amazon Resource Name (ARN) for the identity source.
        public let identitySourceArn: String?
        /// A  IdentitySourceParameters object. Contains details for the resource that provides identities to the identity source. For example, an IAM Identity Center instance.
        public let identitySourceParameters: IdentitySourceParametersForGet?
        /// The type of resource that provided identities to the identity source. For example, an IAM Identity Center instance.
        public let identitySourceType: IdentitySourceType?
        /// Status for the identity source. For example, if the identity source is ACTIVE.
        public let status: IdentitySourceStatus?
        /// Status code of the identity source.
        public let statusCode: IdentitySourceStatusCode?
        /// Message describing the status for the identity source.
        public let statusMessage: String?

        @inlinable
        public init(creationTime: Date? = nil, identitySourceArn: String? = nil, identitySourceParameters: IdentitySourceParametersForGet? = nil, identitySourceType: IdentitySourceType? = nil, status: IdentitySourceStatus? = nil, statusCode: IdentitySourceStatusCode? = nil, statusMessage: String? = nil) {
            self.creationTime = creationTime
            self.identitySourceArn = identitySourceArn
            self.identitySourceParameters = identitySourceParameters
            self.identitySourceType = identitySourceType
            self.status = status
            self.statusCode = statusCode
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case identitySourceArn = "IdentitySourceArn"
            case identitySourceParameters = "IdentitySourceParameters"
            case identitySourceType = "IdentitySourceType"
            case status = "Status"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
        }
    }

    public struct GetPolicyVersionRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the policy.
        public let policyVersionArn: String

        @inlinable
        public init(policyVersionArn: String) {
            self.policyVersionArn = policyVersionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.policyVersionArn, key: "PolicyVersionArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.policyVersionArn, name: "policyVersionArn", parent: name, max: 1224)
            try self.validate(self.policyVersionArn, name: "policyVersionArn", parent: name, pattern: "^arn:.{1,63}:mpa:::aws:policy/[a-zA-Z0-9_\\.-]{1,1023}/[a-zA-Z0-9_\\.-]{1,1023}/(?:[\\d]+|\\$DEFAULT)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPolicyVersionResponse: AWSDecodableShape {
        /// A PolicyVersion object. Contains details for the version of the policy. Policies define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see How other services work with Multi-party approval in the Multi-party approval User Guide.
        public let policyVersion: PolicyVersion

        @inlinable
        public init(policyVersion: PolicyVersion) {
            self.policyVersion = policyVersion
        }

        private enum CodingKeys: String, CodingKey {
            case policyVersion = "PolicyVersion"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// Name of the policy.
        public let policyName: String
        /// The type of policy.
        public let policyType: PolicyType
        /// Amazon Resource Name (ARN) for the resource.
        public let resourceArn: String

        @inlinable
        public init(policyName: String, policyType: PolicyType, resourceArn: String) {
            self.policyName = policyName
            self.policyType = policyType
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.policyName, name: "policyName", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "PolicyName"
            case policyType = "PolicyType"
            case resourceArn = "ResourceArn"
        }
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// Document that contains the contents for the policy.
        public let policyDocument: String
        /// Name of the policy.
        public let policyName: String
        /// The type of policy
        public let policyType: PolicyType
        /// Amazon Resource Name (ARN) for the policy version.
        public let policyVersionArn: String?
        /// Amazon Resource Name (ARN) for the resource.
        public let resourceArn: String

        @inlinable
        public init(policyDocument: String, policyName: String, policyType: PolicyType, policyVersionArn: String? = nil, resourceArn: String) {
            self.policyDocument = policyDocument
            self.policyName = policyName
            self.policyType = policyType
            self.policyVersionArn = policyVersionArn
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "PolicyDocument"
            case policyName = "PolicyName"
            case policyType = "PolicyType"
            case policyVersionArn = "PolicyVersionArn"
            case resourceArn = "ResourceArn"
        }
    }

    public struct GetSessionRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the session.
        public let sessionArn: String

        @inlinable
        public init(sessionArn: String) {
            self.sessionArn = sessionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sessionArn, key: "SessionArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, max: 2048)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, min: 20)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, pattern: "^arn:aws(-[^:]+)?:mpa:[a-z0-9-]{1,20}:[0-9]{12}:session/[a-zA-Z0-9._-]+/[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionResponse: AWSDecodableShape {
        /// Strategy for executing the protected operation. AUTO_COMPLETION_UPON_APPROVAL means the operation is automatically executed using the requester's permissions, if approved.
        public let actionCompletionStrategy: ActionCompletionStrategy?
        /// Name of the protected operation.
        public let actionName: String?
        /// An ApprovalStrategyResponse object. Contains details for how the team grants approval
        public let approvalStrategy: ApprovalStrategyResponse?
        /// Amazon Resource Name (ARN) for the approval team.
        public let approvalTeamArn: String?
        /// Name of the approval team.
        public let approvalTeamName: String?
        /// An array of GetSessionResponseApproverResponse objects. Contains details for approver responses in the session.
        public let approverResponses: [GetSessionResponseApproverResponse]?
        /// Timestamp when the session completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completionTime: Date?
        /// Description for the session.
        public let description: String?
        /// Status for the protected operation. For example, if the operation is PENDING.
        public let executionStatus: SessionExecutionStatus?
        /// Timestamp when the session will expire.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expirationTime: Date?
        /// Timestamp when the session was initiated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var initiationTime: Date?
        /// Metadata for the session.
        public let metadata: [String: String]?
        /// Total number of approvers in the session.
        public let numberOfApprovers: Int?
        /// Amazon Resource Name (ARN) for the protected operation.
        public let protectedResourceArn: String?
        /// ID for the account that made the operation request.
        public let requesterAccountId: String?
        /// Message from the account that made the operation request
        public let requesterComment: String?
        ///  IAM principal that made the operation request.
        public let requesterPrincipalArn: String?
        /// Amazon Web Services Region where the operation request originated.
        public let requesterRegion: String?
        ///  Service principal for the service associated with the protected operation.
        public let requesterServicePrincipal: String?
        /// Amazon Resource Name (ARN) for the session.
        public let sessionArn: String?
        /// Status for the session. For example, if the team has approved the requested operation.
        public let status: SessionStatus?
        /// Status code of the session.
        public let statusCode: SessionStatusCode?
        /// Message describing the status for session.
        public let statusMessage: String?

        @inlinable
        public init(actionCompletionStrategy: ActionCompletionStrategy? = nil, actionName: String? = nil, approvalStrategy: ApprovalStrategyResponse? = nil, approvalTeamArn: String? = nil, approvalTeamName: String? = nil, approverResponses: [GetSessionResponseApproverResponse]? = nil, completionTime: Date? = nil, description: String? = nil, executionStatus: SessionExecutionStatus? = nil, expirationTime: Date? = nil, initiationTime: Date? = nil, metadata: [String: String]? = nil, numberOfApprovers: Int? = nil, protectedResourceArn: String? = nil, requesterAccountId: String? = nil, requesterComment: String? = nil, requesterPrincipalArn: String? = nil, requesterRegion: String? = nil, requesterServicePrincipal: String? = nil, sessionArn: String? = nil, status: SessionStatus? = nil, statusCode: SessionStatusCode? = nil, statusMessage: String? = nil) {
            self.actionCompletionStrategy = actionCompletionStrategy
            self.actionName = actionName
            self.approvalStrategy = approvalStrategy
            self.approvalTeamArn = approvalTeamArn
            self.approvalTeamName = approvalTeamName
            self.approverResponses = approverResponses
            self.completionTime = completionTime
            self.description = description
            self.executionStatus = executionStatus
            self.expirationTime = expirationTime
            self.initiationTime = initiationTime
            self.metadata = metadata
            self.numberOfApprovers = numberOfApprovers
            self.protectedResourceArn = protectedResourceArn
            self.requesterAccountId = requesterAccountId
            self.requesterComment = requesterComment
            self.requesterPrincipalArn = requesterPrincipalArn
            self.requesterRegion = requesterRegion
            self.requesterServicePrincipal = requesterServicePrincipal
            self.sessionArn = sessionArn
            self.status = status
            self.statusCode = statusCode
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case actionCompletionStrategy = "ActionCompletionStrategy"
            case actionName = "ActionName"
            case approvalStrategy = "ApprovalStrategy"
            case approvalTeamArn = "ApprovalTeamArn"
            case approvalTeamName = "ApprovalTeamName"
            case approverResponses = "ApproverResponses"
            case completionTime = "CompletionTime"
            case description = "Description"
            case executionStatus = "ExecutionStatus"
            case expirationTime = "ExpirationTime"
            case initiationTime = "InitiationTime"
            case metadata = "Metadata"
            case numberOfApprovers = "NumberOfApprovers"
            case protectedResourceArn = "ProtectedResourceArn"
            case requesterAccountId = "RequesterAccountId"
            case requesterComment = "RequesterComment"
            case requesterPrincipalArn = "RequesterPrincipalArn"
            case requesterRegion = "RequesterRegion"
            case requesterServicePrincipal = "RequesterServicePrincipal"
            case sessionArn = "SessionArn"
            case status = "Status"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
        }
    }

    public struct GetSessionResponseApproverResponse: AWSDecodableShape {
        /// ID for the approver.
        public let approverId: String?
        /// ID for the identity source. The identity source manages the user authentication for approvers.
        public let identityId: String?
        /// Amazon Resource Name (ARN) for the identity source. The identity source manages the user authentication for approvers.
        public let identitySourceArn: String?
        /// Response to the operation request.
        public let response: SessionResponse?
        /// Timestamp when a approver responded to the operation request.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var responseTime: Date?

        @inlinable
        public init(approverId: String? = nil, identityId: String? = nil, identitySourceArn: String? = nil, response: SessionResponse? = nil, responseTime: Date? = nil) {
            self.approverId = approverId
            self.identityId = identityId
            self.identitySourceArn = identitySourceArn
            self.response = response
            self.responseTime = responseTime
        }

        private enum CodingKeys: String, CodingKey {
            case approverId = "ApproverId"
            case identityId = "IdentityId"
            case identitySourceArn = "IdentitySourceArn"
            case response = "Response"
            case responseTime = "ResponseTime"
        }
    }

    public struct IamIdentityCenter: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the IAM Identity Center instance.
        public let instanceArn: String
        /// Amazon Web Services Region where the IAM Identity Center instance is located.
        public let region: String

        @inlinable
        public init(instanceArn: String, region: String) {
            self.instanceArn = instanceArn
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceArn, name: "instanceArn", parent: name, max: 2048)
            try self.validate(self.instanceArn, name: "instanceArn", parent: name, min: 20)
            try self.validate(self.instanceArn, name: "instanceArn", parent: name, pattern: "^arn:.+:sso:::instance/(?:sso)?ins-[a-zA-Z0-9-.]{16}$")
            try self.validate(self.region, name: "region", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceArn = "InstanceArn"
            case region = "Region"
        }
    }

    public struct IamIdentityCenterForGet: AWSDecodableShape {
        /// URL for the approval portal associated with the IAM Identity Center instance.
        public let approvalPortalUrl: String?
        /// Amazon Resource Name (ARN) for the IAM Identity Center instance.
        public let instanceArn: String?
        /// Amazon Web Services Region where the IAM Identity Center instance is located.
        public let region: String?

        @inlinable
        public init(approvalPortalUrl: String? = nil, instanceArn: String? = nil, region: String? = nil) {
            self.approvalPortalUrl = approvalPortalUrl
            self.instanceArn = instanceArn
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case approvalPortalUrl = "ApprovalPortalUrl"
            case instanceArn = "InstanceArn"
            case region = "Region"
        }
    }

    public struct IamIdentityCenterForList: AWSDecodableShape {
        /// URL for the approval portal associated with the IAM Identity Center instance.
        public let approvalPortalUrl: String?
        /// Amazon Resource Name (ARN) for the IAM Identity Center instance.
        public let instanceArn: String?
        /// Amazon Web Services Region where the IAM Identity Center instance is located.
        public let region: String?

        @inlinable
        public init(approvalPortalUrl: String? = nil, instanceArn: String? = nil, region: String? = nil) {
            self.approvalPortalUrl = approvalPortalUrl
            self.instanceArn = instanceArn
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case approvalPortalUrl = "ApprovalPortalUrl"
            case instanceArn = "InstanceArn"
            case region = "Region"
        }
    }

    public struct IdentitySourceForList: AWSDecodableShape {
        /// Timestamp when the identity source was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Amazon Resource Name (ARN) for the identity source.
        public let identitySourceArn: String?
        /// A IdentitySourceParametersForList object. Contains details for the resource that provides identities to the identity source. For example, an IAM Identity Center instance.
        public let identitySourceParameters: IdentitySourceParametersForList?
        /// The type of resource that provided identities to the identity source. For example, an IAM Identity Center instance.
        public let identitySourceType: IdentitySourceType?
        /// Status for the identity source. For example, if the identity source is ACTIVE.
        public let status: IdentitySourceStatus?
        /// Status code of the identity source.
        public let statusCode: IdentitySourceStatusCode?
        /// Message describing the status for the identity source.
        public let statusMessage: String?

        @inlinable
        public init(creationTime: Date? = nil, identitySourceArn: String? = nil, identitySourceParameters: IdentitySourceParametersForList? = nil, identitySourceType: IdentitySourceType? = nil, status: IdentitySourceStatus? = nil, statusCode: IdentitySourceStatusCode? = nil, statusMessage: String? = nil) {
            self.creationTime = creationTime
            self.identitySourceArn = identitySourceArn
            self.identitySourceParameters = identitySourceParameters
            self.identitySourceType = identitySourceType
            self.status = status
            self.statusCode = statusCode
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case identitySourceArn = "IdentitySourceArn"
            case identitySourceParameters = "IdentitySourceParameters"
            case identitySourceType = "IdentitySourceType"
            case status = "Status"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
        }
    }

    public struct IdentitySourceParameters: AWSEncodableShape {
        /// IAM Identity Center credentials.
        public let iamIdentityCenter: IamIdentityCenter?

        @inlinable
        public init(iamIdentityCenter: IamIdentityCenter? = nil) {
            self.iamIdentityCenter = iamIdentityCenter
        }

        public func validate(name: String) throws {
            try self.iamIdentityCenter?.validate(name: "\(name).iamIdentityCenter")
        }

        private enum CodingKeys: String, CodingKey {
            case iamIdentityCenter = "IamIdentityCenter"
        }
    }

    public struct ListApprovalTeamsRequest: AWSEncodableShape {
        /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
        public let maxResults: Int?
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApprovalTeamsResponse: AWSDecodableShape {
        /// An array of ListApprovalTeamsResponseApprovalTeam objects. Contains details for approval teams.
        public let approvalTeams: [ListApprovalTeamsResponseApprovalTeam]?
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?

        @inlinable
        public init(approvalTeams: [ListApprovalTeamsResponseApprovalTeam]? = nil, nextToken: String? = nil) {
            self.approvalTeams = approvalTeams
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case approvalTeams = "ApprovalTeams"
            case nextToken = "NextToken"
        }
    }

    public struct ListApprovalTeamsResponseApprovalTeam: AWSDecodableShape {
        /// An ApprovalStrategyResponse object. Contains details for how an approval team grants approval.
        public let approvalStrategy: ApprovalStrategyResponse?
        /// Amazon Resource Name (ARN) for the team.
        public let arn: String?
        /// Timestamp when the team was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Description for the team.
        public let description: String?
        /// Name of the team.
        public let name: String?
        /// Total number of approvers in the team.
        public let numberOfApprovers: Int?
        /// Status for the team. For more information, see Team health in the Multi-party approval User Guide.
        public let status: ApprovalTeamStatus?
        /// Status code for the team. For more information, see Team health in the Multi-party approval User Guide.
        public let statusCode: ApprovalTeamStatusCode?
        /// Message describing the status for the team.
        public let statusMessage: String?

        @inlinable
        public init(approvalStrategy: ApprovalStrategyResponse? = nil, arn: String? = nil, creationTime: Date? = nil, description: String? = nil, name: String? = nil, numberOfApprovers: Int? = nil, status: ApprovalTeamStatus? = nil, statusCode: ApprovalTeamStatusCode? = nil, statusMessage: String? = nil) {
            self.approvalStrategy = approvalStrategy
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.numberOfApprovers = numberOfApprovers
            self.status = status
            self.statusCode = statusCode
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case approvalStrategy = "ApprovalStrategy"
            case arn = "Arn"
            case creationTime = "CreationTime"
            case description = "Description"
            case name = "Name"
            case numberOfApprovers = "NumberOfApprovers"
            case status = "Status"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ListIdentitySourcesRequest: AWSEncodableShape {
        /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
        public let maxResults: Int?
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdentitySourcesResponse: AWSDecodableShape {
        /// A IdentitySources. Contains details for identity sources.
        public let identitySources: [IdentitySourceForList]?
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?

        @inlinable
        public init(identitySources: [IdentitySourceForList]? = nil, nextToken: String? = nil) {
            self.identitySources = identitySources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case identitySources = "IdentitySources"
            case nextToken = "NextToken"
        }
    }

    public struct ListPoliciesRequest: AWSEncodableShape {
        /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
        public let maxResults: Int?
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPoliciesResponse: AWSDecodableShape {
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?
        /// An array of Policy objects. Contains a list of policies that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see How other services work with Multi-party approval in the Multi-party approval User Guide.
        public let policies: [Policy]?

        @inlinable
        public init(nextToken: String? = nil, policies: [Policy]? = nil) {
            self.nextToken = nextToken
            self.policies = policies
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case policies = "Policies"
        }
    }

    public struct ListPolicyVersionsRequest: AWSEncodableShape {
        /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
        public let maxResults: Int?
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?
        /// Amazon Resource Name (ARN) for the policy.
        public let policyArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, policyArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyArn = policyArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.policyArn, key: "PolicyArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.policyArn, name: "policyArn", parent: name, max: 1224)
            try self.validate(self.policyArn, name: "policyArn", parent: name, pattern: "^arn:.{1,63}:mpa:::aws:policy/[a-zA-Z0-9_\\.-]{1,1023}/[a-zA-Z0-9_\\.-]{1,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPolicyVersionsResponse: AWSDecodableShape {
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?
        /// An array of PolicyVersionSummary objects. Contains details for the version of the policies that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see How other services work with Multi-party approval in the Multi-party approval User Guide.
        public let policyVersions: [PolicyVersionSummary]?

        @inlinable
        public init(nextToken: String? = nil, policyVersions: [PolicyVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.policyVersions = policyVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case policyVersions = "PolicyVersions"
        }
    }

    public struct ListResourcePoliciesRequest: AWSEncodableShape {
        /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
        public let maxResults: Int?
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?
        /// Amazon Resource Name (ARN) for the resource.
        public let resourceArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResourcePoliciesResponse: AWSDecodableShape {
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?
        /// An array of ListResourcePoliciesResponseResourcePolicy objects. Contains details about the policy for the resource.
        public let resourcePolicies: [ListResourcePoliciesResponseResourcePolicy]?

        @inlinable
        public init(nextToken: String? = nil, resourcePolicies: [ListResourcePoliciesResponseResourcePolicy]? = nil) {
            self.nextToken = nextToken
            self.resourcePolicies = resourcePolicies
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourcePolicies = "ResourcePolicies"
        }
    }

    public struct ListResourcePoliciesResponseResourcePolicy: AWSDecodableShape {
        /// Amazon Resource Name (ARN) for policy.
        public let policyArn: String?
        /// Name of the policy.
        public let policyName: String?
        /// The type of policy.
        public let policyType: PolicyType?

        @inlinable
        public init(policyArn: String? = nil, policyName: String? = nil, policyType: PolicyType? = nil) {
            self.policyArn = policyArn
            self.policyName = policyName
            self.policyType = policyType
        }

        private enum CodingKeys: String, CodingKey {
            case policyArn = "PolicyArn"
            case policyName = "PolicyName"
            case policyType = "PolicyType"
        }
    }

    public struct ListSessionsRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the approval team.
        public let approvalTeamArn: String
        /// An array of Filter objects. Contains the filter to apply when listing sessions.
        public let filters: [Filter]?
        /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
        public let maxResults: Int?
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?

        @inlinable
        public init(approvalTeamArn: String, filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.approvalTeamArn = approvalTeamArn
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.approvalTeamArn, key: "ApprovalTeamArn")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.approvalTeamArn, name: "approvalTeamArn", parent: name, max: 2048)
            try self.validate(self.approvalTeamArn, name: "approvalTeamArn", parent: name, min: 20)
            try self.validate(self.approvalTeamArn, name: "approvalTeamArn", parent: name, pattern: "^arn:aws(-[^:]+)?:mpa:[a-z0-9-]{1,20}:[0-9]{12}:approval-team/[a-zA-Z0-9._-]+$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListSessionsResponse: AWSDecodableShape {
        /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
        public let nextToken: String?
        /// An array of ListSessionsResponseSession objects. Contains details for the sessions.
        public let sessions: [ListSessionsResponseSession]?

        @inlinable
        public init(nextToken: String? = nil, sessions: [ListSessionsResponseSession]? = nil) {
            self.nextToken = nextToken
            self.sessions = sessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sessions = "Sessions"
        }
    }

    public struct ListSessionsResponseSession: AWSDecodableShape {
        /// Strategy for executing the protected operation. AUTO_COMPLETION_UPON_APPROVAL means the operation is executed automatically using the requester's permissions, if approved.
        public let actionCompletionStrategy: ActionCompletionStrategy?
        /// Name of the protected operation.
        public let actionName: String?
        /// Amazon Resource Name (ARN) for the approval team.
        public let approvalTeamArn: String?
        /// Name of the approval team.
        public let approvalTeamName: String?
        /// Timestamp when the session was completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completionTime: Date?
        /// Description for the team.
        public let description: String?
        /// Timestamp when the session was expire.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expirationTime: Date?
        /// Timestamp when the session was initiated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var initiationTime: Date?
        /// Amazon Resource Name (ARN) for the protected operation.
        public let protectedResourceArn: String?
        /// ID for the account that made the operation request.
        public let requesterAccountId: String?
        ///  IAM principal that made the operation request.
        public let requesterPrincipalArn: String?
        /// Amazon Web Services Region where the operation request originated.
        public let requesterRegion: String?
        ///  Service principal for the service associated with the protected operation.
        public let requesterServicePrincipal: String?
        /// Amazon Resource Name (ARN) for the session.
        public let sessionArn: String?
        /// Status for the protected operation. For example, if the operation is PENDING.
        public let status: SessionStatus?
        /// Status code of the session.
        public let statusCode: SessionStatusCode?
        /// Message describing the status for session.
        public let statusMessage: String?

        @inlinable
        public init(actionCompletionStrategy: ActionCompletionStrategy? = nil, actionName: String? = nil, approvalTeamArn: String? = nil, approvalTeamName: String? = nil, completionTime: Date? = nil, description: String? = nil, expirationTime: Date? = nil, initiationTime: Date? = nil, protectedResourceArn: String? = nil, requesterAccountId: String? = nil, requesterPrincipalArn: String? = nil, requesterRegion: String? = nil, requesterServicePrincipal: String? = nil, sessionArn: String? = nil, status: SessionStatus? = nil, statusCode: SessionStatusCode? = nil, statusMessage: String? = nil) {
            self.actionCompletionStrategy = actionCompletionStrategy
            self.actionName = actionName
            self.approvalTeamArn = approvalTeamArn
            self.approvalTeamName = approvalTeamName
            self.completionTime = completionTime
            self.description = description
            self.expirationTime = expirationTime
            self.initiationTime = initiationTime
            self.protectedResourceArn = protectedResourceArn
            self.requesterAccountId = requesterAccountId
            self.requesterPrincipalArn = requesterPrincipalArn
            self.requesterRegion = requesterRegion
            self.requesterServicePrincipal = requesterServicePrincipal
            self.sessionArn = sessionArn
            self.status = status
            self.statusCode = statusCode
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case actionCompletionStrategy = "ActionCompletionStrategy"
            case actionName = "ActionName"
            case approvalTeamArn = "ApprovalTeamArn"
            case approvalTeamName = "ApprovalTeamName"
            case completionTime = "CompletionTime"
            case description = "Description"
            case expirationTime = "ExpirationTime"
            case initiationTime = "InitiationTime"
            case protectedResourceArn = "ProtectedResourceArn"
            case requesterAccountId = "RequesterAccountId"
            case requesterPrincipalArn = "RequesterPrincipalArn"
            case requesterRegion = "RequesterRegion"
            case requesterServicePrincipal = "RequesterServicePrincipal"
            case sessionArn = "SessionArn"
            case status = "Status"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Tags attached to the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct MofNApprovalStrategy: AWSEncodableShape & AWSDecodableShape {
        /// Minimum number of approvals (M) required for a total number of approvers (N).
        public let minApprovalsRequired: Int

        @inlinable
        public init(minApprovalsRequired: Int) {
            self.minApprovalsRequired = minApprovalsRequired
        }

        private enum CodingKeys: String, CodingKey {
            case minApprovalsRequired = "MinApprovalsRequired"
        }
    }

    public struct PendingUpdate: AWSDecodableShape {
        /// An ApprovalStrategyResponse object. Contains details for how the team grants approval.
        public let approvalStrategy: ApprovalStrategyResponse?
        /// An array of GetApprovalTeamResponseApprover  objects. Contains details for the approvers in the team.
        public let approvers: [GetApprovalTeamResponseApprover]?
        /// Description for the team.
        public let description: String?
        /// Total number of approvers in the team.
        public let numberOfApprovers: Int?
        /// Status for the team. For more information, see Team health in the Multi-party approval User Guide.
        public let status: ApprovalTeamStatus?
        /// Status code for the update. For more information, see Team health in the Multi-party approval User Guide.
        public let statusCode: ApprovalTeamStatusCode?
        /// Message describing the status for the team.
        public let statusMessage: String?
        /// Timestamp when the update request was initiated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updateInitiationTime: Date?
        /// Version ID for the team.
        public let versionId: String?

        @inlinable
        public init(approvalStrategy: ApprovalStrategyResponse? = nil, approvers: [GetApprovalTeamResponseApprover]? = nil, description: String? = nil, numberOfApprovers: Int? = nil, status: ApprovalTeamStatus? = nil, statusCode: ApprovalTeamStatusCode? = nil, statusMessage: String? = nil, updateInitiationTime: Date? = nil, versionId: String? = nil) {
            self.approvalStrategy = approvalStrategy
            self.approvers = approvers
            self.description = description
            self.numberOfApprovers = numberOfApprovers
            self.status = status
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.updateInitiationTime = updateInitiationTime
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case approvalStrategy = "ApprovalStrategy"
            case approvers = "Approvers"
            case description = "Description"
            case numberOfApprovers = "NumberOfApprovers"
            case status = "Status"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
            case updateInitiationTime = "UpdateInitiationTime"
            case versionId = "VersionId"
        }
    }

    public struct Policy: AWSDecodableShape {
        /// Amazon Resource Name (ARN) for the policy.
        public let arn: String
        /// Determines if the specified policy is the default for the team.
        public let defaultVersion: Int
        /// Name of the policy.
        public let name: String
        /// The type of policy.
        public let policyType: PolicyType

        @inlinable
        public init(arn: String, defaultVersion: Int, name: String, policyType: PolicyType) {
            self.arn = arn
            self.defaultVersion = defaultVersion
            self.name = name
            self.policyType = policyType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case defaultVersion = "DefaultVersion"
            case name = "Name"
            case policyType = "PolicyType"
        }
    }

    public struct PolicyReference: AWSEncodableShape & AWSDecodableShape {
        /// Amazon Resource Name (ARN) for the policy.
        public let policyArn: String

        @inlinable
        public init(policyArn: String) {
            self.policyArn = policyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.policyArn, name: "policyArn", parent: name, max: 1224)
            try self.validate(self.policyArn, name: "policyArn", parent: name, pattern: "^arn:.{1,63}:mpa:::aws:policy/[a-zA-Z0-9_\\.-]{1,1023}/[a-zA-Z0-9_\\.-]{1,1023}/(?:[\\d]+|\\$DEFAULT)$")
        }

        private enum CodingKeys: String, CodingKey {
            case policyArn = "PolicyArn"
        }
    }

    public struct PolicyVersion: AWSDecodableShape {
        /// Amazon Resource Name (ARN) for the team.
        public let arn: String
        /// Timestamp when the policy was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// Document that contains the policy contents.
        public let document: String
        /// Determines if the specified policy is the default for the team.
        public let isDefault: Bool
        /// Timestamp when the policy was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedTime: Date
        /// Name of the policy.
        public let name: String
        /// Amazon Resource Name (ARN) for the policy.
        public let policyArn: String
        /// The type of policy.
        public let policyType: PolicyType
        /// Status for the policy. For example, if the policy is attachable or deprecated.
        public let status: PolicyStatus
        /// Verison ID
        public let versionId: Int

        @inlinable
        public init(arn: String, creationTime: Date, document: String, isDefault: Bool, lastUpdatedTime: Date, name: String, policyArn: String, policyType: PolicyType, status: PolicyStatus, versionId: Int) {
            self.arn = arn
            self.creationTime = creationTime
            self.document = document
            self.isDefault = isDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.policyArn = policyArn
            self.policyType = policyType
            self.status = status
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case document = "Document"
            case isDefault = "IsDefault"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case policyArn = "PolicyArn"
            case policyType = "PolicyType"
            case status = "Status"
            case versionId = "VersionId"
        }
    }

    public struct PolicyVersionSummary: AWSDecodableShape {
        /// Amazon Resource Name (ARN) for the team.
        public let arn: String
        /// Timestamp when the policy was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// Determines if the specified policy is the default for the team.
        public let isDefault: Bool
        /// Timestamp when the policy was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedTime: Date
        /// Name of the policy
        public let name: String
        /// Amazon Resource Name (ARN) for the policy.
        public let policyArn: String
        /// The type of policy.
        public let policyType: PolicyType
        /// Status for the policy. For example, if the policy is attachable or deprecated.
        public let status: PolicyStatus
        /// Version ID for the policy.
        public let versionId: Int

        @inlinable
        public init(arn: String, creationTime: Date, isDefault: Bool, lastUpdatedTime: Date, name: String, policyArn: String, policyType: PolicyType, status: PolicyStatus, versionId: Int) {
            self.arn = arn
            self.creationTime = creationTime
            self.isDefault = isDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.policyArn = policyArn
            self.policyType = policyType
            self.status = status
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case isDefault = "IsDefault"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case policyArn = "PolicyArn"
            case policyType = "PolicyType"
            case status = "Status"
            case versionId = "VersionId"
        }
    }

    public struct StartActiveApprovalTeamDeletionRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the team.
        public let arn: String
        /// Number of days between when the team approves the delete request and when the team is deleted.
        public let pendingWindowDays: Int?

        @inlinable
        public init(arn: String, pendingWindowDays: Int? = nil) {
            self.arn = arn
            self.pendingWindowDays = pendingWindowDays
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
            try container.encodeIfPresent(self.pendingWindowDays, forKey: .pendingWindowDays)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-[^:]+)?:mpa:[a-z0-9-]{1,20}:[0-9]{12}:approval-team/[a-zA-Z0-9._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case pendingWindowDays = "PendingWindowDays"
        }
    }

    public struct StartActiveApprovalTeamDeletionResponse: AWSDecodableShape {
        /// Timestamp when the deletion process is scheduled to complete.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var deletionCompletionTime: Date?
        /// Timestamp when the deletion process was initiated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var deletionStartTime: Date?

        @inlinable
        public init(deletionCompletionTime: Date? = nil, deletionStartTime: Date? = nil) {
            self.deletionCompletionTime = deletionCompletionTime
            self.deletionStartTime = deletionStartTime
        }

        private enum CodingKeys: String, CodingKey {
            case deletionCompletionTime = "DeletionCompletionTime"
            case deletionStartTime = "DeletionStartTime"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the resource you want to tag.
        public let resourceArn: String
        /// Tags that you have added to the specified resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TooManyTagsException: AWSErrorShape {
        /// Message for the TooManyTagsException error.
        public let message: String
        /// Name of the resource for the TooManyTagsException error.
        public let resourceName: String?

        @inlinable
        public init(message: String, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceName = "ResourceName"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the resource you want to untag.
        public let resourceArn: String
        /// Array of tag key-value pairs that you want to untag.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tagKeys, forKey: .tagKeys)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateApprovalTeamRequest: AWSEncodableShape {
        /// An ApprovalStrategy object. Contains details for how the team grants approval.
        public let approvalStrategy: ApprovalStrategy?
        /// An array of ApprovalTeamRequestApprover objects. Contains details for the approvers in the team.
        public let approvers: [ApprovalTeamRequestApprover]?
        /// Amazon Resource Name (ARN) for the team.
        public let arn: String
        /// Description for the team.
        public let description: String?

        @inlinable
        public init(approvalStrategy: ApprovalStrategy? = nil, approvers: [ApprovalTeamRequestApprover]? = nil, arn: String, description: String? = nil) {
            self.approvalStrategy = approvalStrategy
            self.approvers = approvers
            self.arn = arn
            self.description = description
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.approvalStrategy, forKey: .approvalStrategy)
            try container.encodeIfPresent(self.approvers, forKey: .approvers)
            request.encodePath(self.arn, key: "Arn")
            try container.encodeIfPresent(self.description, forKey: .description)
        }

        public func validate(name: String) throws {
            try self.approvers?.forEach {
                try $0.validate(name: "\(name).approvers[]")
            }
            try self.validate(self.approvers, name: "approvers", parent: name, max: 20)
            try self.validate(self.approvers, name: "approvers", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-[^:]+)?:mpa:[a-z0-9-]{1,20}:[0-9]{12}:approval-team/[a-zA-Z0-9._-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case approvalStrategy = "ApprovalStrategy"
            case approvers = "Approvers"
            case description = "Description"
        }
    }

    public struct UpdateApprovalTeamResponse: AWSDecodableShape {
        /// Version ID for the team that was created. When an approval team is updated, the version ID changes.
        public let versionId: String?

        @inlinable
        public init(versionId: String? = nil) {
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case versionId = "VersionId"
        }
    }

    public struct ApprovalStrategy: AWSEncodableShape {
        /// Minimum number of approvals (M) required for a total number of approvers (N).
        public let mofN: MofNApprovalStrategy?

        @inlinable
        public init(mofN: MofNApprovalStrategy? = nil) {
            self.mofN = mofN
        }

        private enum CodingKeys: String, CodingKey {
            case mofN = "MofN"
        }
    }

    public struct ApprovalStrategyResponse: AWSDecodableShape {
        /// Minimum number of approvals (M) required for a total number of approvers (N).
        public let mofN: MofNApprovalStrategy?

        @inlinable
        public init(mofN: MofNApprovalStrategy? = nil) {
            self.mofN = mofN
        }

        private enum CodingKeys: String, CodingKey {
            case mofN = "MofN"
        }
    }

    public struct IdentitySourceParametersForGet: AWSDecodableShape {
        /// IAM Identity Center credentials.
        public let iamIdentityCenter: IamIdentityCenterForGet?

        @inlinable
        public init(iamIdentityCenter: IamIdentityCenterForGet? = nil) {
            self.iamIdentityCenter = iamIdentityCenter
        }

        private enum CodingKeys: String, CodingKey {
            case iamIdentityCenter = "IamIdentityCenter"
        }
    }

    public struct IdentitySourceParametersForList: AWSDecodableShape {
        /// IAM Identity Center credentials.
        public let iamIdentityCenter: IamIdentityCenterForList?

        @inlinable
        public init(iamIdentityCenter: IamIdentityCenterForList? = nil) {
            self.iamIdentityCenter = iamIdentityCenter
        }

        private enum CodingKeys: String, CodingKey {
            case iamIdentityCenter = "IamIdentityCenter"
        }
    }
}

// MARK: - Errors

/// Error enum for MPA
public struct MPAErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidParameterException = "InvalidParameterException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MPA
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action. Check your permissions, and try again.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request cannot be completed because it conflicts with the current state of a resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The service encountered an internal error. Try your request again. If the problem persists, contact Amazon Web Services Support.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request contains an invalid parameter value.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// The specified resource doesn't exist. Check the resource ID, and try again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request exceeds the service quota for your account. Request a quota increase or reduce your request size.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request exceeds the maximum number of tags allowed for this resource. Remove some tags, and try again.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension MPAErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "TooManyTagsException": MPA.TooManyTagsException.self
    ]
}

extension MPAErrorType: Equatable {
    public static func == (lhs: MPAErrorType, rhs: MPAErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MPAErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
