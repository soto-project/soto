//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Honeycode {
    // MARK: Enums

    public enum Format: String, CustomStringConvertible, Codable {
        case accounting = "ACCOUNTING"
        case auto = "AUTO"
        case contact = "CONTACT"
        case currency = "CURRENCY"
        case date = "DATE"
        case dateTime = "DATE_TIME"
        case number = "NUMBER"
        case percentage = "PERCENTAGE"
        case rowlink = "ROWLINK"
        case text = "TEXT"
        case time = "TIME"
        public var description: String { return self.rawValue }
    }

    public enum ImportDataCharacterEncoding: String, CustomStringConvertible, Codable {
        case iso88591 = "ISO-8859-1"
        case usAscii = "US-ASCII"
        case utf16 = "UTF-16"
        case utf16Be = "UTF-16BE"
        case utf16Le = "UTF-16LE"
        case utf8 = "UTF-8"
        public var description: String { return self.rawValue }
    }

    public enum ImportSourceDataFormat: String, CustomStringConvertible, Codable {
        case delimitedText = "DELIMITED_TEXT"
        public var description: String { return self.rawValue }
    }

    public enum TableDataImportJobStatus: String, CustomStringConvertible, Codable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum UpsertAction: String, CustomStringConvertible, Codable {
        case appended = "APPENDED"
        case updated = "UPDATED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct BatchCreateTableRowsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "tableId", location: .uri(locationName: "tableId")),
            AWSMemberEncoding(label: "workbookId", location: .uri(locationName: "workbookId"))
        ]

        ///  The request token for performing the batch create operation. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the operation again.   Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
        public let clientRequestToken: String?
        ///  The list of rows to create at the end of the table. Each item in this list needs to have a batch item id to uniquely identify the element in the request and the cells to create for that row. You need to specify at least one item in this list.   Note that if one of the column ids in any of the rows in the request does not exist in the table, then the request fails and no updates are made to the table.
        public let rowsToCreate: [CreateRowData]
        /// The ID of the table where the new rows are being added.  If a table with the specified ID could not be found, this API throws ResourceNotFoundException.
        public let tableId: String
        /// The ID of the workbook where the new rows are being added.  If a workbook with the specified ID could not be found, this API throws ResourceNotFoundException.
        public let workbookId: String

        public init(clientRequestToken: String? = nil, rowsToCreate: [CreateRowData], tableId: String, workbookId: String) {
            self.clientRequestToken = clientRequestToken
            self.rowsToCreate = rowsToCreate
            self.tableId = tableId
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^(?!\\s*$).+")
            try self.rowsToCreate.forEach {
                try $0.validate(name: "\(name).rowsToCreate[]")
            }
            try self.validate(self.rowsToCreate, name: "rowsToCreate", parent: name, max: 100)
            try self.validate(self.rowsToCreate, name: "rowsToCreate", parent: name, min: 1)
            try self.validate(self.tableId, name: "tableId", parent: name, max: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, min: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken
            case rowsToCreate
        }
    }

    public struct BatchCreateTableRowsResult: AWSDecodableShape {
        /// The map of batch item id to the row id that was created for that item.
        public let createdRows: [String: String]
        ///  The list of batch items in the request that could not be added to the table. Each element in this list contains one item from the request that could not be added to the table along with the reason why that item could not be added.
        public let failedBatchItems: [FailedBatchItem]?
        /// The updated workbook cursor after adding the new rows at the end of the table.
        public let workbookCursor: Int64

        public init(createdRows: [String: String], failedBatchItems: [FailedBatchItem]? = nil, workbookCursor: Int64) {
            self.createdRows = createdRows
            self.failedBatchItems = failedBatchItems
            self.workbookCursor = workbookCursor
        }

        private enum CodingKeys: String, CodingKey {
            case createdRows
            case failedBatchItems
            case workbookCursor
        }
    }

    public struct BatchDeleteTableRowsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "tableId", location: .uri(locationName: "tableId")),
            AWSMemberEncoding(label: "workbookId", location: .uri(locationName: "workbookId"))
        ]

        ///  The request token for performing the delete action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again.   Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
        public let clientRequestToken: String?
        ///  The list of row ids to delete from the table. You need to specify at least one row id in this list.   Note that if one of the row ids provided in the request does not exist in the table, then the request fails and no rows are deleted from the table.
        public let rowIds: [String]
        /// The ID of the table where the rows are being deleted.  If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        public let tableId: String
        /// The ID of the workbook where the rows are being deleted.  If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        public let workbookId: String

        public init(clientRequestToken: String? = nil, rowIds: [String], tableId: String, workbookId: String) {
            self.clientRequestToken = clientRequestToken
            self.rowIds = rowIds
            self.tableId = tableId
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^(?!\\s*$).+")
            try self.rowIds.forEach {
                try validate($0, name: "rowIds[]", parent: name, max: 77)
                try validate($0, name: "rowIds[]", parent: name, min: 77)
                try validate($0, name: "rowIds[]", parent: name, pattern: "row:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\\/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            }
            try self.validate(self.rowIds, name: "rowIds", parent: name, max: 100)
            try self.validate(self.rowIds, name: "rowIds", parent: name, min: 1)
            try self.validate(self.tableId, name: "tableId", parent: name, max: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, min: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken
            case rowIds
        }
    }

    public struct BatchDeleteTableRowsResult: AWSDecodableShape {
        ///  The list of row ids in the request that could not be deleted from the table. Each element in this list contains one row id from the request that could not be deleted along with the reason why that item could not be deleted.
        public let failedBatchItems: [FailedBatchItem]?
        /// The updated workbook cursor after deleting the rows from the table.
        public let workbookCursor: Int64

        public init(failedBatchItems: [FailedBatchItem]? = nil, workbookCursor: Int64) {
            self.failedBatchItems = failedBatchItems
            self.workbookCursor = workbookCursor
        }

        private enum CodingKeys: String, CodingKey {
            case failedBatchItems
            case workbookCursor
        }
    }

    public struct BatchUpdateTableRowsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "tableId", location: .uri(locationName: "tableId")),
            AWSMemberEncoding(label: "workbookId", location: .uri(locationName: "workbookId"))
        ]

        ///  The request token for performing the update action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again.   Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
        public let clientRequestToken: String?
        ///  The list of rows to update in the table. Each item in this list needs to contain the row id to update along with the map of column id to cell values for each column in that row that needs to be updated. You need to specify at least one row in this list, and for each row, you need to specify at least one column to update.   Note that if one of the row or column ids in the request does not exist in the table, then the request fails and no updates are made to the table.
        public let rowsToUpdate: [UpdateRowData]
        /// The ID of the table where the rows are being updated.  If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        public let tableId: String
        /// The ID of the workbook where the rows are being updated.  If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        public let workbookId: String

        public init(clientRequestToken: String? = nil, rowsToUpdate: [UpdateRowData], tableId: String, workbookId: String) {
            self.clientRequestToken = clientRequestToken
            self.rowsToUpdate = rowsToUpdate
            self.tableId = tableId
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^(?!\\s*$).+")
            try self.rowsToUpdate.forEach {
                try $0.validate(name: "\(name).rowsToUpdate[]")
            }
            try self.validate(self.rowsToUpdate, name: "rowsToUpdate", parent: name, max: 100)
            try self.validate(self.rowsToUpdate, name: "rowsToUpdate", parent: name, min: 1)
            try self.validate(self.tableId, name: "tableId", parent: name, max: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, min: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken
            case rowsToUpdate
        }
    }

    public struct BatchUpdateTableRowsResult: AWSDecodableShape {
        ///  The list of batch items in the request that could not be updated in the table. Each element in this list contains one item from the request that could not be updated in the table along with the reason why that item could not be updated.
        public let failedBatchItems: [FailedBatchItem]?
        /// The updated workbook cursor after adding the new rows at the end of the table.
        public let workbookCursor: Int64

        public init(failedBatchItems: [FailedBatchItem]? = nil, workbookCursor: Int64) {
            self.failedBatchItems = failedBatchItems
            self.workbookCursor = workbookCursor
        }

        private enum CodingKeys: String, CodingKey {
            case failedBatchItems
            case workbookCursor
        }
    }

    public struct BatchUpsertTableRowsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "tableId", location: .uri(locationName: "tableId")),
            AWSMemberEncoding(label: "workbookId", location: .uri(locationName: "workbookId"))
        ]

        ///  The request token for performing the update action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again.   Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
        public let clientRequestToken: String?
        ///  The list of rows to upsert in the table. Each item in this list needs to have a batch item id to uniquely identify the element in the request, a filter expression to find the rows to update for that element and the cell values to set for each column in the upserted rows. You need to specify at least one item in this list.   Note that if one of the filter formulas in the request fails to evaluate because of an error or one of the column ids in any of the rows does not exist in the table, then the request fails and no updates are made to the table.
        public let rowsToUpsert: [UpsertRowData]
        /// The ID of the table where the rows are being upserted.  If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        public let tableId: String
        /// The ID of the workbook where the rows are being upserted.  If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        public let workbookId: String

        public init(clientRequestToken: String? = nil, rowsToUpsert: [UpsertRowData], tableId: String, workbookId: String) {
            self.clientRequestToken = clientRequestToken
            self.rowsToUpsert = rowsToUpsert
            self.tableId = tableId
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^(?!\\s*$).+")
            try self.rowsToUpsert.forEach {
                try $0.validate(name: "\(name).rowsToUpsert[]")
            }
            try self.validate(self.tableId, name: "tableId", parent: name, max: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, min: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken
            case rowsToUpsert
        }
    }

    public struct BatchUpsertTableRowsResult: AWSDecodableShape {
        ///  The list of batch items in the request that could not be updated or appended in the table. Each element in this list contains one item from the request that could not be updated in the table along with the reason why that item could not be updated or appended.
        public let failedBatchItems: [FailedBatchItem]?
        ///  A map with the batch item id as the key and the result of the upsert operation as the value. The result of the upsert operation specifies whether existing rows were updated or a new row was appended, along with the list of row ids that were affected.
        public let rows: [String: UpsertRowsResult]
        /// The updated workbook cursor after updating or appending rows in the table.
        public let workbookCursor: Int64

        public init(failedBatchItems: [FailedBatchItem]? = nil, rows: [String: UpsertRowsResult], workbookCursor: Int64) {
            self.failedBatchItems = failedBatchItems
            self.rows = rows
            self.workbookCursor = workbookCursor
        }

        private enum CodingKeys: String, CodingKey {
            case failedBatchItems
            case rows
            case workbookCursor
        }
    }

    public struct Cell: AWSDecodableShape {
        /// The format of the cell. If this field is empty, then the format is either not specified in the workbook or the format is set to AUTO.
        public let format: Format?
        ///  The formatted value of the cell. This is the value that you see displayed in the cell in the UI.   Note that the formatted value of a cell is always represented as a string irrespective of the data that is stored in the cell. For example, if a cell contains a date, the formatted value of the cell is the string representation of the formatted date being shown in the cell in the UI. See details in the rawValue field below for how cells of different formats will have different raw and formatted values.
        public let formattedValue: String?
        ///  The formula contained in the cell. This field is empty if a cell does not have a formula.
        public let formula: String?
        ///  The raw value of the data contained in the cell. The raw value depends on the format of the data in the cell. However the attribute in the API return value is always a string containing the raw value.   Cells with format DATE, DATE_TIME or TIME have the raw value as a floating point number where the whole number represents the number of days since 1/1/1900 and the fractional part represents the fraction of the day since midnight. For example, a cell with date 11/3/2020 has the raw value "44138". A cell with the time 9:00 AM has the raw value "0.375" and a cell with date/time value of 11/3/2020 9:00 AM has the raw value "44138.375". Notice that even though the raw value is a number in all three cases, it is still represented as a string.   Cells with format NUMBER, CURRENCY, PERCENTAGE and ACCOUNTING have the raw value of the data as the number representing the data being displayed. For example, the number 1.325 with two decimal places in the format will have it's raw value as "1.325" and formatted value as "1.33". A currency value for $10 will have the raw value as "10" and formatted value as "$10.00". A value representing 20% with two decimal places in the format will have its raw value as "0.2" and the formatted value as "20.00%". An accounting value of -$25 will have "-25" as the raw value and "$  (25.00)" as the formatted value.   Cells with format TEXT will have the raw text as the raw value. For example, a cell with text "John Smith" will have "John Smith" as both the raw value and the formatted value.   Cells with format CONTACT will have the name of the contact as a formatted value and the email address of the contact as the raw value. For example, a contact for John Smith will have "John Smith" as the formatted value and "john.smith@example.com" as the raw value.   Cells with format ROWLINK (aka picklist) will have the first column of the linked row as the formatted value and the row id of the linked row as the raw value. For example, a cell containing a picklist to a table that displays task status might have "Completed" as the formatted value and "row:dfcefaee-5b37-4355-8f28-40c3e4ff5dd4/ca432b2f-b8eb-431d-9fb5-cbe0342f9f03" as the raw value.   Cells with format AUTO or cells without any format that are auto-detected as one of the formats above will contain the raw and formatted values as mentioned above, based on the auto-detected formats. If there is no auto-detected format, the raw and formatted values will be the same as the data in the cell.
        public let rawValue: String?

        public init(format: Format? = nil, formattedValue: String? = nil, formula: String? = nil, rawValue: String? = nil) {
            self.format = format
            self.formattedValue = formattedValue
            self.formula = formula
            self.rawValue = rawValue
        }

        private enum CodingKeys: String, CodingKey {
            case format
            case formattedValue
            case formula
            case rawValue
        }
    }

    public struct CellInput: AWSEncodableShape {
        ///  Fact represents the data that is entered into a cell. This data can be free text or a formula. Formulas need to start with the equals (=) sign.
        public let fact: String?

        public init(fact: String? = nil) {
            self.fact = fact
        }

        public func validate(name: String) throws {
            try self.validate(self.fact, name: "fact", parent: name, max: 8192)
            try self.validate(self.fact, name: "fact", parent: name, pattern: "[\\s\\S]*")
        }

        private enum CodingKeys: String, CodingKey {
            case fact
        }
    }

    public struct ColumnMetadata: AWSDecodableShape {
        /// The format of the column.
        public let format: Format
        /// The name of the column.
        public let name: String

        public init(format: Format, name: String) {
            self.format = format
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case format
            case name
        }
    }

    public struct CreateRowData: AWSEncodableShape {
        ///  An external identifier that represents the single row that is being created as part of the BatchCreateTableRows request. This can be any string that you can use to identify the row in the request. The BatchCreateTableRows API puts the batch item id in the results to allow you to link data in the request to data in the results.
        public let batchItemId: String
        ///  A map representing the cells to create in the new row. The key is the column id of the cell and the value is the CellInput object that represents the data to set in that cell.
        public let cellsToCreate: [String: CellInput]

        public init(batchItemId: String, cellsToCreate: [String: CellInput]) {
            self.batchItemId = batchItemId
            self.cellsToCreate = cellsToCreate
        }

        public func validate(name: String) throws {
            try self.validate(self.batchItemId, name: "batchItemId", parent: name, max: 64)
            try self.validate(self.batchItemId, name: "batchItemId", parent: name, min: 1)
            try self.validate(self.batchItemId, name: "batchItemId", parent: name, pattern: "^(?!\\s*$).+")
            try self.cellsToCreate.forEach {
                try validate($0.key, name: "cellsToCreate.key", parent: name, max: 36)
                try validate($0.key, name: "cellsToCreate.key", parent: name, min: 36)
                try validate($0.key, name: "cellsToCreate.key", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
                try $0.value.validate(name: "\(name).cellsToCreate[\"\($0.key)\"]")
            }
            try self.validate(self.cellsToCreate, name: "cellsToCreate", parent: name, max: 100)
            try self.validate(self.cellsToCreate, name: "cellsToCreate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case batchItemId
            case cellsToCreate
        }
    }

    public struct DataItem: AWSDecodableShape {
        /// The formatted value of the data. e.g. John Smith.
        public let formattedValue: String?
        ///  The overrideFormat is optional and is specified only if a particular row of data has a different format for the data than the default format defined on the screen or the table.
        public let overrideFormat: Format?
        /// The raw value of the data. e.g. jsmith@example.com
        public let rawValue: String?

        public init(formattedValue: String? = nil, overrideFormat: Format? = nil, rawValue: String? = nil) {
            self.formattedValue = formattedValue
            self.overrideFormat = overrideFormat
            self.rawValue = rawValue
        }

        private enum CodingKeys: String, CodingKey {
            case formattedValue
            case overrideFormat
            case rawValue
        }
    }

    public struct DelimitedTextImportOptions: AWSEncodableShape & AWSDecodableShape {
        /// The encoding of the data in the input file.
        public let dataCharacterEncoding: ImportDataCharacterEncoding?
        /// The delimiter to use for separating columns in a single row of the input.
        public let delimiter: String
        /// Indicates whether the input file has a header row at the top containing the column names.
        public let hasHeaderRow: Bool?
        /// A parameter to indicate whether empty rows should be ignored or be included in the import.
        public let ignoreEmptyRows: Bool?

        public init(dataCharacterEncoding: ImportDataCharacterEncoding? = nil, delimiter: String, hasHeaderRow: Bool? = nil, ignoreEmptyRows: Bool? = nil) {
            self.dataCharacterEncoding = dataCharacterEncoding
            self.delimiter = delimiter
            self.hasHeaderRow = hasHeaderRow
            self.ignoreEmptyRows = ignoreEmptyRows
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, pattern: "^[^\\n\\r\\x00\\x08\\x0B\\x0C\\x0E\\x1F]?$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataCharacterEncoding
            case delimiter
            case hasHeaderRow
            case ignoreEmptyRows
        }
    }

    public struct DescribeTableDataImportJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "jobId")),
            AWSMemberEncoding(label: "tableId", location: .uri(locationName: "tableId")),
            AWSMemberEncoding(label: "workbookId", location: .uri(locationName: "workbookId"))
        ]

        /// The ID of the job that was returned by the StartTableDataImportJob request.  If a job with the specified id could not be found, this API throws ResourceNotFoundException.
        public let jobId: String
        /// The ID of the table into which data was imported.  If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        public let tableId: String
        /// The ID of the workbook into which data was imported.  If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        public let workbookId: String

        public init(jobId: String, tableId: String, workbookId: String) {
            self.jobId = jobId
            self.tableId = tableId
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 100)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[^\\n\\r\\x00\\x08\\x0B\\x0C\\x0E\\x1F]*$")
            try self.validate(self.tableId, name: "tableId", parent: name, max: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, min: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTableDataImportJobResult: AWSDecodableShape {
        ///  The metadata about the job that was submitted for import.
        public let jobMetadata: TableDataImportJobMetadata
        ///  The current status of the import job.
        public let jobStatus: TableDataImportJobStatus
        ///  A message providing more details about the current status of the import job.
        public let message: String

        public init(jobMetadata: TableDataImportJobMetadata, jobStatus: TableDataImportJobStatus, message: String) {
            self.jobMetadata = jobMetadata
            self.jobStatus = jobStatus
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case jobMetadata
            case jobStatus
            case message
        }
    }

    public struct DestinationOptions: AWSEncodableShape & AWSDecodableShape {
        /// A map of the column id to the import properties for each column.
        public let columnMap: [String: SourceDataColumnProperties]?

        public init(columnMap: [String: SourceDataColumnProperties]? = nil) {
            self.columnMap = columnMap
        }

        public func validate(name: String) throws {
            try self.columnMap?.forEach {
                try validate($0.key, name: "columnMap.key", parent: name, max: 36)
                try validate($0.key, name: "columnMap.key", parent: name, min: 36)
                try validate($0.key, name: "columnMap.key", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
                try $0.value.validate(name: "\(name).columnMap[\"\($0.key)\"]")
            }
            try self.validate(self.columnMap, name: "columnMap", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case columnMap
        }
    }

    public struct FailedBatchItem: AWSDecodableShape {
        ///  The error message that indicates why the batch item failed.
        public let errorMessage: String
        ///  The id of the batch item that failed. This is the batch item id for the BatchCreateTableRows and BatchUpsertTableRows operations and the row id for the BatchUpdateTableRows and BatchDeleteTableRows operations.
        public let id: String

        public init(errorMessage: String, id: String) {
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage
            case id
        }
    }

    public struct Filter: AWSEncodableShape {
        ///  The optional contextRowId attribute can be used to specify the row id of the context row if the filter formula contains unqualified references to table columns and needs a context row to evaluate them successfully.
        public let contextRowId: String?
        ///  A formula representing a filter function that returns zero or more matching rows from a table. Valid formulas in this field return a list of rows from a table. The most common ways of writing a formula to return a list of rows are to use the FindRow() or Filter() functions. Any other formula that returns zero or more rows is also acceptable. For example, you can use a formula that points to a cell that contains a filter function.
        public let formula: String

        public init(contextRowId: String? = nil, formula: String) {
            self.contextRowId = contextRowId
            self.formula = formula
        }

        public func validate(name: String) throws {
            try self.validate(self.contextRowId, name: "contextRowId", parent: name, max: 77)
            try self.validate(self.contextRowId, name: "contextRowId", parent: name, min: 77)
            try self.validate(self.contextRowId, name: "contextRowId", parent: name, pattern: "row:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\\/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.formula, name: "formula", parent: name, max: 8192)
            try self.validate(self.formula, name: "formula", parent: name, pattern: "^=.*")
        }

        private enum CodingKeys: String, CodingKey {
            case contextRowId
            case formula
        }
    }

    public struct GetScreenDataRequest: AWSEncodableShape {
        /// The ID of the app that contains the screem.
        public let appId: String
        ///  The number of results to be returned on a single page. Specify a number between 1 and 100. The maximum value is 100.   This parameter is optional. If you don't specify this parameter, the default page size is 100.
        public let maxResults: Int?
        ///  This parameter is optional. If a nextToken is not specified, the API returns the first page of data.   Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException.
        public let nextToken: String?
        /// The ID of the screen.
        public let screenId: String
        ///  Variables are optional and are needed only if the screen requires them to render correctly. Variables are specified as a map where the key is the name of the variable as defined on the screen. The value is an object which currently has only one property, rawValue, which holds the value of the variable to be passed to the screen.
        public let variables: [String: VariableValue]?
        /// The ID of the workbook that contains the screen.
        public let workbookId: String

        public init(appId: String, maxResults: Int? = nil, nextToken: String? = nil, screenId: String, variables: [String: VariableValue]? = nil, workbookId: String) {
            self.appId = appId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.screenId = screenId
            self.variables = variables
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 36)
            try self.validate(self.appId, name: "appId", parent: name, min: 36)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?!\\s*$).+")
            try self.validate(self.screenId, name: "screenId", parent: name, max: 36)
            try self.validate(self.screenId, name: "screenId", parent: name, min: 36)
            try self.validate(self.screenId, name: "screenId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.variables?.forEach {
                try validate($0.key, name: "variables.key", parent: name, pattern: "^(?!\\s*$).+")
                try $0.value.validate(name: "\(name).variables[\"\($0.key)\"]")
            }
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case maxResults
            case nextToken
            case screenId
            case variables
            case workbookId
        }
    }

    public struct GetScreenDataResult: AWSDecodableShape {
        ///  Provides the pagination token to load the next page if there are more results matching the request. If a pagination token is not present in the response, it means that all data matching the query has been loaded.
        public let nextToken: String?
        /// A map of all the rows on the screen keyed by block name.
        public let results: [String: ResultSet]
        ///  Indicates the cursor of the workbook at which the data returned by this workbook is read. Workbook cursor keeps increasing with every update and the increments are not sequential.
        public let workbookCursor: Int64

        public init(nextToken: String? = nil, results: [String: ResultSet], workbookCursor: Int64) {
            self.nextToken = nextToken
            self.results = results
            self.workbookCursor = workbookCursor
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case results
            case workbookCursor
        }
    }

    public struct ImportDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The configuration parameters for the data source of the import
        public let dataSourceConfig: ImportDataSourceConfig

        public init(dataSourceConfig: ImportDataSourceConfig) {
            self.dataSourceConfig = dataSourceConfig
        }

        public func validate(name: String) throws {
            try self.dataSourceConfig.validate(name: "\(name).dataSourceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceConfig
        }
    }

    public struct ImportDataSourceConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The URL from which source data will be downloaded for the import request.
        public let dataSourceUrl: String?

        public init(dataSourceUrl: String? = nil) {
            self.dataSourceUrl = dataSourceUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceUrl, name: "dataSourceUrl", parent: name, max: 8000)
            try self.validate(self.dataSourceUrl, name: "dataSourceUrl", parent: name, min: 1)
            try self.validate(self.dataSourceUrl, name: "dataSourceUrl", parent: name, pattern: "^https:\\/\\/[^\\n\\r\\x00\\x08\\x0B\\x0C\\x0E\\x1F]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceUrl
        }
    }

    public struct ImportJobSubmitter: AWSDecodableShape {
        /// The email id of the submitter of the import job, if available.
        public let email: String?
        /// The AWS user ARN of the submitter of the import job, if available.
        public let userArn: String?

        public init(email: String? = nil, userArn: String? = nil) {
            self.email = email
            self.userArn = userArn
        }

        private enum CodingKeys: String, CodingKey {
            case email
            case userArn
        }
    }

    public struct ImportOptions: AWSEncodableShape & AWSDecodableShape {
        /// Options relating to parsing delimited text. Required if dataFormat is DELIMITED_TEXT.
        public let delimitedTextOptions: DelimitedTextImportOptions?
        /// Options relating to the destination of the import request.
        public let destinationOptions: DestinationOptions?

        public init(delimitedTextOptions: DelimitedTextImportOptions? = nil, destinationOptions: DestinationOptions? = nil) {
            self.delimitedTextOptions = delimitedTextOptions
            self.destinationOptions = destinationOptions
        }

        public func validate(name: String) throws {
            try self.delimitedTextOptions?.validate(name: "\(name).delimitedTextOptions")
            try self.destinationOptions?.validate(name: "\(name).destinationOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case delimitedTextOptions
            case destinationOptions
        }
    }

    public struct InvokeScreenAutomationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "appId", location: .uri(locationName: "appId")),
            AWSMemberEncoding(label: "screenAutomationId", location: .uri(locationName: "screenAutomationId")),
            AWSMemberEncoding(label: "screenId", location: .uri(locationName: "screenId")),
            AWSMemberEncoding(label: "workbookId", location: .uri(locationName: "workbookId"))
        ]

        /// The ID of the app that contains the screen automation.
        public let appId: String
        ///  The request token for performing the automation action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will return the response of the previous call rather than performing the action again.   Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
        public let clientRequestToken: String?
        ///  The row ID for the automation if the automation is defined inside a block with source or list.
        public let rowId: String?
        /// The ID of the automation action to be performed.
        public let screenAutomationId: String
        /// The ID of the screen that contains the screen automation.
        public let screenId: String
        ///  Variables are specified as a map where the key is the name of the variable as defined on the screen. The value is an object which currently has only one property, rawValue, which holds the value of the variable to be passed to the screen. Any variables defined in a screen are required to be passed in the call.
        public let variables: [String: VariableValue]?
        /// The ID of the workbook that contains the screen automation.
        public let workbookId: String

        public init(appId: String, clientRequestToken: String? = nil, rowId: String? = nil, screenAutomationId: String, screenId: String, variables: [String: VariableValue]? = nil, workbookId: String) {
            self.appId = appId
            self.clientRequestToken = clientRequestToken
            self.rowId = rowId
            self.screenAutomationId = screenAutomationId
            self.screenId = screenId
            self.variables = variables
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 36)
            try self.validate(self.appId, name: "appId", parent: name, min: 36)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^(?!\\s*$).+")
            try self.validate(self.rowId, name: "rowId", parent: name, max: 77)
            try self.validate(self.rowId, name: "rowId", parent: name, min: 77)
            try self.validate(self.rowId, name: "rowId", parent: name, pattern: "row:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\\/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.screenAutomationId, name: "screenAutomationId", parent: name, max: 36)
            try self.validate(self.screenAutomationId, name: "screenAutomationId", parent: name, min: 36)
            try self.validate(self.screenAutomationId, name: "screenAutomationId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.screenId, name: "screenId", parent: name, max: 36)
            try self.validate(self.screenId, name: "screenId", parent: name, min: 36)
            try self.validate(self.screenId, name: "screenId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.variables?.forEach {
                try validate($0.key, name: "variables.key", parent: name, pattern: "^(?!\\s*$).+")
                try $0.value.validate(name: "\(name).variables[\"\($0.key)\"]")
            }
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken
            case rowId
            case variables
        }
    }

    public struct InvokeScreenAutomationResult: AWSDecodableShape {
        /// The updated workbook cursor after performing the automation action.
        public let workbookCursor: Int64

        public init(workbookCursor: Int64) {
            self.workbookCursor = workbookCursor
        }

        private enum CodingKeys: String, CodingKey {
            case workbookCursor
        }
    }

    public struct ListTableColumnsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "tableId", location: .uri(locationName: "tableId")),
            AWSMemberEncoding(label: "workbookId", location: .uri(locationName: "workbookId"))
        ]

        ///  This parameter is optional. If a nextToken is not specified, the API returns the first page of data.   Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException.
        public let nextToken: String?
        /// The ID of the table whose columns are being retrieved.  If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        public let tableId: String
        /// The ID of the workbook that contains the table whose columns are being retrieved.  If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        public let workbookId: String

        public init(nextToken: String? = nil, tableId: String, workbookId: String) {
            self.nextToken = nextToken
            self.tableId = tableId
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?!\\s*$).+")
            try self.validate(self.tableId, name: "tableId", parent: name, max: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, min: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTableColumnsResult: AWSDecodableShape {
        ///  Provides the pagination token to load the next page if there are more results matching the request. If a pagination token is not present in the response, it means that all data matching the request has been loaded.
        public let nextToken: String?
        ///  The list of columns in the table.
        public let tableColumns: [TableColumn]
        ///  Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor keeps increasing with every update and the increments are not sequential.
        public let workbookCursor: Int64?

        public init(nextToken: String? = nil, tableColumns: [TableColumn], workbookCursor: Int64? = nil) {
            self.nextToken = nextToken
            self.tableColumns = tableColumns
            self.workbookCursor = workbookCursor
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case tableColumns
            case workbookCursor
        }
    }

    public struct ListTableRowsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "tableId", location: .uri(locationName: "tableId")),
            AWSMemberEncoding(label: "workbookId", location: .uri(locationName: "workbookId"))
        ]

        /// The maximum number of rows to return in each page of the results.
        public let maxResults: Int?
        ///  This parameter is optional. If a nextToken is not specified, the API returns the first page of data.   Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException.
        public let nextToken: String?
        ///  This parameter is optional. If one or more row ids are specified in this list, then only the specified row ids are returned in the result. If no row ids are specified here, then all the rows in the table are returned.
        public let rowIds: [String]?
        /// The ID of the table whose rows are being retrieved.  If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        public let tableId: String
        /// The ID of the workbook that contains the table whose rows are being retrieved.  If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        public let workbookId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, rowIds: [String]? = nil, tableId: String, workbookId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.rowIds = rowIds
            self.tableId = tableId
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?!\\s*$).+")
            try self.rowIds?.forEach {
                try validate($0, name: "rowIds[]", parent: name, max: 77)
                try validate($0, name: "rowIds[]", parent: name, min: 77)
                try validate($0, name: "rowIds[]", parent: name, pattern: "row:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\\/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            }
            try self.validate(self.rowIds, name: "rowIds", parent: name, max: 100)
            try self.validate(self.rowIds, name: "rowIds", parent: name, min: 1)
            try self.validate(self.tableId, name: "tableId", parent: name, max: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, min: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case rowIds
        }
    }

    public struct ListTableRowsResult: AWSDecodableShape {
        ///  The list of columns in the table whose row data is returned in the result.
        public let columnIds: [String]
        ///  Provides the pagination token to load the next page if there are more results matching the request. If a pagination token is not present in the response, it means that all data matching the request has been loaded.
        public let nextToken: String?
        ///  The list of row ids included in the request that were not found in the table.
        public let rowIdsNotFound: [String]?
        ///  The list of rows in the table. Note that this result is paginated, so this list contains a maximum of 100 rows.
        public let rows: [TableRow]
        ///  Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor keeps increasing with every update and the increments are not sequential.
        public let workbookCursor: Int64

        public init(columnIds: [String], nextToken: String? = nil, rowIdsNotFound: [String]? = nil, rows: [TableRow], workbookCursor: Int64) {
            self.columnIds = columnIds
            self.nextToken = nextToken
            self.rowIdsNotFound = rowIdsNotFound
            self.rows = rows
            self.workbookCursor = workbookCursor
        }

        private enum CodingKeys: String, CodingKey {
            case columnIds
            case nextToken
            case rowIdsNotFound
            case rows
            case workbookCursor
        }
    }

    public struct ListTablesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "workbookId", location: .uri(locationName: "workbookId"))
        ]

        /// The maximum number of tables to return in each page of the results.
        public let maxResults: Int?
        ///  This parameter is optional. If a nextToken is not specified, the API returns the first page of data.   Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException.
        public let nextToken: String?
        /// The ID of the workbook whose tables are being retrieved.  If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        public let workbookId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workbookId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?!\\s*$).+")
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTablesResult: AWSDecodableShape {
        ///  Provides the pagination token to load the next page if there are more results matching the request. If a pagination token is not present in the response, it means that all data matching the request has been loaded.
        public let nextToken: String?
        ///  The list of tables in the workbook.
        public let tables: [Table]
        ///  Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor keeps increasing with every update and the increments are not sequential.
        public let workbookCursor: Int64?

        public init(nextToken: String? = nil, tables: [Table], workbookCursor: Int64? = nil) {
            self.nextToken = nextToken
            self.tables = tables
            self.workbookCursor = workbookCursor
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case tables
            case workbookCursor
        }
    }

    public struct QueryTableRowsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "tableId", location: .uri(locationName: "tableId")),
            AWSMemberEncoding(label: "workbookId", location: .uri(locationName: "workbookId"))
        ]

        /// An object that represents a filter formula along with the id of the context row under which the filter function needs to evaluate.
        public let filterFormula: Filter
        /// The maximum number of rows to return in each page of the results.
        public let maxResults: Int?
        ///  This parameter is optional. If a nextToken is not specified, the API returns the first page of data.   Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException.
        public let nextToken: String?
        /// The ID of the table whose rows are being queried.  If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        public let tableId: String
        /// The ID of the workbook whose table rows are being queried.  If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        public let workbookId: String

        public init(filterFormula: Filter, maxResults: Int? = nil, nextToken: String? = nil, tableId: String, workbookId: String) {
            self.filterFormula = filterFormula
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tableId = tableId
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.filterFormula.validate(name: "\(name).filterFormula")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?!\\s*$).+")
            try self.validate(self.tableId, name: "tableId", parent: name, max: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, min: 36)
            try self.validate(self.tableId, name: "tableId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case filterFormula
            case maxResults
            case nextToken
        }
    }

    public struct QueryTableRowsResult: AWSDecodableShape {
        ///  The list of columns in the table whose row data is returned in the result.
        public let columnIds: [String]
        ///  Provides the pagination token to load the next page if there are more results matching the request. If a pagination token is not present in the response, it means that all data matching the request has been loaded.
        public let nextToken: String?
        ///  The list of rows in the table that match the query filter.
        public let rows: [TableRow]
        ///  Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor keeps increasing with every update and the increments are not sequential.
        public let workbookCursor: Int64

        public init(columnIds: [String], nextToken: String? = nil, rows: [TableRow], workbookCursor: Int64) {
            self.columnIds = columnIds
            self.nextToken = nextToken
            self.rows = rows
            self.workbookCursor = workbookCursor
        }

        private enum CodingKeys: String, CodingKey {
            case columnIds
            case nextToken
            case rows
            case workbookCursor
        }
    }

    public struct ResultRow: AWSDecodableShape {
        /// List of all the data cells in a row.
        public let dataItems: [DataItem]
        /// The ID for a particular row.
        public let rowId: String?

        public init(dataItems: [DataItem], rowId: String? = nil) {
            self.dataItems = dataItems
            self.rowId = rowId
        }

        private enum CodingKeys: String, CodingKey {
            case dataItems
            case rowId
        }
    }

    public struct ResultSet: AWSDecodableShape {
        ///  List of headers for all the data cells in the block. The header identifies the name and default format of the data cell. Data cells appear in the same order in all rows as defined in the header. The names and formats are not repeated in the rows. If a particular row does not have a value for a data cell, a blank value is used.   For example, a task list that displays the task name, due date and assigned person might have headers [ { "name": "Task Name"}, {"name": "Due Date", "format": "DATE"}, {"name": "Assigned", "format": "CONTACT"} ]. Every row in the result will have the task name as the first item, due date as the second item and assigned person as the third item. If a particular task does not have a due date, that row will still have a blank value in the second element and the assigned person will still be in the third element.
        public let headers: [ColumnMetadata]
        ///  List of rows returned by the request. Each row has a row Id and a list of data cells in that row. The data cells will be present in the same order as they are defined in the header.
        public let rows: [ResultRow]

        public init(headers: [ColumnMetadata], rows: [ResultRow]) {
            self.headers = headers
            self.rows = rows
        }

        private enum CodingKeys: String, CodingKey {
            case headers
            case rows
        }
    }

    public struct SourceDataColumnProperties: AWSEncodableShape & AWSDecodableShape {
        /// The index of the column in the input file.
        public let columnIndex: Int?

        public init(columnIndex: Int? = nil) {
            self.columnIndex = columnIndex
        }

        public func validate(name: String) throws {
            try self.validate(self.columnIndex, name: "columnIndex", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnIndex
        }
    }

    public struct StartTableDataImportJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "destinationTableId", location: .uri(locationName: "destinationTableId")),
            AWSMemberEncoding(label: "workbookId", location: .uri(locationName: "workbookId"))
        ]

        ///  The request token for performing the update action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again.   Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
        public let clientRequestToken: String
        ///  The format of the data that is being imported. Currently the only option supported is "DELIMITED_TEXT".
        public let dataFormat: ImportSourceDataFormat
        ///  The source of the data that is being imported. The size of source must be no larger than 100 MB. Source must have no more than 100,000 cells and no more than 1,000 rows.
        public let dataSource: ImportDataSource
        /// The ID of the table where the rows are being imported.  If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        public let destinationTableId: String
        ///  The options for customizing this import request.
        public let importOptions: ImportOptions
        /// The ID of the workbook where the rows are being imported.  If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        public let workbookId: String

        public init(clientRequestToken: String, dataFormat: ImportSourceDataFormat, dataSource: ImportDataSource, destinationTableId: String, importOptions: ImportOptions, workbookId: String) {
            self.clientRequestToken = clientRequestToken
            self.dataFormat = dataFormat
            self.dataSource = dataSource
            self.destinationTableId = destinationTableId
            self.importOptions = importOptions
            self.workbookId = workbookId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 32)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^(?!\\s*$).+")
            try self.dataSource.validate(name: "\(name).dataSource")
            try self.validate(self.destinationTableId, name: "destinationTableId", parent: name, max: 36)
            try self.validate(self.destinationTableId, name: "destinationTableId", parent: name, min: 36)
            try self.validate(self.destinationTableId, name: "destinationTableId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
            try self.importOptions.validate(name: "\(name).importOptions")
            try self.validate(self.workbookId, name: "workbookId", parent: name, max: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, min: 36)
            try self.validate(self.workbookId, name: "workbookId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken
            case dataFormat
            case dataSource
            case importOptions
        }
    }

    public struct StartTableDataImportJobResult: AWSDecodableShape {
        ///  The id that is assigned to this import job. Future requests to find out the status of this import job need to send this id in the appropriate parameter in the request.
        public let jobId: String
        ///  The status of the import job immediately after submitting the request.
        public let jobStatus: TableDataImportJobStatus

        public init(jobId: String, jobStatus: TableDataImportJobStatus) {
            self.jobId = jobId
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
            case jobStatus
        }
    }

    public struct Table: AWSDecodableShape {
        /// The id of the table.
        public let tableId: String?
        /// The name of the table.
        public let tableName: String?

        public init(tableId: String? = nil, tableName: String? = nil) {
            self.tableId = tableId
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case tableId
            case tableName
        }
    }

    public struct TableColumn: AWSDecodableShape {
        ///  The column level format that is applied in the table. An empty value in this field means that the column format is the default value 'AUTO'.
        public let format: Format?
        /// The id of the column in the table.
        public let tableColumnId: String?
        /// The name of the column in the table.
        public let tableColumnName: String?

        public init(format: Format? = nil, tableColumnId: String? = nil, tableColumnName: String? = nil) {
            self.format = format
            self.tableColumnId = tableColumnId
            self.tableColumnName = tableColumnName
        }

        private enum CodingKeys: String, CodingKey {
            case format
            case tableColumnId
            case tableColumnName
        }
    }

    public struct TableDataImportJobMetadata: AWSDecodableShape {
        /// The source of the data that was submitted for import.
        public let dataSource: ImportDataSource
        /// The options that was specified at the time of submitting the import request.
        public let importOptions: ImportOptions
        /// Details about the submitter of the import request.
        public let submitter: ImportJobSubmitter
        /// The timestamp when the job was submitted for import.
        public let submitTime: Date

        public init(dataSource: ImportDataSource, importOptions: ImportOptions, submitter: ImportJobSubmitter, submitTime: Date) {
            self.dataSource = dataSource
            self.importOptions = importOptions
            self.submitter = submitter
            self.submitTime = submitTime
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource
            case importOptions
            case submitter
            case submitTime
        }
    }

    public struct TableRow: AWSDecodableShape {
        /// A list of cells in the table row. The cells appear in the same order as the columns of the table.
        public let cells: [Cell]
        /// The id of the row in the table.
        public let rowId: String

        public init(cells: [Cell], rowId: String) {
            self.cells = cells
            self.rowId = rowId
        }

        private enum CodingKeys: String, CodingKey {
            case cells
            case rowId
        }
    }

    public struct UpdateRowData: AWSEncodableShape {
        ///  A map representing the cells to update in the given row. The key is the column id of the cell and the value is the CellInput object that represents the data to set in that cell.
        public let cellsToUpdate: [String: CellInput]
        ///  The id of the row that needs to be updated.
        public let rowId: String

        public init(cellsToUpdate: [String: CellInput], rowId: String) {
            self.cellsToUpdate = cellsToUpdate
            self.rowId = rowId
        }

        public func validate(name: String) throws {
            try self.cellsToUpdate.forEach {
                try validate($0.key, name: "cellsToUpdate.key", parent: name, max: 36)
                try validate($0.key, name: "cellsToUpdate.key", parent: name, min: 36)
                try validate($0.key, name: "cellsToUpdate.key", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
                try $0.value.validate(name: "\(name).cellsToUpdate[\"\($0.key)\"]")
            }
            try self.validate(self.cellsToUpdate, name: "cellsToUpdate", parent: name, max: 100)
            try self.validate(self.cellsToUpdate, name: "cellsToUpdate", parent: name, min: 1)
            try self.validate(self.rowId, name: "rowId", parent: name, max: 77)
            try self.validate(self.rowId, name: "rowId", parent: name, min: 77)
            try self.validate(self.rowId, name: "rowId", parent: name, pattern: "row:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\\/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case cellsToUpdate
            case rowId
        }
    }

    public struct UpsertRowData: AWSEncodableShape {
        ///  An external identifier that represents a single item in the request that is being upserted as part of the BatchUpsertTableRows request. This can be any string that you can use to identify the item in the request. The BatchUpsertTableRows API puts the batch item id in the results to allow you to link data in the request to data in the results.
        public let batchItemId: String
        ///  A map representing the cells to update for the matching rows or an appended row. The key is the column id of the cell and the value is the CellInput object that represents the data to set in that cell.
        public let cellsToUpdate: [String: CellInput]
        ///  The filter formula to use to find existing matching rows to update. The formula needs to return zero or more rows. If the formula returns 0 rows, then a new row will be appended in the target table. If the formula returns one or more rows, then the returned rows will be updated.   Note that the filter formula needs to return rows from the target table for the upsert operation to succeed. If the filter formula has a syntax error or it doesn't evaluate to zero or more rows in the target table for any one item in the input list, then the entire BatchUpsertTableRows request fails and no updates are made to the table.
        public let filter: Filter

        public init(batchItemId: String, cellsToUpdate: [String: CellInput], filter: Filter) {
            self.batchItemId = batchItemId
            self.cellsToUpdate = cellsToUpdate
            self.filter = filter
        }

        public func validate(name: String) throws {
            try self.validate(self.batchItemId, name: "batchItemId", parent: name, max: 64)
            try self.validate(self.batchItemId, name: "batchItemId", parent: name, min: 1)
            try self.validate(self.batchItemId, name: "batchItemId", parent: name, pattern: "^(?!\\s*$).+")
            try self.cellsToUpdate.forEach {
                try validate($0.key, name: "cellsToUpdate.key", parent: name, max: 36)
                try validate($0.key, name: "cellsToUpdate.key", parent: name, min: 36)
                try validate($0.key, name: "cellsToUpdate.key", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
                try $0.value.validate(name: "\(name).cellsToUpdate[\"\($0.key)\"]")
            }
            try self.validate(self.cellsToUpdate, name: "cellsToUpdate", parent: name, max: 100)
            try self.validate(self.cellsToUpdate, name: "cellsToUpdate", parent: name, min: 1)
            try self.filter.validate(name: "\(name).filter")
        }

        private enum CodingKeys: String, CodingKey {
            case batchItemId
            case cellsToUpdate
            case filter
        }
    }

    public struct UpsertRowsResult: AWSDecodableShape {
        ///  The list of row ids that were changed as part of an upsert row operation. If the upsert resulted in an update, this list could potentially contain multiple rows that matched the filter and hence got updated. If the upsert resulted in an append, this list would only have the single row that was appended.
        public let rowIds: [String]
        ///  The result of the upsert action.
        public let upsertAction: UpsertAction

        public init(rowIds: [String], upsertAction: UpsertAction) {
            self.rowIds = rowIds
            self.upsertAction = upsertAction
        }

        private enum CodingKeys: String, CodingKey {
            case rowIds
            case upsertAction
        }
    }

    public struct VariableValue: AWSEncodableShape {
        /// Raw value of the variable.
        public let rawValue: String

        public init(rawValue: String) {
            self.rawValue = rawValue
        }

        public func validate(name: String) throws {
            try self.validate(self.rawValue, name: "rawValue", parent: name, max: 32767)
            try self.validate(self.rawValue, name: "rawValue", parent: name, pattern: "[\\s\\S]*")
        }

        private enum CodingKeys: String, CodingKey {
            case rawValue
        }
    }
}
