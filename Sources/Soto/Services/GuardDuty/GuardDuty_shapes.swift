//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension GuardDuty {
    // MARK: Enums

    public enum AdminStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AutoEnableMembers: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case new = "NEW"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum CoverageFilterCriterionKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "ACCOUNT_ID"
        case addonVersion = "ADDON_VERSION"
        case agentVersion = "AGENT_VERSION"
        case clusterArn = "CLUSTER_ARN"
        case clusterName = "CLUSTER_NAME"
        case coverageStatus = "COVERAGE_STATUS"
        case ecsClusterName = "ECS_CLUSTER_NAME"
        case eksClusterName = "EKS_CLUSTER_NAME"
        case instanceId = "INSTANCE_ID"
        case managementType = "MANAGEMENT_TYPE"
        case resourceType = "RESOURCE_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum CoverageSortKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "ACCOUNT_ID"
        case addonVersion = "ADDON_VERSION"
        case clusterName = "CLUSTER_NAME"
        case coverageStatus = "COVERAGE_STATUS"
        case ecsClusterName = "ECS_CLUSTER_NAME"
        case eksClusterName = "EKS_CLUSTER_NAME"
        case instanceId = "INSTANCE_ID"
        case issue = "ISSUE"
        case updatedAt = "UPDATED_AT"
        public var description: String { return self.rawValue }
    }

    public enum CoverageStatisticsType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case countByCoverageStatus = "COUNT_BY_COVERAGE_STATUS"
        case countByResourceType = "COUNT_BY_RESOURCE_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum CoverageStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum CriterionKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "ACCOUNT_ID"
        case ec2InstanceArn = "EC2_INSTANCE_ARN"
        case guarddutyFindingId = "GUARDDUTY_FINDING_ID"
        case scanId = "SCAN_ID"
        case scanStartTime = "SCAN_START_TIME"
        case scanStatus = "SCAN_STATUS"
        case scanType = "SCAN_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum DataSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudTrail = "CLOUD_TRAIL"
        case dnsLogs = "DNS_LOGS"
        case ec2MalwareScan = "EC2_MALWARE_SCAN"
        case flowLogs = "FLOW_LOGS"
        case kubernetesAuditLogs = "KUBERNETES_AUDIT_LOGS"
        case s3Logs = "S3_LOGS"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DestinationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum DetectorFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ebsMalwareProtection = "EBS_MALWARE_PROTECTION"
        case eksAuditLogs = "EKS_AUDIT_LOGS"
        case eksRuntimeMonitoring = "EKS_RUNTIME_MONITORING"
        case lambdaNetworkLogs = "LAMBDA_NETWORK_LOGS"
        case rdsLoginEvents = "RDS_LOGIN_EVENTS"
        case runtimeMonitoring = "RUNTIME_MONITORING"
        case s3DataEvents = "S3_DATA_EVENTS"
        public var description: String { return self.rawValue }
    }

    public enum DetectorFeatureResult: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudTrail = "CLOUD_TRAIL"
        case dnsLogs = "DNS_LOGS"
        case ebsMalwareProtection = "EBS_MALWARE_PROTECTION"
        case eksAuditLogs = "EKS_AUDIT_LOGS"
        case eksRuntimeMonitoring = "EKS_RUNTIME_MONITORING"
        case flowLogs = "FLOW_LOGS"
        case lambdaNetworkLogs = "LAMBDA_NETWORK_LOGS"
        case rdsLoginEvents = "RDS_LOGIN_EVENTS"
        case runtimeMonitoring = "RUNTIME_MONITORING"
        case s3DataEvents = "S3_DATA_EVENTS"
        public var description: String { return self.rawValue }
    }

    public enum DetectorStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum EbsSnapshotPreservation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case noRetention = "NO_RETENTION"
        case retentionWithFinding = "RETENTION_WITH_FINDING"
        public var description: String { return self.rawValue }
    }

    public enum FeatureAdditionalConfiguration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2AgentManagement = "EC2_AGENT_MANAGEMENT"
        case ecsFargateAgentManagement = "ECS_FARGATE_AGENT_MANAGEMENT"
        case eksAddonManagement = "EKS_ADDON_MANAGEMENT"
        public var description: String { return self.rawValue }
    }

    public enum FeatureStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Feedback: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notUseful = "NOT_USEFUL"
        case useful = "USEFUL"
        public var description: String { return self.rawValue }
    }

    public enum FilterAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case archive = "ARCHIVE"
        case noop = "NOOP"
        public var description: String { return self.rawValue }
    }

    public enum FindingPublishingFrequency: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fifteenMinutes = "FIFTEEN_MINUTES"
        case oneHour = "ONE_HOUR"
        case sixHours = "SIX_HOURS"
        public var description: String { return self.rawValue }
    }

    public enum FindingResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessKey = "ACCESS_KEY"
        case ec2Instance = "EC2_INSTANCE"
        case ec2NetworkInterface = "EC2_NETWORK_INTERFACE"
        case s3Bucket = "S3_BUCKET"
        case s3Object = "S3_OBJECT"
        public var description: String { return self.rawValue }
    }

    public enum FindingStatisticType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case countBySeverity = "COUNT_BY_SEVERITY"
        public var description: String { return self.rawValue }
    }

    public enum FreeTrialFeatureResult: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudTrail = "CLOUD_TRAIL"
        case dnsLogs = "DNS_LOGS"
        case ebsMalwareProtection = "EBS_MALWARE_PROTECTION"
        case ec2RuntimeMonitoring = "EC2_RUNTIME_MONITORING"
        case eksAuditLogs = "EKS_AUDIT_LOGS"
        case eksRuntimeMonitoring = "EKS_RUNTIME_MONITORING"
        case fargateRuntimeMonitoring = "FARGATE_RUNTIME_MONITORING"
        case flowLogs = "FLOW_LOGS"
        case lambdaNetworkLogs = "LAMBDA_NETWORK_LOGS"
        case rdsLoginEvents = "RDS_LOGIN_EVENTS"
        case s3DataEvents = "S3_DATA_EVENTS"
        public var description: String { return self.rawValue }
    }

    public enum GroupByType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case account = "ACCOUNT"
        case date = "DATE"
        case findingType = "FINDING_TYPE"
        case resource = "RESOURCE"
        case severity = "SEVERITY"
        public var description: String { return self.rawValue }
    }

    public enum IndicatorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attackTactic = "ATTACK_TACTIC"
        case attackTechnique = "ATTACK_TECHNIQUE"
        case highRiskApi = "HIGH_RISK_API"
        case maliciousIp = "MALICIOUS_IP"
        case suspiciousNetwork = "SUSPICIOUS_NETWORK"
        case suspiciousUserAgent = "SUSPICIOUS_USER_AGENT"
        case torIp = "TOR_IP"
        case unusualApiForAccount = "UNUSUAL_API_FOR_ACCOUNT"
        case unusualAsnForAccount = "UNUSUAL_ASN_FOR_ACCOUNT"
        case unusualAsnForUser = "UNUSUAL_ASN_FOR_USER"
        public var description: String { return self.rawValue }
    }

    public enum IpSetFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alienVault = "ALIEN_VAULT"
        case fireEye = "FIRE_EYE"
        case otxCsv = "OTX_CSV"
        case proofPoint = "PROOF_POINT"
        case stix = "STIX"
        case txt = "TXT"
        public var description: String { return self.rawValue }
    }

    public enum IpSetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case deactivating = "DEACTIVATING"
        case deletePending = "DELETE_PENDING"
        case deleted = "DELETED"
        case error = "ERROR"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum MalwareProtectionPlanStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case error = "ERROR"
        case warning = "WARNING"
        public var description: String { return self.rawValue }
    }

    public enum MalwareProtectionPlanTaggingActionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ManagementType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case autoManaged = "AUTO_MANAGED"
        case disabled = "DISABLED"
        case manual = "MANUAL"
        public var description: String { return self.rawValue }
    }

    public enum MfaStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum NetworkDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
        public var description: String { return self.rawValue }
    }

    public enum OrderBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum OrgFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ebsMalwareProtection = "EBS_MALWARE_PROTECTION"
        case eksAuditLogs = "EKS_AUDIT_LOGS"
        case eksRuntimeMonitoring = "EKS_RUNTIME_MONITORING"
        case lambdaNetworkLogs = "LAMBDA_NETWORK_LOGS"
        case rdsLoginEvents = "RDS_LOGIN_EVENTS"
        case runtimeMonitoring = "RUNTIME_MONITORING"
        case s3DataEvents = "S3_DATA_EVENTS"
        public var description: String { return self.rawValue }
    }

    public enum OrgFeatureAdditionalConfiguration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2AgentManagement = "EC2_AGENT_MANAGEMENT"
        case ecsFargateAgentManagement = "ECS_FARGATE_AGENT_MANAGEMENT"
        case eksAddonManagement = "EKS_ADDON_MANAGEMENT"
        public var description: String { return self.rawValue }
    }

    public enum OrgFeatureStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case new = "NEW"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ProfileSubtype: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case frequent = "FREQUENT"
        case infrequent = "INFREQUENT"
        case rare = "RARE"
        case unseen = "UNSEEN"
        public var description: String { return self.rawValue }
    }

    public enum ProfileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case frequency = "FREQUENCY"
        public var description: String { return self.rawValue }
    }

    public enum PublicAccessStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allowed = "ALLOWED"
        case blocked = "BLOCKED"
        public var description: String { return self.rawValue }
    }

    public enum PublicAclIgnoreBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ignored = "IGNORED"
        case notIgnored = "NOT_IGNORED"
        public var description: String { return self.rawValue }
    }

    public enum PublicBucketRestrictBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notRestricted = "NOT_RESTRICTED"
        case restricted = "RESTRICTED"
        public var description: String { return self.rawValue }
    }

    public enum PublishingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pendingVerification = "PENDING_VERIFICATION"
        case publishing = "PUBLISHING"
        case stopped = "STOPPED"
        case unableToPublishFixDestinationProperty = "UNABLE_TO_PUBLISH_FIX_DESTINATION_PROPERTY"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2 = "EC2"
        case ecs = "ECS"
        case eks = "EKS"
        public var description: String { return self.rawValue }
    }

    public enum ScanCriterionKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2InstanceTag = "EC2_INSTANCE_TAG"
        public var description: String { return self.rawValue }
    }

    public enum ScanResult: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case clean = "CLEAN"
        case infected = "INFECTED"
        public var description: String { return self.rawValue }
    }

    public enum ScanStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case running = "RUNNING"
        case skipped = "SKIPPED"
        public var description: String { return self.rawValue }
    }

    public enum ScanType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case guarddutyInitiated = "GUARDDUTY_INITIATED"
        case onDemand = "ON_DEMAND"
        public var description: String { return self.rawValue }
    }

    public enum SignalType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudTrail = "CLOUD_TRAIL"
        case finding = "FINDING"
        case s3DataEvents = "S3_DATA_EVENTS"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelSetFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alienVault = "ALIEN_VAULT"
        case fireEye = "FIRE_EYE"
        case otxCsv = "OTX_CSV"
        case proofPoint = "PROOF_POINT"
        case stix = "STIX"
        case txt = "TXT"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelSetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case deactivating = "DEACTIVATING"
        case deletePending = "DELETE_PENDING"
        case deleted = "DELETED"
        case error = "ERROR"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum UsageFeature: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudTrail = "CLOUD_TRAIL"
        case dnsLogs = "DNS_LOGS"
        case ebsMalwareProtection = "EBS_MALWARE_PROTECTION"
        case ec2RuntimeMonitoring = "EC2_RUNTIME_MONITORING"
        case eksAuditLogs = "EKS_AUDIT_LOGS"
        case eksRuntimeMonitoring = "EKS_RUNTIME_MONITORING"
        case fargateRuntimeMonitoring = "FARGATE_RUNTIME_MONITORING"
        case flowLogs = "FLOW_LOGS"
        case lambdaNetworkLogs = "LAMBDA_NETWORK_LOGS"
        case rdsDbiProtectionProvisioned = "RDS_DBI_PROTECTION_PROVISIONED"
        case rdsDbiProtectionServerless = "RDS_DBI_PROTECTION_SERVERLESS"
        case rdsLoginEvents = "RDS_LOGIN_EVENTS"
        case s3DataEvents = "S3_DATA_EVENTS"
        public var description: String { return self.rawValue }
    }

    public enum UsageStatisticType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sumByAccount = "SUM_BY_ACCOUNT"
        case sumByDataSource = "SUM_BY_DATA_SOURCE"
        case sumByFeatures = "SUM_BY_FEATURES"
        case sumByResource = "SUM_BY_RESOURCE"
        case topAccountsByFeature = "TOP_ACCOUNTS_BY_FEATURE"
        case topResources = "TOP_RESOURCES"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcceptAdministratorInvitationRequest: AWSEncodableShape {
        /// The account ID of the GuardDuty administrator account whose invitation you're accepting.
        public let administratorId: String?
        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String
        /// The value that is used to validate the administrator account to the member account.
        public let invitationId: String?

        @inlinable
        public init(administratorId: String? = nil, detectorId: String, invitationId: String? = nil) {
            self.administratorId = administratorId
            self.detectorId = detectorId
            self.invitationId = invitationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.administratorId, forKey: .administratorId)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.invitationId, forKey: .invitationId)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case administratorId = "administratorId"
            case invitationId = "invitationId"
        }
    }

    public struct AcceptAdministratorInvitationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AcceptInvitationRequest: AWSEncodableShape {
        /// The unique ID of the detector of the GuardDuty member account. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The value that is used to validate the administrator account to the member account.
        public let invitationId: String?
        /// The account ID of the GuardDuty administrator account whose invitation you're accepting.
        public let masterId: String?

        @inlinable
        public init(detectorId: String, invitationId: String? = nil, masterId: String? = nil) {
            self.detectorId = detectorId
            self.invitationId = invitationId
            self.masterId = masterId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.invitationId, forKey: .invitationId)
            try container.encodeIfPresent(self.masterId, forKey: .masterId)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invitationId = "invitationId"
            case masterId = "masterId"
        }
    }

    public struct AcceptInvitationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AccessControlList: AWSDecodableShape {
        /// A value that indicates whether public read access for the bucket is enabled through an Access Control List (ACL).
        public let allowsPublicReadAccess: Bool?
        /// A value that indicates whether public write access for the bucket is enabled through an Access Control List (ACL).
        public let allowsPublicWriteAccess: Bool?

        @inlinable
        public init(allowsPublicReadAccess: Bool? = nil, allowsPublicWriteAccess: Bool? = nil) {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }

        private enum CodingKeys: String, CodingKey {
            case allowsPublicReadAccess = "allowsPublicReadAccess"
            case allowsPublicWriteAccess = "allowsPublicWriteAccess"
        }
    }

    public struct AccessDeniedException: AWSErrorShape {
        /// The error message.
        public let message: String?
        /// The error type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "__type"
        }
    }

    public struct AccessKey: AWSDecodableShape {
        /// Principal ID of the user.
        public let principalId: String?
        /// Name of the user.
        public let userName: String?
        /// Type of the user.
        public let userType: String?

        @inlinable
        public init(principalId: String? = nil, userName: String? = nil, userType: String? = nil) {
            self.principalId = principalId
            self.userName = userName
            self.userType = userType
        }

        private enum CodingKeys: String, CodingKey {
            case principalId = "principalId"
            case userName = "userName"
            case userType = "userType"
        }
    }

    public struct AccessKeyDetails: AWSDecodableShape {
        /// The access key ID of the user.
        public let accessKeyId: String?
        /// The principal ID of the user.
        public let principalId: String?
        /// The name of the user.
        public let userName: String?
        /// The type of the user.
        public let userType: String?

        @inlinable
        public init(accessKeyId: String? = nil, principalId: String? = nil, userName: String? = nil, userType: String? = nil) {
            self.accessKeyId = accessKeyId
            self.principalId = principalId
            self.userName = userName
            self.userType = userType
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "accessKeyId"
            case principalId = "principalId"
            case userName = "userName"
            case userType = "userType"
        }
    }

    public struct Account: AWSDecodableShape {
        /// Name of the member's Amazon Web Services account.
        public let name: String?
        /// ID of the member's Amazon Web Services account
        public let uid: String?

        @inlinable
        public init(name: String? = nil, uid: String? = nil) {
            self.name = name
            self.uid = uid
        }

        private enum CodingKeys: String, CodingKey {
            case name = "account"
            case uid = "uid"
        }
    }

    public struct AccountDetail: AWSEncodableShape {
        /// The member account ID.
        public let accountId: String?
        /// The email address of the member account.
        public let email: String?

        @inlinable
        public init(accountId: String? = nil, email: String? = nil) {
            self.accountId = accountId
            self.email = email
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.email, name: "email", parent: name, max: 64)
            try self.validate(self.email, name: "email", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case email = "email"
        }
    }

    public struct AccountFreeTrialInfo: AWSDecodableShape {
        /// The account identifier of the GuardDuty member account.
        public let accountId: String?
        /// Describes the data source enabled for the GuardDuty member account.
        public let dataSources: DataSourcesFreeTrial?
        /// A list of features enabled for the GuardDuty account.
        public let features: [FreeTrialFeatureConfigurationResult]?

        @inlinable
        public init(accountId: String? = nil, features: [FreeTrialFeatureConfigurationResult]? = nil) {
            self.accountId = accountId
            self.dataSources = nil
            self.features = features
        }

        @available(*, deprecated, message: "Members dataSources have been deprecated")
        @inlinable
        public init(accountId: String? = nil, dataSources: DataSourcesFreeTrial? = nil, features: [FreeTrialFeatureConfigurationResult]? = nil) {
            self.accountId = accountId
            self.dataSources = dataSources
            self.features = features
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case dataSources = "dataSources"
            case features = "features"
        }
    }

    public struct AccountLevelPermissions: AWSDecodableShape {
        /// Describes the S3 Block Public Access settings of the bucket's parent account.
        public let blockPublicAccess: BlockPublicAccess?

        @inlinable
        public init(blockPublicAccess: BlockPublicAccess? = nil) {
            self.blockPublicAccess = blockPublicAccess
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAccess = "blockPublicAccess"
        }
    }

    public struct AccountStatistics: AWSDecodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountId: String?
        /// The timestamp at which the finding for this account was last generated.
        public let lastGeneratedAt: Date?
        /// The total number of findings associated with an account.
        public let totalFindings: Int?

        @inlinable
        public init(accountId: String? = nil, lastGeneratedAt: Date? = nil, totalFindings: Int? = nil) {
            self.accountId = accountId
            self.lastGeneratedAt = lastGeneratedAt
            self.totalFindings = totalFindings
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case lastGeneratedAt = "lastGeneratedAt"
            case totalFindings = "totalFindings"
        }
    }

    public struct Action: AWSDecodableShape {
        /// The GuardDuty finding activity type.
        public let actionType: String?
        /// Information about the AWS_API_CALL action described in this finding.
        public let awsApiCallAction: AwsApiCallAction?
        /// Information about the DNS_REQUEST action described in this finding.
        public let dnsRequestAction: DnsRequestAction?
        /// Information about the Kubernetes API call action described in this finding.
        public let kubernetesApiCallAction: KubernetesApiCallAction?
        /// Information whether the user has the permission to use a specific Kubernetes API.
        public let kubernetesPermissionCheckedDetails: KubernetesPermissionCheckedDetails?
        /// Information about the role binding that grants the permission defined in a Kubernetes role.
        public let kubernetesRoleBindingDetails: KubernetesRoleBindingDetails?
        /// Information about the Kubernetes role name and role type.
        public let kubernetesRoleDetails: KubernetesRoleDetails?
        /// Information about the NETWORK_CONNECTION action described in this finding.
        public let networkConnectionAction: NetworkConnectionAction?
        /// Information about the PORT_PROBE action described in this finding.
        public let portProbeAction: PortProbeAction?
        /// Information about RDS_LOGIN_ATTEMPT action described in this finding.
        public let rdsLoginAttemptAction: RdsLoginAttemptAction?

        @inlinable
        public init(actionType: String? = nil, awsApiCallAction: AwsApiCallAction? = nil, dnsRequestAction: DnsRequestAction? = nil, kubernetesApiCallAction: KubernetesApiCallAction? = nil, kubernetesPermissionCheckedDetails: KubernetesPermissionCheckedDetails? = nil, kubernetesRoleBindingDetails: KubernetesRoleBindingDetails? = nil, kubernetesRoleDetails: KubernetesRoleDetails? = nil, networkConnectionAction: NetworkConnectionAction? = nil, portProbeAction: PortProbeAction? = nil, rdsLoginAttemptAction: RdsLoginAttemptAction? = nil) {
            self.actionType = actionType
            self.awsApiCallAction = awsApiCallAction
            self.dnsRequestAction = dnsRequestAction
            self.kubernetesApiCallAction = kubernetesApiCallAction
            self.kubernetesPermissionCheckedDetails = kubernetesPermissionCheckedDetails
            self.kubernetesRoleBindingDetails = kubernetesRoleBindingDetails
            self.kubernetesRoleDetails = kubernetesRoleDetails
            self.networkConnectionAction = networkConnectionAction
            self.portProbeAction = portProbeAction
            self.rdsLoginAttemptAction = rdsLoginAttemptAction
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "actionType"
            case awsApiCallAction = "awsApiCallAction"
            case dnsRequestAction = "dnsRequestAction"
            case kubernetesApiCallAction = "kubernetesApiCallAction"
            case kubernetesPermissionCheckedDetails = "kubernetesPermissionCheckedDetails"
            case kubernetesRoleBindingDetails = "kubernetesRoleBindingDetails"
            case kubernetesRoleDetails = "kubernetesRoleDetails"
            case networkConnectionAction = "networkConnectionAction"
            case portProbeAction = "portProbeAction"
            case rdsLoginAttemptAction = "rdsLoginAttemptAction"
        }
    }

    public struct Actor: AWSDecodableShape {
        /// ID of the threat actor.
        public let id: String?
        /// Contains information about the user session where the activity initiated.
        public let session: Session?
        /// Contains information about the user credentials used by the threat actor.
        public let user: User?

        @inlinable
        public init(id: String? = nil, session: Session? = nil, user: User? = nil) {
            self.id = id
            self.session = session
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case session = "session"
            case user = "user"
        }
    }

    public struct AddonDetails: AWSDecodableShape {
        /// Status of the installed EKS add-on.
        public let addonStatus: String?
        /// Version of the installed EKS add-on.
        public let addonVersion: String?

        @inlinable
        public init(addonStatus: String? = nil, addonVersion: String? = nil) {
            self.addonStatus = addonStatus
            self.addonVersion = addonVersion
        }

        private enum CodingKeys: String, CodingKey {
            case addonStatus = "addonStatus"
            case addonVersion = "addonVersion"
        }
    }

    public struct AdminAccount: AWSDecodableShape {
        /// The Amazon Web Services account ID for the account.
        public let adminAccountId: String?
        /// Indicates whether the account is enabled as the delegated administrator.
        public let adminStatus: AdminStatus?

        @inlinable
        public init(adminAccountId: String? = nil, adminStatus: AdminStatus? = nil) {
            self.adminAccountId = adminAccountId
            self.adminStatus = adminStatus
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "adminAccountId"
            case adminStatus = "adminStatus"
        }
    }

    public struct Administrator: AWSDecodableShape {
        /// The ID of the account used as the administrator account.
        public let accountId: String?
        /// The value that is used to validate the administrator account to the member account.
        public let invitationId: String?
        /// The timestamp when the invitation was sent.
        public let invitedAt: String?
        /// The status of the relationship between the administrator and member accounts.
        public let relationshipStatus: String?

        @inlinable
        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: String? = nil, relationshipStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case invitationId = "invitationId"
            case invitedAt = "invitedAt"
            case relationshipStatus = "relationshipStatus"
        }
    }

    public struct AgentDetails: AWSDecodableShape {
        /// Version of the installed GuardDuty security agent.
        public let version: String?

        @inlinable
        public init(version: String? = nil) {
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case version = "version"
        }
    }

    public struct Anomaly: AWSDecodableShape {
        /// Information about the types of profiles.
        public let profiles: [String: [String: [AnomalyObject]]]?
        /// Information about the behavior of the anomalies.
        public let unusual: AnomalyUnusual?

        @inlinable
        public init(profiles: [String: [String: [AnomalyObject]]]? = nil, unusual: AnomalyUnusual? = nil) {
            self.profiles = profiles
            self.unusual = unusual
        }

        private enum CodingKeys: String, CodingKey {
            case profiles = "profiles"
            case unusual = "unusual"
        }
    }

    public struct AnomalyObject: AWSDecodableShape {
        /// The recorded value.
        public let observations: Observations?
        /// The frequency of the anomaly.
        public let profileSubtype: ProfileSubtype?
        /// The type of behavior of the profile.
        public let profileType: ProfileType?

        @inlinable
        public init(observations: Observations? = nil, profileSubtype: ProfileSubtype? = nil, profileType: ProfileType? = nil) {
            self.observations = observations
            self.profileSubtype = profileSubtype
            self.profileType = profileType
        }

        private enum CodingKeys: String, CodingKey {
            case observations = "observations"
            case profileSubtype = "profileSubtype"
            case profileType = "profileType"
        }
    }

    public struct AnomalyUnusual: AWSDecodableShape {
        /// The behavior of the anomalous activity that caused GuardDuty to  generate the finding.
        public let behavior: [String: [String: AnomalyObject]]?

        @inlinable
        public init(behavior: [String: [String: AnomalyObject]]? = nil) {
            self.behavior = behavior
        }

        private enum CodingKeys: String, CodingKey {
            case behavior = "behavior"
        }
    }

    public struct ArchiveFindingsRequest: AWSEncodableShape {
        /// The ID of the detector that specifies the GuardDuty service whose findings you want to archive. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The IDs of the findings that you want to archive.
        public let findingIds: [String]?

        @inlinable
        public init(detectorId: String, findingIds: [String]? = nil) {
            self.detectorId = detectorId
            self.findingIds = findingIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.findingIds, forKey: .findingIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.findingIds?.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try self.validate(self.findingIds, name: "findingIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds = "findingIds"
        }
    }

    public struct ArchiveFindingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AutonomousSystem: AWSDecodableShape {
        /// Name associated with the Autonomous System (AS).
        public let name: String?
        /// The unique number that identifies the Autonomous System (AS).
        public let number: Int?

        @inlinable
        public init(name: String? = nil, number: Int? = nil) {
            self.name = name
            self.number = number
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case number = "number"
        }
    }

    public struct AwsApiCallAction: AWSDecodableShape {
        /// The details of the Amazon Web Services account that made the API call. This field identifies the resources that were affected by this API call.
        public let affectedResources: [String: String]?
        /// The Amazon Web Services API name.
        public let api: String?
        /// The Amazon Web Services API caller type.
        public let callerType: String?
        /// The domain information for the Amazon Web Services API call.
        public let domainDetails: DomainDetails?
        /// The error code of the failed Amazon Web Services API action.
        public let errorCode: String?
        /// The details of the Amazon Web Services account that made the API call. This field appears if the call was made from outside your account.
        public let remoteAccountDetails: RemoteAccountDetails?
        /// The remote IP information of the connection that initiated the Amazon Web Services API call.
        public let remoteIpDetails: RemoteIpDetails?
        /// The Amazon Web Services service name whose API was invoked.
        public let serviceName: String?
        /// The agent through which the API request was made.
        public let userAgent: String?

        @inlinable
        public init(affectedResources: [String: String]? = nil, api: String? = nil, callerType: String? = nil, domainDetails: DomainDetails? = nil, errorCode: String? = nil, remoteAccountDetails: RemoteAccountDetails? = nil, remoteIpDetails: RemoteIpDetails? = nil, serviceName: String? = nil, userAgent: String? = nil) {
            self.affectedResources = affectedResources
            self.api = api
            self.callerType = callerType
            self.domainDetails = domainDetails
            self.errorCode = errorCode
            self.remoteAccountDetails = remoteAccountDetails
            self.remoteIpDetails = remoteIpDetails
            self.serviceName = serviceName
            self.userAgent = userAgent
        }

        private enum CodingKeys: String, CodingKey {
            case affectedResources = "affectedResources"
            case api = "api"
            case callerType = "callerType"
            case domainDetails = "domainDetails"
            case errorCode = "errorCode"
            case remoteAccountDetails = "remoteAccountDetails"
            case remoteIpDetails = "remoteIpDetails"
            case serviceName = "serviceName"
            case userAgent = "userAgent"
        }
    }

    public struct BadRequestException: AWSErrorShape {
        /// The error message.
        public let message: String?
        /// The error type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "__type"
        }
    }

    public struct BlockPublicAccess: AWSDecodableShape {
        /// Indicates if S3 Block Public Access is set to BlockPublicAcls.
        public let blockPublicAcls: Bool?
        /// Indicates if S3 Block Public Access is set to BlockPublicPolicy.
        public let blockPublicPolicy: Bool?
        /// Indicates if S3 Block Public Access is set to IgnorePublicAcls.
        public let ignorePublicAcls: Bool?
        /// Indicates if S3 Block Public Access is set to RestrictPublicBuckets.
        public let restrictPublicBuckets: Bool?

        @inlinable
        public init(blockPublicAcls: Bool? = nil, blockPublicPolicy: Bool? = nil, ignorePublicAcls: Bool? = nil, restrictPublicBuckets: Bool? = nil) {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAcls = "blockPublicAcls"
            case blockPublicPolicy = "blockPublicPolicy"
            case ignorePublicAcls = "ignorePublicAcls"
            case restrictPublicBuckets = "restrictPublicBuckets"
        }
    }

    public struct BucketLevelPermissions: AWSDecodableShape {
        /// Contains information on how Access Control Policies are applied to the bucket.
        public let accessControlList: AccessControlList?
        /// Contains information on which account level S3 Block Public Access settings are applied to the S3 bucket.
        public let blockPublicAccess: BlockPublicAccess?
        /// Contains information on the bucket policies for the S3 bucket.
        public let bucketPolicy: BucketPolicy?

        @inlinable
        public init(accessControlList: AccessControlList? = nil, blockPublicAccess: BlockPublicAccess? = nil, bucketPolicy: BucketPolicy? = nil) {
            self.accessControlList = accessControlList
            self.blockPublicAccess = blockPublicAccess
            self.bucketPolicy = bucketPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlList = "accessControlList"
            case blockPublicAccess = "blockPublicAccess"
            case bucketPolicy = "bucketPolicy"
        }
    }

    public struct BucketPolicy: AWSDecodableShape {
        /// A value that indicates whether public read access for the bucket is enabled through a bucket policy.
        public let allowsPublicReadAccess: Bool?
        /// A value that indicates whether public write access for the bucket is enabled through a bucket policy.
        public let allowsPublicWriteAccess: Bool?

        @inlinable
        public init(allowsPublicReadAccess: Bool? = nil, allowsPublicWriteAccess: Bool? = nil) {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }

        private enum CodingKeys: String, CodingKey {
            case allowsPublicReadAccess = "allowsPublicReadAccess"
            case allowsPublicWriteAccess = "allowsPublicWriteAccess"
        }
    }

    public struct City: AWSDecodableShape {
        /// The city name of the remote IP address.
        public let cityName: String?

        @inlinable
        public init(cityName: String? = nil) {
            self.cityName = cityName
        }

        private enum CodingKeys: String, CodingKey {
            case cityName = "cityName"
        }
    }

    public struct CloudTrailConfigurationResult: AWSDecodableShape {
        /// Describes whether CloudTrail is enabled as a data source for the detector.
        public let status: DataSourceStatus?

        @inlinable
        public init(status: DataSourceStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct Condition: AWSEncodableShape & AWSDecodableShape {
        /// Represents the equal condition to be applied to a single field when querying for findings.
        public let eq: [String]?
        /// Represents an equal condition to be applied to a single field when querying for findings.
        public let equals: [String]?
        /// Represents a greater than condition to be applied to a single field when querying for findings.
        public let greaterThan: Int64?
        /// Represents a greater than or equal condition to be applied to a single field when querying for findings.
        public let greaterThanOrEqual: Int64?
        /// Represents a greater than condition to be applied to a single field when querying for findings.
        public let gt: Int?
        /// Represents a greater than or equal condition to be applied to a single field when querying for findings.
        public let gte: Int?
        /// Represents a less than condition to be applied to a single field when querying for findings.
        public let lessThan: Int64?
        /// Represents a less than or equal condition to be applied to a single field when querying for findings.
        public let lessThanOrEqual: Int64?
        /// Represents a less than condition to be applied to a single field when querying for findings.
        public let lt: Int?
        /// Represents a less than or equal condition to be applied to a single field when querying for findings.
        public let lte: Int?
        /// Represents the not equal condition to be applied to a single field when querying for findings.
        public let neq: [String]?
        /// Represents a not equal condition to be applied to a single field when querying for findings.
        public let notEquals: [String]?

        @inlinable
        public init(equals: [String]? = nil, greaterThan: Int64? = nil, greaterThanOrEqual: Int64? = nil, lessThan: Int64? = nil, lessThanOrEqual: Int64? = nil, notEquals: [String]? = nil) {
            self.eq = nil
            self.equals = equals
            self.greaterThan = greaterThan
            self.greaterThanOrEqual = greaterThanOrEqual
            self.gt = nil
            self.gte = nil
            self.lessThan = lessThan
            self.lessThanOrEqual = lessThanOrEqual
            self.lt = nil
            self.lte = nil
            self.neq = nil
            self.notEquals = notEquals
        }

        @available(*, deprecated, message: "Members eq, gt, gte, lt, lte, neq have been deprecated")
        @inlinable
        public init(eq: [String]? = nil, equals: [String]? = nil, greaterThan: Int64? = nil, greaterThanOrEqual: Int64? = nil, gt: Int? = nil, gte: Int? = nil, lessThan: Int64? = nil, lessThanOrEqual: Int64? = nil, lt: Int? = nil, lte: Int? = nil, neq: [String]? = nil, notEquals: [String]? = nil) {
            self.eq = eq
            self.equals = equals
            self.greaterThan = greaterThan
            self.greaterThanOrEqual = greaterThanOrEqual
            self.gt = gt
            self.gte = gte
            self.lessThan = lessThan
            self.lessThanOrEqual = lessThanOrEqual
            self.lt = lt
            self.lte = lte
            self.neq = neq
            self.notEquals = notEquals
        }

        private enum CodingKeys: String, CodingKey {
            case eq = "eq"
            case equals = "equals"
            case greaterThan = "greaterThan"
            case greaterThanOrEqual = "greaterThanOrEqual"
            case gt = "gt"
            case gte = "gte"
            case lessThan = "lessThan"
            case lessThanOrEqual = "lessThanOrEqual"
            case lt = "lt"
            case lte = "lte"
            case neq = "neq"
            case notEquals = "notEquals"
        }
    }

    public struct ConflictException: AWSErrorShape {
        /// The error message.
        public let message: String?
        /// The error type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "__type"
        }
    }

    public struct Container: AWSDecodableShape {
        /// The container runtime (such as, Docker or containerd) used to run the container.
        public let containerRuntime: String?
        /// Container ID.
        public let id: String?
        /// Container image.
        public let image: String?
        /// Part of the image name before the last slash. For example, imagePrefix for public.ecr.aws/amazonlinux/amazonlinux:latest would be public.ecr.aws/amazonlinux. If the image name is relative and does not have a slash, this field is empty.
        public let imagePrefix: String?
        /// Container name.
        public let name: String?
        /// Container security context.
        public let securityContext: SecurityContext?
        /// Container volume mounts.
        public let volumeMounts: [VolumeMount]?

        @inlinable
        public init(containerRuntime: String? = nil, id: String? = nil, image: String? = nil, imagePrefix: String? = nil, name: String? = nil, securityContext: SecurityContext? = nil, volumeMounts: [VolumeMount]? = nil) {
            self.containerRuntime = containerRuntime
            self.id = id
            self.image = image
            self.imagePrefix = imagePrefix
            self.name = name
            self.securityContext = securityContext
            self.volumeMounts = volumeMounts
        }

        private enum CodingKeys: String, CodingKey {
            case containerRuntime = "containerRuntime"
            case id = "id"
            case image = "image"
            case imagePrefix = "imagePrefix"
            case name = "name"
            case securityContext = "securityContext"
            case volumeMounts = "volumeMounts"
        }
    }

    public struct ContainerInstanceDetails: AWSDecodableShape {
        /// Represents total number of nodes in the Amazon ECS cluster.
        public let compatibleContainerInstances: Int64?
        /// Represents the nodes in the Amazon ECS cluster that has a HEALTHY coverage status.
        public let coveredContainerInstances: Int64?

        @inlinable
        public init(compatibleContainerInstances: Int64? = nil, coveredContainerInstances: Int64? = nil) {
            self.compatibleContainerInstances = compatibleContainerInstances
            self.coveredContainerInstances = coveredContainerInstances
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleContainerInstances = "compatibleContainerInstances"
            case coveredContainerInstances = "coveredContainerInstances"
        }
    }

    public struct Country: AWSDecodableShape {
        /// The country code of the remote IP address.
        public let countryCode: String?
        /// The country name of the remote IP address.
        public let countryName: String?

        @inlinable
        public init(countryCode: String? = nil, countryName: String? = nil) {
            self.countryCode = countryCode
            self.countryName = countryName
        }

        private enum CodingKeys: String, CodingKey {
            case countryCode = "countryCode"
            case countryName = "countryName"
        }
    }

    public struct CoverageEc2InstanceDetails: AWSDecodableShape {
        /// Information about the installed security agent.
        public let agentDetails: AgentDetails?
        /// The cluster ARN of the Amazon ECS cluster running on  the Amazon EC2 instance.
        public let clusterArn: String?
        /// The Amazon EC2 instance ID.
        public let instanceId: String?
        /// The instance type of the Amazon EC2 instance.
        public let instanceType: String?
        /// Indicates how the GuardDuty security agent is managed for this resource.    AUTO_MANAGED indicates that GuardDuty deploys and manages updates for this resource.    MANUAL indicates that you are responsible to deploy, update, and manage the GuardDuty  security agent updates for this resource.    The DISABLED status doesn't apply to Amazon  EC2 instances and Amazon EKS clusters.
        public let managementType: ManagementType?

        @inlinable
        public init(agentDetails: AgentDetails? = nil, clusterArn: String? = nil, instanceId: String? = nil, instanceType: String? = nil, managementType: ManagementType? = nil) {
            self.agentDetails = agentDetails
            self.clusterArn = clusterArn
            self.instanceId = instanceId
            self.instanceType = instanceType
            self.managementType = managementType
        }

        private enum CodingKeys: String, CodingKey {
            case agentDetails = "agentDetails"
            case clusterArn = "clusterArn"
            case instanceId = "instanceId"
            case instanceType = "instanceType"
            case managementType = "managementType"
        }
    }

    public struct CoverageEcsClusterDetails: AWSDecodableShape {
        /// The name of the Amazon ECS cluster.
        public let clusterName: String?
        /// Information about the Amazon ECS container running on Amazon EC2  instance.
        public let containerInstanceDetails: ContainerInstanceDetails?
        /// Information about the Fargate details associated with the Amazon  ECS cluster.
        public let fargateDetails: FargateDetails?

        @inlinable
        public init(clusterName: String? = nil, containerInstanceDetails: ContainerInstanceDetails? = nil, fargateDetails: FargateDetails? = nil) {
            self.clusterName = clusterName
            self.containerInstanceDetails = containerInstanceDetails
            self.fargateDetails = fargateDetails
        }

        private enum CodingKeys: String, CodingKey {
            case clusterName = "clusterName"
            case containerInstanceDetails = "containerInstanceDetails"
            case fargateDetails = "fargateDetails"
        }
    }

    public struct CoverageEksClusterDetails: AWSDecodableShape {
        /// Information about the installed EKS add-on.
        public let addonDetails: AddonDetails?
        /// Name of the EKS cluster.
        public let clusterName: String?
        /// Represents all the nodes within the EKS cluster in your account.
        public let compatibleNodes: Int64?
        /// Represents the nodes within the EKS cluster that have a HEALTHY coverage status.
        public let coveredNodes: Int64?
        /// Indicates how the Amazon EKS add-on GuardDuty agent is managed for this EKS cluster.  AUTO_MANAGED indicates GuardDuty deploys and manages updates for this resource.  MANUAL indicates that you are responsible to deploy, update, and manage  the Amazon EKS add-on GuardDuty agent for this resource.
        public let managementType: ManagementType?

        @inlinable
        public init(addonDetails: AddonDetails? = nil, clusterName: String? = nil, compatibleNodes: Int64? = nil, coveredNodes: Int64? = nil, managementType: ManagementType? = nil) {
            self.addonDetails = addonDetails
            self.clusterName = clusterName
            self.compatibleNodes = compatibleNodes
            self.coveredNodes = coveredNodes
            self.managementType = managementType
        }

        private enum CodingKeys: String, CodingKey {
            case addonDetails = "addonDetails"
            case clusterName = "clusterName"
            case compatibleNodes = "compatibleNodes"
            case coveredNodes = "coveredNodes"
            case managementType = "managementType"
        }
    }

    public struct CoverageFilterCondition: AWSEncodableShape {
        /// Represents an equal condition that is applied to a single field while retrieving the coverage details.
        public let equals: [String]?
        /// Represents a not equal condition that is applied to a single field while retrieving the coverage details.
        public let notEquals: [String]?

        @inlinable
        public init(equals: [String]? = nil, notEquals: [String]? = nil) {
            self.equals = equals
            self.notEquals = notEquals
        }

        private enum CodingKeys: String, CodingKey {
            case equals = "equals"
            case notEquals = "notEquals"
        }
    }

    public struct CoverageFilterCriteria: AWSEncodableShape {
        /// Represents a condition that when matched will be added to the response of the operation.
        public let filterCriterion: [CoverageFilterCriterion]?

        @inlinable
        public init(filterCriterion: [CoverageFilterCriterion]? = nil) {
            self.filterCriterion = filterCriterion
        }

        public func validate(name: String) throws {
            try self.validate(self.filterCriterion, name: "filterCriterion", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriterion = "filterCriterion"
        }
    }

    public struct CoverageFilterCriterion: AWSEncodableShape {
        /// An enum value representing possible filter fields.  Replace the enum value CLUSTER_NAME with EKS_CLUSTER_NAME. CLUSTER_NAME has been deprecated.
        public let criterionKey: CoverageFilterCriterionKey?
        /// Contains information about the condition.
        public let filterCondition: CoverageFilterCondition?

        @inlinable
        public init(criterionKey: CoverageFilterCriterionKey? = nil, filterCondition: CoverageFilterCondition? = nil) {
            self.criterionKey = criterionKey
            self.filterCondition = filterCondition
        }

        private enum CodingKeys: String, CodingKey {
            case criterionKey = "criterionKey"
            case filterCondition = "filterCondition"
        }
    }

    public struct CoverageResource: AWSDecodableShape {
        /// The unique ID of the Amazon Web Services account.
        public let accountId: String?
        /// Represents the status of the EKS cluster coverage.
        public let coverageStatus: CoverageStatus?
        /// The unique ID of the GuardDuty detector associated with the resource.
        public let detectorId: String?
        /// Represents the reason why a coverage status was UNHEALTHY for the EKS cluster.
        public let issue: String?
        /// Information about the resource for which the coverage statistics are retrieved.
        public let resourceDetails: CoverageResourceDetails?
        /// The unique ID of the resource.
        public let resourceId: String?
        /// The timestamp at which the coverage details for the resource were last updated. This is in UTC format.
        public let updatedAt: Date?

        @inlinable
        public init(accountId: String? = nil, coverageStatus: CoverageStatus? = nil, detectorId: String? = nil, issue: String? = nil, resourceDetails: CoverageResourceDetails? = nil, resourceId: String? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.coverageStatus = coverageStatus
            self.detectorId = detectorId
            self.issue = issue
            self.resourceDetails = resourceDetails
            self.resourceId = resourceId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case coverageStatus = "coverageStatus"
            case detectorId = "detectorId"
            case issue = "issue"
            case resourceDetails = "resourceDetails"
            case resourceId = "resourceId"
            case updatedAt = "updatedAt"
        }
    }

    public struct CoverageResourceDetails: AWSDecodableShape {
        /// Information about the Amazon EC2 instance assessed  for runtime coverage.
        public let ec2InstanceDetails: CoverageEc2InstanceDetails?
        /// Information about the Amazon ECS cluster that is assessed for  runtime coverage.
        public let ecsClusterDetails: CoverageEcsClusterDetails?
        /// EKS cluster details involved in the coverage statistics.
        public let eksClusterDetails: CoverageEksClusterDetails?
        /// The type of Amazon Web Services resource.
        public let resourceType: ResourceType?

        @inlinable
        public init(ec2InstanceDetails: CoverageEc2InstanceDetails? = nil, ecsClusterDetails: CoverageEcsClusterDetails? = nil, eksClusterDetails: CoverageEksClusterDetails? = nil, resourceType: ResourceType? = nil) {
            self.ec2InstanceDetails = ec2InstanceDetails
            self.ecsClusterDetails = ecsClusterDetails
            self.eksClusterDetails = eksClusterDetails
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceDetails = "ec2InstanceDetails"
            case ecsClusterDetails = "ecsClusterDetails"
            case eksClusterDetails = "eksClusterDetails"
            case resourceType = "resourceType"
        }
    }

    public struct CoverageSortCriteria: AWSEncodableShape {
        /// Represents the field name used to sort the coverage details.  Replace the enum value CLUSTER_NAME with EKS_CLUSTER_NAME. CLUSTER_NAME has been deprecated.
        public let attributeName: CoverageSortKey?
        /// The order in which the sorted findings are to be displayed.
        public let orderBy: OrderBy?

        @inlinable
        public init(attributeName: CoverageSortKey? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "attributeName"
            case orderBy = "orderBy"
        }
    }

    public struct CoverageStatistics: AWSDecodableShape {
        /// Represents coverage statistics for EKS clusters aggregated by coverage status.
        public let countByCoverageStatus: [CoverageStatus: Int64]?
        /// Represents coverage statistics for EKS clusters aggregated by resource type.
        public let countByResourceType: [ResourceType: Int64]?

        @inlinable
        public init(countByCoverageStatus: [CoverageStatus: Int64]? = nil, countByResourceType: [ResourceType: Int64]? = nil) {
            self.countByCoverageStatus = countByCoverageStatus
            self.countByResourceType = countByResourceType
        }

        private enum CodingKeys: String, CodingKey {
            case countByCoverageStatus = "countByCoverageStatus"
            case countByResourceType = "countByResourceType"
        }
    }

    public struct CreateDetectorRequest: AWSEncodableShape {
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// Describes which data sources will be enabled for the detector. There might be regional differences because some data sources might not be  available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more  information, see Regions and endpoints.
        public let dataSources: DataSourceConfigurations?
        /// A Boolean value that specifies whether the detector is to be enabled.
        public let enable: Bool?
        /// A list of features that will be configured for the detector.
        public let features: [DetectorFeatureConfiguration]?
        /// A value that specifies how frequently updated findings are exported.
        public let findingPublishingFrequency: FindingPublishingFrequency?
        /// The tags to be added to a new detector resource.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateDetectorRequest.idempotencyToken(), enable: Bool? = nil, features: [DetectorFeatureConfiguration]? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.dataSources = nil
            self.enable = enable
            self.features = features
            self.findingPublishingFrequency = findingPublishingFrequency
            self.tags = tags
        }

        @available(*, deprecated, message: "Members dataSources have been deprecated")
        @inlinable
        public init(clientToken: String? = CreateDetectorRequest.idempotencyToken(), dataSources: DataSourceConfigurations? = nil, enable: Bool? = nil, features: [DetectorFeatureConfiguration]? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.dataSources = dataSources
            self.enable = enable
            self.features = features
            self.findingPublishingFrequency = findingPublishingFrequency
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dataSources = "dataSources"
            case enable = "enable"
            case features = "features"
            case findingPublishingFrequency = "findingPublishingFrequency"
            case tags = "tags"
        }
    }

    public struct CreateDetectorResponse: AWSDecodableShape {
        /// The unique ID of the created detector.
        public let detectorId: String?
        /// Specifies the data sources that couldn't be enabled when GuardDuty was enabled for the first time.
        public let unprocessedDataSources: UnprocessedDataSourcesResult?

        @inlinable
        public init(detectorId: String? = nil, unprocessedDataSources: UnprocessedDataSourcesResult? = nil) {
            self.detectorId = detectorId
            self.unprocessedDataSources = unprocessedDataSources
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case unprocessedDataSources = "unprocessedDataSources"
        }
    }

    public struct CreateFilterRequest: AWSEncodableShape {
        /// Specifies the action that is to be applied to the findings that match the filter.
        public let action: FilterAction?
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// The description of the filter. Valid characters include alphanumeric characters, and special characters such as hyphen, period, colon, underscore, parentheses ({ }, [ ], and ( )), forward slash, horizontal tab, vertical tab, newline, form feed, return, and whitespace.
        public let description: String?
        /// The detector ID associated with the GuardDuty account for which you want to create a filter. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// Represents the criteria to be used in the filter for querying findings. You can only use the following attributes to query findings:   accountId   id   region   severity To filter on the basis of severity, the API and CLI use the following input list for the FindingCriteria condition:    Low: ["1", "2", "3"]     Medium: ["4", "5", "6"]     High: ["7", "8"]     Critical: ["9", "10"]    For more information, see Findings severity levels in the Amazon GuardDuty User Guide.   type   updatedAt Type: ISO 8601 string format: YYYY-MM-DDTHH:MM:SS.SSSZ or YYYY-MM-DDTHH:MM:SSZ depending on whether the value contains milliseconds.   resource.accessKeyDetails.accessKeyId   resource.accessKeyDetails.principalId   resource.accessKeyDetails.userName   resource.accessKeyDetails.userType   resource.instanceDetails.iamInstanceProfile.id   resource.instanceDetails.imageId   resource.instanceDetails.instanceId   resource.instanceDetails.tags.key   resource.instanceDetails.tags.value   resource.instanceDetails.networkInterfaces.ipv6Addresses   resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress   resource.instanceDetails.networkInterfaces.publicDnsName   resource.instanceDetails.networkInterfaces.publicIp   resource.instanceDetails.networkInterfaces.securityGroups.groupId   resource.instanceDetails.networkInterfaces.securityGroups.groupName   resource.instanceDetails.networkInterfaces.subnetId   resource.instanceDetails.networkInterfaces.vpcId   resource.instanceDetails.outpostArn   resource.resourceType   resource.s3BucketDetails.publicAccess.effectivePermissions   resource.s3BucketDetails.name   resource.s3BucketDetails.tags.key   resource.s3BucketDetails.tags.value   resource.s3BucketDetails.type   service.action.actionType   service.action.awsApiCallAction.api   service.action.awsApiCallAction.callerType   service.action.awsApiCallAction.errorCode   service.action.awsApiCallAction.remoteIpDetails.city.cityName   service.action.awsApiCallAction.remoteIpDetails.country.countryName   service.action.awsApiCallAction.remoteIpDetails.ipAddressV4   service.action.awsApiCallAction.remoteIpDetails.ipAddressV6   service.action.awsApiCallAction.remoteIpDetails.organization.asn   service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg   service.action.awsApiCallAction.serviceName   service.action.dnsRequestAction.domain   service.action.dnsRequestAction.domainWithSuffix   service.action.networkConnectionAction.blocked   service.action.networkConnectionAction.connectionDirection   service.action.networkConnectionAction.localPortDetails.port   service.action.networkConnectionAction.protocol   service.action.networkConnectionAction.remoteIpDetails.city.cityName   service.action.networkConnectionAction.remoteIpDetails.country.countryName   service.action.networkConnectionAction.remoteIpDetails.ipAddressV4   service.action.networkConnectionAction.remoteIpDetails.ipAddressV6   service.action.networkConnectionAction.remoteIpDetails.organization.asn   service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg   service.action.networkConnectionAction.remotePortDetails.port   service.action.awsApiCallAction.remoteAccountDetails.affiliated   service.action.kubernetesApiCallAction.remoteIpDetails.ipAddressV4   service.action.kubernetesApiCallAction.remoteIpDetails.ipAddressV6   service.action.kubernetesApiCallAction.namespace   service.action.kubernetesApiCallAction.remoteIpDetails.organization.asn   service.action.kubernetesApiCallAction.requestUri   service.action.kubernetesApiCallAction.statusCode   service.action.networkConnectionAction.localIpDetails.ipAddressV4   service.action.networkConnectionAction.localIpDetails.ipAddressV6   service.action.networkConnectionAction.protocol   service.action.awsApiCallAction.serviceName   service.action.awsApiCallAction.remoteAccountDetails.accountId   service.additionalInfo.threatListName   service.resourceRole   resource.eksClusterDetails.name   resource.kubernetesDetails.kubernetesWorkloadDetails.name   resource.kubernetesDetails.kubernetesWorkloadDetails.namespace   resource.kubernetesDetails.kubernetesUserDetails.username   resource.kubernetesDetails.kubernetesWorkloadDetails.containers.image   resource.kubernetesDetails.kubernetesWorkloadDetails.containers.imagePrefix   service.ebsVolumeScanDetails.scanId   service.ebsVolumeScanDetails.scanDetections.threatDetectedByName.threatNames.name   service.ebsVolumeScanDetails.scanDetections.threatDetectedByName.threatNames.severity   service.ebsVolumeScanDetails.scanDetections.threatDetectedByName.threatNames.filePaths.hash   resource.ecsClusterDetails.name   resource.ecsClusterDetails.taskDetails.containers.image   resource.ecsClusterDetails.taskDetails.definitionArn   resource.containerDetails.image   resource.rdsDbInstanceDetails.dbInstanceIdentifier   resource.rdsDbInstanceDetails.dbClusterIdentifier   resource.rdsDbInstanceDetails.engine   resource.rdsDbUserDetails.user   resource.rdsDbInstanceDetails.tags.key   resource.rdsDbInstanceDetails.tags.value   service.runtimeDetails.process.executableSha256   service.runtimeDetails.process.name   service.runtimeDetails.process.executablePath   resource.lambdaDetails.functionName   resource.lambdaDetails.functionArn   resource.lambdaDetails.tags.key   resource.lambdaDetails.tags.value
        public let findingCriteria: FindingCriteria?
        /// The name of the filter. Valid characters include period (.), underscore (_), dash (-), and alphanumeric characters. A whitespace is considered to be an invalid character.
        public let name: String?
        /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
        public let rank: Int?
        /// The tags to be added to a new filter resource.
        public let tags: [String: String]?

        @inlinable
        public init(action: FilterAction? = nil, clientToken: String? = CreateFilterRequest.idempotencyToken(), description: String? = nil, detectorId: String, findingCriteria: FindingCriteria? = nil, name: String? = nil, rank: Int? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.clientToken = clientToken
            self.description = description
            self.detectorId = detectorId
            self.findingCriteria = findingCriteria
            self.name = name
            self.rank = rank
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.action, forKey: .action)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.findingCriteria, forKey: .findingCriteria)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.rank, forKey: .rank)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.rank, name: "rank", parent: name, max: 100)
            try self.validate(self.rank, name: "rank", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case clientToken = "clientToken"
            case description = "description"
            case findingCriteria = "findingCriteria"
            case name = "name"
            case rank = "rank"
            case tags = "tags"
        }
    }

    public struct CreateFilterResponse: AWSDecodableShape {
        /// The name of the successfully created filter.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct CreateIPSetRequest: AWSEncodableShape {
        /// A Boolean value that indicates whether GuardDuty is to start using the uploaded IPSet.
        public let activate: Bool?
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// The unique ID of the detector of the GuardDuty account for which you want to create an IPSet. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The format of the file that contains the IPSet.
        public let format: IpSetFormat?
        /// The URI of the file that contains the IPSet.
        public let location: String?
        /// The user-friendly name to identify the IPSet. Allowed characters are alphanumeric, whitespace, dash (-), and underscores (_).
        public let name: String?
        /// The tags to be added to a new IP set resource.
        public let tags: [String: String]?

        @inlinable
        public init(activate: Bool? = nil, clientToken: String? = CreateIPSetRequest.idempotencyToken(), detectorId: String, format: IpSetFormat? = nil, location: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.activate = activate
            self.clientToken = clientToken
            self.detectorId = detectorId
            self.format = format
            self.location = location
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.activate, forKey: .activate)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.format, forKey: .format)
            try container.encodeIfPresent(self.location, forKey: .location)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.location, name: "location", parent: name, max: 300)
            try self.validate(self.location, name: "location", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activate = "activate"
            case clientToken = "clientToken"
            case format = "format"
            case location = "location"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateIPSetResponse: AWSDecodableShape {
        /// The ID of the IPSet resource.
        public let ipSetId: String?

        @inlinable
        public init(ipSetId: String? = nil) {
            self.ipSetId = ipSetId
        }

        private enum CodingKeys: String, CodingKey {
            case ipSetId = "ipSetId"
        }
    }

    public struct CreateMalwareProtectionPlanRequest: AWSEncodableShape {
        /// Information about whether the tags will be added to the S3 object after scanning.
        public let actions: MalwareProtectionPlanActions?
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// Information about the protected resource that is associated with the created  Malware Protection plan. Presently, S3Bucket is the only supported  protected resource.
        public let protectedResource: CreateProtectedResource?
        /// Amazon Resource Name (ARN) of the IAM role that has the permissions to scan and add tags to the associated protected resource.
        public let role: String?
        /// Tags added to the Malware Protection plan resource.
        public let tags: [String: String]?

        @inlinable
        public init(actions: MalwareProtectionPlanActions? = nil, clientToken: String? = CreateMalwareProtectionPlanRequest.idempotencyToken(), protectedResource: CreateProtectedResource? = nil, role: String? = nil, tags: [String: String]? = nil) {
            self.actions = actions
            self.clientToken = clientToken
            self.protectedResource = protectedResource
            self.role = role
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.protectedResource?.validate(name: "\(name).protectedResource")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case clientToken = "clientToken"
            case protectedResource = "protectedResource"
            case role = "role"
            case tags = "tags"
        }
    }

    public struct CreateMalwareProtectionPlanResponse: AWSDecodableShape {
        /// A unique identifier associated with the Malware Protection plan resource.
        public let malwareProtectionPlanId: String?

        @inlinable
        public init(malwareProtectionPlanId: String? = nil) {
            self.malwareProtectionPlanId = malwareProtectionPlanId
        }

        private enum CodingKeys: String, CodingKey {
            case malwareProtectionPlanId = "malwareProtectionPlanId"
        }
    }

    public struct CreateMembersRequest: AWSEncodableShape {
        /// A list of account ID and email address pairs of the accounts that you want to associate with the GuardDuty administrator account.
        public let accountDetails: [AccountDetail]?
        /// The unique ID of the detector of the GuardDuty account for which you want to associate member accounts. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(accountDetails: [AccountDetail]? = nil, detectorId: String) {
            self.accountDetails = accountDetails
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountDetails, forKey: .accountDetails)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.accountDetails?.forEach {
                try $0.validate(name: "\(name).accountDetails[]")
            }
            try self.validate(self.accountDetails, name: "accountDetails", parent: name, max: 50)
            try self.validate(self.accountDetails, name: "accountDetails", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountDetails = "accountDetails"
        }
    }

    public struct CreateMembersResponse: AWSDecodableShape {
        /// A list of objects that include the accountIds of the unprocessed accounts and a result string that explains why each was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct CreateProtectedResource: AWSEncodableShape & AWSDecodableShape {
        /// Information about the protected S3 bucket resource.
        public let s3Bucket: CreateS3BucketResource?

        @inlinable
        public init(s3Bucket: CreateS3BucketResource? = nil) {
            self.s3Bucket = s3Bucket
        }

        public func validate(name: String) throws {
            try self.s3Bucket?.validate(name: "\(name).s3Bucket")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
        }
    }

    public struct CreatePublishingDestinationRequest: AWSEncodableShape {
        /// The idempotency token for the request.
        public let clientToken: String?
        /// The properties of the publishing destination, including the ARNs for the destination and the KMS key used for encryption.
        public let destinationProperties: DestinationProperties?
        /// The type of resource for the publishing destination. Currently only Amazon S3 buckets are supported.
        public let destinationType: DestinationType?
        /// The ID of the GuardDuty detector associated with the publishing destination. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(clientToken: String? = CreatePublishingDestinationRequest.idempotencyToken(), destinationProperties: DestinationProperties? = nil, destinationType: DestinationType? = nil, detectorId: String) {
            self.clientToken = clientToken
            self.destinationProperties = destinationProperties
            self.destinationType = destinationType
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.destinationProperties, forKey: .destinationProperties)
            try container.encodeIfPresent(self.destinationType, forKey: .destinationType)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case destinationProperties = "destinationProperties"
            case destinationType = "destinationType"
        }
    }

    public struct CreatePublishingDestinationResponse: AWSDecodableShape {
        /// The ID of the publishing destination that is created.
        public let destinationId: String?

        @inlinable
        public init(destinationId: String? = nil) {
            self.destinationId = destinationId
        }

        private enum CodingKeys: String, CodingKey {
            case destinationId = "destinationId"
        }
    }

    public struct CreateS3BucketResource: AWSEncodableShape & AWSDecodableShape {
        /// Name of the S3 bucket.
        public let bucketName: String?
        /// Information about the specified object prefixes. The S3 object will be scanned only  if it belongs to any of the specified object prefixes.
        public let objectPrefixes: [String]?

        @inlinable
        public init(bucketName: String? = nil, objectPrefixes: [String]? = nil) {
            self.bucketName = bucketName
            self.objectPrefixes = objectPrefixes
        }

        public func validate(name: String) throws {
            try self.validate(self.objectPrefixes, name: "objectPrefixes", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case objectPrefixes = "objectPrefixes"
        }
    }

    public struct CreateSampleFindingsRequest: AWSEncodableShape {
        /// The ID of the detector for which you need to create sample findings. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The types of sample findings to generate.
        public let findingTypes: [String]?

        @inlinable
        public init(detectorId: String, findingTypes: [String]? = nil) {
            self.detectorId = detectorId
            self.findingTypes = findingTypes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.findingTypes, forKey: .findingTypes)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.findingTypes?.forEach {
                try validate($0, name: "findingTypes[]", parent: name, max: 50)
                try validate($0, name: "findingTypes[]", parent: name, min: 1)
            }
            try self.validate(self.findingTypes, name: "findingTypes", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case findingTypes = "findingTypes"
        }
    }

    public struct CreateSampleFindingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateThreatIntelSetRequest: AWSEncodableShape {
        /// A Boolean value that indicates whether GuardDuty is to start using the uploaded ThreatIntelSet.
        public let activate: Bool?
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// The unique ID of the detector of the GuardDuty account for which you want to create a ThreatIntelSet. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The format of the file that contains the ThreatIntelSet.
        public let format: ThreatIntelSetFormat?
        /// The URI of the file that contains the ThreatIntelSet.
        public let location: String?
        /// A user-friendly ThreatIntelSet name displayed in all findings that are generated by activity that involves IP addresses included in this ThreatIntelSet.
        public let name: String?
        /// The tags to be added to a new threat list resource.
        public let tags: [String: String]?

        @inlinable
        public init(activate: Bool? = nil, clientToken: String? = CreateThreatIntelSetRequest.idempotencyToken(), detectorId: String, format: ThreatIntelSetFormat? = nil, location: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.activate = activate
            self.clientToken = clientToken
            self.detectorId = detectorId
            self.format = format
            self.location = location
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.activate, forKey: .activate)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.format, forKey: .format)
            try container.encodeIfPresent(self.location, forKey: .location)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.location, name: "location", parent: name, max: 300)
            try self.validate(self.location, name: "location", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activate = "activate"
            case clientToken = "clientToken"
            case format = "format"
            case location = "location"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateThreatIntelSetResponse: AWSDecodableShape {
        /// The ID of the ThreatIntelSet resource.
        public let threatIntelSetId: String?

        @inlinable
        public init(threatIntelSetId: String? = nil) {
            self.threatIntelSetId = threatIntelSetId
        }

        private enum CodingKeys: String, CodingKey {
            case threatIntelSetId = "threatIntelSetId"
        }
    }

    public struct DNSLogsConfigurationResult: AWSDecodableShape {
        /// Denotes whether DNS logs is enabled as a data source.
        public let status: DataSourceStatus?

        @inlinable
        public init(status: DataSourceStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DataSourceConfigurations: AWSEncodableShape {
        /// Describes whether any Kubernetes logs are enabled as data sources.
        public let kubernetes: KubernetesConfiguration?
        /// Describes whether Malware Protection is enabled as a data source.
        public let malwareProtection: MalwareProtectionConfiguration?
        /// Describes whether S3 data event logs are enabled as a data source.
        public let s3Logs: S3LogsConfiguration?

        @inlinable
        public init(kubernetes: KubernetesConfiguration? = nil, malwareProtection: MalwareProtectionConfiguration? = nil, s3Logs: S3LogsConfiguration? = nil) {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }

        private enum CodingKeys: String, CodingKey {
            case kubernetes = "kubernetes"
            case malwareProtection = "malwareProtection"
            case s3Logs = "s3Logs"
        }
    }

    public struct DataSourceConfigurationsResult: AWSDecodableShape {
        /// An object that contains information on the status of CloudTrail as a data source.
        public let cloudTrail: CloudTrailConfigurationResult?
        /// An object that contains information on the status of DNS logs as a data source.
        public let dnsLogs: DNSLogsConfigurationResult?
        /// An object that contains information on the status of VPC flow logs as a data source.
        public let flowLogs: FlowLogsConfigurationResult?
        /// An object that contains information on the status of all Kubernetes data sources.
        public let kubernetes: KubernetesConfigurationResult?
        /// Describes the configuration of Malware Protection data sources.
        public let malwareProtection: MalwareProtectionConfigurationResult?
        /// An object that contains information on the status of S3 Data event logs as a data source.
        public let s3Logs: S3LogsConfigurationResult?

        @inlinable
        public init(cloudTrail: CloudTrailConfigurationResult? = nil, dnsLogs: DNSLogsConfigurationResult? = nil, flowLogs: FlowLogsConfigurationResult? = nil, kubernetes: KubernetesConfigurationResult? = nil, malwareProtection: MalwareProtectionConfigurationResult? = nil, s3Logs: S3LogsConfigurationResult? = nil) {
            self.cloudTrail = cloudTrail
            self.dnsLogs = dnsLogs
            self.flowLogs = flowLogs
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }

        private enum CodingKeys: String, CodingKey {
            case cloudTrail = "cloudTrail"
            case dnsLogs = "dnsLogs"
            case flowLogs = "flowLogs"
            case kubernetes = "kubernetes"
            case malwareProtection = "malwareProtection"
            case s3Logs = "s3Logs"
        }
    }

    public struct DataSourceFreeTrial: AWSDecodableShape {
        /// A value that specifies the number of days left to use each enabled data source.
        public let freeTrialDaysRemaining: Int?

        @inlinable
        public init(freeTrialDaysRemaining: Int? = nil) {
            self.freeTrialDaysRemaining = freeTrialDaysRemaining
        }

        private enum CodingKeys: String, CodingKey {
            case freeTrialDaysRemaining = "freeTrialDaysRemaining"
        }
    }

    public struct DataSourcesFreeTrial: AWSDecodableShape {
        /// Describes whether any Amazon Web Services CloudTrail management event logs are enabled as data sources.
        public let cloudTrail: DataSourceFreeTrial?
        /// Describes whether any DNS logs are enabled as data sources.
        public let dnsLogs: DataSourceFreeTrial?
        /// Describes whether any VPC Flow logs are enabled as data sources.
        public let flowLogs: DataSourceFreeTrial?
        /// Describes whether any Kubernetes logs are enabled as data sources.
        public let kubernetes: KubernetesDataSourceFreeTrial?
        /// Describes whether Malware Protection is enabled as a data source.
        public let malwareProtection: MalwareProtectionDataSourceFreeTrial?
        /// Describes whether any S3 data event logs are enabled as data sources.
        public let s3Logs: DataSourceFreeTrial?

        @inlinable
        public init(cloudTrail: DataSourceFreeTrial? = nil, dnsLogs: DataSourceFreeTrial? = nil, flowLogs: DataSourceFreeTrial? = nil, kubernetes: KubernetesDataSourceFreeTrial? = nil, malwareProtection: MalwareProtectionDataSourceFreeTrial? = nil, s3Logs: DataSourceFreeTrial? = nil) {
            self.cloudTrail = cloudTrail
            self.dnsLogs = dnsLogs
            self.flowLogs = flowLogs
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }

        private enum CodingKeys: String, CodingKey {
            case cloudTrail = "cloudTrail"
            case dnsLogs = "dnsLogs"
            case flowLogs = "flowLogs"
            case kubernetes = "kubernetes"
            case malwareProtection = "malwareProtection"
            case s3Logs = "s3Logs"
        }
    }

    public struct DateStatistics: AWSDecodableShape {
        /// The timestamp when the total findings count is observed. For example, Date would look like "2024-09-05T17:00:00-07:00" whereas LastGeneratedAt would look like 2024-09-05T17:12:29-07:00".
        public let date: Date?
        /// The timestamp at which the last finding in the findings count, was generated.
        public let lastGeneratedAt: Date?
        /// The severity of the findings generated on each date.
        public let severity: Double?
        /// The total number of findings that were generated per severity level on each date.
        public let totalFindings: Int?

        @inlinable
        public init(date: Date? = nil, lastGeneratedAt: Date? = nil, severity: Double? = nil, totalFindings: Int? = nil) {
            self.date = date
            self.lastGeneratedAt = lastGeneratedAt
            self.severity = severity
            self.totalFindings = totalFindings
        }

        private enum CodingKeys: String, CodingKey {
            case date = "date"
            case lastGeneratedAt = "lastGeneratedAt"
            case severity = "severity"
            case totalFindings = "totalFindings"
        }
    }

    public struct DeclineInvitationsRequest: AWSEncodableShape {
        /// A list of account IDs of the Amazon Web Services accounts that sent invitations to the current member account that you want to decline invitations from.
        public let accountIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct DeclineInvitationsResponse: AWSDecodableShape {
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct DefaultServerSideEncryption: AWSDecodableShape {
        /// The type of encryption used for objects within the S3 bucket.
        public let encryptionType: String?
        /// The Amazon Resource Name (ARN) of the KMS encryption key. Only available if the bucket EncryptionType is aws:kms.
        public let kmsMasterKeyArn: String?

        @inlinable
        public init(encryptionType: String? = nil, kmsMasterKeyArn: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsMasterKeyArn = kmsMasterKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
            case kmsMasterKeyArn = "kmsMasterKeyArn"
        }
    }

    public struct DeleteDetectorRequest: AWSEncodableShape {
        /// The unique ID of the detector that you want to delete. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDetectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFilterRequest: AWSEncodableShape {
        /// The unique ID of the detector that is associated with the filter. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The name of the filter that you want to delete.
        public let filterName: String

        @inlinable
        public init(detectorId: String, filterName: String) {
            self.detectorId = detectorId
            self.filterName = filterName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodePath(self.filterName, key: "filterName")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFilterResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIPSetRequest: AWSEncodableShape {
        /// The unique ID of the detector associated with the IPSet. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The unique ID of the IPSet to delete.
        public let ipSetId: String

        @inlinable
        public init(detectorId: String, ipSetId: String) {
            self.detectorId = detectorId
            self.ipSetId = ipSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodePath(self.ipSetId, key: "ipSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIPSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteInvitationsRequest: AWSEncodableShape {
        /// A list of account IDs of the Amazon Web Services accounts that sent invitations to the current member account that you want to delete invitations from.
        public let accountIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct DeleteInvitationsResponse: AWSDecodableShape {
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct DeleteMalwareProtectionPlanRequest: AWSEncodableShape {
        /// A unique identifier associated with Malware Protection plan resource.
        public let malwareProtectionPlanId: String

        @inlinable
        public init(malwareProtectionPlanId: String) {
            self.malwareProtectionPlanId = malwareProtectionPlanId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.malwareProtectionPlanId, key: "malwareProtectionPlanId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMembersRequest: AWSEncodableShape {
        /// A list of account IDs of the GuardDuty member accounts that you want to delete.
        public let accountIds: [String]?
        /// The unique ID of the detector of the GuardDuty account whose members you want to delete. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(accountIds: [String]? = nil, detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountIds, forKey: .accountIds)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct DeleteMembersResponse: AWSDecodableShape {
        /// The accounts that could not be processed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct DeletePublishingDestinationRequest: AWSEncodableShape {
        /// The ID of the publishing destination to delete.
        public let destinationId: String
        /// The unique ID of the detector associated with the publishing destination to delete. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(destinationId: String, detectorId: String) {
            self.destinationId = destinationId
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.destinationId, key: "destinationId")
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePublishingDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteThreatIntelSetRequest: AWSEncodableShape {
        /// The unique ID of the detector that is associated with the threatIntelSet. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The unique ID of the threatIntelSet that you want to delete.
        public let threatIntelSetId: String

        @inlinable
        public init(detectorId: String, threatIntelSetId: String) {
            self.detectorId = detectorId
            self.threatIntelSetId = threatIntelSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodePath(self.threatIntelSetId, key: "threatIntelSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteThreatIntelSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeMalwareScansRequest: AWSEncodableShape {
        /// The unique ID of the detector that the request is associated with. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// Represents the criteria to be used in the filter for describing scan entries.
        public let filterCriteria: FilterCriteria?
        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// Represents the criteria used for sorting scan entries. The  attributeName is required and it must be scanStartTime.
        public let sortCriteria: SortCriteria?

        @inlinable
        public init(detectorId: String, filterCriteria: FilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: SortCriteria? = nil) {
            self.detectorId = detectorId
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.filterCriteria, forKey: .filterCriteria)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortCriteria, forKey: .sortCriteria)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct DescribeMalwareScansResponse: AWSDecodableShape {
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?
        /// Contains information about malware scans associated with GuardDuty Malware Protection for EC2.
        public let scans: [Scan]?

        @inlinable
        public init(nextToken: String? = nil, scans: [Scan]? = nil) {
            self.nextToken = nextToken
            self.scans = scans
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case scans = "scans"
        }
    }

    public struct DescribeOrganizationConfigurationRequest: AWSEncodableShape {
        /// The detector ID of the delegated administrator for which you need to retrieve the information. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items that you want in the response.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        @inlinable
        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeOrganizationConfigurationResponse: AWSDecodableShape {
        /// Indicates whether GuardDuty is automatically enabled for accounts added to the organization. Even though this is still supported, we recommend using AutoEnableOrganizationMembers to achieve the similar results.
        public let autoEnable: Bool?
        /// Indicates the auto-enablement configuration of GuardDuty or any of the corresponding protection plans for the member accounts in the organization.    NEW: Indicates that when a new account joins the organization, they will have GuardDuty or any of the corresponding protection plans enabled automatically.     ALL: Indicates that all accounts in the organization have GuardDuty and any of the corresponding  protection plans enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty.    NONE: Indicates that GuardDuty or any of the corresponding protection plans  will not be automatically enabled for any account in the organization. The administrator must manage GuardDuty for each account in  the organization individually. When you update the auto-enable setting from ALL or NEW to  NONE, this action doesn't disable the corresponding option for your existing accounts. This configuration will apply to the new accounts that join the organization. After you update the auto-enable settings, no new account will have the corresponding option as enabled.
        public let autoEnableOrganizationMembers: AutoEnableMembers?
        /// Describes which data sources are enabled automatically for member accounts.
        public let dataSources: OrganizationDataSourceConfigurationsResult?
        /// A list of features that are configured for this organization.
        public let features: [OrganizationFeatureConfigurationResult]?
        /// Indicates whether the maximum number of allowed member accounts are already associated with the delegated administrator account for your organization.
        public let memberAccountLimitReached: Bool?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        @inlinable
        public init(autoEnableOrganizationMembers: AutoEnableMembers? = nil, features: [OrganizationFeatureConfigurationResult]? = nil, memberAccountLimitReached: Bool? = nil, nextToken: String? = nil) {
            self.autoEnable = nil
            self.autoEnableOrganizationMembers = autoEnableOrganizationMembers
            self.dataSources = nil
            self.features = features
            self.memberAccountLimitReached = memberAccountLimitReached
            self.nextToken = nextToken
        }

        @available(*, deprecated, message: "Members autoEnable, dataSources have been deprecated")
        @inlinable
        public init(autoEnable: Bool? = nil, autoEnableOrganizationMembers: AutoEnableMembers? = nil, dataSources: OrganizationDataSourceConfigurationsResult? = nil, features: [OrganizationFeatureConfigurationResult]? = nil, memberAccountLimitReached: Bool? = nil, nextToken: String? = nil) {
            self.autoEnable = autoEnable
            self.autoEnableOrganizationMembers = autoEnableOrganizationMembers
            self.dataSources = dataSources
            self.features = features
            self.memberAccountLimitReached = memberAccountLimitReached
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
            case autoEnableOrganizationMembers = "autoEnableOrganizationMembers"
            case dataSources = "dataSources"
            case features = "features"
            case memberAccountLimitReached = "memberAccountLimitReached"
            case nextToken = "nextToken"
        }
    }

    public struct DescribePublishingDestinationRequest: AWSEncodableShape {
        /// The ID of the publishing destination to retrieve.
        public let destinationId: String
        /// The unique ID of the detector associated with the publishing destination to retrieve. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(destinationId: String, detectorId: String) {
            self.destinationId = destinationId
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.destinationId, key: "destinationId")
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePublishingDestinationResponse: AWSDecodableShape {
        /// The ID of the publishing destination.
        public let destinationId: String?
        /// A DestinationProperties object that includes the DestinationArn and KmsKeyArn of the publishing destination.
        public let destinationProperties: DestinationProperties?
        /// The type of publishing destination. Currently, only Amazon S3 buckets are supported.
        public let destinationType: DestinationType?
        /// The time, in epoch millisecond format, at which GuardDuty was first unable to publish findings to the destination.
        public let publishingFailureStartTimestamp: Int64?
        /// The status of the publishing destination.
        public let status: PublishingStatus?

        @inlinable
        public init(destinationId: String? = nil, destinationProperties: DestinationProperties? = nil, destinationType: DestinationType? = nil, publishingFailureStartTimestamp: Int64? = nil, status: PublishingStatus? = nil) {
            self.destinationId = destinationId
            self.destinationProperties = destinationProperties
            self.destinationType = destinationType
            self.publishingFailureStartTimestamp = publishingFailureStartTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case destinationId = "destinationId"
            case destinationProperties = "destinationProperties"
            case destinationType = "destinationType"
            case publishingFailureStartTimestamp = "publishingFailureStartTimestamp"
            case status = "status"
        }
    }

    public struct Destination: AWSDecodableShape {
        /// The unique ID of the publishing destination.
        public let destinationId: String?
        /// The type of resource used for the publishing destination. Currently, only Amazon S3 buckets are supported.
        public let destinationType: DestinationType?
        /// The status of the publishing destination.
        public let status: PublishingStatus?

        @inlinable
        public init(destinationId: String? = nil, destinationType: DestinationType? = nil, status: PublishingStatus? = nil) {
            self.destinationId = destinationId
            self.destinationType = destinationType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case destinationId = "destinationId"
            case destinationType = "destinationType"
            case status = "status"
        }
    }

    public struct DestinationProperties: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the resource to publish to. To specify an S3 bucket folder use the following format: arn:aws:s3:::DOC-EXAMPLE-BUCKET/myFolder/
        public let destinationArn: String?
        /// The ARN of the KMS key to use for encryption.
        public let kmsKeyArn: String?

        @inlinable
        public init(destinationArn: String? = nil, kmsKeyArn: String? = nil) {
            self.destinationArn = destinationArn
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case destinationArn = "destinationArn"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct Detection: AWSDecodableShape {
        /// The details about the anomalous activity that caused GuardDuty to  generate the finding.
        public let anomaly: Anomaly?
        /// The details about the attack sequence.
        public let sequence: Sequence?

        @inlinable
        public init(anomaly: Anomaly? = nil, sequence: Sequence? = nil) {
            self.anomaly = anomaly
            self.sequence = sequence
        }

        private enum CodingKeys: String, CodingKey {
            case anomaly = "anomaly"
            case sequence = "sequence"
        }
    }

    public struct DetectorAdditionalConfiguration: AWSEncodableShape {
        /// Name of the additional configuration.
        public let name: FeatureAdditionalConfiguration?
        /// Status of the additional configuration.
        public let status: FeatureStatus?

        @inlinable
        public init(name: FeatureAdditionalConfiguration? = nil, status: FeatureStatus? = nil) {
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
        }
    }

    public struct DetectorAdditionalConfigurationResult: AWSDecodableShape {
        /// Name of the additional configuration.
        public let name: FeatureAdditionalConfiguration?
        /// Status of the additional configuration.
        public let status: FeatureStatus?
        /// The timestamp at which the additional configuration was last updated. This is in UTC format.
        public let updatedAt: Date?

        @inlinable
        public init(name: FeatureAdditionalConfiguration? = nil, status: FeatureStatus? = nil, updatedAt: Date? = nil) {
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DetectorFeatureConfiguration: AWSEncodableShape {
        /// Additional configuration for a resource.
        public let additionalConfiguration: [DetectorAdditionalConfiguration]?
        /// The name of the feature.
        public let name: DetectorFeature?
        /// The status of the feature.
        public let status: FeatureStatus?

        @inlinable
        public init(additionalConfiguration: [DetectorAdditionalConfiguration]? = nil, name: DetectorFeature? = nil, status: FeatureStatus? = nil) {
            self.additionalConfiguration = additionalConfiguration
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case additionalConfiguration = "additionalConfiguration"
            case name = "name"
            case status = "status"
        }
    }

    public struct DetectorFeatureConfigurationResult: AWSDecodableShape {
        /// Additional configuration for a resource.
        public let additionalConfiguration: [DetectorAdditionalConfigurationResult]?
        /// Indicates the name of the feature that can be enabled for the detector.
        public let name: DetectorFeatureResult?
        /// Indicates the status of the feature that is enabled for the detector.
        public let status: FeatureStatus?
        /// The timestamp at which the feature object was updated.
        public let updatedAt: Date?

        @inlinable
        public init(additionalConfiguration: [DetectorAdditionalConfigurationResult]? = nil, name: DetectorFeatureResult? = nil, status: FeatureStatus? = nil, updatedAt: Date? = nil) {
            self.additionalConfiguration = additionalConfiguration
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case additionalConfiguration = "additionalConfiguration"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DisableOrganizationAdminAccountRequest: AWSEncodableShape {
        /// The Amazon Web Services Account ID for the organizations account to be disabled as a GuardDuty delegated administrator.
        public let adminAccountId: String?

        @inlinable
        public init(adminAccountId: String? = nil) {
            self.adminAccountId = adminAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "adminAccountId"
        }
    }

    public struct DisableOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateFromAdministratorAccountRequest: AWSEncodableShape {
        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String

        @inlinable
        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateFromAdministratorAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateFromMasterAccountRequest: AWSEncodableShape {
        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String

        @inlinable
        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateFromMasterAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateMembersRequest: AWSEncodableShape {
        /// A list of account IDs of the GuardDuty member accounts that you want to disassociate from the administrator account.
        public let accountIds: [String]?
        /// The unique ID of the detector of the GuardDuty account whose members you want to disassociate from the administrator account.
        public let detectorId: String

        @inlinable
        public init(accountIds: [String]? = nil, detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountIds, forKey: .accountIds)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct DisassociateMembersResponse: AWSDecodableShape {
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct DnsRequestAction: AWSDecodableShape {
        /// Indicates whether the targeted port is blocked.
        public let blocked: Bool?
        /// The domain information for the DNS query.
        public let domain: String?
        /// The second and top level domain involved in the  activity that potentially prompted GuardDuty to generate this finding. For a list of top-level and second-level domains, see public suffix list.
        public let domainWithSuffix: String?
        /// The network connection protocol observed in the activity that prompted GuardDuty to generate the finding.
        public let `protocol`: String?

        @inlinable
        public init(blocked: Bool? = nil, domain: String? = nil, domainWithSuffix: String? = nil, protocol: String? = nil) {
            self.blocked = blocked
            self.domain = domain
            self.domainWithSuffix = domainWithSuffix
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case blocked = "blocked"
            case domain = "domain"
            case domainWithSuffix = "domainWithSuffix"
            case `protocol` = "protocol"
        }
    }

    public struct DomainDetails: AWSDecodableShape {
        /// The domain information for the Amazon Web Services API call.
        public let domain: String?

        @inlinable
        public init(domain: String? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
        }
    }

    public struct EbsVolumeDetails: AWSDecodableShape {
        /// List of EBS volumes that were scanned.
        public let scannedVolumeDetails: [VolumeDetail]?
        /// List of EBS volumes that were skipped from the malware scan.
        public let skippedVolumeDetails: [VolumeDetail]?

        @inlinable
        public init(scannedVolumeDetails: [VolumeDetail]? = nil, skippedVolumeDetails: [VolumeDetail]? = nil) {
            self.scannedVolumeDetails = scannedVolumeDetails
            self.skippedVolumeDetails = skippedVolumeDetails
        }

        private enum CodingKeys: String, CodingKey {
            case scannedVolumeDetails = "scannedVolumeDetails"
            case skippedVolumeDetails = "skippedVolumeDetails"
        }
    }

    public struct EbsVolumeScanDetails: AWSDecodableShape {
        /// Returns the completion date and time of the malware scan.
        public let scanCompletedAt: Date?
        /// Contains a complete view providing malware scan result details.
        public let scanDetections: ScanDetections?
        /// Unique Id of the malware scan that generated the finding.
        public let scanId: String?
        /// Returns the start date and time of the malware scan.
        public let scanStartedAt: Date?
        /// Specifies the scan type that invoked the malware scan.
        public let scanType: ScanType?
        /// Contains list of threat intelligence sources used to detect threats.
        public let sources: [String]?
        /// GuardDuty finding ID that triggered a malware scan.
        public let triggerFindingId: String?

        @inlinable
        public init(scanCompletedAt: Date? = nil, scanDetections: ScanDetections? = nil, scanId: String? = nil, scanStartedAt: Date? = nil, scanType: ScanType? = nil, sources: [String]? = nil, triggerFindingId: String? = nil) {
            self.scanCompletedAt = scanCompletedAt
            self.scanDetections = scanDetections
            self.scanId = scanId
            self.scanStartedAt = scanStartedAt
            self.scanType = scanType
            self.sources = sources
            self.triggerFindingId = triggerFindingId
        }

        private enum CodingKeys: String, CodingKey {
            case scanCompletedAt = "scanCompletedAt"
            case scanDetections = "scanDetections"
            case scanId = "scanId"
            case scanStartedAt = "scanStartedAt"
            case scanType = "scanType"
            case sources = "sources"
            case triggerFindingId = "triggerFindingId"
        }
    }

    public struct EbsVolumesResult: AWSDecodableShape {
        /// Specifies the reason why scanning EBS volumes (Malware Protection) was not enabled as a data source.
        public let reason: String?
        /// Describes whether scanning EBS volumes is enabled as a data source.
        public let status: DataSourceStatus?

        @inlinable
        public init(reason: String? = nil, status: DataSourceStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct Ec2Instance: AWSDecodableShape {
        /// The availability zone of the Amazon EC2 instance. For more information, see Availability zones in the Amazon EC2 User Guide.
        public let availabilityZone: String?
        /// The ID of the network interface.
        public let ec2NetworkInterfaceUids: [String]?
        public let iamInstanceProfile: IamInstanceProfile?
        /// The image description of the Amazon EC2 instance.
        public let imageDescription: String?
        /// The state of the Amazon EC2 instance. For more information, see Amazon EC2 instance state changes in the Amazon EC2 User Guide.
        public let instanceState: String?
        /// Type of the Amazon EC2 instance.
        public let instanceType: String?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Outpost. This shows applicable Amazon Web Services Outposts instances.
        public let outpostArn: String?
        /// The platform of the Amazon EC2 instance.
        public let platform: String?
        /// The product code of the Amazon EC2 instance.
        public let productCodes: [ProductCode]?

        @inlinable
        public init(availabilityZone: String? = nil, ec2NetworkInterfaceUids: [String]? = nil, iamInstanceProfile: IamInstanceProfile? = nil, imageDescription: String? = nil, instanceState: String? = nil, instanceType: String? = nil, outpostArn: String? = nil, platform: String? = nil, productCodes: [ProductCode]? = nil) {
            self.availabilityZone = availabilityZone
            self.ec2NetworkInterfaceUids = ec2NetworkInterfaceUids
            self.iamInstanceProfile = iamInstanceProfile
            self.imageDescription = imageDescription
            self.instanceState = instanceState
            self.instanceType = instanceType
            self.outpostArn = outpostArn
            self.platform = platform
            self.productCodes = productCodes
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case ec2NetworkInterfaceUids = "ec2NetworkInterfaceUids"
            case iamInstanceProfile = "IamInstanceProfile"
            case imageDescription = "imageDescription"
            case instanceState = "instanceState"
            case instanceType = "instanceType"
            case outpostArn = "outpostArn"
            case platform = "platform"
            case productCodes = "productCodes"
        }
    }

    public struct Ec2NetworkInterface: AWSDecodableShape {
        /// A list of IPv6 addresses for the Amazon EC2 instance.
        public let ipv6Addresses: [String]?
        /// Other private IP address information of the Amazon EC2 instance.
        public let privateIpAddresses: [PrivateIpAddressDetails]?
        /// The public IP address of the Amazon EC2 instance.
        public let publicIp: String?
        /// The security groups associated with the Amazon EC2 instance.
        public let securityGroups: [SecurityGroup]?
        /// The subnet ID of the Amazon EC2 instance.
        public let subNetId: String?
        /// The VPC ID of the Amazon EC2 instance.
        public let vpcId: String?

        @inlinable
        public init(ipv6Addresses: [String]? = nil, privateIpAddresses: [PrivateIpAddressDetails]? = nil, publicIp: String? = nil, securityGroups: [SecurityGroup]? = nil, subNetId: String? = nil, vpcId: String? = nil) {
            self.ipv6Addresses = ipv6Addresses
            self.privateIpAddresses = privateIpAddresses
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.subNetId = subNetId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6Addresses = "ipv6Addresses"
            case privateIpAddresses = "privateIpAddresses"
            case publicIp = "publicIp"
            case securityGroups = "securityGroups"
            case subNetId = "subNetId"
            case vpcId = "vpcId"
        }
    }

    public struct EcsClusterDetails: AWSDecodableShape {
        /// The number of services that are running on the cluster in an ACTIVE state.
        public let activeServicesCount: Int?
        /// The Amazon Resource Name (ARN) that identifies the cluster.
        public let arn: String?
        /// The name of the ECS Cluster.
        public let name: String?
        /// The number of container instances registered into the cluster.
        public let registeredContainerInstancesCount: Int?
        /// The number of tasks in the cluster that are in the RUNNING state.
        public let runningTasksCount: Int?
        /// The status of the ECS cluster.
        public let status: String?
        /// The tags of the ECS Cluster.
        public let tags: [Tag]?
        /// Contains information about the details of the ECS Task.
        public let taskDetails: EcsTaskDetails?

        @inlinable
        public init(activeServicesCount: Int? = nil, arn: String? = nil, name: String? = nil, registeredContainerInstancesCount: Int? = nil, runningTasksCount: Int? = nil, status: String? = nil, tags: [Tag]? = nil, taskDetails: EcsTaskDetails? = nil) {
            self.activeServicesCount = activeServicesCount
            self.arn = arn
            self.name = name
            self.registeredContainerInstancesCount = registeredContainerInstancesCount
            self.runningTasksCount = runningTasksCount
            self.status = status
            self.tags = tags
            self.taskDetails = taskDetails
        }

        private enum CodingKeys: String, CodingKey {
            case activeServicesCount = "activeServicesCount"
            case arn = "arn"
            case name = "name"
            case registeredContainerInstancesCount = "registeredContainerInstancesCount"
            case runningTasksCount = "runningTasksCount"
            case status = "status"
            case tags = "tags"
            case taskDetails = "taskDetails"
        }
    }

    public struct EcsTaskDetails: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the task.
        public let arn: String?
        /// The containers that's associated with the task.
        public let containers: [Container]?
        /// The ARN of the task definition that creates the task.
        public let definitionArn: String?
        /// The name of the task group that's associated with the task.
        public let group: String?
        /// A capacity on which the task is running. For example, Fargate and EC2.
        public let launchType: String?
        /// The Unix timestamp for the time when the task started.
        public let startedAt: Date?
        /// Contains the tag specified when a task is started.
        public let startedBy: String?
        /// The tags of the ECS Task.
        public let tags: [Tag]?
        /// The Unix timestamp for the time when the task was created.
        public let taskCreatedAt: Date?
        /// The version counter for the task.
        public let version: String?
        /// The list of data volume definitions for the task.
        public let volumes: [Volume]?

        @inlinable
        public init(arn: String? = nil, containers: [Container]? = nil, definitionArn: String? = nil, group: String? = nil, launchType: String? = nil, startedAt: Date? = nil, startedBy: String? = nil, tags: [Tag]? = nil, taskCreatedAt: Date? = nil, version: String? = nil, volumes: [Volume]? = nil) {
            self.arn = arn
            self.containers = containers
            self.definitionArn = definitionArn
            self.group = group
            self.launchType = launchType
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.tags = tags
            self.taskCreatedAt = taskCreatedAt
            self.version = version
            self.volumes = volumes
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case containers = "containers"
            case definitionArn = "definitionArn"
            case group = "group"
            case launchType = "launchType"
            case startedAt = "startedAt"
            case startedBy = "startedBy"
            case tags = "tags"
            case taskCreatedAt = "createdAt"
            case version = "version"
            case volumes = "volumes"
        }
    }

    public struct EksClusterDetails: AWSDecodableShape {
        /// EKS cluster ARN.
        public let arn: String?
        /// The timestamp when the EKS cluster was created.
        public let createdAt: Date?
        /// EKS cluster name.
        public let name: String?
        /// The EKS cluster status.
        public let status: String?
        /// The EKS cluster tags.
        public let tags: [Tag]?
        /// The VPC ID to which the EKS cluster is attached.
        public let vpcId: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, name: String? = nil, status: String? = nil, tags: [Tag]? = nil, vpcId: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.status = status
            self.tags = tags
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case name = "name"
            case status = "status"
            case tags = "tags"
            case vpcId = "vpcId"
        }
    }

    public struct EnableOrganizationAdminAccountRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID for the organization account to be enabled as a GuardDuty delegated administrator.
        public let adminAccountId: String?

        @inlinable
        public init(adminAccountId: String? = nil) {
            self.adminAccountId = adminAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "adminAccountId"
        }
    }

    public struct EnableOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Evidence: AWSDecodableShape {
        /// A list of threat intelligence details related to the evidence.
        public let threatIntelligenceDetails: [ThreatIntelligenceDetail]?

        @inlinable
        public init(threatIntelligenceDetails: [ThreatIntelligenceDetail]? = nil) {
            self.threatIntelligenceDetails = threatIntelligenceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case threatIntelligenceDetails = "threatIntelligenceDetails"
        }
    }

    public struct FargateDetails: AWSDecodableShape {
        /// Runtime coverage issues identified for the resource running on Amazon Web Services Fargate.
        public let issues: [String]?
        /// Indicates how the GuardDuty security agent is managed for this resource.    AUTO_MANAGED indicates that GuardDuty deploys and manages updates for this resource.    DISABLED indicates that the deployment of the GuardDuty security agent is disabled for this resource.    The MANUAL status doesn't apply to the Amazon Web Services Fargate (Amazon ECS only) woprkloads.
        public let managementType: ManagementType?

        @inlinable
        public init(issues: [String]? = nil, managementType: ManagementType? = nil) {
            self.issues = issues
            self.managementType = managementType
        }

        private enum CodingKeys: String, CodingKey {
            case issues = "issues"
            case managementType = "managementType"
        }
    }

    public struct FilterCondition: AWSEncodableShape {
        /// Represents an equal condition to be applied to a single field when querying for scan entries.
        public let equalsValue: String?
        /// Represents a greater than condition to be applied to a single field when querying for scan entries.
        public let greaterThan: Int64?
        /// Represents a less than condition to be applied to a single field when querying for scan entries.
        public let lessThan: Int64?

        @inlinable
        public init(equalsValue: String? = nil, greaterThan: Int64? = nil, lessThan: Int64? = nil) {
            self.equalsValue = equalsValue
            self.greaterThan = greaterThan
            self.lessThan = lessThan
        }

        public func validate(name: String) throws {
            try self.validate(self.equalsValue, name: "equalsValue", parent: name, max: 200)
            try self.validate(self.equalsValue, name: "equalsValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case equalsValue = "equalsValue"
            case greaterThan = "greaterThan"
            case lessThan = "lessThan"
        }
    }

    public struct FilterCriteria: AWSEncodableShape {
        /// Represents a condition that when matched will be added to the response of the operation.
        public let filterCriterion: [FilterCriterion]?

        @inlinable
        public init(filterCriterion: [FilterCriterion]? = nil) {
            self.filterCriterion = filterCriterion
        }

        public func validate(name: String) throws {
            try self.filterCriterion?.forEach {
                try $0.validate(name: "\(name).filterCriterion[]")
            }
            try self.validate(self.filterCriterion, name: "filterCriterion", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriterion = "filterCriterion"
        }
    }

    public struct FilterCriterion: AWSEncodableShape {
        /// An enum value representing possible scan properties to match with given scan entries.  Replace the enum value CLUSTER_NAME with EKS_CLUSTER_NAME. CLUSTER_NAME has been deprecated.
        public let criterionKey: CriterionKey?
        /// Contains information about the condition.
        public let filterCondition: FilterCondition?

        @inlinable
        public init(criterionKey: CriterionKey? = nil, filterCondition: FilterCondition? = nil) {
            self.criterionKey = criterionKey
            self.filterCondition = filterCondition
        }

        public func validate(name: String) throws {
            try self.filterCondition?.validate(name: "\(name).filterCondition")
        }

        private enum CodingKeys: String, CodingKey {
            case criterionKey = "criterionKey"
            case filterCondition = "filterCondition"
        }
    }

    public struct Finding: AWSDecodableShape {
        /// The ID of the account in which the finding was generated.
        public let accountId: String?
        /// The ARN of the finding.
        public let arn: String?
        /// Amazon Resource Name (ARN) associated with the attack sequence finding.
        public let associatedAttackSequenceArn: String?
        /// The confidence score for the finding.
        public let confidence: Double?
        /// The time and date when the finding was created.
        public let createdAt: String?
        /// The description of the finding.
        public let description: String?
        /// The ID of the finding.
        public let id: String?
        /// The partition associated with the finding.
        public let partition: String?
        /// The Region where the finding was generated.
        public let region: String?
        public let resource: Resource?
        /// The version of the schema used for the finding.
        public let schemaVersion: String?
        public let service: Service?
        /// The severity of the finding.
        public let severity: Double?
        /// The title of the finding.
        public let title: String?
        /// The type of finding.
        public let type: String?
        /// The time and date when the finding was last updated.
        public let updatedAt: String?

        @inlinable
        public init(accountId: String? = nil, arn: String? = nil, associatedAttackSequenceArn: String? = nil, confidence: Double? = nil, createdAt: String? = nil, description: String? = nil, id: String? = nil, partition: String? = nil, region: String? = nil, resource: Resource? = nil, schemaVersion: String? = nil, service: Service? = nil, severity: Double? = nil, title: String? = nil, type: String? = nil, updatedAt: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.associatedAttackSequenceArn = associatedAttackSequenceArn
            self.confidence = confidence
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.partition = partition
            self.region = region
            self.resource = resource
            self.schemaVersion = schemaVersion
            self.service = service
            self.severity = severity
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case arn = "arn"
            case associatedAttackSequenceArn = "associatedAttackSequenceArn"
            case confidence = "confidence"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case partition = "partition"
            case region = "region"
            case resource = "resource"
            case schemaVersion = "schemaVersion"
            case service = "service"
            case severity = "severity"
            case title = "title"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct FindingCriteria: AWSEncodableShape & AWSDecodableShape {
        /// Represents a map of finding properties that match specified conditions and values when querying findings.
        public let criterion: [String: Condition]?

        @inlinable
        public init(criterion: [String: Condition]? = nil) {
            self.criterion = criterion
        }

        private enum CodingKeys: String, CodingKey {
            case criterion = "criterion"
        }
    }

    public struct FindingStatistics: AWSDecodableShape {
        /// Represents a list of map of severity to count statistics for a set of findings.
        public let countBySeverity: [String: Int]?
        /// Represents a list of map of accounts with a findings count associated with each account.
        public let groupedByAccount: [AccountStatistics]?
        /// Represents a list of map of dates with a count of total findings generated on each date per severity level.
        public let groupedByDate: [DateStatistics]?
        /// Represents a list of map of finding types with a count of total findings generated for each type.  Based on the orderBy parameter, this request returns either the most occurring finding types or the least occurring finding types. If the orderBy parameter is ASC, this will represent the least occurring finding types in your account; otherwise, this will represent the most occurring finding types. The default value of orderBy is DESC.
        public let groupedByFindingType: [FindingTypeStatistics]?
        /// Represents a list of map of top resources with a count of total findings.
        public let groupedByResource: [ResourceStatistics]?
        /// Represents a list of map of total findings for each severity level.
        public let groupedBySeverity: [SeverityStatistics]?

        @inlinable
        public init(groupedByAccount: [AccountStatistics]? = nil, groupedByDate: [DateStatistics]? = nil, groupedByFindingType: [FindingTypeStatistics]? = nil, groupedByResource: [ResourceStatistics]? = nil, groupedBySeverity: [SeverityStatistics]? = nil) {
            self.countBySeverity = nil
            self.groupedByAccount = groupedByAccount
            self.groupedByDate = groupedByDate
            self.groupedByFindingType = groupedByFindingType
            self.groupedByResource = groupedByResource
            self.groupedBySeverity = groupedBySeverity
        }

        @available(*, deprecated, message: "Members countBySeverity have been deprecated")
        @inlinable
        public init(countBySeverity: [String: Int]? = nil, groupedByAccount: [AccountStatistics]? = nil, groupedByDate: [DateStatistics]? = nil, groupedByFindingType: [FindingTypeStatistics]? = nil, groupedByResource: [ResourceStatistics]? = nil, groupedBySeverity: [SeverityStatistics]? = nil) {
            self.countBySeverity = countBySeverity
            self.groupedByAccount = groupedByAccount
            self.groupedByDate = groupedByDate
            self.groupedByFindingType = groupedByFindingType
            self.groupedByResource = groupedByResource
            self.groupedBySeverity = groupedBySeverity
        }

        private enum CodingKeys: String, CodingKey {
            case countBySeverity = "countBySeverity"
            case groupedByAccount = "groupedByAccount"
            case groupedByDate = "groupedByDate"
            case groupedByFindingType = "groupedByFindingType"
            case groupedByResource = "groupedByResource"
            case groupedBySeverity = "groupedBySeverity"
        }
    }

    public struct FindingTypeStatistics: AWSDecodableShape {
        /// Name of the finding type.
        public let findingType: String?
        /// The timestamp at which this finding type was last generated in your environment.
        public let lastGeneratedAt: Date?
        /// The total number of findings associated with generated for each distinct finding type.
        public let totalFindings: Int?

        @inlinable
        public init(findingType: String? = nil, lastGeneratedAt: Date? = nil, totalFindings: Int? = nil) {
            self.findingType = findingType
            self.lastGeneratedAt = lastGeneratedAt
            self.totalFindings = totalFindings
        }

        private enum CodingKeys: String, CodingKey {
            case findingType = "findingType"
            case lastGeneratedAt = "lastGeneratedAt"
            case totalFindings = "totalFindings"
        }
    }

    public struct FlowLogsConfigurationResult: AWSDecodableShape {
        /// Denotes whether VPC flow logs is enabled as a data source.
        public let status: DataSourceStatus?

        @inlinable
        public init(status: DataSourceStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct FreeTrialFeatureConfigurationResult: AWSDecodableShape {
        /// The number of the remaining free trial days for the feature.
        public let freeTrialDaysRemaining: Int?
        /// The name of the feature for which the free trial is configured.
        public let name: FreeTrialFeatureResult?

        @inlinable
        public init(freeTrialDaysRemaining: Int? = nil, name: FreeTrialFeatureResult? = nil) {
            self.freeTrialDaysRemaining = freeTrialDaysRemaining
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case freeTrialDaysRemaining = "freeTrialDaysRemaining"
            case name = "name"
        }
    }

    public struct GeoLocation: AWSDecodableShape {
        /// The latitude information of the remote IP address.
        public let lat: Double?
        /// The longitude information of the remote IP address.
        public let lon: Double?

        @inlinable
        public init(lat: Double? = nil, lon: Double? = nil) {
            self.lat = lat
            self.lon = lon
        }

        private enum CodingKeys: String, CodingKey {
            case lat = "lat"
            case lon = "lon"
        }
    }

    public struct GetAdministratorAccountRequest: AWSEncodableShape {
        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String

        @inlinable
        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAdministratorAccountResponse: AWSDecodableShape {
        /// The administrator account details.
        public let administrator: Administrator?

        @inlinable
        public init(administrator: Administrator? = nil) {
            self.administrator = administrator
        }

        private enum CodingKeys: String, CodingKey {
            case administrator = "administrator"
        }
    }

    public struct GetCoverageStatisticsRequest: AWSEncodableShape {
        /// The unique ID of the GuardDuty detector. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// Represents the criteria used to filter the coverage statistics.
        public let filterCriteria: CoverageFilterCriteria?
        /// Represents the statistics type used to aggregate the coverage details.
        public let statisticsType: [CoverageStatisticsType]?

        @inlinable
        public init(detectorId: String, filterCriteria: CoverageFilterCriteria? = nil, statisticsType: [CoverageStatisticsType]? = nil) {
            self.detectorId = detectorId
            self.filterCriteria = filterCriteria
            self.statisticsType = statisticsType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.filterCriteria, forKey: .filterCriteria)
            try container.encodeIfPresent(self.statisticsType, forKey: .statisticsType)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case statisticsType = "statisticsType"
        }
    }

    public struct GetCoverageStatisticsResponse: AWSDecodableShape {
        /// Represents the count aggregated by the statusCode and resourceType.
        public let coverageStatistics: CoverageStatistics?

        @inlinable
        public init(coverageStatistics: CoverageStatistics? = nil) {
            self.coverageStatistics = coverageStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case coverageStatistics = "coverageStatistics"
        }
    }

    public struct GetDetectorRequest: AWSEncodableShape {
        /// The unique ID of the detector that you want to get. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDetectorResponse: AWSDecodableShape {
        /// The timestamp of when the detector was created.
        public let createdAt: String?
        /// Describes which data sources are enabled for the detector.
        public let dataSources: DataSourceConfigurationsResult?
        /// Describes the features that have been enabled for the detector.
        public let features: [DetectorFeatureConfigurationResult]?
        /// The publishing frequency of the finding.
        public let findingPublishingFrequency: FindingPublishingFrequency?
        /// The GuardDuty service role.
        public let serviceRole: String?
        /// The detector status.
        public let status: DetectorStatus?
        /// The tags of the detector resource.
        public let tags: [String: String]?
        /// The last-updated timestamp for the detector.
        public let updatedAt: String?

        @inlinable
        public init(createdAt: String? = nil, features: [DetectorFeatureConfigurationResult]? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil, serviceRole: String? = nil, status: DetectorStatus? = nil, tags: [String: String]? = nil, updatedAt: String? = nil) {
            self.createdAt = createdAt
            self.dataSources = nil
            self.features = features
            self.findingPublishingFrequency = findingPublishingFrequency
            self.serviceRole = serviceRole
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }

        @available(*, deprecated, message: "Members dataSources have been deprecated")
        @inlinable
        public init(createdAt: String? = nil, dataSources: DataSourceConfigurationsResult? = nil, features: [DetectorFeatureConfigurationResult]? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil, serviceRole: String? = nil, status: DetectorStatus? = nil, tags: [String: String]? = nil, updatedAt: String? = nil) {
            self.createdAt = createdAt
            self.dataSources = dataSources
            self.features = features
            self.findingPublishingFrequency = findingPublishingFrequency
            self.serviceRole = serviceRole
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSources = "dataSources"
            case features = "features"
            case findingPublishingFrequency = "findingPublishingFrequency"
            case serviceRole = "serviceRole"
            case status = "status"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetFilterRequest: AWSEncodableShape {
        /// The unique ID of the detector that is associated with this filter. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The name of the filter you want to get.
        public let filterName: String

        @inlinable
        public init(detectorId: String, filterName: String) {
            self.detectorId = detectorId
            self.filterName = filterName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodePath(self.filterName, key: "filterName")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFilterResponse: AWSDecodableShape {
        /// Specifies the action that is to be applied to the findings that match the filter.
        public let action: FilterAction?
        /// The description of the filter.
        public let description: String?
        /// Represents the criteria to be used in the filter for querying findings.
        public let findingCriteria: FindingCriteria?
        /// The name of the filter.
        public let name: String?
        /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
        public let rank: Int?
        /// The tags of the filter resource.
        public let tags: [String: String]?

        @inlinable
        public init(action: FilterAction? = nil, description: String? = nil, findingCriteria: FindingCriteria? = nil, name: String? = nil, rank: Int? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.description = description
            self.findingCriteria = findingCriteria
            self.name = name
            self.rank = rank
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case findingCriteria = "findingCriteria"
            case name = "name"
            case rank = "rank"
            case tags = "tags"
        }
    }

    public struct GetFindingsRequest: AWSEncodableShape {
        /// The ID of the detector that specifies the GuardDuty service whose findings you want to retrieve. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The IDs of the findings that you want to retrieve.
        public let findingIds: [String]?
        /// Represents the criteria used for sorting findings.
        public let sortCriteria: SortCriteria?

        @inlinable
        public init(detectorId: String, findingIds: [String]? = nil, sortCriteria: SortCriteria? = nil) {
            self.detectorId = detectorId
            self.findingIds = findingIds
            self.sortCriteria = sortCriteria
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.findingIds, forKey: .findingIds)
            try container.encodeIfPresent(self.sortCriteria, forKey: .sortCriteria)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.findingIds?.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try self.validate(self.findingIds, name: "findingIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds = "findingIds"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct GetFindingsResponse: AWSDecodableShape {
        /// A list of findings.
        public let findings: [Finding]?

        @inlinable
        public init(findings: [Finding]? = nil) {
            self.findings = findings
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
        }
    }

    public struct GetFindingsStatisticsRequest: AWSEncodableShape {
        /// The ID of the detector whose findings statistics you want to retrieve. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// Represents the criteria that is used for querying findings.
        public let findingCriteria: FindingCriteria?
        /// The types of finding statistics to retrieve.
        public let findingStatisticTypes: [FindingStatisticType]?
        /// Displays the findings statistics grouped by one of the listed valid values.
        public let groupBy: GroupByType?
        /// The maximum number of results to be returned in the response. The default value is 25. You can use this parameter only with the groupBy parameter.
        public let maxResults: Int?
        /// Displays the sorted findings in the requested order. The default value of orderBy is DESC. You can use this parameter only with the groupBy parameter.
        public let orderBy: OrderBy?

        @inlinable
        public init(detectorId: String, findingCriteria: FindingCriteria? = nil, groupBy: GroupByType? = nil, maxResults: Int? = nil, orderBy: OrderBy? = nil) {
            self.detectorId = detectorId
            self.findingCriteria = findingCriteria
            self.findingStatisticTypes = nil
            self.groupBy = groupBy
            self.maxResults = maxResults
            self.orderBy = orderBy
        }

        @available(*, deprecated, message: "Members findingStatisticTypes have been deprecated")
        @inlinable
        public init(detectorId: String, findingCriteria: FindingCriteria? = nil, findingStatisticTypes: [FindingStatisticType]? = nil, groupBy: GroupByType? = nil, maxResults: Int? = nil, orderBy: OrderBy? = nil) {
            self.detectorId = detectorId
            self.findingCriteria = findingCriteria
            self.findingStatisticTypes = findingStatisticTypes
            self.groupBy = groupBy
            self.maxResults = maxResults
            self.orderBy = orderBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.findingCriteria, forKey: .findingCriteria)
            try container.encodeIfPresent(self.findingStatisticTypes, forKey: .findingStatisticTypes)
            try container.encodeIfPresent(self.groupBy, forKey: .groupBy)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.orderBy, forKey: .orderBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.findingStatisticTypes, name: "findingStatisticTypes", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case findingCriteria = "findingCriteria"
            case findingStatisticTypes = "findingStatisticTypes"
            case groupBy = "groupBy"
            case maxResults = "maxResults"
            case orderBy = "orderBy"
        }
    }

    public struct GetFindingsStatisticsResponse: AWSDecodableShape {
        /// The finding statistics object.
        public let findingStatistics: FindingStatistics?
        /// The pagination parameter to be used on the next list operation to retrieve more items. This parameter is currently not supported.
        public let nextToken: String?

        @inlinable
        public init(findingStatistics: FindingStatistics? = nil, nextToken: String? = nil) {
            self.findingStatistics = findingStatistics
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingStatistics = "findingStatistics"
            case nextToken = "nextToken"
        }
    }

    public struct GetIPSetRequest: AWSEncodableShape {
        /// The unique ID of the detector that is associated with the IPSet. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The unique ID of the IPSet to retrieve.
        public let ipSetId: String

        @inlinable
        public init(detectorId: String, ipSetId: String) {
            self.detectorId = detectorId
            self.ipSetId = ipSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodePath(self.ipSetId, key: "ipSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIPSetResponse: AWSDecodableShape {
        /// The format of the file that contains the IPSet.
        public let format: IpSetFormat?
        /// The URI of the file that contains the IPSet.
        public let location: String?
        /// The user-friendly name for the IPSet.
        public let name: String?
        /// The status of IPSet file that was uploaded.
        public let status: IpSetStatus?
        /// The tags of the IPSet resource.
        public let tags: [String: String]?

        @inlinable
        public init(format: IpSetFormat? = nil, location: String? = nil, name: String? = nil, status: IpSetStatus? = nil, tags: [String: String]? = nil) {
            self.format = format
            self.location = location
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case location = "location"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct GetInvitationsCountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetInvitationsCountResponse: AWSDecodableShape {
        /// The number of received invitations.
        public let invitationsCount: Int?

        @inlinable
        public init(invitationsCount: Int? = nil) {
            self.invitationsCount = invitationsCount
        }

        private enum CodingKeys: String, CodingKey {
            case invitationsCount = "invitationsCount"
        }
    }

    public struct GetMalwareProtectionPlanRequest: AWSEncodableShape {
        /// A unique identifier associated with Malware Protection plan resource.
        public let malwareProtectionPlanId: String

        @inlinable
        public init(malwareProtectionPlanId: String) {
            self.malwareProtectionPlanId = malwareProtectionPlanId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.malwareProtectionPlanId, key: "malwareProtectionPlanId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMalwareProtectionPlanResponse: AWSDecodableShape {
        /// Information about whether the tags will be added to the S3 object after scanning.
        public let actions: MalwareProtectionPlanActions?
        /// Amazon Resource Name (ARN) of the protected resource.
        public let arn: String?
        /// The timestamp when the Malware Protection plan resource was created.
        public let createdAt: Date?
        /// Information about the protected resource that is associated with the created  Malware Protection plan. Presently, S3Bucket is the only supported  protected resource.
        public let protectedResource: CreateProtectedResource?
        /// Amazon Resource Name (ARN) of the IAM role that includes the permissions to scan and  add tags to the associated protected resource.
        public let role: String?
        /// Malware Protection plan status.
        public let status: MalwareProtectionPlanStatus?
        /// Information about the issue code and message associated to the status of your Malware Protection plan.
        public let statusReasons: [MalwareProtectionPlanStatusReason]?
        /// Tags added to the Malware Protection plan resource.
        public let tags: [String: String]?

        @inlinable
        public init(actions: MalwareProtectionPlanActions? = nil, arn: String? = nil, createdAt: Date? = nil, protectedResource: CreateProtectedResource? = nil, role: String? = nil, status: MalwareProtectionPlanStatus? = nil, statusReasons: [MalwareProtectionPlanStatusReason]? = nil, tags: [String: String]? = nil) {
            self.actions = actions
            self.arn = arn
            self.createdAt = createdAt
            self.protectedResource = protectedResource
            self.role = role
            self.status = status
            self.statusReasons = statusReasons
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case arn = "arn"
            case createdAt = "createdAt"
            case protectedResource = "protectedResource"
            case role = "role"
            case status = "status"
            case statusReasons = "statusReasons"
            case tags = "tags"
        }
    }

    public struct GetMalwareScanSettingsRequest: AWSEncodableShape {
        /// The unique ID of the detector that is associated with this scan. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMalwareScanSettingsResponse: AWSDecodableShape {
        /// An enum value representing possible snapshot preservation settings.
        public let ebsSnapshotPreservation: EbsSnapshotPreservation?
        /// Represents the criteria to be used in the filter for scanning resources.
        public let scanResourceCriteria: ScanResourceCriteria?

        @inlinable
        public init(ebsSnapshotPreservation: EbsSnapshotPreservation? = nil, scanResourceCriteria: ScanResourceCriteria? = nil) {
            self.ebsSnapshotPreservation = ebsSnapshotPreservation
            self.scanResourceCriteria = scanResourceCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case ebsSnapshotPreservation = "ebsSnapshotPreservation"
            case scanResourceCriteria = "scanResourceCriteria"
        }
    }

    public struct GetMasterAccountRequest: AWSEncodableShape {
        /// The unique ID of the detector of the GuardDuty member account. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMasterAccountResponse: AWSDecodableShape {
        /// The administrator account details.
        public let master: Master?

        @inlinable
        public init(master: Master? = nil) {
            self.master = master
        }

        private enum CodingKeys: String, CodingKey {
            case master = "master"
        }
    }

    public struct GetMemberDetectorsRequest: AWSEncodableShape {
        /// A list of member account IDs.
        public let accountIds: [String]?
        /// The detector ID for the administrator account. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(accountIds: [String]? = nil, detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountIds, forKey: .accountIds)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct GetMemberDetectorsResponse: AWSDecodableShape {
        /// An object that describes which data sources are enabled for a member account.
        public let memberDataSourceConfigurations: [MemberDataSourceConfiguration]?
        /// A list of member account IDs that were unable to be processed along with an explanation for why they were not processed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(memberDataSourceConfigurations: [MemberDataSourceConfiguration]? = nil, unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.memberDataSourceConfigurations = memberDataSourceConfigurations
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case memberDataSourceConfigurations = "members"
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct GetMembersRequest: AWSEncodableShape {
        /// A list of account IDs of the GuardDuty member accounts that you want to describe.
        public let accountIds: [String]?
        /// The unique ID of the detector of the GuardDuty account whose members you want to retrieve. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(accountIds: [String]? = nil, detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountIds, forKey: .accountIds)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct GetMembersResponse: AWSDecodableShape {
        /// A list of members.
        public let members: [Member]?
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(members: [Member]? = nil, unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.members = members
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct GetOrganizationStatisticsResponse: AWSDecodableShape {
        /// Information about the statistics report for your organization.
        public let organizationDetails: OrganizationDetails?

        @inlinable
        public init(organizationDetails: OrganizationDetails? = nil) {
            self.organizationDetails = organizationDetails
        }

        private enum CodingKeys: String, CodingKey {
            case organizationDetails = "organizationDetails"
        }
    }

    public struct GetRemainingFreeTrialDaysRequest: AWSEncodableShape {
        /// A list of account identifiers of the GuardDuty member account.
        public let accountIds: [String]?
        /// The unique ID of the detector of the GuardDuty member account. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(accountIds: [String]? = nil, detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountIds, forKey: .accountIds)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct GetRemainingFreeTrialDaysResponse: AWSDecodableShape {
        /// The member accounts which were included in a request and were processed successfully.
        public let accounts: [AccountFreeTrialInfo]?
        /// The member account that was included in a request but for which the request could not be processed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(accounts: [AccountFreeTrialInfo]? = nil, unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.accounts = accounts
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "accounts"
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct GetThreatIntelSetRequest: AWSEncodableShape {
        /// The unique ID of the detector that is associated with the threatIntelSet. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The unique ID of the threatIntelSet that you want to get.
        public let threatIntelSetId: String

        @inlinable
        public init(detectorId: String, threatIntelSetId: String) {
            self.detectorId = detectorId
            self.threatIntelSetId = threatIntelSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodePath(self.threatIntelSetId, key: "threatIntelSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetThreatIntelSetResponse: AWSDecodableShape {
        /// The format of the threatIntelSet.
        public let format: ThreatIntelSetFormat?
        /// The URI of the file that contains the ThreatIntelSet.
        public let location: String?
        /// A user-friendly ThreatIntelSet name displayed in all findings that are generated by activity that involves IP addresses included in this ThreatIntelSet.
        public let name: String?
        /// The status of threatIntelSet file uploaded.
        public let status: ThreatIntelSetStatus?
        /// The tags of the threat list resource.
        public let tags: [String: String]?

        @inlinable
        public init(format: ThreatIntelSetFormat? = nil, location: String? = nil, name: String? = nil, status: ThreatIntelSetStatus? = nil, tags: [String: String]? = nil) {
            self.format = format
            self.location = location
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case location = "location"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct GetUsageStatisticsRequest: AWSEncodableShape {
        /// The ID of the detector that specifies the GuardDuty service whose usage statistics you want to retrieve. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// The currency unit you would like to view your usage statistics in. Current valid values are USD.
        public let unit: String?
        /// Represents the criteria used for querying usage.
        public let usageCriteria: UsageCriteria?
        /// The type of usage statistics to retrieve.
        public let usageStatisticType: UsageStatisticType?

        @inlinable
        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil, unit: String? = nil, usageCriteria: UsageCriteria? = nil, usageStatisticType: UsageStatisticType? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.unit = unit
            self.usageCriteria = usageCriteria
            self.usageStatisticType = usageStatisticType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.unit, forKey: .unit)
            try container.encodeIfPresent(self.usageCriteria, forKey: .usageCriteria)
            try container.encodeIfPresent(self.usageStatisticType, forKey: .usageStatisticType)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.usageCriteria?.validate(name: "\(name).usageCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case unit = "unit"
            case usageCriteria = "usageCriteria"
            case usageStatisticType = "usageStatisticsType"
        }
    }

    public struct GetUsageStatisticsResponse: AWSDecodableShape {
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?
        /// The usage statistics object. If a UsageStatisticType was provided, the objects representing other types will be null.
        public let usageStatistics: UsageStatistics?

        @inlinable
        public init(nextToken: String? = nil, usageStatistics: UsageStatistics? = nil) {
            self.nextToken = nextToken
            self.usageStatistics = usageStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case usageStatistics = "usageStatistics"
        }
    }

    public struct HighestSeverityThreatDetails: AWSDecodableShape {
        /// Total number of infected files with the highest severity threat detected.
        public let count: Int?
        /// Severity level of the highest severity threat detected.
        public let severity: String?
        /// Threat name of the highest severity threat detected as part of the malware scan.
        public let threatName: String?

        @inlinable
        public init(count: Int? = nil, severity: String? = nil, threatName: String? = nil) {
            self.count = count
            self.severity = severity
            self.threatName = threatName
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case severity = "severity"
            case threatName = "threatName"
        }
    }

    public struct HostPath: AWSDecodableShape {
        /// Path of the file or directory on the host that the volume maps to.
        public let path: String?

        @inlinable
        public init(path: String? = nil) {
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case path = "path"
        }
    }

    public struct IamInstanceProfile: AWSDecodableShape {
        /// The profile ARN of the EC2 instance.
        public let arn: String?
        /// The profile ID of the EC2 instance.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct ImpersonatedUser: AWSDecodableShape {
        /// The group to which the user name belongs.
        public let groups: [String]?
        /// Information about the username that was being impersonated.
        public let username: String?

        @inlinable
        public init(groups: [String]? = nil, username: String? = nil) {
            self.groups = groups
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "groups"
            case username = "username"
        }
    }

    public struct Indicator: AWSDecodableShape {
        /// Specific indicator keys observed in the attack sequence. For description of the valid values for key, see Attack sequence finding details in the Amazon GuardDuty User Guide.
        public let key: IndicatorType?
        /// Title describing the indicator.
        public let title: String?
        /// Values associated with each indicator key. For example, if the indicator key is SUSPICIOUS_NETWORK, then the value will be the name of the network. If the indicator key is ATTACK_TACTIC, then the value will be one of the MITRE tactics.
        public let values: [String]?

        @inlinable
        public init(key: IndicatorType? = nil, title: String? = nil, values: [String]? = nil) {
            self.key = key
            self.title = title
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case title = "title"
            case values = "values"
        }
    }

    public struct InstanceDetails: AWSDecodableShape {
        /// The Availability Zone of the EC2 instance.
        public let availabilityZone: String?
        /// The profile information of the EC2 instance.
        public let iamInstanceProfile: IamInstanceProfile?
        /// The image description of the EC2 instance.
        public let imageDescription: String?
        /// The image ID of the EC2 instance.
        public let imageId: String?
        /// The ID of the EC2 instance.
        public let instanceId: String?
        /// The state of the EC2 instance.
        public let instanceState: String?
        /// The type of the EC2 instance.
        public let instanceType: String?
        /// The launch time of the EC2 instance.
        public let launchTime: String?
        /// The elastic network interface information of the EC2 instance.
        public let networkInterfaces: [NetworkInterface]?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Outpost. Only applicable to Amazon Web Services Outposts instances.
        public let outpostArn: String?
        /// The platform of the EC2 instance.
        public let platform: String?
        /// The product code of the EC2 instance.
        public let productCodes: [ProductCode]?
        /// The tags of the EC2 instance.
        public let tags: [Tag]?

        @inlinable
        public init(availabilityZone: String? = nil, iamInstanceProfile: IamInstanceProfile? = nil, imageDescription: String? = nil, imageId: String? = nil, instanceId: String? = nil, instanceState: String? = nil, instanceType: String? = nil, launchTime: String? = nil, networkInterfaces: [NetworkInterface]? = nil, outpostArn: String? = nil, platform: String? = nil, productCodes: [ProductCode]? = nil, tags: [Tag]? = nil) {
            self.availabilityZone = availabilityZone
            self.iamInstanceProfile = iamInstanceProfile
            self.imageDescription = imageDescription
            self.imageId = imageId
            self.instanceId = instanceId
            self.instanceState = instanceState
            self.instanceType = instanceType
            self.launchTime = launchTime
            self.networkInterfaces = networkInterfaces
            self.outpostArn = outpostArn
            self.platform = platform
            self.productCodes = productCodes
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case iamInstanceProfile = "iamInstanceProfile"
            case imageDescription = "imageDescription"
            case imageId = "imageId"
            case instanceId = "instanceId"
            case instanceState = "instanceState"
            case instanceType = "instanceType"
            case launchTime = "launchTime"
            case networkInterfaces = "networkInterfaces"
            case outpostArn = "outpostArn"
            case platform = "platform"
            case productCodes = "productCodes"
            case tags = "tags"
        }
    }

    public struct InternalServerErrorException: AWSErrorShape {
        /// The error message.
        public let message: String?
        /// The error type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "__type"
        }
    }

    public struct Invitation: AWSDecodableShape {
        /// The ID of the account that the invitation was sent from.
        public let accountId: String?
        /// The ID of the invitation. This value is used to validate the inviter account to the member account.
        public let invitationId: String?
        /// The timestamp when the invitation was sent.
        public let invitedAt: String?
        /// The status of the relationship between the inviter and invitee accounts.
        public let relationshipStatus: String?

        @inlinable
        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: String? = nil, relationshipStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case invitationId = "invitationId"
            case invitedAt = "invitedAt"
            case relationshipStatus = "relationshipStatus"
        }
    }

    public struct InviteMembersRequest: AWSEncodableShape {
        /// A list of account IDs of the accounts that you want to invite to GuardDuty as members.
        public let accountIds: [String]?
        /// The unique ID of the detector of the GuardDuty account with which you want to invite members. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// A Boolean value that specifies whether you want to disable email notification to the accounts that you are inviting to GuardDuty as members.
        public let disableEmailNotification: Bool?
        /// The invitation message that you want to send to the accounts that you're inviting to GuardDuty as members.
        public let message: String?

        @inlinable
        public init(accountIds: [String]? = nil, detectorId: String, disableEmailNotification: Bool? = nil, message: String? = nil) {
            self.accountIds = accountIds
            self.detectorId = detectorId
            self.disableEmailNotification = disableEmailNotification
            self.message = message
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountIds, forKey: .accountIds)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.disableEmailNotification, forKey: .disableEmailNotification)
            try container.encodeIfPresent(self.message, forKey: .message)
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case disableEmailNotification = "disableEmailNotification"
            case message = "message"
        }
    }

    public struct InviteMembersResponse: AWSDecodableShape {
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct ItemPath: AWSDecodableShape {
        /// The hash value of the infected resource.
        public let hash: String?
        /// The nested item path where the infected file was found.
        public let nestedItemPath: String?

        @inlinable
        public init(hash: String? = nil, nestedItemPath: String? = nil) {
            self.hash = hash
            self.nestedItemPath = nestedItemPath
        }

        private enum CodingKeys: String, CodingKey {
            case hash = "hash"
            case nestedItemPath = "nestedItemPath"
        }
    }

    public struct KubernetesApiCallAction: AWSDecodableShape {
        /// The name of the namespace where the Kubernetes API call action takes place.
        public let namespace: String?
        /// Parameters related to the Kubernetes API call action.
        public let parameters: String?
        public let remoteIpDetails: RemoteIpDetails?
        /// The Kubernetes API request URI.
        public let requestUri: String?
        /// The resource component in the Kubernetes API call action.
        public let resource: String?
        /// The name of the resource in the Kubernetes API call action.
        public let resourceName: String?
        /// The IP of the Kubernetes API caller and the IPs of any proxies or load balancers between the caller and the API endpoint.
        public let sourceIps: [String]?
        /// The resulting HTTP response code of the Kubernetes API call action.
        public let statusCode: Int?
        /// The name of the sub-resource in the Kubernetes API call action.
        public let subresource: String?
        /// The user agent of the caller of the Kubernetes API.
        public let userAgent: String?
        /// The Kubernetes API request HTTP verb.
        public let verb: String?

        @inlinable
        public init(namespace: String? = nil, parameters: String? = nil, remoteIpDetails: RemoteIpDetails? = nil, requestUri: String? = nil, resource: String? = nil, resourceName: String? = nil, sourceIps: [String]? = nil, statusCode: Int? = nil, subresource: String? = nil, userAgent: String? = nil, verb: String? = nil) {
            self.namespace = namespace
            self.parameters = parameters
            self.remoteIpDetails = remoteIpDetails
            self.requestUri = requestUri
            self.resource = resource
            self.resourceName = resourceName
            self.sourceIps = sourceIps
            self.statusCode = statusCode
            self.subresource = subresource
            self.userAgent = userAgent
            self.verb = verb
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "namespace"
            case parameters = "parameters"
            case remoteIpDetails = "remoteIpDetails"
            case requestUri = "requestUri"
            case resource = "resource"
            case resourceName = "resourceName"
            case sourceIps = "sourceIPs"
            case statusCode = "statusCode"
            case subresource = "subresource"
            case userAgent = "userAgent"
            case verb = "verb"
        }
    }

    public struct KubernetesAuditLogsConfiguration: AWSEncodableShape {
        /// The status of Kubernetes audit logs as a data source.
        public let enable: Bool?

        @inlinable
        public init(enable: Bool? = nil) {
            self.enable = enable
        }

        private enum CodingKeys: String, CodingKey {
            case enable = "enable"
        }
    }

    public struct KubernetesAuditLogsConfigurationResult: AWSDecodableShape {
        /// A value that describes whether Kubernetes audit logs are enabled as a data source.
        public let status: DataSourceStatus?

        @inlinable
        public init(status: DataSourceStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct KubernetesConfiguration: AWSEncodableShape {
        /// The status of Kubernetes audit logs as a data source.
        public let auditLogs: KubernetesAuditLogsConfiguration?

        @inlinable
        public init(auditLogs: KubernetesAuditLogsConfiguration? = nil) {
            self.auditLogs = auditLogs
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs = "auditLogs"
        }
    }

    public struct KubernetesConfigurationResult: AWSDecodableShape {
        /// Describes whether Kubernetes audit logs are enabled as a data source.
        public let auditLogs: KubernetesAuditLogsConfigurationResult?

        @inlinable
        public init(auditLogs: KubernetesAuditLogsConfigurationResult? = nil) {
            self.auditLogs = auditLogs
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs = "auditLogs"
        }
    }

    public struct KubernetesDataSourceFreeTrial: AWSDecodableShape {
        /// Describes whether Kubernetes audit logs are enabled as a data source.
        public let auditLogs: DataSourceFreeTrial?

        @inlinable
        public init(auditLogs: DataSourceFreeTrial? = nil) {
            self.auditLogs = auditLogs
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs = "auditLogs"
        }
    }

    public struct KubernetesDetails: AWSDecodableShape {
        /// Details about the Kubernetes user involved in a Kubernetes finding.
        public let kubernetesUserDetails: KubernetesUserDetails?
        /// Details about the Kubernetes workload involved in a Kubernetes finding.
        public let kubernetesWorkloadDetails: KubernetesWorkloadDetails?

        @inlinable
        public init(kubernetesUserDetails: KubernetesUserDetails? = nil, kubernetesWorkloadDetails: KubernetesWorkloadDetails? = nil) {
            self.kubernetesUserDetails = kubernetesUserDetails
            self.kubernetesWorkloadDetails = kubernetesWorkloadDetails
        }

        private enum CodingKeys: String, CodingKey {
            case kubernetesUserDetails = "kubernetesUserDetails"
            case kubernetesWorkloadDetails = "kubernetesWorkloadDetails"
        }
    }

    public struct KubernetesPermissionCheckedDetails: AWSDecodableShape {
        /// Information whether the user has the permission to call the Kubernetes API.
        public let allowed: Bool?
        /// The namespace where the Kubernetes API action will take place.
        public let namespace: String?
        /// The Kubernetes resource with which your Kubernetes API call will interact.
        public let resource: String?
        /// The verb component of the Kubernetes API call. For example, when you check whether or not you have the permission to call the CreatePod API, the verb component will be Create.
        public let verb: String?

        @inlinable
        public init(allowed: Bool? = nil, namespace: String? = nil, resource: String? = nil, verb: String? = nil) {
            self.allowed = allowed
            self.namespace = namespace
            self.resource = resource
            self.verb = verb
        }

        private enum CodingKeys: String, CodingKey {
            case allowed = "allowed"
            case namespace = "namespace"
            case resource = "resource"
            case verb = "verb"
        }
    }

    public struct KubernetesRoleBindingDetails: AWSDecodableShape {
        /// The kind of the role. For role binding, this value will be RoleBinding.
        public let kind: String?
        /// The name of the RoleBinding.
        public let name: String?
        /// The type of the role being referenced. This could be either Role or  ClusterRole.
        public let roleRefKind: String?
        /// The name of the role being referenced. This must match the name of the Role or ClusterRole that you want to bind to.
        public let roleRefName: String?
        /// The unique identifier of the role binding.
        public let uid: String?

        @inlinable
        public init(kind: String? = nil, name: String? = nil, roleRefKind: String? = nil, roleRefName: String? = nil, uid: String? = nil) {
            self.kind = kind
            self.name = name
            self.roleRefKind = roleRefKind
            self.roleRefName = roleRefName
            self.uid = uid
        }

        private enum CodingKeys: String, CodingKey {
            case kind = "kind"
            case name = "name"
            case roleRefKind = "roleRefKind"
            case roleRefName = "roleRefName"
            case uid = "uid"
        }
    }

    public struct KubernetesRoleDetails: AWSDecodableShape {
        /// The kind of role. For this API, the value of kind will be Role.
        public let kind: String?
        /// The name of the Kubernetes role.
        public let name: String?
        /// The unique identifier of the Kubernetes role name.
        public let uid: String?

        @inlinable
        public init(kind: String? = nil, name: String? = nil, uid: String? = nil) {
            self.kind = kind
            self.name = name
            self.uid = uid
        }

        private enum CodingKeys: String, CodingKey {
            case kind = "kind"
            case name = "name"
            case uid = "uid"
        }
    }

    public struct KubernetesUserDetails: AWSDecodableShape {
        /// The groups that include the user who called the Kubernetes API.
        public let groups: [String]?
        /// Information about the impersonated user.
        public let impersonatedUser: ImpersonatedUser?
        /// Entity that assumes the IAM role  when Kubernetes RBAC permissions are assigned to that role.
        public let sessionName: [String]?
        /// The user ID of the user who called the Kubernetes API.
        public let uid: String?
        /// The username of the user who called the Kubernetes API.
        public let username: String?

        @inlinable
        public init(groups: [String]? = nil, impersonatedUser: ImpersonatedUser? = nil, sessionName: [String]? = nil, uid: String? = nil, username: String? = nil) {
            self.groups = groups
            self.impersonatedUser = impersonatedUser
            self.sessionName = sessionName
            self.uid = uid
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "groups"
            case impersonatedUser = "impersonatedUser"
            case sessionName = "sessionName"
            case uid = "uid"
            case username = "username"
        }
    }

    public struct KubernetesWorkloadDetails: AWSDecodableShape {
        /// Containers running as part of the Kubernetes workload.
        public let containers: [Container]?
        /// Whether the host IPC flag is enabled for the pods in the workload.
        public let hostIPC: Bool?
        /// Whether the hostNetwork flag is enabled for the pods included in the workload.
        public let hostNetwork: Bool?
        /// Whether the host PID flag is enabled for the pods in the workload.
        public let hostPID: Bool?
        /// Kubernetes workload name.
        public let name: String?
        /// Kubernetes namespace that the workload is part of.
        public let namespace: String?
        /// The service account name that is associated with a Kubernetes workload.
        public let serviceAccountName: String?
        /// Kubernetes workload type (e.g. Pod, Deployment, etc.).
        public let type: String?
        /// Kubernetes workload ID.
        public let uid: String?
        /// Volumes used by the Kubernetes workload.
        public let volumes: [Volume]?

        @inlinable
        public init(containers: [Container]? = nil, hostIPC: Bool? = nil, hostNetwork: Bool? = nil, hostPID: Bool? = nil, name: String? = nil, namespace: String? = nil, serviceAccountName: String? = nil, type: String? = nil, uid: String? = nil, volumes: [Volume]? = nil) {
            self.containers = containers
            self.hostIPC = hostIPC
            self.hostNetwork = hostNetwork
            self.hostPID = hostPID
            self.name = name
            self.namespace = namespace
            self.serviceAccountName = serviceAccountName
            self.type = type
            self.uid = uid
            self.volumes = volumes
        }

        private enum CodingKeys: String, CodingKey {
            case containers = "containers"
            case hostIPC = "hostIPC"
            case hostNetwork = "hostNetwork"
            case hostPID = "hostPID"
            case name = "name"
            case namespace = "namespace"
            case serviceAccountName = "serviceAccountName"
            case type = "type"
            case uid = "uid"
            case volumes = "volumes"
        }
    }

    public struct LambdaDetails: AWSDecodableShape {
        /// Description of the Lambda function.
        public let description: String?
        /// Amazon Resource Name (ARN) of the Lambda function.
        public let functionArn: String?
        /// Name of the Lambda function.
        public let functionName: String?
        /// The version of the Lambda function.
        public let functionVersion: String?
        /// The timestamp when the Lambda function was last modified. This field is in the UTC date string  format (2023-03-22T19:37:20.168Z).
        public let lastModifiedAt: Date?
        /// The revision ID of the Lambda function version.
        public let revisionId: String?
        /// The execution role of the Lambda function.
        public let role: String?
        /// A list of tags attached to this resource, listed in the format of  key:value pair.
        public let tags: [Tag]?
        /// Amazon Virtual Private Cloud configuration details associated with your Lambda function.
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(description: String? = nil, functionArn: String? = nil, functionName: String? = nil, functionVersion: String? = nil, lastModifiedAt: Date? = nil, revisionId: String? = nil, role: String? = nil, tags: [Tag]? = nil, vpcConfig: VpcConfig? = nil) {
            self.description = description
            self.functionArn = functionArn
            self.functionName = functionName
            self.functionVersion = functionVersion
            self.lastModifiedAt = lastModifiedAt
            self.revisionId = revisionId
            self.role = role
            self.tags = tags
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case functionArn = "functionArn"
            case functionName = "functionName"
            case functionVersion = "functionVersion"
            case lastModifiedAt = "lastModifiedAt"
            case revisionId = "revisionId"
            case role = "role"
            case tags = "tags"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct LineageObject: AWSDecodableShape {
        /// The effective user ID that was used to execute the process.
        public let euid: Int?
        /// The absolute path of the process executable file.
        public let executablePath: String?
        /// The name of the process.
        public let name: String?
        /// The process ID of the child process.
        public let namespacePid: Int?
        /// The unique ID of the parent process. This ID is assigned to the parent process by GuardDuty.
        public let parentUuid: String?
        /// The ID of the process.
        public let pid: Int?
        /// The time when the process started. This is in UTC format.
        public let startTime: Date?
        /// The user ID of the user that executed the process.
        public let userId: Int?
        /// The unique ID assigned to the process by GuardDuty.
        public let uuid: String?

        @inlinable
        public init(euid: Int? = nil, executablePath: String? = nil, name: String? = nil, namespacePid: Int? = nil, parentUuid: String? = nil, pid: Int? = nil, startTime: Date? = nil, userId: Int? = nil, uuid: String? = nil) {
            self.euid = euid
            self.executablePath = executablePath
            self.name = name
            self.namespacePid = namespacePid
            self.parentUuid = parentUuid
            self.pid = pid
            self.startTime = startTime
            self.userId = userId
            self.uuid = uuid
        }

        private enum CodingKeys: String, CodingKey {
            case euid = "euid"
            case executablePath = "executablePath"
            case name = "name"
            case namespacePid = "namespacePid"
            case parentUuid = "parentUuid"
            case pid = "pid"
            case startTime = "startTime"
            case userId = "userId"
            case uuid = "uuid"
        }
    }

    public struct ListCoverageRequest: AWSEncodableShape {
        /// The unique ID of the detector whose coverage details you want to retrieve. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// Represents the criteria used to filter the coverage details.
        public let filterCriteria: CoverageFilterCriteria?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// Represents the criteria used to sort the coverage details.
        public let sortCriteria: CoverageSortCriteria?

        @inlinable
        public init(detectorId: String, filterCriteria: CoverageFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: CoverageSortCriteria? = nil) {
            self.detectorId = detectorId
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.filterCriteria, forKey: .filterCriteria)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortCriteria, forKey: .sortCriteria)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct ListCoverageResponse: AWSDecodableShape {
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?
        /// A list of resources and their attributes providing cluster details.
        public let resources: [CoverageResource]?

        @inlinable
        public init(nextToken: String? = nil, resources: [CoverageResource]? = nil) {
            self.nextToken = nextToken
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resources = "resources"
        }
    }

    public struct ListDetectorsRequest: AWSEncodableShape {
        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDetectorsResponse: AWSDecodableShape {
        /// A list of detector IDs.
        public let detectorIds: [String]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        @inlinable
        public init(detectorIds: [String]? = nil, nextToken: String? = nil) {
            self.detectorIds = detectorIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case detectorIds = "detectorIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListFiltersRequest: AWSEncodableShape {
        /// The unique ID of the detector that is associated with the filter. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        @inlinable
        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFiltersResponse: AWSDecodableShape {
        /// A list of filter names.
        public let filterNames: [String]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        @inlinable
        public init(filterNames: [String]? = nil, nextToken: String? = nil) {
            self.filterNames = filterNames
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filterNames = "filterNames"
            case nextToken = "nextToken"
        }
    }

    public struct ListFindingsRequest: AWSEncodableShape {
        /// The ID of the detector that specifies the GuardDuty service whose findings you want to list. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// Represents the criteria used for querying findings. Valid values include:   JSON field name   accountId   region   confidence   id   resource.accessKeyDetails.accessKeyId   resource.accessKeyDetails.principalId   resource.accessKeyDetails.userName   resource.accessKeyDetails.userType   resource.instanceDetails.iamInstanceProfile.id   resource.instanceDetails.imageId   resource.instanceDetails.instanceId   resource.instanceDetails.networkInterfaces.ipv6Addresses   resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress   resource.instanceDetails.networkInterfaces.publicDnsName   resource.instanceDetails.networkInterfaces.publicIp   resource.instanceDetails.networkInterfaces.securityGroups.groupId   resource.instanceDetails.networkInterfaces.securityGroups.groupName   resource.instanceDetails.networkInterfaces.subnetId   resource.instanceDetails.networkInterfaces.vpcId   resource.instanceDetails.tags.key   resource.instanceDetails.tags.value   resource.resourceType   service.action.actionType   service.action.awsApiCallAction.api   service.action.awsApiCallAction.callerType   service.action.awsApiCallAction.remoteIpDetails.city.cityName   service.action.awsApiCallAction.remoteIpDetails.country.countryName   service.action.awsApiCallAction.remoteIpDetails.ipAddressV4   service.action.awsApiCallAction.remoteIpDetails.organization.asn   service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg   service.action.awsApiCallAction.serviceName   service.action.dnsRequestAction.domain   service.action.dnsRequestAction.domainWithSuffix   service.action.networkConnectionAction.blocked   service.action.networkConnectionAction.connectionDirection   service.action.networkConnectionAction.localPortDetails.port   service.action.networkConnectionAction.protocol   service.action.networkConnectionAction.remoteIpDetails.country.countryName   service.action.networkConnectionAction.remoteIpDetails.ipAddressV4   service.action.networkConnectionAction.remoteIpDetails.organization.asn   service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg   service.action.networkConnectionAction.remotePortDetails.port   service.additionalInfo.threatListName   service.archived When this attribute is set to 'true', only archived findings are listed. When it's set to 'false', only unarchived findings are listed. When this attribute is not set, all existing findings are listed.   service.ebsVolumeScanDetails.scanId   service.resourceRole   severity   type   updatedAt Type: Timestamp in Unix Epoch millisecond format: 1486685375000
        public let findingCriteria: FindingCriteria?
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// Represents the criteria used for sorting findings.
        public let sortCriteria: SortCriteria?

        @inlinable
        public init(detectorId: String, findingCriteria: FindingCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: SortCriteria? = nil) {
            self.detectorId = detectorId
            self.findingCriteria = findingCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.findingCriteria, forKey: .findingCriteria)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortCriteria, forKey: .sortCriteria)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case findingCriteria = "findingCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct ListFindingsResponse: AWSDecodableShape {
        /// The IDs of the findings that you're listing.
        public let findingIds: [String]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        @inlinable
        public init(findingIds: [String]? = nil, nextToken: String? = nil) {
            self.findingIds = findingIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds = "findingIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListIPSetsRequest: AWSEncodableShape {
        /// The unique ID of the detector that is associated with IPSet. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        @inlinable
        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIPSetsResponse: AWSDecodableShape {
        /// The IDs of the IPSet resources.
        public let ipSetIds: [String]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        @inlinable
        public init(ipSetIds: [String]? = nil, nextToken: String? = nil) {
            self.ipSetIds = ipSetIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ipSetIds = "ipSetIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListInvitationsRequest: AWSEncodableShape {
        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInvitationsResponse: AWSDecodableShape {
        /// A list of invitation descriptions.
        public let invitations: [Invitation]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        @inlinable
        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "invitations"
            case nextToken = "nextToken"
        }
    }

    public struct ListMalwareProtectionPlansRequest: AWSEncodableShape {
        /// You can use this parameter when paginating results. Set the value  of this parameter to null on your first call to the list action.  For subsequent calls to the action, fill nextToken in the request  with the value of NextToken from the previous response to  continue listing data.
        public let nextToken: String?

        @inlinable
        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMalwareProtectionPlansResponse: AWSDecodableShape {
        /// A list of unique identifiers associated with each Malware Protection plan.
        public let malwareProtectionPlans: [MalwareProtectionPlanSummary]?
        /// You can use this parameter when paginating results. Set the value  of this parameter to null on your first call to the list action.  For subsequent calls to the action, fill nextToken in the request  with the value of NextToken from the previous response to  continue listing data.
        public let nextToken: String?

        @inlinable
        public init(malwareProtectionPlans: [MalwareProtectionPlanSummary]? = nil, nextToken: String? = nil) {
            self.malwareProtectionPlans = malwareProtectionPlans
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case malwareProtectionPlans = "malwareProtectionPlans"
            case nextToken = "nextToken"
        }
    }

    public struct ListMembersRequest: AWSEncodableShape {
        /// The unique ID of the detector that is associated with the member. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// Specifies whether to only return associated members or to return all members (including members who haven't been invited yet or have been disassociated). Member accounts must have been previously associated with the GuardDuty administrator account using  Create Members .
        public let onlyAssociated: String?

        @inlinable
        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil, onlyAssociated: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.onlyAssociated = onlyAssociated
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.onlyAssociated, key: "onlyAssociated")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersResponse: AWSDecodableShape {
        /// A list of members.  The values for email and invitedAt are available only if the member accounts are added by invitation.
        public let members: [Member]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        @inlinable
        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListOrganizationAdminAccountsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOrganizationAdminAccountsResponse: AWSDecodableShape {
        /// A list of accounts configured as GuardDuty delegated administrators.
        public let adminAccounts: [AdminAccount]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        @inlinable
        public init(adminAccounts: [AdminAccount]? = nil, nextToken: String? = nil) {
            self.adminAccounts = adminAccounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccounts = "adminAccounts"
            case nextToken = "nextToken"
        }
    }

    public struct ListPublishingDestinationsRequest: AWSEncodableShape {
        /// The detector ID for which you want to retrieve the publishing destination. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPublishingDestinationsResponse: AWSDecodableShape {
        /// A Destinations object that includes information about each publishing destination returned.
        public let destinations: [Destination]?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(destinations: [Destination]? = nil, nextToken: String? = nil) {
            self.destinations = destinations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "destinations"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the given GuardDuty resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\\d+:detector/[A-Za-z0-9_/.-]{32,264}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListThreatIntelSetsRequest: AWSEncodableShape {
        /// The unique ID of the detector that is associated with the threatIntelSet. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter to paginate results in the response. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        @inlinable
        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThreatIntelSetsResponse: AWSDecodableShape {
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?
        /// The IDs of the ThreatIntelSet resources.
        public let threatIntelSetIds: [String]?

        @inlinable
        public init(nextToken: String? = nil, threatIntelSetIds: [String]? = nil) {
            self.nextToken = nextToken
            self.threatIntelSetIds = threatIntelSetIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case threatIntelSetIds = "threatIntelSetIds"
        }
    }

    public struct LocalIpDetails: AWSDecodableShape {
        /// The IPv4 local address of the connection.
        public let ipAddressV4: String?
        /// The IPv6 local address of the connection.
        public let ipAddressV6: String?

        @inlinable
        public init(ipAddressV4: String? = nil, ipAddressV6: String? = nil) {
            self.ipAddressV4 = ipAddressV4
            self.ipAddressV6 = ipAddressV6
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddressV4 = "ipAddressV4"
            case ipAddressV6 = "ipAddressV6"
        }
    }

    public struct LocalPortDetails: AWSDecodableShape {
        /// The port number of the local connection.
        public let port: Int?
        /// The port name of the local connection.
        public let portName: String?

        @inlinable
        public init(port: Int? = nil, portName: String? = nil) {
            self.port = port
            self.portName = portName
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case portName = "portName"
        }
    }

    public struct LoginAttribute: AWSDecodableShape {
        /// Indicates the application name used to attempt log in.
        public let application: String?
        /// Represents the sum of failed (unsuccessful) login attempts made to establish a connection to the database instance.
        public let failedLoginAttempts: Int?
        /// Represents the sum of successful connections (a correct combination of login attributes) made to the database instance by the actor.
        public let successfulLoginAttempts: Int?
        /// Indicates the user name which attempted to log in.
        public let user: String?

        @inlinable
        public init(application: String? = nil, failedLoginAttempts: Int? = nil, successfulLoginAttempts: Int? = nil, user: String? = nil) {
            self.application = application
            self.failedLoginAttempts = failedLoginAttempts
            self.successfulLoginAttempts = successfulLoginAttempts
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case failedLoginAttempts = "failedLoginAttempts"
            case successfulLoginAttempts = "successfulLoginAttempts"
            case user = "user"
        }
    }

    public struct MalwareProtectionConfiguration: AWSEncodableShape {
        /// Describes the configuration of Malware Protection for EC2 instances with findings.
        public let scanEc2InstanceWithFindings: ScanEc2InstanceWithFindings?

        @inlinable
        public init(scanEc2InstanceWithFindings: ScanEc2InstanceWithFindings? = nil) {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }

        private enum CodingKeys: String, CodingKey {
            case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
        }
    }

    public struct MalwareProtectionConfigurationResult: AWSDecodableShape {
        /// Describes the configuration of Malware Protection for EC2 instances with findings.
        public let scanEc2InstanceWithFindings: ScanEc2InstanceWithFindingsResult?
        /// The GuardDuty Malware Protection service role.
        public let serviceRole: String?

        @inlinable
        public init(scanEc2InstanceWithFindings: ScanEc2InstanceWithFindingsResult? = nil, serviceRole: String? = nil) {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
            self.serviceRole = serviceRole
        }

        private enum CodingKeys: String, CodingKey {
            case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
            case serviceRole = "serviceRole"
        }
    }

    public struct MalwareProtectionDataSourceFreeTrial: AWSDecodableShape {
        /// Describes whether Malware Protection for EC2 instances with findings is enabled as a data source.
        public let scanEc2InstanceWithFindings: DataSourceFreeTrial?

        @inlinable
        public init(scanEc2InstanceWithFindings: DataSourceFreeTrial? = nil) {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }

        private enum CodingKeys: String, CodingKey {
            case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
        }
    }

    public struct MalwareProtectionPlanActions: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the scanned S3 object will have tags about the scan result.
        public let tagging: MalwareProtectionPlanTaggingAction?

        @inlinable
        public init(tagging: MalwareProtectionPlanTaggingAction? = nil) {
            self.tagging = tagging
        }

        private enum CodingKeys: String, CodingKey {
            case tagging = "tagging"
        }
    }

    public struct MalwareProtectionPlanStatusReason: AWSDecodableShape {
        /// Issue code.
        public let code: String?
        /// Issue message that specifies the reason. For information about potential troubleshooting steps, see Troubleshooting Malware Protection for S3 status issues in the  Amazon GuardDuty User Guide.
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct MalwareProtectionPlanSummary: AWSDecodableShape {
        /// A unique identifier associated with Malware Protection plan.
        public let malwareProtectionPlanId: String?

        @inlinable
        public init(malwareProtectionPlanId: String? = nil) {
            self.malwareProtectionPlanId = malwareProtectionPlanId
        }

        private enum CodingKeys: String, CodingKey {
            case malwareProtectionPlanId = "malwareProtectionPlanId"
        }
    }

    public struct MalwareProtectionPlanTaggingAction: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether or not the tags will added.
        public let status: MalwareProtectionPlanTaggingActionStatus?

        @inlinable
        public init(status: MalwareProtectionPlanTaggingActionStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct MalwareScanDetails: AWSDecodableShape {
        /// Information about the detected threats associated with the generated GuardDuty finding.
        public let threats: [Threat]?

        @inlinable
        public init(threats: [Threat]? = nil) {
            self.threats = threats
        }

        private enum CodingKeys: String, CodingKey {
            case threats = "threats"
        }
    }

    public struct Master: AWSDecodableShape {
        /// The ID of the account used as the administrator account.
        public let accountId: String?
        /// The value used to validate the administrator account to the member account.
        public let invitationId: String?
        /// The timestamp when the invitation was sent.
        public let invitedAt: String?
        /// The status of the relationship between the administrator and member accounts.
        public let relationshipStatus: String?

        @inlinable
        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: String? = nil, relationshipStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case invitationId = "invitationId"
            case invitedAt = "invitedAt"
            case relationshipStatus = "relationshipStatus"
        }
    }

    public struct Member: AWSDecodableShape {
        /// The ID of the member account.
        public let accountId: String?
        /// The administrator account ID.
        public let administratorId: String?
        /// The detector ID of the member account.
        public let detectorId: String?
        /// The email address of the member account.
        public let email: String?
        /// The timestamp when the invitation was sent.
        public let invitedAt: String?
        /// The administrator account ID.
        public let masterId: String?
        /// The status of the relationship between the member and the administrator.
        public let relationshipStatus: String?
        /// The last-updated timestamp of the member.
        public let updatedAt: String?

        @inlinable
        public init(accountId: String? = nil, administratorId: String? = nil, detectorId: String? = nil, email: String? = nil, invitedAt: String? = nil, masterId: String? = nil, relationshipStatus: String? = nil, updatedAt: String? = nil) {
            self.accountId = accountId
            self.administratorId = administratorId
            self.detectorId = detectorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.relationshipStatus = relationshipStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case administratorId = "administratorId"
            case detectorId = "detectorId"
            case email = "email"
            case invitedAt = "invitedAt"
            case masterId = "masterId"
            case relationshipStatus = "relationshipStatus"
            case updatedAt = "updatedAt"
        }
    }

    public struct MemberAdditionalConfiguration: AWSEncodableShape {
        /// Name of the additional configuration.
        public let name: OrgFeatureAdditionalConfiguration?
        /// Status of the additional configuration.
        public let status: FeatureStatus?

        @inlinable
        public init(name: OrgFeatureAdditionalConfiguration? = nil, status: FeatureStatus? = nil) {
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
        }
    }

    public struct MemberAdditionalConfigurationResult: AWSDecodableShape {
        /// Indicates the name of the additional configuration that is set for the member account.
        public let name: OrgFeatureAdditionalConfiguration?
        /// Indicates the status of the additional configuration that is set for the member account.
        public let status: FeatureStatus?
        /// The timestamp at which the additional configuration was set for the member account. This is in UTC format.
        public let updatedAt: Date?

        @inlinable
        public init(name: OrgFeatureAdditionalConfiguration? = nil, status: FeatureStatus? = nil, updatedAt: Date? = nil) {
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct MemberDataSourceConfiguration: AWSDecodableShape {
        /// The account ID for the member account.
        public let accountId: String?
        /// Contains information on the status of data sources for the account.
        public let dataSources: DataSourceConfigurationsResult?
        /// Contains information about the status of the features for the member account.
        public let features: [MemberFeaturesConfigurationResult]?

        @inlinable
        public init(accountId: String? = nil, features: [MemberFeaturesConfigurationResult]? = nil) {
            self.accountId = accountId
            self.dataSources = nil
            self.features = features
        }

        @available(*, deprecated, message: "Members dataSources have been deprecated")
        @inlinable
        public init(accountId: String? = nil, dataSources: DataSourceConfigurationsResult? = nil, features: [MemberFeaturesConfigurationResult]? = nil) {
            self.accountId = accountId
            self.dataSources = dataSources
            self.features = features
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case dataSources = "dataSources"
            case features = "features"
        }
    }

    public struct MemberFeaturesConfiguration: AWSEncodableShape {
        /// Additional configuration of the feature for the member account.
        public let additionalConfiguration: [MemberAdditionalConfiguration]?
        /// The name of the feature.
        public let name: OrgFeature?
        /// The status of the feature.
        public let status: FeatureStatus?

        @inlinable
        public init(additionalConfiguration: [MemberAdditionalConfiguration]? = nil, name: OrgFeature? = nil, status: FeatureStatus? = nil) {
            self.additionalConfiguration = additionalConfiguration
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case additionalConfiguration = "additionalConfiguration"
            case name = "name"
            case status = "status"
        }
    }

    public struct MemberFeaturesConfigurationResult: AWSDecodableShape {
        /// Indicates the additional configuration of the feature that is configured for the member account.
        public let additionalConfiguration: [MemberAdditionalConfigurationResult]?
        /// Indicates the name of the feature that is enabled for the detector.
        public let name: OrgFeature?
        /// Indicates the status of the feature that is enabled for the detector.
        public let status: FeatureStatus?
        /// The timestamp at which the feature object was updated.
        public let updatedAt: Date?

        @inlinable
        public init(additionalConfiguration: [MemberAdditionalConfigurationResult]? = nil, name: OrgFeature? = nil, status: FeatureStatus? = nil, updatedAt: Date? = nil) {
            self.additionalConfiguration = additionalConfiguration
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case additionalConfiguration = "additionalConfiguration"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct NetworkConnection: AWSDecodableShape {
        /// The direction in which the network traffic is flowing.
        public let direction: NetworkDirection?

        @inlinable
        public init(direction: NetworkDirection? = nil) {
            self.direction = direction
        }

        private enum CodingKeys: String, CodingKey {
            case direction = "direction"
        }
    }

    public struct NetworkConnectionAction: AWSDecodableShape {
        /// Indicates whether EC2 blocked the network connection to your instance.
        public let blocked: Bool?
        /// The network connection direction.
        public let connectionDirection: String?
        /// The local IP information of the connection.
        public let localIpDetails: LocalIpDetails?
        /// The EC2 instance's local elastic network interface utilized for the connection.
        public let localNetworkInterface: String?
        /// The local port information of the connection.
        public let localPortDetails: LocalPortDetails?
        /// The network connection protocol.
        public let `protocol`: String?
        /// The remote IP information of the connection.
        public let remoteIpDetails: RemoteIpDetails?
        /// The remote port information of the connection.
        public let remotePortDetails: RemotePortDetails?

        @inlinable
        public init(blocked: Bool? = nil, connectionDirection: String? = nil, localIpDetails: LocalIpDetails? = nil, localNetworkInterface: String? = nil, localPortDetails: LocalPortDetails? = nil, protocol: String? = nil, remoteIpDetails: RemoteIpDetails? = nil, remotePortDetails: RemotePortDetails? = nil) {
            self.blocked = blocked
            self.connectionDirection = connectionDirection
            self.localIpDetails = localIpDetails
            self.localNetworkInterface = localNetworkInterface
            self.localPortDetails = localPortDetails
            self.`protocol` = `protocol`
            self.remoteIpDetails = remoteIpDetails
            self.remotePortDetails = remotePortDetails
        }

        private enum CodingKeys: String, CodingKey {
            case blocked = "blocked"
            case connectionDirection = "connectionDirection"
            case localIpDetails = "localIpDetails"
            case localNetworkInterface = "localNetworkInterface"
            case localPortDetails = "localPortDetails"
            case `protocol` = "protocol"
            case remoteIpDetails = "remoteIpDetails"
            case remotePortDetails = "remotePortDetails"
        }
    }

    public struct NetworkEndpoint: AWSDecodableShape {
        /// The Autonomous System (AS) of the network endpoint.
        public let autonomousSystem: AutonomousSystem?
        /// Information about the network connection.
        public let connection: NetworkConnection?
        /// The domain information for the network endpoint.
        public let domain: String?
        /// The ID of the network endpoint.
        public let id: String?
        /// The IP address associated with the network endpoint.
        public let ip: String?
        /// Information about the location of the network endpoint.
        public let location: NetworkGeoLocation?
        /// The port number associated with the network endpoint.
        public let port: Int?

        @inlinable
        public init(autonomousSystem: AutonomousSystem? = nil, connection: NetworkConnection? = nil, domain: String? = nil, id: String? = nil, ip: String? = nil, location: NetworkGeoLocation? = nil, port: Int? = nil) {
            self.autonomousSystem = autonomousSystem
            self.connection = connection
            self.domain = domain
            self.id = id
            self.ip = ip
            self.location = location
            self.port = port
        }

        private enum CodingKeys: String, CodingKey {
            case autonomousSystem = "autonomousSystem"
            case connection = "connection"
            case domain = "domain"
            case id = "id"
            case ip = "ip"
            case location = "location"
            case port = "port"
        }
    }

    public struct NetworkGeoLocation: AWSDecodableShape {
        /// The name of the city.
        public let city: String?
        /// The name of the country.
        public let country: String?
        /// The latitude information of the endpoint location.
        public let latitude: Double?
        /// The longitude information of the endpoint location.
        public let longitude: Double?

        @inlinable
        public init(city: String? = nil, country: String? = nil, latitude: Double? = nil, longitude: Double? = nil) {
            self.city = city
            self.country = country
            self.latitude = latitude
            self.longitude = longitude
        }

        private enum CodingKeys: String, CodingKey {
            case city = "city"
            case country = "country"
            case latitude = "lat"
            case longitude = "lon"
        }
    }

    public struct NetworkInterface: AWSDecodableShape {
        /// A list of IPv6 addresses for the EC2 instance.
        public let ipv6Addresses: [String]?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The private DNS name of the EC2 instance.
        public let privateDnsName: String?
        /// The private IP address of the EC2 instance.
        public let privateIpAddress: String?
        /// Other private IP address information of the EC2 instance.
        public let privateIpAddresses: [PrivateIpAddressDetails]?
        /// The public DNS name of the EC2 instance.
        public let publicDnsName: String?
        /// The public IP address of the EC2 instance.
        public let publicIp: String?
        /// The security groups associated with the EC2 instance.
        public let securityGroups: [SecurityGroup]?
        /// The subnet ID of the EC2 instance.
        public let subnetId: String?
        /// The VPC ID of the EC2 instance.
        public let vpcId: String?

        @inlinable
        public init(ipv6Addresses: [String]? = nil, networkInterfaceId: String? = nil, privateDnsName: String? = nil, privateIpAddress: String? = nil, privateIpAddresses: [PrivateIpAddressDetails]? = nil, publicDnsName: String? = nil, publicIp: String? = nil, securityGroups: [SecurityGroup]? = nil, subnetId: String? = nil, vpcId: String? = nil) {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6Addresses = "ipv6Addresses"
            case networkInterfaceId = "networkInterfaceId"
            case privateDnsName = "privateDnsName"
            case privateIpAddress = "privateIpAddress"
            case privateIpAddresses = "privateIpAddresses"
            case publicDnsName = "publicDnsName"
            case publicIp = "publicIp"
            case securityGroups = "securityGroups"
            case subnetId = "subnetId"
            case vpcId = "vpcId"
        }
    }

    public struct Observations: AWSDecodableShape {
        /// The text that was unusual.
        public let text: [String]?

        @inlinable
        public init(text: [String]? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct Organization: AWSDecodableShape {
        /// The Autonomous System Number (ASN) of the internet provider of the remote IP address.
        public let asn: String?
        /// The organization that registered this ASN.
        public let asnOrg: String?
        /// The ISP information for the internet provider.
        public let isp: String?
        /// The name of the internet provider.
        public let org: String?

        @inlinable
        public init(asn: String? = nil, asnOrg: String? = nil, isp: String? = nil, org: String? = nil) {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }

        private enum CodingKeys: String, CodingKey {
            case asn = "asn"
            case asnOrg = "asnOrg"
            case isp = "isp"
            case org = "org"
        }
    }

    public struct OrganizationAdditionalConfiguration: AWSEncodableShape {
        /// The status of the additional configuration that will be configured for the organization. Use one of the following  values to configure the feature status for the entire organization:    NEW: Indicates that when a new account joins the organization, they will have the additional configuration enabled automatically.     ALL: Indicates that all accounts in the organization have  the additional configuration enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty. It may take up to 24 hours to update the configuration for all the member accounts.    NONE: Indicates that the additional configuration will not be  automatically enabled for any account in the organization. The administrator must manage the additional configuration  for each account individually.
        public let autoEnable: OrgFeatureStatus?
        /// The name of the additional configuration that will be configured for the organization. These values are applicable to only Runtime Monitoring protection plan.
        public let name: OrgFeatureAdditionalConfiguration?

        @inlinable
        public init(autoEnable: OrgFeatureStatus? = nil, name: OrgFeatureAdditionalConfiguration? = nil) {
            self.autoEnable = autoEnable
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
            case name = "name"
        }
    }

    public struct OrganizationAdditionalConfigurationResult: AWSDecodableShape {
        /// Describes the status of the additional configuration that is configured for the member accounts within the organization. One of the following  values is the status for the entire organization:    NEW: Indicates that when a new account joins the organization, they will have the additional configuration enabled automatically.     ALL: Indicates that all accounts in the organization have  the additional configuration enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty. It may take up to 24 hours to update the configuration for all the member accounts.    NONE: Indicates that the additional configuration will not be  automatically enabled for any account in the organization. The administrator must manage the additional configuration  for each account individually.
        public let autoEnable: OrgFeatureStatus?
        /// The name of the additional configuration that is configured for the member accounts within the organization. These values are applicable to only Runtime Monitoring protection plan.
        public let name: OrgFeatureAdditionalConfiguration?

        @inlinable
        public init(autoEnable: OrgFeatureStatus? = nil, name: OrgFeatureAdditionalConfiguration? = nil) {
            self.autoEnable = autoEnable
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
            case name = "name"
        }
    }

    public struct OrganizationDataSourceConfigurations: AWSEncodableShape {
        /// Describes the configuration of Kubernetes data sources for new members of the organization.
        public let kubernetes: OrganizationKubernetesConfiguration?
        /// Describes the configuration of Malware Protection for new members of the organization.
        public let malwareProtection: OrganizationMalwareProtectionConfiguration?
        /// Describes whether S3 data event logs are enabled for new members of the organization.
        public let s3Logs: OrganizationS3LogsConfiguration?

        @inlinable
        public init(kubernetes: OrganizationKubernetesConfiguration? = nil, malwareProtection: OrganizationMalwareProtectionConfiguration? = nil, s3Logs: OrganizationS3LogsConfiguration? = nil) {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }

        private enum CodingKeys: String, CodingKey {
            case kubernetes = "kubernetes"
            case malwareProtection = "malwareProtection"
            case s3Logs = "s3Logs"
        }
    }

    public struct OrganizationDataSourceConfigurationsResult: AWSDecodableShape {
        /// Describes the configuration of Kubernetes data sources.
        public let kubernetes: OrganizationKubernetesConfigurationResult?
        /// Describes the configuration of Malware Protection data source for an organization.
        public let malwareProtection: OrganizationMalwareProtectionConfigurationResult?
        /// Describes whether S3 data event logs are enabled as a data source.
        public let s3Logs: OrganizationS3LogsConfigurationResult?

        @inlinable
        public init(kubernetes: OrganizationKubernetesConfigurationResult? = nil, malwareProtection: OrganizationMalwareProtectionConfigurationResult? = nil, s3Logs: OrganizationS3LogsConfigurationResult? = nil) {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }

        private enum CodingKeys: String, CodingKey {
            case kubernetes = "kubernetes"
            case malwareProtection = "malwareProtection"
            case s3Logs = "s3Logs"
        }
    }

    public struct OrganizationDetails: AWSDecodableShape {
        /// Information about the GuardDuty coverage statistics  for members in your Amazon Web Services organization.
        public let organizationStatistics: OrganizationStatistics?
        /// The timestamp at which the organization statistics was last updated. This is in UTC format.
        public let updatedAt: Date?

        @inlinable
        public init(organizationStatistics: OrganizationStatistics? = nil, updatedAt: Date? = nil) {
            self.organizationStatistics = organizationStatistics
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case organizationStatistics = "organizationStatistics"
            case updatedAt = "updatedAt"
        }
    }

    public struct OrganizationEbsVolumes: AWSEncodableShape {
        /// Whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public let autoEnable: Bool?

        @inlinable
        public init(autoEnable: Bool? = nil) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
        }
    }

    public struct OrganizationEbsVolumesResult: AWSDecodableShape {
        /// An object that contains the status of whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public let autoEnable: Bool?

        @inlinable
        public init(autoEnable: Bool? = nil) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
        }
    }

    public struct OrganizationFeatureConfiguration: AWSEncodableShape {
        /// The additional information that will be configured for the organization.
        public let additionalConfiguration: [OrganizationAdditionalConfiguration]?
        /// Describes the status of the feature that is configured for the member accounts within the organization. One of the following  values is the status for the entire organization:    NEW: Indicates that when a new account joins the organization, they will have the feature enabled automatically.     ALL: Indicates that all accounts in the organization have the feature enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty. It may take up to 24 hours to update the configuration for all the member accounts.    NONE: Indicates that the feature will not be  automatically enabled for any account in the organization. The administrator must manage the feature for each account individually.
        public let autoEnable: OrgFeatureStatus?
        /// The name of the feature that will be configured for the organization.
        public let name: OrgFeature?

        @inlinable
        public init(additionalConfiguration: [OrganizationAdditionalConfiguration]? = nil, autoEnable: OrgFeatureStatus? = nil, name: OrgFeature? = nil) {
            self.additionalConfiguration = additionalConfiguration
            self.autoEnable = autoEnable
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case additionalConfiguration = "additionalConfiguration"
            case autoEnable = "autoEnable"
            case name = "name"
        }
    }

    public struct OrganizationFeatureConfigurationResult: AWSDecodableShape {
        /// The additional configuration that is configured for the member accounts within the organization.
        public let additionalConfiguration: [OrganizationAdditionalConfigurationResult]?
        /// Describes the status of the feature that is configured for the member accounts within the organization.    NEW: Indicates that when a new account joins the organization, they will have the feature enabled automatically.     ALL: Indicates that all accounts in the organization have the feature  enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty.    NONE: Indicates that the feature will not be automatically enabled for any account in the organization. In this case, each account will be managed individually  by the administrator.
        public let autoEnable: OrgFeatureStatus?
        /// The name of the feature that is configured for the member accounts within the organization.
        public let name: OrgFeature?

        @inlinable
        public init(additionalConfiguration: [OrganizationAdditionalConfigurationResult]? = nil, autoEnable: OrgFeatureStatus? = nil, name: OrgFeature? = nil) {
            self.additionalConfiguration = additionalConfiguration
            self.autoEnable = autoEnable
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case additionalConfiguration = "additionalConfiguration"
            case autoEnable = "autoEnable"
            case name = "name"
        }
    }

    public struct OrganizationFeatureStatistics: AWSDecodableShape {
        /// Name of the additional configuration.
        public let additionalConfiguration: [OrganizationFeatureStatisticsAdditionalConfiguration]?
        /// Total number of accounts that have enabled a specific feature.
        public let enabledAccountsCount: Int?
        /// Name of the feature.
        public let name: OrgFeature?

        @inlinable
        public init(additionalConfiguration: [OrganizationFeatureStatisticsAdditionalConfiguration]? = nil, enabledAccountsCount: Int? = nil, name: OrgFeature? = nil) {
            self.additionalConfiguration = additionalConfiguration
            self.enabledAccountsCount = enabledAccountsCount
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case additionalConfiguration = "additionalConfiguration"
            case enabledAccountsCount = "enabledAccountsCount"
            case name = "name"
        }
    }

    public struct OrganizationFeatureStatisticsAdditionalConfiguration: AWSDecodableShape {
        /// Total number of accounts that have enabled the additional configuration.
        public let enabledAccountsCount: Int?
        /// Name of the additional configuration within a feature.
        public let name: OrgFeatureAdditionalConfiguration?

        @inlinable
        public init(enabledAccountsCount: Int? = nil, name: OrgFeatureAdditionalConfiguration? = nil) {
            self.enabledAccountsCount = enabledAccountsCount
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case enabledAccountsCount = "enabledAccountsCount"
            case name = "name"
        }
    }

    public struct OrganizationKubernetesAuditLogsConfiguration: AWSEncodableShape {
        /// A value that contains information on whether Kubernetes audit logs should be enabled automatically as a data source for the organization.
        public let autoEnable: Bool?

        @inlinable
        public init(autoEnable: Bool? = nil) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
        }
    }

    public struct OrganizationKubernetesAuditLogsConfigurationResult: AWSDecodableShape {
        /// Whether Kubernetes audit logs data source should be auto-enabled for new members joining the organization.
        public let autoEnable: Bool?

        @inlinable
        public init(autoEnable: Bool? = nil) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
        }
    }

    public struct OrganizationKubernetesConfiguration: AWSEncodableShape {
        /// Whether Kubernetes audit logs data source should be auto-enabled for new members joining the organization.
        public let auditLogs: OrganizationKubernetesAuditLogsConfiguration?

        @inlinable
        public init(auditLogs: OrganizationKubernetesAuditLogsConfiguration? = nil) {
            self.auditLogs = auditLogs
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs = "auditLogs"
        }
    }

    public struct OrganizationKubernetesConfigurationResult: AWSDecodableShape {
        /// The current configuration of Kubernetes audit logs as a data source for the organization.
        public let auditLogs: OrganizationKubernetesAuditLogsConfigurationResult?

        @inlinable
        public init(auditLogs: OrganizationKubernetesAuditLogsConfigurationResult? = nil) {
            self.auditLogs = auditLogs
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs = "auditLogs"
        }
    }

    public struct OrganizationMalwareProtectionConfiguration: AWSEncodableShape {
        /// Whether Malware Protection for EC2 instances with findings should be auto-enabled for new members joining the organization.
        public let scanEc2InstanceWithFindings: OrganizationScanEc2InstanceWithFindings?

        @inlinable
        public init(scanEc2InstanceWithFindings: OrganizationScanEc2InstanceWithFindings? = nil) {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }

        private enum CodingKeys: String, CodingKey {
            case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
        }
    }

    public struct OrganizationMalwareProtectionConfigurationResult: AWSDecodableShape {
        /// Describes the configuration for scanning EC2 instances with findings for an organization.
        public let scanEc2InstanceWithFindings: OrganizationScanEc2InstanceWithFindingsResult?

        @inlinable
        public init(scanEc2InstanceWithFindings: OrganizationScanEc2InstanceWithFindingsResult? = nil) {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }

        private enum CodingKeys: String, CodingKey {
            case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
        }
    }

    public struct OrganizationS3LogsConfiguration: AWSEncodableShape {
        /// A value that contains information on whether S3 data event logs will be enabled automatically as a data source for the organization.
        public let autoEnable: Bool?

        @inlinable
        public init(autoEnable: Bool? = nil) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
        }
    }

    public struct OrganizationS3LogsConfigurationResult: AWSDecodableShape {
        /// A value that describes whether S3 data event logs are automatically enabled for new members of the organization.
        public let autoEnable: Bool?

        @inlinable
        public init(autoEnable: Bool? = nil) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
        }
    }

    public struct OrganizationScanEc2InstanceWithFindings: AWSEncodableShape {
        /// Whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public let ebsVolumes: OrganizationEbsVolumes?

        @inlinable
        public init(ebsVolumes: OrganizationEbsVolumes? = nil) {
            self.ebsVolumes = ebsVolumes
        }

        private enum CodingKeys: String, CodingKey {
            case ebsVolumes = "ebsVolumes"
        }
    }

    public struct OrganizationScanEc2InstanceWithFindingsResult: AWSDecodableShape {
        /// Describes the configuration for scanning EBS volumes for an organization.
        public let ebsVolumes: OrganizationEbsVolumesResult?

        @inlinable
        public init(ebsVolumes: OrganizationEbsVolumesResult? = nil) {
            self.ebsVolumes = ebsVolumes
        }

        private enum CodingKeys: String, CodingKey {
            case ebsVolumes = "ebsVolumes"
        }
    }

    public struct OrganizationStatistics: AWSDecodableShape {
        /// Total number of active accounts in your Amazon Web Services  organization that are associated with GuardDuty.
        public let activeAccountsCount: Int?
        /// Retrieves the coverage  statistics for each feature.
        public let countByFeature: [OrganizationFeatureStatistics]?
        /// Total number of accounts that have enabled GuardDuty.
        public let enabledAccountsCount: Int?
        /// Total number of accounts in your Amazon Web Services organization  that are associated with GuardDuty.
        public let memberAccountsCount: Int?
        /// Total number of accounts in your Amazon Web Services organization.
        public let totalAccountsCount: Int?

        @inlinable
        public init(activeAccountsCount: Int? = nil, countByFeature: [OrganizationFeatureStatistics]? = nil, enabledAccountsCount: Int? = nil, memberAccountsCount: Int? = nil, totalAccountsCount: Int? = nil) {
            self.activeAccountsCount = activeAccountsCount
            self.countByFeature = countByFeature
            self.enabledAccountsCount = enabledAccountsCount
            self.memberAccountsCount = memberAccountsCount
            self.totalAccountsCount = totalAccountsCount
        }

        private enum CodingKeys: String, CodingKey {
            case activeAccountsCount = "activeAccountsCount"
            case countByFeature = "countByFeature"
            case enabledAccountsCount = "enabledAccountsCount"
            case memberAccountsCount = "memberAccountsCount"
            case totalAccountsCount = "totalAccountsCount"
        }
    }

    public struct Owner: AWSDecodableShape {
        /// The canonical user ID of the bucket owner. For information about locating your canonical user ID see Finding Your Account Canonical User ID.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct PermissionConfiguration: AWSDecodableShape {
        /// Contains information about the account level permissions on the S3 bucket.
        public let accountLevelPermissions: AccountLevelPermissions?
        /// Contains information about the bucket level permissions for the S3 bucket.
        public let bucketLevelPermissions: BucketLevelPermissions?

        @inlinable
        public init(accountLevelPermissions: AccountLevelPermissions? = nil, bucketLevelPermissions: BucketLevelPermissions? = nil) {
            self.accountLevelPermissions = accountLevelPermissions
            self.bucketLevelPermissions = bucketLevelPermissions
        }

        private enum CodingKeys: String, CodingKey {
            case accountLevelPermissions = "accountLevelPermissions"
            case bucketLevelPermissions = "bucketLevelPermissions"
        }
    }

    public struct PortProbeAction: AWSDecodableShape {
        /// Indicates whether EC2 blocked the port probe to the instance, such as with an ACL.
        public let blocked: Bool?
        /// A list of objects related to port probe details.
        public let portProbeDetails: [PortProbeDetail]?

        @inlinable
        public init(blocked: Bool? = nil, portProbeDetails: [PortProbeDetail]? = nil) {
            self.blocked = blocked
            self.portProbeDetails = portProbeDetails
        }

        private enum CodingKeys: String, CodingKey {
            case blocked = "blocked"
            case portProbeDetails = "portProbeDetails"
        }
    }

    public struct PortProbeDetail: AWSDecodableShape {
        /// The local IP information of the connection.
        public let localIpDetails: LocalIpDetails?
        /// The local port information of the connection.
        public let localPortDetails: LocalPortDetails?
        /// The remote IP information of the connection.
        public let remoteIpDetails: RemoteIpDetails?

        @inlinable
        public init(localIpDetails: LocalIpDetails? = nil, localPortDetails: LocalPortDetails? = nil, remoteIpDetails: RemoteIpDetails? = nil) {
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.remoteIpDetails = remoteIpDetails
        }

        private enum CodingKeys: String, CodingKey {
            case localIpDetails = "localIpDetails"
            case localPortDetails = "localPortDetails"
            case remoteIpDetails = "remoteIpDetails"
        }
    }

    public struct PrivateIpAddressDetails: AWSDecodableShape {
        /// The private DNS name of the EC2 instance.
        public let privateDnsName: String?
        /// The private IP address of the EC2 instance.
        public let privateIpAddress: String?

        @inlinable
        public init(privateDnsName: String? = nil, privateIpAddress: String? = nil) {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }

        private enum CodingKeys: String, CodingKey {
            case privateDnsName = "privateDnsName"
            case privateIpAddress = "privateIpAddress"
        }
    }

    public struct ProcessDetails: AWSDecodableShape {
        /// The effective user ID of the user that executed the process.
        public let euid: Int?
        /// The absolute path of the process executable file.
        public let executablePath: String?
        /// The SHA256 hash of the process executable.
        public let executableSha256: String?
        /// Information about the process's lineage.
        public let lineage: [LineageObject]?
        /// The name of the process.
        public let name: String?
        /// The ID of the child process.
        public let namespacePid: Int?
        /// The unique ID of the parent process. This ID is assigned to the parent process by GuardDuty.
        public let parentUuid: String?
        /// The ID of the process.
        public let pid: Int?
        /// The present working directory of the process.
        public let pwd: String?
        /// The time when the process started. This is in UTC format.
        public let startTime: Date?
        /// The user that executed the process.
        public let user: String?
        /// The unique ID of the user that executed the process.
        public let userId: Int?
        /// The unique ID assigned to the process by GuardDuty.
        public let uuid: String?

        @inlinable
        public init(euid: Int? = nil, executablePath: String? = nil, executableSha256: String? = nil, lineage: [LineageObject]? = nil, name: String? = nil, namespacePid: Int? = nil, parentUuid: String? = nil, pid: Int? = nil, pwd: String? = nil, startTime: Date? = nil, user: String? = nil, userId: Int? = nil, uuid: String? = nil) {
            self.euid = euid
            self.executablePath = executablePath
            self.executableSha256 = executableSha256
            self.lineage = lineage
            self.name = name
            self.namespacePid = namespacePid
            self.parentUuid = parentUuid
            self.pid = pid
            self.pwd = pwd
            self.startTime = startTime
            self.user = user
            self.userId = userId
            self.uuid = uuid
        }

        private enum CodingKeys: String, CodingKey {
            case euid = "euid"
            case executablePath = "executablePath"
            case executableSha256 = "executableSha256"
            case lineage = "lineage"
            case name = "name"
            case namespacePid = "namespacePid"
            case parentUuid = "parentUuid"
            case pid = "pid"
            case pwd = "pwd"
            case startTime = "startTime"
            case user = "user"
            case userId = "userId"
            case uuid = "uuid"
        }
    }

    public struct ProductCode: AWSDecodableShape {
        /// The product code information.
        public let code: String?
        /// The product code type.
        public let productType: String?

        @inlinable
        public init(code: String? = nil, productType: String? = nil) {
            self.code = code
            self.productType = productType
        }

        private enum CodingKeys: String, CodingKey {
            case code = "productCodeId"
            case productType = "productCodeType"
        }
    }

    public struct PublicAccess: AWSDecodableShape {
        /// Describes the effective permission on this bucket after factoring all attached policies.
        public let effectivePermission: String?
        /// Contains information about how permissions are configured for the S3 bucket.
        public let permissionConfiguration: PermissionConfiguration?

        @inlinable
        public init(effectivePermission: String? = nil, permissionConfiguration: PermissionConfiguration? = nil) {
            self.effectivePermission = effectivePermission
            self.permissionConfiguration = permissionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case effectivePermission = "effectivePermission"
            case permissionConfiguration = "permissionConfiguration"
        }
    }

    public struct PublicAccessConfiguration: AWSDecodableShape {
        /// Indicates whether or not there is a setting that allows public access to the Amazon S3 buckets through access control lists (ACLs).
        public let publicAclAccess: PublicAccessStatus?
        /// Indicates whether or not there is a setting that ignores all public access control lists (ACLs) on the Amazon S3 bucket and the objects that it contains.
        public let publicAclIgnoreBehavior: PublicAclIgnoreBehavior?
        /// Indicates whether or not there is a setting that restricts access to the bucket with specified policies.
        public let publicBucketRestrictBehavior: PublicBucketRestrictBehavior?
        /// Indicates whether or not there is a setting that allows public access to the Amazon S3 bucket policy.
        public let publicPolicyAccess: PublicAccessStatus?

        @inlinable
        public init(publicAclAccess: PublicAccessStatus? = nil, publicAclIgnoreBehavior: PublicAclIgnoreBehavior? = nil, publicBucketRestrictBehavior: PublicBucketRestrictBehavior? = nil, publicPolicyAccess: PublicAccessStatus? = nil) {
            self.publicAclAccess = publicAclAccess
            self.publicAclIgnoreBehavior = publicAclIgnoreBehavior
            self.publicBucketRestrictBehavior = publicBucketRestrictBehavior
            self.publicPolicyAccess = publicPolicyAccess
        }

        private enum CodingKeys: String, CodingKey {
            case publicAclAccess = "publicAclAccess"
            case publicAclIgnoreBehavior = "publicAclIgnoreBehavior"
            case publicBucketRestrictBehavior = "publicBucketRestrictBehavior"
            case publicPolicyAccess = "publicPolicyAccess"
        }
    }

    public struct RdsDbInstanceDetails: AWSDecodableShape {
        /// The identifier of the database cluster that contains the database instance ID involved in the finding.
        public let dbClusterIdentifier: String?
        /// The Amazon Resource Name (ARN) that identifies the database instance involved in the finding.
        public let dbInstanceArn: String?
        /// The identifier associated to the database instance that was involved in the finding.
        public let dbInstanceIdentifier: String?
        /// The database engine of the database instance involved in the finding.
        public let engine: String?
        /// The version of the database engine that was involved in the finding.
        public let engineVersion: String?
        /// Information about the tag key-value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(dbClusterIdentifier: String? = nil, dbInstanceArn: String? = nil, dbInstanceIdentifier: String? = nil, engine: String? = nil, engineVersion: String? = nil, tags: [Tag]? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbInstanceArn = dbInstanceArn
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.engine = engine
            self.engineVersion = engineVersion
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "dbClusterIdentifier"
            case dbInstanceArn = "dbInstanceArn"
            case dbInstanceIdentifier = "dbInstanceIdentifier"
            case engine = "engine"
            case engineVersion = "engineVersion"
            case tags = "tags"
        }
    }

    public struct RdsDbUserDetails: AWSDecodableShape {
        /// The application name used in the anomalous login attempt.
        public let application: String?
        /// The authentication method used by the user involved in the finding.
        public let authMethod: String?
        /// The name of the database instance involved in the anomalous login attempt.
        public let database: String?
        /// The version of the Secure Socket Layer (SSL) used for the network.
        public let ssl: String?
        /// The user name used in the anomalous login attempt.
        public let user: String?

        @inlinable
        public init(application: String? = nil, authMethod: String? = nil, database: String? = nil, ssl: String? = nil, user: String? = nil) {
            self.application = application
            self.authMethod = authMethod
            self.database = database
            self.ssl = ssl
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case authMethod = "authMethod"
            case database = "database"
            case ssl = "ssl"
            case user = "user"
        }
    }

    public struct RdsLimitlessDbDetails: AWSDecodableShape {
        /// The name of the database cluster that is a part of the Limitless Database.
        public let dbClusterIdentifier: String?
        /// The Amazon Resource Name (ARN) that identifies the DB shard group.
        public let dbShardGroupArn: String?
        /// The name associated with the Limitless DB shard group.
        public let dbShardGroupIdentifier: String?
        /// The resource identifier of the DB shard group within the Limitless Database.
        public let dbShardGroupResourceId: String?
        /// The database engine of the database instance involved in the finding.
        public let engine: String?
        /// The version of the database engine.
        public let engineVersion: String?
        /// Information about the tag key-value pair.
        public let tags: [Tag]?

        @inlinable
        public init(dbClusterIdentifier: String? = nil, dbShardGroupArn: String? = nil, dbShardGroupIdentifier: String? = nil, dbShardGroupResourceId: String? = nil, engine: String? = nil, engineVersion: String? = nil, tags: [Tag]? = nil) {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbShardGroupArn = dbShardGroupArn
            self.dbShardGroupIdentifier = dbShardGroupIdentifier
            self.dbShardGroupResourceId = dbShardGroupResourceId
            self.engine = engine
            self.engineVersion = engineVersion
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterIdentifier = "dbClusterIdentifier"
            case dbShardGroupArn = "dbShardGroupArn"
            case dbShardGroupIdentifier = "dbShardGroupIdentifier"
            case dbShardGroupResourceId = "dbShardGroupResourceId"
            case engine = "engine"
            case engineVersion = "engineVersion"
            case tags = "tags"
        }
    }

    public struct RdsLoginAttemptAction: AWSDecodableShape {
        /// Indicates the login attributes used in the login attempt.
        public let loginAttributes: [LoginAttribute]?
        public let remoteIpDetails: RemoteIpDetails?

        @inlinable
        public init(loginAttributes: [LoginAttribute]? = nil, remoteIpDetails: RemoteIpDetails? = nil) {
            self.loginAttributes = loginAttributes
            self.remoteIpDetails = remoteIpDetails
        }

        private enum CodingKeys: String, CodingKey {
            case loginAttributes = "LoginAttributes"
            case remoteIpDetails = "remoteIpDetails"
        }
    }

    public struct RemoteAccountDetails: AWSDecodableShape {
        /// The Amazon Web Services account ID of the remote API caller.
        public let accountId: String?
        /// Details on whether the Amazon Web Services account of the remote API caller is related to your GuardDuty environment. If this value is True the API caller is affiliated to your account in some way. If it is False the API caller is from outside your environment.
        public let affiliated: Bool?

        @inlinable
        public init(accountId: String? = nil, affiliated: Bool? = nil) {
            self.accountId = accountId
            self.affiliated = affiliated
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case affiliated = "affiliated"
        }
    }

    public struct RemoteIpDetails: AWSDecodableShape {
        /// The city information of the remote IP address.
        public let city: City?
        /// The country code of the remote IP address.
        public let country: Country?
        /// The location information of the remote IP address.
        public let geoLocation: GeoLocation?
        /// The IPv4 remote address of the connection.
        public let ipAddressV4: String?
        /// The IPv6 remote address of the connection.
        public let ipAddressV6: String?
        /// The ISP organization information of the remote IP address.
        public let organization: Organization?

        @inlinable
        public init(city: City? = nil, country: Country? = nil, geoLocation: GeoLocation? = nil, ipAddressV4: String? = nil, ipAddressV6: String? = nil, organization: Organization? = nil) {
            self.city = city
            self.country = country
            self.geoLocation = geoLocation
            self.ipAddressV4 = ipAddressV4
            self.ipAddressV6 = ipAddressV6
            self.organization = organization
        }

        private enum CodingKeys: String, CodingKey {
            case city = "city"
            case country = "country"
            case geoLocation = "geoLocation"
            case ipAddressV4 = "ipAddressV4"
            case ipAddressV6 = "ipAddressV6"
            case organization = "organization"
        }
    }

    public struct RemotePortDetails: AWSDecodableShape {
        /// The port number of the remote connection.
        public let port: Int?
        /// The port name of the remote connection.
        public let portName: String?

        @inlinable
        public init(port: Int? = nil, portName: String? = nil) {
            self.port = port
            self.portName = portName
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case portName = "portName"
        }
    }

    public struct Resource: AWSDecodableShape {
        /// The IAM access key details (user information) of a user that engaged in the activity that prompted GuardDuty to generate a finding.
        public let accessKeyDetails: AccessKeyDetails?
        public let containerDetails: Container?
        /// Contains list of scanned and skipped EBS volumes with details.
        public let ebsVolumeDetails: EbsVolumeDetails?
        /// Contains information about the details of the ECS Cluster.
        public let ecsClusterDetails: EcsClusterDetails?
        /// Details about the EKS cluster involved in a Kubernetes finding.
        public let eksClusterDetails: EksClusterDetails?
        /// The information about the EC2 instance associated with the activity that prompted GuardDuty to generate a finding.
        public let instanceDetails: InstanceDetails?
        /// Details about the Kubernetes user and workload involved in a Kubernetes finding.
        public let kubernetesDetails: KubernetesDetails?
        /// Contains information about the Lambda function that was involved in a finding.
        public let lambdaDetails: LambdaDetails?
        /// Contains information about the database instance to which an anomalous login attempt was made.
        public let rdsDbInstanceDetails: RdsDbInstanceDetails?
        /// Contains information about the user details through which anomalous login attempt was made.
        public let rdsDbUserDetails: RdsDbUserDetails?
        /// Contains information about the RDS Limitless database that was involved in a GuardDuty finding.
        public let rdsLimitlessDbDetails: RdsLimitlessDbDetails?
        /// The type of Amazon Web Services resource.
        public let resourceType: String?
        /// Contains information on the S3 bucket.
        public let s3BucketDetails: [S3BucketDetail]?

        @inlinable
        public init(accessKeyDetails: AccessKeyDetails? = nil, containerDetails: Container? = nil, ebsVolumeDetails: EbsVolumeDetails? = nil, ecsClusterDetails: EcsClusterDetails? = nil, eksClusterDetails: EksClusterDetails? = nil, instanceDetails: InstanceDetails? = nil, kubernetesDetails: KubernetesDetails? = nil, lambdaDetails: LambdaDetails? = nil, rdsDbInstanceDetails: RdsDbInstanceDetails? = nil, rdsDbUserDetails: RdsDbUserDetails? = nil, rdsLimitlessDbDetails: RdsLimitlessDbDetails? = nil, resourceType: String? = nil, s3BucketDetails: [S3BucketDetail]? = nil) {
            self.accessKeyDetails = accessKeyDetails
            self.containerDetails = containerDetails
            self.ebsVolumeDetails = ebsVolumeDetails
            self.ecsClusterDetails = ecsClusterDetails
            self.eksClusterDetails = eksClusterDetails
            self.instanceDetails = instanceDetails
            self.kubernetesDetails = kubernetesDetails
            self.lambdaDetails = lambdaDetails
            self.rdsDbInstanceDetails = rdsDbInstanceDetails
            self.rdsDbUserDetails = rdsDbUserDetails
            self.rdsLimitlessDbDetails = rdsLimitlessDbDetails
            self.resourceType = resourceType
            self.s3BucketDetails = s3BucketDetails
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyDetails = "accessKeyDetails"
            case containerDetails = "containerDetails"
            case ebsVolumeDetails = "ebsVolumeDetails"
            case ecsClusterDetails = "ecsClusterDetails"
            case eksClusterDetails = "eksClusterDetails"
            case instanceDetails = "instanceDetails"
            case kubernetesDetails = "kubernetesDetails"
            case lambdaDetails = "lambdaDetails"
            case rdsDbInstanceDetails = "rdsDbInstanceDetails"
            case rdsDbUserDetails = "rdsDbUserDetails"
            case rdsLimitlessDbDetails = "rdsLimitlessDbDetails"
            case resourceType = "resourceType"
            case s3BucketDetails = "s3BucketDetails"
        }
    }

    public struct ResourceData: AWSDecodableShape {
        /// Contains information about the IAM access key details of a user that involved in the GuardDuty finding.
        public let accessKey: AccessKey?
        /// Contains information about the Amazon EC2 instance.
        public let ec2Instance: Ec2Instance?
        /// Contains information about the elastic network interface of the Amazon EC2 instance.
        public let ec2NetworkInterface: Ec2NetworkInterface?
        /// Contains information about the Amazon S3 bucket.
        public let s3Bucket: S3Bucket?
        /// Contains information about the Amazon S3 object.
        public let s3Object: S3Object?

        @inlinable
        public init(accessKey: AccessKey? = nil, ec2Instance: Ec2Instance? = nil, ec2NetworkInterface: Ec2NetworkInterface? = nil, s3Bucket: S3Bucket? = nil, s3Object: S3Object? = nil) {
            self.accessKey = accessKey
            self.ec2Instance = ec2Instance
            self.ec2NetworkInterface = ec2NetworkInterface
            self.s3Bucket = s3Bucket
            self.s3Object = s3Object
        }

        private enum CodingKeys: String, CodingKey {
            case accessKey = "accessKey"
            case ec2Instance = "ec2Instance"
            case ec2NetworkInterface = "ec2NetworkInterface"
            case s3Bucket = "s3Bucket"
            case s3Object = "s3Object"
        }
    }

    public struct ResourceDetails: AWSDecodableShape {
        /// Instance ARN that was scanned in the scan entry.
        public let instanceArn: String?

        @inlinable
        public init(instanceArn: String? = nil) {
            self.instanceArn = instanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case instanceArn = "instanceArn"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        /// The error message.
        public let message: String?
        /// The error type.
        public let type: String?

        @inlinable
        public init(message: String? = nil, type: String? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case type = "__type"
        }
    }

    public struct ResourceStatistics: AWSDecodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountId: String?
        /// The timestamp at which the statistics for this resource was last generated.
        public let lastGeneratedAt: Date?
        /// ID associated with each resource. The following list provides the mapping of the resource type and resource ID.  Mapping of resource and resource ID    AccessKey - resource.accessKeyDetails.accessKeyId    Container - resource.containerDetails.id    ECSCluster - resource.ecsClusterDetails.name    EKSCluster - resource.eksClusterDetails.name    Instance - resource.instanceDetails.instanceId    KubernetesCluster - resource.kubernetesDetails.kubernetesWorkloadDetails.name    Lambda - resource.lambdaDetails.functionName    RDSDBInstance - resource.rdsDbInstanceDetails.dbInstanceIdentifier    S3Bucket - resource.s3BucketDetails.name    S3Object - resource.s3BucketDetails.name
        public let resourceId: String?
        /// The type of resource.
        public let resourceType: String?
        /// The total number of findings associated with this resource.
        public let totalFindings: Int?

        @inlinable
        public init(accountId: String? = nil, lastGeneratedAt: Date? = nil, resourceId: String? = nil, resourceType: String? = nil, totalFindings: Int? = nil) {
            self.accountId = accountId
            self.lastGeneratedAt = lastGeneratedAt
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.totalFindings = totalFindings
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case lastGeneratedAt = "lastGeneratedAt"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case totalFindings = "totalFindings"
        }
    }

    public struct ResourceV2: AWSDecodableShape {
        /// The Amazon Web Services account ID to which the resource belongs.
        public let accountId: String?
        /// The cloud partition within the Amazon Web Services Region to which the resource belongs.
        public let cloudPartition: String?
        /// Contains information about the Amazon Web Services resource associated with the activity that prompted GuardDuty to generate a finding.
        public let data: ResourceData?
        /// The name of the resource.
        public let name: String?
        /// The Amazon Web Services Region where the resource belongs.
        public let region: String?
        /// The type of the Amazon Web Services resource.
        public let resourceType: FindingResourceType?
        /// The Amazon Web Services service of the resource.
        public let service: String?
        /// Contains information about the tags associated with the resource.
        public let tags: [Tag]?
        /// The unique identifier of the resource.
        public let uid: String?

        @inlinable
        public init(accountId: String? = nil, cloudPartition: String? = nil, data: ResourceData? = nil, name: String? = nil, region: String? = nil, resourceType: FindingResourceType? = nil, service: String? = nil, tags: [Tag]? = nil, uid: String? = nil) {
            self.accountId = accountId
            self.cloudPartition = cloudPartition
            self.data = data
            self.name = name
            self.region = region
            self.resourceType = resourceType
            self.service = service
            self.tags = tags
            self.uid = uid
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case cloudPartition = "cloudPartition"
            case data = "data"
            case name = "name"
            case region = "region"
            case resourceType = "resourceType"
            case service = "service"
            case tags = "tags"
            case uid = "uid"
        }
    }

    public struct RuntimeContext: AWSDecodableShape {
        /// Represents the communication protocol associated with the address. For example, the address family AF_INET is used for IP version of 4 protocol.
        public let addressFamily: String?
        /// Example of the command line involved in the suspicious activity.
        public let commandLineExample: String?
        /// Represents the type of mounted fileSystem.
        public let fileSystemType: String?
        /// Represents options that control the behavior of a runtime operation or action. For example, a filesystem mount operation may contain a read-only flag.
        public let flags: [String]?
        /// Specifies a particular protocol within the address family. Usually there is a single protocol in address families. For example, the address family AF_INET only has the IP protocol.
        public let ianaProtocolNumber: Int?
        /// The value of the LD_PRELOAD environment variable.
        public let ldPreloadValue: String?
        /// The path to the new library that was loaded.
        public let libraryPath: String?
        /// Specifies the Region of a process's address space such as stack and heap.
        public let memoryRegions: [String]?
        /// The timestamp at which the process modified the current process. The timestamp is in UTC date string format.
        public let modifiedAt: Date?
        /// Information about the process that modified the current process. This is available for multiple finding types.
        public let modifyingProcess: ProcessDetails?
        /// The path to the module loaded into the kernel.
        public let moduleFilePath: String?
        /// The name of the module loaded into the kernel.
        public let moduleName: String?
        /// The SHA256 hash of the module.
        public let moduleSha256: String?
        /// The path on the host that is mounted by the container.
        public let mountSource: String?
        /// The path in the container that is mapped to the host directory.
        public let mountTarget: String?
        /// The path in the container that modified the release agent file.
        public let releaseAgentPath: String?
        /// The path to the leveraged runc implementation.
        public let runcBinaryPath: String?
        /// The path to the script that was executed.
        public let scriptPath: String?
        /// Name of the security service that has been potentially disabled.
        public let serviceName: String?
        /// The path to the modified shell history file.
        public let shellHistoryFilePath: String?
        /// The path to the docket socket that was accessed.
        public let socketPath: String?
        /// Information about the process that had its memory overwritten by the current process.
        public let targetProcess: ProcessDetails?
        /// The suspicious file path for which the threat intelligence details were found.
        public let threatFilePath: String?
        /// Category that the tool belongs to. Some of the examples are Backdoor Tool, Pentest Tool, Network Scanner, and Network Sniffer.
        public let toolCategory: String?
        /// Name of the potentially suspicious tool.
        public let toolName: String?

        @inlinable
        public init(addressFamily: String? = nil, commandLineExample: String? = nil, fileSystemType: String? = nil, flags: [String]? = nil, ianaProtocolNumber: Int? = nil, ldPreloadValue: String? = nil, libraryPath: String? = nil, memoryRegions: [String]? = nil, modifiedAt: Date? = nil, modifyingProcess: ProcessDetails? = nil, moduleFilePath: String? = nil, moduleName: String? = nil, moduleSha256: String? = nil, mountSource: String? = nil, mountTarget: String? = nil, releaseAgentPath: String? = nil, runcBinaryPath: String? = nil, scriptPath: String? = nil, serviceName: String? = nil, shellHistoryFilePath: String? = nil, socketPath: String? = nil, targetProcess: ProcessDetails? = nil, threatFilePath: String? = nil, toolCategory: String? = nil, toolName: String? = nil) {
            self.addressFamily = addressFamily
            self.commandLineExample = commandLineExample
            self.fileSystemType = fileSystemType
            self.flags = flags
            self.ianaProtocolNumber = ianaProtocolNumber
            self.ldPreloadValue = ldPreloadValue
            self.libraryPath = libraryPath
            self.memoryRegions = memoryRegions
            self.modifiedAt = modifiedAt
            self.modifyingProcess = modifyingProcess
            self.moduleFilePath = moduleFilePath
            self.moduleName = moduleName
            self.moduleSha256 = moduleSha256
            self.mountSource = mountSource
            self.mountTarget = mountTarget
            self.releaseAgentPath = releaseAgentPath
            self.runcBinaryPath = runcBinaryPath
            self.scriptPath = scriptPath
            self.serviceName = serviceName
            self.shellHistoryFilePath = shellHistoryFilePath
            self.socketPath = socketPath
            self.targetProcess = targetProcess
            self.threatFilePath = threatFilePath
            self.toolCategory = toolCategory
            self.toolName = toolName
        }

        private enum CodingKeys: String, CodingKey {
            case addressFamily = "addressFamily"
            case commandLineExample = "commandLineExample"
            case fileSystemType = "fileSystemType"
            case flags = "flags"
            case ianaProtocolNumber = "ianaProtocolNumber"
            case ldPreloadValue = "ldPreloadValue"
            case libraryPath = "libraryPath"
            case memoryRegions = "memoryRegions"
            case modifiedAt = "modifiedAt"
            case modifyingProcess = "modifyingProcess"
            case moduleFilePath = "moduleFilePath"
            case moduleName = "moduleName"
            case moduleSha256 = "moduleSha256"
            case mountSource = "mountSource"
            case mountTarget = "mountTarget"
            case releaseAgentPath = "releaseAgentPath"
            case runcBinaryPath = "runcBinaryPath"
            case scriptPath = "scriptPath"
            case serviceName = "serviceName"
            case shellHistoryFilePath = "shellHistoryFilePath"
            case socketPath = "socketPath"
            case targetProcess = "targetProcess"
            case threatFilePath = "threatFilePath"
            case toolCategory = "toolCategory"
            case toolName = "toolName"
        }
    }

    public struct RuntimeDetails: AWSDecodableShape {
        /// Additional information about the suspicious activity.
        public let context: RuntimeContext?
        /// Information about the observed process.
        public let process: ProcessDetails?

        @inlinable
        public init(context: RuntimeContext? = nil, process: ProcessDetails? = nil) {
            self.context = context
            self.process = process
        }

        private enum CodingKeys: String, CodingKey {
            case context = "context"
            case process = "process"
        }
    }

    public struct S3Bucket: AWSDecodableShape {
        /// Contains information about the public access policies that apply to the Amazon S3 bucket at the account level.
        public let accountPublicAccess: PublicAccessConfiguration?
        /// Contains information about public access policies that apply to the Amazon S3 bucket.
        public let bucketPublicAccess: PublicAccessConfiguration?
        /// The timestamp at which the Amazon S3 bucket was created.
        public let createdAt: Date?
        /// Describes the effective permissions on this S3 bucket, after factoring all the attached policies.
        public let effectivePermission: String?
        /// The Amazon Resource Name (ARN) of the encryption key that is used to encrypt the Amazon S3 bucket and its objects.
        public let encryptionKeyArn: String?
        /// The type of encryption used for the Amazon S3 buckets and its objects. For more information, see Protecting data with server-side encryption in the Amazon S3 User Guide.
        public let encryptionType: String?
        /// The owner ID of the associated S3Amazon S3bucket.
        public let ownerId: String?
        /// Indicates whether or not the public read access is allowed for an Amazon S3 bucket.
        public let publicReadAccess: PublicAccessStatus?
        /// Indicates whether or not the public write access is allowed for an Amazon S3 bucket.
        public let publicWriteAccess: PublicAccessStatus?
        /// Represents a list of Amazon S3 object identifiers.
        public let s3ObjectUids: [String]?

        @inlinable
        public init(accountPublicAccess: PublicAccessConfiguration? = nil, bucketPublicAccess: PublicAccessConfiguration? = nil, createdAt: Date? = nil, effectivePermission: String? = nil, encryptionKeyArn: String? = nil, encryptionType: String? = nil, ownerId: String? = nil, publicReadAccess: PublicAccessStatus? = nil, publicWriteAccess: PublicAccessStatus? = nil, s3ObjectUids: [String]? = nil) {
            self.accountPublicAccess = accountPublicAccess
            self.bucketPublicAccess = bucketPublicAccess
            self.createdAt = createdAt
            self.effectivePermission = effectivePermission
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionType = encryptionType
            self.ownerId = ownerId
            self.publicReadAccess = publicReadAccess
            self.publicWriteAccess = publicWriteAccess
            self.s3ObjectUids = s3ObjectUids
        }

        private enum CodingKeys: String, CodingKey {
            case accountPublicAccess = "accountPublicAccess"
            case bucketPublicAccess = "bucketPublicAccess"
            case createdAt = "createdAt"
            case effectivePermission = "effectivePermission"
            case encryptionKeyArn = "encryptionKeyArn"
            case encryptionType = "encryptionType"
            case ownerId = "ownerId"
            case publicReadAccess = "publicReadAccess"
            case publicWriteAccess = "publicWriteAccess"
            case s3ObjectUids = "s3ObjectUids"
        }
    }

    public struct S3BucketDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let arn: String?
        /// The date and time the bucket was created at.
        public let createdAt: Date?
        /// Describes the server side encryption method used in the S3 bucket.
        public let defaultServerSideEncryption: DefaultServerSideEncryption?
        /// The name of the S3 bucket.
        public let name: String?
        /// The owner of the S3 bucket.
        public let owner: Owner?
        /// Describes the public access policies that apply to the S3 bucket.
        public let publicAccess: PublicAccess?
        /// Information about the S3 object that was scanned.
        public let s3ObjectDetails: [S3ObjectDetail]?
        /// All tags attached to the S3 bucket
        public let tags: [Tag]?
        /// Describes whether the bucket is a source or destination bucket.
        public let type: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, defaultServerSideEncryption: DefaultServerSideEncryption? = nil, name: String? = nil, owner: Owner? = nil, publicAccess: PublicAccess? = nil, s3ObjectDetails: [S3ObjectDetail]? = nil, tags: [Tag]? = nil, type: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.defaultServerSideEncryption = defaultServerSideEncryption
            self.name = name
            self.owner = owner
            self.publicAccess = publicAccess
            self.s3ObjectDetails = s3ObjectDetails
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case defaultServerSideEncryption = "defaultServerSideEncryption"
            case name = "name"
            case owner = "owner"
            case publicAccess = "publicAccess"
            case s3ObjectDetails = "s3ObjectDetails"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct S3LogsConfiguration: AWSEncodableShape {
        ///  The status of S3 data event logs as a data source.
        public let enable: Bool?

        @inlinable
        public init(enable: Bool? = nil) {
            self.enable = enable
        }

        private enum CodingKeys: String, CodingKey {
            case enable = "enable"
        }
    }

    public struct S3LogsConfigurationResult: AWSDecodableShape {
        /// A value that describes whether S3 data event logs are automatically enabled for new members of the organization.
        public let status: DataSourceStatus?

        @inlinable
        public init(status: DataSourceStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct S3Object: AWSDecodableShape {
        /// The entity tag is a hash of the Amazon S3 object. The ETag reflects changes only to the contents of an object, and not its metadata.
        public let eTag: String?
        /// The key of the Amazon S3 object.
        public let key: String?
        /// The version Id of the Amazon S3 object.
        public let versionId: String?

        @inlinable
        public init(eTag: String? = nil, key: String? = nil, versionId: String? = nil) {
            self.eTag = eTag
            self.key = key
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case eTag = "eTag"
            case key = "key"
            case versionId = "versionId"
        }
    }

    public struct S3ObjectDetail: AWSDecodableShape {
        /// The entity tag is a hash of the S3 object. The ETag reflects changes only to the contents of  an object, and not its metadata.
        public let eTag: String?
        /// Hash of the threat detected in this finding.
        public let hash: String?
        /// Key of the S3 object.
        public let key: String?
        /// Amazon Resource Name (ARN) of the S3 object.
        public let objectArn: String?
        /// Version ID of the object.
        public let versionId: String?

        @inlinable
        public init(eTag: String? = nil, hash: String? = nil, key: String? = nil, objectArn: String? = nil, versionId: String? = nil) {
            self.eTag = eTag
            self.hash = hash
            self.key = key
            self.objectArn = objectArn
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case eTag = "eTag"
            case hash = "hash"
            case key = "key"
            case objectArn = "objectArn"
            case versionId = "versionId"
        }
    }

    public struct Scan: AWSDecodableShape {
        /// The ID for the account that belongs to the scan.
        public let accountId: String?
        /// The unique detector ID of the administrator account that the request is associated with. If the account is an administrator, the AdminDetectorId will be the same as the one used for  DetectorId. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let adminDetectorId: String?
        /// List of volumes that were attached to the original instance to be scanned.
        public let attachedVolumes: [VolumeDetail]?
        /// The unique ID of the detector that is associated with the request. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String?
        /// Represents the reason for FAILED scan status.
        public let failureReason: String?
        /// Represents the number of files that were scanned.
        public let fileCount: Int64?
        /// Represents the resources that were scanned in the scan entry.
        public let resourceDetails: ResourceDetails?
        /// The timestamp of when the scan was finished.
        public let scanEndTime: Date?
        /// The unique scan ID associated with a scan entry.
        public let scanId: String?
        /// Represents the result of the scan.
        public let scanResultDetails: ScanResultDetails?
        /// The timestamp of when the scan was triggered.
        public let scanStartTime: Date?
        /// An enum value representing possible scan statuses.
        public let scanStatus: ScanStatus?
        /// Specifies the scan type that invoked the malware scan.
        public let scanType: ScanType?
        /// Represents total bytes that were scanned.
        public let totalBytes: Int64?
        /// Specifies the reason why the scan was initiated.
        public let triggerDetails: TriggerDetails?

        @inlinable
        public init(accountId: String? = nil, adminDetectorId: String? = nil, attachedVolumes: [VolumeDetail]? = nil, detectorId: String? = nil, failureReason: String? = nil, fileCount: Int64? = nil, resourceDetails: ResourceDetails? = nil, scanEndTime: Date? = nil, scanId: String? = nil, scanResultDetails: ScanResultDetails? = nil, scanStartTime: Date? = nil, scanStatus: ScanStatus? = nil, scanType: ScanType? = nil, totalBytes: Int64? = nil, triggerDetails: TriggerDetails? = nil) {
            self.accountId = accountId
            self.adminDetectorId = adminDetectorId
            self.attachedVolumes = attachedVolumes
            self.detectorId = detectorId
            self.failureReason = failureReason
            self.fileCount = fileCount
            self.resourceDetails = resourceDetails
            self.scanEndTime = scanEndTime
            self.scanId = scanId
            self.scanResultDetails = scanResultDetails
            self.scanStartTime = scanStartTime
            self.scanStatus = scanStatus
            self.scanType = scanType
            self.totalBytes = totalBytes
            self.triggerDetails = triggerDetails
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case adminDetectorId = "adminDetectorId"
            case attachedVolumes = "attachedVolumes"
            case detectorId = "detectorId"
            case failureReason = "failureReason"
            case fileCount = "fileCount"
            case resourceDetails = "resourceDetails"
            case scanEndTime = "scanEndTime"
            case scanId = "scanId"
            case scanResultDetails = "scanResultDetails"
            case scanStartTime = "scanStartTime"
            case scanStatus = "scanStatus"
            case scanType = "scanType"
            case totalBytes = "totalBytes"
            case triggerDetails = "triggerDetails"
        }
    }

    public struct ScanCondition: AWSEncodableShape & AWSDecodableShape {
        /// Represents an mapEqual condition to be applied to a single field when triggering for malware scan.
        public let mapEquals: [ScanConditionPair]?

        @inlinable
        public init(mapEquals: [ScanConditionPair]? = nil) {
            self.mapEquals = mapEquals
        }

        public func validate(name: String) throws {
            try self.mapEquals?.forEach {
                try $0.validate(name: "\(name).mapEquals[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case mapEquals = "mapEquals"
        }
    }

    public struct ScanConditionPair: AWSEncodableShape & AWSDecodableShape {
        /// Represents the key in the map condition.
        public let key: String?
        /// Represents optional value in the map condition. If not specified, only the key will be matched.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct ScanDetections: AWSDecodableShape {
        /// Details of the highest severity threat detected during malware scan and number of infected files.
        public let highestSeverityThreatDetails: HighestSeverityThreatDetails?
        /// Total number of scanned files.
        public let scannedItemCount: ScannedItemCount?
        /// Contains details about identified threats organized by threat name.
        public let threatDetectedByName: ThreatDetectedByName?
        /// Total number of infected files.
        public let threatsDetectedItemCount: ThreatsDetectedItemCount?

        @inlinable
        public init(highestSeverityThreatDetails: HighestSeverityThreatDetails? = nil, scannedItemCount: ScannedItemCount? = nil, threatDetectedByName: ThreatDetectedByName? = nil, threatsDetectedItemCount: ThreatsDetectedItemCount? = nil) {
            self.highestSeverityThreatDetails = highestSeverityThreatDetails
            self.scannedItemCount = scannedItemCount
            self.threatDetectedByName = threatDetectedByName
            self.threatsDetectedItemCount = threatsDetectedItemCount
        }

        private enum CodingKeys: String, CodingKey {
            case highestSeverityThreatDetails = "highestSeverityThreatDetails"
            case scannedItemCount = "scannedItemCount"
            case threatDetectedByName = "threatDetectedByName"
            case threatsDetectedItemCount = "threatsDetectedItemCount"
        }
    }

    public struct ScanEc2InstanceWithFindings: AWSEncodableShape {
        /// Describes the configuration for scanning EBS volumes as data source.
        public let ebsVolumes: Bool?

        @inlinable
        public init(ebsVolumes: Bool? = nil) {
            self.ebsVolumes = ebsVolumes
        }

        private enum CodingKeys: String, CodingKey {
            case ebsVolumes = "ebsVolumes"
        }
    }

    public struct ScanEc2InstanceWithFindingsResult: AWSDecodableShape {
        /// Describes the configuration of scanning EBS volumes as a data source.
        public let ebsVolumes: EbsVolumesResult?

        @inlinable
        public init(ebsVolumes: EbsVolumesResult? = nil) {
            self.ebsVolumes = ebsVolumes
        }

        private enum CodingKeys: String, CodingKey {
            case ebsVolumes = "ebsVolumes"
        }
    }

    public struct ScanFilePath: AWSDecodableShape {
        /// File name of the infected file.
        public let fileName: String?
        /// The file path of the infected file.
        public let filePath: String?
        /// The hash value of the infected file.
        public let hash: String?
        /// EBS volume ARN details of the infected file.
        public let volumeArn: String?

        @inlinable
        public init(fileName: String? = nil, filePath: String? = nil, hash: String? = nil, volumeArn: String? = nil) {
            self.fileName = fileName
            self.filePath = filePath
            self.hash = hash
            self.volumeArn = volumeArn
        }

        private enum CodingKeys: String, CodingKey {
            case fileName = "fileName"
            case filePath = "filePath"
            case hash = "hash"
            case volumeArn = "volumeArn"
        }
    }

    public struct ScanResourceCriteria: AWSEncodableShape & AWSDecodableShape {
        /// Represents condition that when matched will prevent a malware scan for a certain resource.
        public let exclude: [ScanCriterionKey: ScanCondition]?
        /// Represents condition that when matched will allow a malware scan for a certain resource.
        public let include: [ScanCriterionKey: ScanCondition]?

        @inlinable
        public init(exclude: [ScanCriterionKey: ScanCondition]? = nil, include: [ScanCriterionKey: ScanCondition]? = nil) {
            self.exclude = exclude
            self.include = include
        }

        public func validate(name: String) throws {
            try self.exclude?.forEach {
                try $0.value.validate(name: "\(name).exclude[\"\($0.key)\"]")
            }
            try self.include?.forEach {
                try $0.value.validate(name: "\(name).include[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case exclude = "exclude"
            case include = "include"
        }
    }

    public struct ScanResultDetails: AWSDecodableShape {
        /// An enum value representing possible scan results.
        public let scanResult: ScanResult?

        @inlinable
        public init(scanResult: ScanResult? = nil) {
            self.scanResult = scanResult
        }

        private enum CodingKeys: String, CodingKey {
            case scanResult = "scanResult"
        }
    }

    public struct ScanThreatName: AWSDecodableShape {
        /// List of infected files in EBS volume with details.
        public let filePaths: [ScanFilePath]?
        /// Total number of files infected with given threat.
        public let itemCount: Int?
        /// The name of the identified threat.
        public let name: String?
        /// Severity of threat identified as part of the malware scan.
        public let severity: String?

        @inlinable
        public init(filePaths: [ScanFilePath]? = nil, itemCount: Int? = nil, name: String? = nil, severity: String? = nil) {
            self.filePaths = filePaths
            self.itemCount = itemCount
            self.name = name
            self.severity = severity
        }

        private enum CodingKeys: String, CodingKey {
            case filePaths = "filePaths"
            case itemCount = "itemCount"
            case name = "name"
            case severity = "severity"
        }
    }

    public struct ScannedItemCount: AWSDecodableShape {
        /// Number of files scanned.
        public let files: Int?
        /// Total GB of files scanned for malware.
        public let totalGb: Int?
        /// Total number of scanned volumes.
        public let volumes: Int?

        @inlinable
        public init(files: Int? = nil, totalGb: Int? = nil, volumes: Int? = nil) {
            self.files = files
            self.totalGb = totalGb
            self.volumes = volumes
        }

        private enum CodingKeys: String, CodingKey {
            case files = "files"
            case totalGb = "totalGb"
            case volumes = "volumes"
        }
    }

    public struct SecurityContext: AWSDecodableShape {
        /// Whether or not a container or a Kubernetes pod is allowed to gain more privileges than its parent process.
        public let allowPrivilegeEscalation: Bool?
        /// Whether the container is privileged.
        public let privileged: Bool?

        @inlinable
        public init(allowPrivilegeEscalation: Bool? = nil, privileged: Bool? = nil) {
            self.allowPrivilegeEscalation = allowPrivilegeEscalation
            self.privileged = privileged
        }

        private enum CodingKeys: String, CodingKey {
            case allowPrivilegeEscalation = "allowPrivilegeEscalation"
            case privileged = "privileged"
        }
    }

    public struct SecurityGroup: AWSDecodableShape {
        /// The security group ID of the EC2 instance.
        public let groupId: String?
        /// The security group name of the EC2 instance.
        public let groupName: String?

        @inlinable
        public init(groupId: String? = nil, groupName: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "groupId"
            case groupName = "groupName"
        }
    }

    public struct Sequence: AWSDecodableShape {
        /// Contains information about the actors involved in the attack sequence.
        public let actors: [Actor]?
        /// Description of the attack sequence.
        public let description: String?
        /// Contains information about the network endpoints that were used in the attack sequence.
        public let endpoints: [NetworkEndpoint]?
        /// Contains information about the resources involved in the attack sequence.
        public let resources: [ResourceV2]?
        /// Contains information about the indicators observed in the attack sequence.
        public let sequenceIndicators: [Indicator]?
        /// Contains information about the signals involved in the attack sequence.
        public let signals: [Signal]?
        /// Unique identifier of the attack sequence.
        public let uid: String?

        @inlinable
        public init(actors: [Actor]? = nil, description: String? = nil, endpoints: [NetworkEndpoint]? = nil, resources: [ResourceV2]? = nil, sequenceIndicators: [Indicator]? = nil, signals: [Signal]? = nil, uid: String? = nil) {
            self.actors = actors
            self.description = description
            self.endpoints = endpoints
            self.resources = resources
            self.sequenceIndicators = sequenceIndicators
            self.signals = signals
            self.uid = uid
        }

        private enum CodingKeys: String, CodingKey {
            case actors = "actors"
            case description = "description"
            case endpoints = "endpoints"
            case resources = "resources"
            case sequenceIndicators = "sequenceIndicators"
            case signals = "signals"
            case uid = "uid"
        }
    }

    public struct Service: AWSDecodableShape {
        /// Information about the activity that is described in a finding.
        public let action: Action?
        /// Contains additional information about the generated finding.
        public let additionalInfo: ServiceAdditionalInfo?
        /// Indicates whether this finding is archived.
        public let archived: Bool?
        /// The total count of the occurrences of this finding type.
        public let count: Int?
        /// Contains information about the detected unusual behavior.
        public let detection: Detection?
        /// The detector ID for the GuardDuty service.
        public let detectorId: String?
        /// Returns details from the malware scan that created a finding.
        public let ebsVolumeScanDetails: EbsVolumeScanDetails?
        /// The first-seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public let eventFirstSeen: String?
        /// The last-seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public let eventLastSeen: String?
        /// An evidence object associated with the service.
        public let evidence: Evidence?
        /// The name of the feature that generated a finding.
        public let featureName: String?
        /// Returns details from the malware scan that generated a GuardDuty finding.
        public let malwareScanDetails: MalwareScanDetails?
        /// The resource role information for this finding.
        public let resourceRole: String?
        /// Information about the process and any required context values for a specific finding
        public let runtimeDetails: RuntimeDetails?
        /// The name of the Amazon Web Services service (GuardDuty) that generated a finding.
        public let serviceName: String?
        /// Feedback that was submitted about the finding.
        public let userFeedback: String?

        @inlinable
        public init(action: Action? = nil, additionalInfo: ServiceAdditionalInfo? = nil, archived: Bool? = nil, count: Int? = nil, detection: Detection? = nil, detectorId: String? = nil, ebsVolumeScanDetails: EbsVolumeScanDetails? = nil, eventFirstSeen: String? = nil, eventLastSeen: String? = nil, evidence: Evidence? = nil, featureName: String? = nil, malwareScanDetails: MalwareScanDetails? = nil, resourceRole: String? = nil, runtimeDetails: RuntimeDetails? = nil, serviceName: String? = nil, userFeedback: String? = nil) {
            self.action = action
            self.additionalInfo = additionalInfo
            self.archived = archived
            self.count = count
            self.detection = detection
            self.detectorId = detectorId
            self.ebsVolumeScanDetails = ebsVolumeScanDetails
            self.eventFirstSeen = eventFirstSeen
            self.eventLastSeen = eventLastSeen
            self.evidence = evidence
            self.featureName = featureName
            self.malwareScanDetails = malwareScanDetails
            self.resourceRole = resourceRole
            self.runtimeDetails = runtimeDetails
            self.serviceName = serviceName
            self.userFeedback = userFeedback
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case additionalInfo = "additionalInfo"
            case archived = "archived"
            case count = "count"
            case detection = "detection"
            case detectorId = "detectorId"
            case ebsVolumeScanDetails = "ebsVolumeScanDetails"
            case eventFirstSeen = "eventFirstSeen"
            case eventLastSeen = "eventLastSeen"
            case evidence = "evidence"
            case featureName = "featureName"
            case malwareScanDetails = "malwareScanDetails"
            case resourceRole = "resourceRole"
            case runtimeDetails = "runtimeDetails"
            case serviceName = "serviceName"
            case userFeedback = "userFeedback"
        }
    }

    public struct ServiceAdditionalInfo: AWSDecodableShape {
        /// Describes the type of the additional information.
        public let type: String?
        /// This field specifies the value of the additional information.
        public let value: String?

        @inlinable
        public init(type: String? = nil, value: String? = nil) {
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case value = "value"
        }
    }

    public struct Session: AWSDecodableShape {
        /// The timestamp for when the session was created. In Amazon Web Services CloudTrail, you can find this value as userIdentity.sessionContext.attributes.creationDate.
        public let createdTime: Date?
        /// Identifier of the session issuer. In Amazon Web Services CloudTrail, you can find this value as userIdentity.sessionContext.sessionIssuer.arn.
        public let issuer: String?
        /// Indicates whether or not multi-factor authencation (MFA) was used during authentication. In Amazon Web Services CloudTrail, you can find this value as userIdentity.sessionContext.attributes.mfaAuthenticated.
        public let mfaStatus: MfaStatus?
        /// The unique identifier of the session.
        public let uid: String?

        @inlinable
        public init(createdTime: Date? = nil, issuer: String? = nil, mfaStatus: MfaStatus? = nil, uid: String? = nil) {
            self.createdTime = createdTime
            self.issuer = issuer
            self.mfaStatus = mfaStatus
            self.uid = uid
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case issuer = "issuer"
            case mfaStatus = "mfaStatus"
            case uid = "uid"
        }
    }

    public struct SeverityStatistics: AWSDecodableShape {
        /// The timestamp at which a finding type for a specific severity was last generated.
        public let lastGeneratedAt: Date?
        /// The severity level associated with each finding type.
        public let severity: Double?
        /// The total number of findings associated with this severity.
        public let totalFindings: Int?

        @inlinable
        public init(lastGeneratedAt: Date? = nil, severity: Double? = nil, totalFindings: Int? = nil) {
            self.lastGeneratedAt = lastGeneratedAt
            self.severity = severity
            self.totalFindings = totalFindings
        }

        private enum CodingKeys: String, CodingKey {
            case lastGeneratedAt = "lastGeneratedAt"
            case severity = "severity"
            case totalFindings = "totalFindings"
        }
    }

    public struct Signal: AWSDecodableShape {
        /// Information about the IDs of the threat actors involved in the signal.
        public let actorIds: [String]?
        /// The number of times this signal was observed.
        public let count: Int?
        /// The timestamp when the first finding or activity related to this signal was observed.
        public let createdAt: Date?
        /// The description of the signal.
        public let description: String?
        /// Information about the endpoint IDs associated with this signal.
        public let endpointIds: [String]?
        /// The timestamp when the first finding or activity related to this signal was observed.
        public let firstSeenAt: Date?
        /// The timestamp when the last finding or activity related to this signal was observed.
        public let lastSeenAt: Date?
        /// The name of the signal. For example, when signal type is FINDING,  the signal name is the name of the finding.
        public let name: String?
        /// Information about the unique identifiers of the resources involved in the signal.
        public let resourceUids: [String]?
        /// The severity associated with the signal. For more information about severity, see  Findings severity levels in the Amazon GuardDuty User Guide.
        public let severity: Double?
        /// Contains information about the indicators associated with the signals.
        public let signalIndicators: [Indicator]?
        /// The type of the signal used to identify an attack sequence. Signals can be GuardDuty findings or activities observed in data sources that GuardDuty monitors. For more information, see  Foundational data sources in the Amazon GuardDuty User Guide. A signal type can be one of the valid values listed in this API. Here are the related descriptions:    FINDING - Individually generated GuardDuty finding.    CLOUD_TRAIL - Activity observed from CloudTrail logs    S3_DATA_EVENTS - Activity observed from CloudTrail data events for S3. Activities associated with this type will show up only when you have enabled GuardDuty S3 Protection feature in your account. For more information about S3 Protection and steps to enable it, see S3 Protection in the Amazon GuardDuty User Guide.
        public let type: SignalType?
        /// The unique identifier of the signal.
        public let uid: String?
        /// The timestamp when this signal was last observed.
        public let updatedAt: Date?

        @inlinable
        public init(actorIds: [String]? = nil, count: Int? = nil, createdAt: Date? = nil, description: String? = nil, endpointIds: [String]? = nil, firstSeenAt: Date? = nil, lastSeenAt: Date? = nil, name: String? = nil, resourceUids: [String]? = nil, severity: Double? = nil, signalIndicators: [Indicator]? = nil, type: SignalType? = nil, uid: String? = nil, updatedAt: Date? = nil) {
            self.actorIds = actorIds
            self.count = count
            self.createdAt = createdAt
            self.description = description
            self.endpointIds = endpointIds
            self.firstSeenAt = firstSeenAt
            self.lastSeenAt = lastSeenAt
            self.name = name
            self.resourceUids = resourceUids
            self.severity = severity
            self.signalIndicators = signalIndicators
            self.type = type
            self.uid = uid
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case actorIds = "actorIds"
            case count = "count"
            case createdAt = "createdAt"
            case description = "description"
            case endpointIds = "endpointIds"
            case firstSeenAt = "firstSeenAt"
            case lastSeenAt = "lastSeenAt"
            case name = "name"
            case resourceUids = "resourceUids"
            case severity = "severity"
            case signalIndicators = "signalIndicators"
            case type = "type"
            case uid = "uid"
            case updatedAt = "updatedAt"
        }
    }

    public struct SortCriteria: AWSEncodableShape {
        /// Represents the finding attribute, such as accountId, that sorts the findings.
        public let attributeName: String?
        /// The order by which the sorted findings are to be displayed.
        public let orderBy: OrderBy?

        @inlinable
        public init(attributeName: String? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "attributeName"
            case orderBy = "orderBy"
        }
    }

    public struct StartMalwareScanRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the resource for which you invoked the API.
        public let resourceArn: String?

        @inlinable
        public init(resourceArn: String? = nil) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z-]+:[A-Za-z0-9]+:[A-Za-z0-9-]+:\\d+:(([A-Za-z0-9-]+)[:\\/])?[A-Za-z0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct StartMalwareScanResponse: AWSDecodableShape {
        /// A unique identifier that gets generated when you invoke the API without any error. Each malware scan has  a corresponding scan ID. Using this scan ID, you can monitor the status of your malware scan.
        public let scanId: String?

        @inlinable
        public init(scanId: String? = nil) {
            self.scanId = scanId
        }

        private enum CodingKeys: String, CodingKey {
            case scanId = "scanId"
        }
    }

    public struct StartMonitoringMembersRequest: AWSEncodableShape {
        /// A list of account IDs of the GuardDuty member accounts to start monitoring.
        public let accountIds: [String]?
        /// The unique ID of the detector of the GuardDuty administrator account associated with the member accounts to monitor. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(accountIds: [String]? = nil, detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountIds, forKey: .accountIds)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct StartMonitoringMembersResponse: AWSDecodableShape {
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct StopMonitoringMembersRequest: AWSEncodableShape {
        /// A list of account IDs for the member accounts to stop monitoring.
        public let accountIds: [String]?
        /// The unique ID of the detector associated with the GuardDuty administrator account that is monitoring member accounts. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(accountIds: [String]? = nil, detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountIds, forKey: .accountIds)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct StopMonitoringMembersResponse: AWSDecodableShape {
        /// A list of objects that contain an accountId for each account that could not be processed, and a result string that indicates why the account was not processed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct Tag: AWSDecodableShape {
        /// Describes the key associated with the tag.
        public let key: String?
        /// Describes the value associated with the tag key.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the GuardDuty resource to apply a tag to.
        public let resourceArn: String
        /// The tags to be added to a resource.
        public let tags: [String: String]?

        @inlinable
        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\\d+:detector/[A-Za-z0-9_/.-]{32,264}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Threat: AWSDecodableShape {
        /// Information about the nested item path and  hash of the protected resource.
        public let itemPaths: [ItemPath]?
        /// Name of the detected threat that caused GuardDuty to generate this finding.
        public let name: String?
        /// Source of the threat that generated this finding.
        public let source: String?

        @inlinable
        public init(itemPaths: [ItemPath]? = nil, name: String? = nil, source: String? = nil) {
            self.itemPaths = itemPaths
            self.name = name
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case itemPaths = "itemPaths"
            case name = "name"
            case source = "source"
        }
    }

    public struct ThreatDetectedByName: AWSDecodableShape {
        /// Total number of infected files identified.
        public let itemCount: Int?
        /// Flag to determine if the finding contains every single infected file-path and/or every threat.
        public let shortened: Bool?
        /// List of identified threats with details, organized by threat name.
        public let threatNames: [ScanThreatName]?
        /// Total number of unique threats by name identified, as part of the malware scan.
        public let uniqueThreatNameCount: Int?

        @inlinable
        public init(itemCount: Int? = nil, shortened: Bool? = nil, threatNames: [ScanThreatName]? = nil, uniqueThreatNameCount: Int? = nil) {
            self.itemCount = itemCount
            self.shortened = shortened
            self.threatNames = threatNames
            self.uniqueThreatNameCount = uniqueThreatNameCount
        }

        private enum CodingKeys: String, CodingKey {
            case itemCount = "itemCount"
            case shortened = "shortened"
            case threatNames = "threatNames"
            case uniqueThreatNameCount = "uniqueThreatNameCount"
        }
    }

    public struct ThreatIntelligenceDetail: AWSDecodableShape {
        /// SHA256 of the file that generated the finding.
        public let threatFileSha256: String?
        /// The name of the threat intelligence list that triggered the finding.
        public let threatListName: String?
        /// A list of names of the threats in the threat intelligence list that triggered the finding.
        public let threatNames: [String]?

        @inlinable
        public init(threatFileSha256: String? = nil, threatListName: String? = nil, threatNames: [String]? = nil) {
            self.threatFileSha256 = threatFileSha256
            self.threatListName = threatListName
            self.threatNames = threatNames
        }

        private enum CodingKeys: String, CodingKey {
            case threatFileSha256 = "threatFileSha256"
            case threatListName = "threatListName"
            case threatNames = "threatNames"
        }
    }

    public struct ThreatsDetectedItemCount: AWSDecodableShape {
        /// Total number of infected files.
        public let files: Int?

        @inlinable
        public init(files: Int? = nil) {
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case files = "files"
        }
    }

    public struct Total: AWSDecodableShape {
        /// The total usage.
        public let amount: String?
        /// The currency unit that the amount is given in.
        public let unit: String?

        @inlinable
        public init(amount: String? = nil, unit: String? = nil) {
            self.amount = amount
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case unit = "unit"
        }
    }

    public struct TriggerDetails: AWSDecodableShape {
        /// The description of the scan trigger.
        public let description: String?
        /// The ID of the GuardDuty finding that triggered the malware scan.
        public let guardDutyFindingId: String?

        @inlinable
        public init(description: String? = nil, guardDutyFindingId: String? = nil) {
            self.description = description
            self.guardDutyFindingId = guardDutyFindingId
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case guardDutyFindingId = "guardDutyFindingId"
        }
    }

    public struct UnarchiveFindingsRequest: AWSEncodableShape {
        /// The ID of the detector associated with the findings to unarchive. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The IDs of the findings to unarchive.
        public let findingIds: [String]?

        @inlinable
        public init(detectorId: String, findingIds: [String]? = nil) {
            self.detectorId = detectorId
            self.findingIds = findingIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.findingIds, forKey: .findingIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.findingIds?.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try self.validate(self.findingIds, name: "findingIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds = "findingIds"
        }
    }

    public struct UnarchiveFindingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UnprocessedAccount: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// A reason why the account hasn't been processed.
        public let result: String?

        @inlinable
        public init(accountId: String? = nil, result: String? = nil) {
            self.accountId = accountId
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case result = "result"
        }
    }

    public struct UnprocessedDataSourcesResult: AWSDecodableShape {
        public let malwareProtection: MalwareProtectionConfigurationResult?

        @inlinable
        public init(malwareProtection: MalwareProtectionConfigurationResult? = nil) {
            self.malwareProtection = malwareProtection
        }

        private enum CodingKeys: String, CodingKey {
            case malwareProtection = "malwareProtection"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the resource to remove tags from.
        public let resourceArn: String
        /// The tag keys to remove from the resource.
        public let tagKeys: [String]?

        @inlinable
        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\\d+:detector/[A-Za-z0-9_/.-]{32,264}$")
            try self.tagKeys?.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDetectorRequest: AWSEncodableShape {
        /// Describes which data sources will be updated. There might be regional differences because some data sources might not be  available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more  information, see Regions and endpoints.
        public let dataSources: DataSourceConfigurations?
        /// The unique ID of the detector to update. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// Specifies whether the detector is enabled or not enabled.
        public let enable: Bool?
        /// Provides the features that will be updated for the detector.
        public let features: [DetectorFeatureConfiguration]?
        /// An enum value that specifies how frequently findings are exported, such as to CloudWatch Events.
        public let findingPublishingFrequency: FindingPublishingFrequency?

        @inlinable
        public init(detectorId: String, enable: Bool? = nil, features: [DetectorFeatureConfiguration]? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil) {
            self.dataSources = nil
            self.detectorId = detectorId
            self.enable = enable
            self.features = features
            self.findingPublishingFrequency = findingPublishingFrequency
        }

        @available(*, deprecated, message: "Members dataSources have been deprecated")
        @inlinable
        public init(dataSources: DataSourceConfigurations? = nil, detectorId: String, enable: Bool? = nil, features: [DetectorFeatureConfiguration]? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil) {
            self.dataSources = dataSources
            self.detectorId = detectorId
            self.enable = enable
            self.features = features
            self.findingPublishingFrequency = findingPublishingFrequency
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.dataSources, forKey: .dataSources)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.enable, forKey: .enable)
            try container.encodeIfPresent(self.features, forKey: .features)
            try container.encodeIfPresent(self.findingPublishingFrequency, forKey: .findingPublishingFrequency)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources = "dataSources"
            case enable = "enable"
            case features = "features"
            case findingPublishingFrequency = "findingPublishingFrequency"
        }
    }

    public struct UpdateDetectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFilterRequest: AWSEncodableShape {
        /// Specifies the action that is to be applied to the findings that match the filter.
        public let action: FilterAction?
        /// The description of the filter. Valid characters include alphanumeric characters, and special characters such as hyphen, period, colon, underscore, parentheses ({ }, [ ], and ( )), forward slash, horizontal tab, vertical tab, newline, form feed, return, and whitespace.
        public let description: String?
        /// The unique ID of the detector that specifies the GuardDuty service where you want to update a filter. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The name of the filter.
        public let filterName: String
        /// Represents the criteria to be used in the filter for querying findings.
        public let findingCriteria: FindingCriteria?
        /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
        public let rank: Int?

        @inlinable
        public init(action: FilterAction? = nil, description: String? = nil, detectorId: String, filterName: String, findingCriteria: FindingCriteria? = nil, rank: Int? = nil) {
            self.action = action
            self.description = description
            self.detectorId = detectorId
            self.filterName = filterName
            self.findingCriteria = findingCriteria
            self.rank = rank
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.action, forKey: .action)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodePath(self.filterName, key: "filterName")
            try container.encodeIfPresent(self.findingCriteria, forKey: .findingCriteria)
            try container.encodeIfPresent(self.rank, forKey: .rank)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.rank, name: "rank", parent: name, max: 100)
            try self.validate(self.rank, name: "rank", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case findingCriteria = "findingCriteria"
            case rank = "rank"
        }
    }

    public struct UpdateFilterResponse: AWSDecodableShape {
        /// The name of the filter.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct UpdateFindingsFeedbackRequest: AWSEncodableShape {
        /// Additional feedback about the GuardDuty findings.
        public let comments: String?
        /// The ID of the detector that is associated with the findings for which you want to update  the feedback. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The feedback for the finding.
        public let feedback: Feedback?
        /// The IDs of the findings that you want to mark as useful or not useful.
        public let findingIds: [String]?

        @inlinable
        public init(comments: String? = nil, detectorId: String, feedback: Feedback? = nil, findingIds: [String]? = nil) {
            self.comments = comments
            self.detectorId = detectorId
            self.feedback = feedback
            self.findingIds = findingIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.comments, forKey: .comments)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.feedback, forKey: .feedback)
            try container.encodeIfPresent(self.findingIds, forKey: .findingIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.findingIds?.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try self.validate(self.findingIds, name: "findingIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case comments = "comments"
            case feedback = "feedback"
            case findingIds = "findingIds"
        }
    }

    public struct UpdateFindingsFeedbackResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateIPSetRequest: AWSEncodableShape {
        /// The updated Boolean value that specifies whether the IPSet is active or not.
        public let activate: Bool?
        /// The detectorID that specifies the GuardDuty service whose IPSet you want to update. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The unique ID that specifies the IPSet that you want to update.
        public let ipSetId: String
        /// The updated URI of the file that contains the IPSet.
        public let location: String?
        /// The unique ID that specifies the IPSet that you want to update.
        public let name: String?

        @inlinable
        public init(activate: Bool? = nil, detectorId: String, ipSetId: String, location: String? = nil, name: String? = nil) {
            self.activate = activate
            self.detectorId = detectorId
            self.ipSetId = ipSetId
            self.location = location
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.activate, forKey: .activate)
            request.encodePath(self.detectorId, key: "detectorId")
            request.encodePath(self.ipSetId, key: "ipSetId")
            try container.encodeIfPresent(self.location, forKey: .location)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.location, name: "location", parent: name, max: 300)
            try self.validate(self.location, name: "location", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activate = "activate"
            case location = "location"
            case name = "name"
        }
    }

    public struct UpdateIPSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMalwareProtectionPlanRequest: AWSEncodableShape {
        /// Information about whether the tags will be added to the S3 object after scanning.
        public let actions: MalwareProtectionPlanActions?
        /// A unique identifier associated with the Malware Protection plan.
        public let malwareProtectionPlanId: String
        /// Information about the protected resource that is associated  with the created Malware Protection plan. Presently, S3Bucket is the only supported protected resource.
        public let protectedResource: UpdateProtectedResource?
        /// Amazon Resource Name (ARN) of the IAM role with permissions to scan and add tags to  the associated protected resource.
        public let role: String?

        @inlinable
        public init(actions: MalwareProtectionPlanActions? = nil, malwareProtectionPlanId: String, protectedResource: UpdateProtectedResource? = nil, role: String? = nil) {
            self.actions = actions
            self.malwareProtectionPlanId = malwareProtectionPlanId
            self.protectedResource = protectedResource
            self.role = role
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actions, forKey: .actions)
            request.encodePath(self.malwareProtectionPlanId, key: "malwareProtectionPlanId")
            try container.encodeIfPresent(self.protectedResource, forKey: .protectedResource)
            try container.encodeIfPresent(self.role, forKey: .role)
        }

        public func validate(name: String) throws {
            try self.protectedResource?.validate(name: "\(name).protectedResource")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case protectedResource = "protectedResource"
            case role = "role"
        }
    }

    public struct UpdateMalwareScanSettingsRequest: AWSEncodableShape {
        /// The unique ID of the detector that specifies the GuardDuty service where you want to update scan settings. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// An enum value representing possible snapshot preservation settings.
        public let ebsSnapshotPreservation: EbsSnapshotPreservation?
        /// Represents the criteria to be used in the filter for selecting resources to scan.
        public let scanResourceCriteria: ScanResourceCriteria?

        @inlinable
        public init(detectorId: String, ebsSnapshotPreservation: EbsSnapshotPreservation? = nil, scanResourceCriteria: ScanResourceCriteria? = nil) {
            self.detectorId = detectorId
            self.ebsSnapshotPreservation = ebsSnapshotPreservation
            self.scanResourceCriteria = scanResourceCriteria
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.ebsSnapshotPreservation, forKey: .ebsSnapshotPreservation)
            try container.encodeIfPresent(self.scanResourceCriteria, forKey: .scanResourceCriteria)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.scanResourceCriteria?.validate(name: "\(name).scanResourceCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case ebsSnapshotPreservation = "ebsSnapshotPreservation"
            case scanResourceCriteria = "scanResourceCriteria"
        }
    }

    public struct UpdateMalwareScanSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMemberDetectorsRequest: AWSEncodableShape {
        /// A list of member account IDs to be updated.
        public let accountIds: [String]?
        /// Describes which data sources will be updated.
        public let dataSources: DataSourceConfigurations?
        /// The detector ID of the administrator account. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// A list of features that will be updated for the specified member accounts.
        public let features: [MemberFeaturesConfiguration]?

        @inlinable
        public init(accountIds: [String]? = nil, detectorId: String, features: [MemberFeaturesConfiguration]? = nil) {
            self.accountIds = accountIds
            self.dataSources = nil
            self.detectorId = detectorId
            self.features = features
        }

        @available(*, deprecated, message: "Members dataSources have been deprecated")
        @inlinable
        public init(accountIds: [String]? = nil, dataSources: DataSourceConfigurations? = nil, detectorId: String, features: [MemberFeaturesConfiguration]? = nil) {
            self.accountIds = accountIds
            self.dataSources = dataSources
            self.detectorId = detectorId
            self.features = features
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountIds, forKey: .accountIds)
            try container.encodeIfPresent(self.dataSources, forKey: .dataSources)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.features, forKey: .features)
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case dataSources = "dataSources"
            case features = "features"
        }
    }

    public struct UpdateMemberDetectorsResponse: AWSDecodableShape {
        /// A list of member account IDs that were unable to be processed along with an explanation for why they were not processed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        @inlinable
        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct UpdateOrganizationConfigurationRequest: AWSEncodableShape {
        /// Represents whether to automatically enable member accounts in the organization. This applies to only new member accounts, not the existing member accounts. When a new account joins the organization, the chosen features will be enabled for them by default. Even though this is still supported, we recommend using AutoEnableOrganizationMembers to achieve the similar results. You must provide a  value for either autoEnableOrganizationMembers or autoEnable.
        public let autoEnable: Bool?
        /// Indicates the auto-enablement configuration of GuardDuty for the member accounts in the organization. You must provide a value for either autoEnableOrganizationMembers or autoEnable.  Use one of the  following configuration values for autoEnableOrganizationMembers:    NEW: Indicates that when a new account joins the organization, they will have GuardDuty enabled automatically.     ALL: Indicates that all accounts in the organization have GuardDuty enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty. It may take up to 24 hours to update the configuration for all the member accounts.    NONE: Indicates that GuardDuty will not be automatically enabled for any account in the organization. The administrator must manage GuardDuty for each account in the organization individually. When you update the auto-enable setting from ALL or NEW to  NONE, this action doesn't disable the corresponding option for your existing accounts. This configuration will apply to the new accounts that join the organization. After you update the auto-enable settings, no new account will have the corresponding option as enabled.
        public let autoEnableOrganizationMembers: AutoEnableMembers?
        /// Describes which data sources will be updated.
        public let dataSources: OrganizationDataSourceConfigurations?
        /// The ID of the detector that configures the delegated administrator. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// A list of features that will be configured for the organization.
        public let features: [OrganizationFeatureConfiguration]?

        @inlinable
        public init(autoEnableOrganizationMembers: AutoEnableMembers? = nil, detectorId: String, features: [OrganizationFeatureConfiguration]? = nil) {
            self.autoEnable = nil
            self.autoEnableOrganizationMembers = autoEnableOrganizationMembers
            self.dataSources = nil
            self.detectorId = detectorId
            self.features = features
        }

        @available(*, deprecated, message: "Members autoEnable, dataSources have been deprecated")
        @inlinable
        public init(autoEnable: Bool? = nil, autoEnableOrganizationMembers: AutoEnableMembers? = nil, dataSources: OrganizationDataSourceConfigurations? = nil, detectorId: String, features: [OrganizationFeatureConfiguration]? = nil) {
            self.autoEnable = autoEnable
            self.autoEnableOrganizationMembers = autoEnableOrganizationMembers
            self.dataSources = dataSources
            self.detectorId = detectorId
            self.features = features
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.autoEnable, forKey: .autoEnable)
            try container.encodeIfPresent(self.autoEnableOrganizationMembers, forKey: .autoEnableOrganizationMembers)
            try container.encodeIfPresent(self.dataSources, forKey: .dataSources)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.features, forKey: .features)
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
            case autoEnableOrganizationMembers = "autoEnableOrganizationMembers"
            case dataSources = "dataSources"
            case features = "features"
        }
    }

    public struct UpdateOrganizationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateProtectedResource: AWSEncodableShape {
        /// Information about the protected S3 bucket resource.
        public let s3Bucket: UpdateS3BucketResource?

        @inlinable
        public init(s3Bucket: UpdateS3BucketResource? = nil) {
            self.s3Bucket = s3Bucket
        }

        public func validate(name: String) throws {
            try self.s3Bucket?.validate(name: "\(name).s3Bucket")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
        }
    }

    public struct UpdatePublishingDestinationRequest: AWSEncodableShape {
        /// The ID of the publishing destination to update.
        public let destinationId: String
        /// A DestinationProperties object that includes the DestinationArn and KmsKeyArn of the publishing destination.
        public let destinationProperties: DestinationProperties?
        /// The ID of the detector associated with the publishing destinations to update. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String

        @inlinable
        public init(destinationId: String, destinationProperties: DestinationProperties? = nil, detectorId: String) {
            self.destinationId = destinationId
            self.destinationProperties = destinationProperties
            self.detectorId = detectorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.destinationId, key: "destinationId")
            try container.encodeIfPresent(self.destinationProperties, forKey: .destinationProperties)
            request.encodePath(self.detectorId, key: "detectorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationProperties = "destinationProperties"
        }
    }

    public struct UpdatePublishingDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateS3BucketResource: AWSEncodableShape {
        /// Information about the specified object prefixes. The S3 object will be scanned only  if it belongs to any of the specified object prefixes.
        public let objectPrefixes: [String]?

        @inlinable
        public init(objectPrefixes: [String]? = nil) {
            self.objectPrefixes = objectPrefixes
        }

        public func validate(name: String) throws {
            try self.validate(self.objectPrefixes, name: "objectPrefixes", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case objectPrefixes = "objectPrefixes"
        }
    }

    public struct UpdateThreatIntelSetRequest: AWSEncodableShape {
        /// The updated Boolean value that specifies whether the ThreateIntelSet is active or not.
        public let activate: Bool?
        /// The detectorID that specifies the GuardDuty service whose ThreatIntelSet you want to update. To find the detectorId in the current Region, see the
        /// Settings page in the GuardDuty console, or run the ListDetectors API.
        public let detectorId: String
        /// The updated URI of the file that contains the ThreateIntelSet.
        public let location: String?
        /// The unique ID that specifies the ThreatIntelSet that you want to update.
        public let name: String?
        /// The unique ID that specifies the ThreatIntelSet that you want to update.
        public let threatIntelSetId: String

        @inlinable
        public init(activate: Bool? = nil, detectorId: String, location: String? = nil, name: String? = nil, threatIntelSetId: String) {
            self.activate = activate
            self.detectorId = detectorId
            self.location = location
            self.name = name
            self.threatIntelSetId = threatIntelSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.activate, forKey: .activate)
            request.encodePath(self.detectorId, key: "detectorId")
            try container.encodeIfPresent(self.location, forKey: .location)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.threatIntelSetId, key: "threatIntelSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.location, name: "location", parent: name, max: 300)
            try self.validate(self.location, name: "location", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activate = "activate"
            case location = "location"
            case name = "name"
        }
    }

    public struct UpdateThreatIntelSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UsageAccountResult: AWSDecodableShape {
        /// The Account ID that generated usage.
        public let accountId: String?
        /// Represents the total of usage for the Account ID.
        public let total: Total?

        @inlinable
        public init(accountId: String? = nil, total: Total? = nil) {
            self.accountId = accountId
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case total = "total"
        }
    }

    public struct UsageCriteria: AWSEncodableShape {
        /// The account IDs to aggregate usage statistics from.
        public let accountIds: [String]?
        /// The data sources to aggregate usage statistics from.
        public let dataSources: [DataSource]?
        /// The features to aggregate usage statistics from.
        public let features: [UsageFeature]?
        /// The resources to aggregate usage statistics from. Only accepts exact resource names.
        public let resources: [String]?

        @inlinable
        public init(accountIds: [String]? = nil, features: [UsageFeature]? = nil, resources: [String]? = nil) {
            self.accountIds = accountIds
            self.dataSources = nil
            self.features = features
            self.resources = resources
        }

        @available(*, deprecated, message: "Members dataSources have been deprecated")
        @inlinable
        public init(accountIds: [String]? = nil, dataSources: [DataSource]? = nil, features: [UsageFeature]? = nil, resources: [String]? = nil) {
            self.accountIds = accountIds
            self.dataSources = dataSources
            self.features = features
            self.resources = resources
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case dataSources = "dataSources"
            case features = "features"
            case resources = "resources"
        }
    }

    public struct UsageDataSourceResult: AWSDecodableShape {
        /// The data source type that generated usage.
        public let dataSource: DataSource?
        /// Represents the total of usage for the specified data source.
        public let total: Total?

        @inlinable
        public init(dataSource: DataSource? = nil, total: Total? = nil) {
            self.dataSource = dataSource
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
            case total = "total"
        }
    }

    public struct UsageFeatureResult: AWSDecodableShape {
        /// The feature that generated the usage cost.
        public let feature: UsageFeature?
        public let total: Total?

        @inlinable
        public init(feature: UsageFeature? = nil, total: Total? = nil) {
            self.feature = feature
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case feature = "feature"
            case total = "total"
        }
    }

    public struct UsageResourceResult: AWSDecodableShape {
        /// The Amazon Web Services resource that generated usage.
        public let resource: String?
        /// Represents the sum total of usage for the specified resource type.
        public let total: Total?

        @inlinable
        public init(resource: String? = nil, total: Total? = nil) {
            self.resource = resource
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "resource"
            case total = "total"
        }
    }

    public struct UsageStatistics: AWSDecodableShape {
        /// The usage statistic sum organized by account ID.
        public let sumByAccount: [UsageAccountResult]?
        /// The usage statistic sum organized by on data source.
        public let sumByDataSource: [UsageDataSourceResult]?
        /// The usage statistic sum organized by feature.
        public let sumByFeature: [UsageFeatureResult]?
        /// The usage statistic sum organized by resource.
        public let sumByResource: [UsageResourceResult]?
        /// Lists the top 50 accounts by feature that have generated the most GuardDuty usage, in the order from most to least expensive. Currently, this doesn't support RDS_LOGIN_EVENTS.
        public let topAccountsByFeature: [UsageTopAccountsResult]?
        /// Lists the top 50 resources that have generated the most GuardDuty usage, in order from most to least expensive.
        public let topResources: [UsageResourceResult]?

        @inlinable
        public init(sumByAccount: [UsageAccountResult]? = nil, sumByDataSource: [UsageDataSourceResult]? = nil, sumByFeature: [UsageFeatureResult]? = nil, sumByResource: [UsageResourceResult]? = nil, topAccountsByFeature: [UsageTopAccountsResult]? = nil, topResources: [UsageResourceResult]? = nil) {
            self.sumByAccount = sumByAccount
            self.sumByDataSource = sumByDataSource
            self.sumByFeature = sumByFeature
            self.sumByResource = sumByResource
            self.topAccountsByFeature = topAccountsByFeature
            self.topResources = topResources
        }

        private enum CodingKeys: String, CodingKey {
            case sumByAccount = "sumByAccount"
            case sumByDataSource = "sumByDataSource"
            case sumByFeature = "sumByFeature"
            case sumByResource = "sumByResource"
            case topAccountsByFeature = "topAccountsByFeature"
            case topResources = "topResources"
        }
    }

    public struct UsageTopAccountResult: AWSDecodableShape {
        /// The unique account ID.
        public let accountId: String?
        public let total: Total?

        @inlinable
        public init(accountId: String? = nil, total: Total? = nil) {
            self.accountId = accountId
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case total = "total"
        }
    }

    public struct UsageTopAccountsResult: AWSDecodableShape {
        /// The accounts that contributed to the total usage cost.
        public let accounts: [UsageTopAccountResult]?
        /// Features by which you can generate the usage statistics.  RDS_LOGIN_EVENTS is currently not supported  with topAccountsByFeature.
        public let feature: UsageFeature?

        @inlinable
        public init(accounts: [UsageTopAccountResult]? = nil, feature: UsageFeature? = nil) {
            self.accounts = accounts
            self.feature = feature
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "accounts"
            case feature = "feature"
        }
    }

    public struct User: AWSDecodableShape {
        /// Contains information about the Amazon Web Services account.
        public let account: Account?
        /// The credentials of the user ID.
        public let credentialUid: String?
        /// The name of the user.
        public let name: String?
        /// The type of the user.
        public let type: String?
        /// The unique identifier of the user.
        public let uid: String?

        @inlinable
        public init(account: Account? = nil, credentialUid: String? = nil, name: String? = nil, type: String? = nil, uid: String? = nil) {
            self.account = account
            self.credentialUid = credentialUid
            self.name = name
            self.type = type
            self.uid = uid
        }

        private enum CodingKeys: String, CodingKey {
            case account = "account"
            case credentialUid = "credentialUid"
            case name = "name"
            case type = "type"
            case uid = "uid"
        }
    }

    public struct Volume: AWSDecodableShape {
        /// Represents a pre-existing file or directory on the host machine that the volume maps to.
        public let hostPath: HostPath?
        /// Volume name.
        public let name: String?

        @inlinable
        public init(hostPath: HostPath? = nil, name: String? = nil) {
            self.hostPath = hostPath
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case hostPath = "hostPath"
            case name = "name"
        }
    }

    public struct VolumeDetail: AWSDecodableShape {
        /// The device name for the EBS volume.
        public let deviceName: String?
        /// EBS volume encryption type.
        public let encryptionType: String?
        /// KMS key ARN used to encrypt the EBS volume.
        public let kmsKeyArn: String?
        /// Snapshot ARN of the EBS volume.
        public let snapshotArn: String?
        /// EBS volume ARN information.
        public let volumeArn: String?
        /// EBS volume size in GB.
        public let volumeSizeInGB: Int?
        /// The EBS volume type.
        public let volumeType: String?

        @inlinable
        public init(deviceName: String? = nil, encryptionType: String? = nil, kmsKeyArn: String? = nil, snapshotArn: String? = nil, volumeArn: String? = nil, volumeSizeInGB: Int? = nil, volumeType: String? = nil) {
            self.deviceName = deviceName
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
            self.snapshotArn = snapshotArn
            self.volumeArn = volumeArn
            self.volumeSizeInGB = volumeSizeInGB
            self.volumeType = volumeType
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "deviceName"
            case encryptionType = "encryptionType"
            case kmsKeyArn = "kmsKeyArn"
            case snapshotArn = "snapshotArn"
            case volumeArn = "volumeArn"
            case volumeSizeInGB = "volumeSizeInGB"
            case volumeType = "volumeType"
        }
    }

    public struct VolumeMount: AWSDecodableShape {
        /// Volume mount path.
        public let mountPath: String?
        /// Volume mount name.
        public let name: String?

        @inlinable
        public init(mountPath: String? = nil, name: String? = nil) {
            self.mountPath = mountPath
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case mountPath = "mountPath"
            case name = "name"
        }
    }

    public struct VpcConfig: AWSDecodableShape {
        /// The identifier of the security group attached to the Lambda function.
        public let securityGroups: [SecurityGroup]?
        /// The identifiers of the subnets that are associated with your Lambda function.
        public let subnetIds: [String]?
        /// The identifier of the Amazon Virtual Private Cloud.
        public let vpcId: String?

        @inlinable
        public init(securityGroups: [SecurityGroup]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.securityGroups = securityGroups
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroups = "securityGroups"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }
}

// MARK: - Errors

/// Error enum for GuardDuty
public struct GuardDutyErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case internalServerErrorException = "InternalServerErrorException"
        case resourceNotFoundException = "ResourceNotFoundException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize GuardDuty
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An access denied exception object.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A bad request exception object.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// A request conflict exception object.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error exception object.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// The requested resource can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
}

extension GuardDutyErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": GuardDuty.AccessDeniedException.self,
        "BadRequestException": GuardDuty.BadRequestException.self,
        "ConflictException": GuardDuty.ConflictException.self,
        "InternalServerErrorException": GuardDuty.InternalServerErrorException.self,
        "ResourceNotFoundException": GuardDuty.ResourceNotFoundException.self
    ]
}

extension GuardDutyErrorType: Equatable {
    public static func == (lhs: GuardDutyErrorType, rhs: GuardDutyErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GuardDutyErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
