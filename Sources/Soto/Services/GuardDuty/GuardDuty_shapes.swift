//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension GuardDuty {
    // MARK: Enums

    public enum AdminStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum CriterionKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case accountId = "ACCOUNT_ID"
        case ec2InstanceArn = "EC2_INSTANCE_ARN"
        case guarddutyFindingId = "GUARDDUTY_FINDING_ID"
        case scanId = "SCAN_ID"
        case scanStartTime = "SCAN_START_TIME"
        case scanStatus = "SCAN_STATUS"
        public var description: String { return self.rawValue }
    }

    public enum DataSource: String, CustomStringConvertible, Codable, _SotoSendable {
        case cloudTrail = "CLOUD_TRAIL"
        case dnsLogs = "DNS_LOGS"
        case ec2MalwareScan = "EC2_MALWARE_SCAN"
        case flowLogs = "FLOW_LOGS"
        case kubernetesAuditLogs = "KUBERNETES_AUDIT_LOGS"
        case s3Logs = "S3_LOGS"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DestinationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum DetectorStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum EbsSnapshotPreservation: String, CustomStringConvertible, Codable, _SotoSendable {
        case noRetention = "NO_RETENTION"
        case retentionWithFinding = "RETENTION_WITH_FINDING"
        public var description: String { return self.rawValue }
    }

    public enum Feedback: String, CustomStringConvertible, Codable, _SotoSendable {
        case notUseful = "NOT_USEFUL"
        case useful = "USEFUL"
        public var description: String { return self.rawValue }
    }

    public enum FilterAction: String, CustomStringConvertible, Codable, _SotoSendable {
        case archive = "ARCHIVE"
        case noop = "NOOP"
        public var description: String { return self.rawValue }
    }

    public enum FindingPublishingFrequency: String, CustomStringConvertible, Codable, _SotoSendable {
        case fifteenMinutes = "FIFTEEN_MINUTES"
        case oneHour = "ONE_HOUR"
        case sixHours = "SIX_HOURS"
        public var description: String { return self.rawValue }
    }

    public enum FindingStatisticType: String, CustomStringConvertible, Codable, _SotoSendable {
        case countBySeverity = "COUNT_BY_SEVERITY"
        public var description: String { return self.rawValue }
    }

    public enum IpSetFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        case alienVault = "ALIEN_VAULT"
        case fireEye = "FIRE_EYE"
        case otxCsv = "OTX_CSV"
        case proofPoint = "PROOF_POINT"
        case stix = "STIX"
        case txt = "TXT"
        public var description: String { return self.rawValue }
    }

    public enum IpSetStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case deactivating = "DEACTIVATING"
        case deletePending = "DELETE_PENDING"
        case deleted = "DELETED"
        case error = "ERROR"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum OrderBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum PublishingStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case pendingVerification = "PENDING_VERIFICATION"
        case publishing = "PUBLISHING"
        case stopped = "STOPPED"
        case unableToPublishFixDestinationProperty = "UNABLE_TO_PUBLISH_FIX_DESTINATION_PROPERTY"
        public var description: String { return self.rawValue }
    }

    public enum ScanCriterionKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case ec2InstanceTag = "EC2_INSTANCE_TAG"
        public var description: String { return self.rawValue }
    }

    public enum ScanResult: String, CustomStringConvertible, Codable, _SotoSendable {
        case clean = "CLEAN"
        case infected = "INFECTED"
        public var description: String { return self.rawValue }
    }

    public enum ScanStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelSetFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        case alienVault = "ALIEN_VAULT"
        case fireEye = "FIRE_EYE"
        case otxCsv = "OTX_CSV"
        case proofPoint = "PROOF_POINT"
        case stix = "STIX"
        case txt = "TXT"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelSetStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case deactivating = "DEACTIVATING"
        case deletePending = "DELETE_PENDING"
        case deleted = "DELETED"
        case error = "ERROR"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum UsageStatisticType: String, CustomStringConvertible, Codable, _SotoSendable {
        case sumByAccount = "SUM_BY_ACCOUNT"
        case sumByDataSource = "SUM_BY_DATA_SOURCE"
        case sumByResource = "SUM_BY_RESOURCE"
        case topResources = "TOP_RESOURCES"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcceptAdministratorInvitationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The account ID of the GuardDuty administrator account whose invitation you're accepting.
        public let administratorId: String
        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String
        /// The value that is used to validate the administrator account to the member account.
        public let invitationId: String

        public init(administratorId: String, detectorId: String, invitationId: String) {
            self.administratorId = administratorId
            self.detectorId = detectorId
            self.invitationId = invitationId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case administratorId
            case invitationId
        }
    }

    public struct AcceptAdministratorInvitationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AcceptInvitationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String
        /// The value that is used to validate the administrator account to the member account.
        public let invitationId: String
        /// The account ID of the GuardDuty administrator account whose invitation you're accepting.
        public let masterId: String

        public init(detectorId: String, invitationId: String, masterId: String) {
            self.detectorId = detectorId
            self.invitationId = invitationId
            self.masterId = masterId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invitationId
            case masterId
        }
    }

    public struct AcceptInvitationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AccessControlList: AWSDecodableShape {
        /// A value that indicates whether public read access for the bucket is enabled through an Access Control List (ACL).
        public let allowsPublicReadAccess: Bool?
        /// A value that indicates whether public write access for the bucket is enabled through an Access Control List (ACL).
        public let allowsPublicWriteAccess: Bool?

        public init(allowsPublicReadAccess: Bool? = nil, allowsPublicWriteAccess: Bool? = nil) {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }

        private enum CodingKeys: String, CodingKey {
            case allowsPublicReadAccess
            case allowsPublicWriteAccess
        }
    }

    public struct AccessKeyDetails: AWSDecodableShape {
        /// The access key ID of the user.
        public let accessKeyId: String?
        /// The principal ID of the user.
        public let principalId: String?
        /// The name of the user.
        public let userName: String?
        /// The type of the user.
        public let userType: String?

        public init(accessKeyId: String? = nil, principalId: String? = nil, userName: String? = nil, userType: String? = nil) {
            self.accessKeyId = accessKeyId
            self.principalId = principalId
            self.userName = userName
            self.userType = userType
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId
            case principalId
            case userName
            case userType
        }
    }

    public struct AccountDetail: AWSEncodableShape {
        /// The member account ID.
        public let accountId: String
        /// The email address of the member account.
        public let email: String

        public init(accountId: String, email: String) {
            self.accountId = accountId
            self.email = email
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.email, name: "email", parent: name, max: 64)
            try self.validate(self.email, name: "email", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case email
        }
    }

    public struct AccountFreeTrialInfo: AWSDecodableShape {
        /// The account identifier of the GuardDuty member account.
        public let accountId: String?
        /// Describes the data source enabled for the GuardDuty member account.
        public let dataSources: DataSourcesFreeTrial?

        public init(accountId: String? = nil, dataSources: DataSourcesFreeTrial? = nil) {
            self.accountId = accountId
            self.dataSources = dataSources
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case dataSources
        }
    }

    public struct AccountLevelPermissions: AWSDecodableShape {
        /// Describes the S3 Block Public Access settings of the bucket's parent account.
        public let blockPublicAccess: BlockPublicAccess?

        public init(blockPublicAccess: BlockPublicAccess? = nil) {
            self.blockPublicAccess = blockPublicAccess
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAccess
        }
    }

    public struct Action: AWSDecodableShape {
        /// The GuardDuty finding activity type.
        public let actionType: String?
        /// Information about the AWS_API_CALL action described in this finding.
        public let awsApiCallAction: AwsApiCallAction?
        /// Information about the DNS_REQUEST action described in this finding.
        public let dnsRequestAction: DnsRequestAction?
        /// Information about the Kubernetes API call action described in this finding.
        public let kubernetesApiCallAction: KubernetesApiCallAction?
        /// Information about the NETWORK_CONNECTION action described in this finding.
        public let networkConnectionAction: NetworkConnectionAction?
        /// Information about the PORT_PROBE action described in this finding.
        public let portProbeAction: PortProbeAction?

        public init(actionType: String? = nil, awsApiCallAction: AwsApiCallAction? = nil, dnsRequestAction: DnsRequestAction? = nil, kubernetesApiCallAction: KubernetesApiCallAction? = nil, networkConnectionAction: NetworkConnectionAction? = nil, portProbeAction: PortProbeAction? = nil) {
            self.actionType = actionType
            self.awsApiCallAction = awsApiCallAction
            self.dnsRequestAction = dnsRequestAction
            self.kubernetesApiCallAction = kubernetesApiCallAction
            self.networkConnectionAction = networkConnectionAction
            self.portProbeAction = portProbeAction
        }

        private enum CodingKeys: String, CodingKey {
            case actionType
            case awsApiCallAction
            case dnsRequestAction
            case kubernetesApiCallAction
            case networkConnectionAction
            case portProbeAction
        }
    }

    public struct AdminAccount: AWSDecodableShape {
        /// The Amazon Web Services account ID for the account.
        public let adminAccountId: String?
        /// Indicates whether the account is enabled as the delegated administrator.
        public let adminStatus: AdminStatus?

        public init(adminAccountId: String? = nil, adminStatus: AdminStatus? = nil) {
            self.adminAccountId = adminAccountId
            self.adminStatus = adminStatus
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId
            case adminStatus
        }
    }

    public struct Administrator: AWSDecodableShape {
        /// The ID of the account used as the administrator account.
        public let accountId: String?
        /// The value that is used to validate the administrator account to the member account.
        public let invitationId: String?
        /// The timestamp when the invitation was sent.
        public let invitedAt: String?
        /// The status of the relationship between the administrator and member accounts.
        public let relationshipStatus: String?

        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: String? = nil, relationshipStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case invitationId
            case invitedAt
            case relationshipStatus
        }
    }

    public struct ArchiveFindingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The ID of the detector that specifies the GuardDuty service whose findings you want to archive.
        public let detectorId: String
        /// The IDs of the findings that you want to archive.
        public let findingIds: [String]

        public init(detectorId: String, findingIds: [String]) {
            self.detectorId = detectorId
            self.findingIds = findingIds
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.findingIds.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try self.validate(self.findingIds, name: "findingIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds
        }
    }

    public struct ArchiveFindingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AwsApiCallAction: AWSDecodableShape {
        /// The details of the Amazon Web Services account that made the API call. This field identifies the resources that were affected by this API call.
        public let affectedResources: [String: String]?
        /// The Amazon Web Services API name.
        public let api: String?
        /// The Amazon Web Services API caller type.
        public let callerType: String?
        /// The domain information for the Amazon Web Services API call.
        public let domainDetails: DomainDetails?
        /// The error code of the failed Amazon Web Services API action.
        public let errorCode: String?
        /// The details of the Amazon Web Services account that made the API call. This field appears if the call was made from outside your account.
        public let remoteAccountDetails: RemoteAccountDetails?
        /// The remote IP information of the connection that initiated the Amazon Web Services API call.
        public let remoteIpDetails: RemoteIpDetails?
        /// The Amazon Web Services service name whose API was invoked.
        public let serviceName: String?
        /// The agent through which the API request was made.
        public let userAgent: String?

        public init(affectedResources: [String: String]? = nil, api: String? = nil, callerType: String? = nil, domainDetails: DomainDetails? = nil, errorCode: String? = nil, remoteAccountDetails: RemoteAccountDetails? = nil, remoteIpDetails: RemoteIpDetails? = nil, serviceName: String? = nil, userAgent: String? = nil) {
            self.affectedResources = affectedResources
            self.api = api
            self.callerType = callerType
            self.domainDetails = domainDetails
            self.errorCode = errorCode
            self.remoteAccountDetails = remoteAccountDetails
            self.remoteIpDetails = remoteIpDetails
            self.serviceName = serviceName
            self.userAgent = userAgent
        }

        private enum CodingKeys: String, CodingKey {
            case affectedResources
            case api
            case callerType
            case domainDetails
            case errorCode
            case remoteAccountDetails
            case remoteIpDetails
            case serviceName
            case userAgent
        }
    }

    public struct BlockPublicAccess: AWSDecodableShape {
        /// Indicates if S3 Block Public Access is set to BlockPublicAcls.
        public let blockPublicAcls: Bool?
        /// Indicates if S3 Block Public Access is set to BlockPublicPolicy.
        public let blockPublicPolicy: Bool?
        /// Indicates if S3 Block Public Access is set to IgnorePublicAcls.
        public let ignorePublicAcls: Bool?
        /// Indicates if S3 Block Public Access is set to RestrictPublicBuckets.
        public let restrictPublicBuckets: Bool?

        public init(blockPublicAcls: Bool? = nil, blockPublicPolicy: Bool? = nil, ignorePublicAcls: Bool? = nil, restrictPublicBuckets: Bool? = nil) {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAcls
            case blockPublicPolicy
            case ignorePublicAcls
            case restrictPublicBuckets
        }
    }

    public struct BucketLevelPermissions: AWSDecodableShape {
        /// Contains information on how Access Control Policies are applied to the bucket.
        public let accessControlList: AccessControlList?
        /// Contains information on which account level S3 Block Public Access settings are applied to the S3 bucket.
        public let blockPublicAccess: BlockPublicAccess?
        /// Contains information on the bucket policies for the S3 bucket.
        public let bucketPolicy: BucketPolicy?

        public init(accessControlList: AccessControlList? = nil, blockPublicAccess: BlockPublicAccess? = nil, bucketPolicy: BucketPolicy? = nil) {
            self.accessControlList = accessControlList
            self.blockPublicAccess = blockPublicAccess
            self.bucketPolicy = bucketPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlList
            case blockPublicAccess
            case bucketPolicy
        }
    }

    public struct BucketPolicy: AWSDecodableShape {
        /// A value that indicates whether public read access for the bucket is enabled through a bucket policy.
        public let allowsPublicReadAccess: Bool?
        /// A value that indicates whether public write access for the bucket is enabled through a bucket policy.
        public let allowsPublicWriteAccess: Bool?

        public init(allowsPublicReadAccess: Bool? = nil, allowsPublicWriteAccess: Bool? = nil) {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }

        private enum CodingKeys: String, CodingKey {
            case allowsPublicReadAccess
            case allowsPublicWriteAccess
        }
    }

    public struct City: AWSDecodableShape {
        /// The city name of the remote IP address.
        public let cityName: String?

        public init(cityName: String? = nil) {
            self.cityName = cityName
        }

        private enum CodingKeys: String, CodingKey {
            case cityName
        }
    }

    public struct CloudTrailConfigurationResult: AWSDecodableShape {
        /// Describes whether CloudTrail is enabled as a data source for the detector.
        public let status: DataSourceStatus

        public init(status: DataSourceStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct Condition: AWSEncodableShape & AWSDecodableShape {
        /// Represents the equal condition to be applied to a single field when querying for findings.
        public let eq: [String]?
        /// Represents an equal condition to be applied to a single field when querying for findings.
        public let equals: [String]?
        /// Represents a greater than condition to be applied to a single field when querying for findings.
        public let greaterThan: Int64?
        /// Represents a greater than or equal condition to be applied to a single field when querying for findings.
        public let greaterThanOrEqual: Int64?
        /// Represents a greater than condition to be applied to a single field when querying for findings.
        public let gt: Int?
        /// Represents a greater than or equal condition to be applied to a single field when querying for findings.
        public let gte: Int?
        /// Represents a less than condition to be applied to a single field when querying for findings.
        public let lessThan: Int64?
        /// Represents a less than or equal condition to be applied to a single field when querying for findings.
        public let lessThanOrEqual: Int64?
        /// Represents a less than condition to be applied to a single field when querying for findings.
        public let lt: Int?
        /// Represents a less than or equal condition to be applied to a single field when querying for findings.
        public let lte: Int?
        /// Represents the not equal condition to be applied to a single field when querying for findings.
        public let neq: [String]?
        /// Represents a not equal condition to be applied to a single field when querying for findings.
        public let notEquals: [String]?

        public init(equals: [String]? = nil, greaterThan: Int64? = nil, greaterThanOrEqual: Int64? = nil, lessThan: Int64? = nil, lessThanOrEqual: Int64? = nil, notEquals: [String]? = nil) {
            self.eq = nil
            self.equals = equals
            self.greaterThan = greaterThan
            self.greaterThanOrEqual = greaterThanOrEqual
            self.gt = nil
            self.gte = nil
            self.lessThan = lessThan
            self.lessThanOrEqual = lessThanOrEqual
            self.lt = nil
            self.lte = nil
            self.neq = nil
            self.notEquals = notEquals
        }

        @available(*, deprecated, message: "Members eq, gt, gte, lt, lte, neq have been deprecated")
        public init(eq: [String]? = nil, equals: [String]? = nil, greaterThan: Int64? = nil, greaterThanOrEqual: Int64? = nil, gt: Int? = nil, gte: Int? = nil, lessThan: Int64? = nil, lessThanOrEqual: Int64? = nil, lt: Int? = nil, lte: Int? = nil, neq: [String]? = nil, notEquals: [String]? = nil) {
            self.eq = eq
            self.equals = equals
            self.greaterThan = greaterThan
            self.greaterThanOrEqual = greaterThanOrEqual
            self.gt = gt
            self.gte = gte
            self.lessThan = lessThan
            self.lessThanOrEqual = lessThanOrEqual
            self.lt = lt
            self.lte = lte
            self.neq = neq
            self.notEquals = notEquals
        }

        private enum CodingKeys: String, CodingKey {
            case eq
            case equals
            case greaterThan
            case greaterThanOrEqual
            case gt
            case gte
            case lessThan
            case lessThanOrEqual
            case lt
            case lte
            case neq
            case notEquals
        }
    }

    public struct Container: AWSDecodableShape {
        /// The container runtime (such as, Docker or containerd) used to run the container.
        public let containerRuntime: String?
        /// Container ID.
        public let id: String?
        /// Container image.
        public let image: String?
        /// Part of the image name before the last slash. For example, imagePrefix for public.ecr.aws/amazonlinux/amazonlinux:latest would be public.ecr.aws/amazonlinux. If the image name is relative and does not have a slash, this field is empty.
        public let imagePrefix: String?
        /// Container name.
        public let name: String?
        /// Container security context.
        public let securityContext: SecurityContext?
        /// Container volume mounts.
        public let volumeMounts: [VolumeMount]?

        public init(containerRuntime: String? = nil, id: String? = nil, image: String? = nil, imagePrefix: String? = nil, name: String? = nil, securityContext: SecurityContext? = nil, volumeMounts: [VolumeMount]? = nil) {
            self.containerRuntime = containerRuntime
            self.id = id
            self.image = image
            self.imagePrefix = imagePrefix
            self.name = name
            self.securityContext = securityContext
            self.volumeMounts = volumeMounts
        }

        private enum CodingKeys: String, CodingKey {
            case containerRuntime
            case id
            case image
            case imagePrefix
            case name
            case securityContext
            case volumeMounts
        }
    }

    public struct Country: AWSDecodableShape {
        /// The country code of the remote IP address.
        public let countryCode: String?
        /// The country name of the remote IP address.
        public let countryName: String?

        public init(countryCode: String? = nil, countryName: String? = nil) {
            self.countryCode = countryCode
            self.countryName = countryName
        }

        private enum CodingKeys: String, CodingKey {
            case countryCode
            case countryName
        }
    }

    public struct CreateDetectorRequest: AWSEncodableShape {
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// Describes which data sources will be enabled for the detector.
        public let dataSources: DataSourceConfigurations?
        /// A Boolean value that specifies whether the detector is to be enabled.
        public let enable: Bool
        /// A value that specifies how frequently updated findings are exported.
        public let findingPublishingFrequency: FindingPublishingFrequency?
        /// The tags to be added to a new detector resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateDetectorRequest.idempotencyToken(), dataSources: DataSourceConfigurations? = nil, enable: Bool = false, findingPublishingFrequency: FindingPublishingFrequency? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.dataSources = dataSources
            self.enable = enable
            self.findingPublishingFrequency = findingPublishingFrequency
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case dataSources
            case enable
            case findingPublishingFrequency
            case tags
        }
    }

    public struct CreateDetectorResponse: AWSDecodableShape {
        /// The unique ID of the created detector.
        public let detectorId: String?
        /// Specifies the data sources that couldn't be enabled when GuardDuty was enabled for the  first time.
        public let unprocessedDataSources: UnprocessedDataSourcesResult?

        public init(detectorId: String? = nil, unprocessedDataSources: UnprocessedDataSourcesResult? = nil) {
            self.detectorId = detectorId
            self.unprocessedDataSources = unprocessedDataSources
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId
            case unprocessedDataSources
        }
    }

    public struct CreateFilterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// Specifies the action that is to be applied to the findings that match the filter.
        public let action: FilterAction?
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// The description of the filter. Valid special characters include period (.), underscore (_), dash (-),  and whitespace. The new line character is considered to be an invalid input for description.
        public let description: String?
        /// The ID of the detector belonging to the GuardDuty account that you want to create a filter for.
        public let detectorId: String
        /// Represents the criteria to be used in the filter for querying findings. You can only use the following attributes to query findings:   accountId   region   confidence   id   resource.accessKeyDetails.accessKeyId   resource.accessKeyDetails.principalId   resource.accessKeyDetails.userName   resource.accessKeyDetails.userType   resource.instanceDetails.iamInstanceProfile.id   resource.instanceDetails.imageId   resource.instanceDetails.instanceId   resource.instanceDetails.outpostArn   resource.instanceDetails.networkInterfaces.ipv6Addresses   resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress   resource.instanceDetails.networkInterfaces.publicDnsName   resource.instanceDetails.networkInterfaces.publicIp   resource.instanceDetails.networkInterfaces.securityGroups.groupId   resource.instanceDetails.networkInterfaces.securityGroups.groupName   resource.instanceDetails.networkInterfaces.subnetId   resource.instanceDetails.networkInterfaces.vpcId   resource.instanceDetails.tags.key   resource.instanceDetails.tags.value   resource.resourceType   service.action.actionType   service.action.awsApiCallAction.api   service.action.awsApiCallAction.callerType   service.action.awsApiCallAction.errorCode   service.action.awsApiCallAction.userAgent   service.action.awsApiCallAction.remoteIpDetails.city.cityName   service.action.awsApiCallAction.remoteIpDetails.country.countryName   service.action.awsApiCallAction.remoteIpDetails.ipAddressV4   service.action.awsApiCallAction.remoteIpDetails.organization.asn   service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg   service.action.awsApiCallAction.serviceName   service.action.dnsRequestAction.domain   service.action.networkConnectionAction.blocked   service.action.networkConnectionAction.connectionDirection   service.action.networkConnectionAction.localPortDetails.port   service.action.networkConnectionAction.protocol   service.action.networkConnectionAction.localIpDetails.ipAddressV4   service.action.networkConnectionAction.remoteIpDetails.city.cityName   service.action.networkConnectionAction.remoteIpDetails.country.countryName   service.action.networkConnectionAction.remoteIpDetails.ipAddressV4   service.action.networkConnectionAction.remoteIpDetails.organization.asn   service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg   service.action.networkConnectionAction.remotePortDetails.port   service.additionalInfo.threatListName   resource.s3BucketDetails.publicAccess.effectivePermissions   resource.s3BucketDetails.name   resource.s3BucketDetails.tags.key   resource.s3BucketDetails.tags.value   resource.s3BucketDetails.type   service.archived When this attribute is set to TRUE, only archived findings are listed. When it's set to FALSE, only unarchived findings are listed. When this attribute is not set, all existing findings are listed.   service.resourceRole   severity   type   updatedAt Type: ISO 8601 string format: YYYY-MM-DDTHH:MM:SS.SSSZ or YYYY-MM-DDTHH:MM:SSZ depending on whether the value contains milliseconds.
        public let findingCriteria: FindingCriteria
        /// The name of the filter. Valid characters include period (.), underscore (_),  dash (-), and alphanumeric characters. A whitespace is considered to be an invalid character.
        public let name: String
        /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
        public let rank: Int?
        /// The tags to be added to a new filter resource.
        public let tags: [String: String]?

        public init(action: FilterAction? = nil, clientToken: String? = CreateFilterRequest.idempotencyToken(), description: String? = nil, detectorId: String, findingCriteria: FindingCriteria, name: String, rank: Int? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.clientToken = clientToken
            self.description = description
            self.detectorId = detectorId
            self.findingCriteria = findingCriteria
            self.name = name
            self.rank = rank
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.rank, name: "rank", parent: name, max: 100)
            try self.validate(self.rank, name: "rank", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case clientToken
            case description
            case findingCriteria
            case name
            case rank
            case tags
        }
    }

    public struct CreateFilterResponse: AWSDecodableShape {
        /// The name of the successfully created filter.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct CreateIPSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// A Boolean value that indicates whether GuardDuty is to start using the uploaded IPSet.
        public let activate: Bool
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// The unique ID of the detector of the GuardDuty account that you want to create an IPSet for.
        public let detectorId: String
        /// The format of the file that contains the IPSet.
        public let format: IpSetFormat
        /// The URI of the file that contains the IPSet.
        public let location: String
        /// The user-friendly name to identify the IPSet. Allowed characters are alphanumerics, spaces, hyphens (-), and underscores (_).
        public let name: String
        /// The tags to be added to a new IP set resource.
        public let tags: [String: String]?

        public init(activate: Bool = false, clientToken: String? = CreateIPSetRequest.idempotencyToken(), detectorId: String, format: IpSetFormat, location: String, name: String, tags: [String: String]? = nil) {
            self.activate = activate
            self.clientToken = clientToken
            self.detectorId = detectorId
            self.format = format
            self.location = location
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.location, name: "location", parent: name, max: 300)
            try self.validate(self.location, name: "location", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activate
            case clientToken
            case format
            case location
            case name
            case tags
        }
    }

    public struct CreateIPSetResponse: AWSDecodableShape {
        /// The ID of the IPSet resource.
        public let ipSetId: String

        public init(ipSetId: String) {
            self.ipSetId = ipSetId
        }

        private enum CodingKeys: String, CodingKey {
            case ipSetId
        }
    }

    public struct CreateMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// A list of account ID and email address pairs of the accounts that you want to associate with the GuardDuty administrator account.
        public let accountDetails: [AccountDetail]
        /// The unique ID of the detector of the GuardDuty account that you want to associate member accounts with.
        public let detectorId: String

        public init(accountDetails: [AccountDetail], detectorId: String) {
            self.accountDetails = accountDetails
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountDetails.forEach {
                try $0.validate(name: "\(name).accountDetails[]")
            }
            try self.validate(self.accountDetails, name: "accountDetails", parent: name, max: 50)
            try self.validate(self.accountDetails, name: "accountDetails", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountDetails
        }
    }

    public struct CreateMembersResponse: AWSDecodableShape {
        /// A list of objects that include the accountIds of the unprocessed accounts and a result string that explains why each was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct CreatePublishingDestinationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The idempotency token for the request.
        public let clientToken: String?
        /// The properties of the publishing destination, including the ARNs for the destination and the KMS key used for encryption.
        public let destinationProperties: DestinationProperties
        /// The type of resource for the publishing destination. Currently only Amazon S3 buckets are supported.
        public let destinationType: DestinationType
        /// The ID of the GuardDuty detector associated with the publishing destination.
        public let detectorId: String

        public init(clientToken: String? = CreatePublishingDestinationRequest.idempotencyToken(), destinationProperties: DestinationProperties, destinationType: DestinationType, detectorId: String) {
            self.clientToken = clientToken
            self.destinationProperties = destinationProperties
            self.destinationType = destinationType
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case destinationProperties
            case destinationType
        }
    }

    public struct CreatePublishingDestinationResponse: AWSDecodableShape {
        /// The ID of the publishing destination that is created.
        public let destinationId: String

        public init(destinationId: String) {
            self.destinationId = destinationId
        }

        private enum CodingKeys: String, CodingKey {
            case destinationId
        }
    }

    public struct CreateSampleFindingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The ID of the detector to create sample findings for.
        public let detectorId: String
        /// The types of sample findings to generate.
        public let findingTypes: [String]?

        public init(detectorId: String, findingTypes: [String]? = nil) {
            self.detectorId = detectorId
            self.findingTypes = findingTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.findingTypes?.forEach {
                try validate($0, name: "findingTypes[]", parent: name, max: 50)
                try validate($0, name: "findingTypes[]", parent: name, min: 1)
            }
            try self.validate(self.findingTypes, name: "findingTypes", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case findingTypes
        }
    }

    public struct CreateSampleFindingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateThreatIntelSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// A Boolean value that indicates whether GuardDuty is to start using the uploaded ThreatIntelSet.
        public let activate: Bool
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// The unique ID of the detector of the GuardDuty account that you want to create a threatIntelSet for.
        public let detectorId: String
        /// The format of the file that contains the ThreatIntelSet.
        public let format: ThreatIntelSetFormat
        /// The URI of the file that contains the ThreatIntelSet.
        public let location: String
        /// A user-friendly ThreatIntelSet name displayed in all findings that are generated by activity that involves IP addresses included in this ThreatIntelSet.
        public let name: String
        /// The tags to be added to a new threat list resource.
        public let tags: [String: String]?

        public init(activate: Bool = false, clientToken: String? = CreateThreatIntelSetRequest.idempotencyToken(), detectorId: String, format: ThreatIntelSetFormat, location: String, name: String, tags: [String: String]? = nil) {
            self.activate = activate
            self.clientToken = clientToken
            self.detectorId = detectorId
            self.format = format
            self.location = location
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.location, name: "location", parent: name, max: 300)
            try self.validate(self.location, name: "location", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activate
            case clientToken
            case format
            case location
            case name
            case tags
        }
    }

    public struct CreateThreatIntelSetResponse: AWSDecodableShape {
        /// The ID of the ThreatIntelSet resource.
        public let threatIntelSetId: String

        public init(threatIntelSetId: String) {
            self.threatIntelSetId = threatIntelSetId
        }

        private enum CodingKeys: String, CodingKey {
            case threatIntelSetId
        }
    }

    public struct DNSLogsConfigurationResult: AWSDecodableShape {
        /// Denotes whether DNS logs is enabled as a data source.
        public let status: DataSourceStatus

        public init(status: DataSourceStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct DataSourceConfigurations: AWSEncodableShape {
        /// Describes whether any Kubernetes logs are enabled as data sources.
        public let kubernetes: KubernetesConfiguration?
        /// Describes whether Malware Protection is enabled as a data source.
        public let malwareProtection: MalwareProtectionConfiguration?
        /// Describes whether S3 data event logs are enabled as a data source.
        public let s3Logs: S3LogsConfiguration?

        public init(kubernetes: KubernetesConfiguration? = nil, malwareProtection: MalwareProtectionConfiguration? = nil, s3Logs: S3LogsConfiguration? = nil) {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }

        private enum CodingKeys: String, CodingKey {
            case kubernetes
            case malwareProtection
            case s3Logs
        }
    }

    public struct DataSourceConfigurationsResult: AWSDecodableShape {
        /// An object that contains information on the status of CloudTrail as a data source.
        public let cloudTrail: CloudTrailConfigurationResult
        /// An object that contains information on the status of DNS logs as a data source.
        public let dnsLogs: DNSLogsConfigurationResult
        /// An object that contains information on the status of VPC flow logs as a data source.
        public let flowLogs: FlowLogsConfigurationResult
        /// An object that contains information on the status of all Kubernetes data sources.
        public let kubernetes: KubernetesConfigurationResult?
        /// Describes the configuration of Malware Protection data sources.
        public let malwareProtection: MalwareProtectionConfigurationResult?
        /// An object that contains information on the status of S3 Data event logs as a data source.
        public let s3Logs: S3LogsConfigurationResult

        public init(cloudTrail: CloudTrailConfigurationResult, dnsLogs: DNSLogsConfigurationResult, flowLogs: FlowLogsConfigurationResult, kubernetes: KubernetesConfigurationResult? = nil, malwareProtection: MalwareProtectionConfigurationResult? = nil, s3Logs: S3LogsConfigurationResult) {
            self.cloudTrail = cloudTrail
            self.dnsLogs = dnsLogs
            self.flowLogs = flowLogs
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }

        private enum CodingKeys: String, CodingKey {
            case cloudTrail
            case dnsLogs
            case flowLogs
            case kubernetes
            case malwareProtection
            case s3Logs
        }
    }

    public struct DataSourceFreeTrial: AWSDecodableShape {
        /// A value that specifies the number of days left to use each enabled data source.
        public let freeTrialDaysRemaining: Int?

        public init(freeTrialDaysRemaining: Int? = nil) {
            self.freeTrialDaysRemaining = freeTrialDaysRemaining
        }

        private enum CodingKeys: String, CodingKey {
            case freeTrialDaysRemaining
        }
    }

    public struct DataSourcesFreeTrial: AWSDecodableShape {
        /// Describes whether any Amazon Web Services CloudTrail management event logs are enabled as data sources.
        public let cloudTrail: DataSourceFreeTrial?
        /// Describes whether any DNS logs are enabled as data sources.
        public let dnsLogs: DataSourceFreeTrial?
        /// Describes whether any VPC Flow logs are enabled as data sources.
        public let flowLogs: DataSourceFreeTrial?
        /// Describes whether any Kubernetes logs are enabled as data sources.
        public let kubernetes: KubernetesDataSourceFreeTrial?
        /// Describes whether Malware Protection is enabled as a data source.
        public let malwareProtection: MalwareProtectionDataSourceFreeTrial?
        /// Describes whether any S3 data event logs are enabled as data sources.
        public let s3Logs: DataSourceFreeTrial?

        public init(cloudTrail: DataSourceFreeTrial? = nil, dnsLogs: DataSourceFreeTrial? = nil, flowLogs: DataSourceFreeTrial? = nil, kubernetes: KubernetesDataSourceFreeTrial? = nil, malwareProtection: MalwareProtectionDataSourceFreeTrial? = nil, s3Logs: DataSourceFreeTrial? = nil) {
            self.cloudTrail = cloudTrail
            self.dnsLogs = dnsLogs
            self.flowLogs = flowLogs
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }

        private enum CodingKeys: String, CodingKey {
            case cloudTrail
            case dnsLogs
            case flowLogs
            case kubernetes
            case malwareProtection
            case s3Logs
        }
    }

    public struct DeclineInvitationsRequest: AWSEncodableShape {
        /// A list of account IDs of the Amazon Web Services accounts that sent invitations to the current member account that you want to decline invitations from.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct DeclineInvitationsResponse: AWSDecodableShape {
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct DefaultServerSideEncryption: AWSDecodableShape {
        /// The type of encryption used for objects within the S3 bucket.
        public let encryptionType: String?
        /// The Amazon Resource Name (ARN) of the KMS encryption key. Only available if the bucket EncryptionType is aws:kms.
        public let kmsMasterKeyArn: String?

        public init(encryptionType: String? = nil, kmsMasterKeyArn: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsMasterKeyArn = kmsMasterKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType
            case kmsMasterKeyArn
        }
    }

    public struct DeleteDetectorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The unique ID of the detector that you want to delete.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDetectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFilterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "filterName", location: .uri("filterName"))
        ]

        /// The unique ID of the detector that the filter is associated with.
        public let detectorId: String
        /// The name of the filter that you want to delete.
        public let filterName: String

        public init(detectorId: String, filterName: String) {
            self.detectorId = detectorId
            self.filterName = filterName
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFilterResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIPSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "ipSetId", location: .uri("ipSetId"))
        ]

        /// The unique ID of the detector associated with the IPSet.
        public let detectorId: String
        /// The unique ID of the IPSet to delete.
        public let ipSetId: String

        public init(detectorId: String, ipSetId: String) {
            self.detectorId = detectorId
            self.ipSetId = ipSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIPSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteInvitationsRequest: AWSEncodableShape {
        /// A list of account IDs of the Amazon Web Services accounts that sent invitations to the current member account that you want to delete invitations from.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct DeleteInvitationsResponse: AWSDecodableShape {
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct DeleteMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// A list of account IDs of the GuardDuty member accounts that you want to delete.
        public let accountIds: [String]
        /// The unique ID of the detector of the GuardDuty account whose members you want to delete.
        public let detectorId: String

        public init(accountIds: [String], detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct DeleteMembersResponse: AWSDecodableShape {
        /// The accounts that could not be processed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct DeletePublishingDestinationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "destinationId", location: .uri("destinationId")),
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The ID of the publishing destination to delete.
        public let destinationId: String
        /// The unique ID of the detector associated with the publishing destination to delete.
        public let detectorId: String

        public init(destinationId: String, detectorId: String) {
            self.destinationId = destinationId
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePublishingDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteThreatIntelSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "threatIntelSetId", location: .uri("threatIntelSetId"))
        ]

        /// The unique ID of the detector that the threatIntelSet is associated with.
        public let detectorId: String
        /// The unique ID of the threatIntelSet that you want to delete.
        public let threatIntelSetId: String

        public init(detectorId: String, threatIntelSetId: String) {
            self.detectorId = detectorId
            self.threatIntelSetId = threatIntelSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteThreatIntelSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeMalwareScansRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The unique ID of the detector that the request is associated with.
        public let detectorId: String
        /// Represents the criteria to be used in the filter for describing scan entries.
        public let filterCriteria: FilterCriteria?
        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// Represents the criteria used for sorting scan entries.
        public let sortCriteria: SortCriteria?

        public init(detectorId: String, filterCriteria: FilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: SortCriteria? = nil) {
            self.detectorId = detectorId
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria
            case maxResults
            case nextToken
            case sortCriteria
        }
    }

    public struct DescribeMalwareScansResponse: AWSDecodableShape {
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?
        /// Contains information about malware scans.
        public let scans: [Scan]

        public init(nextToken: String? = nil, scans: [Scan]) {
            self.nextToken = nextToken
            self.scans = scans
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case scans
        }
    }

    public struct DescribeOrganizationConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The ID of the detector to retrieve information about the delegated administrator from.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeOrganizationConfigurationResponse: AWSDecodableShape {
        /// Indicates whether GuardDuty is automatically enabled for accounts added to the organization.
        public let autoEnable: Bool
        /// Describes which data sources are enabled automatically for member accounts.
        public let dataSources: OrganizationDataSourceConfigurationsResult?
        /// Indicates whether the maximum number of allowed member accounts are already associated with the delegated administrator account for your organization.
        public let memberAccountLimitReached: Bool

        public init(autoEnable: Bool, dataSources: OrganizationDataSourceConfigurationsResult? = nil, memberAccountLimitReached: Bool) {
            self.autoEnable = autoEnable
            self.dataSources = dataSources
            self.memberAccountLimitReached = memberAccountLimitReached
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
            case dataSources
            case memberAccountLimitReached
        }
    }

    public struct DescribePublishingDestinationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "destinationId", location: .uri("destinationId")),
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The ID of the publishing destination to retrieve.
        public let destinationId: String
        /// The unique ID of the detector associated with the publishing destination to retrieve.
        public let detectorId: String

        public init(destinationId: String, detectorId: String) {
            self.destinationId = destinationId
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePublishingDestinationResponse: AWSDecodableShape {
        /// The ID of the publishing destination.
        public let destinationId: String
        /// A DestinationProperties object that includes the DestinationArn and KmsKeyArn of the publishing destination.
        public let destinationProperties: DestinationProperties
        /// The type of publishing destination. Currently, only Amazon S3 buckets are supported.
        public let destinationType: DestinationType
        /// The time, in epoch millisecond format, at which GuardDuty was first unable to publish findings to the destination.
        public let publishingFailureStartTimestamp: Int64
        /// The status of the publishing destination.
        public let status: PublishingStatus

        public init(destinationId: String, destinationProperties: DestinationProperties, destinationType: DestinationType, publishingFailureStartTimestamp: Int64, status: PublishingStatus) {
            self.destinationId = destinationId
            self.destinationProperties = destinationProperties
            self.destinationType = destinationType
            self.publishingFailureStartTimestamp = publishingFailureStartTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case destinationId
            case destinationProperties
            case destinationType
            case publishingFailureStartTimestamp
            case status
        }
    }

    public struct Destination: AWSDecodableShape {
        /// The unique ID of the publishing destination.
        public let destinationId: String
        /// The type of resource used for the publishing destination. Currently, only Amazon S3 buckets are supported.
        public let destinationType: DestinationType
        /// The status of the publishing destination.
        public let status: PublishingStatus

        public init(destinationId: String, destinationType: DestinationType, status: PublishingStatus) {
            self.destinationId = destinationId
            self.destinationType = destinationType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case destinationId
            case destinationType
            case status
        }
    }

    public struct DestinationProperties: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the resource to publish to. To specify an S3 bucket folder use the following format: arn:aws:s3:::DOC-EXAMPLE-BUCKET/myFolder/
        public let destinationArn: String?
        /// The ARN of the KMS key to use for encryption.
        public let kmsKeyArn: String?

        public init(destinationArn: String? = nil, kmsKeyArn: String? = nil) {
            self.destinationArn = destinationArn
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case destinationArn
            case kmsKeyArn
        }
    }

    public struct DisableOrganizationAdminAccountRequest: AWSEncodableShape {
        /// The Amazon Web Services Account ID for the organizations account to be disabled as a GuardDuty delegated administrator.
        public let adminAccountId: String

        public init(adminAccountId: String) {
            self.adminAccountId = adminAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId
        }
    }

    public struct DisableOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateFromAdministratorAccountRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateFromAdministratorAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateFromMasterAccountRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateFromMasterAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// A list of account IDs of the GuardDuty member accounts that you want to disassociate from the administrator account.
        public let accountIds: [String]
        /// The unique ID of the detector of the GuardDuty account whose members you want to disassociate from the administrator account.
        public let detectorId: String

        public init(accountIds: [String], detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct DisassociateMembersResponse: AWSDecodableShape {
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct DnsRequestAction: AWSDecodableShape {
        /// Indicates whether the targeted port is blocked.
        public let blocked: Bool?
        /// The domain information for the API request.
        public let domain: String?
        /// The network connection protocol observed in the activity that prompted GuardDuty to generate the finding.
        public let `protocol`: String?

        public init(blocked: Bool? = nil, domain: String? = nil, protocol: String? = nil) {
            self.blocked = blocked
            self.domain = domain
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case blocked
            case domain
            case `protocol`
        }
    }

    public struct DomainDetails: AWSDecodableShape {
        /// The domain information for the Amazon Web Services API call.
        public let domain: String?

        public init(domain: String? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain
        }
    }

    public struct EbsVolumeDetails: AWSDecodableShape {
        /// List of EBS volumes that were scanned.
        public let scannedVolumeDetails: [VolumeDetail]?
        /// List of EBS volumes that were skipped from the malware scan.
        public let skippedVolumeDetails: [VolumeDetail]?

        public init(scannedVolumeDetails: [VolumeDetail]? = nil, skippedVolumeDetails: [VolumeDetail]? = nil) {
            self.scannedVolumeDetails = scannedVolumeDetails
            self.skippedVolumeDetails = skippedVolumeDetails
        }

        private enum CodingKeys: String, CodingKey {
            case scannedVolumeDetails
            case skippedVolumeDetails
        }
    }

    public struct EbsVolumeScanDetails: AWSDecodableShape {
        /// Returns the completion date and time of the malware scan.
        public let scanCompletedAt: Date?
        /// Contains a complete view providing malware scan result details.
        public let scanDetections: ScanDetections?
        /// Unique Id of the malware scan that generated the finding.
        public let scanId: String?
        /// Returns the start date and time of the malware scan.
        public let scanStartedAt: Date?
        /// Contains list of threat intelligence sources used to detect threats.
        public let sources: [String]?
        /// GuardDuty finding ID that triggered a malware scan.
        public let triggerFindingId: String?

        public init(scanCompletedAt: Date? = nil, scanDetections: ScanDetections? = nil, scanId: String? = nil, scanStartedAt: Date? = nil, sources: [String]? = nil, triggerFindingId: String? = nil) {
            self.scanCompletedAt = scanCompletedAt
            self.scanDetections = scanDetections
            self.scanId = scanId
            self.scanStartedAt = scanStartedAt
            self.sources = sources
            self.triggerFindingId = triggerFindingId
        }

        private enum CodingKeys: String, CodingKey {
            case scanCompletedAt
            case scanDetections
            case scanId
            case scanStartedAt
            case sources
            case triggerFindingId
        }
    }

    public struct EbsVolumesResult: AWSDecodableShape {
        /// Specifies the reason why scanning EBS volumes (Malware Protection) was not enabled as a data source.
        public let reason: String?
        /// Describes whether scanning EBS volumes is enabled as a data source.
        public let status: DataSourceStatus?

        public init(reason: String? = nil, status: DataSourceStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason
            case status
        }
    }

    public struct EcsClusterDetails: AWSDecodableShape {
        /// The number of services that are running on the cluster in an ACTIVE state.
        public let activeServicesCount: Int?
        /// The Amazon Resource Name (ARN) that identifies the cluster.
        public let arn: String?
        /// The name of the ECS Cluster.
        public let name: String?
        /// The number of container instances registered into the cluster.
        public let registeredContainerInstancesCount: Int?
        /// The number of tasks in the cluster that are in the RUNNING state.
        public let runningTasksCount: Int?
        /// The status of the ECS cluster.
        public let status: String?
        /// The tags of the ECS Cluster.
        public let tags: [Tag]?
        /// Contains information about the details of the ECS Task.
        public let taskDetails: EcsTaskDetails?

        public init(activeServicesCount: Int? = nil, arn: String? = nil, name: String? = nil, registeredContainerInstancesCount: Int? = nil, runningTasksCount: Int? = nil, status: String? = nil, tags: [Tag]? = nil, taskDetails: EcsTaskDetails? = nil) {
            self.activeServicesCount = activeServicesCount
            self.arn = arn
            self.name = name
            self.registeredContainerInstancesCount = registeredContainerInstancesCount
            self.runningTasksCount = runningTasksCount
            self.status = status
            self.tags = tags
            self.taskDetails = taskDetails
        }

        private enum CodingKeys: String, CodingKey {
            case activeServicesCount
            case arn
            case name
            case registeredContainerInstancesCount
            case runningTasksCount
            case status
            case tags
            case taskDetails
        }
    }

    public struct EcsTaskDetails: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the task.
        public let arn: String?
        /// The containers that's associated with the task.
        public let containers: [Container]?
        /// The ARN of the task definition that creates the task.
        public let definitionArn: String?
        /// The name of the task group that's associated with the task.
        public let group: String?
        /// The Unix timestamp for the time when the task started.
        public let startedAt: Date?
        /// Contains the tag specified when a task is started.
        public let startedBy: String?
        /// The tags of the ECS Task.
        public let tags: [Tag]?
        /// The Unix timestamp for the time when the task was created.
        public let taskCreatedAt: Date?
        /// The version counter for the task.
        public let version: String?
        /// The list of data volume definitions for the task.
        public let volumes: [Volume]?

        public init(arn: String? = nil, containers: [Container]? = nil, definitionArn: String? = nil, group: String? = nil, startedAt: Date? = nil, startedBy: String? = nil, tags: [Tag]? = nil, taskCreatedAt: Date? = nil, version: String? = nil, volumes: [Volume]? = nil) {
            self.arn = arn
            self.containers = containers
            self.definitionArn = definitionArn
            self.group = group
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.tags = tags
            self.taskCreatedAt = taskCreatedAt
            self.version = version
            self.volumes = volumes
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case containers
            case definitionArn
            case group
            case startedAt
            case startedBy
            case tags
            case taskCreatedAt = "createdAt"
            case version
            case volumes
        }
    }

    public struct EksClusterDetails: AWSDecodableShape {
        /// EKS cluster ARN.
        public let arn: String?
        /// The timestamp when the EKS cluster was created.
        public let createdAt: Date?
        /// EKS cluster name.
        public let name: String?
        /// The EKS cluster status.
        public let status: String?
        /// The EKS cluster tags.
        public let tags: [Tag]?
        /// The VPC ID to which the EKS cluster is attached.
        public let vpcId: String?

        public init(arn: String? = nil, createdAt: Date? = nil, name: String? = nil, status: String? = nil, tags: [Tag]? = nil, vpcId: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.status = status
            self.tags = tags
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case name
            case status
            case tags
            case vpcId
        }
    }

    public struct EnableOrganizationAdminAccountRequest: AWSEncodableShape {
        /// The Amazon Web Services Account ID for the organization account to be enabled as a GuardDuty delegated administrator.
        public let adminAccountId: String

        public init(adminAccountId: String) {
            self.adminAccountId = adminAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId
        }
    }

    public struct EnableOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Evidence: AWSDecodableShape {
        /// A list of threat intelligence details related to the evidence.
        public let threatIntelligenceDetails: [ThreatIntelligenceDetail]?

        public init(threatIntelligenceDetails: [ThreatIntelligenceDetail]? = nil) {
            self.threatIntelligenceDetails = threatIntelligenceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case threatIntelligenceDetails
        }
    }

    public struct FilterCondition: AWSEncodableShape {
        /// Represents an equal condition to be applied to a single field when querying for scan entries.
        public let equalsValue: String?
        /// Represents a greater than condition to be applied to a single field when querying for scan entries.
        public let greaterThan: Int64?
        /// Represents a less than condition to be applied to a single field when querying for scan entries.
        public let lessThan: Int64?

        public init(equalsValue: String? = nil, greaterThan: Int64? = nil, lessThan: Int64? = nil) {
            self.equalsValue = equalsValue
            self.greaterThan = greaterThan
            self.lessThan = lessThan
        }

        public func validate(name: String) throws {
            try self.validate(self.equalsValue, name: "equalsValue", parent: name, max: 200)
            try self.validate(self.equalsValue, name: "equalsValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case equalsValue
            case greaterThan
            case lessThan
        }
    }

    public struct FilterCriteria: AWSEncodableShape {
        /// Represents a condition that when matched will be added to the response of the operation.
        public let filterCriterion: [FilterCriterion]?

        public init(filterCriterion: [FilterCriterion]? = nil) {
            self.filterCriterion = filterCriterion
        }

        public func validate(name: String) throws {
            try self.filterCriterion?.forEach {
                try $0.validate(name: "\(name).filterCriterion[]")
            }
            try self.validate(self.filterCriterion, name: "filterCriterion", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriterion
        }
    }

    public struct FilterCriterion: AWSEncodableShape {
        /// An enum value representing possible scan properties to match with given scan entries.
        public let criterionKey: CriterionKey?
        /// Contains information about the condition.
        public let filterCondition: FilterCondition?

        public init(criterionKey: CriterionKey? = nil, filterCondition: FilterCondition? = nil) {
            self.criterionKey = criterionKey
            self.filterCondition = filterCondition
        }

        public func validate(name: String) throws {
            try self.filterCondition?.validate(name: "\(name).filterCondition")
        }

        private enum CodingKeys: String, CodingKey {
            case criterionKey
            case filterCondition
        }
    }

    public struct Finding: AWSDecodableShape {
        /// The ID of the account in which the finding was generated.
        public let accountId: String
        /// The ARN of the finding.
        public let arn: String
        /// The confidence score for the finding.
        public let confidence: Double?
        /// The time and date when the finding was created.
        public let createdAt: String
        /// The description of the finding.
        public let description: String?
        /// The ID of the finding.
        public let id: String
        /// The partition associated with the finding.
        public let partition: String?
        /// The Region where the finding was generated.
        public let region: String
        public let resource: Resource
        /// The version of the schema used for the finding.
        public let schemaVersion: String
        public let service: Service?
        /// The severity of the finding.
        public let severity: Double
        /// The title of the finding.
        public let title: String?
        /// The type of finding.
        public let type: String
        /// The time and date when the finding was last updated.
        public let updatedAt: String

        public init(accountId: String, arn: String, confidence: Double? = nil, createdAt: String, description: String? = nil, id: String, partition: String? = nil, region: String, resource: Resource, schemaVersion: String, service: Service? = nil, severity: Double, title: String? = nil, type: String, updatedAt: String) {
            self.accountId = accountId
            self.arn = arn
            self.confidence = confidence
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.partition = partition
            self.region = region
            self.resource = resource
            self.schemaVersion = schemaVersion
            self.service = service
            self.severity = severity
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case arn
            case confidence
            case createdAt
            case description
            case id
            case partition
            case region
            case resource
            case schemaVersion
            case service
            case severity
            case title
            case type
            case updatedAt
        }
    }

    public struct FindingCriteria: AWSEncodableShape & AWSDecodableShape {
        /// Represents a map of finding properties that match specified conditions and values when querying findings.
        public let criterion: [String: Condition]?

        public init(criterion: [String: Condition]? = nil) {
            self.criterion = criterion
        }

        private enum CodingKeys: String, CodingKey {
            case criterion
        }
    }

    public struct FindingStatistics: AWSDecodableShape {
        /// Represents a map of severity to count statistics for a set of findings.
        public let countBySeverity: [String: Int]?

        public init(countBySeverity: [String: Int]? = nil) {
            self.countBySeverity = countBySeverity
        }

        private enum CodingKeys: String, CodingKey {
            case countBySeverity
        }
    }

    public struct FlowLogsConfigurationResult: AWSDecodableShape {
        /// Denotes whether VPC flow logs is enabled as a data source.
        public let status: DataSourceStatus

        public init(status: DataSourceStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct GeoLocation: AWSDecodableShape {
        /// The latitude information of the remote IP address.
        public let lat: Double?
        /// The longitude information of the remote IP address.
        public let lon: Double?

        public init(lat: Double? = nil, lon: Double? = nil) {
            self.lat = lat
            self.lon = lon
        }

        private enum CodingKeys: String, CodingKey {
            case lat
            case lon
        }
    }

    public struct GetAdministratorAccountRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAdministratorAccountResponse: AWSDecodableShape {
        /// The administrator account details.
        public let administrator: Administrator

        public init(administrator: Administrator) {
            self.administrator = administrator
        }

        private enum CodingKeys: String, CodingKey {
            case administrator
        }
    }

    public struct GetDetectorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The unique ID of the detector that you want to get.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDetectorResponse: AWSDecodableShape {
        /// The timestamp of when the detector was created.
        public let createdAt: String?
        /// Describes which data sources are enabled for the detector.
        public let dataSources: DataSourceConfigurationsResult?
        /// The publishing frequency of the finding.
        public let findingPublishingFrequency: FindingPublishingFrequency?
        /// The GuardDuty service role.
        public let serviceRole: String
        /// The detector status.
        public let status: DetectorStatus
        /// The tags of the detector resource.
        public let tags: [String: String]?
        /// The last-updated timestamp for the detector.
        public let updatedAt: String?

        public init(createdAt: String? = nil, dataSources: DataSourceConfigurationsResult? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil, serviceRole: String, status: DetectorStatus, tags: [String: String]? = nil, updatedAt: String? = nil) {
            self.createdAt = createdAt
            self.dataSources = dataSources
            self.findingPublishingFrequency = findingPublishingFrequency
            self.serviceRole = serviceRole
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case dataSources
            case findingPublishingFrequency
            case serviceRole
            case status
            case tags
            case updatedAt
        }
    }

    public struct GetFilterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "filterName", location: .uri("filterName"))
        ]

        /// The unique ID of the detector that the filter is associated with.
        public let detectorId: String
        /// The name of the filter you want to get.
        public let filterName: String

        public init(detectorId: String, filterName: String) {
            self.detectorId = detectorId
            self.filterName = filterName
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFilterResponse: AWSDecodableShape {
        /// Specifies the action that is to be applied to the findings that match the filter.
        public let action: FilterAction
        /// The description of the filter.
        public let description: String?
        /// Represents the criteria to be used in the filter for querying findings.
        public let findingCriteria: FindingCriteria
        /// The name of the filter.
        public let name: String
        /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
        public let rank: Int?
        /// The tags of the filter resource.
        public let tags: [String: String]?

        public init(action: FilterAction, description: String? = nil, findingCriteria: FindingCriteria, name: String, rank: Int? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.description = description
            self.findingCriteria = findingCriteria
            self.name = name
            self.rank = rank
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case description
            case findingCriteria
            case name
            case rank
            case tags
        }
    }

    public struct GetFindingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The ID of the detector that specifies the GuardDuty service whose findings you want to retrieve.
        public let detectorId: String
        /// The IDs of the findings that you want to retrieve.
        public let findingIds: [String]
        /// Represents the criteria used for sorting findings.
        public let sortCriteria: SortCriteria?

        public init(detectorId: String, findingIds: [String], sortCriteria: SortCriteria? = nil) {
            self.detectorId = detectorId
            self.findingIds = findingIds
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.findingIds.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try self.validate(self.findingIds, name: "findingIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds
            case sortCriteria
        }
    }

    public struct GetFindingsResponse: AWSDecodableShape {
        /// A list of findings.
        public let findings: [Finding]

        public init(findings: [Finding]) {
            self.findings = findings
        }

        private enum CodingKeys: String, CodingKey {
            case findings
        }
    }

    public struct GetFindingsStatisticsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The ID of the detector that specifies the GuardDuty service whose findings' statistics you want to retrieve.
        public let detectorId: String
        /// Represents the criteria that is used for querying findings.
        public let findingCriteria: FindingCriteria?
        /// The types of finding statistics to retrieve.
        public let findingStatisticTypes: [FindingStatisticType]

        public init(detectorId: String, findingCriteria: FindingCriteria? = nil, findingStatisticTypes: [FindingStatisticType]) {
            self.detectorId = detectorId
            self.findingCriteria = findingCriteria
            self.findingStatisticTypes = findingStatisticTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.findingStatisticTypes, name: "findingStatisticTypes", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case findingCriteria
            case findingStatisticTypes
        }
    }

    public struct GetFindingsStatisticsResponse: AWSDecodableShape {
        /// The finding statistics object.
        public let findingStatistics: FindingStatistics

        public init(findingStatistics: FindingStatistics) {
            self.findingStatistics = findingStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case findingStatistics
        }
    }

    public struct GetIPSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "ipSetId", location: .uri("ipSetId"))
        ]

        /// The unique ID of the detector that the IPSet is associated with.
        public let detectorId: String
        /// The unique ID of the IPSet to retrieve.
        public let ipSetId: String

        public init(detectorId: String, ipSetId: String) {
            self.detectorId = detectorId
            self.ipSetId = ipSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIPSetResponse: AWSDecodableShape {
        /// The format of the file that contains the IPSet.
        public let format: IpSetFormat
        /// The URI of the file that contains the IPSet.
        public let location: String
        /// The user-friendly name for the IPSet.
        public let name: String
        /// The status of IPSet file that was uploaded.
        public let status: IpSetStatus
        /// The tags of the IPSet resource.
        public let tags: [String: String]?

        public init(format: IpSetFormat, location: String, name: String, status: IpSetStatus, tags: [String: String]? = nil) {
            self.format = format
            self.location = location
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case format
            case location
            case name
            case status
            case tags
        }
    }

    public struct GetInvitationsCountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetInvitationsCountResponse: AWSDecodableShape {
        /// The number of received invitations.
        public let invitationsCount: Int?

        public init(invitationsCount: Int? = nil) {
            self.invitationsCount = invitationsCount
        }

        private enum CodingKeys: String, CodingKey {
            case invitationsCount
        }
    }

    public struct GetMalwareScanSettingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The unique ID of the detector that the scan setting is associated with.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMalwareScanSettingsResponse: AWSDecodableShape {
        /// An enum value representing possible snapshot preservation settings.
        public let ebsSnapshotPreservation: EbsSnapshotPreservation?
        /// Represents the criteria to be used in the filter for scanning resources.
        public let scanResourceCriteria: ScanResourceCriteria?

        public init(ebsSnapshotPreservation: EbsSnapshotPreservation? = nil, scanResourceCriteria: ScanResourceCriteria? = nil) {
            self.ebsSnapshotPreservation = ebsSnapshotPreservation
            self.scanResourceCriteria = scanResourceCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case ebsSnapshotPreservation
            case scanResourceCriteria
        }
    }

    public struct GetMasterAccountRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMasterAccountResponse: AWSDecodableShape {
        /// The administrator account details.
        public let master: Master

        public init(master: Master) {
            self.master = master
        }

        private enum CodingKeys: String, CodingKey {
            case master
        }
    }

    public struct GetMemberDetectorsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The account ID of the member account.
        public let accountIds: [String]
        /// The detector ID for the administrator account.
        public let detectorId: String

        public init(accountIds: [String], detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct GetMemberDetectorsResponse: AWSDecodableShape {
        /// An object that describes which data sources are enabled for a member account.
        public let memberDataSourceConfigurations: [MemberDataSourceConfiguration]
        /// A list of member account IDs that were unable to be processed along with an explanation for why they were not processed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(memberDataSourceConfigurations: [MemberDataSourceConfiguration], unprocessedAccounts: [UnprocessedAccount]) {
            self.memberDataSourceConfigurations = memberDataSourceConfigurations
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case memberDataSourceConfigurations = "members"
            case unprocessedAccounts
        }
    }

    public struct GetMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// A list of account IDs of the GuardDuty member accounts that you want to describe.
        public let accountIds: [String]
        /// The unique ID of the detector of the GuardDuty account whose members you want to retrieve.
        public let detectorId: String

        public init(accountIds: [String], detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct GetMembersResponse: AWSDecodableShape {
        /// A list of members.
        public let members: [Member]
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(members: [Member], unprocessedAccounts: [UnprocessedAccount]) {
            self.members = members
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case members
            case unprocessedAccounts
        }
    }

    public struct GetRemainingFreeTrialDaysRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// A list of account identifiers of the GuardDuty member account.
        public let accountIds: [String]?
        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String

        public init(accountIds: [String]? = nil, detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct GetRemainingFreeTrialDaysResponse: AWSDecodableShape {
        /// The member accounts which were included in a request and were processed successfully.
        public let accounts: [AccountFreeTrialInfo]?
        /// The member account that was included in a request but for which the request could not be processed.
        public let unprocessedAccounts: [UnprocessedAccount]?

        public init(accounts: [AccountFreeTrialInfo]? = nil, unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.accounts = accounts
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case accounts
            case unprocessedAccounts
        }
    }

    public struct GetThreatIntelSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "threatIntelSetId", location: .uri("threatIntelSetId"))
        ]

        /// The unique ID of the detector that the threatIntelSet is associated with.
        public let detectorId: String
        /// The unique ID of the threatIntelSet that you want to get.
        public let threatIntelSetId: String

        public init(detectorId: String, threatIntelSetId: String) {
            self.detectorId = detectorId
            self.threatIntelSetId = threatIntelSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetThreatIntelSetResponse: AWSDecodableShape {
        /// The format of the threatIntelSet.
        public let format: ThreatIntelSetFormat
        /// The URI of the file that contains the ThreatIntelSet.
        public let location: String
        /// A user-friendly ThreatIntelSet name displayed in all findings that are generated by activity that involves IP addresses included in this ThreatIntelSet.
        public let name: String
        /// The status of threatIntelSet file uploaded.
        public let status: ThreatIntelSetStatus
        /// The tags of the threat list resource.
        public let tags: [String: String]?

        public init(format: ThreatIntelSetFormat, location: String, name: String, status: ThreatIntelSetStatus, tags: [String: String]? = nil) {
            self.format = format
            self.location = location
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case format
            case location
            case name
            case status
            case tags
        }
    }

    public struct GetUsageStatisticsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The ID of the detector that specifies the GuardDuty service whose usage statistics you want to retrieve.
        public let detectorId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// The currency unit you would like to view your usage statistics in. Current valid values are USD.
        public let unit: String?
        /// Represents the criteria used for querying usage.
        public let usageCriteria: UsageCriteria
        /// The type of usage statistics to retrieve.
        public let usageStatisticType: UsageStatisticType

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil, unit: String? = nil, usageCriteria: UsageCriteria, usageStatisticType: UsageStatisticType) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.unit = unit
            self.usageCriteria = usageCriteria
            self.usageStatisticType = usageStatisticType
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.usageCriteria.validate(name: "\(name).usageCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case unit
            case usageCriteria
            case usageStatisticType = "usageStatisticsType"
        }
    }

    public struct GetUsageStatisticsResponse: AWSDecodableShape {
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?
        /// The usage statistics object. If a UsageStatisticType was provided, the objects representing other types will be null.
        public let usageStatistics: UsageStatistics?

        public init(nextToken: String? = nil, usageStatistics: UsageStatistics? = nil) {
            self.nextToken = nextToken
            self.usageStatistics = usageStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case usageStatistics
        }
    }

    public struct HighestSeverityThreatDetails: AWSDecodableShape {
        /// Total number of infected files with the highest severity threat detected.
        public let count: Int?
        /// Severity level of the highest severity threat detected.
        public let severity: String?
        /// Threat name of the highest severity threat detected as part of the malware scan.
        public let threatName: String?

        public init(count: Int? = nil, severity: String? = nil, threatName: String? = nil) {
            self.count = count
            self.severity = severity
            self.threatName = threatName
        }

        private enum CodingKeys: String, CodingKey {
            case count
            case severity
            case threatName
        }
    }

    public struct HostPath: AWSDecodableShape {
        /// Path of the file or directory on the host that the volume maps to.
        public let path: String?

        public init(path: String? = nil) {
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case path
        }
    }

    public struct IamInstanceProfile: AWSDecodableShape {
        /// The profile ARN of the EC2 instance.
        public let arn: String?
        /// The profile ID of the EC2 instance.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case id
        }
    }

    public struct InstanceDetails: AWSDecodableShape {
        /// The Availability Zone of the EC2 instance.
        public let availabilityZone: String?
        /// The profile information of the EC2 instance.
        public let iamInstanceProfile: IamInstanceProfile?
        /// The image description of the EC2 instance.
        public let imageDescription: String?
        /// The image ID of the EC2 instance.
        public let imageId: String?
        /// The ID of the EC2 instance.
        public let instanceId: String?
        /// The state of the EC2 instance.
        public let instanceState: String?
        /// The type of the EC2 instance.
        public let instanceType: String?
        /// The launch time of the EC2 instance.
        public let launchTime: String?
        /// The elastic network interface information of the EC2 instance.
        public let networkInterfaces: [NetworkInterface]?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Outpost. Only applicable to Amazon Web Services Outposts instances.
        public let outpostArn: String?
        /// The platform of the EC2 instance.
        public let platform: String?
        /// The product code of the EC2 instance.
        public let productCodes: [ProductCode]?
        /// The tags of the EC2 instance.
        public let tags: [Tag]?

        public init(availabilityZone: String? = nil, iamInstanceProfile: IamInstanceProfile? = nil, imageDescription: String? = nil, imageId: String? = nil, instanceId: String? = nil, instanceState: String? = nil, instanceType: String? = nil, launchTime: String? = nil, networkInterfaces: [NetworkInterface]? = nil, outpostArn: String? = nil, platform: String? = nil, productCodes: [ProductCode]? = nil, tags: [Tag]? = nil) {
            self.availabilityZone = availabilityZone
            self.iamInstanceProfile = iamInstanceProfile
            self.imageDescription = imageDescription
            self.imageId = imageId
            self.instanceId = instanceId
            self.instanceState = instanceState
            self.instanceType = instanceType
            self.launchTime = launchTime
            self.networkInterfaces = networkInterfaces
            self.outpostArn = outpostArn
            self.platform = platform
            self.productCodes = productCodes
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone
            case iamInstanceProfile
            case imageDescription
            case imageId
            case instanceId
            case instanceState
            case instanceType
            case launchTime
            case networkInterfaces
            case outpostArn
            case platform
            case productCodes
            case tags
        }
    }

    public struct Invitation: AWSDecodableShape {
        /// The ID of the account that the invitation was sent from.
        public let accountId: String?
        /// The ID of the invitation. This value is used to validate the inviter account to the member account.
        public let invitationId: String?
        /// The timestamp when the invitation was sent.
        public let invitedAt: String?
        /// The status of the relationship between the inviter and invitee accounts.
        public let relationshipStatus: String?

        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: String? = nil, relationshipStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case invitationId
            case invitedAt
            case relationshipStatus
        }
    }

    public struct InviteMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// A list of account IDs of the accounts that you want to invite to GuardDuty as members.
        public let accountIds: [String]
        /// The unique ID of the detector of the GuardDuty account that you want to invite members with.
        public let detectorId: String
        /// A Boolean value that specifies whether you want to disable email notification to the accounts that you are inviting to GuardDuty as members.
        public let disableEmailNotification: Bool?
        /// The invitation message that you want to send to the accounts that you're inviting to GuardDuty as members.
        public let message: String?

        public init(accountIds: [String], detectorId: String, disableEmailNotification: Bool? = nil, message: String? = nil) {
            self.accountIds = accountIds
            self.detectorId = detectorId
            self.disableEmailNotification = disableEmailNotification
            self.message = message
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
            case disableEmailNotification
            case message
        }
    }

    public struct InviteMembersResponse: AWSDecodableShape {
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct KubernetesApiCallAction: AWSDecodableShape {
        /// Parameters related to the Kubernetes API call action.
        public let parameters: String?
        public let remoteIpDetails: RemoteIpDetails?
        /// The Kubernetes API request URI.
        public let requestUri: String?
        /// The IP of the  Kubernetes API caller and the IPs of any proxies or load balancers between the caller and the API endpoint.
        public let sourceIps: [String]?
        /// The resulting HTTP response code of the Kubernetes API call action.
        public let statusCode: Int?
        /// The user agent of the caller of the Kubernetes API.
        public let userAgent: String?
        /// The Kubernetes API request HTTP verb.
        public let verb: String?

        public init(parameters: String? = nil, remoteIpDetails: RemoteIpDetails? = nil, requestUri: String? = nil, sourceIps: [String]? = nil, statusCode: Int? = nil, userAgent: String? = nil, verb: String? = nil) {
            self.parameters = parameters
            self.remoteIpDetails = remoteIpDetails
            self.requestUri = requestUri
            self.sourceIps = sourceIps
            self.statusCode = statusCode
            self.userAgent = userAgent
            self.verb = verb
        }

        private enum CodingKeys: String, CodingKey {
            case parameters
            case remoteIpDetails
            case requestUri
            case sourceIps
            case statusCode
            case userAgent
            case verb
        }
    }

    public struct KubernetesAuditLogsConfiguration: AWSEncodableShape {
        /// The status of Kubernetes audit logs as a data source.
        public let enable: Bool

        public init(enable: Bool = false) {
            self.enable = enable
        }

        private enum CodingKeys: String, CodingKey {
            case enable
        }
    }

    public struct KubernetesAuditLogsConfigurationResult: AWSDecodableShape {
        /// A value that describes whether Kubernetes audit logs are enabled as a data source.
        public let status: DataSourceStatus

        public init(status: DataSourceStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct KubernetesConfiguration: AWSEncodableShape {
        /// The status of Kubernetes audit logs as a data source.
        public let auditLogs: KubernetesAuditLogsConfiguration

        public init(auditLogs: KubernetesAuditLogsConfiguration) {
            self.auditLogs = auditLogs
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs
        }
    }

    public struct KubernetesConfigurationResult: AWSDecodableShape {
        /// Describes whether Kubernetes audit logs are enabled as a data source.
        public let auditLogs: KubernetesAuditLogsConfigurationResult

        public init(auditLogs: KubernetesAuditLogsConfigurationResult) {
            self.auditLogs = auditLogs
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs
        }
    }

    public struct KubernetesDataSourceFreeTrial: AWSDecodableShape {
        /// Describes whether Kubernetes audit logs are enabled as a data source.
        public let auditLogs: DataSourceFreeTrial?

        public init(auditLogs: DataSourceFreeTrial? = nil) {
            self.auditLogs = auditLogs
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs
        }
    }

    public struct KubernetesDetails: AWSDecodableShape {
        /// Details about the Kubernetes user involved in a Kubernetes finding.
        public let kubernetesUserDetails: KubernetesUserDetails?
        /// Details about the Kubernetes workload involved in a Kubernetes finding.
        public let kubernetesWorkloadDetails: KubernetesWorkloadDetails?

        public init(kubernetesUserDetails: KubernetesUserDetails? = nil, kubernetesWorkloadDetails: KubernetesWorkloadDetails? = nil) {
            self.kubernetesUserDetails = kubernetesUserDetails
            self.kubernetesWorkloadDetails = kubernetesWorkloadDetails
        }

        private enum CodingKeys: String, CodingKey {
            case kubernetesUserDetails
            case kubernetesWorkloadDetails
        }
    }

    public struct KubernetesUserDetails: AWSDecodableShape {
        /// The groups that include the user who called the Kubernetes API.
        public let groups: [String]?
        /// The user ID of the user who called the Kubernetes API.
        public let uid: String?
        /// The username of the user who called the Kubernetes API.
        public let username: String?

        public init(groups: [String]? = nil, uid: String? = nil, username: String? = nil) {
            self.groups = groups
            self.uid = uid
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case groups
            case uid
            case username
        }
    }

    public struct KubernetesWorkloadDetails: AWSDecodableShape {
        /// Containers running as part of the Kubernetes workload.
        public let containers: [Container]?
        /// Whether the hostNetwork flag is enabled for the pods included in the workload.
        public let hostNetwork: Bool?
        /// Kubernetes workload name.
        public let name: String?
        /// Kubernetes namespace that the workload is part of.
        public let namespace: String?
        /// Kubernetes workload type (e.g. Pod, Deployment, etc.).
        public let type: String?
        /// Kubernetes workload ID.
        public let uid: String?
        /// Volumes used by the Kubernetes workload.
        public let volumes: [Volume]?

        public init(containers: [Container]? = nil, hostNetwork: Bool? = nil, name: String? = nil, namespace: String? = nil, type: String? = nil, uid: String? = nil, volumes: [Volume]? = nil) {
            self.containers = containers
            self.hostNetwork = hostNetwork
            self.name = name
            self.namespace = namespace
            self.type = type
            self.uid = uid
            self.volumes = volumes
        }

        private enum CodingKeys: String, CodingKey {
            case containers
            case hostNetwork
            case name
            case namespace
            case type
            case uid
            case volumes
        }
    }

    public struct ListDetectorsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDetectorsResponse: AWSDecodableShape {
        /// A list of detector IDs.
        public let detectorIds: [String]
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(detectorIds: [String], nextToken: String? = nil) {
            self.detectorIds = detectorIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case detectorIds
            case nextToken
        }
    }

    public struct ListFiltersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique ID of the detector that the filter is associated with.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFiltersResponse: AWSDecodableShape {
        /// A list of filter names.
        public let filterNames: [String]
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(filterNames: [String], nextToken: String? = nil) {
            self.filterNames = filterNames
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filterNames
            case nextToken
        }
    }

    public struct ListFindingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The ID of the detector that specifies the GuardDuty service whose findings you want to list.
        public let detectorId: String
        /// Represents the criteria used for querying findings. Valid values include:   JSON field name   accountId   region   confidence   id   resource.accessKeyDetails.accessKeyId   resource.accessKeyDetails.principalId   resource.accessKeyDetails.userName   resource.accessKeyDetails.userType   resource.instanceDetails.iamInstanceProfile.id   resource.instanceDetails.imageId   resource.instanceDetails.instanceId   resource.instanceDetails.networkInterfaces.ipv6Addresses   resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress   resource.instanceDetails.networkInterfaces.publicDnsName   resource.instanceDetails.networkInterfaces.publicIp   resource.instanceDetails.networkInterfaces.securityGroups.groupId   resource.instanceDetails.networkInterfaces.securityGroups.groupName   resource.instanceDetails.networkInterfaces.subnetId   resource.instanceDetails.networkInterfaces.vpcId   resource.instanceDetails.tags.key   resource.instanceDetails.tags.value   resource.resourceType   service.action.actionType   service.action.awsApiCallAction.api   service.action.awsApiCallAction.callerType   service.action.awsApiCallAction.remoteIpDetails.city.cityName   service.action.awsApiCallAction.remoteIpDetails.country.countryName   service.action.awsApiCallAction.remoteIpDetails.ipAddressV4   service.action.awsApiCallAction.remoteIpDetails.organization.asn   service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg   service.action.awsApiCallAction.serviceName   service.action.dnsRequestAction.domain   service.action.networkConnectionAction.blocked   service.action.networkConnectionAction.connectionDirection   service.action.networkConnectionAction.localPortDetails.port   service.action.networkConnectionAction.protocol   service.action.networkConnectionAction.remoteIpDetails.country.countryName   service.action.networkConnectionAction.remoteIpDetails.ipAddressV4   service.action.networkConnectionAction.remoteIpDetails.organization.asn   service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg   service.action.networkConnectionAction.remotePortDetails.port   service.additionalInfo.threatListName   service.archived When this attribute is set to 'true', only archived findings are listed. When it's set to 'false', only unarchived findings are listed. When this attribute is not set, all existing findings are listed.   service.resourceRole   severity   type   updatedAt Type: Timestamp in Unix Epoch millisecond format: 1486685375000
        public let findingCriteria: FindingCriteria?
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// Represents the criteria used for sorting findings.
        public let sortCriteria: SortCriteria?

        public init(detectorId: String, findingCriteria: FindingCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: SortCriteria? = nil) {
            self.detectorId = detectorId
            self.findingCriteria = findingCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case findingCriteria
            case maxResults
            case nextToken
            case sortCriteria
        }
    }

    public struct ListFindingsResponse: AWSDecodableShape {
        /// The IDs of the findings that you're listing.
        public let findingIds: [String]
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(findingIds: [String], nextToken: String? = nil) {
            self.findingIds = findingIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds
            case nextToken
        }
    }

    public struct ListIPSetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique ID of the detector that the IPSet is associated with.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIPSetsResponse: AWSDecodableShape {
        /// The IDs of the IPSet resources.
        public let ipSetIds: [String]
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(ipSetIds: [String], nextToken: String? = nil) {
            self.ipSetIds = ipSetIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ipSetIds
            case nextToken
        }
    }

    public struct ListInvitationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInvitationsResponse: AWSDecodableShape {
        /// A list of invitation descriptions.
        public let invitations: [Invitation]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations
            case nextToken
        }
    }

    public struct ListMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "onlyAssociated", location: .querystring("onlyAssociated"))
        ]

        /// The unique ID of the detector the member is associated with.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// Specifies whether to only return associated members or to return all members (including members who haven't been invited yet or have been disassociated). Member accounts must have been previously associated with the GuardDuty administrator account using  Create Members .
        public let onlyAssociated: String?

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil, onlyAssociated: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.onlyAssociated = onlyAssociated
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersResponse: AWSDecodableShape {
        /// A list of members.
        public let members: [Member]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members
            case nextToken
        }
    }

    public struct ListOrganizationAdminAccountsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOrganizationAdminAccountsResponse: AWSDecodableShape {
        /// A list of accounts configured as GuardDuty delegated administrators.
        public let adminAccounts: [AdminAccount]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(adminAccounts: [AdminAccount]? = nil, nextToken: String? = nil) {
            self.adminAccounts = adminAccounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccounts
            case nextToken
        }
    }

    public struct ListPublishingDestinationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The ID of the detector to retrieve publishing destinations for.
        public let detectorId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPublishingDestinationsResponse: AWSDecodableShape {
        /// A Destinations object that includes information about each publishing destination returned.
        public let destinations: [Destination]
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(destinations: [Destination], nextToken: String? = nil) {
            self.destinations = destinations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case destinations
            case nextToken
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) for the given GuardDuty resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\\d+:detector/[A-Za-z0-9_/.-]{32,264}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ListThreatIntelSetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique ID of the detector that the threatIntelSet is associated with.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter to paginate results in the response. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThreatIntelSetsResponse: AWSDecodableShape {
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?
        /// The IDs of the ThreatIntelSet resources.
        public let threatIntelSetIds: [String]

        public init(nextToken: String? = nil, threatIntelSetIds: [String]) {
            self.nextToken = nextToken
            self.threatIntelSetIds = threatIntelSetIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case threatIntelSetIds
        }
    }

    public struct LocalIpDetails: AWSDecodableShape {
        /// The IPv4 local address of the connection.
        public let ipAddressV4: String?

        public init(ipAddressV4: String? = nil) {
            self.ipAddressV4 = ipAddressV4
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddressV4
        }
    }

    public struct LocalPortDetails: AWSDecodableShape {
        /// The port number of the local connection.
        public let port: Int?
        /// The port name of the local connection.
        public let portName: String?

        public init(port: Int? = nil, portName: String? = nil) {
            self.port = port
            self.portName = portName
        }

        private enum CodingKeys: String, CodingKey {
            case port
            case portName
        }
    }

    public struct MalwareProtectionConfiguration: AWSEncodableShape {
        /// Describes the configuration of Malware Protection for EC2 instances with findings.
        public let scanEc2InstanceWithFindings: ScanEc2InstanceWithFindings?

        public init(scanEc2InstanceWithFindings: ScanEc2InstanceWithFindings? = nil) {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }

        private enum CodingKeys: String, CodingKey {
            case scanEc2InstanceWithFindings
        }
    }

    public struct MalwareProtectionConfigurationResult: AWSDecodableShape {
        /// Describes the configuration of Malware Protection for EC2 instances with findings.
        public let scanEc2InstanceWithFindings: ScanEc2InstanceWithFindingsResult?
        /// The GuardDuty Malware Protection service role.
        public let serviceRole: String?

        public init(scanEc2InstanceWithFindings: ScanEc2InstanceWithFindingsResult? = nil, serviceRole: String? = nil) {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
            self.serviceRole = serviceRole
        }

        private enum CodingKeys: String, CodingKey {
            case scanEc2InstanceWithFindings
            case serviceRole
        }
    }

    public struct MalwareProtectionDataSourceFreeTrial: AWSDecodableShape {
        /// Describes whether Malware Protection for EC2 instances with findings is enabled as a data source.
        public let scanEc2InstanceWithFindings: DataSourceFreeTrial?

        public init(scanEc2InstanceWithFindings: DataSourceFreeTrial? = nil) {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }

        private enum CodingKeys: String, CodingKey {
            case scanEc2InstanceWithFindings
        }
    }

    public struct Master: AWSDecodableShape {
        /// The ID of the account used as the administrator account.
        public let accountId: String?
        /// The value used to validate the administrator account to the member account.
        public let invitationId: String?
        /// The timestamp when the invitation was sent.
        public let invitedAt: String?
        /// The status of the relationship between the administrator and member accounts.
        public let relationshipStatus: String?

        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: String? = nil, relationshipStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case invitationId
            case invitedAt
            case relationshipStatus
        }
    }

    public struct Member: AWSDecodableShape {
        /// The ID of the member account.
        public let accountId: String
        /// The administrator account ID.
        public let administratorId: String?
        /// The detector ID of the member account.
        public let detectorId: String?
        /// The email address of the member account.
        public let email: String
        /// The timestamp when the invitation was sent.
        public let invitedAt: String?
        /// The administrator account ID.
        public let masterId: String
        /// The status of the relationship between the member and the administrator.
        public let relationshipStatus: String
        /// The last-updated timestamp of the member.
        public let updatedAt: String

        public init(accountId: String, administratorId: String? = nil, detectorId: String? = nil, email: String, invitedAt: String? = nil, masterId: String, relationshipStatus: String, updatedAt: String) {
            self.accountId = accountId
            self.administratorId = administratorId
            self.detectorId = detectorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.relationshipStatus = relationshipStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case administratorId
            case detectorId
            case email
            case invitedAt
            case masterId
            case relationshipStatus
            case updatedAt
        }
    }

    public struct MemberDataSourceConfiguration: AWSDecodableShape {
        /// The account ID for the member account.
        public let accountId: String
        /// Contains information on the status of data sources for the account.
        public let dataSources: DataSourceConfigurationsResult

        public init(accountId: String, dataSources: DataSourceConfigurationsResult) {
            self.accountId = accountId
            self.dataSources = dataSources
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case dataSources
        }
    }

    public struct NetworkConnectionAction: AWSDecodableShape {
        /// Indicates whether EC2 blocked the network connection to your instance.
        public let blocked: Bool?
        /// The network connection direction.
        public let connectionDirection: String?
        /// The local IP information of the connection.
        public let localIpDetails: LocalIpDetails?
        /// The local port information of the connection.
        public let localPortDetails: LocalPortDetails?
        /// The network connection protocol.
        public let `protocol`: String?
        /// The remote IP information of the connection.
        public let remoteIpDetails: RemoteIpDetails?
        /// The remote port information of the connection.
        public let remotePortDetails: RemotePortDetails?

        public init(blocked: Bool? = nil, connectionDirection: String? = nil, localIpDetails: LocalIpDetails? = nil, localPortDetails: LocalPortDetails? = nil, protocol: String? = nil, remoteIpDetails: RemoteIpDetails? = nil, remotePortDetails: RemotePortDetails? = nil) {
            self.blocked = blocked
            self.connectionDirection = connectionDirection
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.`protocol` = `protocol`
            self.remoteIpDetails = remoteIpDetails
            self.remotePortDetails = remotePortDetails
        }

        private enum CodingKeys: String, CodingKey {
            case blocked
            case connectionDirection
            case localIpDetails
            case localPortDetails
            case `protocol`
            case remoteIpDetails
            case remotePortDetails
        }
    }

    public struct NetworkInterface: AWSDecodableShape {
        /// A list of IPv6 addresses for the EC2 instance.
        public let ipv6Addresses: [String]?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The private DNS name of the EC2 instance.
        public let privateDnsName: String?
        /// The private IP address of the EC2 instance.
        public let privateIpAddress: String?
        /// Other private IP address information of the EC2 instance.
        public let privateIpAddresses: [PrivateIpAddressDetails]?
        /// The public DNS name of the EC2 instance.
        public let publicDnsName: String?
        /// The public IP address of the EC2 instance.
        public let publicIp: String?
        /// The security groups associated with the EC2 instance.
        public let securityGroups: [SecurityGroup]?
        /// The subnet ID of the EC2 instance.
        public let subnetId: String?
        /// The VPC ID of the EC2 instance.
        public let vpcId: String?

        public init(ipv6Addresses: [String]? = nil, networkInterfaceId: String? = nil, privateDnsName: String? = nil, privateIpAddress: String? = nil, privateIpAddresses: [PrivateIpAddressDetails]? = nil, publicDnsName: String? = nil, publicIp: String? = nil, securityGroups: [SecurityGroup]? = nil, subnetId: String? = nil, vpcId: String? = nil) {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6Addresses
            case networkInterfaceId
            case privateDnsName
            case privateIpAddress
            case privateIpAddresses
            case publicDnsName
            case publicIp
            case securityGroups
            case subnetId
            case vpcId
        }
    }

    public struct Organization: AWSDecodableShape {
        /// The Autonomous System Number (ASN) of the internet provider of the remote IP address.
        public let asn: String?
        /// The organization that registered this ASN.
        public let asnOrg: String?
        /// The ISP information for the internet provider.
        public let isp: String?
        /// The name of the internet provider.
        public let org: String?

        public init(asn: String? = nil, asnOrg: String? = nil, isp: String? = nil, org: String? = nil) {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }

        private enum CodingKeys: String, CodingKey {
            case asn
            case asnOrg
            case isp
            case org
        }
    }

    public struct OrganizationDataSourceConfigurations: AWSEncodableShape {
        /// Describes the configuration of Kubernetes data sources for new members of the organization.
        public let kubernetes: OrganizationKubernetesConfiguration?
        /// Describes the configuration of Malware Protection for new members of the organization.
        public let malwareProtection: OrganizationMalwareProtectionConfiguration?
        /// Describes whether S3 data event logs are enabled for new members of the organization.
        public let s3Logs: OrganizationS3LogsConfiguration?

        public init(kubernetes: OrganizationKubernetesConfiguration? = nil, malwareProtection: OrganizationMalwareProtectionConfiguration? = nil, s3Logs: OrganizationS3LogsConfiguration? = nil) {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }

        private enum CodingKeys: String, CodingKey {
            case kubernetes
            case malwareProtection
            case s3Logs
        }
    }

    public struct OrganizationDataSourceConfigurationsResult: AWSDecodableShape {
        /// Describes the configuration of Kubernetes data sources.
        public let kubernetes: OrganizationKubernetesConfigurationResult?
        /// Describes the configuration of Malware Protection data source for an organization.
        public let malwareProtection: OrganizationMalwareProtectionConfigurationResult?
        /// Describes whether S3 data event logs are enabled as a data source.
        public let s3Logs: OrganizationS3LogsConfigurationResult

        public init(kubernetes: OrganizationKubernetesConfigurationResult? = nil, malwareProtection: OrganizationMalwareProtectionConfigurationResult? = nil, s3Logs: OrganizationS3LogsConfigurationResult) {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }

        private enum CodingKeys: String, CodingKey {
            case kubernetes
            case malwareProtection
            case s3Logs
        }
    }

    public struct OrganizationEbsVolumes: AWSEncodableShape {
        /// Whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public let autoEnable: Bool?

        public init(autoEnable: Bool? = nil) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
        }
    }

    public struct OrganizationEbsVolumesResult: AWSDecodableShape {
        /// An object that contains the status of whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public let autoEnable: Bool?

        public init(autoEnable: Bool? = nil) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
        }
    }

    public struct OrganizationKubernetesAuditLogsConfiguration: AWSEncodableShape {
        /// A value that contains information on whether Kubernetes audit logs should be enabled automatically as a data source for the organization.
        public let autoEnable: Bool

        public init(autoEnable: Bool = false) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
        }
    }

    public struct OrganizationKubernetesAuditLogsConfigurationResult: AWSDecodableShape {
        /// Whether Kubernetes audit logs data source should be auto-enabled for new members joining the organization.
        public let autoEnable: Bool

        public init(autoEnable: Bool) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
        }
    }

    public struct OrganizationKubernetesConfiguration: AWSEncodableShape {
        /// Whether Kubernetes audit logs data source should be auto-enabled for new members joining the organization.
        public let auditLogs: OrganizationKubernetesAuditLogsConfiguration

        public init(auditLogs: OrganizationKubernetesAuditLogsConfiguration) {
            self.auditLogs = auditLogs
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs
        }
    }

    public struct OrganizationKubernetesConfigurationResult: AWSDecodableShape {
        /// The current configuration of Kubernetes audit logs as a data source for the organization.
        public let auditLogs: OrganizationKubernetesAuditLogsConfigurationResult

        public init(auditLogs: OrganizationKubernetesAuditLogsConfigurationResult) {
            self.auditLogs = auditLogs
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs
        }
    }

    public struct OrganizationMalwareProtectionConfiguration: AWSEncodableShape {
        /// Whether Malware Protection for EC2 instances with findings should be auto-enabled for new members joining the organization.
        public let scanEc2InstanceWithFindings: OrganizationScanEc2InstanceWithFindings?

        public init(scanEc2InstanceWithFindings: OrganizationScanEc2InstanceWithFindings? = nil) {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }

        private enum CodingKeys: String, CodingKey {
            case scanEc2InstanceWithFindings
        }
    }

    public struct OrganizationMalwareProtectionConfigurationResult: AWSDecodableShape {
        /// Describes the configuration for scanning EC2 instances with findings for an organization.
        public let scanEc2InstanceWithFindings: OrganizationScanEc2InstanceWithFindingsResult?

        public init(scanEc2InstanceWithFindings: OrganizationScanEc2InstanceWithFindingsResult? = nil) {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }

        private enum CodingKeys: String, CodingKey {
            case scanEc2InstanceWithFindings
        }
    }

    public struct OrganizationS3LogsConfiguration: AWSEncodableShape {
        /// A value that contains information on whether S3 data event logs will be enabled automatically as a data source for the organization.
        public let autoEnable: Bool

        public init(autoEnable: Bool = false) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
        }
    }

    public struct OrganizationS3LogsConfigurationResult: AWSDecodableShape {
        /// A value that describes whether S3 data event logs are automatically enabled for new members of the organization.
        public let autoEnable: Bool

        public init(autoEnable: Bool) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
        }
    }

    public struct OrganizationScanEc2InstanceWithFindings: AWSEncodableShape {
        /// Whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public let ebsVolumes: OrganizationEbsVolumes?

        public init(ebsVolumes: OrganizationEbsVolumes? = nil) {
            self.ebsVolumes = ebsVolumes
        }

        private enum CodingKeys: String, CodingKey {
            case ebsVolumes
        }
    }

    public struct OrganizationScanEc2InstanceWithFindingsResult: AWSDecodableShape {
        /// Describes the configuration for scanning EBS volumes for an organization.
        public let ebsVolumes: OrganizationEbsVolumesResult?

        public init(ebsVolumes: OrganizationEbsVolumesResult? = nil) {
            self.ebsVolumes = ebsVolumes
        }

        private enum CodingKeys: String, CodingKey {
            case ebsVolumes
        }
    }

    public struct Owner: AWSDecodableShape {
        /// The canonical user ID of the bucket owner. For information about locating your canonical user ID see Finding Your Account Canonical User ID.
        public let id: String?

        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct PermissionConfiguration: AWSDecodableShape {
        /// Contains information about the account level permissions on the S3 bucket.
        public let accountLevelPermissions: AccountLevelPermissions?
        /// Contains information about the bucket level permissions for the S3 bucket.
        public let bucketLevelPermissions: BucketLevelPermissions?

        public init(accountLevelPermissions: AccountLevelPermissions? = nil, bucketLevelPermissions: BucketLevelPermissions? = nil) {
            self.accountLevelPermissions = accountLevelPermissions
            self.bucketLevelPermissions = bucketLevelPermissions
        }

        private enum CodingKeys: String, CodingKey {
            case accountLevelPermissions
            case bucketLevelPermissions
        }
    }

    public struct PortProbeAction: AWSDecodableShape {
        /// Indicates whether EC2 blocked the port probe to the instance, such as with an ACL.
        public let blocked: Bool?
        /// A list of objects related to port probe details.
        public let portProbeDetails: [PortProbeDetail]?

        public init(blocked: Bool? = nil, portProbeDetails: [PortProbeDetail]? = nil) {
            self.blocked = blocked
            self.portProbeDetails = portProbeDetails
        }

        private enum CodingKeys: String, CodingKey {
            case blocked
            case portProbeDetails
        }
    }

    public struct PortProbeDetail: AWSDecodableShape {
        /// The local IP information of the connection.
        public let localIpDetails: LocalIpDetails?
        /// The local port information of the connection.
        public let localPortDetails: LocalPortDetails?
        /// The remote IP information of the connection.
        public let remoteIpDetails: RemoteIpDetails?

        public init(localIpDetails: LocalIpDetails? = nil, localPortDetails: LocalPortDetails? = nil, remoteIpDetails: RemoteIpDetails? = nil) {
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.remoteIpDetails = remoteIpDetails
        }

        private enum CodingKeys: String, CodingKey {
            case localIpDetails
            case localPortDetails
            case remoteIpDetails
        }
    }

    public struct PrivateIpAddressDetails: AWSDecodableShape {
        /// The private DNS name of the EC2 instance.
        public let privateDnsName: String?
        /// The private IP address of the EC2 instance.
        public let privateIpAddress: String?

        public init(privateDnsName: String? = nil, privateIpAddress: String? = nil) {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }

        private enum CodingKeys: String, CodingKey {
            case privateDnsName
            case privateIpAddress
        }
    }

    public struct ProductCode: AWSDecodableShape {
        /// The product code information.
        public let code: String?
        /// The product code type.
        public let productType: String?

        public init(code: String? = nil, productType: String? = nil) {
            self.code = code
            self.productType = productType
        }

        private enum CodingKeys: String, CodingKey {
            case code = "productCodeId"
            case productType = "productCodeType"
        }
    }

    public struct PublicAccess: AWSDecodableShape {
        /// Describes the effective permission on this bucket after factoring all attached policies.
        public let effectivePermission: String?
        /// Contains information about how permissions are configured for the S3 bucket.
        public let permissionConfiguration: PermissionConfiguration?

        public init(effectivePermission: String? = nil, permissionConfiguration: PermissionConfiguration? = nil) {
            self.effectivePermission = effectivePermission
            self.permissionConfiguration = permissionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case effectivePermission
            case permissionConfiguration
        }
    }

    public struct RemoteAccountDetails: AWSDecodableShape {
        /// The Amazon Web Services account ID of the remote API caller.
        public let accountId: String?
        /// Details on whether the Amazon Web Services account of the remote API caller is related to your GuardDuty environment. If this value is True the API caller is affiliated to your account in some way. If it is False the API caller is from outside your environment.
        public let affiliated: Bool?

        public init(accountId: String? = nil, affiliated: Bool? = nil) {
            self.accountId = accountId
            self.affiliated = affiliated
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case affiliated
        }
    }

    public struct RemoteIpDetails: AWSDecodableShape {
        /// The city information of the remote IP address.
        public let city: City?
        /// The country code of the remote IP address.
        public let country: Country?
        /// The location information of the remote IP address.
        public let geoLocation: GeoLocation?
        /// The IPv4 remote address of the connection.
        public let ipAddressV4: String?
        /// The ISP organization information of the remote IP address.
        public let organization: Organization?

        public init(city: City? = nil, country: Country? = nil, geoLocation: GeoLocation? = nil, ipAddressV4: String? = nil, organization: Organization? = nil) {
            self.city = city
            self.country = country
            self.geoLocation = geoLocation
            self.ipAddressV4 = ipAddressV4
            self.organization = organization
        }

        private enum CodingKeys: String, CodingKey {
            case city
            case country
            case geoLocation
            case ipAddressV4
            case organization
        }
    }

    public struct RemotePortDetails: AWSDecodableShape {
        /// The port number of the remote connection.
        public let port: Int?
        /// The port name of the remote connection.
        public let portName: String?

        public init(port: Int? = nil, portName: String? = nil) {
            self.port = port
            self.portName = portName
        }

        private enum CodingKeys: String, CodingKey {
            case port
            case portName
        }
    }

    public struct Resource: AWSDecodableShape {
        /// The IAM access key details (IAM user information) of a user that engaged in the activity that prompted GuardDuty to generate a finding.
        public let accessKeyDetails: AccessKeyDetails?
        public let containerDetails: Container?
        /// Contains list of scanned and skipped EBS volumes with details.
        public let ebsVolumeDetails: EbsVolumeDetails?
        /// Contains information about the details of the ECS Cluster.
        public let ecsClusterDetails: EcsClusterDetails?
        /// Details about the EKS cluster involved in a Kubernetes finding.
        public let eksClusterDetails: EksClusterDetails?
        /// The information about the EC2 instance associated with the activity that prompted GuardDuty to generate a finding.
        public let instanceDetails: InstanceDetails?
        /// Details about the Kubernetes user and workload involved in a Kubernetes finding.
        public let kubernetesDetails: KubernetesDetails?
        /// The type of Amazon Web Services resource.
        public let resourceType: String?
        /// Contains information on the S3 bucket.
        public let s3BucketDetails: [S3BucketDetail]?

        public init(accessKeyDetails: AccessKeyDetails? = nil, containerDetails: Container? = nil, ebsVolumeDetails: EbsVolumeDetails? = nil, ecsClusterDetails: EcsClusterDetails? = nil, eksClusterDetails: EksClusterDetails? = nil, instanceDetails: InstanceDetails? = nil, kubernetesDetails: KubernetesDetails? = nil, resourceType: String? = nil, s3BucketDetails: [S3BucketDetail]? = nil) {
            self.accessKeyDetails = accessKeyDetails
            self.containerDetails = containerDetails
            self.ebsVolumeDetails = ebsVolumeDetails
            self.ecsClusterDetails = ecsClusterDetails
            self.eksClusterDetails = eksClusterDetails
            self.instanceDetails = instanceDetails
            self.kubernetesDetails = kubernetesDetails
            self.resourceType = resourceType
            self.s3BucketDetails = s3BucketDetails
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyDetails
            case containerDetails
            case ebsVolumeDetails
            case ecsClusterDetails
            case eksClusterDetails
            case instanceDetails
            case kubernetesDetails
            case resourceType
            case s3BucketDetails
        }
    }

    public struct ResourceDetails: AWSDecodableShape {
        /// InstanceArn that was scanned in the scan entry.
        public let instanceArn: String?

        public init(instanceArn: String? = nil) {
            self.instanceArn = instanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case instanceArn
        }
    }

    public struct S3BucketDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public let arn: String?
        /// The date and time the bucket was created at.
        public let createdAt: Date?
        /// Describes the server side encryption method used in the S3 bucket.
        public let defaultServerSideEncryption: DefaultServerSideEncryption?
        /// The name of the S3 bucket.
        public let name: String?
        /// The owner of the S3 bucket.
        public let owner: Owner?
        /// Describes the public access policies that apply to the S3 bucket.
        public let publicAccess: PublicAccess?
        /// All tags attached to the S3 bucket
        public let tags: [Tag]?
        /// Describes whether the bucket is a source or destination bucket.
        public let type: String?

        public init(arn: String? = nil, createdAt: Date? = nil, defaultServerSideEncryption: DefaultServerSideEncryption? = nil, name: String? = nil, owner: Owner? = nil, publicAccess: PublicAccess? = nil, tags: [Tag]? = nil, type: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.defaultServerSideEncryption = defaultServerSideEncryption
            self.name = name
            self.owner = owner
            self.publicAccess = publicAccess
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case defaultServerSideEncryption
            case name
            case owner
            case publicAccess
            case tags
            case type
        }
    }

    public struct S3LogsConfiguration: AWSEncodableShape {
        ///  The status of S3 data event logs as a data source.
        public let enable: Bool

        public init(enable: Bool = false) {
            self.enable = enable
        }

        private enum CodingKeys: String, CodingKey {
            case enable
        }
    }

    public struct S3LogsConfigurationResult: AWSDecodableShape {
        /// A value that describes whether S3 data event logs are automatically enabled for new members of the organization.
        public let status: DataSourceStatus

        public init(status: DataSourceStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct Scan: AWSDecodableShape {
        /// The ID for the account that belongs to the scan.
        public let accountId: String?
        /// The unique detector ID of the administrator account that the request is associated with. Note that this value will be the same as the one used for DetectorId if the account is an administrator.
        public let adminDetectorId: String?
        /// List of volumes that were attached to the original instance to be scanned.
        public let attachedVolumes: [VolumeDetail]?
        /// The unique ID of the detector that the request is associated with.
        public let detectorId: String?
        /// Represents the reason for FAILED scan status.
        public let failureReason: String?
        /// Represents the number of files that were scanned.
        public let fileCount: Int64?
        /// Represents the resources that were scanned in the scan entry.
        public let resourceDetails: ResourceDetails?
        /// The timestamp of when the scan was finished.
        public let scanEndTime: Date?
        /// The unique scan ID associated with a scan entry.
        public let scanId: String?
        /// Represents the result of the scan.
        public let scanResultDetails: ScanResultDetails?
        /// The timestamp of when the scan was triggered.
        public let scanStartTime: Date?
        /// An enum value representing possible scan statuses.
        public let scanStatus: ScanStatus?
        /// Represents total bytes that were scanned.
        public let totalBytes: Int64?
        /// Specifies the reason why the scan was initiated.
        public let triggerDetails: TriggerDetails?

        public init(accountId: String? = nil, adminDetectorId: String? = nil, attachedVolumes: [VolumeDetail]? = nil, detectorId: String? = nil, failureReason: String? = nil, fileCount: Int64? = nil, resourceDetails: ResourceDetails? = nil, scanEndTime: Date? = nil, scanId: String? = nil, scanResultDetails: ScanResultDetails? = nil, scanStartTime: Date? = nil, scanStatus: ScanStatus? = nil, totalBytes: Int64? = nil, triggerDetails: TriggerDetails? = nil) {
            self.accountId = accountId
            self.adminDetectorId = adminDetectorId
            self.attachedVolumes = attachedVolumes
            self.detectorId = detectorId
            self.failureReason = failureReason
            self.fileCount = fileCount
            self.resourceDetails = resourceDetails
            self.scanEndTime = scanEndTime
            self.scanId = scanId
            self.scanResultDetails = scanResultDetails
            self.scanStartTime = scanStartTime
            self.scanStatus = scanStatus
            self.totalBytes = totalBytes
            self.triggerDetails = triggerDetails
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case adminDetectorId
            case attachedVolumes
            case detectorId
            case failureReason
            case fileCount
            case resourceDetails
            case scanEndTime
            case scanId
            case scanResultDetails
            case scanStartTime
            case scanStatus
            case totalBytes
            case triggerDetails
        }
    }

    public struct ScanCondition: AWSEncodableShape & AWSDecodableShape {
        /// Represents an mapEqual condition to be applied to a single field when triggering for malware scan.
        public let mapEquals: [ScanConditionPair]

        public init(mapEquals: [ScanConditionPair]) {
            self.mapEquals = mapEquals
        }

        public func validate(name: String) throws {
            try self.mapEquals.forEach {
                try $0.validate(name: "\(name).mapEquals[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case mapEquals
        }
    }

    public struct ScanConditionPair: AWSEncodableShape & AWSDecodableShape {
        /// Represents key in the map condition.
        public let key: String
        /// Represents optional value in the map condition. If not specified, only key will be matched.
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct ScanDetections: AWSDecodableShape {
        /// Details of the highest severity threat detected during malware scan and number of infected files.
        public let highestSeverityThreatDetails: HighestSeverityThreatDetails?
        /// Total number of scanned files.
        public let scannedItemCount: ScannedItemCount?
        /// Contains details about identified threats organized by threat name.
        public let threatDetectedByName: ThreatDetectedByName?
        /// Total number of infected files.
        public let threatsDetectedItemCount: ThreatsDetectedItemCount?

        public init(highestSeverityThreatDetails: HighestSeverityThreatDetails? = nil, scannedItemCount: ScannedItemCount? = nil, threatDetectedByName: ThreatDetectedByName? = nil, threatsDetectedItemCount: ThreatsDetectedItemCount? = nil) {
            self.highestSeverityThreatDetails = highestSeverityThreatDetails
            self.scannedItemCount = scannedItemCount
            self.threatDetectedByName = threatDetectedByName
            self.threatsDetectedItemCount = threatsDetectedItemCount
        }

        private enum CodingKeys: String, CodingKey {
            case highestSeverityThreatDetails
            case scannedItemCount
            case threatDetectedByName
            case threatsDetectedItemCount
        }
    }

    public struct ScanEc2InstanceWithFindings: AWSEncodableShape {
        /// Describes the configuration for scanning EBS volumes as data source.
        public let ebsVolumes: Bool?

        public init(ebsVolumes: Bool? = nil) {
            self.ebsVolumes = ebsVolumes
        }

        private enum CodingKeys: String, CodingKey {
            case ebsVolumes
        }
    }

    public struct ScanEc2InstanceWithFindingsResult: AWSDecodableShape {
        /// Describes the configuration of scanning EBS volumes as a data source.
        public let ebsVolumes: EbsVolumesResult?

        public init(ebsVolumes: EbsVolumesResult? = nil) {
            self.ebsVolumes = ebsVolumes
        }

        private enum CodingKeys: String, CodingKey {
            case ebsVolumes
        }
    }

    public struct ScanFilePath: AWSDecodableShape {
        /// File name of the infected file.
        public let fileName: String?
        /// The file path of the infected file.
        public let filePath: String?
        /// The hash value of the infected file.
        public let hash: String?
        /// EBS volume Arn details of the infected file.
        public let volumeArn: String?

        public init(fileName: String? = nil, filePath: String? = nil, hash: String? = nil, volumeArn: String? = nil) {
            self.fileName = fileName
            self.filePath = filePath
            self.hash = hash
            self.volumeArn = volumeArn
        }

        private enum CodingKeys: String, CodingKey {
            case fileName
            case filePath
            case hash
            case volumeArn
        }
    }

    public struct ScanResourceCriteria: AWSEncodableShape & AWSDecodableShape {
        /// Represents condition that when matched will prevent a malware scan for a certain resource.
        public let exclude: [ScanCriterionKey: ScanCondition]?
        /// Represents condition that when matched will allow a malware scan for a certain resource.
        public let include: [ScanCriterionKey: ScanCondition]?

        public init(exclude: [ScanCriterionKey: ScanCondition]? = nil, include: [ScanCriterionKey: ScanCondition]? = nil) {
            self.exclude = exclude
            self.include = include
        }

        public func validate(name: String) throws {
            try self.exclude?.forEach {
                try $0.value.validate(name: "\(name).exclude[\"\($0.key)\"]")
            }
            try self.include?.forEach {
                try $0.value.validate(name: "\(name).include[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case exclude
            case include
        }
    }

    public struct ScanResultDetails: AWSDecodableShape {
        /// An enum value representing possible scan results.
        public let scanResult: ScanResult?

        public init(scanResult: ScanResult? = nil) {
            self.scanResult = scanResult
        }

        private enum CodingKeys: String, CodingKey {
            case scanResult
        }
    }

    public struct ScanThreatName: AWSDecodableShape {
        /// List of infected files in EBS volume with details.
        public let filePaths: [ScanFilePath]?
        /// Total number of files infected with given threat.
        public let itemCount: Int?
        /// The name of the identified threat.
        public let name: String?
        /// Severity of threat identified as part of the malware scan.
        public let severity: String?

        public init(filePaths: [ScanFilePath]? = nil, itemCount: Int? = nil, name: String? = nil, severity: String? = nil) {
            self.filePaths = filePaths
            self.itemCount = itemCount
            self.name = name
            self.severity = severity
        }

        private enum CodingKeys: String, CodingKey {
            case filePaths
            case itemCount
            case name
            case severity
        }
    }

    public struct ScannedItemCount: AWSDecodableShape {
        /// Number of files scanned.
        public let files: Int?
        /// Total GB of files scanned for malware.
        public let totalGb: Int?
        /// Total number of scanned volumes.
        public let volumes: Int?

        public init(files: Int? = nil, totalGb: Int? = nil, volumes: Int? = nil) {
            self.files = files
            self.totalGb = totalGb
            self.volumes = volumes
        }

        private enum CodingKeys: String, CodingKey {
            case files
            case totalGb
            case volumes
        }
    }

    public struct SecurityContext: AWSDecodableShape {
        /// Whether the container is privileged.
        public let privileged: Bool?

        public init(privileged: Bool? = nil) {
            self.privileged = privileged
        }

        private enum CodingKeys: String, CodingKey {
            case privileged
        }
    }

    public struct SecurityGroup: AWSDecodableShape {
        /// The security group ID of the EC2 instance.
        public let groupId: String?
        /// The security group name of the EC2 instance.
        public let groupName: String?

        public init(groupId: String? = nil, groupName: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case groupId
            case groupName
        }
    }

    public struct Service: AWSDecodableShape {
        /// Information about the activity that is described in a finding.
        public let action: Action?
        /// Contains additional information about the generated finding.
        public let additionalInfo: ServiceAdditionalInfo?
        /// Indicates whether this finding is archived.
        public let archived: Bool?
        /// The total count of the occurrences of this finding type.
        public let count: Int?
        /// The detector ID for the GuardDuty service.
        public let detectorId: String?
        /// Returns details from the malware scan that created a finding.
        public let ebsVolumeScanDetails: EbsVolumeScanDetails?
        /// The first-seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public let eventFirstSeen: String?
        /// The last-seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public let eventLastSeen: String?
        /// An evidence object associated with the service.
        public let evidence: Evidence?
        /// The name of the feature that generated a finding.
        public let featureName: String?
        /// The resource role information for this finding.
        public let resourceRole: String?
        /// The name of the Amazon Web Services service (GuardDuty) that generated a finding.
        public let serviceName: String?
        /// Feedback that was submitted about the finding.
        public let userFeedback: String?

        public init(action: Action? = nil, additionalInfo: ServiceAdditionalInfo? = nil, archived: Bool? = nil, count: Int? = nil, detectorId: String? = nil, ebsVolumeScanDetails: EbsVolumeScanDetails? = nil, eventFirstSeen: String? = nil, eventLastSeen: String? = nil, evidence: Evidence? = nil, featureName: String? = nil, resourceRole: String? = nil, serviceName: String? = nil, userFeedback: String? = nil) {
            self.action = action
            self.additionalInfo = additionalInfo
            self.archived = archived
            self.count = count
            self.detectorId = detectorId
            self.ebsVolumeScanDetails = ebsVolumeScanDetails
            self.eventFirstSeen = eventFirstSeen
            self.eventLastSeen = eventLastSeen
            self.evidence = evidence
            self.featureName = featureName
            self.resourceRole = resourceRole
            self.serviceName = serviceName
            self.userFeedback = userFeedback
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case additionalInfo
            case archived
            case count
            case detectorId
            case ebsVolumeScanDetails
            case eventFirstSeen
            case eventLastSeen
            case evidence
            case featureName
            case resourceRole
            case serviceName
            case userFeedback
        }
    }

    public struct ServiceAdditionalInfo: AWSDecodableShape {
        /// Describes the type of the additional information.
        public let type: String?
        /// This field specifies the value of the additional information.
        public let value: String?

        public init(type: String? = nil, value: String? = nil) {
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case value
        }
    }

    public struct SortCriteria: AWSEncodableShape {
        /// Represents the finding attribute (for example, accountId) to sort findings by.
        public let attributeName: String?
        /// The order by which the sorted findings are to be displayed.
        public let orderBy: OrderBy?

        public init(attributeName: String? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName
            case orderBy
        }
    }

    public struct StartMonitoringMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// A list of account IDs of the GuardDuty member accounts to start monitoring.
        public let accountIds: [String]
        /// The unique ID of the detector of the GuardDuty administrator account associated with the member accounts to monitor.
        public let detectorId: String

        public init(accountIds: [String], detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct StartMonitoringMembersResponse: AWSDecodableShape {
        /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct StopMonitoringMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// A list of account IDs for the member accounts to stop monitoring.
        public let accountIds: [String]
        /// The unique ID of the detector associated with the GuardDuty administrator account that is monitoring member accounts.
        public let detectorId: String

        public init(accountIds: [String], detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct StopMonitoringMembersResponse: AWSDecodableShape {
        /// A list of objects that contain an accountId for each account that could not be processed, and a result string that indicates why the account was not processed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct Tag: AWSDecodableShape {
        /// The EC2 instance tag key.
        public let key: String?
        /// The EC2 instance tag value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) for the GuardDuty resource to apply a tag to.
        public let resourceArn: String
        /// The tags to be added to a resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\\d+:detector/[A-Za-z0-9_/.-]{32,264}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThreatDetectedByName: AWSDecodableShape {
        /// Total number of infected files identified.
        public let itemCount: Int?
        /// Flag to determine if the finding contains every single infected file-path and/or every threat.
        public let shortened: Bool?
        /// List of identified threats with details, organized by threat name.
        public let threatNames: [ScanThreatName]?
        /// Total number of unique threats by name identified, as part of the malware scan.
        public let uniqueThreatNameCount: Int?

        public init(itemCount: Int? = nil, shortened: Bool? = nil, threatNames: [ScanThreatName]? = nil, uniqueThreatNameCount: Int? = nil) {
            self.itemCount = itemCount
            self.shortened = shortened
            self.threatNames = threatNames
            self.uniqueThreatNameCount = uniqueThreatNameCount
        }

        private enum CodingKeys: String, CodingKey {
            case itemCount
            case shortened
            case threatNames
            case uniqueThreatNameCount
        }
    }

    public struct ThreatIntelligenceDetail: AWSDecodableShape {
        /// The name of the threat intelligence list that triggered the finding.
        public let threatListName: String?
        /// A list of names of the threats in the threat intelligence list that triggered the finding.
        public let threatNames: [String]?

        public init(threatListName: String? = nil, threatNames: [String]? = nil) {
            self.threatListName = threatListName
            self.threatNames = threatNames
        }

        private enum CodingKeys: String, CodingKey {
            case threatListName
            case threatNames
        }
    }

    public struct ThreatsDetectedItemCount: AWSDecodableShape {
        /// Total number of infected files.
        public let files: Int?

        public init(files: Int? = nil) {
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case files
        }
    }

    public struct Total: AWSDecodableShape {
        /// The total usage.
        public let amount: String?
        /// The currency unit that the amount is given in.
        public let unit: String?

        public init(amount: String? = nil, unit: String? = nil) {
            self.amount = amount
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case amount
            case unit
        }
    }

    public struct TriggerDetails: AWSDecodableShape {
        /// The description of the scan trigger.
        public let description: String?
        /// The ID of the GuardDuty finding that triggered the BirdDog scan.
        public let guardDutyFindingId: String?

        public init(description: String? = nil, guardDutyFindingId: String? = nil) {
            self.description = description
            self.guardDutyFindingId = guardDutyFindingId
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case guardDutyFindingId
        }
    }

    public struct UnarchiveFindingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The ID of the detector associated with the findings to unarchive.
        public let detectorId: String
        /// The IDs of the findings to unarchive.
        public let findingIds: [String]

        public init(detectorId: String, findingIds: [String]) {
            self.detectorId = detectorId
            self.findingIds = findingIds
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.findingIds.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try self.validate(self.findingIds, name: "findingIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds
        }
    }

    public struct UnarchiveFindingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UnprocessedAccount: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String
        /// A reason why the account hasn't been processed.
        public let result: String

        public init(accountId: String, result: String) {
            self.accountId = accountId
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case result
        }
    }

    public struct UnprocessedDataSourcesResult: AWSDecodableShape {
        public let malwareProtection: MalwareProtectionConfigurationResult?

        public init(malwareProtection: MalwareProtectionConfigurationResult? = nil) {
            self.malwareProtection = malwareProtection
        }

        private enum CodingKeys: String, CodingKey {
            case malwareProtection
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) for the resource to remove tags from.
        public let resourceArn: String
        /// The tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\\d+:detector/[A-Za-z0-9_/.-]{32,264}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDetectorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// Describes which data sources will be updated.
        public let dataSources: DataSourceConfigurations?
        /// The unique ID of the detector to update.
        public let detectorId: String
        /// Specifies whether the detector is enabled or not enabled.
        public let enable: Bool?
        /// An enum value that specifies how frequently findings are exported, such as to CloudWatch Events.
        public let findingPublishingFrequency: FindingPublishingFrequency?

        public init(dataSources: DataSourceConfigurations? = nil, detectorId: String, enable: Bool? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil) {
            self.dataSources = dataSources
            self.detectorId = detectorId
            self.enable = enable
            self.findingPublishingFrequency = findingPublishingFrequency
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources
            case enable
            case findingPublishingFrequency
        }
    }

    public struct UpdateDetectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFilterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "filterName", location: .uri("filterName"))
        ]

        /// Specifies the action that is to be applied to the findings that match the filter.
        public let action: FilterAction?
        /// The description of the filter. Valid special characters include period (.), underscore (_), dash (-),  and whitespace. The new line character is considered to be an invalid input for description.
        public let description: String?
        /// The unique ID of the detector that specifies the GuardDuty service where you want to update a filter.
        public let detectorId: String
        /// The name of the filter.
        public let filterName: String
        /// Represents the criteria to be used in the filter for querying findings.
        public let findingCriteria: FindingCriteria?
        /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
        public let rank: Int?

        public init(action: FilterAction? = nil, description: String? = nil, detectorId: String, filterName: String, findingCriteria: FindingCriteria? = nil, rank: Int? = nil) {
            self.action = action
            self.description = description
            self.detectorId = detectorId
            self.filterName = filterName
            self.findingCriteria = findingCriteria
            self.rank = rank
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.rank, name: "rank", parent: name, max: 100)
            try self.validate(self.rank, name: "rank", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case description
            case findingCriteria
            case rank
        }
    }

    public struct UpdateFilterResponse: AWSDecodableShape {
        /// The name of the filter.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct UpdateFindingsFeedbackRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// Additional feedback about the GuardDuty findings.
        public let comments: String?
        /// The ID of the detector associated with the findings to update feedback for.
        public let detectorId: String
        /// The feedback for the finding.
        public let feedback: Feedback
        /// The IDs of the findings that you want to mark as useful or not useful.
        public let findingIds: [String]

        public init(comments: String? = nil, detectorId: String, feedback: Feedback, findingIds: [String]) {
            self.comments = comments
            self.detectorId = detectorId
            self.feedback = feedback
            self.findingIds = findingIds
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.findingIds.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try self.validate(self.findingIds, name: "findingIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case comments
            case feedback
            case findingIds
        }
    }

    public struct UpdateFindingsFeedbackResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateIPSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "ipSetId", location: .uri("ipSetId"))
        ]

        /// The updated Boolean value that specifies whether the IPSet is active or not.
        public let activate: Bool?
        /// The detectorID that specifies the GuardDuty service whose IPSet you want to update.
        public let detectorId: String
        /// The unique ID that specifies the IPSet that you want to update.
        public let ipSetId: String
        /// The updated URI of the file that contains the IPSet.
        public let location: String?
        /// The unique ID that specifies the IPSet that you want to update.
        public let name: String?

        public init(activate: Bool? = nil, detectorId: String, ipSetId: String, location: String? = nil, name: String? = nil) {
            self.activate = activate
            self.detectorId = detectorId
            self.ipSetId = ipSetId
            self.location = location
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.location, name: "location", parent: name, max: 300)
            try self.validate(self.location, name: "location", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activate
            case location
            case name
        }
    }

    public struct UpdateIPSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMalwareScanSettingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The unique ID of the detector that specifies the GuardDuty service where you want to update scan settings.
        public let detectorId: String
        /// An enum value representing possible snapshot preservation settings.
        public let ebsSnapshotPreservation: EbsSnapshotPreservation?
        /// Represents the criteria to be used in the filter for selecting resources to scan.
        public let scanResourceCriteria: ScanResourceCriteria?

        public init(detectorId: String, ebsSnapshotPreservation: EbsSnapshotPreservation? = nil, scanResourceCriteria: ScanResourceCriteria? = nil) {
            self.detectorId = detectorId
            self.ebsSnapshotPreservation = ebsSnapshotPreservation
            self.scanResourceCriteria = scanResourceCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.scanResourceCriteria?.validate(name: "\(name).scanResourceCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case ebsSnapshotPreservation
            case scanResourceCriteria
        }
    }

    public struct UpdateMalwareScanSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMemberDetectorsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// A list of member account IDs to be updated.
        public let accountIds: [String]
        /// Describes which data sources will be updated.
        public let dataSources: DataSourceConfigurations?
        /// The detector ID of the administrator account.
        public let detectorId: String

        public init(accountIds: [String], dataSources: DataSourceConfigurations? = nil, detectorId: String) {
            self.accountIds = accountIds
            self.dataSources = dataSources
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
            case dataSources
        }
    }

    public struct UpdateMemberDetectorsResponse: AWSDecodableShape {
        /// A list of member account IDs that were unable to be processed along with an explanation for why they were not processed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct UpdateOrganizationConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// Indicates whether to automatically enable member accounts in the organization.
        public let autoEnable: Bool
        /// Describes which data sources will be updated.
        public let dataSources: OrganizationDataSourceConfigurations?
        /// The ID of the detector to update the delegated administrator for.
        public let detectorId: String

        public init(autoEnable: Bool = false, dataSources: OrganizationDataSourceConfigurations? = nil, detectorId: String) {
            self.autoEnable = autoEnable
            self.dataSources = dataSources
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
            case dataSources
        }
    }

    public struct UpdateOrganizationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePublishingDestinationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "destinationId", location: .uri("destinationId")),
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId"))
        ]

        /// The ID of the publishing destination to update.
        public let destinationId: String
        /// A DestinationProperties object that includes the DestinationArn and KmsKeyArn of the publishing destination.
        public let destinationProperties: DestinationProperties?
        /// The ID of the detector associated with the publishing destinations to update.
        public let detectorId: String

        public init(destinationId: String, destinationProperties: DestinationProperties? = nil, detectorId: String) {
            self.destinationId = destinationId
            self.destinationProperties = destinationProperties
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationProperties
        }
    }

    public struct UpdatePublishingDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateThreatIntelSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "detectorId", location: .uri("detectorId")),
            AWSMemberEncoding(label: "threatIntelSetId", location: .uri("threatIntelSetId"))
        ]

        /// The updated Boolean value that specifies whether the ThreateIntelSet is active or not.
        public let activate: Bool?
        /// The detectorID that specifies the GuardDuty service whose ThreatIntelSet you want to update.
        public let detectorId: String
        /// The updated URI of the file that contains the ThreateIntelSet.
        public let location: String?
        /// The unique ID that specifies the ThreatIntelSet that you want to update.
        public let name: String?
        /// The unique ID that specifies the ThreatIntelSet that you want to update.
        public let threatIntelSetId: String

        public init(activate: Bool? = nil, detectorId: String, location: String? = nil, name: String? = nil, threatIntelSetId: String) {
            self.activate = activate
            self.detectorId = detectorId
            self.location = location
            self.name = name
            self.threatIntelSetId = threatIntelSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorId, name: "detectorId", parent: name, max: 300)
            try self.validate(self.detectorId, name: "detectorId", parent: name, min: 1)
            try self.validate(self.location, name: "location", parent: name, max: 300)
            try self.validate(self.location, name: "location", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 300)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activate
            case location
            case name
        }
    }

    public struct UpdateThreatIntelSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UsageAccountResult: AWSDecodableShape {
        /// The Account ID that generated usage.
        public let accountId: String?
        /// Represents the total of usage for the Account ID.
        public let total: Total?

        public init(accountId: String? = nil, total: Total? = nil) {
            self.accountId = accountId
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case total
        }
    }

    public struct UsageCriteria: AWSEncodableShape {
        /// The account IDs to aggregate usage statistics from.
        public let accountIds: [String]?
        /// The data sources to aggregate usage statistics from.
        public let dataSources: [DataSource]
        /// The resources to aggregate usage statistics from. Only accepts exact resource names.
        public let resources: [String]?

        public init(accountIds: [String]? = nil, dataSources: [DataSource], resources: [String]? = nil) {
            self.accountIds = accountIds
            self.dataSources = dataSources
            self.resources = resources
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 50)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
            case dataSources
            case resources
        }
    }

    public struct UsageDataSourceResult: AWSDecodableShape {
        /// The data source type that generated usage.
        public let dataSource: DataSource?
        /// Represents the total of usage for the specified data source.
        public let total: Total?

        public init(dataSource: DataSource? = nil, total: Total? = nil) {
            self.dataSource = dataSource
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource
            case total
        }
    }

    public struct UsageResourceResult: AWSDecodableShape {
        /// The Amazon Web Services resource that generated usage.
        public let resource: String?
        /// Represents the sum total of usage for the specified resource type.
        public let total: Total?

        public init(resource: String? = nil, total: Total? = nil) {
            self.resource = resource
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case resource
            case total
        }
    }

    public struct UsageStatistics: AWSDecodableShape {
        /// The usage statistic sum organized by account ID.
        public let sumByAccount: [UsageAccountResult]?
        /// The usage statistic sum organized by on data source.
        public let sumByDataSource: [UsageDataSourceResult]?
        /// The usage statistic sum organized by resource.
        public let sumByResource: [UsageResourceResult]?
        /// Lists the top 50 resources that have generated the most GuardDuty usage, in order from most to least expensive.
        public let topResources: [UsageResourceResult]?

        public init(sumByAccount: [UsageAccountResult]? = nil, sumByDataSource: [UsageDataSourceResult]? = nil, sumByResource: [UsageResourceResult]? = nil, topResources: [UsageResourceResult]? = nil) {
            self.sumByAccount = sumByAccount
            self.sumByDataSource = sumByDataSource
            self.sumByResource = sumByResource
            self.topResources = topResources
        }

        private enum CodingKeys: String, CodingKey {
            case sumByAccount
            case sumByDataSource
            case sumByResource
            case topResources
        }
    }

    public struct Volume: AWSDecodableShape {
        /// Represents a pre-existing file or directory on the host machine that the volume maps to.
        public let hostPath: HostPath?
        /// Volume name.
        public let name: String?

        public init(hostPath: HostPath? = nil, name: String? = nil) {
            self.hostPath = hostPath
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case hostPath
            case name
        }
    }

    public struct VolumeDetail: AWSDecodableShape {
        /// The device name for the EBS volume.
        public let deviceName: String?
        /// EBS volume encryption type.
        public let encryptionType: String?
        /// KMS key Arn used to encrypt the EBS volume.
        public let kmsKeyArn: String?
        /// Snapshot Arn of the EBS volume.
        public let snapshotArn: String?
        /// EBS volume Arn information.
        public let volumeArn: String?
        /// EBS volume size in GB.
        public let volumeSizeInGB: Int?
        /// The EBS volume type.
        public let volumeType: String?

        public init(deviceName: String? = nil, encryptionType: String? = nil, kmsKeyArn: String? = nil, snapshotArn: String? = nil, volumeArn: String? = nil, volumeSizeInGB: Int? = nil, volumeType: String? = nil) {
            self.deviceName = deviceName
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
            self.snapshotArn = snapshotArn
            self.volumeArn = volumeArn
            self.volumeSizeInGB = volumeSizeInGB
            self.volumeType = volumeType
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName
            case encryptionType
            case kmsKeyArn
            case snapshotArn
            case volumeArn
            case volumeSizeInGB
            case volumeType
        }
    }

    public struct VolumeMount: AWSDecodableShape {
        /// Volume mount path.
        public let mountPath: String?
        /// Volume mount name.
        public let name: String?

        public init(mountPath: String? = nil, name: String? = nil) {
            self.mountPath = mountPath
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case mountPath
            case name
        }
    }
}

// MARK: - Errors

/// Error enum for GuardDuty
public struct GuardDutyErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case internalServerErrorException = "InternalServerErrorException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize GuardDuty
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// A bad request exception object.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// An internal server error exception object.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
}

extension GuardDutyErrorType: Equatable {
    public static func == (lhs: GuardDutyErrorType, rhs: GuardDutyErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GuardDutyErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
