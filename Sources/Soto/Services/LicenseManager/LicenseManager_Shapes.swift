//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension LicenseManager {
    // MARK: Enums

    public enum InventoryFilterCondition: String, CustomStringConvertible, Codable {
        case beginsWith = "BEGINS_WITH"
        case contains = "CONTAINS"
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum LicenseConfigurationStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum LicenseCountingType: String, CustomStringConvertible, Codable {
        case core = "Core"
        case instance = "Instance"
        case socket = "Socket"
        case vcpu = "vCPU"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable {
        case ec2Ami = "EC2_AMI"
        case ec2Host = "EC2_HOST"
        case ec2Instance = "EC2_INSTANCE"
        case rds = "RDS"
        case systemsManagerManagedInstance = "SYSTEMS_MANAGER_MANAGED_INSTANCE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AutomatedDiscoveryInformation: AWSDecodableShape {
        /// Time that automated discovery last ran.
        public let lastRunTime: Date?

        public init(lastRunTime: Date? = nil) {
            self.lastRunTime = lastRunTime
        }

        private enum CodingKeys: String, CodingKey {
            case lastRunTime = "LastRunTime"
        }
    }

    public struct ConsumedLicenseSummary: AWSDecodableShape {
        /// Number of licenses consumed by the resource.
        public let consumedLicenses: Int64?
        /// Resource type of the resource consuming a license.
        public let resourceType: ResourceType?

        public init(consumedLicenses: Int64? = nil, resourceType: ResourceType? = nil) {
            self.consumedLicenses = consumedLicenses
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case consumedLicenses = "ConsumedLicenses"
            case resourceType = "ResourceType"
        }
    }

    public struct CreateLicenseConfigurationRequest: AWSEncodableShape {
        /// Description of the license configuration.
        public let description: String?
        /// Number of licenses managed by the license configuration.
        public let licenseCount: Int64?
        /// Indicates whether hard or soft license enforcement is used. Exceeding a hard limit blocks the launch of new instances.
        public let licenseCountHardLimit: Bool?
        /// Dimension used to track the license inventory.
        public let licenseCountingType: LicenseCountingType
        /// License rules. The syntax is #name=value (for example, #allowedTenancy=EC2-DedicatedHost). The available rules vary by dimension, as follows.    Cores dimension: allowedTenancy | licenseAffinityToHost | maximumCores | minimumCores     Instances dimension: allowedTenancy | maximumCores | minimumCores | maximumSockets | minimumSockets | maximumVcpus | minimumVcpus     Sockets dimension: allowedTenancy | licenseAffinityToHost | maximumSockets | minimumSockets     vCPUs dimension: allowedTenancy | honorVcpuOptimization | maximumVcpus | minimumVcpus    The unit for licenseAffinityToHost is days and the range is 1 to 180. The possible values for allowedTenancy are EC2-Default, EC2-DedicatedHost, and EC2-DedicatedInstance. The possible values for honorVcpuOptimization are True and False.
        public let licenseRules: [String]?
        /// Name of the license configuration.
        public let name: String
        /// Product information.
        public let productInformationList: [ProductInformation]?
        /// Tags to add to the license configuration.
        public let tags: [Tag]?

        public init(description: String? = nil, licenseCount: Int64? = nil, licenseCountHardLimit: Bool? = nil, licenseCountingType: LicenseCountingType, licenseRules: [String]? = nil, name: String, productInformationList: [ProductInformation]? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.licenseCount = licenseCount
            self.licenseCountHardLimit = licenseCountHardLimit
            self.licenseCountingType = licenseCountingType
            self.licenseRules = licenseRules
            self.name = name
            self.productInformationList = productInformationList
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case licenseCount = "LicenseCount"
            case licenseCountHardLimit = "LicenseCountHardLimit"
            case licenseCountingType = "LicenseCountingType"
            case licenseRules = "LicenseRules"
            case name = "Name"
            case productInformationList = "ProductInformationList"
            case tags = "Tags"
        }
    }

    public struct CreateLicenseConfigurationResponse: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the license configuration.
        public let licenseConfigurationArn: String?

        public init(licenseConfigurationArn: String? = nil) {
            self.licenseConfigurationArn = licenseConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case licenseConfigurationArn = "LicenseConfigurationArn"
        }
    }

    public struct DeleteLicenseConfigurationRequest: AWSEncodableShape {
        /// ID of the license configuration.
        public let licenseConfigurationArn: String

        public init(licenseConfigurationArn: String) {
            self.licenseConfigurationArn = licenseConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case licenseConfigurationArn = "LicenseConfigurationArn"
        }
    }

    public struct DeleteLicenseConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Filter: AWSEncodableShape {
        /// Name of the filter. Filter names are case-sensitive.
        public let name: String?
        /// Filter values. Filter values are case-sensitive.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct GetLicenseConfigurationRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the license configuration.
        public let licenseConfigurationArn: String

        public init(licenseConfigurationArn: String) {
            self.licenseConfigurationArn = licenseConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case licenseConfigurationArn = "LicenseConfigurationArn"
        }
    }

    public struct GetLicenseConfigurationResponse: AWSDecodableShape {
        /// Automated discovery information.
        public let automatedDiscoveryInformation: AutomatedDiscoveryInformation?
        /// Number of licenses assigned to resources.
        public let consumedLicenses: Int64?
        /// Summaries of the licenses consumed by resources.
        public let consumedLicenseSummaryList: [ConsumedLicenseSummary]?
        /// Description of the license configuration.
        public let description: String?
        /// Amazon Resource Name (ARN) of the license configuration.
        public let licenseConfigurationArn: String?
        /// Unique ID for the license configuration.
        public let licenseConfigurationId: String?
        /// Number of available licenses.
        public let licenseCount: Int64?
        /// Sets the number of available licenses as a hard limit.
        public let licenseCountHardLimit: Bool?
        /// Dimension on which the licenses are counted.
        public let licenseCountingType: LicenseCountingType?
        /// License rules.
        public let licenseRules: [String]?
        /// Summaries of the managed resources.
        public let managedResourceSummaryList: [ManagedResourceSummary]?
        /// Name of the license configuration.
        public let name: String?
        /// Account ID of the owner of the license configuration.
        public let ownerAccountId: String?
        /// Product information.
        public let productInformationList: [ProductInformation]?
        /// License configuration status.
        public let status: String?
        /// Tags for the license configuration.
        public let tags: [Tag]?

        public init(automatedDiscoveryInformation: AutomatedDiscoveryInformation? = nil, consumedLicenses: Int64? = nil, consumedLicenseSummaryList: [ConsumedLicenseSummary]? = nil, description: String? = nil, licenseConfigurationArn: String? = nil, licenseConfigurationId: String? = nil, licenseCount: Int64? = nil, licenseCountHardLimit: Bool? = nil, licenseCountingType: LicenseCountingType? = nil, licenseRules: [String]? = nil, managedResourceSummaryList: [ManagedResourceSummary]? = nil, name: String? = nil, ownerAccountId: String? = nil, productInformationList: [ProductInformation]? = nil, status: String? = nil, tags: [Tag]? = nil) {
            self.automatedDiscoveryInformation = automatedDiscoveryInformation
            self.consumedLicenses = consumedLicenses
            self.consumedLicenseSummaryList = consumedLicenseSummaryList
            self.description = description
            self.licenseConfigurationArn = licenseConfigurationArn
            self.licenseConfigurationId = licenseConfigurationId
            self.licenseCount = licenseCount
            self.licenseCountHardLimit = licenseCountHardLimit
            self.licenseCountingType = licenseCountingType
            self.licenseRules = licenseRules
            self.managedResourceSummaryList = managedResourceSummaryList
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.productInformationList = productInformationList
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case automatedDiscoveryInformation = "AutomatedDiscoveryInformation"
            case consumedLicenses = "ConsumedLicenses"
            case consumedLicenseSummaryList = "ConsumedLicenseSummaryList"
            case description = "Description"
            case licenseConfigurationArn = "LicenseConfigurationArn"
            case licenseConfigurationId = "LicenseConfigurationId"
            case licenseCount = "LicenseCount"
            case licenseCountHardLimit = "LicenseCountHardLimit"
            case licenseCountingType = "LicenseCountingType"
            case licenseRules = "LicenseRules"
            case managedResourceSummaryList = "ManagedResourceSummaryList"
            case name = "Name"
            case ownerAccountId = "OwnerAccountId"
            case productInformationList = "ProductInformationList"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct GetServiceSettingsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetServiceSettingsResponse: AWSDecodableShape {
        /// Indicates whether cross-account discovery has been enabled.
        public let enableCrossAccountsDiscovery: Bool?
        /// Amazon Resource Name (ARN) of the AWS resource share. The License Manager master account will provide member accounts with access to this share.
        public let licenseManagerResourceShareArn: String?
        /// Indicates whether AWS Organizations has been integrated with License Manager for cross-account discovery.
        public let organizationConfiguration: OrganizationConfiguration?
        /// Regional S3 bucket path for storing reports, license trail event data, discovery data, and so on.
        public let s3BucketArn: String?
        /// SNS topic configured to receive notifications from License Manager.
        public let snsTopicArn: String?

        public init(enableCrossAccountsDiscovery: Bool? = nil, licenseManagerResourceShareArn: String? = nil, organizationConfiguration: OrganizationConfiguration? = nil, s3BucketArn: String? = nil, snsTopicArn: String? = nil) {
            self.enableCrossAccountsDiscovery = enableCrossAccountsDiscovery
            self.licenseManagerResourceShareArn = licenseManagerResourceShareArn
            self.organizationConfiguration = organizationConfiguration
            self.s3BucketArn = s3BucketArn
            self.snsTopicArn = snsTopicArn
        }

        private enum CodingKeys: String, CodingKey {
            case enableCrossAccountsDiscovery = "EnableCrossAccountsDiscovery"
            case licenseManagerResourceShareArn = "LicenseManagerResourceShareArn"
            case organizationConfiguration = "OrganizationConfiguration"
            case s3BucketArn = "S3BucketArn"
            case snsTopicArn = "SnsTopicArn"
        }
    }

    public struct InventoryFilter: AWSEncodableShape {
        /// Condition of the filter.
        public let condition: InventoryFilterCondition
        /// Name of the filter.
        public let name: String
        /// Value of the filter.
        public let value: String?

        public init(condition: InventoryFilterCondition, name: String, value: String? = nil) {
            self.condition = condition
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case name = "Name"
            case value = "Value"
        }
    }

    public struct LicenseConfiguration: AWSDecodableShape {
        /// Automated discovery information.
        public let automatedDiscoveryInformation: AutomatedDiscoveryInformation?
        /// Number of licenses consumed.
        public let consumedLicenses: Int64?
        /// Summaries for licenses consumed by various resources.
        public let consumedLicenseSummaryList: [ConsumedLicenseSummary]?
        /// Description of the license configuration.
        public let description: String?
        /// Amazon Resource Name (ARN) of the license configuration.
        public let licenseConfigurationArn: String?
        /// Unique ID of the license configuration.
        public let licenseConfigurationId: String?
        /// Number of licenses managed by the license configuration.
        public let licenseCount: Int64?
        /// Number of available licenses as a hard limit.
        public let licenseCountHardLimit: Bool?
        /// Dimension to use to track the license inventory.
        public let licenseCountingType: LicenseCountingType?
        /// License rules.
        public let licenseRules: [String]?
        /// Summaries for managed resources.
        public let managedResourceSummaryList: [ManagedResourceSummary]?
        /// Name of the license configuration.
        public let name: String?
        /// Account ID of the license configuration's owner.
        public let ownerAccountId: String?
        /// Product information.
        public let productInformationList: [ProductInformation]?
        /// Status of the license configuration.
        public let status: String?

        public init(automatedDiscoveryInformation: AutomatedDiscoveryInformation? = nil, consumedLicenses: Int64? = nil, consumedLicenseSummaryList: [ConsumedLicenseSummary]? = nil, description: String? = nil, licenseConfigurationArn: String? = nil, licenseConfigurationId: String? = nil, licenseCount: Int64? = nil, licenseCountHardLimit: Bool? = nil, licenseCountingType: LicenseCountingType? = nil, licenseRules: [String]? = nil, managedResourceSummaryList: [ManagedResourceSummary]? = nil, name: String? = nil, ownerAccountId: String? = nil, productInformationList: [ProductInformation]? = nil, status: String? = nil) {
            self.automatedDiscoveryInformation = automatedDiscoveryInformation
            self.consumedLicenses = consumedLicenses
            self.consumedLicenseSummaryList = consumedLicenseSummaryList
            self.description = description
            self.licenseConfigurationArn = licenseConfigurationArn
            self.licenseConfigurationId = licenseConfigurationId
            self.licenseCount = licenseCount
            self.licenseCountHardLimit = licenseCountHardLimit
            self.licenseCountingType = licenseCountingType
            self.licenseRules = licenseRules
            self.managedResourceSummaryList = managedResourceSummaryList
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.productInformationList = productInformationList
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case automatedDiscoveryInformation = "AutomatedDiscoveryInformation"
            case consumedLicenses = "ConsumedLicenses"
            case consumedLicenseSummaryList = "ConsumedLicenseSummaryList"
            case description = "Description"
            case licenseConfigurationArn = "LicenseConfigurationArn"
            case licenseConfigurationId = "LicenseConfigurationId"
            case licenseCount = "LicenseCount"
            case licenseCountHardLimit = "LicenseCountHardLimit"
            case licenseCountingType = "LicenseCountingType"
            case licenseRules = "LicenseRules"
            case managedResourceSummaryList = "ManagedResourceSummaryList"
            case name = "Name"
            case ownerAccountId = "OwnerAccountId"
            case productInformationList = "ProductInformationList"
            case status = "Status"
        }
    }

    public struct LicenseConfigurationAssociation: AWSDecodableShape {
        /// Scope of AMI associations.
        public let amiAssociationScope: String?
        /// Time when the license configuration was associated with the resource.
        public let associationTime: Date?
        /// Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String?
        /// ID of the AWS account that owns the resource consuming licenses.
        public let resourceOwnerId: String?
        /// Type of server resource.
        public let resourceType: ResourceType?

        public init(amiAssociationScope: String? = nil, associationTime: Date? = nil, resourceArn: String? = nil, resourceOwnerId: String? = nil, resourceType: ResourceType? = nil) {
            self.amiAssociationScope = amiAssociationScope
            self.associationTime = associationTime
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case amiAssociationScope = "AmiAssociationScope"
            case associationTime = "AssociationTime"
            case resourceArn = "ResourceArn"
            case resourceOwnerId = "ResourceOwnerId"
            case resourceType = "ResourceType"
        }
    }

    public struct LicenseConfigurationUsage: AWSDecodableShape {
        /// Time when the license configuration was initially associated with the resource.
        public let associationTime: Date?
        /// Number of licenses consumed by the resource.
        public let consumedLicenses: Int64?
        /// Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String?
        /// ID of the account that owns the resource.
        public let resourceOwnerId: String?
        /// Status of the resource.
        public let resourceStatus: String?
        /// Type of resource.
        public let resourceType: ResourceType?

        public init(associationTime: Date? = nil, consumedLicenses: Int64? = nil, resourceArn: String? = nil, resourceOwnerId: String? = nil, resourceStatus: String? = nil, resourceType: ResourceType? = nil) {
            self.associationTime = associationTime
            self.consumedLicenses = consumedLicenses
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceStatus = resourceStatus
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case associationTime = "AssociationTime"
            case consumedLicenses = "ConsumedLicenses"
            case resourceArn = "ResourceArn"
            case resourceOwnerId = "ResourceOwnerId"
            case resourceStatus = "ResourceStatus"
            case resourceType = "ResourceType"
        }
    }

    public struct LicenseOperationFailure: AWSDecodableShape {
        /// Error message.
        public let errorMessage: String?
        /// Failure time.
        public let failureTime: Date?
        /// Reserved.
        public let metadataList: [Metadata]?
        /// Name of the operation.
        public let operationName: String?
        /// The requester is "License Manager Automated Discovery".
        public let operationRequestedBy: String?
        /// Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String?
        /// ID of the AWS account that owns the resource.
        public let resourceOwnerId: String?
        /// Resource type.
        public let resourceType: ResourceType?

        public init(errorMessage: String? = nil, failureTime: Date? = nil, metadataList: [Metadata]? = nil, operationName: String? = nil, operationRequestedBy: String? = nil, resourceArn: String? = nil, resourceOwnerId: String? = nil, resourceType: ResourceType? = nil) {
            self.errorMessage = errorMessage
            self.failureTime = failureTime
            self.metadataList = metadataList
            self.operationName = operationName
            self.operationRequestedBy = operationRequestedBy
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case failureTime = "FailureTime"
            case metadataList = "MetadataList"
            case operationName = "OperationName"
            case operationRequestedBy = "OperationRequestedBy"
            case resourceArn = "ResourceArn"
            case resourceOwnerId = "ResourceOwnerId"
            case resourceType = "ResourceType"
        }
    }

    public struct LicenseSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Scope of AMI associations.
        public let amiAssociationScope: String?
        /// Amazon Resource Name (ARN) of the license configuration.
        public let licenseConfigurationArn: String

        public init(amiAssociationScope: String? = nil, licenseConfigurationArn: String) {
            self.amiAssociationScope = amiAssociationScope
            self.licenseConfigurationArn = licenseConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case amiAssociationScope = "AmiAssociationScope"
            case licenseConfigurationArn = "LicenseConfigurationArn"
        }
    }

    public struct ListAssociationsForLicenseConfigurationRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of a license configuration.
        public let licenseConfigurationArn: String
        /// Maximum number of results to return in a single call.
        public let maxResults: Int?
        /// Token for the next set of results.
        public let nextToken: String?

        public init(licenseConfigurationArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.licenseConfigurationArn = licenseConfigurationArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case licenseConfigurationArn = "LicenseConfigurationArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListAssociationsForLicenseConfigurationResponse: AWSDecodableShape {
        /// Information about the associations for the license configuration.
        public let licenseConfigurationAssociations: [LicenseConfigurationAssociation]?
        /// Token for the next set of results.
        public let nextToken: String?

        public init(licenseConfigurationAssociations: [LicenseConfigurationAssociation]? = nil, nextToken: String? = nil) {
            self.licenseConfigurationAssociations = licenseConfigurationAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case licenseConfigurationAssociations = "LicenseConfigurationAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct ListFailuresForLicenseConfigurationOperationsRequest: AWSEncodableShape {
        /// Amazon Resource Name of the license configuration.
        public let licenseConfigurationArn: String
        /// Maximum number of results to return in a single call.
        public let maxResults: Int?
        /// Token for the next set of results.
        public let nextToken: String?

        public init(licenseConfigurationArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.licenseConfigurationArn = licenseConfigurationArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case licenseConfigurationArn = "LicenseConfigurationArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListFailuresForLicenseConfigurationOperationsResponse: AWSDecodableShape {
        /// License configuration operations that failed.
        public let licenseOperationFailureList: [LicenseOperationFailure]?
        /// Token for the next set of results.
        public let nextToken: String?

        public init(licenseOperationFailureList: [LicenseOperationFailure]? = nil, nextToken: String? = nil) {
            self.licenseOperationFailureList = licenseOperationFailureList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case licenseOperationFailureList = "LicenseOperationFailureList"
            case nextToken = "NextToken"
        }
    }

    public struct ListLicenseConfigurationsRequest: AWSEncodableShape {
        /// Filters to scope the results. The following filters and logical operators are supported:    licenseCountingType - The dimension on which licenses are counted. Possible values are vCPU | Instance | Core | Socket. Logical operators are EQUALS | NOT_EQUALS.    enforceLicenseCount - A Boolean value that indicates whether hard license enforcement is used. Logical operators are EQUALS | NOT_EQUALS.    usagelimitExceeded - A Boolean value that indicates whether the available licenses have been exceeded. Logical operators are EQUALS | NOT_EQUALS.
        public let filters: [Filter]?
        /// Amazon Resource Names (ARN) of the license configurations.
        public let licenseConfigurationArns: [String]?
        /// Maximum number of results to return in a single call.
        public let maxResults: Int?
        /// Token for the next set of results.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, licenseConfigurationArns: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.licenseConfigurationArns = licenseConfigurationArns
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case licenseConfigurationArns = "LicenseConfigurationArns"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListLicenseConfigurationsResponse: AWSDecodableShape {
        /// Information about the license configurations.
        public let licenseConfigurations: [LicenseConfiguration]?
        /// Token for the next set of results.
        public let nextToken: String?

        public init(licenseConfigurations: [LicenseConfiguration]? = nil, nextToken: String? = nil) {
            self.licenseConfigurations = licenseConfigurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case licenseConfigurations = "LicenseConfigurations"
            case nextToken = "NextToken"
        }
    }

    public struct ListLicenseSpecificationsForResourceRequest: AWSEncodableShape {
        /// Maximum number of results to return in a single call.
        public let maxResults: Int?
        /// Token for the next set of results.
        public let nextToken: String?
        /// Amazon Resource Name (ARN) of a resource that has an associated license configuration.
        public let resourceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListLicenseSpecificationsForResourceResponse: AWSDecodableShape {
        /// License configurations associated with a resource.
        public let licenseSpecifications: [LicenseSpecification]?
        /// Token for the next set of results.
        public let nextToken: String?

        public init(licenseSpecifications: [LicenseSpecification]? = nil, nextToken: String? = nil) {
            self.licenseSpecifications = licenseSpecifications
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case licenseSpecifications = "LicenseSpecifications"
            case nextToken = "NextToken"
        }
    }

    public struct ListResourceInventoryRequest: AWSEncodableShape {
        /// Filters to scope the results. The following filters and logical operators are supported:    account_id - The ID of the AWS account that owns the resource. Logical operators are EQUALS | NOT_EQUALS.    application_name - The name of the application. Logical operators are EQUALS | BEGINS_WITH.    license_included - The type of license included. Logical operators are EQUALS | NOT_EQUALS. Possible values are sql-server-enterprise | sql-server-standard | sql-server-web | windows-server-datacenter.    platform - The platform of the resource. Logical operators are EQUALS | BEGINS_WITH.    resource_id - The ID of the resource. Logical operators are EQUALS | NOT_EQUALS.
        public let filters: [InventoryFilter]?
        /// Maximum number of results to return in a single call.
        public let maxResults: Int?
        /// Token for the next set of results.
        public let nextToken: String?

        public init(filters: [InventoryFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListResourceInventoryResponse: AWSDecodableShape {
        /// Token for the next set of results.
        public let nextToken: String?
        /// Information about the resources.
        public let resourceInventoryList: [ResourceInventory]?

        public init(nextToken: String? = nil, resourceInventoryList: [ResourceInventory]? = nil) {
            self.nextToken = nextToken
            self.resourceInventoryList = resourceInventoryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourceInventoryList = "ResourceInventoryList"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the license configuration.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Information about the tags.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListUsageForLicenseConfigurationRequest: AWSEncodableShape {
        /// Filters to scope the results. The following filters and logical operators are supported:    resourceArn - The ARN of the license configuration resource. Logical operators are EQUALS | NOT_EQUALS.    resourceType - The resource type (EC2_INSTANCE | EC2_HOST | EC2_AMI | SYSTEMS_MANAGER_MANAGED_INSTANCE). Logical operators are EQUALS | NOT_EQUALS.    resourceAccount - The ID of the account that owns the resource. Logical operators are EQUALS | NOT_EQUALS.
        public let filters: [Filter]?
        /// Amazon Resource Name (ARN) of the license configuration.
        public let licenseConfigurationArn: String
        /// Maximum number of results to return in a single call.
        public let maxResults: Int?
        /// Token for the next set of results.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, licenseConfigurationArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.licenseConfigurationArn = licenseConfigurationArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case licenseConfigurationArn = "LicenseConfigurationArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListUsageForLicenseConfigurationResponse: AWSDecodableShape {
        /// Information about the license configurations.
        public let licenseConfigurationUsageList: [LicenseConfigurationUsage]?
        /// Token for the next set of results.
        public let nextToken: String?

        public init(licenseConfigurationUsageList: [LicenseConfigurationUsage]? = nil, nextToken: String? = nil) {
            self.licenseConfigurationUsageList = licenseConfigurationUsageList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case licenseConfigurationUsageList = "LicenseConfigurationUsageList"
            case nextToken = "NextToken"
        }
    }

    public struct ManagedResourceSummary: AWSDecodableShape {
        /// Number of resources associated with licenses.
        public let associationCount: Int64?
        /// Type of resource associated with a license.
        public let resourceType: ResourceType?

        public init(associationCount: Int64? = nil, resourceType: ResourceType? = nil) {
            self.associationCount = associationCount
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case associationCount = "AssociationCount"
            case resourceType = "ResourceType"
        }
    }

    public struct Metadata: AWSDecodableShape {
        /// Reserved.
        public let name: String?
        /// Reserved.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct OrganizationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables AWS Organization integration.
        public let enableIntegration: Bool

        public init(enableIntegration: Bool) {
            self.enableIntegration = enableIntegration
        }

        private enum CodingKeys: String, CodingKey {
            case enableIntegration = "EnableIntegration"
        }
    }

    public struct ProductInformation: AWSEncodableShape & AWSDecodableShape {
        /// Product information filters. The following filters and logical operators are supported when the resource type is SSM_MANAGED:    Application Name - The name of the application. Logical operator is EQUALS.    Application Publisher - The publisher of the application. Logical operator is EQUALS.    Application Version - The version of the application. Logical operator is EQUALS.    Platform Name - The name of the platform. Logical operator is EQUALS.    Platform Type - The platform type. Logical operator is EQUALS.    License Included - The type of license included. Logical operators are EQUALS and NOT_EQUALS. Possible values are: sql-server-enterprise | sql-server-standard | sql-server-web | windows-server-datacenter.   The following filters and logical operators are supported when the resource type is RDS:    Engine Edition - The edition of the database engine. Logical operator is EQUALS. Possible values are: oracle-ee | oracle-se | oracle-se1 | oracle-se2.    License Pack - The license pack. Logical operator is EQUALS. Possible values are: data guard | diagnostic pack sqlt | tuning pack sqlt | ols | olap.
        public let productInformationFilterList: [ProductInformationFilter]
        /// Resource type. The possible values are SSM_MANAGED | RDS.
        public let resourceType: String

        public init(productInformationFilterList: [ProductInformationFilter], resourceType: String) {
            self.productInformationFilterList = productInformationFilterList
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case productInformationFilterList = "ProductInformationFilterList"
            case resourceType = "ResourceType"
        }
    }

    public struct ProductInformationFilter: AWSEncodableShape & AWSDecodableShape {
        /// Logical operator.
        public let productInformationFilterComparator: String
        /// Filter name.
        public let productInformationFilterName: String
        /// Filter value.
        public let productInformationFilterValue: [String]

        public init(productInformationFilterComparator: String, productInformationFilterName: String, productInformationFilterValue: [String]) {
            self.productInformationFilterComparator = productInformationFilterComparator
            self.productInformationFilterName = productInformationFilterName
            self.productInformationFilterValue = productInformationFilterValue
        }

        private enum CodingKeys: String, CodingKey {
            case productInformationFilterComparator = "ProductInformationFilterComparator"
            case productInformationFilterName = "ProductInformationFilterName"
            case productInformationFilterValue = "ProductInformationFilterValue"
        }
    }

    public struct ResourceInventory: AWSDecodableShape {
        /// Platform of the resource.
        public let platform: String?
        /// Platform version of the resource in the inventory.
        public let platformVersion: String?
        /// Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String?
        /// ID of the resource.
        public let resourceId: String?
        /// ID of the account that owns the resource.
        public let resourceOwningAccountId: String?
        /// Type of resource.
        public let resourceType: ResourceType?

        public init(platform: String? = nil, platformVersion: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, resourceOwningAccountId: String? = nil, resourceType: ResourceType? = nil) {
            self.platform = platform
            self.platformVersion = platformVersion
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceOwningAccountId = resourceOwningAccountId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case platform = "Platform"
            case platformVersion = "PlatformVersion"
            case resourceArn = "ResourceArn"
            case resourceId = "ResourceId"
            case resourceOwningAccountId = "ResourceOwningAccountId"
            case resourceType = "ResourceType"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// Tag key.
        public let key: String?
        /// Tag value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the license configuration.
        public let resourceArn: String
        /// One or more tags.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the license configuration.
        public let resourceArn: String
        /// Keys identifying the tags to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLicenseConfigurationRequest: AWSEncodableShape {
        /// New description of the license configuration.
        public let description: String?
        /// Amazon Resource Name (ARN) of the license configuration.
        public let licenseConfigurationArn: String
        /// New status of the license configuration.
        public let licenseConfigurationStatus: LicenseConfigurationStatus?
        /// New number of licenses managed by the license configuration.
        public let licenseCount: Int64?
        /// New hard limit of the number of available licenses.
        public let licenseCountHardLimit: Bool?
        /// New license rule. The only rule that you can add after you create a license configuration is licenseAffinityToHost.
        public let licenseRules: [String]?
        /// New name of the license configuration.
        public let name: String?
        /// New product information.
        public let productInformationList: [ProductInformation]?

        public init(description: String? = nil, licenseConfigurationArn: String, licenseConfigurationStatus: LicenseConfigurationStatus? = nil, licenseCount: Int64? = nil, licenseCountHardLimit: Bool? = nil, licenseRules: [String]? = nil, name: String? = nil, productInformationList: [ProductInformation]? = nil) {
            self.description = description
            self.licenseConfigurationArn = licenseConfigurationArn
            self.licenseConfigurationStatus = licenseConfigurationStatus
            self.licenseCount = licenseCount
            self.licenseCountHardLimit = licenseCountHardLimit
            self.licenseRules = licenseRules
            self.name = name
            self.productInformationList = productInformationList
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case licenseConfigurationArn = "LicenseConfigurationArn"
            case licenseConfigurationStatus = "LicenseConfigurationStatus"
            case licenseCount = "LicenseCount"
            case licenseCountHardLimit = "LicenseCountHardLimit"
            case licenseRules = "LicenseRules"
            case name = "Name"
            case productInformationList = "ProductInformationList"
        }
    }

    public struct UpdateLicenseConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLicenseSpecificationsForResourceRequest: AWSEncodableShape {
        /// ARNs of the license configurations to add.
        public let addLicenseSpecifications: [LicenseSpecification]?
        /// ARNs of the license configurations to remove.
        public let removeLicenseSpecifications: [LicenseSpecification]?
        /// Amazon Resource Name (ARN) of the AWS resource.
        public let resourceArn: String

        public init(addLicenseSpecifications: [LicenseSpecification]? = nil, removeLicenseSpecifications: [LicenseSpecification]? = nil, resourceArn: String) {
            self.addLicenseSpecifications = addLicenseSpecifications
            self.removeLicenseSpecifications = removeLicenseSpecifications
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case addLicenseSpecifications = "AddLicenseSpecifications"
            case removeLicenseSpecifications = "RemoveLicenseSpecifications"
            case resourceArn = "ResourceArn"
        }
    }

    public struct UpdateLicenseSpecificationsForResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateServiceSettingsRequest: AWSEncodableShape {
        /// Activates cross-account discovery.
        public let enableCrossAccountsDiscovery: Bool?
        /// Enables integration with AWS Organizations for cross-account discovery.
        public let organizationConfiguration: OrganizationConfiguration?
        /// Amazon Resource Name (ARN) of the Amazon S3 bucket where the License Manager information is stored.
        public let s3BucketArn: String?
        /// Amazon Resource Name (ARN) of the Amazon SNS topic used for License Manager alerts.
        public let snsTopicArn: String?

        public init(enableCrossAccountsDiscovery: Bool? = nil, organizationConfiguration: OrganizationConfiguration? = nil, s3BucketArn: String? = nil, snsTopicArn: String? = nil) {
            self.enableCrossAccountsDiscovery = enableCrossAccountsDiscovery
            self.organizationConfiguration = organizationConfiguration
            self.s3BucketArn = s3BucketArn
            self.snsTopicArn = snsTopicArn
        }

        private enum CodingKeys: String, CodingKey {
            case enableCrossAccountsDiscovery = "EnableCrossAccountsDiscovery"
            case organizationConfiguration = "OrganizationConfiguration"
            case s3BucketArn = "S3BucketArn"
            case snsTopicArn = "SnsTopicArn"
        }
    }

    public struct UpdateServiceSettingsResponse: AWSDecodableShape {
        public init() {}
    }
}
