//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS EntityResolution service.
///
/// Welcome to the Entity Resolution API Reference. Entity Resolution is an Amazon Web Services service that provides pre-configured entity resolution capabilities that enable developers and analysts at advertising and marketing companies to build an accurate and complete view of their consumers. With Entity Resolution, you can match source records containing consumer identifiers, such as name, email address, and phone number. This is true even when these records have incomplete or conflicting identifiers. For example, Entity Resolution can effectively match a source record from a customer relationship management (CRM) system with a source record from a marketing system containing campaign information. To learn more about Entity Resolution concepts, procedures, and best practices, see the Entity Resolution User Guide.
public struct EntityResolution: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the EntityResolution client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "EntityResolution",
            serviceIdentifier: "entityresolution",
            serviceProtocol: .restjson,
            apiVersion: "2018-05-10",
            endpoint: endpoint,
            errorType: EntityResolutionErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Adds a policy statement object. To retrieve a list of existing policy statements, use the GetPolicy API.
    @Sendable
    @inlinable
    public func addPolicyStatement(_ input: AddPolicyStatementInput, logger: Logger = AWSClient.loggingDisabled) async throws -> AddPolicyStatementOutput {
        try await self.client.execute(
            operation: "AddPolicyStatement", 
            path: "/policies/{arn}/{statementId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds a policy statement object. To retrieve a list of existing policy statements, use the GetPolicy API.
    ///
    /// Parameters:
    ///   - action: The action that the principal can use on the resource.  For example, entityresolution:GetIdMappingJob, entityresolution:GetMatchingJob.
    ///   - arn: The Amazon Resource Name (ARN) of the resource that will be accessed by the principal.
    ///   - condition: A set of condition keys that you can use in key policies.
    ///   - effect: Determines whether the permissions specified in the policy are to be allowed (Allow) or denied (Deny).  If you set the value of the effect parameter to Deny for the AddPolicyStatement operation, you must also set the value of the effect parameter in the policy to Deny for the PutPolicy operation.
    ///   - principal: The Amazon Web Services service or Amazon Web Services account that can access the resource defined as ARN.
    ///   - statementId: A statement identifier that differentiates the statement from others in the same policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func addPolicyStatement(
        action: [String],
        arn: String,
        condition: String? = nil,
        effect: StatementEffect,
        principal: [String],
        statementId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AddPolicyStatementOutput {
        let input = AddPolicyStatementInput(
            action: action, 
            arn: arn, 
            condition: condition, 
            effect: effect, 
            principal: principal, 
            statementId: statementId
        )
        return try await self.addPolicyStatement(input, logger: logger)
    }

    /// Deletes multiple unique IDs in a matching workflow.
    @Sendable
    @inlinable
    public func batchDeleteUniqueId(_ input: BatchDeleteUniqueIdInput, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteUniqueIdOutput {
        try await self.client.execute(
            operation: "BatchDeleteUniqueId", 
            path: "/matchingworkflows/{workflowName}/uniqueids", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes multiple unique IDs in a matching workflow.
    ///
    /// Parameters:
    ///   - inputSource: The input source for the batch delete unique ID operation.
    ///   - uniqueIds: The unique IDs to delete.
    ///   - workflowName: The name of the workflow.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteUniqueId(
        inputSource: String? = nil,
        uniqueIds: [String],
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteUniqueIdOutput {
        let input = BatchDeleteUniqueIdInput(
            inputSource: inputSource, 
            uniqueIds: uniqueIds, 
            workflowName: workflowName
        )
        return try await self.batchDeleteUniqueId(input, logger: logger)
    }

    /// Creates an IdMappingWorkflow object which stores the configuration of the data processing job to be run. Each IdMappingWorkflow must have a unique workflow name. To modify an existing workflow, use the UpdateIdMappingWorkflow API.
    @Sendable
    @inlinable
    public func createIdMappingWorkflow(_ input: CreateIdMappingWorkflowInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateIdMappingWorkflowOutput {
        try await self.client.execute(
            operation: "CreateIdMappingWorkflow", 
            path: "/idmappingworkflows", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an IdMappingWorkflow object which stores the configuration of the data processing job to be run. Each IdMappingWorkflow must have a unique workflow name. To modify an existing workflow, use the UpdateIdMappingWorkflow API.
    ///
    /// Parameters:
    ///   - description: A description of the workflow.
    ///   - idMappingTechniques: An object which defines the ID mapping technique and any additional configurations.
    ///   - inputSourceConfig: A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    ///   - outputSourceConfig: A list of IdMappingWorkflowOutputSource objects, each of which contains fields OutputS3Path and Output.
    ///   - roleArn: The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    ///   - tags: The tags used to organize, track, or control access for this resource.
    ///   - workflowName: The name of the workflow. There can't be multiple IdMappingWorkflows with the same name.
    ///   - logger: Logger use during operation
    @inlinable
    public func createIdMappingWorkflow(
        description: String? = nil,
        idMappingTechniques: IdMappingTechniques,
        inputSourceConfig: [IdMappingWorkflowInputSource],
        outputSourceConfig: [IdMappingWorkflowOutputSource]? = nil,
        roleArn: String? = nil,
        tags: [String: String]? = nil,
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateIdMappingWorkflowOutput {
        let input = CreateIdMappingWorkflowInput(
            description: description, 
            idMappingTechniques: idMappingTechniques, 
            inputSourceConfig: inputSourceConfig, 
            outputSourceConfig: outputSourceConfig, 
            roleArn: roleArn, 
            tags: tags, 
            workflowName: workflowName
        )
        return try await self.createIdMappingWorkflow(input, logger: logger)
    }

    /// Creates an ID namespace object which will help customers provide metadata explaining their dataset and how to use it. Each ID namespace must have a unique name. To modify an existing ID namespace, use the UpdateIdNamespace API.
    @Sendable
    @inlinable
    public func createIdNamespace(_ input: CreateIdNamespaceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateIdNamespaceOutput {
        try await self.client.execute(
            operation: "CreateIdNamespace", 
            path: "/idnamespaces", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an ID namespace object which will help customers provide metadata explaining their dataset and how to use it. Each ID namespace must have a unique name. To modify an existing ID namespace, use the UpdateIdNamespace API.
    ///
    /// Parameters:
    ///   - description: The description of the ID namespace.
    ///   - idMappingWorkflowProperties: Determines the properties of IdMappingWorflow where this IdNamespace can be used as a Source or a Target.
    ///   - idNamespaceName: The name of the ID namespace.
    ///   - inputSourceConfig: A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    ///   - roleArn: The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of the workflow run.
    ///   - tags: The tags used to organize, track, or control access for this resource.
    ///   - type: The type of ID namespace. There are two types: SOURCE and TARGET.  The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow.  The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
    ///   - logger: Logger use during operation
    @inlinable
    public func createIdNamespace(
        description: String? = nil,
        idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceName: String,
        inputSourceConfig: [IdNamespaceInputSource]? = nil,
        roleArn: String? = nil,
        tags: [String: String]? = nil,
        type: IdNamespaceType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateIdNamespaceOutput {
        let input = CreateIdNamespaceInput(
            description: description, 
            idMappingWorkflowProperties: idMappingWorkflowProperties, 
            idNamespaceName: idNamespaceName, 
            inputSourceConfig: inputSourceConfig, 
            roleArn: roleArn, 
            tags: tags, 
            type: type
        )
        return try await self.createIdNamespace(input, logger: logger)
    }

    /// Creates a MatchingWorkflow object which stores the configuration of the data processing job to be run. It is important to note that there should not be a pre-existing MatchingWorkflow with the same name. To modify an existing workflow, utilize the UpdateMatchingWorkflow API.
    @Sendable
    @inlinable
    public func createMatchingWorkflow(_ input: CreateMatchingWorkflowInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMatchingWorkflowOutput {
        try await self.client.execute(
            operation: "CreateMatchingWorkflow", 
            path: "/matchingworkflows", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a MatchingWorkflow object which stores the configuration of the data processing job to be run. It is important to note that there should not be a pre-existing MatchingWorkflow with the same name. To modify an existing workflow, utilize the UpdateMatchingWorkflow API.
    ///
    /// Parameters:
    ///   - description: A description of the workflow.
    ///   - incrementalRunConfig: An object which defines an incremental run type and has only incrementalRunType as a field.
    ///   - inputSourceConfig: A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    ///   - outputSourceConfig: A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    ///   - resolutionTechniques: An object which defines the resolutionType and the ruleBasedProperties.
    ///   - roleArn: The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    ///   - tags: The tags used to organize, track, or control access for this resource.
    ///   - workflowName: The name of the workflow. There can't be multiple MatchingWorkflows with the same name.
    ///   - logger: Logger use during operation
    @inlinable
    public func createMatchingWorkflow(
        description: String? = nil,
        incrementalRunConfig: IncrementalRunConfig? = nil,
        inputSourceConfig: [InputSource],
        outputSourceConfig: [OutputSource],
        resolutionTechniques: ResolutionTechniques,
        roleArn: String,
        tags: [String: String]? = nil,
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMatchingWorkflowOutput {
        let input = CreateMatchingWorkflowInput(
            description: description, 
            incrementalRunConfig: incrementalRunConfig, 
            inputSourceConfig: inputSourceConfig, 
            outputSourceConfig: outputSourceConfig, 
            resolutionTechniques: resolutionTechniques, 
            roleArn: roleArn, 
            tags: tags, 
            workflowName: workflowName
        )
        return try await self.createMatchingWorkflow(input, logger: logger)
    }

    /// Creates a schema mapping, which defines the schema of the input customer records table. The SchemaMapping also provides Entity Resolution with some metadata about the table, such as the attribute types of the columns and which columns to match on.
    @Sendable
    @inlinable
    public func createSchemaMapping(_ input: CreateSchemaMappingInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSchemaMappingOutput {
        try await self.client.execute(
            operation: "CreateSchemaMapping", 
            path: "/schemas", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a schema mapping, which defines the schema of the input customer records table. The SchemaMapping also provides Entity Resolution with some metadata about the table, such as the attribute types of the columns and which columns to match on.
    ///
    /// Parameters:
    ///   - description: A description of the schema.
    ///   - mappedInputFields: A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    ///   - schemaName: The name of the schema. There can't be multiple SchemaMappings with the same name.
    ///   - tags: The tags used to organize, track, or control access for this resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSchemaMapping(
        description: String? = nil,
        mappedInputFields: [SchemaInputAttribute],
        schemaName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSchemaMappingOutput {
        let input = CreateSchemaMappingInput(
            description: description, 
            mappedInputFields: mappedInputFields, 
            schemaName: schemaName, 
            tags: tags
        )
        return try await self.createSchemaMapping(input, logger: logger)
    }

    /// Deletes the IdMappingWorkflow with a given name. This operation will succeed even if a workflow with the given name does not exist.
    @Sendable
    @inlinable
    public func deleteIdMappingWorkflow(_ input: DeleteIdMappingWorkflowInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteIdMappingWorkflowOutput {
        try await self.client.execute(
            operation: "DeleteIdMappingWorkflow", 
            path: "/idmappingworkflows/{workflowName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the IdMappingWorkflow with a given name. This operation will succeed even if a workflow with the given name does not exist.
    ///
    /// Parameters:
    ///   - workflowName: The name of the workflow to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteIdMappingWorkflow(
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteIdMappingWorkflowOutput {
        let input = DeleteIdMappingWorkflowInput(
            workflowName: workflowName
        )
        return try await self.deleteIdMappingWorkflow(input, logger: logger)
    }

    /// Deletes the IdNamespace with a given name.
    @Sendable
    @inlinable
    public func deleteIdNamespace(_ input: DeleteIdNamespaceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteIdNamespaceOutput {
        try await self.client.execute(
            operation: "DeleteIdNamespace", 
            path: "/idnamespaces/{idNamespaceName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the IdNamespace with a given name.
    ///
    /// Parameters:
    ///   - idNamespaceName: The name of the ID namespace.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteIdNamespace(
        idNamespaceName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteIdNamespaceOutput {
        let input = DeleteIdNamespaceInput(
            idNamespaceName: idNamespaceName
        )
        return try await self.deleteIdNamespace(input, logger: logger)
    }

    /// Deletes the MatchingWorkflow with a given name. This operation will succeed even if a workflow with the given name does not exist.
    @Sendable
    @inlinable
    public func deleteMatchingWorkflow(_ input: DeleteMatchingWorkflowInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMatchingWorkflowOutput {
        try await self.client.execute(
            operation: "DeleteMatchingWorkflow", 
            path: "/matchingworkflows/{workflowName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the MatchingWorkflow with a given name. This operation will succeed even if a workflow with the given name does not exist.
    ///
    /// Parameters:
    ///   - workflowName: The name of the workflow to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMatchingWorkflow(
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteMatchingWorkflowOutput {
        let input = DeleteMatchingWorkflowInput(
            workflowName: workflowName
        )
        return try await self.deleteMatchingWorkflow(input, logger: logger)
    }

    /// Deletes the policy statement.
    @Sendable
    @inlinable
    public func deletePolicyStatement(_ input: DeletePolicyStatementInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePolicyStatementOutput {
        try await self.client.execute(
            operation: "DeletePolicyStatement", 
            path: "/policies/{arn}/{statementId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the policy statement.
    ///
    /// Parameters:
    ///   - arn: The ARN of the resource for which the policy need to be deleted.
    ///   - statementId: A statement identifier that differentiates the statement from others in the same policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePolicyStatement(
        arn: String,
        statementId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePolicyStatementOutput {
        let input = DeletePolicyStatementInput(
            arn: arn, 
            statementId: statementId
        )
        return try await self.deletePolicyStatement(input, logger: logger)
    }

    /// Deletes the SchemaMapping with a given name. This operation will succeed even if a schema with the given name does not exist. This operation will fail if there is a MatchingWorkflow object that references the SchemaMapping in the workflow's InputSourceConfig.
    @Sendable
    @inlinable
    public func deleteSchemaMapping(_ input: DeleteSchemaMappingInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSchemaMappingOutput {
        try await self.client.execute(
            operation: "DeleteSchemaMapping", 
            path: "/schemas/{schemaName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the SchemaMapping with a given name. This operation will succeed even if a schema with the given name does not exist. This operation will fail if there is a MatchingWorkflow object that references the SchemaMapping in the workflow's InputSourceConfig.
    ///
    /// Parameters:
    ///   - schemaName: The name of the schema to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSchemaMapping(
        schemaName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSchemaMappingOutput {
        let input = DeleteSchemaMappingInput(
            schemaName: schemaName
        )
        return try await self.deleteSchemaMapping(input, logger: logger)
    }

    /// Gets the status, metrics, and errors (if there are any) that are associated with a job.
    @Sendable
    @inlinable
    public func getIdMappingJob(_ input: GetIdMappingJobInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIdMappingJobOutput {
        try await self.client.execute(
            operation: "GetIdMappingJob", 
            path: "/idmappingworkflows/{workflowName}/jobs/{jobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the status, metrics, and errors (if there are any) that are associated with a job.
    ///
    /// Parameters:
    ///   - jobId: The ID of the job.
    ///   - workflowName: The name of the workflow.
    ///   - logger: Logger use during operation
    @inlinable
    public func getIdMappingJob(
        jobId: String,
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetIdMappingJobOutput {
        let input = GetIdMappingJobInput(
            jobId: jobId, 
            workflowName: workflowName
        )
        return try await self.getIdMappingJob(input, logger: logger)
    }

    /// Returns the IdMappingWorkflow with a given name, if it exists.
    @Sendable
    @inlinable
    public func getIdMappingWorkflow(_ input: GetIdMappingWorkflowInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIdMappingWorkflowOutput {
        try await self.client.execute(
            operation: "GetIdMappingWorkflow", 
            path: "/idmappingworkflows/{workflowName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the IdMappingWorkflow with a given name, if it exists.
    ///
    /// Parameters:
    ///   - workflowName: The name of the workflow.
    ///   - logger: Logger use during operation
    @inlinable
    public func getIdMappingWorkflow(
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetIdMappingWorkflowOutput {
        let input = GetIdMappingWorkflowInput(
            workflowName: workflowName
        )
        return try await self.getIdMappingWorkflow(input, logger: logger)
    }

    /// Returns the IdNamespace with a given name, if it exists.
    @Sendable
    @inlinable
    public func getIdNamespace(_ input: GetIdNamespaceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIdNamespaceOutput {
        try await self.client.execute(
            operation: "GetIdNamespace", 
            path: "/idnamespaces/{idNamespaceName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the IdNamespace with a given name, if it exists.
    ///
    /// Parameters:
    ///   - idNamespaceName: The name of the ID namespace.
    ///   - logger: Logger use during operation
    @inlinable
    public func getIdNamespace(
        idNamespaceName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetIdNamespaceOutput {
        let input = GetIdNamespaceInput(
            idNamespaceName: idNamespaceName
        )
        return try await self.getIdNamespace(input, logger: logger)
    }

    /// Returns the corresponding Match ID of a customer record if the record has been processed in a rule-based matching workflow or ML matching workflow. You can call this API as a dry run of an incremental load on the rule-based matching workflow.
    @Sendable
    @inlinable
    public func getMatchId(_ input: GetMatchIdInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMatchIdOutput {
        try await self.client.execute(
            operation: "GetMatchId", 
            path: "/matchingworkflows/{workflowName}/matches", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the corresponding Match ID of a customer record if the record has been processed in a rule-based matching workflow or ML matching workflow. You can call this API as a dry run of an incremental load on the rule-based matching workflow.
    ///
    /// Parameters:
    ///   - applyNormalization: Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
    ///   - record: The record to fetch the Match ID for.
    ///   - workflowName: The name of the workflow.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMatchId(
        applyNormalization: Bool? = nil,
        record: [String: String],
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMatchIdOutput {
        let input = GetMatchIdInput(
            applyNormalization: applyNormalization, 
            record: record, 
            workflowName: workflowName
        )
        return try await self.getMatchId(input, logger: logger)
    }

    /// Gets the status, metrics, and errors (if there are any) that are associated with a job.
    @Sendable
    @inlinable
    public func getMatchingJob(_ input: GetMatchingJobInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMatchingJobOutput {
        try await self.client.execute(
            operation: "GetMatchingJob", 
            path: "/matchingworkflows/{workflowName}/jobs/{jobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the status, metrics, and errors (if there are any) that are associated with a job.
    ///
    /// Parameters:
    ///   - jobId: The ID of the job.
    ///   - workflowName: The name of the workflow.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMatchingJob(
        jobId: String,
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMatchingJobOutput {
        let input = GetMatchingJobInput(
            jobId: jobId, 
            workflowName: workflowName
        )
        return try await self.getMatchingJob(input, logger: logger)
    }

    /// Returns the MatchingWorkflow with a given name, if it exists.
    @Sendable
    @inlinable
    public func getMatchingWorkflow(_ input: GetMatchingWorkflowInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMatchingWorkflowOutput {
        try await self.client.execute(
            operation: "GetMatchingWorkflow", 
            path: "/matchingworkflows/{workflowName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the MatchingWorkflow with a given name, if it exists.
    ///
    /// Parameters:
    ///   - workflowName: The name of the workflow.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMatchingWorkflow(
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMatchingWorkflowOutput {
        let input = GetMatchingWorkflowInput(
            workflowName: workflowName
        )
        return try await self.getMatchingWorkflow(input, logger: logger)
    }

    /// Returns the resource-based policy.
    @Sendable
    @inlinable
    public func getPolicy(_ input: GetPolicyInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPolicyOutput {
        try await self.client.execute(
            operation: "GetPolicy", 
            path: "/policies/{arn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the resource-based policy.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the resource for which the policy need to be returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPolicy(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPolicyOutput {
        let input = GetPolicyInput(
            arn: arn
        )
        return try await self.getPolicy(input, logger: logger)
    }

    /// Returns the ProviderService of a given name.
    @Sendable
    @inlinable
    public func getProviderService(_ input: GetProviderServiceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetProviderServiceOutput {
        try await self.client.execute(
            operation: "GetProviderService", 
            path: "/providerservices/{providerName}/{providerServiceName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the ProviderService of a given name.
    ///
    /// Parameters:
    ///   - providerName: The name of the provider. This name is typically the company name.
    ///   - providerServiceName: The ARN (Amazon Resource Name) of the product that the provider service provides.
    ///   - logger: Logger use during operation
    @inlinable
    public func getProviderService(
        providerName: String,
        providerServiceName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetProviderServiceOutput {
        let input = GetProviderServiceInput(
            providerName: providerName, 
            providerServiceName: providerServiceName
        )
        return try await self.getProviderService(input, logger: logger)
    }

    /// Returns the SchemaMapping of a given name.
    @Sendable
    @inlinable
    public func getSchemaMapping(_ input: GetSchemaMappingInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSchemaMappingOutput {
        try await self.client.execute(
            operation: "GetSchemaMapping", 
            path: "/schemas/{schemaName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the SchemaMapping of a given name.
    ///
    /// Parameters:
    ///   - schemaName: The name of the schema to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSchemaMapping(
        schemaName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSchemaMappingOutput {
        let input = GetSchemaMappingInput(
            schemaName: schemaName
        )
        return try await self.getSchemaMapping(input, logger: logger)
    }

    /// Lists all ID mapping jobs for a given workflow.
    @Sendable
    @inlinable
    public func listIdMappingJobs(_ input: ListIdMappingJobsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIdMappingJobsOutput {
        try await self.client.execute(
            operation: "ListIdMappingJobs", 
            path: "/idmappingworkflows/{workflowName}/jobs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all ID mapping jobs for a given workflow.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - nextToken: The pagination token from the previous API call.
    ///   - workflowName: The name of the workflow to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIdMappingJobs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIdMappingJobsOutput {
        let input = ListIdMappingJobsInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            workflowName: workflowName
        )
        return try await self.listIdMappingJobs(input, logger: logger)
    }

    /// Returns a list of all the IdMappingWorkflows that have been created for an Amazon Web Services account.
    @Sendable
    @inlinable
    public func listIdMappingWorkflows(_ input: ListIdMappingWorkflowsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIdMappingWorkflowsOutput {
        try await self.client.execute(
            operation: "ListIdMappingWorkflows", 
            path: "/idmappingworkflows", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the IdMappingWorkflows that have been created for an Amazon Web Services account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - nextToken: The pagination token from the previous API call.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIdMappingWorkflows(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIdMappingWorkflowsOutput {
        let input = ListIdMappingWorkflowsInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listIdMappingWorkflows(input, logger: logger)
    }

    /// Returns a list of all ID namespaces.
    @Sendable
    @inlinable
    public func listIdNamespaces(_ input: ListIdNamespacesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIdNamespacesOutput {
        try await self.client.execute(
            operation: "ListIdNamespaces", 
            path: "/idnamespaces", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all ID namespaces.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of IdNamespace objects returned per page.
    ///   - nextToken: The pagination token from the previous API call.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIdNamespaces(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIdNamespacesOutput {
        let input = ListIdNamespacesInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listIdNamespaces(input, logger: logger)
    }

    /// Lists all jobs for a given workflow.
    @Sendable
    @inlinable
    public func listMatchingJobs(_ input: ListMatchingJobsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMatchingJobsOutput {
        try await self.client.execute(
            operation: "ListMatchingJobs", 
            path: "/matchingworkflows/{workflowName}/jobs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all jobs for a given workflow.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - nextToken: The pagination token from the previous API call.
    ///   - workflowName: The name of the workflow to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMatchingJobs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMatchingJobsOutput {
        let input = ListMatchingJobsInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            workflowName: workflowName
        )
        return try await self.listMatchingJobs(input, logger: logger)
    }

    /// Returns a list of all the MatchingWorkflows that have been created for an Amazon Web Services account.
    @Sendable
    @inlinable
    public func listMatchingWorkflows(_ input: ListMatchingWorkflowsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMatchingWorkflowsOutput {
        try await self.client.execute(
            operation: "ListMatchingWorkflows", 
            path: "/matchingworkflows", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the MatchingWorkflows that have been created for an Amazon Web Services account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - nextToken: The pagination token from the previous API call.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMatchingWorkflows(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMatchingWorkflowsOutput {
        let input = ListMatchingWorkflowsInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listMatchingWorkflows(input, logger: logger)
    }

    /// Returns a list of all the ProviderServices that are available in this Amazon Web Services Region.
    @Sendable
    @inlinable
    public func listProviderServices(_ input: ListProviderServicesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListProviderServicesOutput {
        try await self.client.execute(
            operation: "ListProviderServices", 
            path: "/providerservices", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the ProviderServices that are available in this Amazon Web Services Region.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - nextToken: The pagination token from the previous API call.
    ///   - providerName: The name of the provider. This name is typically the company name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listProviderServices(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        providerName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListProviderServicesOutput {
        let input = ListProviderServicesInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            providerName: providerName
        )
        return try await self.listProviderServices(input, logger: logger)
    }

    /// Returns a list of all the SchemaMappings that have been created for an Amazon Web Services account.
    @Sendable
    @inlinable
    public func listSchemaMappings(_ input: ListSchemaMappingsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSchemaMappingsOutput {
        try await self.client.execute(
            operation: "ListSchemaMappings", 
            path: "/schemas", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the SchemaMappings that have been created for an Amazon Web Services account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - nextToken: The pagination token from the previous API call.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSchemaMappings(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSchemaMappingsOutput {
        let input = ListSchemaMappingsInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listSchemaMappings(input, logger: logger)
    }

    /// Displays the tags associated with an Entity Resolution resource. In Entity Resolution, SchemaMapping, and MatchingWorkflow can be tagged.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceOutput {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Displays the tags associated with an Entity Resolution resource. In Entity Resolution, SchemaMapping, and MatchingWorkflow can be tagged.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource for which you want to view tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceOutput {
        let input = ListTagsForResourceInput(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Updates the resource-based policy.
    @Sendable
    @inlinable
    public func putPolicy(_ input: PutPolicyInput, logger: Logger = AWSClient.loggingDisabled) async throws -> PutPolicyOutput {
        try await self.client.execute(
            operation: "PutPolicy", 
            path: "/policies/{arn}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the resource-based policy.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the resource for which the policy needs to be updated.
    ///   - policy: The resource-based policy.  If you set the value of the effect parameter in the policy to Deny for the PutPolicy operation, you must also set the value of the effect parameter to Deny for the AddPolicyStatement operation.
    ///   - token: A unique identifier for the current revision of the policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func putPolicy(
        arn: String,
        policy: String,
        token: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutPolicyOutput {
        let input = PutPolicyInput(
            arn: arn, 
            policy: policy, 
            token: token
        )
        return try await self.putPolicy(input, logger: logger)
    }

    /// Starts the IdMappingJob of a workflow. The workflow must have previously been created using the CreateIdMappingWorkflow endpoint.
    @Sendable
    @inlinable
    public func startIdMappingJob(_ input: StartIdMappingJobInput, logger: Logger = AWSClient.loggingDisabled) async throws -> StartIdMappingJobOutput {
        try await self.client.execute(
            operation: "StartIdMappingJob", 
            path: "/idmappingworkflows/{workflowName}/jobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts the IdMappingJob of a workflow. The workflow must have previously been created using the CreateIdMappingWorkflow endpoint.
    ///
    /// Parameters:
    ///   - outputSourceConfig: A list of OutputSource objects.
    ///   - workflowName: The name of the ID mapping job to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func startIdMappingJob(
        outputSourceConfig: [IdMappingJobOutputSource]? = nil,
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartIdMappingJobOutput {
        let input = StartIdMappingJobInput(
            outputSourceConfig: outputSourceConfig, 
            workflowName: workflowName
        )
        return try await self.startIdMappingJob(input, logger: logger)
    }

    /// Starts the MatchingJob of a workflow. The workflow must have previously been created using the CreateMatchingWorkflow endpoint.
    @Sendable
    @inlinable
    public func startMatchingJob(_ input: StartMatchingJobInput, logger: Logger = AWSClient.loggingDisabled) async throws -> StartMatchingJobOutput {
        try await self.client.execute(
            operation: "StartMatchingJob", 
            path: "/matchingworkflows/{workflowName}/jobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts the MatchingJob of a workflow. The workflow must have previously been created using the CreateMatchingWorkflow endpoint.
    ///
    /// Parameters:
    ///   - workflowName: The name of the matching job to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func startMatchingJob(
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartMatchingJobOutput {
        let input = StartMatchingJobInput(
            workflowName: workflowName
        )
        return try await self.startMatchingJob(input, logger: logger)
    }

    /// Assigns one or more tags (key-value pairs) to the specified Entity Resolution resource. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. In Entity Resolution, SchemaMapping and MatchingWorkflow can be tagged. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can use the TagResource action with a resource that already has tags. If you specify a new tag key, this tag is appended to the list of tags associated with the resource. If you specify a tag key that is already associated with the resource, the new tag value that you specify replaces the previous value for that tag.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceOutput {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Assigns one or more tags (key-value pairs) to the specified Entity Resolution resource. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. In Entity Resolution, SchemaMapping and MatchingWorkflow can be tagged. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can use the TagResource action with a resource that already has tags. If you specify a new tag key, this tag is appended to the list of tags associated with the resource. If you specify a tag key that is already associated with the resource, the new tag value that you specify replaces the previous value for that tag.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource for which you want to view tags.
    ///   - tags: The tags used to organize, track, or control access for this resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceOutput {
        let input = TagResourceInput(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes one or more tags from the specified Entity Resolution resource. In Entity Resolution, SchemaMapping, and MatchingWorkflow can be tagged.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceOutput {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes one or more tags from the specified Entity Resolution resource. In Entity Resolution, SchemaMapping, and MatchingWorkflow can be tagged.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource for which you want to untag.
    ///   - tagKeys: The list of tag keys to remove from the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceOutput {
        let input = UntagResourceInput(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates an existing IdMappingWorkflow. This method is identical to CreateIdMappingWorkflow, except it uses an HTTP PUT request instead of a POST request, and the IdMappingWorkflow must already exist for the method to succeed.
    @Sendable
    @inlinable
    public func updateIdMappingWorkflow(_ input: UpdateIdMappingWorkflowInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateIdMappingWorkflowOutput {
        try await self.client.execute(
            operation: "UpdateIdMappingWorkflow", 
            path: "/idmappingworkflows/{workflowName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing IdMappingWorkflow. This method is identical to CreateIdMappingWorkflow, except it uses an HTTP PUT request instead of a POST request, and the IdMappingWorkflow must already exist for the method to succeed.
    ///
    /// Parameters:
    ///   - description: A description of the workflow.
    ///   - idMappingTechniques: An object which defines the ID mapping technique and any additional configurations.
    ///   - inputSourceConfig: A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    ///   - outputSourceConfig: A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
    ///   - roleArn: The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
    ///   - workflowName: The name of the workflow.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateIdMappingWorkflow(
        description: String? = nil,
        idMappingTechniques: IdMappingTechniques,
        inputSourceConfig: [IdMappingWorkflowInputSource],
        outputSourceConfig: [IdMappingWorkflowOutputSource]? = nil,
        roleArn: String? = nil,
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateIdMappingWorkflowOutput {
        let input = UpdateIdMappingWorkflowInput(
            description: description, 
            idMappingTechniques: idMappingTechniques, 
            inputSourceConfig: inputSourceConfig, 
            outputSourceConfig: outputSourceConfig, 
            roleArn: roleArn, 
            workflowName: workflowName
        )
        return try await self.updateIdMappingWorkflow(input, logger: logger)
    }

    /// Updates an existing ID namespace.
    @Sendable
    @inlinable
    public func updateIdNamespace(_ input: UpdateIdNamespaceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateIdNamespaceOutput {
        try await self.client.execute(
            operation: "UpdateIdNamespace", 
            path: "/idnamespaces/{idNamespaceName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing ID namespace.
    ///
    /// Parameters:
    ///   - description: The description of the ID namespace.
    ///   - idMappingWorkflowProperties: Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
    ///   - idNamespaceName: The name of the ID namespace.
    ///   - inputSourceConfig: A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    ///   - roleArn: The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of a workflow run.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateIdNamespace(
        description: String? = nil,
        idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceName: String,
        inputSourceConfig: [IdNamespaceInputSource]? = nil,
        roleArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateIdNamespaceOutput {
        let input = UpdateIdNamespaceInput(
            description: description, 
            idMappingWorkflowProperties: idMappingWorkflowProperties, 
            idNamespaceName: idNamespaceName, 
            inputSourceConfig: inputSourceConfig, 
            roleArn: roleArn
        )
        return try await self.updateIdNamespace(input, logger: logger)
    }

    /// Updates an existing MatchingWorkflow. This method is identical to CreateMatchingWorkflow, except it uses an HTTP PUT request instead of a POST request, and the MatchingWorkflow must already exist for the method to succeed.
    @Sendable
    @inlinable
    public func updateMatchingWorkflow(_ input: UpdateMatchingWorkflowInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateMatchingWorkflowOutput {
        try await self.client.execute(
            operation: "UpdateMatchingWorkflow", 
            path: "/matchingworkflows/{workflowName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing MatchingWorkflow. This method is identical to CreateMatchingWorkflow, except it uses an HTTP PUT request instead of a POST request, and the MatchingWorkflow must already exist for the method to succeed.
    ///
    /// Parameters:
    ///   - description: A description of the workflow.
    ///   - incrementalRunConfig: An object which defines an incremental run type and has only incrementalRunType as a field.
    ///   - inputSourceConfig: A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    ///   - outputSourceConfig: A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    ///   - resolutionTechniques: An object which defines the resolutionType and the ruleBasedProperties.
    ///   - roleArn: The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    ///   - workflowName: The name of the workflow to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateMatchingWorkflow(
        description: String? = nil,
        incrementalRunConfig: IncrementalRunConfig? = nil,
        inputSourceConfig: [InputSource],
        outputSourceConfig: [OutputSource],
        resolutionTechniques: ResolutionTechniques,
        roleArn: String,
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateMatchingWorkflowOutput {
        let input = UpdateMatchingWorkflowInput(
            description: description, 
            incrementalRunConfig: incrementalRunConfig, 
            inputSourceConfig: inputSourceConfig, 
            outputSourceConfig: outputSourceConfig, 
            resolutionTechniques: resolutionTechniques, 
            roleArn: roleArn, 
            workflowName: workflowName
        )
        return try await self.updateMatchingWorkflow(input, logger: logger)
    }

    /// Updates a schema mapping.  A schema is immutable if it is being used by a workflow. Therefore, you can't update a schema mapping if it's associated with a workflow.
    @Sendable
    @inlinable
    public func updateSchemaMapping(_ input: UpdateSchemaMappingInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSchemaMappingOutput {
        try await self.client.execute(
            operation: "UpdateSchemaMapping", 
            path: "/schemas/{schemaName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a schema mapping.  A schema is immutable if it is being used by a workflow. Therefore, you can't update a schema mapping if it's associated with a workflow.
    ///
    /// Parameters:
    ///   - description: A description of the schema.
    ///   - mappedInputFields: A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    ///   - schemaName: The name of the schema. There can't be multiple SchemaMappings with the same name.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSchemaMapping(
        description: String? = nil,
        mappedInputFields: [SchemaInputAttribute],
        schemaName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSchemaMappingOutput {
        let input = UpdateSchemaMappingInput(
            description: description, 
            mappedInputFields: mappedInputFields, 
            schemaName: schemaName
        )
        return try await self.updateSchemaMapping(input, logger: logger)
    }
}

extension EntityResolution {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: EntityResolution, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension EntityResolution {
    /// Return PaginatorSequence for operation ``listIdMappingJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIdMappingJobsPaginator(
        _ input: ListIdMappingJobsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIdMappingJobsInput, ListIdMappingJobsOutput> {
        return .init(
            input: input,
            command: self.listIdMappingJobs,
            inputKey: \ListIdMappingJobsInput.nextToken,
            outputKey: \ListIdMappingJobsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIdMappingJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - workflowName: The name of the workflow to be retrieved.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIdMappingJobsPaginator(
        maxResults: Int? = nil,
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIdMappingJobsInput, ListIdMappingJobsOutput> {
        let input = ListIdMappingJobsInput(
            maxResults: maxResults, 
            workflowName: workflowName
        )
        return self.listIdMappingJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listIdMappingWorkflows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIdMappingWorkflowsPaginator(
        _ input: ListIdMappingWorkflowsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIdMappingWorkflowsInput, ListIdMappingWorkflowsOutput> {
        return .init(
            input: input,
            command: self.listIdMappingWorkflows,
            inputKey: \ListIdMappingWorkflowsInput.nextToken,
            outputKey: \ListIdMappingWorkflowsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIdMappingWorkflows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIdMappingWorkflowsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIdMappingWorkflowsInput, ListIdMappingWorkflowsOutput> {
        let input = ListIdMappingWorkflowsInput(
            maxResults: maxResults
        )
        return self.listIdMappingWorkflowsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listIdNamespaces(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIdNamespacesPaginator(
        _ input: ListIdNamespacesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIdNamespacesInput, ListIdNamespacesOutput> {
        return .init(
            input: input,
            command: self.listIdNamespaces,
            inputKey: \ListIdNamespacesInput.nextToken,
            outputKey: \ListIdNamespacesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIdNamespaces(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of IdNamespace objects returned per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIdNamespacesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIdNamespacesInput, ListIdNamespacesOutput> {
        let input = ListIdNamespacesInput(
            maxResults: maxResults
        )
        return self.listIdNamespacesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMatchingJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMatchingJobsPaginator(
        _ input: ListMatchingJobsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMatchingJobsInput, ListMatchingJobsOutput> {
        return .init(
            input: input,
            command: self.listMatchingJobs,
            inputKey: \ListMatchingJobsInput.nextToken,
            outputKey: \ListMatchingJobsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMatchingJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - workflowName: The name of the workflow to be retrieved.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMatchingJobsPaginator(
        maxResults: Int? = nil,
        workflowName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMatchingJobsInput, ListMatchingJobsOutput> {
        let input = ListMatchingJobsInput(
            maxResults: maxResults, 
            workflowName: workflowName
        )
        return self.listMatchingJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMatchingWorkflows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMatchingWorkflowsPaginator(
        _ input: ListMatchingWorkflowsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMatchingWorkflowsInput, ListMatchingWorkflowsOutput> {
        return .init(
            input: input,
            command: self.listMatchingWorkflows,
            inputKey: \ListMatchingWorkflowsInput.nextToken,
            outputKey: \ListMatchingWorkflowsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMatchingWorkflows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMatchingWorkflowsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMatchingWorkflowsInput, ListMatchingWorkflowsOutput> {
        let input = ListMatchingWorkflowsInput(
            maxResults: maxResults
        )
        return self.listMatchingWorkflowsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listProviderServices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listProviderServicesPaginator(
        _ input: ListProviderServicesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListProviderServicesInput, ListProviderServicesOutput> {
        return .init(
            input: input,
            command: self.listProviderServices,
            inputKey: \ListProviderServicesInput.nextToken,
            outputKey: \ListProviderServicesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listProviderServices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - providerName: The name of the provider. This name is typically the company name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listProviderServicesPaginator(
        maxResults: Int? = nil,
        providerName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListProviderServicesInput, ListProviderServicesOutput> {
        let input = ListProviderServicesInput(
            maxResults: maxResults, 
            providerName: providerName
        )
        return self.listProviderServicesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSchemaMappings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSchemaMappingsPaginator(
        _ input: ListSchemaMappingsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSchemaMappingsInput, ListSchemaMappingsOutput> {
        return .init(
            input: input,
            command: self.listSchemaMappings,
            inputKey: \ListSchemaMappingsInput.nextToken,
            outputKey: \ListSchemaMappingsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSchemaMappings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of objects returned per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSchemaMappingsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSchemaMappingsInput, ListSchemaMappingsOutput> {
        let input = ListSchemaMappingsInput(
            maxResults: maxResults
        )
        return self.listSchemaMappingsPaginator(input, logger: logger)
    }
}

extension EntityResolution.ListIdMappingJobsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EntityResolution.ListIdMappingJobsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            workflowName: self.workflowName
        )
    }
}

extension EntityResolution.ListIdMappingWorkflowsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EntityResolution.ListIdMappingWorkflowsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EntityResolution.ListIdNamespacesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EntityResolution.ListIdNamespacesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EntityResolution.ListMatchingJobsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EntityResolution.ListMatchingJobsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            workflowName: self.workflowName
        )
    }
}

extension EntityResolution.ListMatchingWorkflowsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EntityResolution.ListMatchingWorkflowsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EntityResolution.ListProviderServicesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EntityResolution.ListProviderServicesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            providerName: self.providerName
        )
    }
}

extension EntityResolution.ListSchemaMappingsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EntityResolution.ListSchemaMappingsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
