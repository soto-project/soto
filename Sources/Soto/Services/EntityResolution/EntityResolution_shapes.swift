//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension EntityResolution {
    // MARK: Enums

    public enum AttributeMatchingModel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case manyToMany = "MANY_TO_MANY"
        case oneToOne = "ONE_TO_ONE"
        public var description: String { return self.rawValue }
    }

    public enum IdMappingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case provider = "PROVIDER"
        public var description: String { return self.rawValue }
    }

    public enum IncrementalRunType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case immediate = "IMMEDIATE"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case queued = "QUEUED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ResolutionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mlMatching = "ML_MATCHING"
        case provider = "PROVIDER"
        case ruleMatching = "RULE_MATCHING"
        public var description: String { return self.rawValue }
    }

    public enum SchemaAttributeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case address = "ADDRESS"
        case addressCity = "ADDRESS_CITY"
        case addressCountry = "ADDRESS_COUNTRY"
        case addressPostalcode = "ADDRESS_POSTALCODE"
        case addressState = "ADDRESS_STATE"
        case addressStreet1 = "ADDRESS_STREET1"
        case addressStreet2 = "ADDRESS_STREET2"
        case addressStreet3 = "ADDRESS_STREET3"
        case date = "DATE"
        case emailAddress = "EMAIL_ADDRESS"
        case name = "NAME"
        case nameFirst = "NAME_FIRST"
        case nameLast = "NAME_LAST"
        case nameMiddle = "NAME_MIDDLE"
        case phone = "PHONE"
        case phoneCountrycode = "PHONE_COUNTRYCODE"
        case phoneNumber = "PHONE_NUMBER"
        case providerId = "PROVIDER_ID"
        case string = "STRING"
        case uniqueId = "UNIQUE_ID"
        public var description: String { return self.rawValue }
    }

    public enum ServiceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assignment = "ASSIGNMENT"
        case idMapping = "ID_MAPPING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateIdMappingWorkflowInput: AWSEncodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines the idMappingType and the providerProperties.
        public let idMappingTechniques: IdMappingTechniques
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdMappingWorkflowInputSource]
        /// A list of IdMappingWorkflowOutputSource objects, each of which contains fields OutputS3Path and Output.
        public let outputSourceConfig: [IdMappingWorkflowOutputSource]
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The name of the workflow. There can't be multiple IdMappingWorkflows with the same name.
        public let workflowName: String

        public init(description: String? = nil, idMappingTechniques: IdMappingTechniques, inputSourceConfig: [IdMappingWorkflowInputSource], outputSourceConfig: [IdMappingWorkflowOutputSource], roleArn: String, tags: [String: String]? = nil, workflowName: String) {
            self.description = description
            self.idMappingTechniques = idMappingTechniques
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.roleArn = roleArn
            self.tags = tags
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.idMappingTechniques.validate(name: "\(name).idMappingTechniques")
            try self.inputSourceConfig.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, min: 1)
            try self.outputSourceConfig.forEach {
                try $0.validate(name: "\(name).outputSourceConfig[]")
            }
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, max: 1)
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingTechniques = "idMappingTechniques"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case roleArn = "roleArn"
            case tags = "tags"
            case workflowName = "workflowName"
        }
    }

    public struct CreateIdMappingWorkflowOutput: AWSDecodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines the idMappingType and the providerProperties.
        public let idMappingTechniques: IdMappingTechniques
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdMappingWorkflowInputSource]
        /// A list of IdMappingWorkflowOutputSource objects, each of which contains fields OutputS3Path and Output.
        public let outputSourceConfig: [IdMappingWorkflowOutputSource]
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IDMappingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, idMappingTechniques: IdMappingTechniques, inputSourceConfig: [IdMappingWorkflowInputSource], outputSourceConfig: [IdMappingWorkflowOutputSource], roleArn: String, workflowArn: String, workflowName: String) {
            self.description = description
            self.idMappingTechniques = idMappingTechniques
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.roleArn = roleArn
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingTechniques = "idMappingTechniques"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case roleArn = "roleArn"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct CreateMatchingWorkflowInput: AWSEncodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The name of the workflow. There can't be multiple MatchingWorkflows with the same name.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, tags: [String: String]? = nil, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.tags = tags
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.inputSourceConfig.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, min: 1)
            try self.outputSourceConfig.forEach {
                try $0.validate(name: "\(name).outputSourceConfig[]")
            }
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, max: 1)
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, min: 1)
            try self.resolutionTechniques.validate(name: "\(name).resolutionTechniques")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case tags = "tags"
            case workflowName = "workflowName"
        }
    }

    public struct CreateMatchingWorkflowOutput: AWSDecodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, workflowArn: String, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct CreateSchemaMappingInput: AWSEncodableShape {
        /// A description of the schema.
        public let description: String?
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The name of the schema. There can't be multiple SchemaMappings with the same name.
        public let schemaName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(description: String? = nil, mappedInputFields: [SchemaInputAttribute], schemaName: String, tags: [String: String]? = nil) {
            self.description = description
            self.mappedInputFields = mappedInputFields
            self.schemaName = schemaName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.mappedInputFields.forEach {
                try $0.validate(name: "\(name).mappedInputFields[]")
            }
            try self.validate(self.mappedInputFields, name: "mappedInputFields", parent: name, max: 25)
            try self.validate(self.mappedInputFields, name: "mappedInputFields", parent: name, min: 2)
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case mappedInputFields = "mappedInputFields"
            case schemaName = "schemaName"
            case tags = "tags"
        }
    }

    public struct CreateSchemaMappingOutput: AWSDecodableShape {
        /// A description of the schema.
        public let description: String
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        public let schemaArn: String
        /// The name of the schema.
        public let schemaName: String

        public init(description: String, mappedInputFields: [SchemaInputAttribute], schemaArn: String, schemaName: String) {
            self.description = description
            self.mappedInputFields = mappedInputFields
            self.schemaArn = schemaArn
            self.schemaName = schemaName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case mappedInputFields = "mappedInputFields"
            case schemaArn = "schemaArn"
            case schemaName = "schemaName"
        }
    }

    public struct DeleteIdMappingWorkflowInput: AWSEncodableShape {
        /// The name of the workflow to be deleted.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIdMappingWorkflowOutput: AWSDecodableShape {
        /// A successful operation message.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DeleteMatchingWorkflowInput: AWSEncodableShape {
        /// The name of the workflow to be retrieved.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMatchingWorkflowOutput: AWSDecodableShape {
        /// A successful operation message.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DeleteSchemaMappingInput: AWSEncodableShape {
        /// The name of the schema to delete.
        public let schemaName: String

        public init(schemaName: String) {
            self.schemaName = schemaName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.schemaName, key: "schemaName")
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSchemaMappingOutput: AWSDecodableShape {
        /// A successful operation message.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error message from the job, if there is one.
        public let errorMessage: String?

        public init(errorMessage: String? = nil) {
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
        }
    }

    public struct GetIdMappingJobInput: AWSEncodableShape {
        /// The ID of the job.
        public let jobId: String
        /// The name of the workflow.
        public let workflowName: String

        public init(jobId: String, workflowName: String) {
            self.jobId = jobId
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIdMappingJobOutput: AWSDecodableShape {
        /// The time at which the job has finished.
        public let endTime: Date?
        public let errorDetails: ErrorDetails?
        /// The ID of the job.
        public let jobId: String
        /// Metrics associated with the execution, specifically total records processed, unique IDs generated, and records the execution skipped.
        public let metrics: IdMappingJobMetrics?
        /// The time at which the job was started.
        public let startTime: Date
        /// The current status of the job.
        public let status: JobStatus

        public init(endTime: Date? = nil, errorDetails: ErrorDetails? = nil, jobId: String, metrics: IdMappingJobMetrics? = nil, startTime: Date, status: JobStatus) {
            self.endTime = endTime
            self.errorDetails = errorDetails
            self.jobId = jobId
            self.metrics = metrics
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case errorDetails = "errorDetails"
            case jobId = "jobId"
            case metrics = "metrics"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct GetIdMappingWorkflowInput: AWSEncodableShape {
        /// The name of the workflow.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIdMappingWorkflowOutput: AWSDecodableShape {
        /// The timestamp of when the workflow was created.
        public let createdAt: Date
        /// A description of the workflow.
        public let description: String?
        /// An object which defines the idMappingType and the providerProperties.
        public let idMappingTechniques: IdMappingTechniques
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdMappingWorkflowInputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
        public let outputSourceConfig: [IdMappingWorkflowOutputSource]
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access resources on your behalf.
        public let roleArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The timestamp of when the workflow was last updated.
        public let updatedAt: Date
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IdMappingWorkflow .
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(createdAt: Date, description: String? = nil, idMappingTechniques: IdMappingTechniques, inputSourceConfig: [IdMappingWorkflowInputSource], outputSourceConfig: [IdMappingWorkflowOutputSource], roleArn: String, tags: [String: String]? = nil, updatedAt: Date, workflowArn: String, workflowName: String) {
            self.createdAt = createdAt
            self.description = description
            self.idMappingTechniques = idMappingTechniques
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.roleArn = roleArn
            self.tags = tags
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case idMappingTechniques = "idMappingTechniques"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case roleArn = "roleArn"
            case tags = "tags"
            case updatedAt = "updatedAt"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct GetMatchIdInput: AWSEncodableShape {
        /// The record to fetch the Match ID for.
        public let record: [String: String]
        /// The name of the workflow.
        public let workflowName: String

        public init(record: [String: String], workflowName: String) {
            self.record = record
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.record, forKey: .record)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case record = "record"
        }
    }

    public struct GetMatchIdOutput: AWSDecodableShape {
        /// The unique identifiers for this group of match records.
        public let matchId: String?

        public init(matchId: String? = nil) {
            self.matchId = matchId
        }

        private enum CodingKeys: String, CodingKey {
            case matchId = "matchId"
        }
    }

    public struct GetMatchingJobInput: AWSEncodableShape {
        /// The ID of the job.
        public let jobId: String
        /// The name of the workflow.
        public let workflowName: String

        public init(jobId: String, workflowName: String) {
            self.jobId = jobId
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMatchingJobOutput: AWSDecodableShape {
        /// The time at which the job has finished.
        public let endTime: Date?
        /// An object containing an error message, if there was an error.
        public let errorDetails: ErrorDetails?
        /// The ID of the job.
        public let jobId: String
        /// Metrics associated with the execution, specifically total records processed, unique IDs generated, and records the execution skipped.
        public let metrics: JobMetrics?
        /// The time at which the job was started.
        public let startTime: Date
        /// The current status of the job.
        public let status: JobStatus

        public init(endTime: Date? = nil, errorDetails: ErrorDetails? = nil, jobId: String, metrics: JobMetrics? = nil, startTime: Date, status: JobStatus) {
            self.endTime = endTime
            self.errorDetails = errorDetails
            self.jobId = jobId
            self.metrics = metrics
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case errorDetails = "errorDetails"
            case jobId = "jobId"
            case metrics = "metrics"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct GetMatchingWorkflowInput: AWSEncodableShape {
        /// The name of the workflow.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMatchingWorkflowOutput: AWSDecodableShape {
        /// The timestamp of when the workflow was created.
        public let createdAt: Date
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access resources on your behalf.
        public let roleArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The timestamp of when the workflow was last updated.
        public let updatedAt: Date
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(createdAt: Date, description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, tags: [String: String]? = nil, updatedAt: Date, workflowArn: String, workflowName: String) {
            self.createdAt = createdAt
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.tags = tags
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case tags = "tags"
            case updatedAt = "updatedAt"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct GetProviderServiceInput: AWSEncodableShape {
        /// The name of the provider. This name is typically the company name.
        public let providerName: String
        /// The ARN (Amazon Resource Name) of the product that the provider service provides.
        public let providerServiceName: String

        public init(providerName: String, providerServiceName: String) {
            self.providerName = providerName
            self.providerServiceName = providerServiceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.providerName, key: "providerName")
            request.encodePath(self.providerServiceName, key: "providerServiceName")
        }

        public func validate(name: String) throws {
            try self.validate(self.providerName, name: "providerName", parent: name, max: 255)
            try self.validate(self.providerName, name: "providerName", parent: name, min: 1)
            try self.validate(self.providerName, name: "providerName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
            try self.validate(self.providerServiceName, name: "providerServiceName", parent: name, max: 255)
            try self.validate(self.providerServiceName, name: "providerServiceName", parent: name, min: 20)
            try self.validate(self.providerServiceName, name: "providerServiceName", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):(entityresolution):([a-z]{2}-[a-z-]+?-[0-9])::providerservice/([a-zA-Z0-9_-]+)/([a-zA-Z0-9_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProviderServiceOutput: AWSDecodableShape {
        /// Specifies whether output data from the provider is anonymized. A value of TRUE means the output will be anonymized and you can't relate the data that comes back from the provider to the identifying input. A value of FALSE means the output won't be anonymized and you can relate the data that comes back from the provider to your source data.
        public let anonymizedOutput: Bool
        /// The definition of the provider configuration.
        public let providerConfigurationDefinition: String?
        /// The required configuration fields to use with the provider service.
        public let providerEndpointConfiguration: ProviderEndpointConfiguration
        /// The definition of the provider entity output.
        public let providerEntityOutputDefinition: String
        /// The Amazon Web Services accounts and the S3 permissions that are required by some providers to create an S3 bucket for intermediate data storage.
        public let providerIntermediateDataAccessConfiguration: ProviderIntermediateDataAccessConfiguration?
        /// The name of the provider. This name is typically the company name.
        public let providerName: String
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the provider service.
        public let providerServiceArn: String
        /// The display name of the provider service.
        public let providerServiceDisplayName: String
        /// The name of the product that the provider service provides.
        public let providerServiceName: String
        /// The type of provider service.
        public let providerServiceType: ServiceType

        public init(anonymizedOutput: Bool, providerConfigurationDefinition: String? = nil, providerEndpointConfiguration: ProviderEndpointConfiguration, providerEntityOutputDefinition: String, providerIntermediateDataAccessConfiguration: ProviderIntermediateDataAccessConfiguration? = nil, providerName: String, providerServiceArn: String, providerServiceDisplayName: String, providerServiceName: String, providerServiceType: ServiceType) {
            self.anonymizedOutput = anonymizedOutput
            self.providerConfigurationDefinition = providerConfigurationDefinition
            self.providerEndpointConfiguration = providerEndpointConfiguration
            self.providerEntityOutputDefinition = providerEntityOutputDefinition
            self.providerIntermediateDataAccessConfiguration = providerIntermediateDataAccessConfiguration
            self.providerName = providerName
            self.providerServiceArn = providerServiceArn
            self.providerServiceDisplayName = providerServiceDisplayName
            self.providerServiceName = providerServiceName
            self.providerServiceType = providerServiceType
        }

        private enum CodingKeys: String, CodingKey {
            case anonymizedOutput = "anonymizedOutput"
            case providerConfigurationDefinition = "providerConfigurationDefinition"
            case providerEndpointConfiguration = "providerEndpointConfiguration"
            case providerEntityOutputDefinition = "providerEntityOutputDefinition"
            case providerIntermediateDataAccessConfiguration = "providerIntermediateDataAccessConfiguration"
            case providerName = "providerName"
            case providerServiceArn = "providerServiceArn"
            case providerServiceDisplayName = "providerServiceDisplayName"
            case providerServiceName = "providerServiceName"
            case providerServiceType = "providerServiceType"
        }
    }

    public struct GetSchemaMappingInput: AWSEncodableShape {
        /// The name of the schema to be retrieved.
        public let schemaName: String

        public init(schemaName: String) {
            self.schemaName = schemaName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.schemaName, key: "schemaName")
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaMappingOutput: AWSDecodableShape {
        /// The timestamp of when the SchemaMapping was created.
        public let createdAt: Date
        /// A description of the schema.
        public let description: String?
        /// Specifies whether the schema mapping has been applied to a workflow.
        public let hasWorkflows: Bool
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information Venice uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        public let schemaArn: String
        /// The name of the schema.
        public let schemaName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The timestamp of when the SchemaMapping was last updated.
        public let updatedAt: Date

        public init(createdAt: Date, description: String? = nil, hasWorkflows: Bool, mappedInputFields: [SchemaInputAttribute], schemaArn: String, schemaName: String, tags: [String: String]? = nil, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.hasWorkflows = hasWorkflows
            self.mappedInputFields = mappedInputFields
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case hasWorkflows = "hasWorkflows"
            case mappedInputFields = "mappedInputFields"
            case schemaArn = "schemaArn"
            case schemaName = "schemaName"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct IdMappingJobMetrics: AWSDecodableShape {
        /// The total number of input records.
        public let inputRecords: Int?
        /// The total number of records that did not get processed.
        public let recordsNotProcessed: Int?
        /// The total number of records processed.
        public let totalRecordsProcessed: Int?

        public init(inputRecords: Int? = nil, recordsNotProcessed: Int? = nil, totalRecordsProcessed: Int? = nil) {
            self.inputRecords = inputRecords
            self.recordsNotProcessed = recordsNotProcessed
            self.totalRecordsProcessed = totalRecordsProcessed
        }

        private enum CodingKeys: String, CodingKey {
            case inputRecords = "inputRecords"
            case recordsNotProcessed = "recordsNotProcessed"
            case totalRecordsProcessed = "totalRecordsProcessed"
        }
    }

    public struct IdMappingTechniques: AWSEncodableShape & AWSDecodableShape {
        /// The type of ID mapping.
        public let idMappingType: IdMappingType
        /// An object which defines any additional configurations required by the provider service.
        public let providerProperties: ProviderProperties

        public init(idMappingType: IdMappingType, providerProperties: ProviderProperties) {
            self.idMappingType = idMappingType
            self.providerProperties = providerProperties
        }

        public func validate(name: String) throws {
            try self.providerProperties.validate(name: "\(name).providerProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingType = "idMappingType"
            case providerProperties = "providerProperties"
        }
    }

    public struct IdMappingWorkflowInputSource: AWSEncodableShape & AWSDecodableShape {
        /// An Gluetable ARN for the input source table.
        public let inputSourceARN: String
        /// The name of the schema to be retrieved.
        public let schemaName: String

        public init(inputSourceARN: String, schemaName: String) {
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputSourceARN = "inputSourceARN"
            case schemaName = "schemaName"
        }
    }

    public struct IdMappingWorkflowOutputSource: AWSEncodableShape & AWSDecodableShape {
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public let kmsArn: String?
        /// The S3 path to which Entity Resolution will write the output table.
        public let outputS3Path: String

        public init(kmsArn: String? = nil, outputS3Path: String) {
            self.kmsArn = kmsArn
            self.outputS3Path = outputS3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "^arn:aws:kms:.*:[0-9]+:.*$")
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, max: 1024)
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, min: 1)
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsArn = "KMSArn"
            case outputS3Path = "outputS3Path"
        }
    }

    public struct IdMappingWorkflowSummary: AWSDecodableShape {
        /// The timestamp of when the workflow was created.
        public let createdAt: Date
        /// The timestamp of when the workflow was last updated.
        public let updatedAt: Date
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IdMappingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(createdAt: Date, updatedAt: Date, workflowArn: String, workflowName: String) {
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case updatedAt = "updatedAt"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct IncrementalRunConfig: AWSEncodableShape & AWSDecodableShape {
        /// The type of incremental run. It takes only one value: IMMEDIATE.
        public let incrementalRunType: IncrementalRunType?

        public init(incrementalRunType: IncrementalRunType? = nil) {
            self.incrementalRunType = incrementalRunType
        }

        private enum CodingKeys: String, CodingKey {
            case incrementalRunType = "incrementalRunType"
        }
    }

    public struct InputSource: AWSEncodableShape & AWSDecodableShape {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public let applyNormalization: Bool?
        /// An Glue table ARN for the input source table.
        public let inputSourceARN: String
        /// The name of the schema to be retrieved.
        public let schemaName: String

        public init(applyNormalization: Bool? = nil, inputSourceARN: String, schemaName: String) {
            self.applyNormalization = applyNormalization
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case applyNormalization = "applyNormalization"
            case inputSourceARN = "inputSourceARN"
            case schemaName = "schemaName"
        }
    }

    public struct IntermediateSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 location (bucket and prefix). For example: s3://provider_bucket/DOC-EXAMPLE-BUCKET
        public let intermediateS3Path: String

        public init(intermediateS3Path: String) {
            self.intermediateS3Path = intermediateS3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.intermediateS3Path, name: "intermediateS3Path", parent: name, max: 1024)
            try self.validate(self.intermediateS3Path, name: "intermediateS3Path", parent: name, min: 1)
            try self.validate(self.intermediateS3Path, name: "intermediateS3Path", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case intermediateS3Path = "intermediateS3Path"
        }
    }

    public struct JobMetrics: AWSDecodableShape {
        /// The total number of input records.
        public let inputRecords: Int?
        /// The total number of matchIDs generated.
        public let matchIDs: Int?
        /// The total number of records that did not get processed.
        public let recordsNotProcessed: Int?
        /// The total number of records processed.
        public let totalRecordsProcessed: Int?

        public init(inputRecords: Int? = nil, matchIDs: Int? = nil, recordsNotProcessed: Int? = nil, totalRecordsProcessed: Int? = nil) {
            self.inputRecords = inputRecords
            self.matchIDs = matchIDs
            self.recordsNotProcessed = recordsNotProcessed
            self.totalRecordsProcessed = totalRecordsProcessed
        }

        private enum CodingKeys: String, CodingKey {
            case inputRecords = "inputRecords"
            case matchIDs = "matchIDs"
            case recordsNotProcessed = "recordsNotProcessed"
            case totalRecordsProcessed = "totalRecordsProcessed"
        }
    }

    public struct JobSummary: AWSDecodableShape {
        /// The time at which the job has finished.
        public let endTime: Date?
        /// The ID of the job.
        public let jobId: String
        /// The time at which the job was started.
        public let startTime: Date
        /// The current status of the job.
        public let status: JobStatus

        public init(endTime: Date? = nil, jobId: String, startTime: Date, status: JobStatus) {
            self.endTime = endTime
            self.jobId = jobId
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case jobId = "jobId"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct ListIdMappingJobsInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// The name of the workflow to be retrieved.
        public let workflowName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workflowName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdMappingJobsOutput: AWSDecodableShape {
        /// A list of JobSummary objects.
        public let jobs: [JobSummary]?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(jobs: [JobSummary]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListIdMappingWorkflowsInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdMappingWorkflowsOutput: AWSDecodableShape {
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// A list of IdMappingWorkflowSummary objects.
        public let workflowSummaries: [IdMappingWorkflowSummary]?

        public init(nextToken: String? = nil, workflowSummaries: [IdMappingWorkflowSummary]? = nil) {
            self.nextToken = nextToken
            self.workflowSummaries = workflowSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workflowSummaries = "workflowSummaries"
        }
    }

    public struct ListMatchingJobsInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// The name of the workflow to be retrieved.
        public let workflowName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workflowName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMatchingJobsOutput: AWSDecodableShape {
        /// A list of JobSummary objects, each of which contain the ID, status, start time, and end time of a job.
        public let jobs: [JobSummary]?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(jobs: [JobSummary]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListMatchingWorkflowsInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMatchingWorkflowsOutput: AWSDecodableShape {
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// A list of MatchingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, and UpdatedAt.
        public let workflowSummaries: [MatchingWorkflowSummary]?

        public init(nextToken: String? = nil, workflowSummaries: [MatchingWorkflowSummary]? = nil) {
            self.nextToken = nextToken
            self.workflowSummaries = workflowSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workflowSummaries = "workflowSummaries"
        }
    }

    public struct ListProviderServicesInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// The name of the provider. This name is typically the company name.
        public let providerName: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, providerName: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.providerName = providerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.providerName, key: "providerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
            try self.validate(self.providerName, name: "providerName", parent: name, max: 255)
            try self.validate(self.providerName, name: "providerName", parent: name, min: 1)
            try self.validate(self.providerName, name: "providerName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProviderServicesOutput: AWSDecodableShape {
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// A list of ProviderServices objects.
        public let providerServiceSummaries: [ProviderServiceSummary]?

        public init(nextToken: String? = nil, providerServiceSummaries: [ProviderServiceSummary]? = nil) {
            self.nextToken = nextToken
            self.providerServiceSummaries = providerServiceSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case providerServiceSummaries = "providerServiceSummaries"
        }
    }

    public struct ListSchemaMappingsInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemaMappingsOutput: AWSDecodableShape {
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// A list of SchemaMappingSummary objects, each of which contain the fields SchemaName, SchemaArn, CreatedAt, UpdatedAt.
        public let schemaList: [SchemaMappingSummary]?

        public init(nextToken: String? = nil, schemaList: [SchemaMappingSummary]? = nil) {
            self.nextToken = nextToken
            self.schemaList = schemaList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case schemaList = "schemaList"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The ARN of the resource for which you want to view tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):(entityresolution):.*:[0-9]+:((schemamapping|matchingworkflow|idmappingworkflow)/[a-zA-Z0-9_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MatchingWorkflowSummary: AWSDecodableShape {
        /// The timestamp of when the workflow was created.
        public let createdAt: Date
        /// The method that has been specified for data matching, either using matching provided by Entity Resolution or through a provider service.
        public let resolutionType: ResolutionType
        /// The timestamp of when the workflow was last updated.
        public let updatedAt: Date
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(createdAt: Date, resolutionType: ResolutionType, updatedAt: Date, workflowArn: String, workflowName: String) {
            self.createdAt = createdAt
            self.resolutionType = resolutionType
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case resolutionType = "resolutionType"
            case updatedAt = "updatedAt"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct OutputAttribute: AWSEncodableShape & AWSDecodableShape {
        /// Enables the ability to hash the column values in the output.
        public let hashed: Bool?
        /// A name of a column to be written to the output. This must be an InputField name in the schema mapping.
        public let name: String

        public init(hashed: Bool? = nil, name: String) {
            self.hashed = hashed
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case hashed = "hashed"
            case name = "name"
        }
    }

    public struct OutputSource: AWSEncodableShape & AWSDecodableShape {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public let applyNormalization: Bool?
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public let kmsArn: String?
        /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
        public let output: [OutputAttribute]
        /// The S3 path to which Entity Resolution will write the output table.
        public let outputS3Path: String

        public init(applyNormalization: Bool? = nil, kmsArn: String? = nil, output: [OutputAttribute], outputS3Path: String) {
            self.applyNormalization = applyNormalization
            self.kmsArn = kmsArn
            self.output = output
            self.outputS3Path = outputS3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "^arn:aws:kms:.*:[0-9]+:.*$")
            try self.output.forEach {
                try $0.validate(name: "\(name).output[]")
            }
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, max: 1024)
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, min: 1)
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case applyNormalization = "applyNormalization"
            case kmsArn = "KMSArn"
            case output = "output"
            case outputS3Path = "outputS3Path"
        }
    }

    public struct ProviderIntermediateDataAccessConfiguration: AWSDecodableShape {
        /// The Amazon Web Services account that provider can use to read or write data into the customer's intermediate S3 bucket.
        public let awsAccountIds: [String]?
        /// The S3 bucket actions that the provider requires permission for.
        public let requiredBucketActions: [String]?

        public init(awsAccountIds: [String]? = nil, requiredBucketActions: [String]? = nil) {
            self.awsAccountIds = awsAccountIds
            self.requiredBucketActions = requiredBucketActions
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountIds = "awsAccountIds"
            case requiredBucketActions = "requiredBucketActions"
        }
    }

    public struct ProviderMarketplaceConfiguration: AWSDecodableShape {
        /// The asset ID on Data Exchange.
        public let assetId: String
        /// The dataset ID on Data Exchange.
        public let dataSetId: String
        /// The listing ID on Data Exchange.
        public let listingId: String
        /// The revision ID on Data Exchange.
        public let revisionId: String

        public init(assetId: String, dataSetId: String, listingId: String, revisionId: String) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.listingId = listingId
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case dataSetId = "dataSetId"
            case listingId = "listingId"
            case revisionId = "revisionId"
        }
    }

    public struct ProviderProperties: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
        public let intermediateSourceConfiguration: IntermediateSourceConfiguration?
        /// The required configuration fields to use with the provider service.
        public let providerConfiguration: String?
        /// The ARN of the provider service.
        public let providerServiceArn: String

        public init(intermediateSourceConfiguration: IntermediateSourceConfiguration? = nil, providerConfiguration: String? = nil, providerServiceArn: String) {
            self.intermediateSourceConfiguration = intermediateSourceConfiguration
            self.providerConfiguration = providerConfiguration
            self.providerServiceArn = providerServiceArn
        }

        public func validate(name: String) throws {
            try self.intermediateSourceConfiguration?.validate(name: "\(name).intermediateSourceConfiguration")
            try self.validate(self.providerServiceArn, name: "providerServiceArn", parent: name, max: 255)
            try self.validate(self.providerServiceArn, name: "providerServiceArn", parent: name, min: 20)
            try self.validate(self.providerServiceArn, name: "providerServiceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):(entityresolution):([a-z]{2}-[a-z-]+?-[0-9])::providerservice/([a-zA-Z0-9_-]+)/([a-zA-Z0-9_-]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case intermediateSourceConfiguration = "intermediateSourceConfiguration"
            case providerConfiguration = "providerConfiguration"
            case providerServiceArn = "providerServiceArn"
        }
    }

    public struct ProviderServiceSummary: AWSDecodableShape {
        /// The name of the provider. This name is typically the company name.
        public let providerName: String
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the providerService.
        public let providerServiceArn: String
        /// The display name of the provider service.
        public let providerServiceDisplayName: String
        /// The name of the product that the provider service provides.
        public let providerServiceName: String
        /// The type of provider service.
        public let providerServiceType: ServiceType

        public init(providerName: String, providerServiceArn: String, providerServiceDisplayName: String, providerServiceName: String, providerServiceType: ServiceType) {
            self.providerName = providerName
            self.providerServiceArn = providerServiceArn
            self.providerServiceDisplayName = providerServiceDisplayName
            self.providerServiceName = providerServiceName
            self.providerServiceType = providerServiceType
        }

        private enum CodingKeys: String, CodingKey {
            case providerName = "providerName"
            case providerServiceArn = "providerServiceArn"
            case providerServiceDisplayName = "providerServiceDisplayName"
            case providerServiceName = "providerServiceName"
            case providerServiceType = "providerServiceType"
        }
    }

    public struct ResolutionTechniques: AWSEncodableShape & AWSDecodableShape {
        /// The properties of the provider service.
        public let providerProperties: ProviderProperties?
        /// The type of matching. There are two types of matching: RULE_MATCHING and ML_MATCHING.
        public let resolutionType: ResolutionType
        /// An object which defines the list of matching rules to run and has a field Rules, which is a list of rule objects.
        public let ruleBasedProperties: RuleBasedProperties?

        public init(providerProperties: ProviderProperties? = nil, resolutionType: ResolutionType, ruleBasedProperties: RuleBasedProperties? = nil) {
            self.providerProperties = providerProperties
            self.resolutionType = resolutionType
            self.ruleBasedProperties = ruleBasedProperties
        }

        public func validate(name: String) throws {
            try self.providerProperties?.validate(name: "\(name).providerProperties")
            try self.ruleBasedProperties?.validate(name: "\(name).ruleBasedProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case providerProperties = "providerProperties"
            case resolutionType = "resolutionType"
            case ruleBasedProperties = "ruleBasedProperties"
        }
    }

    public struct Rule: AWSEncodableShape & AWSDecodableShape {
        /// A list of MatchingKeys. The MatchingKeys must have been defined in the SchemaMapping. Two records are considered to match according to this rule if all of the MatchingKeys match.
        public let matchingKeys: [String]
        /// A name for the matching rule.
        public let ruleName: String

        public init(matchingKeys: [String], ruleName: String) {
            self.matchingKeys = matchingKeys
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.matchingKeys.forEach {
                try validate($0, name: "matchingKeys[]", parent: name, max: 255)
                try validate($0, name: "matchingKeys[]", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case matchingKeys = "matchingKeys"
            case ruleName = "ruleName"
        }
    }

    public struct RuleBasedProperties: AWSEncodableShape & AWSDecodableShape {
        /// The comparison type. You can either choose ONE_TO_ONE or MANY_TO_MANY as the AttributeMatchingModel. When choosing MANY_TO_MANY, the system can match attributes across the sub-types of an attribute type. For example, if the value of the Email field of Profile A and the value of BusinessEmail field of Profile B matches, the two profiles are matched on the Email type. When choosing ONE_TO_ONE ,the system can only match if the sub-types are exact matches. For example, only when the value of the Email field of Profile A and the value of the Email field of Profile B matches, the two profiles are matched on the Email type.
        public let attributeMatchingModel: AttributeMatchingModel
        /// A list of Rule objects, each of which have fields RuleName and MatchingKeys.
        public let rules: [Rule]

        public init(attributeMatchingModel: AttributeMatchingModel, rules: [Rule]) {
            self.attributeMatchingModel = attributeMatchingModel
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributeMatchingModel = "attributeMatchingModel"
            case rules = "rules"
        }
    }

    public struct SchemaInputAttribute: AWSEncodableShape & AWSDecodableShape {
        /// A string containing the field name.
        public let fieldName: String
        /// Instruct Entity Resolution to combine several columns into a unified column with the identical attribute type. For example, when working with columns such as first_name, middle_name, and last_name, assigning them a common GroupName will prompt Entity Resolution to concatenate them into a single value.
        public let groupName: String?
        /// A key that allows grouping of multiple input attributes into a unified matching group. For example, let's consider a scenario where the source table contains various addresses, such as business_address and shipping_address. By assigning the MatchKey Address to both attributes, Entity Resolution will match records across these fields to create a consolidated matching group. If no MatchKey is specified for a column, it won't be utilized for matching purposes but will still be included in the output table.
        public let matchKey: String?
        /// The subtype of the attribute, selected from a list of values.
        public let subType: String?
        /// The type of the attribute, selected from a list of values.
        public let type: SchemaAttributeType

        public init(fieldName: String, groupName: String? = nil, matchKey: String? = nil, subType: String? = nil, type: SchemaAttributeType) {
            self.fieldName = fieldName
            self.groupName = groupName
            self.matchKey = matchKey
            self.subType = subType
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 255)
            try self.validate(self.fieldName, name: "fieldName", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 255)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
            try self.validate(self.matchKey, name: "matchKey", parent: name, max: 255)
            try self.validate(self.matchKey, name: "matchKey", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
            try self.validate(self.subType, name: "subType", parent: name, max: 255)
            try self.validate(self.subType, name: "subType", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "fieldName"
            case groupName = "groupName"
            case matchKey = "matchKey"
            case subType = "subType"
            case type = "type"
        }
    }

    public struct SchemaMappingSummary: AWSDecodableShape {
        /// The timestamp of when the SchemaMapping was created.
        public let createdAt: Date
        /// Specifies whether the schema mapping has been applied to a workflow.
        public let hasWorkflows: Bool
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        public let schemaArn: String
        /// The name of the schema.
        public let schemaName: String
        /// The timestamp of when the SchemaMapping was last updated.
        public let updatedAt: Date

        public init(createdAt: Date, hasWorkflows: Bool, schemaArn: String, schemaName: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.hasWorkflows = hasWorkflows
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case hasWorkflows = "hasWorkflows"
            case schemaArn = "schemaArn"
            case schemaName = "schemaName"
            case updatedAt = "updatedAt"
        }
    }

    public struct StartIdMappingJobInput: AWSEncodableShape {
        /// The name of the ID mapping job to be retrieved.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartIdMappingJobOutput: AWSDecodableShape {
        /// The ID of the job.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct StartMatchingJobInput: AWSEncodableShape {
        /// The name of the matching job to be retrieved.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartMatchingJobOutput: AWSDecodableShape {
        /// The ID of the job.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The ARN of the resource for which you want to view tags.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):(entityresolution):.*:[0-9]+:((schemamapping|matchingworkflow|idmappingworkflow)/[a-zA-Z0-9_-]+)$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The ARN of the resource for which you want to untag.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):(entityresolution):.*:[0-9]+:((schemamapping|matchingworkflow|idmappingworkflow)/[a-zA-Z0-9_-]+)$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateIdMappingWorkflowInput: AWSEncodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines the idMappingType and the providerProperties.
        public let idMappingTechniques: IdMappingTechniques
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdMappingWorkflowInputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
        public let outputSourceConfig: [IdMappingWorkflowOutputSource]
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access resources on your behalf.
        public let roleArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, idMappingTechniques: IdMappingTechniques, inputSourceConfig: [IdMappingWorkflowInputSource], outputSourceConfig: [IdMappingWorkflowOutputSource], roleArn: String, workflowName: String) {
            self.description = description
            self.idMappingTechniques = idMappingTechniques
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.roleArn = roleArn
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.idMappingTechniques, forKey: .idMappingTechniques)
            try container.encode(self.inputSourceConfig, forKey: .inputSourceConfig)
            try container.encode(self.outputSourceConfig, forKey: .outputSourceConfig)
            try container.encode(self.roleArn, forKey: .roleArn)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.idMappingTechniques.validate(name: "\(name).idMappingTechniques")
            try self.inputSourceConfig.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, min: 1)
            try self.outputSourceConfig.forEach {
                try $0.validate(name: "\(name).outputSourceConfig[]")
            }
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, max: 1)
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingTechniques = "idMappingTechniques"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateIdMappingWorkflowOutput: AWSDecodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines the idMappingType and the providerProperties.
        public let idMappingTechniques: IdMappingTechniques
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdMappingWorkflowInputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
        public let outputSourceConfig: [IdMappingWorkflowOutputSource]
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access resources on your behalf.
        public let roleArn: String
        /// The Amazon Resource Name (ARN) of the workflow role. Entity Resolution assumes this role to access resources on your behalf.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, idMappingTechniques: IdMappingTechniques, inputSourceConfig: [IdMappingWorkflowInputSource], outputSourceConfig: [IdMappingWorkflowOutputSource], roleArn: String, workflowArn: String, workflowName: String) {
            self.description = description
            self.idMappingTechniques = idMappingTechniques
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.roleArn = roleArn
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingTechniques = "idMappingTechniques"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case roleArn = "roleArn"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct UpdateMatchingWorkflowInput: AWSEncodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The name of the workflow to be retrieved.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.incrementalRunConfig, forKey: .incrementalRunConfig)
            try container.encode(self.inputSourceConfig, forKey: .inputSourceConfig)
            try container.encode(self.outputSourceConfig, forKey: .outputSourceConfig)
            try container.encode(self.resolutionTechniques, forKey: .resolutionTechniques)
            try container.encode(self.roleArn, forKey: .roleArn)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.inputSourceConfig.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, min: 1)
            try self.outputSourceConfig.forEach {
                try $0.validate(name: "\(name).outputSourceConfig[]")
            }
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, max: 1)
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, min: 1)
            try self.resolutionTechniques.validate(name: "\(name).resolutionTechniques")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateMatchingWorkflowOutput: AWSDecodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case workflowName = "workflowName"
        }
    }

    public struct UpdateSchemaMappingInput: AWSEncodableShape {
        /// A description of the schema.
        public let description: String?
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The name of the schema. There can't be multiple SchemaMappings with the same name.
        public let schemaName: String

        public init(description: String? = nil, mappedInputFields: [SchemaInputAttribute], schemaName: String) {
            self.description = description
            self.mappedInputFields = mappedInputFields
            self.schemaName = schemaName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.mappedInputFields, forKey: .mappedInputFields)
            request.encodePath(self.schemaName, key: "schemaName")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.mappedInputFields.forEach {
                try $0.validate(name: "\(name).mappedInputFields[]")
            }
            try self.validate(self.mappedInputFields, name: "mappedInputFields", parent: name, max: 25)
            try self.validate(self.mappedInputFields, name: "mappedInputFields", parent: name, min: 2)
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case mappedInputFields = "mappedInputFields"
        }
    }

    public struct UpdateSchemaMappingOutput: AWSDecodableShape {
        /// A description of the schema.
        public let description: String?
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        public let schemaArn: String
        /// The name of the schema.
        public let schemaName: String

        public init(description: String? = nil, mappedInputFields: [SchemaInputAttribute], schemaArn: String, schemaName: String) {
            self.description = description
            self.mappedInputFields = mappedInputFields
            self.schemaArn = schemaArn
            self.schemaName = schemaName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case mappedInputFields = "mappedInputFields"
            case schemaArn = "schemaArn"
            case schemaName = "schemaName"
        }
    }

    public struct ProviderEndpointConfiguration: AWSDecodableShape {
        /// The identifiers of the provider service, from Data Exchange.
        public let marketplaceConfiguration: ProviderMarketplaceConfiguration?

        public init(marketplaceConfiguration: ProviderMarketplaceConfiguration? = nil) {
            self.marketplaceConfiguration = marketplaceConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case marketplaceConfiguration = "marketplaceConfiguration"
        }
    }
}

// MARK: - Errors

/// Error enum for EntityResolution
public struct EntityResolutionErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case exceedsLimitException = "ExceedsLimitException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize EntityResolution
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action. HTTP Status Code: 403
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be processed because of conflict in the current state of the resource. Example: Workflow already exists, Schema already exists, Workflow is currently running, etc. HTTP Status Code: 400
    public static var conflictException: Self { .init(.conflictException) }
    /// The request was rejected because it attempted to create resources beyond the current Entity Resolution account limits. The error message describes the limit exceeded. HTTP Status Code: 402
    public static var exceedsLimitException: Self { .init(.exceedsLimitException) }
    /// This exception occurs when there is an internal failure in the Entity Resolution service. HTTP Status Code: 500
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource could not be found. HTTP Status Code: 404
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling. HTTP Status Code: 429
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by Entity Resolution. HTTP Status Code: 400
    public static var validationException: Self { .init(.validationException) }
}

extension EntityResolutionErrorType: Equatable {
    public static func == (lhs: EntityResolutionErrorType, rhs: EntityResolutionErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension EntityResolutionErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
