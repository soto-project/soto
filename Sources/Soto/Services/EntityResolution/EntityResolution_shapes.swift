//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if compiler(>=5.7) && os(Linux)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
import SotoCore

extension EntityResolution {
    // MARK: Enums

    public enum AttributeMatchingModel: String, CustomStringConvertible, Codable, Sendable {
        case manyToMany = "MANY_TO_MANY"
        case oneToOne = "ONE_TO_ONE"
        public var description: String { return self.rawValue }
    }

    public enum IncrementalRunType: String, CustomStringConvertible, Codable, Sendable {
        case immediate = "IMMEDIATE"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable {
        case failed = "FAILED"
        case queued = "QUEUED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ResolutionType: String, CustomStringConvertible, Codable, Sendable {
        case mlMatching = "ML_MATCHING"
        case ruleMatching = "RULE_MATCHING"
        public var description: String { return self.rawValue }
    }

    public enum SchemaAttributeType: String, CustomStringConvertible, Codable, Sendable {
        case address = "ADDRESS"
        case addressCity = "ADDRESS_CITY"
        case addressCountry = "ADDRESS_COUNTRY"
        case addressPostalcode = "ADDRESS_POSTALCODE"
        case addressState = "ADDRESS_STATE"
        case addressStreet1 = "ADDRESS_STREET1"
        case addressStreet2 = "ADDRESS_STREET2"
        case addressStreet3 = "ADDRESS_STREET3"
        case date = "DATE"
        case emailAddress = "EMAIL_ADDRESS"
        case name = "NAME"
        case nameFirst = "NAME_FIRST"
        case nameLast = "NAME_LAST"
        case nameMiddle = "NAME_MIDDLE"
        case phone = "PHONE"
        case phoneCountrycode = "PHONE_COUNTRYCODE"
        case phoneNumber = "PHONE_NUMBER"
        case string = "STRING"
        case uniqueId = "UNIQUE_ID"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateMatchingWorkflowInput: AWSEncodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and  SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path,  ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The name of the workflow. There cannot be multiple DataIntegrationWorkflows with the same name.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, tags: [String: String]? = nil, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.tags = tags
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.inputSourceConfig.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, min: 1)
            try self.outputSourceConfig.forEach {
                try $0.validate(name: "\(name).outputSourceConfig[]")
            }
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, max: 1)
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, min: 1)
            try self.resolutionTechniques.validate(name: "\(name).resolutionTechniques")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case tags = "tags"
            case workflowName = "workflowName"
        }
    }

    public struct CreateMatchingWorkflowOutput: AWSDecodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and  SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path,  ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, workflowArn: String, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct CreateSchemaMappingInput: AWSEncodableShape {
        /// A description of the schema.
        public let description: String?
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The name of the schema. There cannot be multiple SchemaMappings with the same name.
        public let schemaName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(description: String? = nil, mappedInputFields: [SchemaInputAttribute], schemaName: String, tags: [String: String]? = nil) {
            self.description = description
            self.mappedInputFields = mappedInputFields
            self.schemaName = schemaName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.mappedInputFields.forEach {
                try $0.validate(name: "\(name).mappedInputFields[]")
            }
            try self.validate(self.mappedInputFields, name: "mappedInputFields", parent: name, max: 25)
            try self.validate(self.mappedInputFields, name: "mappedInputFields", parent: name, min: 2)
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case mappedInputFields = "mappedInputFields"
            case schemaName = "schemaName"
            case tags = "tags"
        }
    }

    public struct CreateSchemaMappingOutput: AWSDecodableShape {
        /// A description of the schema.
        public let description: String
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        public let schemaArn: String
        /// The name of the schema.
        public let schemaName: String

        public init(description: String, mappedInputFields: [SchemaInputAttribute], schemaArn: String, schemaName: String) {
            self.description = description
            self.mappedInputFields = mappedInputFields
            self.schemaArn = schemaArn
            self.schemaName = schemaName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case mappedInputFields = "mappedInputFields"
            case schemaArn = "schemaArn"
            case schemaName = "schemaName"
        }
    }

    public struct DeleteMatchingWorkflowInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workflowName", location: .uri("workflowName"))
        ]

        /// The name of the workflow to be retrieved.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMatchingWorkflowOutput: AWSDecodableShape {
        /// A successful operation message.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DeleteSchemaMappingInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "schemaName", location: .uri("schemaName"))
        ]

        /// The name of the schema to delete.
        public let schemaName: String

        public init(schemaName: String) {
            self.schemaName = schemaName
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSchemaMappingOutput: AWSDecodableShape {
        /// A successful operation message.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error message from the job, if there is one.
        public let errorMessage: String?

        public init(errorMessage: String? = nil) {
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
        }
    }

    public struct GetMatchIdInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workflowName", location: .uri("workflowName"))
        ]

        /// The record to fetch the Match ID for.
        public let record: [String: String]
        /// The name of the workflow.
        public let workflowName: String

        public init(record: [String: String], workflowName: String) {
            self.record = record
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case record = "record"
        }
    }

    public struct GetMatchIdOutput: AWSDecodableShape {
        /// The unique identifiers for this group of match records.
        public let matchId: String?

        public init(matchId: String? = nil) {
            self.matchId = matchId
        }

        private enum CodingKeys: String, CodingKey {
            case matchId = "matchId"
        }
    }

    public struct GetMatchingJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri("jobId")),
            AWSMemberEncoding(label: "workflowName", location: .uri("workflowName"))
        ]

        /// The ID of the job.
        public let jobId: String
        /// The name of the workflow.
        public let workflowName: String

        public init(jobId: String, workflowName: String) {
            self.jobId = jobId
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMatchingJobOutput: AWSDecodableShape {
        /// The time at which the job has finished.
        public let endTime: Date?
        /// An object containing an error message, if there was an error.
        public let errorDetails: ErrorDetails?
        /// The ID of the job.
        public let jobId: String
        /// Metrics associated with the execution, specifically total records processed,  unique IDs generated, and records the execution skipped.
        public let metrics: JobMetrics?
        /// The time at which the job was started.
        public let startTime: Date
        /// The current status of the job.
        public let status: JobStatus

        public init(endTime: Date? = nil, errorDetails: ErrorDetails? = nil, jobId: String, metrics: JobMetrics? = nil, startTime: Date, status: JobStatus) {
            self.endTime = endTime
            self.errorDetails = errorDetails
            self.jobId = jobId
            self.metrics = metrics
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case errorDetails = "errorDetails"
            case jobId = "jobId"
            case metrics = "metrics"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct GetMatchingWorkflowInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workflowName", location: .uri("workflowName"))
        ]

        /// The name of the workflow.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMatchingWorkflowOutput: AWSDecodableShape {
        /// The timestamp of when the workflow was created.
        public let createdAt: Date
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and  SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path,  ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access  resources on your behalf.
        public let roleArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The timestamp of when the workflow was last updated.
        public let updatedAt: Date
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(createdAt: Date, description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, tags: [String: String]? = nil, updatedAt: Date, workflowArn: String, workflowName: String) {
            self.createdAt = createdAt
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.tags = tags
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case tags = "tags"
            case updatedAt = "updatedAt"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct GetSchemaMappingInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "schemaName", location: .uri("schemaName"))
        ]

        /// The name of the schema to be retrieved.
        public let schemaName: String

        public init(schemaName: String) {
            self.schemaName = schemaName
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaMappingOutput: AWSDecodableShape {
        /// The timestamp of when the SchemaMapping was created.
        public let createdAt: Date
        /// A description of the schema.
        public let description: String?
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information Venice uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        public let schemaArn: String
        /// The name of the schema.
        public let schemaName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The timestamp of when the SchemaMapping was last updated.
        public let updatedAt: Date

        public init(createdAt: Date, description: String? = nil, mappedInputFields: [SchemaInputAttribute], schemaArn: String, schemaName: String, tags: [String: String]? = nil, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.mappedInputFields = mappedInputFields
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case mappedInputFields = "mappedInputFields"
            case schemaArn = "schemaArn"
            case schemaName = "schemaName"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct IncrementalRunConfig: AWSEncodableShape & AWSDecodableShape {
        /// The type of incremental run. It takes only one value: IMMEDIATE.
        public let incrementalRunType: IncrementalRunType?

        public init(incrementalRunType: IncrementalRunType? = nil) {
            self.incrementalRunType = incrementalRunType
        }

        private enum CodingKeys: String, CodingKey {
            case incrementalRunType = "incrementalRunType"
        }
    }

    public struct InputSource: AWSEncodableShape & AWSDecodableShape {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public let applyNormalization: Bool?
        /// An Glue table ARN for the input source table.
        public let inputSourceARN: String
        /// The name of the schema to be retrieved.
        public let schemaName: String

        public init(applyNormalization: Bool? = nil, inputSourceARN: String, schemaName: String) {
            self.applyNormalization = applyNormalization
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case applyNormalization = "applyNormalization"
            case inputSourceARN = "inputSourceARN"
            case schemaName = "schemaName"
        }
    }

    public struct JobMetrics: AWSDecodableShape {
        /// The total number of input records.
        public let inputRecords: Int?
        /// The total number of matchIDs generated.
        public let matchIDs: Int?
        /// The total number of records that did not get processed.
        public let recordsNotProcessed: Int?
        /// The total number of records processed.
        public let totalRecordsProcessed: Int?

        public init(inputRecords: Int? = nil, matchIDs: Int? = nil, recordsNotProcessed: Int? = nil, totalRecordsProcessed: Int? = nil) {
            self.inputRecords = inputRecords
            self.matchIDs = matchIDs
            self.recordsNotProcessed = recordsNotProcessed
            self.totalRecordsProcessed = totalRecordsProcessed
        }

        private enum CodingKeys: String, CodingKey {
            case inputRecords = "inputRecords"
            case matchIDs = "matchIDs"
            case recordsNotProcessed = "recordsNotProcessed"
            case totalRecordsProcessed = "totalRecordsProcessed"
        }
    }

    public struct JobSummary: AWSDecodableShape {
        /// The time at which the job has finished.
        public let endTime: Date?
        /// The ID of the job.
        public let jobId: String
        /// The time at which the job was started.
        public let startTime: Date
        /// The current status of the job.
        public let status: JobStatus

        public init(endTime: Date? = nil, jobId: String, startTime: Date, status: JobStatus) {
            self.endTime = endTime
            self.jobId = jobId
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case jobId = "jobId"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct ListMatchingJobsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "workflowName", location: .uri("workflowName"))
        ]

        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListSchemaMappings API call.
        public let nextToken: String?
        /// The name of the workflow to be retrieved.
        public let workflowName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workflowName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMatchingJobsOutput: AWSDecodableShape {
        /// A list of JobSummary objects, each of which contain the ID, status, start time, and end time of a job.
        public let jobs: [JobSummary]?
        /// The pagination token from the previous ListSchemaMappings API call.
        public let nextToken: String?

        public init(jobs: [JobSummary]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListMatchingWorkflowsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListSchemaMappings API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMatchingWorkflowsOutput: AWSDecodableShape {
        /// The pagination token from the previous ListSchemaMappings API call.
        public let nextToken: String?
        /// A list of MatchingWorkflowSummary objects, each of which contain the fields  WorkflowName, WorkflowArn, CreatedAt, and UpdatedAt.
        public let workflowSummaries: [MatchingWorkflowSummary]?

        public init(nextToken: String? = nil, workflowSummaries: [MatchingWorkflowSummary]? = nil) {
            self.nextToken = nextToken
            self.workflowSummaries = workflowSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workflowSummaries = "workflowSummaries"
        }
    }

    public struct ListSchemaMappingsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListSchemaMappings API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemaMappingsOutput: AWSDecodableShape {
        /// The pagination token from the previous ListDomains API call.
        public let nextToken: String?
        /// A list of SchemaMappingSummary objects, each of which contain the fields  SchemaName, SchemaArn, CreatedAt, UpdatedAt.
        public let schemaList: [SchemaMappingSummary]?

        public init(nextToken: String? = nil, schemaList: [SchemaMappingSummary]? = nil) {
            self.nextToken = nextToken
            self.schemaList = schemaList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case schemaList = "schemaList"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The ARN of the resource for which you want to view tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):(entityresolution):.*:[0-9]+:((schemamapping|matchingworkflow)/[a-zA-Z0-9_-]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MatchingWorkflowSummary: AWSDecodableShape {
        /// The timestamp of when the workflow was created.
        public let createdAt: Date
        /// The timestamp of when the workflow was last updated.
        public let updatedAt: Date
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(createdAt: Date, updatedAt: Date, workflowArn: String, workflowName: String) {
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case updatedAt = "updatedAt"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct OutputAttribute: AWSEncodableShape & AWSDecodableShape {
        /// Enables the ability to hash the column values in the output.
        public let hashed: Bool?
        /// A name of a column to be written to the output. This must be an InputField name  in the schema mapping.
        public let name: String

        public init(hashed: Bool? = nil, name: String) {
            self.hashed = hashed
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case hashed = "hashed"
            case name = "name"
        }
    }

    public struct OutputSource: AWSEncodableShape & AWSDecodableShape {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public let applyNormalization: Bool?
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an  Entity Resolution managed KMS key.
        public let kmsArn: String?
        /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
        public let output: [OutputAttribute]
        /// The S3 path to which Entity Resolution will write the output table.
        public let outputS3Path: String

        public init(applyNormalization: Bool? = nil, kmsArn: String? = nil, output: [OutputAttribute], outputS3Path: String) {
            self.applyNormalization = applyNormalization
            self.kmsArn = kmsArn
            self.output = output
            self.outputS3Path = outputS3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "^arn:aws:kms:.*:[0-9]+:.*$")
            try self.output.forEach {
                try $0.validate(name: "\(name).output[]")
            }
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, pattern: "^s3://([^/]+)/?(.*?([^/]+)/?)$")
        }

        private enum CodingKeys: String, CodingKey {
            case applyNormalization = "applyNormalization"
            case kmsArn = "KMSArn"
            case output = "output"
            case outputS3Path = "outputS3Path"
        }
    }

    public struct ResolutionTechniques: AWSEncodableShape & AWSDecodableShape {
        /// The type of matching. There are two types of matching: RULE_MATCHING and ML_MATCHING.
        public let resolutionType: ResolutionType
        /// An object which defines the list of matching rules to run and has a field Rules, which  is a list of rule objects.
        public let ruleBasedProperties: RuleBasedProperties?

        public init(resolutionType: ResolutionType, ruleBasedProperties: RuleBasedProperties? = nil) {
            self.resolutionType = resolutionType
            self.ruleBasedProperties = ruleBasedProperties
        }

        public func validate(name: String) throws {
            try self.ruleBasedProperties?.validate(name: "\(name).ruleBasedProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case resolutionType = "resolutionType"
            case ruleBasedProperties = "ruleBasedProperties"
        }
    }

    public struct Rule: AWSEncodableShape & AWSDecodableShape {
        /// A list of MatchingKeys. The MatchingKeys must have been defined in  the SchemaMapping. Two records are considered to match according to this rule if all  of the MatchingKeys match.
        public let matchingKeys: [String]
        /// A name for the matching rule.
        public let ruleName: String

        public init(matchingKeys: [String], ruleName: String) {
            self.matchingKeys = matchingKeys
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.matchingKeys.forEach {
                try validate($0, name: "matchingKeys[]", parent: name, max: 255)
                try validate($0, name: "matchingKeys[]", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case matchingKeys = "matchingKeys"
            case ruleName = "ruleName"
        }
    }

    public struct RuleBasedProperties: AWSEncodableShape & AWSDecodableShape {
        /// The comparison type. You can either choose ONE_TO_ONE or MANY_TO_MANY as the AttributeMatchingModel. When  choosing MANY_TO_MANY, the system can match attributes across the sub-types of an attribute type. For  example, if the value of the Email field of Profile A and the value of BusinessEmail field of Profile B matches,  the two profiles are matched on the Email type. When choosing ONE_TO_ONE ,the system can only match if  the sub-types are exact matches. For example, only when the value of the Email field of Profile A and the value of  the Email field of Profile B matches, the two profiles are matched on the Email type.
        public let attributeMatchingModel: AttributeMatchingModel
        /// A list of Rule objects, each of which have fields RuleName and MatchingKeys.
        public let rules: [Rule]

        public init(attributeMatchingModel: AttributeMatchingModel, rules: [Rule]) {
            self.attributeMatchingModel = attributeMatchingModel
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributeMatchingModel = "attributeMatchingModel"
            case rules = "rules"
        }
    }

    public struct SchemaInputAttribute: AWSEncodableShape & AWSDecodableShape {
        /// A string containing the field name.
        public let fieldName: String
        /// Instruct Entity Resolution to combine several columns into a unified column with the identical attribute type. For example, when working with columns such as first_name, middle_name, and last_name, assigning them a common GroupName will prompt Entity Resolution to concatenate them into a single value.
        public let groupName: String?
        /// A key that allows grouping of multiple input attributes into a unified matching group. For example, let's consider a scenario where the source table contains various addresses, such as business_address and shipping_address. By assigning the MatchKey Address to both attributes, Entity Resolution will match records across these fields to create a consolidated matching group. If no MatchKey is specified for a column, it won't be utilized for matching purposes but will still be included in the output table.
        public let matchKey: String?
        /// The type of the attribute, selected from a list of values.
        public let type: SchemaAttributeType

        public init(fieldName: String, groupName: String? = nil, matchKey: String? = nil, type: SchemaAttributeType) {
            self.fieldName = fieldName
            self.groupName = groupName
            self.matchKey = matchKey
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 255)
            try self.validate(self.fieldName, name: "fieldName", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 255)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
            try self.validate(self.matchKey, name: "matchKey", parent: name, max: 255)
            try self.validate(self.matchKey, name: "matchKey", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "fieldName"
            case groupName = "groupName"
            case matchKey = "matchKey"
            case type = "type"
        }
    }

    public struct SchemaMappingSummary: AWSDecodableShape {
        /// The timestamp of when the SchemaMapping was created.
        public let createdAt: Date
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        public let schemaArn: String
        /// The name of the schema.
        public let schemaName: String
        /// The timestamp of when the SchemaMapping was last updated.
        public let updatedAt: Date

        public init(createdAt: Date, schemaArn: String, schemaName: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case schemaArn = "schemaArn"
            case schemaName = "schemaName"
            case updatedAt = "updatedAt"
        }
    }

    public struct StartMatchingJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workflowName", location: .uri("workflowName"))
        ]

        /// The name of the matching job to be retrieved.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartMatchingJobOutput: AWSDecodableShape {
        /// The ID of the job.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The ARN of the resource for which you want to view tags.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):(entityresolution):.*:[0-9]+:((schemamapping|matchingworkflow)/[a-zA-Z0-9_-]+)$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The ARN of the resource for which you want to untag.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):(entityresolution):.*:[0-9]+:((schemamapping|matchingworkflow)/[a-zA-Z0-9_-]+)$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMatchingWorkflowInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workflowName", location: .uri("workflowName"))
        ]

        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and  SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path,  ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The name of the workflow to be retrieved.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.inputSourceConfig.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, min: 1)
            try self.outputSourceConfig.forEach {
                try $0.validate(name: "\(name).outputSourceConfig[]")
            }
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, max: 1)
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, min: 1)
            try self.resolutionTechniques.validate(name: "\(name).resolutionTechniques")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateMatchingWorkflowOutput: AWSDecodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and  SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path,  ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case workflowName = "workflowName"
        }
    }
}

// MARK: - Errors

/// Error enum for EntityResolution
public struct EntityResolutionErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case exceedsLimitException = "ExceedsLimitException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize EntityResolution
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action. HTTP Status Code: 403
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be processed because of conflict in the current state of the resource. Example: Workflow already exists,  Schema already exists, Workflow is currently running, etc.  HTTP Status Code: 400
    public static var conflictException: Self { .init(.conflictException) }
    /// The request was rejected because it attempted to create resources beyond the current Entity Resolution account limits.  The error message describes the limit exceeded. HTTP Status Code: 402
    public static var exceedsLimitException: Self { .init(.exceedsLimitException) }
    /// This exception occurs when there is an internal failure in the Entity Resolution service. HTTP Status Code: 500
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource could not be found. HTTP Status Code: 404
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling. HTTP Status Code: 429
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by Entity Resolution. HTTP Status Code: 400
    public static var validationException: Self { .init(.validationException) }
}

extension EntityResolutionErrorType: Equatable {
    public static func == (lhs: EntityResolutionErrorType, rhs: EntityResolutionErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension EntityResolutionErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
