//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension EntityResolution {
    // MARK: Enums

    public enum AttributeMatchingModel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case manyToMany = "MANY_TO_MANY"
        case oneToOne = "ONE_TO_ONE"
        public var description: String { return self.rawValue }
    }

    public enum DeleteUniqueIdErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case serviceError = "SERVICE_ERROR"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum DeleteUniqueIdStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accepted = "ACCEPTED"
        case completed = "COMPLETED"
        public var description: String { return self.rawValue }
    }

    public enum IdMappingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case provider = "PROVIDER"
        public var description: String { return self.rawValue }
    }

    public enum IdNamespaceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case source = "SOURCE"
        case target = "TARGET"
        public var description: String { return self.rawValue }
    }

    public enum IncrementalRunType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case immediate = "IMMEDIATE"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case queued = "QUEUED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ResolutionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mlMatching = "ML_MATCHING"
        case provider = "PROVIDER"
        case ruleMatching = "RULE_MATCHING"
        public var description: String { return self.rawValue }
    }

    public enum SchemaAttributeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case address = "ADDRESS"
        case addressCity = "ADDRESS_CITY"
        case addressCountry = "ADDRESS_COUNTRY"
        case addressPostalcode = "ADDRESS_POSTALCODE"
        case addressState = "ADDRESS_STATE"
        case addressStreet1 = "ADDRESS_STREET1"
        case addressStreet2 = "ADDRESS_STREET2"
        case addressStreet3 = "ADDRESS_STREET3"
        case date = "DATE"
        case emailAddress = "EMAIL_ADDRESS"
        case name = "NAME"
        case nameFirst = "NAME_FIRST"
        case nameLast = "NAME_LAST"
        case nameMiddle = "NAME_MIDDLE"
        case phone = "PHONE"
        case phoneCountrycode = "PHONE_COUNTRYCODE"
        case phoneNumber = "PHONE_NUMBER"
        case providerId = "PROVIDER_ID"
        case string = "STRING"
        case uniqueId = "UNIQUE_ID"
        public var description: String { return self.rawValue }
    }

    public enum ServiceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assignment = "ASSIGNMENT"
        case idMapping = "ID_MAPPING"
        public var description: String { return self.rawValue }
    }

    public enum StatementEffect: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "Allow"
        case deny = "Deny"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddPolicyStatementInput: AWSEncodableShape {
        /// The action that the principal can use on the resource.  For example, entityresolution:GetIdMappingJob, entityresolution:GetMatchingJob.
        public let action: [String]
        /// The Amazon Resource Name (ARN) of the resource that will be accessed by the principal.
        public let arn: String
        /// A set of condition keys that you can use in key policies.
        public let condition: String?
        /// Determines whether the permissions specified in the policy are to be allowed (Allow) or denied (Deny).
        public let effect: StatementEffect
        /// The Amazon Web Services service or Amazon Web Services account that can access the resource defined as ARN.
        public let principal: [String]
        /// A statement identifier that differentiates the statement from others in the same policy.
        public let statementId: String

        public init(action: [String], arn: String, condition: String? = nil, effect: StatementEffect, principal: [String], statementId: String) {
            self.action = action
            self.arn = arn
            self.condition = condition
            self.effect = effect
            self.principal = principal
            self.statementId = statementId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            request.encodePath(self.arn, key: "arn")
            try container.encodeIfPresent(self.condition, forKey: .condition)
            try container.encode(self.effect, forKey: .effect)
            try container.encode(self.principal, forKey: .principal)
            request.encodePath(self.statementId, key: "statementId")
        }

        public func validate(name: String) throws {
            try self.action.forEach {
                try validate($0, name: "action[]", parent: name, max: 64)
                try validate($0, name: "action[]", parent: name, min: 3)
                try validate($0, name: "action[]", parent: name, pattern: "^(entityresolution:[a-zA-Z0-9]+)$")
            }
            try self.validate(self.action, name: "action", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):entityresolution:[a-z]{2}-[a-z]{1,10}-[0-9]:[0-9]{12}:((schemamapping|matchingworkflow|idmappingworkflow|idnamespace)/[a-zA-Z_0-9-]{1,255})$")
            try self.validate(self.condition, name: "condition", parent: name, max: 40960)
            try self.validate(self.condition, name: "condition", parent: name, min: 1)
            try self.principal.forEach {
                try validate($0, name: "principal[]", parent: name, max: 64)
                try validate($0, name: "principal[]", parent: name, min: 12)
                try validate($0, name: "principal[]", parent: name, pattern: "^(\\d{12})|([a-z0-9\\.]+)$")
            }
            try self.validate(self.principal, name: "principal", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, max: 64)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "^[0-9A-Za-z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case condition = "condition"
            case effect = "effect"
            case principal = "principal"
        }
    }

    public struct AddPolicyStatementOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource that will be accessed by the principal.
        public let arn: String
        /// The resource-based policy.
        public let policy: String?
        /// A unique identifier for the current revision of the policy.
        public let token: String

        public init(arn: String, policy: String? = nil, token: String) {
            self.arn = arn
            self.policy = policy
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case policy = "policy"
            case token = "token"
        }
    }

    public struct BatchDeleteUniqueIdInput: AWSEncodableShape {
        /// The input source for the batch delete unique ID operation.
        public let inputSource: String?
        /// The unique IDs to delete.
        public let uniqueIds: [String]
        /// The name of the workflow.
        public let workflowName: String

        public init(inputSource: String? = nil, uniqueIds: [String], workflowName: String) {
            self.inputSource = inputSource
            self.uniqueIds = uniqueIds
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.inputSource, key: "inputSource")
            request.encodeHeader(self.uniqueIds, key: "uniqueIds")
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.uniqueIds.forEach {
                try validate($0, name: "uniqueIds[]", parent: name, max: 760)
                try validate($0, name: "uniqueIds[]", parent: name, min: 1)
                try validate($0, name: "uniqueIds[]", parent: name, pattern: "^[a-zA-Z_0-9-,]*$")
            }
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct BatchDeleteUniqueIdOutput: AWSDecodableShape {
        /// The unique IDs that were deleted.
        public let deleted: [DeletedUniqueId]
        /// The unique IDs that were disconnected.
        public let disconnectedUniqueIds: [String]
        ///  The errors from deleting multiple unique IDs.
        public let errors: [DeleteUniqueIdError]
        /// The status of the batch delete unique ID operation.
        public let status: DeleteUniqueIdStatus

        public init(deleted: [DeletedUniqueId], disconnectedUniqueIds: [String], errors: [DeleteUniqueIdError], status: DeleteUniqueIdStatus) {
            self.deleted = deleted
            self.disconnectedUniqueIds = disconnectedUniqueIds
            self.errors = errors
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case deleted = "deleted"
            case disconnectedUniqueIds = "disconnectedUniqueIds"
            case errors = "errors"
            case status = "status"
        }
    }

    public struct CreateIdMappingWorkflowInput: AWSEncodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines the idMappingType and the providerProperties.
        public let idMappingTechniques: IdMappingTechniques
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdMappingWorkflowInputSource]
        /// A list of IdMappingWorkflowOutputSource objects, each of which contains fields OutputS3Path and Output.
        public let outputSourceConfig: [IdMappingWorkflowOutputSource]?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The name of the workflow. There can't be multiple IdMappingWorkflows with the same name.
        public let workflowName: String

        public init(description: String? = nil, idMappingTechniques: IdMappingTechniques, inputSourceConfig: [IdMappingWorkflowInputSource], outputSourceConfig: [IdMappingWorkflowOutputSource]? = nil, roleArn: String, tags: [String: String]? = nil, workflowName: String) {
            self.description = description
            self.idMappingTechniques = idMappingTechniques
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.roleArn = roleArn
            self.tags = tags
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.idMappingTechniques.validate(name: "\(name).idMappingTechniques")
            try self.inputSourceConfig.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, min: 1)
            try self.outputSourceConfig?.forEach {
                try $0.validate(name: "\(name).outputSourceConfig[]")
            }
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, max: 1)
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingTechniques = "idMappingTechniques"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case roleArn = "roleArn"
            case tags = "tags"
            case workflowName = "workflowName"
        }
    }

    public struct CreateIdMappingWorkflowOutput: AWSDecodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines the idMappingType and the providerProperties.
        public let idMappingTechniques: IdMappingTechniques
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdMappingWorkflowInputSource]
        /// A list of IdMappingWorkflowOutputSource objects, each of which contains fields OutputS3Path and Output.
        public let outputSourceConfig: [IdMappingWorkflowOutputSource]?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IDMappingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, idMappingTechniques: IdMappingTechniques, inputSourceConfig: [IdMappingWorkflowInputSource], outputSourceConfig: [IdMappingWorkflowOutputSource]? = nil, roleArn: String, workflowArn: String, workflowName: String) {
            self.description = description
            self.idMappingTechniques = idMappingTechniques
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.roleArn = roleArn
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingTechniques = "idMappingTechniques"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case roleArn = "roleArn"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct CreateIdNamespaceInput: AWSEncodableShape {
        /// The description of the ID namespace.
        public let description: String?
        /// Determines the properties of IdMappingWorflow where this IdNamespace can be used as a Source or a Target.
        public let idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]?
        /// The name of the ID namespace.
        public let idNamespaceName: String
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdNamespaceInputSource]?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of the workflow run.
        public let roleArn: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of ID namespace. There are two types: SOURCE and TARGET.  The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow.  The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
        public let type: IdNamespaceType

        public init(description: String? = nil, idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]? = nil, idNamespaceName: String, inputSourceConfig: [IdNamespaceInputSource]? = nil, roleArn: String? = nil, tags: [String: String]? = nil, type: IdNamespaceType) {
            self.description = description
            self.idMappingWorkflowProperties = idMappingWorkflowProperties
            self.idNamespaceName = idNamespaceName
            self.inputSourceConfig = inputSourceConfig
            self.roleArn = roleArn
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.idMappingWorkflowProperties?.forEach {
                try $0.validate(name: "\(name).idMappingWorkflowProperties[]")
            }
            try self.validate(self.idMappingWorkflowProperties, name: "idMappingWorkflowProperties", parent: name, max: 1)
            try self.validate(self.idMappingWorkflowProperties, name: "idMappingWorkflowProperties", parent: name, min: 1)
            try self.validate(self.idNamespaceName, name: "idNamespaceName", parent: name, max: 255)
            try self.validate(self.idNamespaceName, name: "idNamespaceName", parent: name, min: 1)
            try self.validate(self.idNamespaceName, name: "idNamespaceName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
            try self.inputSourceConfig?.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingWorkflowProperties = "idMappingWorkflowProperties"
            case idNamespaceName = "idNamespaceName"
            case inputSourceConfig = "inputSourceConfig"
            case roleArn = "roleArn"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateIdNamespaceOutput: AWSDecodableShape {
        /// The timestamp of when the ID namespace was created.
        public let createdAt: Date
        /// The description of the ID namespace.
        public let description: String?
        /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
        public let idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]?
        /// The Amazon Resource Name (ARN) of the ID namespace.
        public let idNamespaceArn: String
        /// The name of the ID namespace.
        public let idNamespaceName: String
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdNamespaceInputSource]?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in inputSourceConfig on your behalf as part of the workflow run.
        public let roleArn: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow.  The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
        public let type: IdNamespaceType
        /// The timestamp of when the ID namespace was last updated.
        public let updatedAt: Date

        public init(createdAt: Date, description: String? = nil, idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]? = nil, idNamespaceArn: String, idNamespaceName: String, inputSourceConfig: [IdNamespaceInputSource]? = nil, roleArn: String? = nil, tags: [String: String]? = nil, type: IdNamespaceType, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.idMappingWorkflowProperties = idMappingWorkflowProperties
            self.idNamespaceArn = idNamespaceArn
            self.idNamespaceName = idNamespaceName
            self.inputSourceConfig = inputSourceConfig
            self.roleArn = roleArn
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case idMappingWorkflowProperties = "idMappingWorkflowProperties"
            case idNamespaceArn = "idNamespaceArn"
            case idNamespaceName = "idNamespaceName"
            case inputSourceConfig = "inputSourceConfig"
            case roleArn = "roleArn"
            case tags = "tags"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateMatchingWorkflowInput: AWSEncodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The name of the workflow. There can't be multiple MatchingWorkflows with the same name.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, tags: [String: String]? = nil, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.tags = tags
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.inputSourceConfig.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, min: 1)
            try self.outputSourceConfig.forEach {
                try $0.validate(name: "\(name).outputSourceConfig[]")
            }
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, max: 1)
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, min: 1)
            try self.resolutionTechniques.validate(name: "\(name).resolutionTechniques")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case tags = "tags"
            case workflowName = "workflowName"
        }
    }

    public struct CreateMatchingWorkflowOutput: AWSDecodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, workflowArn: String, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct CreateSchemaMappingInput: AWSEncodableShape {
        /// A description of the schema.
        public let description: String?
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The name of the schema. There can't be multiple SchemaMappings with the same name.
        public let schemaName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(description: String? = nil, mappedInputFields: [SchemaInputAttribute], schemaName: String, tags: [String: String]? = nil) {
            self.description = description
            self.mappedInputFields = mappedInputFields
            self.schemaName = schemaName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.mappedInputFields.forEach {
                try $0.validate(name: "\(name).mappedInputFields[]")
            }
            try self.validate(self.mappedInputFields, name: "mappedInputFields", parent: name, max: 25)
            try self.validate(self.mappedInputFields, name: "mappedInputFields", parent: name, min: 2)
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case mappedInputFields = "mappedInputFields"
            case schemaName = "schemaName"
            case tags = "tags"
        }
    }

    public struct CreateSchemaMappingOutput: AWSDecodableShape {
        /// A description of the schema.
        public let description: String
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        public let schemaArn: String
        /// The name of the schema.
        public let schemaName: String

        public init(description: String, mappedInputFields: [SchemaInputAttribute], schemaArn: String, schemaName: String) {
            self.description = description
            self.mappedInputFields = mappedInputFields
            self.schemaArn = schemaArn
            self.schemaName = schemaName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case mappedInputFields = "mappedInputFields"
            case schemaArn = "schemaArn"
            case schemaName = "schemaName"
        }
    }

    public struct DeleteIdMappingWorkflowInput: AWSEncodableShape {
        /// The name of the workflow to be deleted.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIdMappingWorkflowOutput: AWSDecodableShape {
        /// A successful operation message.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DeleteIdNamespaceInput: AWSEncodableShape {
        /// The name of the ID namespace.
        public let idNamespaceName: String

        public init(idNamespaceName: String) {
            self.idNamespaceName = idNamespaceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.idNamespaceName, key: "idNamespaceName")
        }

        public func validate(name: String) throws {
            try self.validate(self.idNamespaceName, name: "idNamespaceName", parent: name, max: 255)
            try self.validate(self.idNamespaceName, name: "idNamespaceName", parent: name, min: 1)
            try self.validate(self.idNamespaceName, name: "idNamespaceName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIdNamespaceOutput: AWSDecodableShape {
        /// A successful operation message.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DeleteMatchingWorkflowInput: AWSEncodableShape {
        /// The name of the workflow to be retrieved.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMatchingWorkflowOutput: AWSDecodableShape {
        /// A successful operation message.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DeletePolicyStatementInput: AWSEncodableShape {
        /// The ARN of the resource for which the policy need to be deleted.
        public let arn: String
        /// A statement identifier that differentiates the statement from others in the same policy.
        public let statementId: String

        public init(arn: String, statementId: String) {
            self.arn = arn
            self.statementId = statementId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            request.encodePath(self.statementId, key: "statementId")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):entityresolution:[a-z]{2}-[a-z]{1,10}-[0-9]:[0-9]{12}:((schemamapping|matchingworkflow|idmappingworkflow|idnamespace)/[a-zA-Z_0-9-]{1,255})$")
            try self.validate(self.statementId, name: "statementId", parent: name, max: 64)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "^[0-9A-Za-z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePolicyStatementOutput: AWSDecodableShape {
        /// The ARN of the resource for which the policy need to be deleted.
        public let arn: String
        /// The resource-based policy.
        public let policy: String?
        /// A unique identifier for the deleted policy.
        public let token: String

        public init(arn: String, policy: String? = nil, token: String) {
            self.arn = arn
            self.policy = policy
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case policy = "policy"
            case token = "token"
        }
    }

    public struct DeleteSchemaMappingInput: AWSEncodableShape {
        /// The name of the schema to delete.
        public let schemaName: String

        public init(schemaName: String) {
            self.schemaName = schemaName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.schemaName, key: "schemaName")
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSchemaMappingOutput: AWSDecodableShape {
        /// A successful operation message.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DeleteUniqueIdError: AWSDecodableShape {
        ///  The error type for the batch delete unique ID operation.
        public let errorType: DeleteUniqueIdErrorType
        /// The unique ID that could not be deleted.
        public let uniqueId: String

        public init(errorType: DeleteUniqueIdErrorType, uniqueId: String) {
            self.errorType = errorType
            self.uniqueId = uniqueId
        }

        private enum CodingKeys: String, CodingKey {
            case errorType = "errorType"
            case uniqueId = "uniqueId"
        }
    }

    public struct DeletedUniqueId: AWSDecodableShape {
        ///  The unique ID of the deleted item.
        public let uniqueId: String

        public init(uniqueId: String) {
            self.uniqueId = uniqueId
        }

        private enum CodingKeys: String, CodingKey {
            case uniqueId = "uniqueId"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error message from the job, if there is one.
        public let errorMessage: String?

        public init(errorMessage: String? = nil) {
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
        }
    }

    public struct GetIdMappingJobInput: AWSEncodableShape {
        /// The ID of the job.
        public let jobId: String
        /// The name of the workflow.
        public let workflowName: String

        public init(jobId: String, workflowName: String) {
            self.jobId = jobId
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$|^arn:(aws|aws-us-gov|aws-cn):entityresolution:[a-z]{2}-[a-z]{1,10}-[0-9]:[0-9]{12}:(idmappingworkflow/[a-zA-Z_0-9-]{1,255})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIdMappingJobOutput: AWSDecodableShape {
        /// The time at which the job has finished.
        public let endTime: Date?
        public let errorDetails: ErrorDetails?
        /// The ID of the job.
        public let jobId: String
        /// Metrics associated with the execution, specifically total records processed, unique IDs generated, and records the execution skipped.
        public let metrics: IdMappingJobMetrics?
        /// A list of OutputSource objects.
        public let outputSourceConfig: [IdMappingJobOutputSource]?
        /// The time at which the job was started.
        public let startTime: Date
        /// The current status of the job.
        public let status: JobStatus

        public init(endTime: Date? = nil, errorDetails: ErrorDetails? = nil, jobId: String, metrics: IdMappingJobMetrics? = nil, outputSourceConfig: [IdMappingJobOutputSource]? = nil, startTime: Date, status: JobStatus) {
            self.endTime = endTime
            self.errorDetails = errorDetails
            self.jobId = jobId
            self.metrics = metrics
            self.outputSourceConfig = outputSourceConfig
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case errorDetails = "errorDetails"
            case jobId = "jobId"
            case metrics = "metrics"
            case outputSourceConfig = "outputSourceConfig"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct GetIdMappingWorkflowInput: AWSEncodableShape {
        /// The name of the workflow.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIdMappingWorkflowOutput: AWSDecodableShape {
        /// The timestamp of when the workflow was created.
        public let createdAt: Date
        /// A description of the workflow.
        public let description: String?
        /// An object which defines the idMappingType and the providerProperties.
        public let idMappingTechniques: IdMappingTechniques
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdMappingWorkflowInputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
        public let outputSourceConfig: [IdMappingWorkflowOutputSource]?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
        public let roleArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The timestamp of when the workflow was last updated.
        public let updatedAt: Date
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IdMappingWorkflow .
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(createdAt: Date, description: String? = nil, idMappingTechniques: IdMappingTechniques, inputSourceConfig: [IdMappingWorkflowInputSource], outputSourceConfig: [IdMappingWorkflowOutputSource]? = nil, roleArn: String, tags: [String: String]? = nil, updatedAt: Date, workflowArn: String, workflowName: String) {
            self.createdAt = createdAt
            self.description = description
            self.idMappingTechniques = idMappingTechniques
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.roleArn = roleArn
            self.tags = tags
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case idMappingTechniques = "idMappingTechniques"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case roleArn = "roleArn"
            case tags = "tags"
            case updatedAt = "updatedAt"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct GetIdNamespaceInput: AWSEncodableShape {
        /// The name of the ID namespace.
        public let idNamespaceName: String

        public init(idNamespaceName: String) {
            self.idNamespaceName = idNamespaceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.idNamespaceName, key: "idNamespaceName")
        }

        public func validate(name: String) throws {
            try self.validate(self.idNamespaceName, name: "idNamespaceName", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$|^arn:(aws|aws-us-gov|aws-cn):entityresolution:[a-z]{2}-[a-z]{1,10}-[0-9]:[0-9]{12}:(idnamespace/[a-zA-Z_0-9-]{1,255})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIdNamespaceOutput: AWSDecodableShape {
        /// The timestamp of when the ID namespace was created.
        public let createdAt: Date
        /// The description of the ID namespace.
        public let description: String?
        /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
        public let idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]?
        /// The Amazon Resource Name (ARN) of the ID namespace.
        public let idNamespaceArn: String
        /// The name of the ID namespace.
        public let idNamespaceName: String
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdNamespaceInputSource]?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of a workflow run.
        public let roleArn: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow.  The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
        public let type: IdNamespaceType
        /// The timestamp of when the ID namespace was last updated.
        public let updatedAt: Date

        public init(createdAt: Date, description: String? = nil, idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]? = nil, idNamespaceArn: String, idNamespaceName: String, inputSourceConfig: [IdNamespaceInputSource]? = nil, roleArn: String? = nil, tags: [String: String]? = nil, type: IdNamespaceType, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.idMappingWorkflowProperties = idMappingWorkflowProperties
            self.idNamespaceArn = idNamespaceArn
            self.idNamespaceName = idNamespaceName
            self.inputSourceConfig = inputSourceConfig
            self.roleArn = roleArn
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case idMappingWorkflowProperties = "idMappingWorkflowProperties"
            case idNamespaceArn = "idNamespaceArn"
            case idNamespaceName = "idNamespaceName"
            case inputSourceConfig = "inputSourceConfig"
            case roleArn = "roleArn"
            case tags = "tags"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetMatchIdInput: AWSEncodableShape {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public let applyNormalization: Bool?
        /// The record to fetch the Match ID for.
        public let record: [String: String]
        /// The name of the workflow.
        public let workflowName: String

        public init(applyNormalization: Bool? = nil, record: [String: String], workflowName: String) {
            self.applyNormalization = applyNormalization
            self.record = record
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.applyNormalization, forKey: .applyNormalization)
            try container.encode(self.record, forKey: .record)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case applyNormalization = "applyNormalization"
            case record = "record"
        }
    }

    public struct GetMatchIdOutput: AWSDecodableShape {
        /// The unique identifiers for this group of match records.
        public let matchId: String?
        /// The rule the record matched on.
        public let matchRule: String?

        public init(matchId: String? = nil, matchRule: String? = nil) {
            self.matchId = matchId
            self.matchRule = matchRule
        }

        private enum CodingKeys: String, CodingKey {
            case matchId = "matchId"
            case matchRule = "matchRule"
        }
    }

    public struct GetMatchingJobInput: AWSEncodableShape {
        /// The ID of the job.
        public let jobId: String
        /// The name of the workflow.
        public let workflowName: String

        public init(jobId: String, workflowName: String) {
            self.jobId = jobId
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMatchingJobOutput: AWSDecodableShape {
        /// The time at which the job has finished.
        public let endTime: Date?
        /// An object containing an error message, if there was an error.
        public let errorDetails: ErrorDetails?
        /// The ID of the job.
        public let jobId: String
        /// Metrics associated with the execution, specifically total records processed, unique IDs generated, and records the execution skipped.
        public let metrics: JobMetrics?
        /// A list of OutputSource objects.
        public let outputSourceConfig: [JobOutputSource]?
        /// The time at which the job was started.
        public let startTime: Date
        /// The current status of the job.
        public let status: JobStatus

        public init(endTime: Date? = nil, errorDetails: ErrorDetails? = nil, jobId: String, metrics: JobMetrics? = nil, outputSourceConfig: [JobOutputSource]? = nil, startTime: Date, status: JobStatus) {
            self.endTime = endTime
            self.errorDetails = errorDetails
            self.jobId = jobId
            self.metrics = metrics
            self.outputSourceConfig = outputSourceConfig
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case errorDetails = "errorDetails"
            case jobId = "jobId"
            case metrics = "metrics"
            case outputSourceConfig = "outputSourceConfig"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct GetMatchingWorkflowInput: AWSEncodableShape {
        /// The name of the workflow.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMatchingWorkflowOutput: AWSDecodableShape {
        /// The timestamp of when the workflow was created.
        public let createdAt: Date
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
        public let roleArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The timestamp of when the workflow was last updated.
        public let updatedAt: Date
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(createdAt: Date, description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, tags: [String: String]? = nil, updatedAt: Date, workflowArn: String, workflowName: String) {
            self.createdAt = createdAt
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.tags = tags
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case tags = "tags"
            case updatedAt = "updatedAt"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct GetPolicyInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which the policy need to be returned.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):entityresolution:[a-z]{2}-[a-z]{1,10}-[0-9]:[0-9]{12}:((schemamapping|matchingworkflow|idmappingworkflow|idnamespace)/[a-zA-Z_0-9-]{1,255})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPolicyOutput: AWSDecodableShape {
        /// The Entity Resolution resource ARN.
        public let arn: String
        /// The resource-based policy.
        public let policy: String?
        /// A unique identifier for the current revision of the policy.
        public let token: String

        public init(arn: String, policy: String? = nil, token: String) {
            self.arn = arn
            self.policy = policy
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case policy = "policy"
            case token = "token"
        }
    }

    public struct GetProviderServiceInput: AWSEncodableShape {
        /// The name of the provider. This name is typically the company name.
        public let providerName: String
        /// The ARN (Amazon Resource Name) of the product that the provider service provides.
        public let providerServiceName: String

        public init(providerName: String, providerServiceName: String) {
            self.providerName = providerName
            self.providerServiceName = providerServiceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.providerName, key: "providerName")
            request.encodePath(self.providerServiceName, key: "providerServiceName")
        }

        public func validate(name: String) throws {
            try self.validate(self.providerName, name: "providerName", parent: name, max: 255)
            try self.validate(self.providerName, name: "providerName", parent: name, min: 1)
            try self.validate(self.providerName, name: "providerName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
            try self.validate(self.providerServiceName, name: "providerServiceName", parent: name, max: 255)
            try self.validate(self.providerServiceName, name: "providerServiceName", parent: name, min: 20)
            try self.validate(self.providerServiceName, name: "providerServiceName", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):(entityresolution):([a-z]{2}-[a-z]{1,10}-[0-9])::providerservice/([a-zA-Z0-9_-]{1,255})/([a-zA-Z0-9_-]{1,255})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProviderServiceOutput: AWSDecodableShape {
        /// Specifies whether output data from the provider is anonymized. A value of TRUE means the output will be anonymized and you can't relate the data that comes back from the provider to the identifying input. A value of FALSE means the output won't be anonymized and you can relate the data that comes back from the provider to your source data.
        public let anonymizedOutput: Bool
        /// Input schema for the provider service.
        public let providerComponentSchema: ProviderComponentSchema?
        /// The definition of the provider configuration.
        public let providerConfigurationDefinition: String?
        /// The required configuration fields to use with the provider service.
        public let providerEndpointConfiguration: ProviderEndpointConfiguration
        /// The definition of the provider entity output.
        public let providerEntityOutputDefinition: String
        /// The provider configuration required for different ID namespace types.
        public let providerIdNameSpaceConfiguration: ProviderIdNameSpaceConfiguration?
        /// The Amazon Web Services accounts and the S3 permissions that are required by some providers to create an S3 bucket for intermediate data storage.
        public let providerIntermediateDataAccessConfiguration: ProviderIntermediateDataAccessConfiguration?
        /// Provider service job configurations.
        public let providerJobConfiguration: String?
        /// The name of the provider. This name is typically the company name.
        public let providerName: String
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the provider service.
        public let providerServiceArn: String
        /// The display name of the provider service.
        public let providerServiceDisplayName: String
        /// The name of the product that the provider service provides.
        public let providerServiceName: String
        /// The type of provider service.
        public let providerServiceType: ServiceType

        public init(anonymizedOutput: Bool, providerComponentSchema: ProviderComponentSchema? = nil, providerConfigurationDefinition: String? = nil, providerEndpointConfiguration: ProviderEndpointConfiguration, providerEntityOutputDefinition: String, providerIdNameSpaceConfiguration: ProviderIdNameSpaceConfiguration? = nil, providerIntermediateDataAccessConfiguration: ProviderIntermediateDataAccessConfiguration? = nil, providerJobConfiguration: String? = nil, providerName: String, providerServiceArn: String, providerServiceDisplayName: String, providerServiceName: String, providerServiceType: ServiceType) {
            self.anonymizedOutput = anonymizedOutput
            self.providerComponentSchema = providerComponentSchema
            self.providerConfigurationDefinition = providerConfigurationDefinition
            self.providerEndpointConfiguration = providerEndpointConfiguration
            self.providerEntityOutputDefinition = providerEntityOutputDefinition
            self.providerIdNameSpaceConfiguration = providerIdNameSpaceConfiguration
            self.providerIntermediateDataAccessConfiguration = providerIntermediateDataAccessConfiguration
            self.providerJobConfiguration = providerJobConfiguration
            self.providerName = providerName
            self.providerServiceArn = providerServiceArn
            self.providerServiceDisplayName = providerServiceDisplayName
            self.providerServiceName = providerServiceName
            self.providerServiceType = providerServiceType
        }

        private enum CodingKeys: String, CodingKey {
            case anonymizedOutput = "anonymizedOutput"
            case providerComponentSchema = "providerComponentSchema"
            case providerConfigurationDefinition = "providerConfigurationDefinition"
            case providerEndpointConfiguration = "providerEndpointConfiguration"
            case providerEntityOutputDefinition = "providerEntityOutputDefinition"
            case providerIdNameSpaceConfiguration = "providerIdNameSpaceConfiguration"
            case providerIntermediateDataAccessConfiguration = "providerIntermediateDataAccessConfiguration"
            case providerJobConfiguration = "providerJobConfiguration"
            case providerName = "providerName"
            case providerServiceArn = "providerServiceArn"
            case providerServiceDisplayName = "providerServiceDisplayName"
            case providerServiceName = "providerServiceName"
            case providerServiceType = "providerServiceType"
        }
    }

    public struct GetSchemaMappingInput: AWSEncodableShape {
        /// The name of the schema to be retrieved.
        public let schemaName: String

        public init(schemaName: String) {
            self.schemaName = schemaName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.schemaName, key: "schemaName")
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaMappingOutput: AWSDecodableShape {
        /// The timestamp of when the SchemaMapping was created.
        public let createdAt: Date
        /// A description of the schema.
        public let description: String?
        /// Specifies whether the schema mapping has been applied to a workflow.
        public let hasWorkflows: Bool
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information Venice uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        public let schemaArn: String
        /// The name of the schema.
        public let schemaName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The timestamp of when the SchemaMapping was last updated.
        public let updatedAt: Date

        public init(createdAt: Date, description: String? = nil, hasWorkflows: Bool, mappedInputFields: [SchemaInputAttribute], schemaArn: String, schemaName: String, tags: [String: String]? = nil, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.hasWorkflows = hasWorkflows
            self.mappedInputFields = mappedInputFields
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case hasWorkflows = "hasWorkflows"
            case mappedInputFields = "mappedInputFields"
            case schemaArn = "schemaArn"
            case schemaName = "schemaName"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct IdMappingJobMetrics: AWSDecodableShape {
        /// The total number of input records.
        public let inputRecords: Int?
        /// The total number of records that did not get processed.
        public let recordsNotProcessed: Int?
        /// The total number of records processed.
        public let totalRecordsProcessed: Int?

        public init(inputRecords: Int? = nil, recordsNotProcessed: Int? = nil, totalRecordsProcessed: Int? = nil) {
            self.inputRecords = inputRecords
            self.recordsNotProcessed = recordsNotProcessed
            self.totalRecordsProcessed = totalRecordsProcessed
        }

        private enum CodingKeys: String, CodingKey {
            case inputRecords = "inputRecords"
            case recordsNotProcessed = "recordsNotProcessed"
            case totalRecordsProcessed = "totalRecordsProcessed"
        }
    }

    public struct IdMappingJobOutputSource: AWSEncodableShape & AWSDecodableShape {
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public let kmsArn: String?
        /// The S3 path to which Entity Resolution will write the output table.
        public let outputS3Path: String
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf as part of workflow execution.
        public let roleArn: String

        public init(kmsArn: String? = nil, outputS3Path: String, roleArn: String) {
            self.kmsArn = kmsArn
            self.outputS3Path = outputS3Path
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "^arn:aws:kms:.*:[0-9]+:.*$")
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, max: 1024)
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, min: 1)
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsArn = "KMSArn"
            case outputS3Path = "outputS3Path"
            case roleArn = "roleArn"
        }
    }

    public struct IdMappingTechniques: AWSEncodableShape & AWSDecodableShape {
        /// The type of ID mapping.
        public let idMappingType: IdMappingType
        /// An object which defines any additional configurations required by the provider service.
        public let providerProperties: ProviderProperties?

        public init(idMappingType: IdMappingType, providerProperties: ProviderProperties? = nil) {
            self.idMappingType = idMappingType
            self.providerProperties = providerProperties
        }

        public func validate(name: String) throws {
            try self.providerProperties?.validate(name: "\(name).providerProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingType = "idMappingType"
            case providerProperties = "providerProperties"
        }
    }

    public struct IdMappingWorkflowInputSource: AWSEncodableShape & AWSDecodableShape {
        /// An Glue table ARN for the input source table.
        public let inputSourceARN: String
        /// The name of the schema to be retrieved.
        public let schemaName: String?
        /// The type of ID namespace. There are two types: SOURCE and TARGET.  The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow.  The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
        public let type: IdNamespaceType?

        public init(inputSourceARN: String, schemaName: String? = nil, type: IdNamespaceType? = nil) {
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputSourceARN = "inputSourceARN"
            case schemaName = "schemaName"
            case type = "type"
        }
    }

    public struct IdMappingWorkflowOutputSource: AWSEncodableShape & AWSDecodableShape {
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public let kmsArn: String?
        /// The S3 path to which Entity Resolution will write the output table.
        public let outputS3Path: String

        public init(kmsArn: String? = nil, outputS3Path: String) {
            self.kmsArn = kmsArn
            self.outputS3Path = outputS3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "^arn:aws:kms:.*:[0-9]+:.*$")
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, max: 1024)
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, min: 1)
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsArn = "KMSArn"
            case outputS3Path = "outputS3Path"
        }
    }

    public struct IdMappingWorkflowSummary: AWSDecodableShape {
        /// The timestamp of when the workflow was created.
        public let createdAt: Date
        /// The timestamp of when the workflow was last updated.
        public let updatedAt: Date
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IdMappingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(createdAt: Date, updatedAt: Date, workflowArn: String, workflowName: String) {
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case updatedAt = "updatedAt"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct IdNamespaceIdMappingWorkflowProperties: AWSEncodableShape & AWSDecodableShape {
        /// The type of ID mapping.
        public let idMappingType: IdMappingType
        /// An object which defines any additional configurations required by the provider service.
        public let providerProperties: NamespaceProviderProperties?

        public init(idMappingType: IdMappingType, providerProperties: NamespaceProviderProperties? = nil) {
            self.idMappingType = idMappingType
            self.providerProperties = providerProperties
        }

        public func validate(name: String) throws {
            try self.providerProperties?.validate(name: "\(name).providerProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingType = "idMappingType"
            case providerProperties = "providerProperties"
        }
    }

    public struct IdNamespaceInputSource: AWSEncodableShape & AWSDecodableShape {
        /// An Glue table ARN for the input source table.
        public let inputSourceARN: String
        /// The name of the schema.
        public let schemaName: String?

        public init(inputSourceARN: String, schemaName: String? = nil) {
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputSourceARN = "inputSourceARN"
            case schemaName = "schemaName"
        }
    }

    public struct IdNamespaceSummary: AWSDecodableShape {
        /// The timestamp of when the ID namespace was created.
        public let createdAt: Date
        /// The description of the ID namespace.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the ID namespace.
        public let idNamespaceArn: String
        /// The name of the ID namespace.
        public let idNamespaceName: String
        /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow.  The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
        public let type: IdNamespaceType
        /// The timestamp of when the ID namespace was last updated.
        public let updatedAt: Date

        public init(createdAt: Date, description: String? = nil, idNamespaceArn: String, idNamespaceName: String, type: IdNamespaceType, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.idNamespaceArn = idNamespaceArn
            self.idNamespaceName = idNamespaceName
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case idNamespaceArn = "idNamespaceArn"
            case idNamespaceName = "idNamespaceName"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct IncrementalRunConfig: AWSEncodableShape & AWSDecodableShape {
        /// The type of incremental run. It takes only one value: IMMEDIATE.
        public let incrementalRunType: IncrementalRunType?

        public init(incrementalRunType: IncrementalRunType? = nil) {
            self.incrementalRunType = incrementalRunType
        }

        private enum CodingKeys: String, CodingKey {
            case incrementalRunType = "incrementalRunType"
        }
    }

    public struct InputSource: AWSEncodableShape & AWSDecodableShape {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public let applyNormalization: Bool?
        /// An Glue table ARN for the input source table.
        public let inputSourceARN: String
        /// The name of the schema to be retrieved.
        public let schemaName: String

        public init(applyNormalization: Bool? = nil, inputSourceARN: String, schemaName: String) {
            self.applyNormalization = applyNormalization
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case applyNormalization = "applyNormalization"
            case inputSourceARN = "inputSourceARN"
            case schemaName = "schemaName"
        }
    }

    public struct IntermediateSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 location (bucket and prefix). For example: s3://provider_bucket/DOC-EXAMPLE-BUCKET
        public let intermediateS3Path: String

        public init(intermediateS3Path: String) {
            self.intermediateS3Path = intermediateS3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.intermediateS3Path, name: "intermediateS3Path", parent: name, max: 1024)
            try self.validate(self.intermediateS3Path, name: "intermediateS3Path", parent: name, min: 1)
            try self.validate(self.intermediateS3Path, name: "intermediateS3Path", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case intermediateS3Path = "intermediateS3Path"
        }
    }

    public struct JobMetrics: AWSDecodableShape {
        /// The total number of input records.
        public let inputRecords: Int?
        /// The total number of matchIDs generated.
        public let matchIDs: Int?
        /// The total number of records that did not get processed.
        public let recordsNotProcessed: Int?
        /// The total number of records processed.
        public let totalRecordsProcessed: Int?

        public init(inputRecords: Int? = nil, matchIDs: Int? = nil, recordsNotProcessed: Int? = nil, totalRecordsProcessed: Int? = nil) {
            self.inputRecords = inputRecords
            self.matchIDs = matchIDs
            self.recordsNotProcessed = recordsNotProcessed
            self.totalRecordsProcessed = totalRecordsProcessed
        }

        private enum CodingKeys: String, CodingKey {
            case inputRecords = "inputRecords"
            case matchIDs = "matchIDs"
            case recordsNotProcessed = "recordsNotProcessed"
            case totalRecordsProcessed = "totalRecordsProcessed"
        }
    }

    public struct JobOutputSource: AWSDecodableShape {
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public let kmsArn: String?
        /// The S3 path to which Entity Resolution will write the output table.
        public let outputS3Path: String
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf as part of workflow execution.
        public let roleArn: String

        public init(kmsArn: String? = nil, outputS3Path: String, roleArn: String) {
            self.kmsArn = kmsArn
            self.outputS3Path = outputS3Path
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case kmsArn = "KMSArn"
            case outputS3Path = "outputS3Path"
            case roleArn = "roleArn"
        }
    }

    public struct JobSummary: AWSDecodableShape {
        /// The time at which the job has finished.
        public let endTime: Date?
        /// The ID of the job.
        public let jobId: String
        /// The time at which the job was started.
        public let startTime: Date
        /// The current status of the job.
        public let status: JobStatus

        public init(endTime: Date? = nil, jobId: String, startTime: Date, status: JobStatus) {
            self.endTime = endTime
            self.jobId = jobId
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case jobId = "jobId"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct ListIdMappingJobsInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// The name of the workflow to be retrieved.
        public let workflowName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workflowName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$|^arn:(aws|aws-us-gov|aws-cn):entityresolution:[a-z]{2}-[a-z]{1,10}-[0-9]:[0-9]{12}:(idmappingworkflow/[a-zA-Z_0-9-]{1,255})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdMappingJobsOutput: AWSDecodableShape {
        /// A list of JobSummary objects.
        public let jobs: [JobSummary]?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(jobs: [JobSummary]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListIdMappingWorkflowsInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdMappingWorkflowsOutput: AWSDecodableShape {
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// A list of IdMappingWorkflowSummary objects.
        public let workflowSummaries: [IdMappingWorkflowSummary]?

        public init(nextToken: String? = nil, workflowSummaries: [IdMappingWorkflowSummary]? = nil) {
            self.nextToken = nextToken
            self.workflowSummaries = workflowSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workflowSummaries = "workflowSummaries"
        }
    }

    public struct ListIdNamespacesInput: AWSEncodableShape {
        /// The maximum number of IdNamespace objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdNamespacesOutput: AWSDecodableShape {
        /// A list of IdNamespaceSummaries objects.
        public let idNamespaceSummaries: [IdNamespaceSummary]?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(idNamespaceSummaries: [IdNamespaceSummary]? = nil, nextToken: String? = nil) {
            self.idNamespaceSummaries = idNamespaceSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case idNamespaceSummaries = "idNamespaceSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMatchingJobsInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// The name of the workflow to be retrieved.
        public let workflowName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workflowName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMatchingJobsOutput: AWSDecodableShape {
        /// A list of JobSummary objects, each of which contain the ID, status, start time, and end time of a job.
        public let jobs: [JobSummary]?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(jobs: [JobSummary]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListMatchingWorkflowsInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMatchingWorkflowsOutput: AWSDecodableShape {
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// A list of MatchingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, and UpdatedAt.
        public let workflowSummaries: [MatchingWorkflowSummary]?

        public init(nextToken: String? = nil, workflowSummaries: [MatchingWorkflowSummary]? = nil) {
            self.nextToken = nextToken
            self.workflowSummaries = workflowSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workflowSummaries = "workflowSummaries"
        }
    }

    public struct ListProviderServicesInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// The name of the provider. This name is typically the company name.
        public let providerName: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, providerName: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.providerName = providerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.providerName, key: "providerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
            try self.validate(self.providerName, name: "providerName", parent: name, max: 255)
            try self.validate(self.providerName, name: "providerName", parent: name, min: 1)
            try self.validate(self.providerName, name: "providerName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProviderServicesOutput: AWSDecodableShape {
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// A list of ProviderServices objects.
        public let providerServiceSummaries: [ProviderServiceSummary]?

        public init(nextToken: String? = nil, providerServiceSummaries: [ProviderServiceSummary]? = nil) {
            self.nextToken = nextToken
            self.providerServiceSummaries = providerServiceSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case providerServiceSummaries = "providerServiceSummaries"
        }
    }

    public struct ListSchemaMappingsInput: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemaMappingsOutput: AWSDecodableShape {
        /// The pagination token from the previous API call.
        public let nextToken: String?
        /// A list of SchemaMappingSummary objects, each of which contain the fields SchemaName, SchemaArn, CreatedAt, UpdatedAt.
        public let schemaList: [SchemaMappingSummary]?

        public init(nextToken: String? = nil, schemaList: [SchemaMappingSummary]? = nil) {
            self.nextToken = nextToken
            self.schemaList = schemaList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case schemaList = "schemaList"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The ARN of the resource for which you want to view tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):entityresolution:[a-z]{2}-[a-z]{1,10}-[0-9]:[0-9]{12}:((schemamapping|matchingworkflow|idmappingworkflow|idnamespace)/[a-zA-Z_0-9-]{1,255})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MatchingWorkflowSummary: AWSDecodableShape {
        /// The timestamp of when the workflow was created.
        public let createdAt: Date
        /// The method that has been specified for data matching, either using matching provided by Entity Resolution or through a provider service.
        public let resolutionType: ResolutionType
        /// The timestamp of when the workflow was last updated.
        public let updatedAt: Date
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(createdAt: Date, resolutionType: ResolutionType, updatedAt: Date, workflowArn: String, workflowName: String) {
            self.createdAt = createdAt
            self.resolutionType = resolutionType
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case resolutionType = "resolutionType"
            case updatedAt = "updatedAt"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct NamespaceProviderProperties: AWSEncodableShape & AWSDecodableShape {
        /// An object which defines any additional configurations required by the provider service.
        public let providerConfiguration: String?
        /// The Amazon Resource Name (ARN) of the provider service.
        public let providerServiceArn: String

        public init(providerConfiguration: String? = nil, providerServiceArn: String) {
            self.providerConfiguration = providerConfiguration
            self.providerServiceArn = providerServiceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.providerServiceArn, name: "providerServiceArn", parent: name, max: 255)
            try self.validate(self.providerServiceArn, name: "providerServiceArn", parent: name, min: 20)
            try self.validate(self.providerServiceArn, name: "providerServiceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):(entityresolution):([a-z]{2}-[a-z]{1,10}-[0-9])::providerservice/([a-zA-Z0-9_-]{1,255})/([a-zA-Z0-9_-]{1,255})$")
        }

        private enum CodingKeys: String, CodingKey {
            case providerConfiguration = "providerConfiguration"
            case providerServiceArn = "providerServiceArn"
        }
    }

    public struct OutputAttribute: AWSEncodableShape & AWSDecodableShape {
        /// Enables the ability to hash the column values in the output.
        public let hashed: Bool?
        /// A name of a column to be written to the output. This must be an InputField name in the schema mapping.
        public let name: String

        public init(hashed: Bool? = nil, name: String) {
            self.hashed = hashed
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case hashed = "hashed"
            case name = "name"
        }
    }

    public struct OutputSource: AWSEncodableShape & AWSDecodableShape {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public let applyNormalization: Bool?
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public let kmsArn: String?
        /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
        public let output: [OutputAttribute]
        /// The S3 path to which Entity Resolution will write the output table.
        public let outputS3Path: String

        public init(applyNormalization: Bool? = nil, kmsArn: String? = nil, output: [OutputAttribute], outputS3Path: String) {
            self.applyNormalization = applyNormalization
            self.kmsArn = kmsArn
            self.output = output
            self.outputS3Path = outputS3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "^arn:aws:kms:.*:[0-9]+:.*$")
            try self.output.forEach {
                try $0.validate(name: "\(name).output[]")
            }
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, max: 1024)
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, min: 1)
            try self.validate(self.outputS3Path, name: "outputS3Path", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case applyNormalization = "applyNormalization"
            case kmsArn = "KMSArn"
            case output = "output"
            case outputS3Path = "outputS3Path"
        }
    }

    public struct ProviderComponentSchema: AWSDecodableShape {
        /// The provider schema attributes.
        public let providerSchemaAttributes: [ProviderSchemaAttribute]?
        /// Input schema for the provider service.
        public let schemas: [[String]]?

        public init(providerSchemaAttributes: [ProviderSchemaAttribute]? = nil, schemas: [[String]]? = nil) {
            self.providerSchemaAttributes = providerSchemaAttributes
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case providerSchemaAttributes = "providerSchemaAttributes"
            case schemas = "schemas"
        }
    }

    public struct ProviderIdNameSpaceConfiguration: AWSDecodableShape {
        /// The description of the ID namespace.
        public let description: String?
        /// Configurations required for the source ID namespace.
        public let providerSourceConfigurationDefinition: String?
        /// Configurations required for the target  ID namespace.
        public let providerTargetConfigurationDefinition: String?

        public init(description: String? = nil, providerSourceConfigurationDefinition: String? = nil, providerTargetConfigurationDefinition: String? = nil) {
            self.description = description
            self.providerSourceConfigurationDefinition = providerSourceConfigurationDefinition
            self.providerTargetConfigurationDefinition = providerTargetConfigurationDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case providerSourceConfigurationDefinition = "providerSourceConfigurationDefinition"
            case providerTargetConfigurationDefinition = "providerTargetConfigurationDefinition"
        }
    }

    public struct ProviderIntermediateDataAccessConfiguration: AWSDecodableShape {
        /// The Amazon Web Services account that provider can use to read or write data into the customer's intermediate S3 bucket.
        public let awsAccountIds: [String]?
        /// The S3 bucket actions that the provider requires permission for.
        public let requiredBucketActions: [String]?

        public init(awsAccountIds: [String]? = nil, requiredBucketActions: [String]? = nil) {
            self.awsAccountIds = awsAccountIds
            self.requiredBucketActions = requiredBucketActions
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountIds = "awsAccountIds"
            case requiredBucketActions = "requiredBucketActions"
        }
    }

    public struct ProviderMarketplaceConfiguration: AWSDecodableShape {
        /// The asset ID on Data Exchange.
        public let assetId: String
        /// The dataset ID on Data Exchange.
        public let dataSetId: String
        /// The listing ID on Data Exchange.
        public let listingId: String
        /// The revision ID on Data Exchange.
        public let revisionId: String

        public init(assetId: String, dataSetId: String, listingId: String, revisionId: String) {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.listingId = listingId
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case dataSetId = "dataSetId"
            case listingId = "listingId"
            case revisionId = "revisionId"
        }
    }

    public struct ProviderProperties: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
        public let intermediateSourceConfiguration: IntermediateSourceConfiguration?
        /// The required configuration fields to use with the provider service.
        public let providerConfiguration: String?
        /// The ARN of the provider service.
        public let providerServiceArn: String

        public init(intermediateSourceConfiguration: IntermediateSourceConfiguration? = nil, providerConfiguration: String? = nil, providerServiceArn: String) {
            self.intermediateSourceConfiguration = intermediateSourceConfiguration
            self.providerConfiguration = providerConfiguration
            self.providerServiceArn = providerServiceArn
        }

        public func validate(name: String) throws {
            try self.intermediateSourceConfiguration?.validate(name: "\(name).intermediateSourceConfiguration")
            try self.validate(self.providerServiceArn, name: "providerServiceArn", parent: name, max: 255)
            try self.validate(self.providerServiceArn, name: "providerServiceArn", parent: name, min: 20)
            try self.validate(self.providerServiceArn, name: "providerServiceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):(entityresolution):([a-z]{2}-[a-z]{1,10}-[0-9])::providerservice/([a-zA-Z0-9_-]{1,255})/([a-zA-Z0-9_-]{1,255})$")
        }

        private enum CodingKeys: String, CodingKey {
            case intermediateSourceConfiguration = "intermediateSourceConfiguration"
            case providerConfiguration = "providerConfiguration"
            case providerServiceArn = "providerServiceArn"
        }
    }

    public struct ProviderSchemaAttribute: AWSDecodableShape {
        /// The field name.
        public let fieldName: String
        /// The hashing attribute of the provider schema.
        public let hashing: Bool?
        /// The sub type of the provider schema attribute.
        public let subType: String?
        /// The type of the provider schema attribute.
        public let type: SchemaAttributeType

        public init(fieldName: String, hashing: Bool? = nil, subType: String? = nil, type: SchemaAttributeType) {
            self.fieldName = fieldName
            self.hashing = hashing
            self.subType = subType
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "fieldName"
            case hashing = "hashing"
            case subType = "subType"
            case type = "type"
        }
    }

    public struct ProviderServiceSummary: AWSDecodableShape {
        /// The name of the provider. This name is typically the company name.
        public let providerName: String
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the providerService.
        public let providerServiceArn: String
        /// The display name of the provider service.
        public let providerServiceDisplayName: String
        /// The name of the product that the provider service provides.
        public let providerServiceName: String
        /// The type of provider service.
        public let providerServiceType: ServiceType

        public init(providerName: String, providerServiceArn: String, providerServiceDisplayName: String, providerServiceName: String, providerServiceType: ServiceType) {
            self.providerName = providerName
            self.providerServiceArn = providerServiceArn
            self.providerServiceDisplayName = providerServiceDisplayName
            self.providerServiceName = providerServiceName
            self.providerServiceType = providerServiceType
        }

        private enum CodingKeys: String, CodingKey {
            case providerName = "providerName"
            case providerServiceArn = "providerServiceArn"
            case providerServiceDisplayName = "providerServiceDisplayName"
            case providerServiceName = "providerServiceName"
            case providerServiceType = "providerServiceType"
        }
    }

    public struct PutPolicyInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which the policy needs to be updated.
        public let arn: String
        /// The resource-based policy.
        public let policy: String
        /// A unique identifier for the current revision of the policy.
        public let token: String?

        public init(arn: String, policy: String, token: String? = nil) {
            self.arn = arn
            self.policy = policy
            self.token = token
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encode(self.policy, forKey: .policy)
            try container.encodeIfPresent(self.token, forKey: .token)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):entityresolution:[a-z]{2}-[a-z]{1,10}-[0-9]:[0-9]{12}:((schemamapping|matchingworkflow|idmappingworkflow|idnamespace)/[a-zA-Z_0-9-]{1,255})$")
            try self.validate(self.policy, name: "policy", parent: name, max: 40960)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.token, name: "token", parent: name, max: 36)
            try self.validate(self.token, name: "token", parent: name, min: 36)
            try self.validate(self.token, name: "token", parent: name, pattern: "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case token = "token"
        }
    }

    public struct PutPolicyOutput: AWSDecodableShape {
        /// The Entity Resolution resource ARN.
        public let arn: String
        /// The resource-based policy.
        public let policy: String?
        /// A unique identifier for the current revision of the policy.
        public let token: String

        public init(arn: String, policy: String? = nil, token: String) {
            self.arn = arn
            self.policy = policy
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case policy = "policy"
            case token = "token"
        }
    }

    public struct ResolutionTechniques: AWSEncodableShape & AWSDecodableShape {
        /// The properties of the provider service.
        public let providerProperties: ProviderProperties?
        /// The type of matching. There are three types of matching: RULE_MATCHING, ML_MATCHING, and PROVIDER.
        public let resolutionType: ResolutionType
        /// An object which defines the list of matching rules to run and has a field Rules, which is a list of rule objects.
        public let ruleBasedProperties: RuleBasedProperties?

        public init(providerProperties: ProviderProperties? = nil, resolutionType: ResolutionType, ruleBasedProperties: RuleBasedProperties? = nil) {
            self.providerProperties = providerProperties
            self.resolutionType = resolutionType
            self.ruleBasedProperties = ruleBasedProperties
        }

        public func validate(name: String) throws {
            try self.providerProperties?.validate(name: "\(name).providerProperties")
            try self.ruleBasedProperties?.validate(name: "\(name).ruleBasedProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case providerProperties = "providerProperties"
            case resolutionType = "resolutionType"
            case ruleBasedProperties = "ruleBasedProperties"
        }
    }

    public struct Rule: AWSEncodableShape & AWSDecodableShape {
        /// A list of MatchingKeys. The MatchingKeys must have been defined in the SchemaMapping. Two records are considered to match according to this rule if all of the MatchingKeys match.
        public let matchingKeys: [String]
        /// A name for the matching rule.
        public let ruleName: String

        public init(matchingKeys: [String], ruleName: String) {
            self.matchingKeys = matchingKeys
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.matchingKeys.forEach {
                try validate($0, name: "matchingKeys[]", parent: name, max: 255)
                try validate($0, name: "matchingKeys[]", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case matchingKeys = "matchingKeys"
            case ruleName = "ruleName"
        }
    }

    public struct RuleBasedProperties: AWSEncodableShape & AWSDecodableShape {
        /// The comparison type. You can either choose ONE_TO_ONE or MANY_TO_MANY as the AttributeMatchingModel. When choosing MANY_TO_MANY, the system can match attributes across the sub-types of an attribute type. For example, if the value of the Email field of Profile A and the value of BusinessEmail field of Profile B matches, the two profiles are matched on the Email type. When choosing ONE_TO_ONE ,the system can only match if the sub-types are exact matches. For example, only when the value of the Email field of Profile A and the value of the Email field of Profile B matches, the two profiles are matched on the Email type.
        public let attributeMatchingModel: AttributeMatchingModel
        /// A list of Rule objects, each of which have fields RuleName and MatchingKeys.
        public let rules: [Rule]

        public init(attributeMatchingModel: AttributeMatchingModel, rules: [Rule]) {
            self.attributeMatchingModel = attributeMatchingModel
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributeMatchingModel = "attributeMatchingModel"
            case rules = "rules"
        }
    }

    public struct SchemaInputAttribute: AWSEncodableShape & AWSDecodableShape {
        /// A string containing the field name.
        public let fieldName: String
        /// A string that instructs Entity Resolution to combine several columns into a unified column with the identical attribute type.  For example, when working with columns such as first_name, middle_name, and last_name, assigning them a common groupName will prompt Entity Resolution to concatenate them into a single value.
        public let groupName: String?
        /// A key that allows grouping of multiple input attributes into a unified matching group. For example, consider a scenario where the source table contains various addresses, such as business_address and shipping_address. By assigning a matchKey  called address to both attributes, Entity Resolution will match records across these fields to create a consolidated matching group. If no matchKey is specified for a column, it won't be utilized for matching purposes but will still be included in the output table.
        public let matchKey: String?
        /// The subtype of the attribute, selected from a list of values.
        public let subType: String?
        /// The type of the attribute, selected from a list of values.
        public let type: SchemaAttributeType

        public init(fieldName: String, groupName: String? = nil, matchKey: String? = nil, subType: String? = nil, type: SchemaAttributeType) {
            self.fieldName = fieldName
            self.groupName = groupName
            self.matchKey = matchKey
            self.subType = subType
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 255)
            try self.validate(self.fieldName, name: "fieldName", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 255)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
            try self.validate(self.matchKey, name: "matchKey", parent: name, max: 255)
            try self.validate(self.matchKey, name: "matchKey", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
            try self.validate(self.subType, name: "subType", parent: name, max: 255)
            try self.validate(self.subType, name: "subType", parent: name, pattern: "^[a-zA-Z_0-9- \\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "fieldName"
            case groupName = "groupName"
            case matchKey = "matchKey"
            case subType = "subType"
            case type = "type"
        }
    }

    public struct SchemaMappingSummary: AWSDecodableShape {
        /// The timestamp of when the SchemaMapping was created.
        public let createdAt: Date
        /// Specifies whether the schema mapping has been applied to a workflow.
        public let hasWorkflows: Bool
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        public let schemaArn: String
        /// The name of the schema.
        public let schemaName: String
        /// The timestamp of when the SchemaMapping was last updated.
        public let updatedAt: Date

        public init(createdAt: Date, hasWorkflows: Bool, schemaArn: String, schemaName: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.hasWorkflows = hasWorkflows
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case hasWorkflows = "hasWorkflows"
            case schemaArn = "schemaArn"
            case schemaName = "schemaName"
            case updatedAt = "updatedAt"
        }
    }

    public struct StartIdMappingJobInput: AWSEncodableShape {
        /// A list of OutputSource objects.
        public let outputSourceConfig: [IdMappingJobOutputSource]?
        /// The name of the ID mapping job to be retrieved.
        public let workflowName: String

        public init(outputSourceConfig: [IdMappingJobOutputSource]? = nil, workflowName: String) {
            self.outputSourceConfig = outputSourceConfig
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.outputSourceConfig, forKey: .outputSourceConfig)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.outputSourceConfig?.forEach {
                try $0.validate(name: "\(name).outputSourceConfig[]")
            }
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, max: 1)
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-=+/]*$|^arn:(aws|aws-us-gov|aws-cn):entityresolution:[a-z]{2}-[a-z]{1,10}-[0-9]:[0-9]{12}:(idmappingworkflow/[a-zA-Z_0-9-]{1,255})$")
        }

        private enum CodingKeys: String, CodingKey {
            case outputSourceConfig = "outputSourceConfig"
        }
    }

    public struct StartIdMappingJobOutput: AWSDecodableShape {
        /// The ID of the job.
        public let jobId: String
        /// A list of OutputSource objects.
        public let outputSourceConfig: [IdMappingJobOutputSource]?

        public init(jobId: String, outputSourceConfig: [IdMappingJobOutputSource]? = nil) {
            self.jobId = jobId
            self.outputSourceConfig = outputSourceConfig
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
            case outputSourceConfig = "outputSourceConfig"
        }
    }

    public struct StartMatchingJobInput: AWSEncodableShape {
        /// The name of the matching job to be retrieved.
        public let workflowName: String

        public init(workflowName: String) {
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartMatchingJobOutput: AWSDecodableShape {
        /// The ID of the job.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The ARN of the resource for which you want to view tags.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):entityresolution:[a-z]{2}-[a-z]{1,10}-[0-9]:[0-9]{12}:((schemamapping|matchingworkflow|idmappingworkflow|idnamespace)/[a-zA-Z_0-9-]{1,255})$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The ARN of the resource for which you want to untag.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):entityresolution:[a-z]{2}-[a-z]{1,10}-[0-9]:[0-9]{12}:((schemamapping|matchingworkflow|idmappingworkflow|idnamespace)/[a-zA-Z_0-9-]{1,255})$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateIdMappingWorkflowInput: AWSEncodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines the idMappingType and the providerProperties.
        public let idMappingTechniques: IdMappingTechniques
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdMappingWorkflowInputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
        public let outputSourceConfig: [IdMappingWorkflowOutputSource]?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
        public let roleArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, idMappingTechniques: IdMappingTechniques, inputSourceConfig: [IdMappingWorkflowInputSource], outputSourceConfig: [IdMappingWorkflowOutputSource]? = nil, roleArn: String, workflowName: String) {
            self.description = description
            self.idMappingTechniques = idMappingTechniques
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.roleArn = roleArn
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.idMappingTechniques, forKey: .idMappingTechniques)
            try container.encode(self.inputSourceConfig, forKey: .inputSourceConfig)
            try container.encodeIfPresent(self.outputSourceConfig, forKey: .outputSourceConfig)
            try container.encode(self.roleArn, forKey: .roleArn)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.idMappingTechniques.validate(name: "\(name).idMappingTechniques")
            try self.inputSourceConfig.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, min: 1)
            try self.outputSourceConfig?.forEach {
                try $0.validate(name: "\(name).outputSourceConfig[]")
            }
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, max: 1)
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingTechniques = "idMappingTechniques"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateIdMappingWorkflowOutput: AWSDecodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines the idMappingType and the providerProperties.
        public let idMappingTechniques: IdMappingTechniques
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdMappingWorkflowInputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
        public let outputSourceConfig: [IdMappingWorkflowOutputSource]?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
        public let roleArn: String
        /// The Amazon Resource Name (ARN) of the workflow role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
        public let workflowArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, idMappingTechniques: IdMappingTechniques, inputSourceConfig: [IdMappingWorkflowInputSource], outputSourceConfig: [IdMappingWorkflowOutputSource]? = nil, roleArn: String, workflowArn: String, workflowName: String) {
            self.description = description
            self.idMappingTechniques = idMappingTechniques
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.roleArn = roleArn
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingTechniques = "idMappingTechniques"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case roleArn = "roleArn"
            case workflowArn = "workflowArn"
            case workflowName = "workflowName"
        }
    }

    public struct UpdateIdNamespaceInput: AWSEncodableShape {
        /// The description of the ID namespace.
        public let description: String?
        /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
        public let idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]?
        /// The name of the ID namespace.
        public let idNamespaceName: String
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdNamespaceInputSource]?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of a workflow run.
        public let roleArn: String?

        public init(description: String? = nil, idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]? = nil, idNamespaceName: String, inputSourceConfig: [IdNamespaceInputSource]? = nil, roleArn: String? = nil) {
            self.description = description
            self.idMappingWorkflowProperties = idMappingWorkflowProperties
            self.idNamespaceName = idNamespaceName
            self.inputSourceConfig = inputSourceConfig
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.idMappingWorkflowProperties, forKey: .idMappingWorkflowProperties)
            request.encodePath(self.idNamespaceName, key: "idNamespaceName")
            try container.encodeIfPresent(self.inputSourceConfig, forKey: .inputSourceConfig)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.idMappingWorkflowProperties?.forEach {
                try $0.validate(name: "\(name).idMappingWorkflowProperties[]")
            }
            try self.validate(self.idMappingWorkflowProperties, name: "idMappingWorkflowProperties", parent: name, max: 1)
            try self.validate(self.idMappingWorkflowProperties, name: "idMappingWorkflowProperties", parent: name, min: 1)
            try self.validate(self.idNamespaceName, name: "idNamespaceName", parent: name, max: 255)
            try self.validate(self.idNamespaceName, name: "idNamespaceName", parent: name, min: 1)
            try self.validate(self.idNamespaceName, name: "idNamespaceName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
            try self.inputSourceConfig?.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingWorkflowProperties = "idMappingWorkflowProperties"
            case inputSourceConfig = "inputSourceConfig"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateIdNamespaceOutput: AWSDecodableShape {
        /// The timestamp of when the ID namespace was created.
        public let createdAt: Date
        /// The description of the ID namespace.
        public let description: String?
        /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
        public let idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]?
        /// The Amazon Resource Name (ARN) of the ID namespace.
        public let idNamespaceArn: String
        /// The name of the ID namespace.
        public let idNamespaceName: String
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [IdNamespaceInputSource]?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of a workflow run.
        public let roleArn: String?
        /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow.  The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
        public let type: IdNamespaceType
        /// The timestamp of when the ID namespace was last updated.
        public let updatedAt: Date

        public init(createdAt: Date, description: String? = nil, idMappingWorkflowProperties: [IdNamespaceIdMappingWorkflowProperties]? = nil, idNamespaceArn: String, idNamespaceName: String, inputSourceConfig: [IdNamespaceInputSource]? = nil, roleArn: String? = nil, type: IdNamespaceType, updatedAt: Date) {
            self.createdAt = createdAt
            self.description = description
            self.idMappingWorkflowProperties = idMappingWorkflowProperties
            self.idNamespaceArn = idNamespaceArn
            self.idNamespaceName = idNamespaceName
            self.inputSourceConfig = inputSourceConfig
            self.roleArn = roleArn
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case idMappingWorkflowProperties = "idMappingWorkflowProperties"
            case idNamespaceArn = "idNamespaceArn"
            case idNamespaceName = "idNamespaceName"
            case inputSourceConfig = "inputSourceConfig"
            case roleArn = "roleArn"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateMatchingWorkflowInput: AWSEncodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties.
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The name of the workflow to be retrieved.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.workflowName = workflowName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.incrementalRunConfig, forKey: .incrementalRunConfig)
            try container.encode(self.inputSourceConfig, forKey: .inputSourceConfig)
            try container.encode(self.outputSourceConfig, forKey: .outputSourceConfig)
            try container.encode(self.resolutionTechniques, forKey: .resolutionTechniques)
            try container.encode(self.roleArn, forKey: .roleArn)
            request.encodePath(self.workflowName, key: "workflowName")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.inputSourceConfig.forEach {
                try $0.validate(name: "\(name).inputSourceConfig[]")
            }
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, max: 20)
            try self.validate(self.inputSourceConfig, name: "inputSourceConfig", parent: name, min: 1)
            try self.outputSourceConfig.forEach {
                try $0.validate(name: "\(name).outputSourceConfig[]")
            }
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, max: 1)
            try self.validate(self.outputSourceConfig, name: "outputSourceConfig", parent: name, min: 1)
            try self.resolutionTechniques.validate(name: "\(name).resolutionTechniques")
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateMatchingWorkflowOutput: AWSDecodableShape {
        /// A description of the workflow.
        public let description: String?
        /// An object which defines an incremental run type and has only incrementalRunType as a field.
        public let incrementalRunConfig: IncrementalRunConfig?
        /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
        public let inputSourceConfig: [InputSource]
        /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
        public let outputSourceConfig: [OutputSource]
        /// An object which defines the resolutionType and the ruleBasedProperties
        public let resolutionTechniques: ResolutionTechniques
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The name of the workflow.
        public let workflowName: String

        public init(description: String? = nil, incrementalRunConfig: IncrementalRunConfig? = nil, inputSourceConfig: [InputSource], outputSourceConfig: [OutputSource], resolutionTechniques: ResolutionTechniques, roleArn: String, workflowName: String) {
            self.description = description
            self.incrementalRunConfig = incrementalRunConfig
            self.inputSourceConfig = inputSourceConfig
            self.outputSourceConfig = outputSourceConfig
            self.resolutionTechniques = resolutionTechniques
            self.roleArn = roleArn
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case incrementalRunConfig = "incrementalRunConfig"
            case inputSourceConfig = "inputSourceConfig"
            case outputSourceConfig = "outputSourceConfig"
            case resolutionTechniques = "resolutionTechniques"
            case roleArn = "roleArn"
            case workflowName = "workflowName"
        }
    }

    public struct UpdateSchemaMappingInput: AWSEncodableShape {
        /// A description of the schema.
        public let description: String?
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The name of the schema. There can't be multiple SchemaMappings with the same name.
        public let schemaName: String

        public init(description: String? = nil, mappedInputFields: [SchemaInputAttribute], schemaName: String) {
            self.description = description
            self.mappedInputFields = mappedInputFields
            self.schemaName = schemaName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.mappedInputFields, forKey: .mappedInputFields)
            request.encodePath(self.schemaName, key: "schemaName")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.mappedInputFields.forEach {
                try $0.validate(name: "\(name).mappedInputFields[]")
            }
            try self.validate(self.mappedInputFields, name: "mappedInputFields", parent: name, max: 25)
            try self.validate(self.mappedInputFields, name: "mappedInputFields", parent: name, min: 2)
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case mappedInputFields = "mappedInputFields"
        }
    }

    public struct UpdateSchemaMappingOutput: AWSDecodableShape {
        /// A description of the schema.
        public let description: String?
        /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
        public let mappedInputFields: [SchemaInputAttribute]
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        public let schemaArn: String
        /// The name of the schema.
        public let schemaName: String

        public init(description: String? = nil, mappedInputFields: [SchemaInputAttribute], schemaArn: String, schemaName: String) {
            self.description = description
            self.mappedInputFields = mappedInputFields
            self.schemaArn = schemaArn
            self.schemaName = schemaName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case mappedInputFields = "mappedInputFields"
            case schemaArn = "schemaArn"
            case schemaName = "schemaName"
        }
    }

    public struct ProviderEndpointConfiguration: AWSDecodableShape {
        /// The identifiers of the provider service, from Data Exchange.
        public let marketplaceConfiguration: ProviderMarketplaceConfiguration?

        public init(marketplaceConfiguration: ProviderMarketplaceConfiguration? = nil) {
            self.marketplaceConfiguration = marketplaceConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case marketplaceConfiguration = "marketplaceConfiguration"
        }
    }
}

// MARK: - Errors

/// Error enum for EntityResolution
public struct EntityResolutionErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case exceedsLimitException = "ExceedsLimitException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize EntityResolution
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action. HTTP Status Code: 403
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be processed because of conflict in the current state of the resource. Example: Workflow already exists, Schema already exists, Workflow is currently running, etc. HTTP Status Code: 400
    public static var conflictException: Self { .init(.conflictException) }
    /// The request was rejected because it attempted to create resources beyond the current Entity Resolution account limits. The error message describes the limit exceeded. HTTP Status Code: 402
    public static var exceedsLimitException: Self { .init(.exceedsLimitException) }
    /// This exception occurs when there is an internal failure in the Entity Resolution service. HTTP Status Code: 500
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource could not be found. HTTP Status Code: 404
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling. HTTP Status Code: 429
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by Entity Resolution. HTTP Status Code: 400
    public static var validationException: Self { .init(.validationException) }
}

extension EntityResolutionErrorType: Equatable {
    public static func == (lhs: EntityResolutionErrorType, rhs: EntityResolutionErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension EntityResolutionErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
