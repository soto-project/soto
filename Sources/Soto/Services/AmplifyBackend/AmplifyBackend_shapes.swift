//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension AmplifyBackend {
    // MARK: Enums

    public enum AdditionalConstraintsElement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case requireDigit = "REQUIRE_DIGIT"
        case requireLowercase = "REQUIRE_LOWERCASE"
        case requireSymbol = "REQUIRE_SYMBOL"
        case requireUppercase = "REQUIRE_UPPERCASE"
        public var description: String { return self.rawValue }
    }

    public enum AuthResources: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case identityPoolAndUserPool = "IDENTITY_POOL_AND_USER_POOL"
        case userPoolOnly = "USER_POOL_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum AuthenticatedElement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createAndUpdate = "CREATE_AND_UPDATE"
        case delete = "DELETE"
        case read = "READ"
        public var description: String { return self.rawValue }
    }

    public enum DeliveryMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case email = "EMAIL"
        case sms = "SMS"
        public var description: String { return self.rawValue }
    }

    public enum MFAMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case off = "OFF"
        case on = "ON"
        case optional = "OPTIONAL"
        public var description: String { return self.rawValue }
    }

    public enum MfaTypesElement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sms = "SMS"
        case totp = "TOTP"
        public var description: String { return self.rawValue }
    }

    public enum Mode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonCognitoUserPools = "AMAZON_COGNITO_USER_POOLS"
        case apiKey = "API_KEY"
        case awsIam = "AWS_IAM"
        case openidConnect = "OPENID_CONNECT"
        public var description: String { return self.rawValue }
    }

    public enum OAuthGrantType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case code = "CODE"
        case implicit = "IMPLICIT"
        public var description: String { return self.rawValue }
    }

    public enum OAuthScopesElement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsCognitoSigninUserAdmin = "AWS_COGNITO_SIGNIN_USER_ADMIN"
        case email = "EMAIL"
        case openid = "OPENID"
        case phone = "PHONE"
        case profile = "PROFILE"
        public var description: String { return self.rawValue }
    }

    public enum RequiredSignUpAttributesElement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case address = "ADDRESS"
        case birthdate = "BIRTHDATE"
        case email = "EMAIL"
        case familyName = "FAMILY_NAME"
        case gender = "GENDER"
        case givenName = "GIVEN_NAME"
        case locale = "LOCALE"
        case middleName = "MIDDLE_NAME"
        case name = "NAME"
        case nickname = "NICKNAME"
        case phoneNumber = "PHONE_NUMBER"
        case picture = "PICTURE"
        case preferredUsername = "PREFERRED_USERNAME"
        case profile = "PROFILE"
        case updatedAt = "UPDATED_AT"
        case website = "WEBSITE"
        case zoneInfo = "ZONE_INFO"
        public var description: String { return self.rawValue }
    }

    public enum ResolutionStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automerge = "AUTOMERGE"
        case lambda = "LAMBDA"
        case none = "NONE"
        case optimisticConcurrency = "OPTIMISTIC_CONCURRENCY"
        public var description: String { return self.rawValue }
    }

    public enum Service: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cognito = "COGNITO"
        public var description: String { return self.rawValue }
    }

    public enum ServiceName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum SignInMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case email = "EMAIL"
        case emailAndPhoneNumber = "EMAIL_AND_PHONE_NUMBER"
        case phoneNumber = "PHONE_NUMBER"
        case username = "USERNAME"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case latest = "LATEST"
        case stale = "STALE"
        public var description: String { return self.rawValue }
    }

    public enum UnAuthenticatedElement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createAndUpdate = "CREATE_AND_UPDATE"
        case delete = "DELETE"
        case read = "READ"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct BackendAPIAppSyncAuthSettings: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Cognito user pool ID, if Amazon Cognito was used as an authentication setting to access your data models.
        public let cognitoUserPoolId: String?
        /// The API key description for API_KEY, if it was used as an authentication mechanism to access your data models.
        public let description: String?
        /// The API key expiration time for API_KEY, if it was used as an authentication mechanism to access your data models.
        public let expirationTime: Double?
        /// The expiry time for the OpenID authentication mechanism.
        public let openIDAuthTTL: String?
        /// The clientID for openID, if openID was used as an authentication setting to access your data models.
        public let openIDClientId: String?
        /// The expiry time for the OpenID authentication mechanism.
        public let openIDIatTTL: String?
        /// The openID issuer URL, if openID was used as an authentication setting to access your data models.
        public let openIDIssueURL: String?
        /// The OpenID provider name, if OpenID was used as an authentication mechanism to access your data models.
        public let openIDProviderName: String?

        @inlinable
        public init(cognitoUserPoolId: String? = nil, description: String? = nil, expirationTime: Double? = nil, openIDAuthTTL: String? = nil, openIDClientId: String? = nil, openIDIatTTL: String? = nil, openIDIssueURL: String? = nil, openIDProviderName: String? = nil) {
            self.cognitoUserPoolId = cognitoUserPoolId
            self.description = description
            self.expirationTime = expirationTime
            self.openIDAuthTTL = openIDAuthTTL
            self.openIDClientId = openIDClientId
            self.openIDIatTTL = openIDIatTTL
            self.openIDIssueURL = openIDIssueURL
            self.openIDProviderName = openIDProviderName
        }

        private enum CodingKeys: String, CodingKey {
            case cognitoUserPoolId = "cognitoUserPoolId"
            case description = "description"
            case expirationTime = "expirationTime"
            case openIDAuthTTL = "openIDAuthTTL"
            case openIDClientId = "openIDClientId"
            case openIDIatTTL = "openIDIatTTL"
            case openIDIssueURL = "openIDIssueURL"
            case openIDProviderName = "openIDProviderName"
        }
    }

    public struct BackendAPIAuthType: AWSEncodableShape & AWSDecodableShape {
        /// Describes the authentication mode.
        public let mode: Mode?
        /// Describes settings for the authentication mode.
        public let settings: BackendAPIAppSyncAuthSettings?

        @inlinable
        public init(mode: Mode? = nil, settings: BackendAPIAppSyncAuthSettings? = nil) {
            self.mode = mode
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "mode"
            case settings = "settings"
        }
    }

    public struct BackendAPIConflictResolution: AWSEncodableShape & AWSDecodableShape {
        /// The strategy for conflict resolution.
        public let resolutionStrategy: ResolutionStrategy?

        @inlinable
        public init(resolutionStrategy: ResolutionStrategy? = nil) {
            self.resolutionStrategy = resolutionStrategy
        }

        private enum CodingKeys: String, CodingKey {
            case resolutionStrategy = "resolutionStrategy"
        }
    }

    public struct BackendAPIResourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// Additional authentication methods used to interact with your data models.
        public let additionalAuthTypes: [BackendAPIAuthType]?
        /// The API name used to interact with the data model, configured as a part of your Amplify project.
        public let apiName: String?
        /// The conflict resolution strategy for your data stored in the data models.
        public let conflictResolution: BackendAPIConflictResolution?
        /// The default authentication type for interacting with the configured data models in your Amplify project.
        public let defaultAuthType: BackendAPIAuthType?
        /// The service used to provision and interact with the data model.
        public let service: String?
        /// The definition of the data model in the annotated transform of the GraphQL schema.
        public let transformSchema: String?

        @inlinable
        public init(additionalAuthTypes: [BackendAPIAuthType]? = nil, apiName: String? = nil, conflictResolution: BackendAPIConflictResolution? = nil, defaultAuthType: BackendAPIAuthType? = nil, service: String? = nil, transformSchema: String? = nil) {
            self.additionalAuthTypes = additionalAuthTypes
            self.apiName = apiName
            self.conflictResolution = conflictResolution
            self.defaultAuthType = defaultAuthType
            self.service = service
            self.transformSchema = transformSchema
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAuthTypes = "additionalAuthTypes"
            case apiName = "apiName"
            case conflictResolution = "conflictResolution"
            case defaultAuthType = "defaultAuthType"
            case service = "service"
            case transformSchema = "transformSchema"
        }
    }

    public struct BackendAuthAppleProviderConfig: AWSEncodableShape & AWSDecodableShape {
        /// Describes the client_id (also called Services ID) that comes from Apple.
        public let clientId: String?
        /// Describes the key_id that comes from Apple.
        public let keyId: String?
        /// Describes the private_key that comes from Apple.
        public let privateKey: String?
        /// Describes the team_id that comes from Apple.
        public let teamId: String?

        @inlinable
        public init(clientId: String? = nil, keyId: String? = nil, privateKey: String? = nil, teamId: String? = nil) {
            self.clientId = clientId
            self.keyId = keyId
            self.privateKey = privateKey
            self.teamId = teamId
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "client_id"
            case keyId = "key_id"
            case privateKey = "private_key"
            case teamId = "team_id"
        }
    }

    public struct BackendAuthSocialProviderConfig: AWSEncodableShape & AWSDecodableShape {
        /// Describes the client_id, which can be obtained from the third-party social federation provider.
        public let clientId: String?
        /// Describes the client_secret, which can be obtained from third-party social federation providers.
        public let clientSecret: String?

        @inlinable
        public init(clientId: String? = nil, clientSecret: String? = nil) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "client_id"
            case clientSecret = "client_secret"
        }
    }

    public struct BackendJobRespObj: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The time when the job was created.
        public let createTime: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?
        /// The time when the job was last updated.
        public let updateTime: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, createTime: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil, updateTime: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.createTime = createTime
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case createTime = "createTime"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct BackendStoragePermissions: AWSEncodableShape & AWSDecodableShape {
        /// Lists all authenticated user read, write, and delete permissions for your S3 bucket.
        public let authenticated: [AuthenticatedElement]?
        /// Lists all unauthenticated user read, write, and delete permissions for your S3 bucket.
        public let unAuthenticated: [UnAuthenticatedElement]?

        @inlinable
        public init(authenticated: [AuthenticatedElement]? = nil, unAuthenticated: [UnAuthenticatedElement]? = nil) {
            self.authenticated = authenticated
            self.unAuthenticated = unAuthenticated
        }

        private enum CodingKeys: String, CodingKey {
            case authenticated = "authenticated"
            case unAuthenticated = "unAuthenticated"
        }
    }

    public struct CloneBackendRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The name of the destination backend environment to be created.
        public let targetEnvironmentName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, targetEnvironmentName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.targetEnvironmentName = targetEnvironmentName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.targetEnvironmentName, forKey: .targetEnvironmentName)
        }

        private enum CodingKeys: String, CodingKey {
            case targetEnvironmentName = "targetEnvironmentName"
        }
    }

    public struct CloneBackendResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct CreateBackendAPIRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The resource configuration for this request.
        public let resourceConfig: BackendAPIResourceConfig?
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String? = nil, resourceConfig: BackendAPIResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            try container.encodeIfPresent(self.backendEnvironmentName, forKey: .backendEnvironmentName)
            try container.encodeIfPresent(self.resourceConfig, forKey: .resourceConfig)
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case backendEnvironmentName = "backendEnvironmentName"
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct CreateBackendAPIResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct CreateBackendAuthForgotPasswordConfig: AWSEncodableShape & AWSDecodableShape {
        /// (DEPRECATED) Describes which mode to use (either SMS or email) to deliver messages to app users who want to recover their password.
        public let deliveryMethod: DeliveryMethod?
        /// (DEPRECATED) The configuration for the email sent when an app user forgets their password.
        public let emailSettings: EmailSettings?
        /// (DEPRECATED) The configuration for the SMS message sent when an app user forgets their password.
        public let smsSettings: SmsSettings?

        @inlinable
        public init(deliveryMethod: DeliveryMethod? = nil, emailSettings: EmailSettings? = nil, smsSettings: SmsSettings? = nil) {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryMethod = "deliveryMethod"
            case emailSettings = "emailSettings"
            case smsSettings = "smsSettings"
        }
    }

    public struct CreateBackendAuthIdentityPoolConfig: AWSEncodableShape & AWSDecodableShape {
        /// Name of the Amazon Cognito identity pool used for authorization.
        public let identityPoolName: String?
        /// Set to true or false based on whether you want to enable guest authorization to your Amplify app.
        public let unauthenticatedLogin: Bool?

        @inlinable
        public init(identityPoolName: String? = nil, unauthenticatedLogin: Bool? = nil) {
            self.identityPoolName = identityPoolName
            self.unauthenticatedLogin = unauthenticatedLogin
        }

        private enum CodingKeys: String, CodingKey {
            case identityPoolName = "identityPoolName"
            case unauthenticatedLogin = "unauthenticatedLogin"
        }
    }

    public struct CreateBackendAuthMFAConfig: AWSEncodableShape & AWSDecodableShape {
        /// Describes whether MFA should be [ON, OFF, or OPTIONAL] for authentication in your Amplify project.
        public let mfaMode: MFAMode?
        /// Describes the configuration settings and methods for your Amplify app users to use MFA.
        public let settings: Settings?

        @inlinable
        public init(mfaMode: MFAMode? = nil, settings: Settings? = nil) {
            self.mfaMode = mfaMode
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case mfaMode = "MFAMode"
            case settings = "settings"
        }
    }

    public struct CreateBackendAuthOAuthConfig: AWSEncodableShape & AWSDecodableShape {
        /// The domain prefix for your Amplify app.
        public let domainPrefix: String?
        /// The OAuth grant type that you use to allow app users to authenticate from your Amplify app.
        public let oAuthGrantType: OAuthGrantType?
        /// List of OAuth-related flows used to allow your app users to authenticate from your Amplify app.
        public let oAuthScopes: [OAuthScopesElement]?
        /// The redirected URI for signing in to your Amplify app.
        public let redirectSignInURIs: [String]?
        /// Redirect URLs that OAuth uses when a user signs out of an Amplify app.
        public let redirectSignOutURIs: [String]?
        /// The settings for using social providers to access your Amplify app.
        public let socialProviderSettings: SocialProviderSettings?

        @inlinable
        public init(domainPrefix: String? = nil, oAuthGrantType: OAuthGrantType? = nil, oAuthScopes: [OAuthScopesElement]? = nil, redirectSignInURIs: [String]? = nil, redirectSignOutURIs: [String]? = nil, socialProviderSettings: SocialProviderSettings? = nil) {
            self.domainPrefix = domainPrefix
            self.oAuthGrantType = oAuthGrantType
            self.oAuthScopes = oAuthScopes
            self.redirectSignInURIs = redirectSignInURIs
            self.redirectSignOutURIs = redirectSignOutURIs
            self.socialProviderSettings = socialProviderSettings
        }

        private enum CodingKeys: String, CodingKey {
            case domainPrefix = "domainPrefix"
            case oAuthGrantType = "oAuthGrantType"
            case oAuthScopes = "oAuthScopes"
            case redirectSignInURIs = "redirectSignInURIs"
            case redirectSignOutURIs = "redirectSignOutURIs"
            case socialProviderSettings = "socialProviderSettings"
        }
    }

    public struct CreateBackendAuthPasswordPolicyConfig: AWSEncodableShape & AWSDecodableShape {
        /// Additional constraints for the password used to access the backend of your Amplify project.
        public let additionalConstraints: [AdditionalConstraintsElement]?
        /// The minimum length of the password used to access the backend of your Amplify project.
        public let minimumLength: Double?

        @inlinable
        public init(additionalConstraints: [AdditionalConstraintsElement]? = nil, minimumLength: Double? = nil) {
            self.additionalConstraints = additionalConstraints
            self.minimumLength = minimumLength
        }

        private enum CodingKeys: String, CodingKey {
            case additionalConstraints = "additionalConstraints"
            case minimumLength = "minimumLength"
        }
    }

    public struct CreateBackendAuthRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The resource configuration for this request object.
        public let resourceConfig: CreateBackendAuthResourceConfig?
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String? = nil, resourceConfig: CreateBackendAuthResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            try container.encodeIfPresent(self.backendEnvironmentName, forKey: .backendEnvironmentName)
            try container.encodeIfPresent(self.resourceConfig, forKey: .resourceConfig)
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case backendEnvironmentName = "backendEnvironmentName"
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct CreateBackendAuthResourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// Defines whether you want to configure only authentication or both authentication and authorization settings.
        public let authResources: AuthResources?
        /// Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.
        public let identityPoolConfigs: CreateBackendAuthIdentityPoolConfig?
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        public let service: Service?
        /// Describes authentication configuration for the Amazon Cognito user pool, provisioned as a part of your auth resource in the Amplify project.
        public let userPoolConfigs: CreateBackendAuthUserPoolConfig?

        @inlinable
        public init(authResources: AuthResources? = nil, identityPoolConfigs: CreateBackendAuthIdentityPoolConfig? = nil, service: Service? = nil, userPoolConfigs: CreateBackendAuthUserPoolConfig? = nil) {
            self.authResources = authResources
            self.identityPoolConfigs = identityPoolConfigs
            self.service = service
            self.userPoolConfigs = userPoolConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case authResources = "authResources"
            case identityPoolConfigs = "identityPoolConfigs"
            case service = "service"
            case userPoolConfigs = "userPoolConfigs"
        }
    }

    public struct CreateBackendAuthResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct CreateBackendAuthUserPoolConfig: AWSEncodableShape & AWSDecodableShape {
        /// (DEPRECATED) Describes the forgotten password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let forgotPassword: CreateBackendAuthForgotPasswordConfig?
        /// Describes whether to apply multi-factor authentication policies for your Amazon Cognito user pool configured as a part of your Amplify project.
        public let mfa: CreateBackendAuthMFAConfig?
        /// Describes the OAuth policy and rules for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let oAuth: CreateBackendAuthOAuthConfig?
        /// Describes the password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let passwordPolicy: CreateBackendAuthPasswordPolicyConfig?
        /// The required attributes to sign up new users in the user pool.
        public let requiredSignUpAttributes: [RequiredSignUpAttributesElement]?
        /// Describes the sign-in methods that your Amplify app users use to log in using the Amazon Cognito user pool, configured as a part of your Amplify project.
        public let signInMethod: SignInMethod?
        /// The Amazon Cognito user pool name.
        public let userPoolName: String?
        /// Describes the email or SMS verification message for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let verificationMessage: CreateBackendAuthVerificationMessageConfig?

        @inlinable
        public init(forgotPassword: CreateBackendAuthForgotPasswordConfig? = nil, mfa: CreateBackendAuthMFAConfig? = nil, oAuth: CreateBackendAuthOAuthConfig? = nil, passwordPolicy: CreateBackendAuthPasswordPolicyConfig? = nil, requiredSignUpAttributes: [RequiredSignUpAttributesElement]? = nil, signInMethod: SignInMethod? = nil, userPoolName: String? = nil, verificationMessage: CreateBackendAuthVerificationMessageConfig? = nil) {
            self.forgotPassword = forgotPassword
            self.mfa = mfa
            self.oAuth = oAuth
            self.passwordPolicy = passwordPolicy
            self.requiredSignUpAttributes = requiredSignUpAttributes
            self.signInMethod = signInMethod
            self.userPoolName = userPoolName
            self.verificationMessage = verificationMessage
        }

        private enum CodingKeys: String, CodingKey {
            case forgotPassword = "forgotPassword"
            case mfa = "mfa"
            case oAuth = "oAuth"
            case passwordPolicy = "passwordPolicy"
            case requiredSignUpAttributes = "requiredSignUpAttributes"
            case signInMethod = "signInMethod"
            case userPoolName = "userPoolName"
            case verificationMessage = "verificationMessage"
        }
    }

    public struct CreateBackendAuthVerificationMessageConfig: AWSEncodableShape & AWSDecodableShape {
        /// The type of verification message to send.
        public let deliveryMethod: DeliveryMethod?
        /// The settings for the email message.
        public let emailSettings: EmailSettings?
        /// The settings for the SMS message.
        public let smsSettings: SmsSettings?

        @inlinable
        public init(deliveryMethod: DeliveryMethod? = nil, emailSettings: EmailSettings? = nil, smsSettings: SmsSettings? = nil) {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryMethod = "deliveryMethod"
            case emailSettings = "emailSettings"
            case smsSettings = "smsSettings"
        }
    }

    public struct CreateBackendConfigRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The app ID for the backend manager.
        public let backendManagerAppId: String?

        @inlinable
        public init(appId: String, backendManagerAppId: String? = nil) {
            self.appId = appId
            self.backendManagerAppId = backendManagerAppId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            try container.encodeIfPresent(self.backendManagerAppId, forKey: .backendManagerAppId)
        }

        private enum CodingKeys: String, CodingKey {
            case backendManagerAppId = "backendManagerAppId"
        }
    }

    public struct CreateBackendConfigResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The ID for the job.
        public let jobId: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, jobId: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.jobId = jobId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case jobId = "jobId"
            case status = "status"
        }
    }

    public struct CreateBackendRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the app.
        public let appName: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The resource configuration for creating a backend.
        public let resourceConfig: ResourceConfig?
        /// The name of the resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String? = nil, appName: String? = nil, backendEnvironmentName: String? = nil, resourceConfig: ResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.appName = appName
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appName = "appName"
            case backendEnvironmentName = "backendEnvironmentName"
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct CreateBackendResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct CreateBackendStorageRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The resource configuration for creating backend storage.
        public let resourceConfig: CreateBackendStorageResourceConfig?
        /// The name of the storage resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String? = nil, resourceConfig: CreateBackendStorageResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            try container.encodeIfPresent(self.backendEnvironmentName, forKey: .backendEnvironmentName)
            try container.encodeIfPresent(self.resourceConfig, forKey: .resourceConfig)
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case backendEnvironmentName = "backendEnvironmentName"
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct CreateBackendStorageResourceConfig: AWSEncodableShape {
        /// The name of the S3 bucket.
        public let bucketName: String?
        /// The authorization configuration for the storage S3 bucket.
        public let permissions: BackendStoragePermissions?
        /// The name of the storage service.
        public let serviceName: ServiceName?

        @inlinable
        public init(bucketName: String? = nil, permissions: BackendStoragePermissions? = nil, serviceName: ServiceName? = nil) {
            self.bucketName = bucketName
            self.permissions = permissions
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case permissions = "permissions"
            case serviceName = "serviceName"
        }
    }

    public struct CreateBackendStorageResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The ID for the job.
        public let jobId: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, jobId: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.jobId = jobId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case jobId = "jobId"
            case status = "status"
        }
    }

    public struct CreateTokenRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String

        @inlinable
        public init(appId: String) {
            self.appId = appId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateTokenResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// One-time challenge code for authenticating into the Amplify Admin UI.
        public let challengeCode: String?
        /// A unique ID provided when creating a new challenge token.
        public let sessionId: String?
        /// The expiry time for the one-time generated token code.
        public let ttl: String?

        @inlinable
        public init(appId: String? = nil, challengeCode: String? = nil, sessionId: String? = nil, ttl: String? = nil) {
            self.appId = appId
            self.challengeCode = challengeCode
            self.sessionId = sessionId
            self.ttl = ttl
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case challengeCode = "challengeCode"
            case sessionId = "sessionId"
            case ttl = "ttl"
        }
    }

    public struct DeleteBackendAPIRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// Defines the resource configuration for the data model in your Amplify project.
        public let resourceConfig: BackendAPIResourceConfig?
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, resourceConfig: BackendAPIResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.resourceConfig, forKey: .resourceConfig)
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct DeleteBackendAPIResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct DeleteBackendAuthRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceName = "resourceName"
        }
    }

    public struct DeleteBackendAuthResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct DeleteBackendRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String

        @inlinable
        public init(appId: String, backendEnvironmentName: String) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBackendResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct DeleteBackendStorageRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The name of the storage resource.
        public let resourceName: String?
        /// The name of the storage service.
        public let serviceName: ServiceName?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, resourceName: String? = nil, serviceName: ServiceName? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceName = resourceName
            self.serviceName = serviceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
            try container.encodeIfPresent(self.serviceName, forKey: .serviceName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceName = "resourceName"
            case serviceName = "serviceName"
        }
    }

    public struct DeleteBackendStorageResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The ID for the job.
        public let jobId: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, jobId: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.jobId = jobId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case jobId = "jobId"
            case status = "status"
        }
    }

    public struct DeleteTokenRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The session ID.
        public let sessionId: String

        @inlinable
        public init(appId: String, sessionId: String) {
            self.appId = appId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.sessionId, key: "SessionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTokenResponse: AWSDecodableShape {
        /// Indicates whether the request succeeded or failed.
        public let isSuccess: Bool?

        @inlinable
        public init(isSuccess: Bool? = nil) {
            self.isSuccess = isSuccess
        }

        private enum CodingKeys: String, CodingKey {
            case isSuccess = "isSuccess"
        }
    }

    public struct EmailSettings: AWSEncodableShape & AWSDecodableShape {
        /// The contents of the email message.
        public let emailMessage: String?
        /// The contents of the subject line of the email message.
        public let emailSubject: String?

        @inlinable
        public init(emailMessage: String? = nil, emailSubject: String? = nil) {
            self.emailMessage = emailMessage
            self.emailSubject = emailSubject
        }

        private enum CodingKeys: String, CodingKey {
            case emailMessage = "emailMessage"
            case emailSubject = "emailSubject"
        }
    }

    public struct GenerateBackendAPIModelsRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceName = "resourceName"
        }
    }

    public struct GenerateBackendAPIModelsResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct GetBackendAPIModelsRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceName = "resourceName"
        }
    }

    public struct GetBackendAPIModelsResponse: AWSDecodableShape {
        /// Stringified JSON of the model introspection schema for an existing backend API resource.
        public let modelIntrospectionSchema: String?
        /// Stringified JSON of the datastore model.
        public let models: String?
        /// The current status of the request.
        public let status: Status?

        @inlinable
        public init(modelIntrospectionSchema: String? = nil, models: String? = nil, status: Status? = nil) {
            self.modelIntrospectionSchema = modelIntrospectionSchema
            self.models = models
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case modelIntrospectionSchema = "modelIntrospectionSchema"
            case models = "models"
            case status = "status"
        }
    }

    public struct GetBackendAPIRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// Defines the resource configuration for the data model in your Amplify project.
        public let resourceConfig: BackendAPIResourceConfig?
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, resourceConfig: BackendAPIResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.resourceConfig, forKey: .resourceConfig)
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct GetBackendAPIResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The resource configuration for this response object.
        public let resourceConfig: BackendAPIResourceConfig?
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, resourceConfig: BackendAPIResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct GetBackendAuthRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceName = "resourceName"
        }
    }

    public struct GetBackendAuthResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The resource configuration for authorization requests to the backend of your Amplify project.
        public let resourceConfig: CreateBackendAuthResourceConfig?
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, resourceConfig: CreateBackendAuthResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct GetBackendJobRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The ID for the job.
        public let jobId: String

        @inlinable
        public init(appId: String, backendEnvironmentName: String, jobId: String) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            request.encodePath(self.jobId, key: "JobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackendJobResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The time when the job was created.
        public let createTime: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?
        /// The time when the job was last updated.
        public let updateTime: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, createTime: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil, updateTime: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.createTime = createTime
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case createTime = "createTime"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct GetBackendRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            try container.encodeIfPresent(self.backendEnvironmentName, forKey: .backendEnvironmentName)
        }

        private enum CodingKeys: String, CodingKey {
            case backendEnvironmentName = "backendEnvironmentName"
        }
    }

    public struct GetBackendResponse: AWSDecodableShape {
        /// A stringified version of the cli.json file for your Amplify project.
        public let amplifyFeatureFlags: String?
        /// A stringified version of the current configs for your Amplify project.
        public let amplifyMetaConfig: String?
        /// The app ID.
        public let appId: String?
        /// The name of the app.
        public let appName: String?
        /// A list of backend environments in an array.
        public let backendEnvironmentList: [String]?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request failed, this is the returned error.
        public let error: String?

        @inlinable
        public init(amplifyFeatureFlags: String? = nil, amplifyMetaConfig: String? = nil, appId: String? = nil, appName: String? = nil, backendEnvironmentList: [String]? = nil, backendEnvironmentName: String? = nil, error: String? = nil) {
            self.amplifyFeatureFlags = amplifyFeatureFlags
            self.amplifyMetaConfig = amplifyMetaConfig
            self.appId = appId
            self.appName = appName
            self.backendEnvironmentList = backendEnvironmentList
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case amplifyFeatureFlags = "amplifyFeatureFlags"
            case amplifyMetaConfig = "amplifyMetaConfig"
            case appId = "appId"
            case appName = "appName"
            case backendEnvironmentList = "backendEnvironmentList"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
        }
    }

    public struct GetBackendStorageRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The name of the storage resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceName = "resourceName"
        }
    }

    public struct GetBackendStorageResourceConfig: AWSDecodableShape {
        /// The name of the S3 bucket.
        public let bucketName: String?
        /// Returns True if the storage resource has been imported.
        public let imported: Bool?
        /// The authorization configuration for the storage S3 bucket.
        public let permissions: BackendStoragePermissions?
        /// The name of the storage service.
        public let serviceName: ServiceName?

        @inlinable
        public init(bucketName: String? = nil, imported: Bool? = nil, permissions: BackendStoragePermissions? = nil, serviceName: ServiceName? = nil) {
            self.bucketName = bucketName
            self.imported = imported
            self.permissions = permissions
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case imported = "imported"
            case permissions = "permissions"
            case serviceName = "serviceName"
        }
    }

    public struct GetBackendStorageResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The resource configuration for the backend storage resource.
        public let resourceConfig: GetBackendStorageResourceConfig?
        /// The name of the storage resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, resourceConfig: GetBackendStorageResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct GetTokenRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The session ID.
        public let sessionId: String

        @inlinable
        public init(appId: String, sessionId: String) {
            self.appId = appId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.sessionId, key: "SessionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTokenResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The one-time challenge code for authenticating into the Amplify Admin UI.
        public let challengeCode: String?
        /// A unique ID provided when creating a new challenge token.
        public let sessionId: String?
        /// The expiry time for the one-time generated token code.
        public let ttl: String?

        @inlinable
        public init(appId: String? = nil, challengeCode: String? = nil, sessionId: String? = nil, ttl: String? = nil) {
            self.appId = appId
            self.challengeCode = challengeCode
            self.sessionId = sessionId
            self.ttl = ttl
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case challengeCode = "challengeCode"
            case sessionId = "sessionId"
            case ttl = "ttl"
        }
    }

    public struct ImportBackendAuthRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The ID of the Amazon Cognito identity pool.
        public let identityPoolId: String?
        /// The ID of the Amazon Cognito native client.
        public let nativeClientId: String?
        /// The ID of the Amazon Cognito user pool.
        public let userPoolId: String?
        /// The ID of the Amazon Cognito web client.
        public let webClientId: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, identityPoolId: String? = nil, nativeClientId: String? = nil, userPoolId: String? = nil, webClientId: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.identityPoolId = identityPoolId
            self.nativeClientId = nativeClientId
            self.userPoolId = userPoolId
            self.webClientId = webClientId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.identityPoolId, forKey: .identityPoolId)
            try container.encodeIfPresent(self.nativeClientId, forKey: .nativeClientId)
            try container.encodeIfPresent(self.userPoolId, forKey: .userPoolId)
            try container.encodeIfPresent(self.webClientId, forKey: .webClientId)
        }

        private enum CodingKeys: String, CodingKey {
            case identityPoolId = "identityPoolId"
            case nativeClientId = "nativeClientId"
            case userPoolId = "userPoolId"
            case webClientId = "webClientId"
        }
    }

    public struct ImportBackendAuthResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct ImportBackendStorageRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The name of the S3 bucket.
        public let bucketName: String?
        /// The name of the storage service.
        public let serviceName: ServiceName?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, bucketName: String? = nil, serviceName: ServiceName? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.bucketName = bucketName
            self.serviceName = serviceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.bucketName, forKey: .bucketName)
            try container.encodeIfPresent(self.serviceName, forKey: .serviceName)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case serviceName = "serviceName"
        }
    }

    public struct ImportBackendStorageResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The ID for the job.
        public let jobId: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, jobId: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.jobId = jobId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case jobId = "jobId"
            case status = "status"
        }
    }

    public struct ListBackendJobsRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The ID for the job.
        public let jobId: String?
        /// The maximum number of results that you want in the response.
        public let maxResults: Int?
        /// The token for the next set of results.
        public let nextToken: String?
        /// Filters the list of response objects to include only those with the specified operation name.
        public let operation: String?
        /// Filters the list of response objects to include only those with the specified status.
        public let status: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, jobId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.operation = operation
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.jobId, forKey: .jobId)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.operation, forKey: .operation)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct ListBackendJobsResponse: AWSDecodableShape {
        /// An array of jobs and their properties.
        public let jobs: [BackendJobRespObj]?
        /// The token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(jobs: [BackendJobRespObj]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListS3BucketsRequest: AWSEncodableShape {
        /// Reserved for future use.
        public let nextToken: String?

        @inlinable
        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
        }
    }

    public struct ListS3BucketsResponse: AWSDecodableShape {
        /// The list of S3 buckets.
        public let buckets: [S3BucketInfo]?
        /// Reserved for future use.
        public let nextToken: String?

        @inlinable
        public init(buckets: [S3BucketInfo]? = nil, nextToken: String? = nil) {
            self.buckets = buckets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case buckets = "buckets"
            case nextToken = "nextToken"
        }
    }

    public struct LoginAuthConfigReqObj: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Cognito identity pool ID used for the Amplify Admin UI login authorization.
        public let awsCognitoIdentityPoolId: String?
        /// The AWS Region for the Amplify Admin UI login.
        public let awsCognitoRegion: String?
        /// The Amazon Cognito user pool ID used for Amplify Admin UI login authentication.
        public let awsUserPoolsId: String?
        /// The web client ID for the Amazon Cognito user pools.
        public let awsUserPoolsWebClientId: String?

        @inlinable
        public init(awsCognitoIdentityPoolId: String? = nil, awsCognitoRegion: String? = nil, awsUserPoolsId: String? = nil, awsUserPoolsWebClientId: String? = nil) {
            self.awsCognitoIdentityPoolId = awsCognitoIdentityPoolId
            self.awsCognitoRegion = awsCognitoRegion
            self.awsUserPoolsId = awsUserPoolsId
            self.awsUserPoolsWebClientId = awsUserPoolsWebClientId
        }

        private enum CodingKeys: String, CodingKey {
            case awsCognitoIdentityPoolId = "aws_cognito_identity_pool_id"
            case awsCognitoRegion = "aws_cognito_region"
            case awsUserPoolsId = "aws_user_pools_id"
            case awsUserPoolsWebClientId = "aws_user_pools_web_client_id"
        }
    }

    public struct NotFoundException: AWSErrorShape {
        /// An error message to inform that the request has failed.
        public let message: String?
        /// The type of resource that is not found.
        public let resourceType: String?

        @inlinable
        public init(message: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceType = "resourceType"
        }
    }

    public struct RemoveAllBackendsRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// Cleans up the Amplify Console app if this value is set to true.
        public let cleanAmplifyApp: Bool?

        @inlinable
        public init(appId: String, cleanAmplifyApp: Bool? = nil) {
            self.appId = appId
            self.cleanAmplifyApp = cleanAmplifyApp
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            try container.encodeIfPresent(self.cleanAmplifyApp, forKey: .cleanAmplifyApp)
        }

        private enum CodingKeys: String, CodingKey {
            case cleanAmplifyApp = "cleanAmplifyApp"
        }
    }

    public struct RemoveAllBackendsResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct RemoveBackendConfigRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String

        @inlinable
        public init(appId: String) {
            self.appId = appId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveBackendConfigResponse: AWSDecodableShape {
        /// If the request fails, this error is returned.
        public let error: String?

        @inlinable
        public init(error: String? = nil) {
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
        }
    }

    public struct ResourceConfig: AWSEncodableShape {
        public init() {}
    }

    public struct S3BucketInfo: AWSDecodableShape {
        /// The creation date of the S3 bucket.
        public let creationDate: String?
        /// The name of the S3 bucket.
        public let name: String?

        @inlinable
        public init(creationDate: String? = nil, name: String? = nil) {
            self.creationDate = creationDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case name = "name"
        }
    }

    public struct Settings: AWSEncodableShape & AWSDecodableShape {
        /// The supported MFA types.
        public let mfaTypes: [MfaTypesElement]?
        /// The body of the SMS message.
        public let smsMessage: String?

        @inlinable
        public init(mfaTypes: [MfaTypesElement]? = nil, smsMessage: String? = nil) {
            self.mfaTypes = mfaTypes
            self.smsMessage = smsMessage
        }

        private enum CodingKeys: String, CodingKey {
            case mfaTypes = "mfaTypes"
            case smsMessage = "smsMessage"
        }
    }

    public struct SmsSettings: AWSEncodableShape & AWSDecodableShape {
        /// The contents of the SMS message.
        public let smsMessage: String?

        @inlinable
        public init(smsMessage: String? = nil) {
            self.smsMessage = smsMessage
        }

        private enum CodingKeys: String, CodingKey {
            case smsMessage = "smsMessage"
        }
    }

    public struct SocialProviderSettings: AWSEncodableShape & AWSDecodableShape {
        public let facebook: BackendAuthSocialProviderConfig?
        public let google: BackendAuthSocialProviderConfig?
        public let loginWithAmazon: BackendAuthSocialProviderConfig?
        public let signInWithApple: BackendAuthAppleProviderConfig?

        @inlinable
        public init(facebook: BackendAuthSocialProviderConfig? = nil, google: BackendAuthSocialProviderConfig? = nil, loginWithAmazon: BackendAuthSocialProviderConfig? = nil, signInWithApple: BackendAuthAppleProviderConfig? = nil) {
            self.facebook = facebook
            self.google = google
            self.loginWithAmazon = loginWithAmazon
            self.signInWithApple = signInWithApple
        }

        private enum CodingKeys: String, CodingKey {
            case facebook = "Facebook"
            case google = "Google"
            case loginWithAmazon = "LoginWithAmazon"
            case signInWithApple = "SignInWithApple"
        }
    }

    public struct TooManyRequestsException: AWSErrorShape {
        /// The type of limit that was exceeded.
        public let limitType: String?
        /// An error message to inform that the request has failed.
        public let message: String?

        @inlinable
        public init(limitType: String? = nil, message: String? = nil) {
            self.limitType = limitType
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case limitType = "limitType"
            case message = "message"
        }
    }

    public struct UpdateBackendAPIRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// Defines the resource configuration for the data model in your Amplify project.
        public let resourceConfig: BackendAPIResourceConfig?
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, resourceConfig: BackendAPIResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.resourceConfig, forKey: .resourceConfig)
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct UpdateBackendAPIResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct UpdateBackendAuthForgotPasswordConfig: AWSEncodableShape {
        /// (DEPRECATED) Describes which mode to use (either SMS or email) to deliver messages to app users that want to recover their password.
        public let deliveryMethod: DeliveryMethod?
        /// (DEPRECATED) The configuration for the email sent when an app user forgets their password.
        public let emailSettings: EmailSettings?
        /// (DEPRECATED) The configuration for the SMS message sent when an Amplify app user forgets their password.
        public let smsSettings: SmsSettings?

        @inlinable
        public init(deliveryMethod: DeliveryMethod? = nil, emailSettings: EmailSettings? = nil, smsSettings: SmsSettings? = nil) {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryMethod = "deliveryMethod"
            case emailSettings = "emailSettings"
            case smsSettings = "smsSettings"
        }
    }

    public struct UpdateBackendAuthIdentityPoolConfig: AWSEncodableShape {
        /// A boolean value that can be set to allow or disallow guest-level authorization into your Amplify app.
        public let unauthenticatedLogin: Bool?

        @inlinable
        public init(unauthenticatedLogin: Bool? = nil) {
            self.unauthenticatedLogin = unauthenticatedLogin
        }

        private enum CodingKeys: String, CodingKey {
            case unauthenticatedLogin = "unauthenticatedLogin"
        }
    }

    public struct UpdateBackendAuthMFAConfig: AWSEncodableShape {
        /// The MFA mode for the backend of your Amplify project.
        public let mfaMode: MFAMode?
        /// The settings of your MFA configuration for the backend of your Amplify project.
        public let settings: Settings?

        @inlinable
        public init(mfaMode: MFAMode? = nil, settings: Settings? = nil) {
            self.mfaMode = mfaMode
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case mfaMode = "MFAMode"
            case settings = "settings"
        }
    }

    public struct UpdateBackendAuthOAuthConfig: AWSEncodableShape {
        /// The Amazon Cognito domain prefix used to create a hosted UI for authentication.
        public let domainPrefix: String?
        /// The OAuth grant type to allow app users to authenticate from your Amplify app.
        public let oAuthGrantType: OAuthGrantType?
        /// The list of OAuth-related flows that can allow users to authenticate from your Amplify app.
        public let oAuthScopes: [OAuthScopesElement]?
        /// Redirect URLs that OAuth uses when a user signs in to an Amplify app.
        public let redirectSignInURIs: [String]?
        /// Redirect URLs that OAuth uses when a user signs out of an Amplify app.
        public let redirectSignOutURIs: [String]?
        /// Describes third-party social federation configurations for allowing your users to sign in with OAuth.
        public let socialProviderSettings: SocialProviderSettings?

        @inlinable
        public init(domainPrefix: String? = nil, oAuthGrantType: OAuthGrantType? = nil, oAuthScopes: [OAuthScopesElement]? = nil, redirectSignInURIs: [String]? = nil, redirectSignOutURIs: [String]? = nil, socialProviderSettings: SocialProviderSettings? = nil) {
            self.domainPrefix = domainPrefix
            self.oAuthGrantType = oAuthGrantType
            self.oAuthScopes = oAuthScopes
            self.redirectSignInURIs = redirectSignInURIs
            self.redirectSignOutURIs = redirectSignOutURIs
            self.socialProviderSettings = socialProviderSettings
        }

        private enum CodingKeys: String, CodingKey {
            case domainPrefix = "domainPrefix"
            case oAuthGrantType = "oAuthGrantType"
            case oAuthScopes = "oAuthScopes"
            case redirectSignInURIs = "redirectSignInURIs"
            case redirectSignOutURIs = "redirectSignOutURIs"
            case socialProviderSettings = "socialProviderSettings"
        }
    }

    public struct UpdateBackendAuthPasswordPolicyConfig: AWSEncodableShape {
        /// Describes additional constraints on password requirements to sign in to the auth resource, configured as a part of your Amplify project.
        public let additionalConstraints: [AdditionalConstraintsElement]?
        /// Describes the minimum length of the password required to sign in to the auth resource, configured as a part of your Amplify project.
        public let minimumLength: Double?

        @inlinable
        public init(additionalConstraints: [AdditionalConstraintsElement]? = nil, minimumLength: Double? = nil) {
            self.additionalConstraints = additionalConstraints
            self.minimumLength = minimumLength
        }

        private enum CodingKeys: String, CodingKey {
            case additionalConstraints = "additionalConstraints"
            case minimumLength = "minimumLength"
        }
    }

    public struct UpdateBackendAuthRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The resource configuration for this request object.
        public let resourceConfig: UpdateBackendAuthResourceConfig?
        /// The name of this resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, resourceConfig: UpdateBackendAuthResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.resourceConfig, forKey: .resourceConfig)
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct UpdateBackendAuthResourceConfig: AWSEncodableShape {
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        public let authResources: AuthResources?
        /// Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.
        public let identityPoolConfigs: UpdateBackendAuthIdentityPoolConfig?
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        public let service: Service?
        /// Describes the authentication configuration for the Amazon Cognito user pool, provisioned as a part of your auth resource in the Amplify project.
        public let userPoolConfigs: UpdateBackendAuthUserPoolConfig?

        @inlinable
        public init(authResources: AuthResources? = nil, identityPoolConfigs: UpdateBackendAuthIdentityPoolConfig? = nil, service: Service? = nil, userPoolConfigs: UpdateBackendAuthUserPoolConfig? = nil) {
            self.authResources = authResources
            self.identityPoolConfigs = identityPoolConfigs
            self.service = service
            self.userPoolConfigs = userPoolConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case authResources = "authResources"
            case identityPoolConfigs = "identityPoolConfigs"
            case service = "service"
            case userPoolConfigs = "userPoolConfigs"
        }
    }

    public struct UpdateBackendAuthResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
        }
    }

    public struct UpdateBackendAuthUserPoolConfig: AWSEncodableShape {
        /// (DEPRECATED) Describes the forgot password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let forgotPassword: UpdateBackendAuthForgotPasswordConfig?
        /// Describes whether to apply multi-factor authentication policies for your Amazon Cognito user pool configured as a part of your Amplify project.
        public let mfa: UpdateBackendAuthMFAConfig?
        /// Describes the OAuth policy and rules for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let oAuth: UpdateBackendAuthOAuthConfig?
        /// Describes the password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let passwordPolicy: UpdateBackendAuthPasswordPolicyConfig?
        /// Describes the email or SMS verification message for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let verificationMessage: UpdateBackendAuthVerificationMessageConfig?

        @inlinable
        public init(forgotPassword: UpdateBackendAuthForgotPasswordConfig? = nil, mfa: UpdateBackendAuthMFAConfig? = nil, oAuth: UpdateBackendAuthOAuthConfig? = nil, passwordPolicy: UpdateBackendAuthPasswordPolicyConfig? = nil, verificationMessage: UpdateBackendAuthVerificationMessageConfig? = nil) {
            self.forgotPassword = forgotPassword
            self.mfa = mfa
            self.oAuth = oAuth
            self.passwordPolicy = passwordPolicy
            self.verificationMessage = verificationMessage
        }

        private enum CodingKeys: String, CodingKey {
            case forgotPassword = "forgotPassword"
            case mfa = "mfa"
            case oAuth = "oAuth"
            case passwordPolicy = "passwordPolicy"
            case verificationMessage = "verificationMessage"
        }
    }

    public struct UpdateBackendAuthVerificationMessageConfig: AWSEncodableShape {
        /// The type of verification message to send.
        public let deliveryMethod: DeliveryMethod?
        /// The settings for the email message.
        public let emailSettings: EmailSettings?
        /// The settings for the SMS message.
        public let smsSettings: SmsSettings?

        @inlinable
        public init(deliveryMethod: DeliveryMethod? = nil, emailSettings: EmailSettings? = nil, smsSettings: SmsSettings? = nil) {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryMethod = "deliveryMethod"
            case emailSettings = "emailSettings"
            case smsSettings = "smsSettings"
        }
    }

    public struct UpdateBackendConfigRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// Describes the Amazon Cognito configuration for Admin UI access.
        public let loginAuthConfig: LoginAuthConfigReqObj?

        @inlinable
        public init(appId: String, loginAuthConfig: LoginAuthConfigReqObj? = nil) {
            self.appId = appId
            self.loginAuthConfig = loginAuthConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            try container.encodeIfPresent(self.loginAuthConfig, forKey: .loginAuthConfig)
        }

        private enum CodingKeys: String, CodingKey {
            case loginAuthConfig = "loginAuthConfig"
        }
    }

    public struct UpdateBackendConfigResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The app ID for the backend manager.
        public let backendManagerAppId: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// Describes the Amazon Cognito configurations for the Admin UI auth resource to log in with.
        public let loginAuthConfig: LoginAuthConfigReqObj?

        @inlinable
        public init(appId: String? = nil, backendManagerAppId: String? = nil, error: String? = nil, loginAuthConfig: LoginAuthConfigReqObj? = nil) {
            self.appId = appId
            self.backendManagerAppId = backendManagerAppId
            self.error = error
            self.loginAuthConfig = loginAuthConfig
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendManagerAppId = "backendManagerAppId"
            case error = "error"
            case loginAuthConfig = "loginAuthConfig"
        }
    }

    public struct UpdateBackendJobRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The ID for the job.
        public let jobId: String
        /// Filters the list of response objects to include only those with the specified operation name.
        public let operation: String?
        /// Filters the list of response objects to include only those with the specified status.
        public let status: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, jobId: String, operation: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.jobId = jobId
            self.operation = operation
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            request.encodePath(self.jobId, key: "JobId")
            try container.encodeIfPresent(self.operation, forKey: .operation)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        private enum CodingKeys: String, CodingKey {
            case operation = "operation"
            case status = "status"
        }
    }

    public struct UpdateBackendJobResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The time when the job was created.
        public let createTime: String?
        /// If the request fails, this error is returned.
        public let error: String?
        /// The ID for the job.
        public let jobId: String?
        /// The name of the operation.
        public let operation: String?
        /// The current status of the request.
        public let status: String?
        /// The time when the job was last updated.
        public let updateTime: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, createTime: String? = nil, error: String? = nil, jobId: String? = nil, operation: String? = nil, status: String? = nil, updateTime: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.createTime = createTime
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case createTime = "createTime"
            case error = "error"
            case jobId = "jobId"
            case operation = "operation"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct UpdateBackendStorageRequest: AWSEncodableShape {
        /// The app ID.
        public let appId: String
        /// The name of the backend environment.
        public let backendEnvironmentName: String
        /// The resource configuration for updating backend storage.
        public let resourceConfig: UpdateBackendStorageResourceConfig?
        /// The name of the storage resource.
        public let resourceName: String?

        @inlinable
        public init(appId: String, backendEnvironmentName: String, resourceConfig: UpdateBackendStorageResourceConfig? = nil, resourceName: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.resourceConfig = resourceConfig
            self.resourceName = resourceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "AppId")
            request.encodePath(self.backendEnvironmentName, key: "BackendEnvironmentName")
            try container.encodeIfPresent(self.resourceConfig, forKey: .resourceConfig)
            try container.encodeIfPresent(self.resourceName, forKey: .resourceName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceConfig = "resourceConfig"
            case resourceName = "resourceName"
        }
    }

    public struct UpdateBackendStorageResourceConfig: AWSEncodableShape {
        /// The authorization configuration for the storage S3 bucket.
        public let permissions: BackendStoragePermissions?
        /// The name of the storage service.
        public let serviceName: ServiceName?

        @inlinable
        public init(permissions: BackendStoragePermissions? = nil, serviceName: ServiceName? = nil) {
            self.permissions = permissions
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "permissions"
            case serviceName = "serviceName"
        }
    }

    public struct UpdateBackendStorageResponse: AWSDecodableShape {
        /// The app ID.
        public let appId: String?
        /// The name of the backend environment.
        public let backendEnvironmentName: String?
        /// The ID for the job.
        public let jobId: String?
        /// The current status of the request.
        public let status: String?

        @inlinable
        public init(appId: String? = nil, backendEnvironmentName: String? = nil, jobId: String? = nil, status: String? = nil) {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.jobId = jobId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case backendEnvironmentName = "backendEnvironmentName"
            case jobId = "jobId"
            case status = "status"
        }
    }
}

// MARK: - Errors

/// Error enum for AmplifyBackend
public struct AmplifyBackendErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case gatewayTimeoutException = "GatewayTimeoutException"
        case notFoundException = "NotFoundException"
        case tooManyRequestsException = "TooManyRequestsException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AmplifyBackend
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An error returned if a request is not formed properly.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// An error returned if there's a temporary issue with the service.
    public static var gatewayTimeoutException: Self { .init(.gatewayTimeoutException) }
    /// An error returned when a specific resource type is not found.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// An error that is returned when a limit of a specific type has been exceeded.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
}

extension AmplifyBackendErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "NotFoundException": AmplifyBackend.NotFoundException.self,
        "TooManyRequestsException": AmplifyBackend.TooManyRequestsException.self
    ]
}

extension AmplifyBackendErrorType: Equatable {
    public static func == (lhs: AmplifyBackendErrorType, rhs: AmplifyBackendErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AmplifyBackendErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
