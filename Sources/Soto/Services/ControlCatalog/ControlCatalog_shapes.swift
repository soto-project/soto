//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ControlCatalog {
    // MARK: Enums

    public enum ControlBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case detective = "DETECTIVE"
        case preventive = "PREVENTIVE"
        case proactive = "PROACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum ControlScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case global = "GLOBAL"
        case regional = "REGIONAL"
        public var description: String { return self.rawValue }
    }

    public enum ControlSeverity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case critical = "CRITICAL"
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociatedDomainSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the related domain.
        public let arn: String?
        /// The name of the related domain.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct AssociatedObjectiveSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the related objective.
        public let arn: String?
        /// The name of the related objective.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct CommonControlFilter: AWSEncodableShape {
        /// The objective that's used as filter criteria. You can use this parameter to specify one objective ARN at a time. Passing multiple ARNs in the CommonControlFilter isn’t currently supported.
        public let objectives: [ObjectiveResourceFilter]?

        @inlinable
        public init(objectives: [ObjectiveResourceFilter]? = nil) {
            self.objectives = objectives
        }

        public func validate(name: String) throws {
            try self.objectives?.forEach {
                try $0.validate(name: "\(name).objectives[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case objectives = "Objectives"
        }
    }

    public struct CommonControlSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies the common control.
        public let arn: String
        /// The time when the common control was created.
        public let createTime: Date
        /// The description of the common control.
        public let description: String
        /// The domain that the common control belongs to.
        public let domain: AssociatedDomainSummary
        /// The time when the common control was most recently updated.
        public let lastUpdateTime: Date
        /// The name of the common control.
        public let name: String
        /// The objective that the common control belongs to.
        public let objective: AssociatedObjectiveSummary

        @inlinable
        public init(arn: String, createTime: Date, description: String, domain: AssociatedDomainSummary, lastUpdateTime: Date, name: String, objective: AssociatedObjectiveSummary) {
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.domain = domain
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.objective = objective
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createTime = "CreateTime"
            case description = "Description"
            case domain = "Domain"
            case lastUpdateTime = "LastUpdateTime"
            case name = "Name"
            case objective = "Objective"
        }
    }

    public struct ControlParameter: AWSDecodableShape {
        /// The parameter name. This name is the parameter key when you call  EnableControl or  UpdateEnabledControl .
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ControlSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the control.
        public let arn: String
        /// An enumerated type, with the following possible values:
        public let behavior: ControlBehavior?
        /// A timestamp that notes the time when the control was released (start of its life) as a governance capability in Amazon Web Services.
        public let createTime: Date?
        /// A description of the control, as it may appear in the console. Describes the functionality of the control.
        public let description: String
        /// An object of type ImplementationSummary that describes how the control is implemented.
        public let implementation: ImplementationSummary?
        /// The display name of the control.
        public let name: String
        /// An enumerated type, with the following possible values:
        public let severity: ControlSeverity?

        @inlinable
        public init(arn: String, behavior: ControlBehavior? = nil, createTime: Date? = nil, description: String, implementation: ImplementationSummary? = nil, name: String, severity: ControlSeverity? = nil) {
            self.arn = arn
            self.behavior = behavior
            self.createTime = createTime
            self.description = description
            self.implementation = implementation
            self.name = name
            self.severity = severity
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case behavior = "Behavior"
            case createTime = "CreateTime"
            case description = "Description"
            case implementation = "Implementation"
            case name = "Name"
            case severity = "Severity"
        }
    }

    public struct DomainResourceFilter: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the domain.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 33)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:(aws(?:[-a-z]*)?):controlcatalog:::domain/[0-9a-z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct DomainSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies the domain.
        public let arn: String
        /// The time when the domain was created.
        public let createTime: Date
        /// The description of the domain.
        public let description: String
        /// The time when the domain was most recently updated.
        public let lastUpdateTime: Date
        /// The name of the domain.
        public let name: String

        @inlinable
        public init(arn: String, createTime: Date, description: String, lastUpdateTime: Date, name: String) {
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.lastUpdateTime = lastUpdateTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createTime = "CreateTime"
            case description = "Description"
            case lastUpdateTime = "LastUpdateTime"
            case name = "Name"
        }
    }

    public struct GetControlRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the control. It has one of the following formats:  Global format   arn:{PARTITION}:controlcatalog:::control/{CONTROL_CATALOG_OPAQUE_ID}   Or Regional format   arn:{PARTITION}:controltower:{REGION}::control/{CONTROL_TOWER_OPAQUE_ID}  Here is a more general pattern that covers Amazon Web Services Control Tower and Control Catalog ARNs:  ^arn:(aws(?:[-a-z]*)?):(controlcatalog|controltower):[a-zA-Z0-9-]*::control/[0-9a-zA-Z_\\-]+$
        public let controlArn: String

        @inlinable
        public init(controlArn: String) {
            self.controlArn = controlArn
        }

        public func validate(name: String) throws {
            try self.validate(self.controlArn, name: "controlArn", parent: name, max: 2048)
            try self.validate(self.controlArn, name: "controlArn", parent: name, min: 34)
            try self.validate(self.controlArn, name: "controlArn", parent: name, pattern: "^arn:(aws(?:[-a-z]*)?):(controlcatalog|controltower):[a-zA-Z0-9-]*::control/[0-9a-zA-Z_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case controlArn = "ControlArn"
        }
    }

    public struct GetControlResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the control.
        public let arn: String
        /// A term that identifies the control's functional behavior. One of Preventive, Detective, Proactive
        public let behavior: ControlBehavior
        /// A timestamp that notes the time when the control was released (start of its life) as a governance capability in Amazon Web Services.
        public let createTime: Date?
        /// A description of what the control does.
        public let description: String
        /// Returns information about the control, as an ImplementationDetails object that shows the underlying implementation type for a control.
        public let implementation: ImplementationDetails?
        /// The display name of the control.
        public let name: String
        /// Returns an array of ControlParameter objects that specify the parameters a control supports. An empty list is returned for controls that don’t support parameters.
        public let parameters: [ControlParameter]?
        public let regionConfiguration: RegionConfiguration
        /// An enumerated type, with the following possible values:
        public let severity: ControlSeverity?

        @inlinable
        public init(arn: String, behavior: ControlBehavior, createTime: Date? = nil, description: String, implementation: ImplementationDetails? = nil, name: String, parameters: [ControlParameter]? = nil, regionConfiguration: RegionConfiguration, severity: ControlSeverity? = nil) {
            self.arn = arn
            self.behavior = behavior
            self.createTime = createTime
            self.description = description
            self.implementation = implementation
            self.name = name
            self.parameters = parameters
            self.regionConfiguration = regionConfiguration
            self.severity = severity
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case behavior = "Behavior"
            case createTime = "CreateTime"
            case description = "Description"
            case implementation = "Implementation"
            case name = "Name"
            case parameters = "Parameters"
            case regionConfiguration = "RegionConfiguration"
            case severity = "Severity"
        }
    }

    public struct ImplementationDetails: AWSDecodableShape {
        /// A service-specific identifier for the control, assigned by the service that implemented the control. For example, this identifier could be an Amazon Web Services Config Rule ID or a Security Hub Control ID.
        public let identifier: String?
        /// A string that describes a control's implementation type.
        public let type: String

        @inlinable
        public init(identifier: String? = nil, type: String) {
            self.identifier = identifier
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "Identifier"
            case type = "Type"
        }
    }

    public struct ImplementationSummary: AWSDecodableShape {
        /// The identifier originally assigned by the Amazon Web Services service that implements the control. For example, CODEPIPELINE_DEPLOYMENT_COUNT_CHECK.
        public let identifier: String?
        /// A string that represents the Amazon Web Services service that implements this control. For example, a value of AWS::Config::ConfigRule indicates that the control is implemented by Amazon Web Services Config, and AWS::SecurityHub::SecurityControl indicates implementation by Amazon Web Services Security Hub.
        public let type: String

        @inlinable
        public init(identifier: String? = nil, type: String) {
            self.identifier = identifier
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "Identifier"
            case type = "Type"
        }
    }

    public struct ListCommonControlsRequest: AWSEncodableShape {
        /// An optional filter that narrows the results to a specific objective. This filter allows you to specify one objective ARN at a time. Passing multiple ARNs in the CommonControlFilter isn’t currently supported.
        public let commonControlFilter: CommonControlFilter?
        /// The maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(commonControlFilter: CommonControlFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.commonControlFilter = commonControlFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.commonControlFilter, forKey: .commonControlFilter)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.commonControlFilter?.validate(name: "\(name).commonControlFilter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case commonControlFilter = "CommonControlFilter"
        }
    }

    public struct ListCommonControlsResponse: AWSDecodableShape {
        /// The list of common controls that the ListCommonControls API returns.
        public let commonControls: [CommonControlSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(commonControls: [CommonControlSummary], nextToken: String? = nil) {
            self.commonControls = commonControls
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case commonControls = "CommonControls"
            case nextToken = "NextToken"
        }
    }

    public struct ListControlsRequest: AWSEncodableShape {
        /// The maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListControlsResponse: AWSDecodableShape {
        /// Returns a list of controls, given as structures of type controlSummary.
        public let controls: [ControlSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(controls: [ControlSummary], nextToken: String? = nil) {
            self.controls = controls
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controls = "Controls"
            case nextToken = "NextToken"
        }
    }

    public struct ListDomainsRequest: AWSEncodableShape {
        /// The maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainsResponse: AWSDecodableShape {
        /// The list of domains that the ListDomains API returns.
        public let domains: [DomainSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(domains: [DomainSummary], nextToken: String? = nil) {
            self.domains = domains
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domains = "Domains"
            case nextToken = "NextToken"
        }
    }

    public struct ListObjectivesRequest: AWSEncodableShape {
        /// The maximum number of results on a page or for an API request call.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// An optional filter that narrows the results to a specific domain. This filter allows you to specify one domain ARN at a time.  Passing multiple ARNs in the ObjectiveFilter isn’t currently supported.
        public let objectiveFilter: ObjectiveFilter?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, objectiveFilter: ObjectiveFilter? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectiveFilter = objectiveFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encodeIfPresent(self.objectiveFilter, forKey: .objectiveFilter)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.objectiveFilter?.validate(name: "\(name).objectiveFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case objectiveFilter = "ObjectiveFilter"
        }
    }

    public struct ListObjectivesResponse: AWSDecodableShape {
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// The list of objectives that the ListObjectives API returns.
        public let objectives: [ObjectiveSummary]

        @inlinable
        public init(nextToken: String? = nil, objectives: [ObjectiveSummary]) {
            self.nextToken = nextToken
            self.objectives = objectives
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case objectives = "Objectives"
        }
    }

    public struct ObjectiveFilter: AWSEncodableShape {
        /// The domain that's used as filter criteria. You can use this parameter to specify one domain ARN at a time. Passing multiple ARNs in the ObjectiveFilter isn’t currently supported.
        public let domains: [DomainResourceFilter]?

        @inlinable
        public init(domains: [DomainResourceFilter]? = nil) {
            self.domains = domains
        }

        public func validate(name: String) throws {
            try self.domains?.forEach {
                try $0.validate(name: "\(name).domains[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domains = "Domains"
        }
    }

    public struct ObjectiveResourceFilter: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the objective.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 36)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:(aws(?:[-a-z]*)?):controlcatalog:::objective/[0-9a-z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct ObjectiveSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies the objective.
        public let arn: String
        /// The time when the objective was created.
        public let createTime: Date
        /// The description of the objective.
        public let description: String
        /// The domain that the objective belongs to.
        public let domain: AssociatedDomainSummary
        /// The time when the objective was most recently updated.
        public let lastUpdateTime: Date
        /// The name of the objective.
        public let name: String

        @inlinable
        public init(arn: String, createTime: Date, description: String, domain: AssociatedDomainSummary, lastUpdateTime: Date, name: String) {
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.domain = domain
            self.lastUpdateTime = lastUpdateTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createTime = "CreateTime"
            case description = "Description"
            case domain = "Domain"
            case lastUpdateTime = "LastUpdateTime"
            case name = "Name"
        }
    }

    public struct RegionConfiguration: AWSDecodableShape {
        /// Regions in which the control is available to be deployed.
        public let deployableRegions: [String]?
        /// The coverage of the control, if deployed. Scope is an enumerated type, with value Regional, or Global. A control with Global scope is effective in all Amazon Web Services Regions, regardless of the Region from which it is enabled, or to which it is deployed. A control implemented by an SCP is usually Global in scope. A control with Regional scope has operations that are restricted specifically to the Region from which it is enabled and to which it is deployed. Controls implemented by Config rules and CloudFormation hooks usually are Regional in scope.  Security Hub controls usually are Regional in scope.
        public let scope: ControlScope

        @inlinable
        public init(deployableRegions: [String]? = nil, scope: ControlScope) {
            self.deployableRegions = deployableRegions
            self.scope = scope
        }

        private enum CodingKeys: String, CodingKey {
            case deployableRegions = "DeployableRegions"
            case scope = "Scope"
        }
    }
}

// MARK: - Errors

/// Error enum for ControlCatalog
public struct ControlCatalogErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ControlCatalog
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// An internal service error occurred during the processing of your request. Try again later.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request has invalid or missing parameters.
    public static var validationException: Self { .init(.validationException) }
}

extension ControlCatalogErrorType: Equatable {
    public static func == (lhs: ControlCatalogErrorType, rhs: ControlCatalogErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ControlCatalogErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
