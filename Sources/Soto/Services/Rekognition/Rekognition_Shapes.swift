//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension Rekognition {
    // MARK: Enums

    public enum Attribute: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case `default` = "DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum BodyPart: String, CustomStringConvertible, Codable {
        case face = "FACE"
        case head = "HEAD"
        case leftHand = "LEFT_HAND"
        case rightHand = "RIGHT_HAND"
        public var description: String { return self.rawValue }
    }

    public enum CelebrityRecognitionSortBy: String, CustomStringConvertible, Codable {
        case id = "ID"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum ContentClassifier: String, CustomStringConvertible, Codable {
        case freeofadultcontent = "FreeOfAdultContent"
        case freeofpersonallyidentifiableinformation = "FreeOfPersonallyIdentifiableInformation"
        public var description: String { return self.rawValue }
    }

    public enum ContentModerationSortBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum EmotionName: String, CustomStringConvertible, Codable {
        case angry = "ANGRY"
        case calm = "CALM"
        case confused = "CONFUSED"
        case disgusted = "DISGUSTED"
        case fear = "FEAR"
        case happy = "HAPPY"
        case sad = "SAD"
        case surprised = "SURPRISED"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum FaceAttributes: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case `default` = "DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum FaceSearchSortBy: String, CustomStringConvertible, Codable {
        case index = "INDEX"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum GenderType: String, CustomStringConvertible, Codable {
        case female = "Female"
        case male = "Male"
        public var description: String { return self.rawValue }
    }

    public enum LabelDetectionSortBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum LandmarkType: String, CustomStringConvertible, Codable {
        case chinbottom = "chinBottom"
        case eyeleft = "eyeLeft"
        case eyeright = "eyeRight"
        case lefteyebrowleft = "leftEyeBrowLeft"
        case lefteyebrowright = "leftEyeBrowRight"
        case lefteyebrowup = "leftEyeBrowUp"
        case lefteyedown = "leftEyeDown"
        case lefteyeleft = "leftEyeLeft"
        case lefteyeright = "leftEyeRight"
        case lefteyeup = "leftEyeUp"
        case leftpupil = "leftPupil"
        case midjawlineleft = "midJawlineLeft"
        case midjawlineright = "midJawlineRight"
        case mouthdown = "mouthDown"
        case mouthleft = "mouthLeft"
        case mouthright = "mouthRight"
        case mouthup = "mouthUp"
        case nose
        case noseleft = "noseLeft"
        case noseright = "noseRight"
        case righteyebrowleft = "rightEyeBrowLeft"
        case righteyebrowright = "rightEyeBrowRight"
        case righteyebrowup = "rightEyeBrowUp"
        case righteyedown = "rightEyeDown"
        case righteyeleft = "rightEyeLeft"
        case righteyeright = "rightEyeRight"
        case righteyeup = "rightEyeUp"
        case rightpupil = "rightPupil"
        case upperjawlineleft = "upperJawlineLeft"
        case upperjawlineright = "upperJawlineRight"
        public var description: String { return self.rawValue }
    }

    public enum OrientationCorrection: String, CustomStringConvertible, Codable {
        case rotate0 = "ROTATE_0"
        case rotate180 = "ROTATE_180"
        case rotate270 = "ROTATE_270"
        case rotate90 = "ROTATE_90"
        public var description: String { return self.rawValue }
    }

    public enum PersonTrackingSortBy: String, CustomStringConvertible, Codable {
        case index = "INDEX"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum ProjectStatus: String, CustomStringConvertible, Codable {
        case created = "CREATED"
        case creating = "CREATING"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ProjectVersionStatus: String, CustomStringConvertible, Codable {
        case deleting = "DELETING"
        case failed = "FAILED"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case trainingCompleted = "TRAINING_COMPLETED"
        case trainingFailed = "TRAINING_FAILED"
        case trainingInProgress = "TRAINING_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ProtectiveEquipmentType: String, CustomStringConvertible, Codable {
        case faceCover = "FACE_COVER"
        case handCover = "HAND_COVER"
        case headCover = "HEAD_COVER"
        public var description: String { return self.rawValue }
    }

    public enum QualityFilter: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum Reason: String, CustomStringConvertible, Codable {
        case exceedsMaxFaces = "EXCEEDS_MAX_FACES"
        case extremePose = "EXTREME_POSE"
        case lowBrightness = "LOW_BRIGHTNESS"
        case lowConfidence = "LOW_CONFIDENCE"
        case lowFaceQuality = "LOW_FACE_QUALITY"
        case lowSharpness = "LOW_SHARPNESS"
        case smallBoundingBox = "SMALL_BOUNDING_BOX"
        public var description: String { return self.rawValue }
    }

    public enum SegmentType: String, CustomStringConvertible, Codable {
        case shot = "SHOT"
        case technicalCue = "TECHNICAL_CUE"
        public var description: String { return self.rawValue }
    }

    public enum StreamProcessorStatus: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum TechnicalCueType: String, CustomStringConvertible, Codable {
        case blackframes = "BlackFrames"
        case colorbars = "ColorBars"
        case endcredits = "EndCredits"
        public var description: String { return self.rawValue }
    }

    public enum TextTypes: String, CustomStringConvertible, Codable {
        case line = "LINE"
        case word = "WORD"
        public var description: String { return self.rawValue }
    }

    public enum VideoJobStatus: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AgeRange: AWSDecodableShape {
        /// The highest estimated age.
        public let high: Int?
        /// The lowest estimated age.
        public let low: Int?

        public init(high: Int? = nil, low: Int? = nil) {
            self.high = high
            self.low = low
        }

        private enum CodingKeys: String, CodingKey {
            case high = "High"
            case low = "Low"
        }
    }

    public struct Asset: AWSEncodableShape & AWSDecodableShape {
        public let groundTruthManifest: GroundTruthManifest?

        public init(groundTruthManifest: GroundTruthManifest? = nil) {
            self.groundTruthManifest = groundTruthManifest
        }

        public func validate(name: String) throws {
            try self.groundTruthManifest?.validate(name: "\(name).groundTruthManifest")
        }

        private enum CodingKeys: String, CodingKey {
            case groundTruthManifest = "GroundTruthManifest"
        }
    }

    public struct AudioMetadata: AWSDecodableShape {
        /// The audio codec used to encode or decode the audio stream.
        public let codec: String?
        /// The duration of the audio stream in milliseconds.
        public let durationMillis: Int64?
        /// The number of audio channels in the segment.
        public let numberOfChannels: Int64?
        /// The sample rate for the audio stream.
        public let sampleRate: Int64?

        public init(codec: String? = nil, durationMillis: Int64? = nil, numberOfChannels: Int64? = nil, sampleRate: Int64? = nil) {
            self.codec = codec
            self.durationMillis = durationMillis
            self.numberOfChannels = numberOfChannels
            self.sampleRate = sampleRate
        }

        private enum CodingKeys: String, CodingKey {
            case codec = "Codec"
            case durationMillis = "DurationMillis"
            case numberOfChannels = "NumberOfChannels"
            case sampleRate = "SampleRate"
        }
    }

    public struct Beard: AWSDecodableShape {
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face has beard or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public struct BoundingBox: AWSEncodableShape & AWSDecodableShape {
        /// Height of the bounding box as a ratio of the overall image height.
        public let height: Float?
        /// Left coordinate of the bounding box as a ratio of overall image width.
        public let left: Float?
        /// Top coordinate of the bounding box as a ratio of overall image height.
        public let top: Float?
        /// Width of the bounding box as a ratio of the overall image width.
        public let width: Float?

        public init(height: Float? = nil, left: Float? = nil, top: Float? = nil, width: Float? = nil) {
            self.height = height
            self.left = left
            self.top = top
            self.width = width
        }

        private enum CodingKeys: String, CodingKey {
            case height = "Height"
            case left = "Left"
            case top = "Top"
            case width = "Width"
        }
    }

    public struct Celebrity: AWSDecodableShape {
        /// Provides information about the celebrity's face, such as its location on the image.
        public let face: ComparedFace?
        /// A unique identifier for the celebrity.
        public let id: String?
        /// The confidence, in percentage, that Amazon Rekognition has that the recognized face is the celebrity.
        public let matchConfidence: Float?
        /// The name of the celebrity.
        public let name: String?
        /// An array of URLs pointing to additional information about the celebrity. If there is no additional information about the celebrity, this list is empty.
        public let urls: [String]?

        public init(face: ComparedFace? = nil, id: String? = nil, matchConfidence: Float? = nil, name: String? = nil, urls: [String]? = nil) {
            self.face = face
            self.id = id
            self.matchConfidence = matchConfidence
            self.name = name
            self.urls = urls
        }

        private enum CodingKeys: String, CodingKey {
            case face = "Face"
            case id = "Id"
            case matchConfidence = "MatchConfidence"
            case name = "Name"
            case urls = "Urls"
        }
    }

    public struct CelebrityDetail: AWSDecodableShape {
        /// Bounding box around the body of a celebrity.
        public let boundingBox: BoundingBox?
        /// The confidence, in percentage, that Amazon Rekognition has that the recognized face is the celebrity.
        public let confidence: Float?
        /// Face details for the recognized celebrity.
        public let face: FaceDetail?
        /// The unique identifier for the celebrity.
        public let id: String?
        /// The name of the celebrity.
        public let name: String?
        /// An array of URLs pointing to additional celebrity information.
        public let urls: [String]?

        public init(boundingBox: BoundingBox? = nil, confidence: Float? = nil, face: FaceDetail? = nil, id: String? = nil, name: String? = nil, urls: [String]? = nil) {
            self.boundingBox = boundingBox
            self.confidence = confidence
            self.face = face
            self.id = id
            self.name = name
            self.urls = urls
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case confidence = "Confidence"
            case face = "Face"
            case id = "Id"
            case name = "Name"
            case urls = "Urls"
        }
    }

    public struct CelebrityRecognition: AWSDecodableShape {
        /// Information about a recognized celebrity.
        public let celebrity: CelebrityDetail?
        /// The time, in milliseconds from the start of the video, that the celebrity was recognized.
        public let timestamp: Int64?

        public init(celebrity: CelebrityDetail? = nil, timestamp: Int64? = nil) {
            self.celebrity = celebrity
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case celebrity = "Celebrity"
            case timestamp = "Timestamp"
        }
    }

    public struct CompareFacesMatch: AWSDecodableShape {
        /// Provides face metadata (bounding box and confidence that the bounding box actually contains a face).
        public let face: ComparedFace?
        /// Level of confidence that the faces match.
        public let similarity: Float?

        public init(face: ComparedFace? = nil, similarity: Float? = nil) {
            self.face = face
            self.similarity = similarity
        }

        private enum CodingKeys: String, CodingKey {
            case face = "Face"
            case similarity = "Similarity"
        }
    }

    public struct CompareFacesRequest: AWSEncodableShape {
        /// A filter that specifies a quality bar for how much filtering is done to identify faces. Filtered faces aren't compared. If you specify AUTO, Amazon Rekognition chooses the quality bar. If you specify LOW, MEDIUM, or HIGH, filtering removes all faces that don’t meet the chosen quality bar. The quality bar is based on a variety of common use cases. Low-quality detections can occur for a number of reasons. Some examples are an object that's misidentified as a face, a face that's too blurry, or a face with a pose that's too extreme to use. If you specify NONE, no filtering is performed. The default value is NONE.  To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.
        public let qualityFilter: QualityFilter?
        /// The minimum level of confidence in the face matches that a match must meet to be included in the FaceMatches array.
        public let similarityThreshold: Float?
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported.  If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes passed using the Bytes field. For more information, see Images in the Amazon Rekognition developer guide.
        public let sourceImage: Image
        /// The target image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported.  If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes passed using the Bytes field. For more information, see Images in the Amazon Rekognition developer guide.
        public let targetImage: Image

        public init(qualityFilter: QualityFilter? = nil, similarityThreshold: Float? = nil, sourceImage: Image, targetImage: Image) {
            self.qualityFilter = qualityFilter
            self.similarityThreshold = similarityThreshold
            self.sourceImage = sourceImage
            self.targetImage = targetImage
        }

        public func validate(name: String) throws {
            try self.validate(self.similarityThreshold, name: "similarityThreshold", parent: name, max: 100)
            try self.validate(self.similarityThreshold, name: "similarityThreshold", parent: name, min: 0)
            try self.sourceImage.validate(name: "\(name).sourceImage")
            try self.targetImage.validate(name: "\(name).targetImage")
        }

        private enum CodingKeys: String, CodingKey {
            case qualityFilter = "QualityFilter"
            case similarityThreshold = "SimilarityThreshold"
            case sourceImage = "SourceImage"
            case targetImage = "TargetImage"
        }
    }

    public struct CompareFacesResponse: AWSDecodableShape {
        /// An array of faces in the target image that match the source image face. Each CompareFacesMatch object provides the bounding box, the confidence level that the bounding box contains a face, and the similarity score for the face in the bounding box and the face in the source image.
        public let faceMatches: [CompareFacesMatch]?
        /// The face in the source image that was used for comparison.
        public let sourceImageFace: ComparedSourceImageFace?
        /// The value of SourceImageOrientationCorrection is always null. If the input image is in .jpeg format, it might contain exchangeable image file format (Exif) metadata that includes the image's orientation. Amazon Rekognition uses this orientation information to perform image correction. The bounding box coordinates are translated to represent object locations after the orientation information in the Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata. Amazon Rekognition doesn’t perform image correction for images in .png format and .jpeg images without orientation information in the image Exif metadata. The bounding box coordinates aren't translated and represent the object locations before the image is rotated.
        public let sourceImageOrientationCorrection: OrientationCorrection?
        /// The value of TargetImageOrientationCorrection is always null. If the input image is in .jpeg format, it might contain exchangeable image file format (Exif) metadata that includes the image's orientation. Amazon Rekognition uses this orientation information to perform image correction. The bounding box coordinates are translated to represent object locations after the orientation information in the Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata. Amazon Rekognition doesn’t perform image correction for images in .png format and .jpeg images without orientation information in the image Exif metadata. The bounding box coordinates aren't translated and represent the object locations before the image is rotated.
        public let targetImageOrientationCorrection: OrientationCorrection?
        /// An array of faces in the target image that did not match the source image face.
        public let unmatchedFaces: [ComparedFace]?

        public init(faceMatches: [CompareFacesMatch]? = nil, sourceImageFace: ComparedSourceImageFace? = nil, sourceImageOrientationCorrection: OrientationCorrection? = nil, targetImageOrientationCorrection: OrientationCorrection? = nil, unmatchedFaces: [ComparedFace]? = nil) {
            self.faceMatches = faceMatches
            self.sourceImageFace = sourceImageFace
            self.sourceImageOrientationCorrection = sourceImageOrientationCorrection
            self.targetImageOrientationCorrection = targetImageOrientationCorrection
            self.unmatchedFaces = unmatchedFaces
        }

        private enum CodingKeys: String, CodingKey {
            case faceMatches = "FaceMatches"
            case sourceImageFace = "SourceImageFace"
            case sourceImageOrientationCorrection = "SourceImageOrientationCorrection"
            case targetImageOrientationCorrection = "TargetImageOrientationCorrection"
            case unmatchedFaces = "UnmatchedFaces"
        }
    }

    public struct ComparedFace: AWSDecodableShape {
        /// Bounding box of the face.
        public let boundingBox: BoundingBox?
        /// Level of confidence that what the bounding box contains is a face.
        public let confidence: Float?
        /// An array of facial landmarks.
        public let landmarks: [Landmark]?
        /// Indicates the pose of the face as determined by its pitch, roll, and yaw.
        public let pose: Pose?
        /// Identifies face image brightness and sharpness.
        public let quality: ImageQuality?

        public init(boundingBox: BoundingBox? = nil, confidence: Float? = nil, landmarks: [Landmark]? = nil, pose: Pose? = nil, quality: ImageQuality? = nil) {
            self.boundingBox = boundingBox
            self.confidence = confidence
            self.landmarks = landmarks
            self.pose = pose
            self.quality = quality
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case confidence = "Confidence"
            case landmarks = "Landmarks"
            case pose = "Pose"
            case quality = "Quality"
        }
    }

    public struct ComparedSourceImageFace: AWSDecodableShape {
        /// Bounding box of the face.
        public let boundingBox: BoundingBox?
        /// Confidence level that the selected bounding box contains a face.
        public let confidence: Float?

        public init(boundingBox: BoundingBox? = nil, confidence: Float? = nil) {
            self.boundingBox = boundingBox
            self.confidence = confidence
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case confidence = "Confidence"
        }
    }

    public struct ContentModerationDetection: AWSDecodableShape {
        /// The unsafe content label detected by in the stored video.
        public let moderationLabel: ModerationLabel?
        /// Time, in milliseconds from the beginning of the video, that the unsafe content label was detected.
        public let timestamp: Int64?

        public init(moderationLabel: ModerationLabel? = nil, timestamp: Int64? = nil) {
            self.moderationLabel = moderationLabel
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case moderationLabel = "ModerationLabel"
            case timestamp = "Timestamp"
        }
    }

    public struct CoversBodyPart: AWSDecodableShape {
        /// The confidence that Amazon Rekognition has in the value of Value.
        public let confidence: Float?
        /// True if the PPE covers the corresponding body part, otherwise false.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public struct CreateCollectionRequest: AWSEncodableShape {
        /// ID for the collection that you are creating.
        public let collectionId: String
        ///  A set of tags (key-value pairs) that you want to attach to the collection.
        public let tags: [String: String]?

        public init(collectionId: String, tags: [String: String]? = nil) {
            self.collectionId = collectionId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionId, name: "collectionId", parent: name, max: 255)
            try self.validate(self.collectionId, name: "collectionId", parent: name, min: 1)
            try self.validate(self.collectionId, name: "collectionId", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
            case tags = "Tags"
        }
    }

    public struct CreateCollectionResponse: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the collection. You can use this to manage permissions on your resources.
        public let collectionArn: String?
        /// Version number of the face detection model associated with the collection you are creating.
        public let faceModelVersion: String?
        /// HTTP status code indicating the result of the operation.
        public let statusCode: Int?

        public init(collectionArn: String? = nil, faceModelVersion: String? = nil, statusCode: Int? = nil) {
            self.collectionArn = collectionArn
            self.faceModelVersion = faceModelVersion
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case faceModelVersion = "FaceModelVersion"
            case statusCode = "StatusCode"
        }
    }

    public struct CreateProjectRequest: AWSEncodableShape {
        /// The name of the project to create.
        public let projectName: String

        public init(projectName: String) {
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case projectName = "ProjectName"
        }
    }

    public struct CreateProjectResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new project. You can use the ARN to configure IAM access to the project.
        public let projectArn: String?

        public init(projectArn: String? = nil) {
            self.projectArn = projectArn
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "ProjectArn"
        }
    }

    public struct CreateProjectVersionRequest: AWSEncodableShape {
        /// The identifier for your AWS Key Management Service (AWS KMS) customer master key (CMK). You can supply the Amazon Resource Name (ARN) of your CMK, the ID of your CMK, or an alias for your CMK. The key is used to encrypt training and test images copied into the service for model training. Your source images are unaffected. The key is also used to encrypt training results and manifest files written to the output Amazon S3 bucket (OutputConfig). If you don't specify a value for KmsKeyId, images copied into the service are encrypted using a key that AWS owns and manages.
        public let kmsKeyId: String?
        /// The Amazon S3 location to store the results of training.
        public let outputConfig: OutputConfig
        /// The ARN of the Amazon Rekognition Custom Labels project that manages the model that you want to train.
        public let projectArn: String
        ///  A set of tags (key-value pairs) that you want to attach to the model.
        public let tags: [String: String]?
        /// The dataset to use for testing.
        public let testingData: TestingData
        /// The dataset to use for training.
        public let trainingData: TrainingData
        /// A name for the version of the model. This value must be unique.
        public let versionName: String

        public init(kmsKeyId: String? = nil, outputConfig: OutputConfig, projectArn: String, tags: [String: String]? = nil, testingData: TestingData, trainingData: TrainingData, versionName: String) {
            self.kmsKeyId = kmsKeyId
            self.outputConfig = outputConfig
            self.projectArn = projectArn
            self.tags = tags
            self.testingData = testingData
            self.trainingData = trainingData
            self.versionName = versionName
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,2048}$")
            try self.outputConfig.validate(name: "\(name).outputConfig")
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 2048)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 20)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "(^arn:[a-z\\d-]+:rekognition:[a-z\\d-]+:\\d{12}:project\\/[a-zA-Z0-9_.\\-]{1,255}\\/[0-9]+$)")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.testingData.validate(name: "\(name).testingData")
            try self.trainingData.validate(name: "\(name).trainingData")
            try self.validate(self.versionName, name: "versionName", parent: name, max: 255)
            try self.validate(self.versionName, name: "versionName", parent: name, min: 1)
            try self.validate(self.versionName, name: "versionName", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case outputConfig = "OutputConfig"
            case projectArn = "ProjectArn"
            case tags = "Tags"
            case testingData = "TestingData"
            case trainingData = "TrainingData"
            case versionName = "VersionName"
        }
    }

    public struct CreateProjectVersionResponse: AWSDecodableShape {
        /// The ARN of the model version that was created. Use DescribeProjectVersion to get the current status of the training operation.
        public let projectVersionArn: String?

        public init(projectVersionArn: String? = nil) {
            self.projectVersionArn = projectVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case projectVersionArn = "ProjectVersionArn"
        }
    }

    public struct CreateStreamProcessorRequest: AWSEncodableShape {
        /// Kinesis video stream stream that provides the source streaming video. If you are using the AWS CLI, the parameter name is StreamProcessorInput.
        public let input: StreamProcessorInput
        /// An identifier you assign to the stream processor. You can use Name to manage the stream processor. For example, you can get the current status of the stream processor by calling DescribeStreamProcessor. Name is idempotent.
        public let name: String
        /// Kinesis data stream stream to which Amazon Rekognition Video puts the analysis results. If you are using the AWS CLI, the parameter name is StreamProcessorOutput.
        public let output: StreamProcessorOutput
        /// ARN of the IAM role that allows access to the stream processor.
        public let roleArn: String
        /// Face recognition input parameters to be used by the stream processor. Includes the collection to use for face recognition and the face attributes to detect.
        public let settings: StreamProcessorSettings
        ///  A set of tags (key-value pairs) that you want to attach to the stream processor.
        public let tags: [String: String]?

        public init(input: StreamProcessorInput, name: String, output: StreamProcessorOutput, roleArn: String, settings: StreamProcessorSettings, tags: [String: String]? = nil) {
            self.input = input
            self.name = name
            self.output = output
            self.roleArn = roleArn
            self.settings = settings
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.input.validate(name: "\(name).input")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
            try self.output.validate(name: "\(name).output")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:aws:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
            try self.settings.validate(name: "\(name).settings")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case input = "Input"
            case name = "Name"
            case output = "Output"
            case roleArn = "RoleArn"
            case settings = "Settings"
            case tags = "Tags"
        }
    }

    public struct CreateStreamProcessorResponse: AWSDecodableShape {
        /// ARN for the newly create stream processor.
        public let streamProcessorArn: String?

        public init(streamProcessorArn: String? = nil) {
            self.streamProcessorArn = streamProcessorArn
        }

        private enum CodingKeys: String, CodingKey {
            case streamProcessorArn = "StreamProcessorArn"
        }
    }

    public struct CustomLabel: AWSDecodableShape {
        /// The confidence that the model has in the detection of the custom label. The range is 0-100. A higher value indicates a higher confidence.
        public let confidence: Float?
        /// The location of the detected object on the image that corresponds to the custom label. Includes an axis aligned coarse bounding box surrounding the object and a finer grain polygon for more accurate spatial information.
        public let geometry: Geometry?
        /// The name of the custom label.
        public let name: String?

        public init(confidence: Float? = nil, geometry: Geometry? = nil, name: String? = nil) {
            self.confidence = confidence
            self.geometry = geometry
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case geometry = "Geometry"
            case name = "Name"
        }
    }

    public struct DeleteCollectionRequest: AWSEncodableShape {
        /// ID of the collection to delete.
        public let collectionId: String

        public init(collectionId: String) {
            self.collectionId = collectionId
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionId, name: "collectionId", parent: name, max: 255)
            try self.validate(self.collectionId, name: "collectionId", parent: name, min: 1)
            try self.validate(self.collectionId, name: "collectionId", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
        }
    }

    public struct DeleteCollectionResponse: AWSDecodableShape {
        /// HTTP status code that indicates the result of the operation.
        public let statusCode: Int?

        public init(statusCode: Int? = nil) {
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "StatusCode"
        }
    }

    public struct DeleteFacesRequest: AWSEncodableShape {
        /// Collection from which to remove the specific faces.
        public let collectionId: String
        /// An array of face IDs to delete.
        public let faceIds: [String]

        public init(collectionId: String, faceIds: [String]) {
            self.collectionId = collectionId
            self.faceIds = faceIds
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionId, name: "collectionId", parent: name, max: 255)
            try self.validate(self.collectionId, name: "collectionId", parent: name, min: 1)
            try self.validate(self.collectionId, name: "collectionId", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
            try self.faceIds.forEach {
                try validate($0, name: "faceIds[]", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            }
            try self.validate(self.faceIds, name: "faceIds", parent: name, max: 4096)
            try self.validate(self.faceIds, name: "faceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
            case faceIds = "FaceIds"
        }
    }

    public struct DeleteFacesResponse: AWSDecodableShape {
        /// An array of strings (face IDs) of the faces that were deleted.
        public let deletedFaces: [String]?

        public init(deletedFaces: [String]? = nil) {
            self.deletedFaces = deletedFaces
        }

        private enum CodingKeys: String, CodingKey {
            case deletedFaces = "DeletedFaces"
        }
    }

    public struct DeleteProjectRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the project that you want to delete.
        public let projectArn: String

        public init(projectArn: String) {
            self.projectArn = projectArn
        }

        public func validate(name: String) throws {
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 2048)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 20)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "(^arn:[a-z\\d-]+:rekognition:[a-z\\d-]+:\\d{12}:project\\/[a-zA-Z0-9_.\\-]{1,255}\\/[0-9]+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "ProjectArn"
        }
    }

    public struct DeleteProjectResponse: AWSDecodableShape {
        /// The current status of the delete project operation.
        public let status: ProjectStatus?

        public init(status: ProjectStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct DeleteProjectVersionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the model version that you want to delete.
        public let projectVersionArn: String

        public init(projectVersionArn: String) {
            self.projectVersionArn = projectVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, max: 2048)
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, min: 20)
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, pattern: "(^arn:[a-z\\d-]+:rekognition:[a-z\\d-]+:\\d{12}:project\\/[a-zA-Z0-9_.\\-]{1,255}\\/version\\/[a-zA-Z0-9_.\\-]{1,255}\\/[0-9]+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case projectVersionArn = "ProjectVersionArn"
        }
    }

    public struct DeleteProjectVersionResponse: AWSDecodableShape {
        /// The status of the deletion operation.
        public let status: ProjectVersionStatus?

        public init(status: ProjectVersionStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct DeleteStreamProcessorRequest: AWSEncodableShape {
        /// The name of the stream processor you want to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteStreamProcessorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeCollectionRequest: AWSEncodableShape {
        /// The ID of the collection to describe.
        public let collectionId: String

        public init(collectionId: String) {
            self.collectionId = collectionId
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionId, name: "collectionId", parent: name, max: 255)
            try self.validate(self.collectionId, name: "collectionId", parent: name, min: 1)
            try self.validate(self.collectionId, name: "collectionId", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
        }
    }

    public struct DescribeCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the collection.
        public let collectionARN: String?
        /// The number of milliseconds since the Unix epoch time until the creation of the collection. The Unix epoch time is 00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970.
        public let creationTimestamp: Date?
        /// The number of faces that are indexed into the collection. To index faces into a collection, use IndexFaces.
        public let faceCount: Int64?
        /// The version of the face model that's used by the collection for face detection. For more information, see Model Versioning in the Amazon Rekognition Developer Guide.
        public let faceModelVersion: String?

        public init(collectionARN: String? = nil, creationTimestamp: Date? = nil, faceCount: Int64? = nil, faceModelVersion: String? = nil) {
            self.collectionARN = collectionARN
            self.creationTimestamp = creationTimestamp
            self.faceCount = faceCount
            self.faceModelVersion = faceModelVersion
        }

        private enum CodingKeys: String, CodingKey {
            case collectionARN = "CollectionARN"
            case creationTimestamp = "CreationTimestamp"
            case faceCount = "FaceCount"
            case faceModelVersion = "FaceModelVersion"
        }
    }

    public struct DescribeProjectVersionsRequest: AWSEncodableShape {
        /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response. You can use this pagination token to retrieve the next set of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project that contains the models you want to describe.
        public let projectArn: String
        /// A list of model version names that you want to describe. You can add up to 10 model version names to the list. If you don't specify a value, all model descriptions are returned. A version name is part of a model (ProjectVersion) ARN. For example, my-model.2020-01-21T09.10.15 is the version name in the following ARN. arn:aws:rekognition:us-east-1:123456789012:project/getting-started/version/my-model.2020-01-21T09.10.15/1234567890123.
        public let versionNames: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectArn: String, versionNames: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectArn = projectArn
            self.versionNames = versionNames
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 2048)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 20)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "(^arn:[a-z\\d-]+:rekognition:[a-z\\d-]+:\\d{12}:project\\/[a-zA-Z0-9_.\\-]{1,255}\\/[0-9]+$)")
            try self.versionNames?.forEach {
                try validate($0, name: "versionNames[]", parent: name, max: 255)
                try validate($0, name: "versionNames[]", parent: name, min: 1)
                try validate($0, name: "versionNames[]", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
            }
            try self.validate(self.versionNames, name: "versionNames", parent: name, max: 10)
            try self.validate(self.versionNames, name: "versionNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case projectArn = "ProjectArn"
            case versionNames = "VersionNames"
        }
    }

    public struct DescribeProjectVersionsResponse: AWSDecodableShape {
        /// If the previous response was incomplete (because there is more results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response. You can use this pagination token to retrieve the next set of results.
        public let nextToken: String?
        /// A list of model descriptions. The list is sorted by the creation date and time of the model versions, latest to earliest.
        public let projectVersionDescriptions: [ProjectVersionDescription]?

        public init(nextToken: String? = nil, projectVersionDescriptions: [ProjectVersionDescription]? = nil) {
            self.nextToken = nextToken
            self.projectVersionDescriptions = projectVersionDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case projectVersionDescriptions = "ProjectVersionDescriptions"
        }
    }

    public struct DescribeProjectsRequest: AWSEncodableShape {
        /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response. You can use this pagination token to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeProjectsResponse: AWSDecodableShape {
        /// If the previous response was incomplete (because there is more results to retrieve), Amazon Rekognition Custom Labels returns a pagination token in the response. You can use this pagination token to retrieve the next set of results.
        public let nextToken: String?
        /// A list of project descriptions. The list is sorted by the date and time the projects are created.
        public let projectDescriptions: [ProjectDescription]?

        public init(nextToken: String? = nil, projectDescriptions: [ProjectDescription]? = nil) {
            self.nextToken = nextToken
            self.projectDescriptions = projectDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case projectDescriptions = "ProjectDescriptions"
        }
    }

    public struct DescribeStreamProcessorRequest: AWSEncodableShape {
        /// Name of the stream processor for which you want information.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DescribeStreamProcessorResponse: AWSDecodableShape {
        /// Date and time the stream processor was created
        public let creationTimestamp: Date?
        /// Kinesis video stream that provides the source streaming video.
        public let input: StreamProcessorInput?
        /// The time, in Unix format, the stream processor was last updated. For example, when the stream processor moves from a running state to a failed state, or when the user starts or stops the stream processor.
        public let lastUpdateTimestamp: Date?
        /// Name of the stream processor.
        public let name: String?
        /// Kinesis data stream to which Amazon Rekognition Video puts the analysis results.
        public let output: StreamProcessorOutput?
        /// ARN of the IAM role that allows access to the stream processor.
        public let roleArn: String?
        /// Face recognition input parameters that are being used by the stream processor. Includes the collection to use for face recognition and the face attributes to detect.
        public let settings: StreamProcessorSettings?
        /// Current status of the stream processor.
        public let status: StreamProcessorStatus?
        /// Detailed status message about the stream processor.
        public let statusMessage: String?
        /// ARN of the stream processor.
        public let streamProcessorArn: String?

        public init(creationTimestamp: Date? = nil, input: StreamProcessorInput? = nil, lastUpdateTimestamp: Date? = nil, name: String? = nil, output: StreamProcessorOutput? = nil, roleArn: String? = nil, settings: StreamProcessorSettings? = nil, status: StreamProcessorStatus? = nil, statusMessage: String? = nil, streamProcessorArn: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.input = input
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.name = name
            self.output = output
            self.roleArn = roleArn
            self.settings = settings
            self.status = status
            self.statusMessage = statusMessage
            self.streamProcessorArn = streamProcessorArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case input = "Input"
            case lastUpdateTimestamp = "LastUpdateTimestamp"
            case name = "Name"
            case output = "Output"
            case roleArn = "RoleArn"
            case settings = "Settings"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case streamProcessorArn = "StreamProcessorArn"
        }
    }

    public struct DetectCustomLabelsRequest: AWSEncodableShape {
        public let image: Image
        /// Maximum number of results you want the service to return in the response. The service returns the specified number of highest confidence labels ranked from highest confidence to lowest.
        public let maxResults: Int?
        /// Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't return any labels with a confidence lower than this specified value. If you specify a value of 0, all labels are return, regardless of the default thresholds that the model version applies.
        public let minConfidence: Float?
        /// The ARN of the model version that you want to use.
        public let projectVersionArn: String

        public init(image: Image, maxResults: Int? = nil, minConfidence: Float? = nil, projectVersionArn: String) {
            self.image = image
            self.maxResults = maxResults
            self.minConfidence = minConfidence
            self.projectVersionArn = projectVersionArn
        }

        public func validate(name: String) throws {
            try self.image.validate(name: "\(name).image")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, max: 100)
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, min: 0)
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, max: 2048)
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, min: 20)
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, pattern: "(^arn:[a-z\\d-]+:rekognition:[a-z\\d-]+:\\d{12}:project\\/[a-zA-Z0-9_.\\-]{1,255}\\/version\\/[a-zA-Z0-9_.\\-]{1,255}\\/[0-9]+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case image = "Image"
            case maxResults = "MaxResults"
            case minConfidence = "MinConfidence"
            case projectVersionArn = "ProjectVersionArn"
        }
    }

    public struct DetectCustomLabelsResponse: AWSDecodableShape {
        /// An array of custom labels detected in the input image.
        public let customLabels: [CustomLabel]?

        public init(customLabels: [CustomLabel]? = nil) {
            self.customLabels = customLabels
        }

        private enum CodingKeys: String, CodingKey {
            case customLabels = "CustomLabels"
        }
    }

    public struct DetectFacesRequest: AWSEncodableShape {
        /// An array of facial attributes you want to be returned. This can be the default list of attributes or all attributes. If you don't specify a value for Attributes or if you specify ["DEFAULT"], the API returns the following subset of facial attributes: BoundingBox, Confidence, Pose, Quality, and Landmarks. If you provide ["ALL"], all facial attributes are returned, but the operation takes longer to complete. If you provide both, ["ALL", "DEFAULT"], the service uses a logical AND operator to determine which attributes to return (in this case, all attributes).
        public let attributes: [Attribute]?
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported.  If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes passed using the Bytes field. For more information, see Images in the Amazon Rekognition developer guide.
        public let image: Image

        public init(attributes: [Attribute]? = nil, image: Image) {
            self.attributes = attributes
            self.image = image
        }

        public func validate(name: String) throws {
            try self.image.validate(name: "\(name).image")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case image = "Image"
        }
    }

    public struct DetectFacesResponse: AWSDecodableShape {
        /// Details of each face found in the image.
        public let faceDetails: [FaceDetail]?
        /// The value of OrientationCorrection is always null. If the input image is in .jpeg format, it might contain exchangeable image file format (Exif) metadata that includes the image's orientation. Amazon Rekognition uses this orientation information to perform image correction. The bounding box coordinates are translated to represent object locations after the orientation information in the Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata. Amazon Rekognition doesn’t perform image correction for images in .png format and .jpeg images without orientation information in the image Exif metadata. The bounding box coordinates aren't translated and represent the object locations before the image is rotated.
        public let orientationCorrection: OrientationCorrection?

        public init(faceDetails: [FaceDetail]? = nil, orientationCorrection: OrientationCorrection? = nil) {
            self.faceDetails = faceDetails
            self.orientationCorrection = orientationCorrection
        }

        private enum CodingKeys: String, CodingKey {
            case faceDetails = "FaceDetails"
            case orientationCorrection = "OrientationCorrection"
        }
    }

    public struct DetectLabelsRequest: AWSEncodableShape {
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing image bytes is not supported. Images stored in an S3 Bucket do not need to be base64-encoded. If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes passed using the Bytes field. For more information, see Images in the Amazon Rekognition developer guide.
        public let image: Image
        /// Maximum number of labels you want the service to return in the response. The service returns the specified number of highest confidence labels.
        public let maxLabels: Int?
        /// Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't return any labels with confidence lower than this specified value. If MinConfidence is not specified, the operation returns labels with a confidence values greater than or equal to 55 percent.
        public let minConfidence: Float?

        public init(image: Image, maxLabels: Int? = nil, minConfidence: Float? = nil) {
            self.image = image
            self.maxLabels = maxLabels
            self.minConfidence = minConfidence
        }

        public func validate(name: String) throws {
            try self.image.validate(name: "\(name).image")
            try self.validate(self.maxLabels, name: "maxLabels", parent: name, min: 0)
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, max: 100)
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case image = "Image"
            case maxLabels = "MaxLabels"
            case minConfidence = "MinConfidence"
        }
    }

    public struct DetectLabelsResponse: AWSDecodableShape {
        /// Version number of the label detection model that was used to detect labels.
        public let labelModelVersion: String?
        /// An array of labels for the real-world objects detected.
        public let labels: [Label]?
        /// The value of OrientationCorrection is always null. If the input image is in .jpeg format, it might contain exchangeable image file format (Exif) metadata that includes the image's orientation. Amazon Rekognition uses this orientation information to perform image correction. The bounding box coordinates are translated to represent object locations after the orientation information in the Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata. Amazon Rekognition doesn’t perform image correction for images in .png format and .jpeg images without orientation information in the image Exif metadata. The bounding box coordinates aren't translated and represent the object locations before the image is rotated.
        public let orientationCorrection: OrientationCorrection?

        public init(labelModelVersion: String? = nil, labels: [Label]? = nil, orientationCorrection: OrientationCorrection? = nil) {
            self.labelModelVersion = labelModelVersion
            self.labels = labels
            self.orientationCorrection = orientationCorrection
        }

        private enum CodingKeys: String, CodingKey {
            case labelModelVersion = "LabelModelVersion"
            case labels = "Labels"
            case orientationCorrection = "OrientationCorrection"
        }
    }

    public struct DetectModerationLabelsRequest: AWSEncodableShape {
        /// Sets up the configuration for human evaluation, including the FlowDefinition the image will be sent to.
        public let humanLoopConfig: HumanLoopConfig?
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported.  If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes passed using the Bytes field. For more information, see Images in the Amazon Rekognition developer guide.
        public let image: Image
        /// Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't return any labels with a confidence level lower than this specified value. If you don't specify MinConfidence, the operation returns labels with confidence values greater than or equal to 50 percent.
        public let minConfidence: Float?

        public init(humanLoopConfig: HumanLoopConfig? = nil, image: Image, minConfidence: Float? = nil) {
            self.humanLoopConfig = humanLoopConfig
            self.image = image
            self.minConfidence = minConfidence
        }

        public func validate(name: String) throws {
            try self.humanLoopConfig?.validate(name: "\(name).humanLoopConfig")
            try self.image.validate(name: "\(name).image")
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, max: 100)
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case humanLoopConfig = "HumanLoopConfig"
            case image = "Image"
            case minConfidence = "MinConfidence"
        }
    }

    public struct DetectModerationLabelsResponse: AWSDecodableShape {
        /// Shows the results of the human in the loop evaluation.
        public let humanLoopActivationOutput: HumanLoopActivationOutput?
        /// Array of detected Moderation labels and the time, in milliseconds from the start of the video, they were detected.
        public let moderationLabels: [ModerationLabel]?
        /// Version number of the moderation detection model that was used to detect unsafe content.
        public let moderationModelVersion: String?

        public init(humanLoopActivationOutput: HumanLoopActivationOutput? = nil, moderationLabels: [ModerationLabel]? = nil, moderationModelVersion: String? = nil) {
            self.humanLoopActivationOutput = humanLoopActivationOutput
            self.moderationLabels = moderationLabels
            self.moderationModelVersion = moderationModelVersion
        }

        private enum CodingKeys: String, CodingKey {
            case humanLoopActivationOutput = "HumanLoopActivationOutput"
            case moderationLabels = "ModerationLabels"
            case moderationModelVersion = "ModerationModelVersion"
        }
    }

    public struct DetectProtectiveEquipmentRequest: AWSEncodableShape {
        /// The image in which you want to detect PPE on detected persons. The image can be passed as image bytes or you can reference an image stored in an Amazon S3 bucket.
        public let image: Image
        /// An array of PPE types that you want to summarize.
        public let summarizationAttributes: ProtectiveEquipmentSummarizationAttributes?

        public init(image: Image, summarizationAttributes: ProtectiveEquipmentSummarizationAttributes? = nil) {
            self.image = image
            self.summarizationAttributes = summarizationAttributes
        }

        public func validate(name: String) throws {
            try self.image.validate(name: "\(name).image")
            try self.summarizationAttributes?.validate(name: "\(name).summarizationAttributes")
        }

        private enum CodingKeys: String, CodingKey {
            case image = "Image"
            case summarizationAttributes = "SummarizationAttributes"
        }
    }

    public struct DetectProtectiveEquipmentResponse: AWSDecodableShape {
        /// An array of persons detected in the image (including persons not wearing PPE).
        public let persons: [ProtectiveEquipmentPerson]?
        /// The version number of the PPE detection model used to detect PPE in the image.
        public let protectiveEquipmentModelVersion: String?
        /// Summary information for the types of PPE specified in the SummarizationAttributes input parameter.
        public let summary: ProtectiveEquipmentSummary?

        public init(persons: [ProtectiveEquipmentPerson]? = nil, protectiveEquipmentModelVersion: String? = nil, summary: ProtectiveEquipmentSummary? = nil) {
            self.persons = persons
            self.protectiveEquipmentModelVersion = protectiveEquipmentModelVersion
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case persons = "Persons"
            case protectiveEquipmentModelVersion = "ProtectiveEquipmentModelVersion"
            case summary = "Summary"
        }
    }

    public struct DetectTextFilters: AWSEncodableShape {
        ///  A Filter focusing on a certain area of the image. Uses a BoundingBox object to set the region of the image.
        public let regionsOfInterest: [RegionOfInterest]?
        public let wordFilter: DetectionFilter?

        public init(regionsOfInterest: [RegionOfInterest]? = nil, wordFilter: DetectionFilter? = nil) {
            self.regionsOfInterest = regionsOfInterest
            self.wordFilter = wordFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.regionsOfInterest, name: "regionsOfInterest", parent: name, max: 10)
            try self.validate(self.regionsOfInterest, name: "regionsOfInterest", parent: name, min: 0)
            try self.wordFilter?.validate(name: "\(name).wordFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case regionsOfInterest = "RegionsOfInterest"
            case wordFilter = "WordFilter"
        }
    }

    public struct DetectTextRequest: AWSEncodableShape {
        /// Optional parameters that let you set the criteria that the text must meet to be included in your response.
        public let filters: DetectTextFilters?
        /// The input image as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI to call Amazon Rekognition operations, you can't pass image bytes.  If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes passed using the Bytes field. For more information, see Images in the Amazon Rekognition developer guide.
        public let image: Image

        public init(filters: DetectTextFilters? = nil, image: Image) {
            self.filters = filters
            self.image = image
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.image.validate(name: "\(name).image")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case image = "Image"
        }
    }

    public struct DetectTextResponse: AWSDecodableShape {
        /// An array of text that was detected in the input image.
        public let textDetections: [TextDetection]?
        /// The model version used to detect text.
        public let textModelVersion: String?

        public init(textDetections: [TextDetection]? = nil, textModelVersion: String? = nil) {
            self.textDetections = textDetections
            self.textModelVersion = textModelVersion
        }

        private enum CodingKeys: String, CodingKey {
            case textDetections = "TextDetections"
            case textModelVersion = "TextModelVersion"
        }
    }

    public struct DetectionFilter: AWSEncodableShape {
        /// Sets the minimum height of the word bounding box. Words with bounding box heights lesser than this value will be excluded from the result. Value is relative to the video frame height.
        public let minBoundingBoxHeight: Float?
        /// Sets the minimum width of the word bounding box. Words with bounding boxes widths lesser than this value will be excluded from the result. Value is relative to the video frame width.
        public let minBoundingBoxWidth: Float?
        /// Sets the confidence of word detection. Words with detection confidence below this will be excluded from the result. Values should be between 50 and 100 as Text in Video will not return any result below 50.
        public let minConfidence: Float?

        public init(minBoundingBoxHeight: Float? = nil, minBoundingBoxWidth: Float? = nil, minConfidence: Float? = nil) {
            self.minBoundingBoxHeight = minBoundingBoxHeight
            self.minBoundingBoxWidth = minBoundingBoxWidth
            self.minConfidence = minConfidence
        }

        public func validate(name: String) throws {
            try self.validate(self.minBoundingBoxHeight, name: "minBoundingBoxHeight", parent: name, max: 1)
            try self.validate(self.minBoundingBoxHeight, name: "minBoundingBoxHeight", parent: name, min: 0)
            try self.validate(self.minBoundingBoxWidth, name: "minBoundingBoxWidth", parent: name, max: 1)
            try self.validate(self.minBoundingBoxWidth, name: "minBoundingBoxWidth", parent: name, min: 0)
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, max: 100)
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case minBoundingBoxHeight = "MinBoundingBoxHeight"
            case minBoundingBoxWidth = "MinBoundingBoxWidth"
            case minConfidence = "MinConfidence"
        }
    }

    public struct Emotion: AWSDecodableShape {
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Type of emotion detected.
        public let type: EmotionName?

        public init(confidence: Float? = nil, type: EmotionName? = nil) {
            self.confidence = confidence
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case type = "Type"
        }
    }

    public struct EquipmentDetection: AWSDecodableShape {
        /// A bounding box surrounding the item of detected PPE.
        public let boundingBox: BoundingBox?
        /// The confidence that Amazon Rekognition has that the bounding box (BoundingBox) contains an item of PPE.
        public let confidence: Float?
        /// Information about the body part covered by the detected PPE.
        public let coversBodyPart: CoversBodyPart?
        /// The type of detected PPE.
        public let type: ProtectiveEquipmentType?

        public init(boundingBox: BoundingBox? = nil, confidence: Float? = nil, coversBodyPart: CoversBodyPart? = nil, type: ProtectiveEquipmentType? = nil) {
            self.boundingBox = boundingBox
            self.confidence = confidence
            self.coversBodyPart = coversBodyPart
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case confidence = "Confidence"
            case coversBodyPart = "CoversBodyPart"
            case type = "Type"
        }
    }

    public struct EvaluationResult: AWSDecodableShape {
        /// The F1 score for the evaluation of all labels. The F1 score metric evaluates the overall precision and recall performance of the model as a single value. A higher value indicates better precision and recall performance. A lower score indicates that precision, recall, or both are performing poorly.
        public let f1Score: Float?
        /// The S3 bucket that contains the training summary.
        public let summary: Summary?

        public init(f1Score: Float? = nil, summary: Summary? = nil) {
            self.f1Score = f1Score
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case f1Score = "F1Score"
            case summary = "Summary"
        }
    }

    public struct EyeOpen: AWSDecodableShape {
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the eyes on the face are open.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public struct Eyeglasses: AWSDecodableShape {
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face is wearing eye glasses or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public struct Face: AWSDecodableShape {
        /// Bounding box of the face.
        public let boundingBox: BoundingBox?
        /// Confidence level that the bounding box contains a face (and not a different object such as a tree).
        public let confidence: Float?
        /// Identifier that you assign to all the faces in the input image.
        public let externalImageId: String?
        /// Unique identifier that Amazon Rekognition assigns to the face.
        public let faceId: String?
        /// Unique identifier that Amazon Rekognition assigns to the input image.
        public let imageId: String?

        public init(boundingBox: BoundingBox? = nil, confidence: Float? = nil, externalImageId: String? = nil, faceId: String? = nil, imageId: String? = nil) {
            self.boundingBox = boundingBox
            self.confidence = confidence
            self.externalImageId = externalImageId
            self.faceId = faceId
            self.imageId = imageId
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case confidence = "Confidence"
            case externalImageId = "ExternalImageId"
            case faceId = "FaceId"
            case imageId = "ImageId"
        }
    }

    public struct FaceDetail: AWSDecodableShape {
        /// The estimated age range, in years, for the face. Low represents the lowest estimated age and High represents the highest estimated age.
        public let ageRange: AgeRange?
        /// Indicates whether or not the face has a beard, and the confidence level in the determination.
        public let beard: Beard?
        /// Bounding box of the face. Default attribute.
        public let boundingBox: BoundingBox?
        /// Confidence level that the bounding box contains a face (and not a different object such as a tree). Default attribute.
        public let confidence: Float?
        /// The emotions that appear to be expressed on the face, and the confidence level in the determination. The API is only making a determination of the physical appearance of a person's face. It is not a determination of the person’s internal emotional state and should not be used in such a way. For example, a person pretending to have a sad face might not be sad emotionally.
        public let emotions: [Emotion]?
        /// Indicates whether or not the face is wearing eye glasses, and the confidence level in the determination.
        public let eyeglasses: Eyeglasses?
        /// Indicates whether or not the eyes on the face are open, and the confidence level in the determination.
        public let eyesOpen: EyeOpen?
        /// The predicted gender of a detected face.
        public let gender: Gender?
        /// Indicates the location of landmarks on the face. Default attribute.
        public let landmarks: [Landmark]?
        /// Indicates whether or not the mouth on the face is open, and the confidence level in the determination.
        public let mouthOpen: MouthOpen?
        /// Indicates whether or not the face has a mustache, and the confidence level in the determination.
        public let mustache: Mustache?
        /// Indicates the pose of the face as determined by its pitch, roll, and yaw. Default attribute.
        public let pose: Pose?
        /// Identifies image brightness and sharpness. Default attribute.
        public let quality: ImageQuality?
        /// Indicates whether or not the face is smiling, and the confidence level in the determination.
        public let smile: Smile?
        /// Indicates whether or not the face is wearing sunglasses, and the confidence level in the determination.
        public let sunglasses: Sunglasses?

        public init(ageRange: AgeRange? = nil, beard: Beard? = nil, boundingBox: BoundingBox? = nil, confidence: Float? = nil, emotions: [Emotion]? = nil, eyeglasses: Eyeglasses? = nil, eyesOpen: EyeOpen? = nil, gender: Gender? = nil, landmarks: [Landmark]? = nil, mouthOpen: MouthOpen? = nil, mustache: Mustache? = nil, pose: Pose? = nil, quality: ImageQuality? = nil, smile: Smile? = nil, sunglasses: Sunglasses? = nil) {
            self.ageRange = ageRange
            self.beard = beard
            self.boundingBox = boundingBox
            self.confidence = confidence
            self.emotions = emotions
            self.eyeglasses = eyeglasses
            self.eyesOpen = eyesOpen
            self.gender = gender
            self.landmarks = landmarks
            self.mouthOpen = mouthOpen
            self.mustache = mustache
            self.pose = pose
            self.quality = quality
            self.smile = smile
            self.sunglasses = sunglasses
        }

        private enum CodingKeys: String, CodingKey {
            case ageRange = "AgeRange"
            case beard = "Beard"
            case boundingBox = "BoundingBox"
            case confidence = "Confidence"
            case emotions = "Emotions"
            case eyeglasses = "Eyeglasses"
            case eyesOpen = "EyesOpen"
            case gender = "Gender"
            case landmarks = "Landmarks"
            case mouthOpen = "MouthOpen"
            case mustache = "Mustache"
            case pose = "Pose"
            case quality = "Quality"
            case smile = "Smile"
            case sunglasses = "Sunglasses"
        }
    }

    public struct FaceDetection: AWSDecodableShape {
        /// The face properties for the detected face.
        public let face: FaceDetail?
        /// Time, in milliseconds from the start of the video, that the face was detected.
        public let timestamp: Int64?

        public init(face: FaceDetail? = nil, timestamp: Int64? = nil) {
            self.face = face
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case face = "Face"
            case timestamp = "Timestamp"
        }
    }

    public struct FaceMatch: AWSDecodableShape {
        /// Describes the face properties such as the bounding box, face ID, image ID of the source image, and external image ID that you assigned.
        public let face: Face?
        /// Confidence in the match of this face with the input face.
        public let similarity: Float?

        public init(face: Face? = nil, similarity: Float? = nil) {
            self.face = face
            self.similarity = similarity
        }

        private enum CodingKeys: String, CodingKey {
            case face = "Face"
            case similarity = "Similarity"
        }
    }

    public struct FaceRecord: AWSDecodableShape {
        /// Describes the face properties such as the bounding box, face ID, image ID of the input image, and external image ID that you assigned.
        public let face: Face?
        /// Structure containing attributes of the face that the algorithm detected.
        public let faceDetail: FaceDetail?

        public init(face: Face? = nil, faceDetail: FaceDetail? = nil) {
            self.face = face
            self.faceDetail = faceDetail
        }

        private enum CodingKeys: String, CodingKey {
            case face = "Face"
            case faceDetail = "FaceDetail"
        }
    }

    public struct FaceSearchSettings: AWSEncodableShape & AWSDecodableShape {
        /// The ID of a collection that contains faces that you want to search for.
        public let collectionId: String?
        /// Minimum face match confidence score that must be met to return a result for a recognized face. Default is 80. 0 is the lowest confidence. 100 is the highest confidence.
        public let faceMatchThreshold: Float?

        public init(collectionId: String? = nil, faceMatchThreshold: Float? = nil) {
            self.collectionId = collectionId
            self.faceMatchThreshold = faceMatchThreshold
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionId, name: "collectionId", parent: name, max: 255)
            try self.validate(self.collectionId, name: "collectionId", parent: name, min: 1)
            try self.validate(self.collectionId, name: "collectionId", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
            try self.validate(self.faceMatchThreshold, name: "faceMatchThreshold", parent: name, max: 100)
            try self.validate(self.faceMatchThreshold, name: "faceMatchThreshold", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
            case faceMatchThreshold = "FaceMatchThreshold"
        }
    }

    public struct Gender: AWSDecodableShape {
        /// Level of confidence in the prediction.
        public let confidence: Float?
        /// The predicted gender of the face.
        public let value: GenderType?

        public init(confidence: Float? = nil, value: GenderType? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public struct Geometry: AWSDecodableShape {
        /// An axis-aligned coarse representation of the detected item's location on the image.
        public let boundingBox: BoundingBox?
        /// Within the bounding box, a fine-grained polygon around the detected item.
        public let polygon: [Point]?

        public init(boundingBox: BoundingBox? = nil, polygon: [Point]? = nil) {
            self.boundingBox = boundingBox
            self.polygon = polygon
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case polygon = "Polygon"
        }
    }

    public struct GetCelebrityInfoRequest: AWSEncodableShape {
        /// The ID for the celebrity. You get the celebrity ID from a call to the RecognizeCelebrities operation, which recognizes celebrities in an image.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "[0-9A-Za-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct GetCelebrityInfoResponse: AWSDecodableShape {
        /// The name of the celebrity.
        public let name: String?
        /// An array of URLs pointing to additional celebrity information.
        public let urls: [String]?

        public init(name: String? = nil, urls: [String]? = nil) {
            self.name = name
            self.urls = urls
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case urls = "Urls"
        }
    }

    public struct GetCelebrityRecognitionRequest: AWSEncodableShape {
        /// Job identifier for the required celebrity recognition analysis. You can get the job identifer from a call to StartCelebrityRecognition.
        public let jobId: String
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more recognized celebrities to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of celebrities.
        public let nextToken: String?
        /// Sort to use for celebrities returned in Celebrities field. Specify ID to sort by the celebrity identifier, specify TIMESTAMP to sort by the time the celebrity was recognized.
        public let sortBy: CelebrityRecognitionSortBy?

        public init(jobId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: CelebrityRecognitionSortBy? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
        }
    }

    public struct GetCelebrityRecognitionResponse: AWSDecodableShape {
        /// Array of celebrities recognized in the video.
        public let celebrities: [CelebrityRecognition]?
        /// The current status of the celebrity recognition job.
        public let jobStatus: VideoJobStatus?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of celebrities.
        public let nextToken: String?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// Information about a video that Amazon Rekognition Video analyzed. Videometadata is returned in every page of paginated responses from a Amazon Rekognition Video operation.
        public let videoMetadata: VideoMetadata?

        public init(celebrities: [CelebrityRecognition]? = nil, jobStatus: VideoJobStatus? = nil, nextToken: String? = nil, statusMessage: String? = nil, videoMetadata: VideoMetadata? = nil) {
            self.celebrities = celebrities
            self.jobStatus = jobStatus
            self.nextToken = nextToken
            self.statusMessage = statusMessage
            self.videoMetadata = videoMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case celebrities = "Celebrities"
            case jobStatus = "JobStatus"
            case nextToken = "NextToken"
            case statusMessage = "StatusMessage"
            case videoMetadata = "VideoMetadata"
        }
    }

    public struct GetContentModerationRequest: AWSEncodableShape {
        /// The identifier for the unsafe content job. Use JobId to identify the job in a subsequent call to GetContentModeration.
        public let jobId: String
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Rekognition returns a pagination token in the response. You can use this pagination token to retrieve the next set of unsafe content labels.
        public let nextToken: String?
        /// Sort to use for elements in the ModerationLabelDetections array. Use TIMESTAMP to sort array elements by the time labels are detected. Use NAME to alphabetically group elements for a label together. Within each label group, the array element are sorted by detection confidence. The default sort is by TIMESTAMP.
        public let sortBy: ContentModerationSortBy?

        public init(jobId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: ContentModerationSortBy? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
        }
    }

    public struct GetContentModerationResponse: AWSDecodableShape {
        /// The current status of the unsafe content analysis job.
        public let jobStatus: VideoJobStatus?
        /// The detected unsafe content labels and the time(s) they were detected.
        public let moderationLabels: [ContentModerationDetection]?
        /// Version number of the moderation detection model that was used to detect unsafe content.
        public let moderationModelVersion: String?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of unsafe content labels.
        public let nextToken: String?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// Information about a video that Amazon Rekognition analyzed. Videometadata is returned in every page of paginated responses from GetContentModeration.
        public let videoMetadata: VideoMetadata?

        public init(jobStatus: VideoJobStatus? = nil, moderationLabels: [ContentModerationDetection]? = nil, moderationModelVersion: String? = nil, nextToken: String? = nil, statusMessage: String? = nil, videoMetadata: VideoMetadata? = nil) {
            self.jobStatus = jobStatus
            self.moderationLabels = moderationLabels
            self.moderationModelVersion = moderationModelVersion
            self.nextToken = nextToken
            self.statusMessage = statusMessage
            self.videoMetadata = videoMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus = "JobStatus"
            case moderationLabels = "ModerationLabels"
            case moderationModelVersion = "ModerationModelVersion"
            case nextToken = "NextToken"
            case statusMessage = "StatusMessage"
            case videoMetadata = "VideoMetadata"
        }
    }

    public struct GetFaceDetectionRequest: AWSEncodableShape {
        /// Unique identifier for the face detection job. The JobId is returned from StartFaceDetection.
        public let jobId: String
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there are more faces to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of faces.
        public let nextToken: String?

        public init(jobId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetFaceDetectionResponse: AWSDecodableShape {
        /// An array of faces detected in the video. Each element contains a detected face's details and the time, in milliseconds from the start of the video, the face was detected.
        public let faces: [FaceDetection]?
        /// The current status of the face detection job.
        public let jobStatus: VideoJobStatus?
        /// If the response is truncated, Amazon Rekognition returns this token that you can use in the subsequent request to retrieve the next set of faces.
        public let nextToken: String?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// Information about a video that Amazon Rekognition Video analyzed. Videometadata is returned in every page of paginated responses from a Amazon Rekognition video operation.
        public let videoMetadata: VideoMetadata?

        public init(faces: [FaceDetection]? = nil, jobStatus: VideoJobStatus? = nil, nextToken: String? = nil, statusMessage: String? = nil, videoMetadata: VideoMetadata? = nil) {
            self.faces = faces
            self.jobStatus = jobStatus
            self.nextToken = nextToken
            self.statusMessage = statusMessage
            self.videoMetadata = videoMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case faces = "Faces"
            case jobStatus = "JobStatus"
            case nextToken = "NextToken"
            case statusMessage = "StatusMessage"
            case videoMetadata = "VideoMetadata"
        }
    }

    public struct GetFaceSearchRequest: AWSEncodableShape {
        /// The job identifer for the search request. You get the job identifier from an initial call to StartFaceSearch.
        public let jobId: String
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more search results to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of search results.
        public let nextToken: String?
        /// Sort to use for grouping faces in the response. Use TIMESTAMP to group faces by the time that they are recognized. Use INDEX to sort by recognized faces.
        public let sortBy: FaceSearchSortBy?

        public init(jobId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: FaceSearchSortBy? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
        }
    }

    public struct GetFaceSearchResponse: AWSDecodableShape {
        /// The current status of the face search job.
        public let jobStatus: VideoJobStatus?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of search results.
        public let nextToken: String?
        /// An array of persons, PersonMatch, in the video whose face(s) match the face(s) in an Amazon Rekognition collection. It also includes time information for when persons are matched in the video. You specify the input collection in an initial call to StartFaceSearch. Each Persons element includes a time the person was matched, face match details (FaceMatches) for matching faces in the collection, and person information (Person) for the matched person.
        public let persons: [PersonMatch]?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// Information about a video that Amazon Rekognition analyzed. Videometadata is returned in every page of paginated responses from a Amazon Rekognition Video operation.
        public let videoMetadata: VideoMetadata?

        public init(jobStatus: VideoJobStatus? = nil, nextToken: String? = nil, persons: [PersonMatch]? = nil, statusMessage: String? = nil, videoMetadata: VideoMetadata? = nil) {
            self.jobStatus = jobStatus
            self.nextToken = nextToken
            self.persons = persons
            self.statusMessage = statusMessage
            self.videoMetadata = videoMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus = "JobStatus"
            case nextToken = "NextToken"
            case persons = "Persons"
            case statusMessage = "StatusMessage"
            case videoMetadata = "VideoMetadata"
        }
    }

    public struct GetLabelDetectionRequest: AWSEncodableShape {
        /// Job identifier for the label detection operation for which you want results returned. You get the job identifer from an initial call to StartlabelDetection.
        public let jobId: String
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of labels.
        public let nextToken: String?
        /// Sort to use for elements in the Labels array. Use TIMESTAMP to sort array elements by the time labels are detected. Use NAME to alphabetically group elements for a label together. Within each label group, the array element are sorted by detection confidence. The default sort is by TIMESTAMP.
        public let sortBy: LabelDetectionSortBy?

        public init(jobId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: LabelDetectionSortBy? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
        }
    }

    public struct GetLabelDetectionResponse: AWSDecodableShape {
        /// The current status of the label detection job.
        public let jobStatus: VideoJobStatus?
        /// Version number of the label detection model that was used to detect labels.
        public let labelModelVersion: String?
        /// An array of labels detected in the video. Each element contains the detected label and the time, in milliseconds from the start of the video, that the label was detected.
        public let labels: [LabelDetection]?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of labels.
        public let nextToken: String?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// Information about a video that Amazon Rekognition Video analyzed. Videometadata is returned in every page of paginated responses from a Amazon Rekognition video operation.
        public let videoMetadata: VideoMetadata?

        public init(jobStatus: VideoJobStatus? = nil, labelModelVersion: String? = nil, labels: [LabelDetection]? = nil, nextToken: String? = nil, statusMessage: String? = nil, videoMetadata: VideoMetadata? = nil) {
            self.jobStatus = jobStatus
            self.labelModelVersion = labelModelVersion
            self.labels = labels
            self.nextToken = nextToken
            self.statusMessage = statusMessage
            self.videoMetadata = videoMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus = "JobStatus"
            case labelModelVersion = "LabelModelVersion"
            case labels = "Labels"
            case nextToken = "NextToken"
            case statusMessage = "StatusMessage"
            case videoMetadata = "VideoMetadata"
        }
    }

    public struct GetPersonTrackingRequest: AWSEncodableShape {
        /// The identifier for a job that tracks persons in a video. You get the JobId from a call to StartPersonTracking.
        public let jobId: String
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there are more persons to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of persons.
        public let nextToken: String?
        /// Sort to use for elements in the Persons array. Use TIMESTAMP to sort array elements by the time persons are detected. Use INDEX to sort by the tracked persons. If you sort by INDEX, the array elements for each person are sorted by detection confidence. The default sort is by TIMESTAMP.
        public let sortBy: PersonTrackingSortBy?

        public init(jobId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: PersonTrackingSortBy? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
        }
    }

    public struct GetPersonTrackingResponse: AWSDecodableShape {
        /// The current status of the person tracking job.
        public let jobStatus: VideoJobStatus?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of persons.
        public let nextToken: String?
        /// An array of the persons detected in the video and the time(s) their path was tracked throughout the video. An array element will exist for each time a person's path is tracked.
        public let persons: [PersonDetection]?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// Information about a video that Amazon Rekognition Video analyzed. Videometadata is returned in every page of paginated responses from a Amazon Rekognition Video operation.
        public let videoMetadata: VideoMetadata?

        public init(jobStatus: VideoJobStatus? = nil, nextToken: String? = nil, persons: [PersonDetection]? = nil, statusMessage: String? = nil, videoMetadata: VideoMetadata? = nil) {
            self.jobStatus = jobStatus
            self.nextToken = nextToken
            self.persons = persons
            self.statusMessage = statusMessage
            self.videoMetadata = videoMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus = "JobStatus"
            case nextToken = "NextToken"
            case persons = "Persons"
            case statusMessage = "StatusMessage"
            case videoMetadata = "VideoMetadata"
        }
    }

    public struct GetSegmentDetectionRequest: AWSEncodableShape {
        /// Job identifier for the text detection operation for which you want results returned. You get the job identifer from an initial call to StartSegmentDetection.
        public let jobId: String
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        public let maxResults: Int?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of text.
        public let nextToken: String?

        public init(jobId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetSegmentDetectionResponse: AWSDecodableShape {
        /// An array of objects. There can be multiple audio streams. Each AudioMetadata object contains metadata for a single audio stream. Audio information in an AudioMetadata objects includes the audio codec, the number of audio channels, the duration of the audio stream, and the sample rate. Audio metadata is returned in each page of information returned by GetSegmentDetection.
        public let audioMetadata: [AudioMetadata]?
        /// Current status of the segment detection job.
        public let jobStatus: VideoJobStatus?
        /// If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of text.
        public let nextToken: String?
        /// An array of segments detected in a video. The array is sorted by the segment types (TECHNICAL_CUE or SHOT) specified in the SegmentTypes input parameter of StartSegmentDetection. Within each segment type the array is sorted by timestamp values.
        public let segments: [SegmentDetection]?
        /// An array containing the segment types requested in the call to StartSegmentDetection.
        public let selectedSegmentTypes: [SegmentTypeInfo]?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// Currently, Amazon Rekognition Video returns a single object in the VideoMetadata array. The object contains information about the video stream in the input file that Amazon Rekognition Video chose to analyze. The VideoMetadata object includes the video codec, video format and other information. Video metadata is returned in each page of information returned by GetSegmentDetection.
        public let videoMetadata: [VideoMetadata]?

        public init(audioMetadata: [AudioMetadata]? = nil, jobStatus: VideoJobStatus? = nil, nextToken: String? = nil, segments: [SegmentDetection]? = nil, selectedSegmentTypes: [SegmentTypeInfo]? = nil, statusMessage: String? = nil, videoMetadata: [VideoMetadata]? = nil) {
            self.audioMetadata = audioMetadata
            self.jobStatus = jobStatus
            self.nextToken = nextToken
            self.segments = segments
            self.selectedSegmentTypes = selectedSegmentTypes
            self.statusMessage = statusMessage
            self.videoMetadata = videoMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case audioMetadata = "AudioMetadata"
            case jobStatus = "JobStatus"
            case nextToken = "NextToken"
            case segments = "Segments"
            case selectedSegmentTypes = "SelectedSegmentTypes"
            case statusMessage = "StatusMessage"
            case videoMetadata = "VideoMetadata"
        }
    }

    public struct GetTextDetectionRequest: AWSEncodableShape {
        /// Job identifier for the text detection operation for which you want results returned. You get the job identifer from an initial call to StartTextDetection.
        public let jobId: String
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of text.
        public let nextToken: String?

        public init(jobId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, max: 64)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetTextDetectionResponse: AWSDecodableShape {
        /// Current status of the text detection job.
        public let jobStatus: VideoJobStatus?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of text.
        public let nextToken: String?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// An array of text detected in the video. Each element contains the detected text, the time in milliseconds from the start of the video that the text was detected, and where it was detected on the screen.
        public let textDetections: [TextDetectionResult]?
        /// Version number of the text detection model that was used to detect text.
        public let textModelVersion: String?
        public let videoMetadata: VideoMetadata?

        public init(jobStatus: VideoJobStatus? = nil, nextToken: String? = nil, statusMessage: String? = nil, textDetections: [TextDetectionResult]? = nil, textModelVersion: String? = nil, videoMetadata: VideoMetadata? = nil) {
            self.jobStatus = jobStatus
            self.nextToken = nextToken
            self.statusMessage = statusMessage
            self.textDetections = textDetections
            self.textModelVersion = textModelVersion
            self.videoMetadata = videoMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus = "JobStatus"
            case nextToken = "NextToken"
            case statusMessage = "StatusMessage"
            case textDetections = "TextDetections"
            case textModelVersion = "TextModelVersion"
            case videoMetadata = "VideoMetadata"
        }
    }

    public struct GroundTruthManifest: AWSEncodableShape & AWSDecodableShape {
        public let s3Object: S3Object?

        public init(s3Object: S3Object? = nil) {
            self.s3Object = s3Object
        }

        public func validate(name: String) throws {
            try self.s3Object?.validate(name: "\(name).s3Object")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Object = "S3Object"
        }
    }

    public struct HumanLoopActivationOutput: AWSDecodableShape {
        /// Shows the result of condition evaluations, including those conditions which activated a human review.
        public let humanLoopActivationConditionsEvaluationResults: String?
        /// Shows if and why human review was needed.
        public let humanLoopActivationReasons: [String]?
        /// The Amazon Resource Name (ARN) of the HumanLoop created.
        public let humanLoopArn: String?

        public init(humanLoopActivationConditionsEvaluationResults: String? = nil, humanLoopActivationReasons: [String]? = nil, humanLoopArn: String? = nil) {
            self.humanLoopActivationConditionsEvaluationResults = humanLoopActivationConditionsEvaluationResults
            self.humanLoopActivationReasons = humanLoopActivationReasons
            self.humanLoopArn = humanLoopArn
        }

        private enum CodingKeys: String, CodingKey {
            case humanLoopActivationConditionsEvaluationResults = "HumanLoopActivationConditionsEvaluationResults"
            case humanLoopActivationReasons = "HumanLoopActivationReasons"
            case humanLoopArn = "HumanLoopArn"
        }
    }

    public struct HumanLoopConfig: AWSEncodableShape {
        /// Sets attributes of the input data.
        public let dataAttributes: HumanLoopDataAttributes?
        /// The Amazon Resource Name (ARN) of the flow definition. You can create a flow definition by using the Amazon Sagemaker CreateFlowDefinition Operation.
        public let flowDefinitionArn: String
        /// The name of the human review used for this image. This should be kept unique within a region.
        public let humanLoopName: String

        public init(dataAttributes: HumanLoopDataAttributes? = nil, flowDefinitionArn: String, humanLoopName: String) {
            self.dataAttributes = dataAttributes
            self.flowDefinitionArn = flowDefinitionArn
            self.humanLoopName = humanLoopName
        }

        public func validate(name: String) throws {
            try self.dataAttributes?.validate(name: "\(name).dataAttributes")
            try self.validate(self.flowDefinitionArn, name: "flowDefinitionArn", parent: name, max: 256)
            try self.validate(self.humanLoopName, name: "humanLoopName", parent: name, max: 63)
            try self.validate(self.humanLoopName, name: "humanLoopName", parent: name, min: 1)
            try self.validate(self.humanLoopName, name: "humanLoopName", parent: name, pattern: "^[a-z0-9](-*[a-z0-9])*")
        }

        private enum CodingKeys: String, CodingKey {
            case dataAttributes = "DataAttributes"
            case flowDefinitionArn = "FlowDefinitionArn"
            case humanLoopName = "HumanLoopName"
        }
    }

    public struct HumanLoopDataAttributes: AWSEncodableShape {
        /// Sets whether the input image is free of personally identifiable information.
        public let contentClassifiers: [ContentClassifier]?

        public init(contentClassifiers: [ContentClassifier]? = nil) {
            self.contentClassifiers = contentClassifiers
        }

        public func validate(name: String) throws {
            try self.validate(self.contentClassifiers, name: "contentClassifiers", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case contentClassifiers = "ContentClassifiers"
        }
    }

    public struct Image: AWSEncodableShape {
        /// Blob of image bytes up to 5 MBs.
        public let bytes: Data?
        /// Identifies an S3 object as the image source.
        public let s3Object: S3Object?

        public init(bytes: Data? = nil, s3Object: S3Object? = nil) {
            self.bytes = bytes
            self.s3Object = s3Object
        }

        public func validate(name: String) throws {
            try self.validate(self.bytes, name: "bytes", parent: name, max: 5_242_880)
            try self.validate(self.bytes, name: "bytes", parent: name, min: 1)
            try self.s3Object?.validate(name: "\(name).s3Object")
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "Bytes"
            case s3Object = "S3Object"
        }
    }

    public struct ImageQuality: AWSDecodableShape {
        /// Value representing brightness of the face. The service returns a value between 0 and 100 (inclusive). A higher value indicates a brighter face image.
        public let brightness: Float?
        /// Value representing sharpness of the face. The service returns a value between 0 and 100 (inclusive). A higher value indicates a sharper face image.
        public let sharpness: Float?

        public init(brightness: Float? = nil, sharpness: Float? = nil) {
            self.brightness = brightness
            self.sharpness = sharpness
        }

        private enum CodingKeys: String, CodingKey {
            case brightness = "Brightness"
            case sharpness = "Sharpness"
        }
    }

    public struct IndexFacesRequest: AWSEncodableShape {
        /// The ID of an existing collection to which you want to add the faces that are detected in the input images.
        public let collectionId: String
        /// An array of facial attributes that you want to be returned. This can be the default list of attributes or all attributes. If you don't specify a value for Attributes or if you specify ["DEFAULT"], the API returns the following subset of facial attributes: BoundingBox, Confidence, Pose, Quality, and Landmarks. If you provide ["ALL"], all facial attributes are returned, but the operation takes longer to complete. If you provide both, ["ALL", "DEFAULT"], the service uses a logical AND operator to determine which attributes to return (in this case, all attributes).
        public let detectionAttributes: [Attribute]?
        /// The ID you want to assign to all the faces detected in the image.
        public let externalImageId: String?
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes isn't supported.  If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes passed using the Bytes field. For more information, see Images in the Amazon Rekognition developer guide.
        public let image: Image
        /// The maximum number of faces to index. The value of MaxFaces must be greater than or equal to 1. IndexFaces returns no more than 100 detected faces in an image, even if you specify a larger value for MaxFaces. If IndexFaces detects more faces than the value of MaxFaces, the faces with the lowest quality are filtered out first. If there are still more faces than the value of MaxFaces, the faces with the smallest bounding boxes are filtered out (up to the number that's needed to satisfy the value of MaxFaces). Information about the unindexed faces is available in the UnindexedFaces array.  The faces that are returned by IndexFaces are sorted by the largest face bounding box size to the smallest size, in descending order.  MaxFaces can be used with a collection associated with any version of the face model.
        public let maxFaces: Int?
        /// A filter that specifies a quality bar for how much filtering is done to identify faces. Filtered faces aren't indexed. If you specify AUTO, Amazon Rekognition chooses the quality bar. If you specify LOW, MEDIUM, or HIGH, filtering removes all faces that don’t meet the chosen quality bar. The default value is AUTO. The quality bar is based on a variety of common use cases. Low-quality detections can occur for a number of reasons. Some examples are an object that's misidentified as a face, a face that's too blurry, or a face with a pose that's too extreme to use. If you specify NONE, no filtering is performed.  To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.
        public let qualityFilter: QualityFilter?

        public init(collectionId: String, detectionAttributes: [Attribute]? = nil, externalImageId: String? = nil, image: Image, maxFaces: Int? = nil, qualityFilter: QualityFilter? = nil) {
            self.collectionId = collectionId
            self.detectionAttributes = detectionAttributes
            self.externalImageId = externalImageId
            self.image = image
            self.maxFaces = maxFaces
            self.qualityFilter = qualityFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionId, name: "collectionId", parent: name, max: 255)
            try self.validate(self.collectionId, name: "collectionId", parent: name, min: 1)
            try self.validate(self.collectionId, name: "collectionId", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
            try self.validate(self.externalImageId, name: "externalImageId", parent: name, max: 255)
            try self.validate(self.externalImageId, name: "externalImageId", parent: name, min: 1)
            try self.validate(self.externalImageId, name: "externalImageId", parent: name, pattern: "[a-zA-Z0-9_.\\-:]+")
            try self.image.validate(name: "\(name).image")
            try self.validate(self.maxFaces, name: "maxFaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
            case detectionAttributes = "DetectionAttributes"
            case externalImageId = "ExternalImageId"
            case image = "Image"
            case maxFaces = "MaxFaces"
            case qualityFilter = "QualityFilter"
        }
    }

    public struct IndexFacesResponse: AWSDecodableShape {
        /// The version number of the face detection model that's associated with the input collection (CollectionId).
        public let faceModelVersion: String?
        /// An array of faces detected and added to the collection. For more information, see Searching Faces in a Collection in the Amazon Rekognition Developer Guide.
        public let faceRecords: [FaceRecord]?
        /// If your collection is associated with a face detection model that's later than version 3.0, the value of OrientationCorrection is always null and no orientation information is returned. If your collection is associated with a face detection model that's version 3.0 or earlier, the following applies:   If the input image is in .jpeg format, it might contain exchangeable image file format (Exif) metadata that includes the image's orientation. Amazon Rekognition uses this orientation information to perform image correction - the bounding box coordinates are translated to represent object locations after the orientation information in the Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata. The value of OrientationCorrection is null.   If the image doesn't contain orientation information in its Exif metadata, Amazon Rekognition returns an estimated orientation (ROTATE_0, ROTATE_90, ROTATE_180, ROTATE_270). Amazon Rekognition doesn’t perform image correction for images. The bounding box coordinates aren't translated and represent the object locations before the image is rotated.   Bounding box information is returned in the FaceRecords array. You can get the version of the face detection model by calling DescribeCollection.
        public let orientationCorrection: OrientationCorrection?
        /// An array of faces that were detected in the image but weren't indexed. They weren't indexed because the quality filter identified them as low quality, or the MaxFaces request parameter filtered them out. To use the quality filter, you specify the QualityFilter request parameter.
        public let unindexedFaces: [UnindexedFace]?

        public init(faceModelVersion: String? = nil, faceRecords: [FaceRecord]? = nil, orientationCorrection: OrientationCorrection? = nil, unindexedFaces: [UnindexedFace]? = nil) {
            self.faceModelVersion = faceModelVersion
            self.faceRecords = faceRecords
            self.orientationCorrection = orientationCorrection
            self.unindexedFaces = unindexedFaces
        }

        private enum CodingKeys: String, CodingKey {
            case faceModelVersion = "FaceModelVersion"
            case faceRecords = "FaceRecords"
            case orientationCorrection = "OrientationCorrection"
            case unindexedFaces = "UnindexedFaces"
        }
    }

    public struct Instance: AWSDecodableShape {
        /// The position of the label instance on the image.
        public let boundingBox: BoundingBox?
        /// The confidence that Amazon Rekognition has in the accuracy of the bounding box.
        public let confidence: Float?

        public init(boundingBox: BoundingBox? = nil, confidence: Float? = nil) {
            self.boundingBox = boundingBox
            self.confidence = confidence
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case confidence = "Confidence"
        }
    }

    public struct KinesisDataStream: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the output Amazon Kinesis Data Streams stream.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "(^arn:([a-z\\d-]+):kinesis:([a-z\\d-]+):\\d{12}:.+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct KinesisVideoStream: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the Kinesis video stream stream that streams the source video.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "(^arn:([a-z\\d-]+):kinesisvideo:([a-z\\d-]+):\\d{12}:.+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct Label: AWSDecodableShape {
        /// Level of confidence.
        public let confidence: Float?
        /// If Label represents an object, Instances contains the bounding boxes for each instance of the detected object. Bounding boxes are returned for common object labels such as people, cars, furniture, apparel or pets.
        public let instances: [Instance]?
        /// The name (label) of the object or scene.
        public let name: String?
        /// The parent labels for a label. The response includes all ancestor labels.
        public let parents: [Parent]?

        public init(confidence: Float? = nil, instances: [Instance]? = nil, name: String? = nil, parents: [Parent]? = nil) {
            self.confidence = confidence
            self.instances = instances
            self.name = name
            self.parents = parents
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case instances = "Instances"
            case name = "Name"
            case parents = "Parents"
        }
    }

    public struct LabelDetection: AWSDecodableShape {
        /// Details about the detected label.
        public let label: Label?
        /// Time, in milliseconds from the start of the video, that the label was detected.
        public let timestamp: Int64?

        public init(label: Label? = nil, timestamp: Int64? = nil) {
            self.label = label
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case timestamp = "Timestamp"
        }
    }

    public struct Landmark: AWSDecodableShape {
        /// Type of landmark.
        public let type: LandmarkType?
        /// The x-coordinate of the landmark expressed as a ratio of the width of the image. The x-coordinate is measured from the left-side of the image. For example, if the image is 700 pixels wide and the x-coordinate of the landmark is at 350 pixels, this value is 0.5.
        public let x: Float?
        /// The y-coordinate of the landmark expressed as a ratio of the height of the image. The y-coordinate is measured from the top of the image. For example, if the image height is 200 pixels and the y-coordinate of the landmark is at 50 pixels, this value is 0.25.
        public let y: Float?

        public init(type: LandmarkType? = nil, x: Float? = nil, y: Float? = nil) {
            self.type = type
            self.x = x
            self.y = y
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case x = "X"
            case y = "Y"
        }
    }

    public struct ListCollectionsRequest: AWSEncodableShape {
        /// Maximum number of collection IDs to return.
        public let maxResults: Int?
        /// Pagination token from the previous response.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 4096)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCollectionsResponse: AWSDecodableShape {
        /// An array of collection IDs.
        public let collectionIds: [String]?
        /// Version numbers of the face detection models associated with the collections in the array CollectionIds. For example, the value of FaceModelVersions[2] is the version number for the face detection model used by the collection in CollectionId[2].
        public let faceModelVersions: [String]?
        /// If the result is truncated, the response provides a NextToken that you can use in the subsequent request to fetch the next set of collection IDs.
        public let nextToken: String?

        public init(collectionIds: [String]? = nil, faceModelVersions: [String]? = nil, nextToken: String? = nil) {
            self.collectionIds = collectionIds
            self.faceModelVersions = faceModelVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collectionIds = "CollectionIds"
            case faceModelVersions = "FaceModelVersions"
            case nextToken = "NextToken"
        }
    }

    public struct ListFacesRequest: AWSEncodableShape {
        /// ID of the collection from which to list the faces.
        public let collectionId: String
        /// Maximum number of faces to return.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Rekognition returns a pagination token in the response. You can use this pagination token to retrieve the next set of faces.
        public let nextToken: String?

        public init(collectionId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collectionId = collectionId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionId, name: "collectionId", parent: name, max: 255)
            try self.validate(self.collectionId, name: "collectionId", parent: name, min: 1)
            try self.validate(self.collectionId, name: "collectionId", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 4096)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListFacesResponse: AWSDecodableShape {
        /// Version number of the face detection model associated with the input collection (CollectionId).
        public let faceModelVersion: String?
        /// An array of Face objects.
        public let faces: [Face]?
        /// If the response is truncated, Amazon Rekognition returns this token that you can use in the subsequent request to retrieve the next set of faces.
        public let nextToken: String?

        public init(faceModelVersion: String? = nil, faces: [Face]? = nil, nextToken: String? = nil) {
            self.faceModelVersion = faceModelVersion
            self.faces = faces
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case faceModelVersion = "FaceModelVersion"
            case faces = "Faces"
            case nextToken = "NextToken"
        }
    }

    public struct ListStreamProcessorsRequest: AWSEncodableShape {
        /// Maximum number of stream processors you want Amazon Rekognition Video to return in the response. The default is 1000.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there are more stream processors to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of stream processors.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListStreamProcessorsResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of stream processors.
        public let nextToken: String?
        /// List of stream processors that you have created.
        public let streamProcessors: [StreamProcessor]?

        public init(nextToken: String? = nil, streamProcessors: [StreamProcessor]? = nil) {
            self.nextToken = nextToken
            self.streamProcessors = streamProcessors
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case streamProcessors = "StreamProcessors"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        ///  Amazon Resource Name (ARN) of the model, collection, or stream processor that contains the tags that you want a list of.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  A list of key-value tags assigned to the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ModerationLabel: AWSDecodableShape {
        /// Specifies the confidence that Amazon Rekognition has that the label has been correctly identified. If you don't specify the MinConfidence parameter in the call to DetectModerationLabels, the operation returns labels with a confidence value greater than or equal to 50 percent.
        public let confidence: Float?
        /// The label name for the type of unsafe content detected in the image.
        public let name: String?
        /// The name for the parent label. Labels at the top level of the hierarchy have the parent label "".
        public let parentName: String?

        public init(confidence: Float? = nil, name: String? = nil, parentName: String? = nil) {
            self.confidence = confidence
            self.name = name
            self.parentName = parentName
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case name = "Name"
            case parentName = "ParentName"
        }
    }

    public struct MouthOpen: AWSDecodableShape {
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the mouth on the face is open or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public struct Mustache: AWSDecodableShape {
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face has mustache or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public struct NotificationChannel: AWSEncodableShape {
        /// The ARN of an IAM role that gives Amazon Rekognition publishing permissions to the Amazon SNS topic.
        public let roleArn: String
        /// The Amazon SNS topic to which Amazon Rekognition to posts the completion status.
        public let sNSTopicArn: String

        public init(roleArn: String, sNSTopicArn: String) {
            self.roleArn = roleArn
            self.sNSTopicArn = sNSTopicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:aws:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
            try self.validate(self.sNSTopicArn, name: "sNSTopicArn", parent: name, pattern: "(^arn:aws:sns:.*:\\w{12}:.+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case sNSTopicArn = "SNSTopicArn"
        }
    }

    public struct OutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket where training output is placed.
        public let s3Bucket: String?
        /// The prefix applied to the training output files.
        public let s3KeyPrefix: String?

        public init(s3Bucket: String? = nil, s3KeyPrefix: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3KeyPrefix = s3KeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 255)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "[0-9A-Za-z\\.\\-_]*")
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "S3Bucket"
            case s3KeyPrefix = "S3KeyPrefix"
        }
    }

    public struct Parent: AWSDecodableShape {
        /// The name of the parent label.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct PersonDetail: AWSDecodableShape {
        /// Bounding box around the detected person.
        public let boundingBox: BoundingBox?
        /// Face details for the detected person.
        public let face: FaceDetail?
        /// Identifier for the person detected person within a video. Use to keep track of the person throughout the video. The identifier is not stored by Amazon Rekognition.
        public let index: Int64?

        public init(boundingBox: BoundingBox? = nil, face: FaceDetail? = nil, index: Int64? = nil) {
            self.boundingBox = boundingBox
            self.face = face
            self.index = index
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case face = "Face"
            case index = "Index"
        }
    }

    public struct PersonDetection: AWSDecodableShape {
        /// Details about a person whose path was tracked in a video.
        public let person: PersonDetail?
        /// The time, in milliseconds from the start of the video, that the person's path was tracked.
        public let timestamp: Int64?

        public init(person: PersonDetail? = nil, timestamp: Int64? = nil) {
            self.person = person
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case person = "Person"
            case timestamp = "Timestamp"
        }
    }

    public struct PersonMatch: AWSDecodableShape {
        /// Information about the faces in the input collection that match the face of a person in the video.
        public let faceMatches: [FaceMatch]?
        /// Information about the matched person.
        public let person: PersonDetail?
        /// The time, in milliseconds from the beginning of the video, that the person was matched in the video.
        public let timestamp: Int64?

        public init(faceMatches: [FaceMatch]? = nil, person: PersonDetail? = nil, timestamp: Int64? = nil) {
            self.faceMatches = faceMatches
            self.person = person
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case faceMatches = "FaceMatches"
            case person = "Person"
            case timestamp = "Timestamp"
        }
    }

    public struct Point: AWSDecodableShape {
        /// The value of the X coordinate for a point on a Polygon.
        public let x: Float?
        /// The value of the Y coordinate for a point on a Polygon.
        public let y: Float?

        public init(x: Float? = nil, y: Float? = nil) {
            self.x = x
            self.y = y
        }

        private enum CodingKeys: String, CodingKey {
            case x = "X"
            case y = "Y"
        }
    }

    public struct Pose: AWSDecodableShape {
        /// Value representing the face rotation on the pitch axis.
        public let pitch: Float?
        /// Value representing the face rotation on the roll axis.
        public let roll: Float?
        /// Value representing the face rotation on the yaw axis.
        public let yaw: Float?

        public init(pitch: Float? = nil, roll: Float? = nil, yaw: Float? = nil) {
            self.pitch = pitch
            self.roll = roll
            self.yaw = yaw
        }

        private enum CodingKeys: String, CodingKey {
            case pitch = "Pitch"
            case roll = "Roll"
            case yaw = "Yaw"
        }
    }

    public struct ProjectDescription: AWSDecodableShape {
        /// The Unix timestamp for the date and time that the project was created.
        public let creationTimestamp: Date?
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: String?
        /// The current status of the project.
        public let status: ProjectStatus?

        public init(creationTimestamp: Date? = nil, projectArn: String? = nil, status: ProjectStatus? = nil) {
            self.creationTimestamp = creationTimestamp
            self.projectArn = projectArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case projectArn = "ProjectArn"
            case status = "Status"
        }
    }

    public struct ProjectVersionDescription: AWSDecodableShape {
        /// The duration, in seconds, that the model version has been billed for training. This value is only returned if the model version has been successfully trained.
        public let billableTrainingTimeInSeconds: Int64?
        /// The Unix datetime for the date and time that training started.
        public let creationTimestamp: Date?
        /// The training results. EvaluationResult is only returned if training is successful.
        public let evaluationResult: EvaluationResult?
        /// The identifer for the AWS Key Management Service (AWS KMS) customer master key that was used to encrypt the model during training.
        public let kmsKeyId: String?
        /// The location of the summary manifest. The summary manifest provides aggregate data validation results for the training and test datasets.
        public let manifestSummary: GroundTruthManifest?
        /// The minimum number of inference units used by the model. For more information, see StartProjectVersion.
        public let minInferenceUnits: Int?
        /// The location where training results are saved.
        public let outputConfig: OutputConfig?
        /// The Amazon Resource Name (ARN) of the model version.
        public let projectVersionArn: String?
        /// The current status of the model version.
        public let status: ProjectVersionStatus?
        /// A descriptive message for an error or warning that occurred.
        public let statusMessage: String?
        /// Contains information about the testing results.
        public let testingDataResult: TestingDataResult?
        /// Contains information about the training results.
        public let trainingDataResult: TrainingDataResult?
        /// The Unix date and time that training of the model ended.
        public let trainingEndTimestamp: Date?

        public init(billableTrainingTimeInSeconds: Int64? = nil, creationTimestamp: Date? = nil, evaluationResult: EvaluationResult? = nil, kmsKeyId: String? = nil, manifestSummary: GroundTruthManifest? = nil, minInferenceUnits: Int? = nil, outputConfig: OutputConfig? = nil, projectVersionArn: String? = nil, status: ProjectVersionStatus? = nil, statusMessage: String? = nil, testingDataResult: TestingDataResult? = nil, trainingDataResult: TrainingDataResult? = nil, trainingEndTimestamp: Date? = nil) {
            self.billableTrainingTimeInSeconds = billableTrainingTimeInSeconds
            self.creationTimestamp = creationTimestamp
            self.evaluationResult = evaluationResult
            self.kmsKeyId = kmsKeyId
            self.manifestSummary = manifestSummary
            self.minInferenceUnits = minInferenceUnits
            self.outputConfig = outputConfig
            self.projectVersionArn = projectVersionArn
            self.status = status
            self.statusMessage = statusMessage
            self.testingDataResult = testingDataResult
            self.trainingDataResult = trainingDataResult
            self.trainingEndTimestamp = trainingEndTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case billableTrainingTimeInSeconds = "BillableTrainingTimeInSeconds"
            case creationTimestamp = "CreationTimestamp"
            case evaluationResult = "EvaluationResult"
            case kmsKeyId = "KmsKeyId"
            case manifestSummary = "ManifestSummary"
            case minInferenceUnits = "MinInferenceUnits"
            case outputConfig = "OutputConfig"
            case projectVersionArn = "ProjectVersionArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case testingDataResult = "TestingDataResult"
            case trainingDataResult = "TrainingDataResult"
            case trainingEndTimestamp = "TrainingEndTimestamp"
        }
    }

    public struct ProtectiveEquipmentBodyPart: AWSDecodableShape {
        /// The confidence that Amazon Rekognition has in the detection accuracy of the detected body part.
        public let confidence: Float?
        /// An array of Personal Protective Equipment items detected around a body part.
        public let equipmentDetections: [EquipmentDetection]?
        /// The detected body part.
        public let name: BodyPart?

        public init(confidence: Float? = nil, equipmentDetections: [EquipmentDetection]? = nil, name: BodyPart? = nil) {
            self.confidence = confidence
            self.equipmentDetections = equipmentDetections
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case equipmentDetections = "EquipmentDetections"
            case name = "Name"
        }
    }

    public struct ProtectiveEquipmentPerson: AWSDecodableShape {
        /// An array of body parts detected on a person's body (including body parts without PPE).
        public let bodyParts: [ProtectiveEquipmentBodyPart]?
        /// A bounding box around the detected person.
        public let boundingBox: BoundingBox?
        /// The confidence that Amazon Rekognition has that the bounding box contains a person.
        public let confidence: Float?
        /// The identifier for the detected person. The identifier is only unique for a single call to DetectProtectiveEquipment.
        public let id: Int?

        public init(bodyParts: [ProtectiveEquipmentBodyPart]? = nil, boundingBox: BoundingBox? = nil, confidence: Float? = nil, id: Int? = nil) {
            self.bodyParts = bodyParts
            self.boundingBox = boundingBox
            self.confidence = confidence
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case bodyParts = "BodyParts"
            case boundingBox = "BoundingBox"
            case confidence = "Confidence"
            case id = "Id"
        }
    }

    public struct ProtectiveEquipmentSummarizationAttributes: AWSEncodableShape {
        /// The minimum confidence level for which you want summary information. The confidence level applies to person detection, body part detection, equipment detection, and body part coverage. Amazon Rekognition doesn't return summary information with a confidence than this specified value. There isn't a default value. Specify a MinConfidence value that is between 50-100% as DetectProtectiveEquipment returns predictions only where the detection confidence is between 50% - 100%. If you specify a value that is less than 50%, the results are the same specifying a value of 50%.
        public let minConfidence: Float
        /// An array of personal protective equipment types for which you want summary information. If a person is detected wearing a required requipment type, the person's ID is added to the PersonsWithRequiredEquipment array field returned in ProtectiveEquipmentSummary by DetectProtectiveEquipment.
        public let requiredEquipmentTypes: [ProtectiveEquipmentType]

        public init(minConfidence: Float, requiredEquipmentTypes: [ProtectiveEquipmentType]) {
            self.minConfidence = minConfidence
            self.requiredEquipmentTypes = requiredEquipmentTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, max: 100)
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case minConfidence = "MinConfidence"
            case requiredEquipmentTypes = "RequiredEquipmentTypes"
        }
    }

    public struct ProtectiveEquipmentSummary: AWSDecodableShape {
        /// An array of IDs for persons where it was not possible to determine if they are wearing personal protective equipment.
        public let personsIndeterminate: [Int]?
        /// An array of IDs for persons who are not wearing all of the types of PPE specified in the RequiredEquipmentTypes field of the detected personal protective equipment.
        public let personsWithoutRequiredEquipment: [Int]?
        /// An array of IDs for persons who are wearing detected personal protective equipment.
        public let personsWithRequiredEquipment: [Int]?

        public init(personsIndeterminate: [Int]? = nil, personsWithoutRequiredEquipment: [Int]? = nil, personsWithRequiredEquipment: [Int]? = nil) {
            self.personsIndeterminate = personsIndeterminate
            self.personsWithoutRequiredEquipment = personsWithoutRequiredEquipment
            self.personsWithRequiredEquipment = personsWithRequiredEquipment
        }

        private enum CodingKeys: String, CodingKey {
            case personsIndeterminate = "PersonsIndeterminate"
            case personsWithoutRequiredEquipment = "PersonsWithoutRequiredEquipment"
            case personsWithRequiredEquipment = "PersonsWithRequiredEquipment"
        }
    }

    public struct RecognizeCelebritiesRequest: AWSEncodableShape {
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported.  If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes passed using the Bytes field. For more information, see Images in the Amazon Rekognition developer guide.
        public let image: Image

        public init(image: Image) {
            self.image = image
        }

        public func validate(name: String) throws {
            try self.image.validate(name: "\(name).image")
        }

        private enum CodingKeys: String, CodingKey {
            case image = "Image"
        }
    }

    public struct RecognizeCelebritiesResponse: AWSDecodableShape {
        /// Details about each celebrity found in the image. Amazon Rekognition can detect a maximum of 64 celebrities in an image.
        public let celebrityFaces: [Celebrity]?
        /// The orientation of the input image (counterclockwise direction). If your application displays the image, you can use this value to correct the orientation. The bounding box coordinates returned in CelebrityFaces and UnrecognizedFaces represent face locations before the image orientation is corrected.   If the input image is in .jpeg format, it might contain exchangeable image (Exif) metadata that includes the image's orientation. If so, and the Exif metadata for the input image populates the orientation field, the value of OrientationCorrection is null. The CelebrityFaces and UnrecognizedFaces bounding box coordinates represent face locations after Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata.
        public let orientationCorrection: OrientationCorrection?
        /// Details about each unrecognized face in the image.
        public let unrecognizedFaces: [ComparedFace]?

        public init(celebrityFaces: [Celebrity]? = nil, orientationCorrection: OrientationCorrection? = nil, unrecognizedFaces: [ComparedFace]? = nil) {
            self.celebrityFaces = celebrityFaces
            self.orientationCorrection = orientationCorrection
            self.unrecognizedFaces = unrecognizedFaces
        }

        private enum CodingKeys: String, CodingKey {
            case celebrityFaces = "CelebrityFaces"
            case orientationCorrection = "OrientationCorrection"
            case unrecognizedFaces = "UnrecognizedFaces"
        }
    }

    public struct RegionOfInterest: AWSEncodableShape {
        /// The box representing a region of interest on screen.
        public let boundingBox: BoundingBox?

        public init(boundingBox: BoundingBox? = nil) {
            self.boundingBox = boundingBox
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
        }
    }

    public struct S3Object: AWSEncodableShape & AWSDecodableShape {
        /// Name of the S3 bucket.
        public let bucket: String?
        /// S3 object key name.
        public let name: String?
        /// If the bucket is versioning enabled, you can specify the object version.
        public let version: String?

        public init(bucket: String? = nil, name: String? = nil, version: String? = nil) {
            self.bucket = bucket
            self.name = name
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "[0-9A-Za-z\\.\\-_]*")
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, max: 1024)
            try self.validate(self.version, name: "version", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct SearchFacesByImageRequest: AWSEncodableShape {
        /// ID of the collection to search.
        public let collectionId: String
        /// (Optional) Specifies the minimum confidence in the face match to return. For example, don't return any matches where confidence in matches is less than 70%. The default value is 80%.
        public let faceMatchThreshold: Float?
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported.  If you are using an AWS SDK to call Amazon Rekognition, you might not need to base64-encode image bytes passed using the Bytes field. For more information, see Images in the Amazon Rekognition developer guide.
        public let image: Image
        /// Maximum number of faces to return. The operation returns the maximum number of faces with the highest confidence in the match.
        public let maxFaces: Int?
        /// A filter that specifies a quality bar for how much filtering is done to identify faces. Filtered faces aren't searched for in the collection. If you specify AUTO, Amazon Rekognition chooses the quality bar. If you specify LOW, MEDIUM, or HIGH, filtering removes all faces that don’t meet the chosen quality bar. The quality bar is based on a variety of common use cases. Low-quality detections can occur for a number of reasons. Some examples are an object that's misidentified as a face, a face that's too blurry, or a face with a pose that's too extreme to use. If you specify NONE, no filtering is performed. The default value is NONE.  To use quality filtering, the collection you are using must be associated with version 3 of the face model or higher.
        public let qualityFilter: QualityFilter?

        public init(collectionId: String, faceMatchThreshold: Float? = nil, image: Image, maxFaces: Int? = nil, qualityFilter: QualityFilter? = nil) {
            self.collectionId = collectionId
            self.faceMatchThreshold = faceMatchThreshold
            self.image = image
            self.maxFaces = maxFaces
            self.qualityFilter = qualityFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionId, name: "collectionId", parent: name, max: 255)
            try self.validate(self.collectionId, name: "collectionId", parent: name, min: 1)
            try self.validate(self.collectionId, name: "collectionId", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
            try self.validate(self.faceMatchThreshold, name: "faceMatchThreshold", parent: name, max: 100)
            try self.validate(self.faceMatchThreshold, name: "faceMatchThreshold", parent: name, min: 0)
            try self.image.validate(name: "\(name).image")
            try self.validate(self.maxFaces, name: "maxFaces", parent: name, max: 4096)
            try self.validate(self.maxFaces, name: "maxFaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
            case faceMatchThreshold = "FaceMatchThreshold"
            case image = "Image"
            case maxFaces = "MaxFaces"
            case qualityFilter = "QualityFilter"
        }
    }

    public struct SearchFacesByImageResponse: AWSDecodableShape {
        /// An array of faces that match the input face, along with the confidence in the match.
        public let faceMatches: [FaceMatch]?
        /// Version number of the face detection model associated with the input collection (CollectionId).
        public let faceModelVersion: String?
        /// The bounding box around the face in the input image that Amazon Rekognition used for the search.
        public let searchedFaceBoundingBox: BoundingBox?
        /// The level of confidence that the searchedFaceBoundingBox, contains a face.
        public let searchedFaceConfidence: Float?

        public init(faceMatches: [FaceMatch]? = nil, faceModelVersion: String? = nil, searchedFaceBoundingBox: BoundingBox? = nil, searchedFaceConfidence: Float? = nil) {
            self.faceMatches = faceMatches
            self.faceModelVersion = faceModelVersion
            self.searchedFaceBoundingBox = searchedFaceBoundingBox
            self.searchedFaceConfidence = searchedFaceConfidence
        }

        private enum CodingKeys: String, CodingKey {
            case faceMatches = "FaceMatches"
            case faceModelVersion = "FaceModelVersion"
            case searchedFaceBoundingBox = "SearchedFaceBoundingBox"
            case searchedFaceConfidence = "SearchedFaceConfidence"
        }
    }

    public struct SearchFacesRequest: AWSEncodableShape {
        /// ID of the collection the face belongs to.
        public let collectionId: String
        /// ID of a face to find matches for in the collection.
        public let faceId: String
        /// Optional value specifying the minimum confidence in the face match to return. For example, don't return any matches where confidence in matches is less than 70%. The default value is 80%.
        public let faceMatchThreshold: Float?
        /// Maximum number of faces to return. The operation returns the maximum number of faces with the highest confidence in the match.
        public let maxFaces: Int?

        public init(collectionId: String, faceId: String, faceMatchThreshold: Float? = nil, maxFaces: Int? = nil) {
            self.collectionId = collectionId
            self.faceId = faceId
            self.faceMatchThreshold = faceMatchThreshold
            self.maxFaces = maxFaces
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionId, name: "collectionId", parent: name, max: 255)
            try self.validate(self.collectionId, name: "collectionId", parent: name, min: 1)
            try self.validate(self.collectionId, name: "collectionId", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
            try self.validate(self.faceId, name: "faceId", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.faceMatchThreshold, name: "faceMatchThreshold", parent: name, max: 100)
            try self.validate(self.faceMatchThreshold, name: "faceMatchThreshold", parent: name, min: 0)
            try self.validate(self.maxFaces, name: "maxFaces", parent: name, max: 4096)
            try self.validate(self.maxFaces, name: "maxFaces", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
            case faceId = "FaceId"
            case faceMatchThreshold = "FaceMatchThreshold"
            case maxFaces = "MaxFaces"
        }
    }

    public struct SearchFacesResponse: AWSDecodableShape {
        /// An array of faces that matched the input face, along with the confidence in the match.
        public let faceMatches: [FaceMatch]?
        /// Version number of the face detection model associated with the input collection (CollectionId).
        public let faceModelVersion: String?
        /// ID of the face that was searched for matches in a collection.
        public let searchedFaceId: String?

        public init(faceMatches: [FaceMatch]? = nil, faceModelVersion: String? = nil, searchedFaceId: String? = nil) {
            self.faceMatches = faceMatches
            self.faceModelVersion = faceModelVersion
            self.searchedFaceId = searchedFaceId
        }

        private enum CodingKeys: String, CodingKey {
            case faceMatches = "FaceMatches"
            case faceModelVersion = "FaceModelVersion"
            case searchedFaceId = "SearchedFaceId"
        }
    }

    public struct SegmentDetection: AWSDecodableShape {
        /// The duration of the detected segment in milliseconds.
        public let durationMillis: Int64?
        /// The duration of the timecode for the detected segment in SMPTE format.
        public let durationSMPTE: String?
        /// The frame-accurate SMPTE timecode, from the start of a video, for the end of a detected segment. EndTimecode is in HH:MM:SS:fr format (and ;fr for drop frame-rates).
        public let endTimecodeSMPTE: String?
        /// The end time of the detected segment, in milliseconds, from the start of the video. This value is rounded down.
        public let endTimestampMillis: Int64?
        /// If the segment is a shot detection, contains information about the shot detection.
        public let shotSegment: ShotSegment?
        /// The frame-accurate SMPTE timecode, from the start of a video, for the start of a detected segment. StartTimecode is in HH:MM:SS:fr format (and ;fr for drop frame-rates).
        public let startTimecodeSMPTE: String?
        /// The start time of the detected segment in milliseconds from the start of the video. This value is rounded down. For example, if the actual timestamp is 100.6667 milliseconds, Amazon Rekognition Video returns a value of 100 millis.
        public let startTimestampMillis: Int64?
        /// If the segment is a technical cue, contains information about the technical cue.
        public let technicalCueSegment: TechnicalCueSegment?
        /// The type of the segment. Valid values are TECHNICAL_CUE and SHOT.
        public let type: SegmentType?

        public init(durationMillis: Int64? = nil, durationSMPTE: String? = nil, endTimecodeSMPTE: String? = nil, endTimestampMillis: Int64? = nil, shotSegment: ShotSegment? = nil, startTimecodeSMPTE: String? = nil, startTimestampMillis: Int64? = nil, technicalCueSegment: TechnicalCueSegment? = nil, type: SegmentType? = nil) {
            self.durationMillis = durationMillis
            self.durationSMPTE = durationSMPTE
            self.endTimecodeSMPTE = endTimecodeSMPTE
            self.endTimestampMillis = endTimestampMillis
            self.shotSegment = shotSegment
            self.startTimecodeSMPTE = startTimecodeSMPTE
            self.startTimestampMillis = startTimestampMillis
            self.technicalCueSegment = technicalCueSegment
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case durationMillis = "DurationMillis"
            case durationSMPTE = "DurationSMPTE"
            case endTimecodeSMPTE = "EndTimecodeSMPTE"
            case endTimestampMillis = "EndTimestampMillis"
            case shotSegment = "ShotSegment"
            case startTimecodeSMPTE = "StartTimecodeSMPTE"
            case startTimestampMillis = "StartTimestampMillis"
            case technicalCueSegment = "TechnicalCueSegment"
            case type = "Type"
        }
    }

    public struct SegmentTypeInfo: AWSDecodableShape {
        /// The version of the model used to detect segments.
        public let modelVersion: String?
        /// The type of a segment (technical cue or shot detection).
        public let type: SegmentType?

        public init(modelVersion: String? = nil, type: SegmentType? = nil) {
            self.modelVersion = modelVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case modelVersion = "ModelVersion"
            case type = "Type"
        }
    }

    public struct ShotSegment: AWSDecodableShape {
        /// The confidence that Amazon Rekognition Video has in the accuracy of the detected segment.
        public let confidence: Float?
        /// An Identifier for a shot detection segment detected in a video.
        public let index: Int64?

        public init(confidence: Float? = nil, index: Int64? = nil) {
            self.confidence = confidence
            self.index = index
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case index = "Index"
        }
    }

    public struct Smile: AWSDecodableShape {
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face is smiling or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public struct StartCelebrityRecognitionRequest: AWSEncodableShape {
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartCelebrityRecognition requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once.
        public let clientRequestToken: String?
        /// An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use JobTag to group related jobs and identify them in the completion notification.
        public let jobTag: String?
        /// The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the celebrity recognition analysis to.
        public let notificationChannel: NotificationChannel?
        /// The video in which you want to recognize celebrities. The video must be stored in an Amazon S3 bucket.
        public let video: Video

        public init(clientRequestToken: String? = nil, jobTag: String? = nil, notificationChannel: NotificationChannel? = nil, video: Video) {
            self.clientRequestToken = clientRequestToken
            self.jobTag = jobTag
            self.notificationChannel = notificationChannel
            self.video = video
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.jobTag, name: "jobTag", parent: name, max: 256)
            try self.validate(self.jobTag, name: "jobTag", parent: name, min: 1)
            try self.validate(self.jobTag, name: "jobTag", parent: name, pattern: "[a-zA-Z0-9_.\\-:]+")
            try self.notificationChannel?.validate(name: "\(name).notificationChannel")
            try self.video.validate(name: "\(name).video")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case jobTag = "JobTag"
            case notificationChannel = "NotificationChannel"
            case video = "Video"
        }
    }

    public struct StartCelebrityRecognitionResponse: AWSDecodableShape {
        /// The identifier for the celebrity recognition analysis job. Use JobId to identify the job in a subsequent call to GetCelebrityRecognition.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartContentModerationRequest: AWSEncodableShape {
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartContentModeration requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once.
        public let clientRequestToken: String?
        /// An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use JobTag to group related jobs and identify them in the completion notification.
        public let jobTag: String?
        /// Specifies the minimum confidence that Amazon Rekognition must have in order to return a moderated content label. Confidence represents how certain Amazon Rekognition is that the moderated content is correctly identified. 0 is the lowest confidence. 100 is the highest confidence. Amazon Rekognition doesn't return any moderated content labels with a confidence level lower than this specified value. If you don't specify MinConfidence, GetContentModeration returns labels with confidence values greater than or equal to 50 percent.
        public let minConfidence: Float?
        /// The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the unsafe content analysis to.
        public let notificationChannel: NotificationChannel?
        /// The video in which you want to detect unsafe content. The video must be stored in an Amazon S3 bucket.
        public let video: Video

        public init(clientRequestToken: String? = nil, jobTag: String? = nil, minConfidence: Float? = nil, notificationChannel: NotificationChannel? = nil, video: Video) {
            self.clientRequestToken = clientRequestToken
            self.jobTag = jobTag
            self.minConfidence = minConfidence
            self.notificationChannel = notificationChannel
            self.video = video
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.jobTag, name: "jobTag", parent: name, max: 256)
            try self.validate(self.jobTag, name: "jobTag", parent: name, min: 1)
            try self.validate(self.jobTag, name: "jobTag", parent: name, pattern: "[a-zA-Z0-9_.\\-:]+")
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, max: 100)
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, min: 0)
            try self.notificationChannel?.validate(name: "\(name).notificationChannel")
            try self.video.validate(name: "\(name).video")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case jobTag = "JobTag"
            case minConfidence = "MinConfidence"
            case notificationChannel = "NotificationChannel"
            case video = "Video"
        }
    }

    public struct StartContentModerationResponse: AWSDecodableShape {
        /// The identifier for the unsafe content analysis job. Use JobId to identify the job in a subsequent call to GetContentModeration.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartFaceDetectionRequest: AWSEncodableShape {
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartFaceDetection requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once.
        public let clientRequestToken: String?
        /// The face attributes you want returned.  DEFAULT - The following subset of facial attributes are returned: BoundingBox, Confidence, Pose, Quality and Landmarks.   ALL - All facial attributes are returned.
        public let faceAttributes: FaceAttributes?
        /// An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use JobTag to group related jobs and identify them in the completion notification.
        public let jobTag: String?
        /// The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the face detection operation.
        public let notificationChannel: NotificationChannel?
        /// The video in which you want to detect faces. The video must be stored in an Amazon S3 bucket.
        public let video: Video

        public init(clientRequestToken: String? = nil, faceAttributes: FaceAttributes? = nil, jobTag: String? = nil, notificationChannel: NotificationChannel? = nil, video: Video) {
            self.clientRequestToken = clientRequestToken
            self.faceAttributes = faceAttributes
            self.jobTag = jobTag
            self.notificationChannel = notificationChannel
            self.video = video
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.jobTag, name: "jobTag", parent: name, max: 256)
            try self.validate(self.jobTag, name: "jobTag", parent: name, min: 1)
            try self.validate(self.jobTag, name: "jobTag", parent: name, pattern: "[a-zA-Z0-9_.\\-:]+")
            try self.notificationChannel?.validate(name: "\(name).notificationChannel")
            try self.video.validate(name: "\(name).video")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case faceAttributes = "FaceAttributes"
            case jobTag = "JobTag"
            case notificationChannel = "NotificationChannel"
            case video = "Video"
        }
    }

    public struct StartFaceDetectionResponse: AWSDecodableShape {
        /// The identifier for the face detection job. Use JobId to identify the job in a subsequent call to GetFaceDetection.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartFaceSearchRequest: AWSEncodableShape {
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartFaceSearch requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once.
        public let clientRequestToken: String?
        /// ID of the collection that contains the faces you want to search for.
        public let collectionId: String
        /// The minimum confidence in the person match to return. For example, don't return any matches where confidence in matches is less than 70%. The default value is 80%.
        public let faceMatchThreshold: Float?
        /// An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use JobTag to group related jobs and identify them in the completion notification.
        public let jobTag: String?
        /// The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the search.
        public let notificationChannel: NotificationChannel?
        /// The video you want to search. The video must be stored in an Amazon S3 bucket.
        public let video: Video

        public init(clientRequestToken: String? = nil, collectionId: String, faceMatchThreshold: Float? = nil, jobTag: String? = nil, notificationChannel: NotificationChannel? = nil, video: Video) {
            self.clientRequestToken = clientRequestToken
            self.collectionId = collectionId
            self.faceMatchThreshold = faceMatchThreshold
            self.jobTag = jobTag
            self.notificationChannel = notificationChannel
            self.video = video
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.collectionId, name: "collectionId", parent: name, max: 255)
            try self.validate(self.collectionId, name: "collectionId", parent: name, min: 1)
            try self.validate(self.collectionId, name: "collectionId", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
            try self.validate(self.faceMatchThreshold, name: "faceMatchThreshold", parent: name, max: 100)
            try self.validate(self.faceMatchThreshold, name: "faceMatchThreshold", parent: name, min: 0)
            try self.validate(self.jobTag, name: "jobTag", parent: name, max: 256)
            try self.validate(self.jobTag, name: "jobTag", parent: name, min: 1)
            try self.validate(self.jobTag, name: "jobTag", parent: name, pattern: "[a-zA-Z0-9_.\\-:]+")
            try self.notificationChannel?.validate(name: "\(name).notificationChannel")
            try self.video.validate(name: "\(name).video")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case collectionId = "CollectionId"
            case faceMatchThreshold = "FaceMatchThreshold"
            case jobTag = "JobTag"
            case notificationChannel = "NotificationChannel"
            case video = "Video"
        }
    }

    public struct StartFaceSearchResponse: AWSDecodableShape {
        /// The identifier for the search job. Use JobId to identify the job in a subsequent call to GetFaceSearch.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartLabelDetectionRequest: AWSEncodableShape {
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartLabelDetection requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once.
        public let clientRequestToken: String?
        /// An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use JobTag to group related jobs and identify them in the completion notification.
        public let jobTag: String?
        /// Specifies the minimum confidence that Amazon Rekognition Video must have in order to return a detected label. Confidence represents how certain Amazon Rekognition is that a label is correctly identified.0 is the lowest confidence. 100 is the highest confidence. Amazon Rekognition Video doesn't return any labels with a confidence level lower than this specified value. If you don't specify MinConfidence, the operation returns labels with confidence values greater than or equal to 50 percent.
        public let minConfidence: Float?
        /// The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the label detection operation to.
        public let notificationChannel: NotificationChannel?
        /// The video in which you want to detect labels. The video must be stored in an Amazon S3 bucket.
        public let video: Video

        public init(clientRequestToken: String? = nil, jobTag: String? = nil, minConfidence: Float? = nil, notificationChannel: NotificationChannel? = nil, video: Video) {
            self.clientRequestToken = clientRequestToken
            self.jobTag = jobTag
            self.minConfidence = minConfidence
            self.notificationChannel = notificationChannel
            self.video = video
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.jobTag, name: "jobTag", parent: name, max: 256)
            try self.validate(self.jobTag, name: "jobTag", parent: name, min: 1)
            try self.validate(self.jobTag, name: "jobTag", parent: name, pattern: "[a-zA-Z0-9_.\\-:]+")
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, max: 100)
            try self.validate(self.minConfidence, name: "minConfidence", parent: name, min: 0)
            try self.notificationChannel?.validate(name: "\(name).notificationChannel")
            try self.video.validate(name: "\(name).video")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case jobTag = "JobTag"
            case minConfidence = "MinConfidence"
            case notificationChannel = "NotificationChannel"
            case video = "Video"
        }
    }

    public struct StartLabelDetectionResponse: AWSDecodableShape {
        /// The identifier for the label detection job. Use JobId to identify the job in a subsequent call to GetLabelDetection.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartPersonTrackingRequest: AWSEncodableShape {
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartPersonTracking requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once.
        public let clientRequestToken: String?
        /// An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use JobTag to group related jobs and identify them in the completion notification.
        public let jobTag: String?
        /// The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the people detection operation to.
        public let notificationChannel: NotificationChannel?
        /// The video in which you want to detect people. The video must be stored in an Amazon S3 bucket.
        public let video: Video

        public init(clientRequestToken: String? = nil, jobTag: String? = nil, notificationChannel: NotificationChannel? = nil, video: Video) {
            self.clientRequestToken = clientRequestToken
            self.jobTag = jobTag
            self.notificationChannel = notificationChannel
            self.video = video
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.validate(self.jobTag, name: "jobTag", parent: name, max: 256)
            try self.validate(self.jobTag, name: "jobTag", parent: name, min: 1)
            try self.validate(self.jobTag, name: "jobTag", parent: name, pattern: "[a-zA-Z0-9_.\\-:]+")
            try self.notificationChannel?.validate(name: "\(name).notificationChannel")
            try self.video.validate(name: "\(name).video")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case jobTag = "JobTag"
            case notificationChannel = "NotificationChannel"
            case video = "Video"
        }
    }

    public struct StartPersonTrackingResponse: AWSDecodableShape {
        /// The identifier for the person detection job. Use JobId to identify the job in a subsequent call to GetPersonTracking.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartProjectVersionRequest: AWSEncodableShape {
        /// The minimum number of inference units to use. A single inference unit represents 1 hour of processing and can support up to 5 Transaction Pers Second (TPS). Use a higher number to increase the TPS throughput of your model. You are charged for the number of inference units that you use.
        public let minInferenceUnits: Int
        /// The Amazon Resource Name(ARN) of the model version that you want to start.
        public let projectVersionArn: String

        public init(minInferenceUnits: Int, projectVersionArn: String) {
            self.minInferenceUnits = minInferenceUnits
            self.projectVersionArn = projectVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.minInferenceUnits, name: "minInferenceUnits", parent: name, min: 1)
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, max: 2048)
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, min: 20)
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, pattern: "(^arn:[a-z\\d-]+:rekognition:[a-z\\d-]+:\\d{12}:project\\/[a-zA-Z0-9_.\\-]{1,255}\\/version\\/[a-zA-Z0-9_.\\-]{1,255}\\/[0-9]+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case minInferenceUnits = "MinInferenceUnits"
            case projectVersionArn = "ProjectVersionArn"
        }
    }

    public struct StartProjectVersionResponse: AWSDecodableShape {
        /// The current running status of the model.
        public let status: ProjectVersionStatus?

        public init(status: ProjectVersionStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct StartSegmentDetectionFilters: AWSEncodableShape {
        /// Filters that are specific to shot detections.
        public let shotFilter: StartShotDetectionFilter?
        /// Filters that are specific to technical cues.
        public let technicalCueFilter: StartTechnicalCueDetectionFilter?

        public init(shotFilter: StartShotDetectionFilter? = nil, technicalCueFilter: StartTechnicalCueDetectionFilter? = nil) {
            self.shotFilter = shotFilter
            self.technicalCueFilter = technicalCueFilter
        }

        public func validate(name: String) throws {
            try self.shotFilter?.validate(name: "\(name).shotFilter")
            try self.technicalCueFilter?.validate(name: "\(name).technicalCueFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case shotFilter = "ShotFilter"
            case technicalCueFilter = "TechnicalCueFilter"
        }
    }

    public struct StartSegmentDetectionRequest: AWSEncodableShape {
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartSegmentDetection requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once.
        public let clientRequestToken: String?
        /// Filters for technical cue or shot detection.
        public let filters: StartSegmentDetectionFilters?
        /// An identifier you specify that's returned in the completion notification that's published to your Amazon Simple Notification Service topic. For example, you can use JobTag to group related jobs and identify them in the completion notification.
        public let jobTag: String?
        /// The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the segment detection operation.
        public let notificationChannel: NotificationChannel?
        /// An array of segment types to detect in the video. Valid values are TECHNICAL_CUE and SHOT.
        public let segmentTypes: [SegmentType]
        public let video: Video

        public init(clientRequestToken: String? = nil, filters: StartSegmentDetectionFilters? = nil, jobTag: String? = nil, notificationChannel: NotificationChannel? = nil, segmentTypes: [SegmentType], video: Video) {
            self.clientRequestToken = clientRequestToken
            self.filters = filters
            self.jobTag = jobTag
            self.notificationChannel = notificationChannel
            self.segmentTypes = segmentTypes
            self.video = video
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.jobTag, name: "jobTag", parent: name, max: 256)
            try self.validate(self.jobTag, name: "jobTag", parent: name, min: 1)
            try self.validate(self.jobTag, name: "jobTag", parent: name, pattern: "[a-zA-Z0-9_.\\-:]+")
            try self.notificationChannel?.validate(name: "\(name).notificationChannel")
            try self.validate(self.segmentTypes, name: "segmentTypes", parent: name, min: 1)
            try self.video.validate(name: "\(name).video")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case filters = "Filters"
            case jobTag = "JobTag"
            case notificationChannel = "NotificationChannel"
            case segmentTypes = "SegmentTypes"
            case video = "Video"
        }
    }

    public struct StartSegmentDetectionResponse: AWSDecodableShape {
        /// Unique identifier for the segment detection job. The JobId is returned from StartSegmentDetection.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartShotDetectionFilter: AWSEncodableShape {
        /// Specifies the minimum confidence that Amazon Rekognition Video must have in order to return a detected segment. Confidence represents how certain Amazon Rekognition is that a segment is correctly identified. 0 is the lowest confidence. 100 is the highest confidence. Amazon Rekognition Video doesn't return any segments with a confidence level lower than this specified value. If you don't specify MinSegmentConfidence, the GetSegmentDetection returns segments with confidence values greater than or equal to 50 percent.
        public let minSegmentConfidence: Float?

        public init(minSegmentConfidence: Float? = nil) {
            self.minSegmentConfidence = minSegmentConfidence
        }

        public func validate(name: String) throws {
            try self.validate(self.minSegmentConfidence, name: "minSegmentConfidence", parent: name, max: 100)
            try self.validate(self.minSegmentConfidence, name: "minSegmentConfidence", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case minSegmentConfidence = "MinSegmentConfidence"
        }
    }

    public struct StartStreamProcessorRequest: AWSEncodableShape {
        /// The name of the stream processor to start processing.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartStreamProcessorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartTechnicalCueDetectionFilter: AWSEncodableShape {
        /// Specifies the minimum confidence that Amazon Rekognition Video must have in order to return a detected segment. Confidence represents how certain Amazon Rekognition is that a segment is correctly identified. 0 is the lowest confidence. 100 is the highest confidence. Amazon Rekognition Video doesn't return any segments with a confidence level lower than this specified value. If you don't specify MinSegmentConfidence, GetSegmentDetection returns segments with confidence values greater than or equal to 50 percent.
        public let minSegmentConfidence: Float?

        public init(minSegmentConfidence: Float? = nil) {
            self.minSegmentConfidence = minSegmentConfidence
        }

        public func validate(name: String) throws {
            try self.validate(self.minSegmentConfidence, name: "minSegmentConfidence", parent: name, max: 100)
            try self.validate(self.minSegmentConfidence, name: "minSegmentConfidence", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case minSegmentConfidence = "MinSegmentConfidence"
        }
    }

    public struct StartTextDetectionFilters: AWSEncodableShape {
        /// Filter focusing on a certain area of the frame. Uses a BoundingBox object to set the region of the screen.
        public let regionsOfInterest: [RegionOfInterest]?
        /// Filters focusing on qualities of the text, such as confidence or size.
        public let wordFilter: DetectionFilter?

        public init(regionsOfInterest: [RegionOfInterest]? = nil, wordFilter: DetectionFilter? = nil) {
            self.regionsOfInterest = regionsOfInterest
            self.wordFilter = wordFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.regionsOfInterest, name: "regionsOfInterest", parent: name, max: 10)
            try self.validate(self.regionsOfInterest, name: "regionsOfInterest", parent: name, min: 0)
            try self.wordFilter?.validate(name: "\(name).wordFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case regionsOfInterest = "RegionsOfInterest"
            case wordFilter = "WordFilter"
        }
    }

    public struct StartTextDetectionRequest: AWSEncodableShape {
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartTextDetection requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidentaly started more than once.
        public let clientRequestToken: String?
        /// Optional parameters that let you set criteria the text must meet to be included in your response.
        public let filters: StartTextDetectionFilters?
        /// An identifier returned in the completion status published by your Amazon Simple Notification Service topic. For example, you can use JobTag to group related jobs and identify them in the completion notification.
        public let jobTag: String?
        public let notificationChannel: NotificationChannel?
        public let video: Video

        public init(clientRequestToken: String? = nil, filters: StartTextDetectionFilters? = nil, jobTag: String? = nil, notificationChannel: NotificationChannel? = nil, video: Video) {
            self.clientRequestToken = clientRequestToken
            self.filters = filters
            self.jobTag = jobTag
            self.notificationChannel = notificationChannel
            self.video = video
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.jobTag, name: "jobTag", parent: name, max: 256)
            try self.validate(self.jobTag, name: "jobTag", parent: name, min: 1)
            try self.validate(self.jobTag, name: "jobTag", parent: name, pattern: "[a-zA-Z0-9_.\\-:]+")
            try self.notificationChannel?.validate(name: "\(name).notificationChannel")
            try self.video.validate(name: "\(name).video")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case filters = "Filters"
            case jobTag = "JobTag"
            case notificationChannel = "NotificationChannel"
            case video = "Video"
        }
    }

    public struct StartTextDetectionResponse: AWSDecodableShape {
        /// Identifier for the text detection job. Use JobId to identify the job in a subsequent call to GetTextDetection.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StopProjectVersionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the model version that you want to delete. This operation requires permissions to perform the rekognition:StopProjectVersion action.
        public let projectVersionArn: String

        public init(projectVersionArn: String) {
            self.projectVersionArn = projectVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, max: 2048)
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, min: 20)
            try self.validate(self.projectVersionArn, name: "projectVersionArn", parent: name, pattern: "(^arn:[a-z\\d-]+:rekognition:[a-z\\d-]+:\\d{12}:project\\/[a-zA-Z0-9_.\\-]{1,255}\\/version\\/[a-zA-Z0-9_.\\-]{1,255}\\/[0-9]+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case projectVersionArn = "ProjectVersionArn"
        }
    }

    public struct StopProjectVersionResponse: AWSDecodableShape {
        /// The current status of the stop operation.
        public let status: ProjectVersionStatus?

        public init(status: ProjectVersionStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct StopStreamProcessorRequest: AWSEncodableShape {
        /// The name of a stream processor created by CreateStreamProcessor.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[a-zA-Z0-9_.\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StopStreamProcessorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StreamProcessor: AWSDecodableShape {
        /// Name of the Amazon Rekognition stream processor.
        public let name: String?
        /// Current status of the Amazon Rekognition stream processor.
        public let status: StreamProcessorStatus?

        public init(name: String? = nil, status: StreamProcessorStatus? = nil) {
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case status = "Status"
        }
    }

    public struct StreamProcessorInput: AWSEncodableShape & AWSDecodableShape {
        /// The Kinesis video stream input stream for the source streaming video.
        public let kinesisVideoStream: KinesisVideoStream?

        public init(kinesisVideoStream: KinesisVideoStream? = nil) {
            self.kinesisVideoStream = kinesisVideoStream
        }

        public func validate(name: String) throws {
            try self.kinesisVideoStream?.validate(name: "\(name).kinesisVideoStream")
        }

        private enum CodingKeys: String, CodingKey {
            case kinesisVideoStream = "KinesisVideoStream"
        }
    }

    public struct StreamProcessorOutput: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Kinesis Data Streams stream to which the Amazon Rekognition stream processor streams the analysis results.
        public let kinesisDataStream: KinesisDataStream?

        public init(kinesisDataStream: KinesisDataStream? = nil) {
            self.kinesisDataStream = kinesisDataStream
        }

        public func validate(name: String) throws {
            try self.kinesisDataStream?.validate(name: "\(name).kinesisDataStream")
        }

        private enum CodingKeys: String, CodingKey {
            case kinesisDataStream = "KinesisDataStream"
        }
    }

    public struct StreamProcessorSettings: AWSEncodableShape & AWSDecodableShape {
        /// Face search settings to use on a streaming video.
        public let faceSearch: FaceSearchSettings?

        public init(faceSearch: FaceSearchSettings? = nil) {
            self.faceSearch = faceSearch
        }

        public func validate(name: String) throws {
            try self.faceSearch?.validate(name: "\(name).faceSearch")
        }

        private enum CodingKeys: String, CodingKey {
            case faceSearch = "FaceSearch"
        }
    }

    public struct Summary: AWSDecodableShape {
        public let s3Object: S3Object?

        public init(s3Object: S3Object? = nil) {
            self.s3Object = s3Object
        }

        private enum CodingKeys: String, CodingKey {
            case s3Object = "S3Object"
        }
    }

    public struct Sunglasses: AWSDecodableShape {
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face is wearing sunglasses or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        ///  Amazon Resource Name (ARN) of the model, collection, or stream processor that you want to assign the tags to.
        public let resourceArn: String
        ///  The key-value tags to assign to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TechnicalCueSegment: AWSDecodableShape {
        /// The confidence that Amazon Rekognition Video has in the accuracy of the detected segment.
        public let confidence: Float?
        /// The type of the technical cue.
        public let type: TechnicalCueType?

        public init(confidence: Float? = nil, type: TechnicalCueType? = nil) {
            self.confidence = confidence
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case type = "Type"
        }
    }

    public struct TestingData: AWSEncodableShape & AWSDecodableShape {
        /// The assets used for testing.
        public let assets: [Asset]?
        /// If specified, Amazon Rekognition Custom Labels creates a testing dataset with an 80/20 split of the training dataset.
        public let autoCreate: Bool?

        public init(assets: [Asset]? = nil, autoCreate: Bool? = nil) {
            self.assets = assets
            self.autoCreate = autoCreate
        }

        public func validate(name: String) throws {
            try self.assets?.forEach {
                try $0.validate(name: "\(name).assets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "Assets"
            case autoCreate = "AutoCreate"
        }
    }

    public struct TestingDataResult: AWSDecodableShape {
        /// The testing dataset that was supplied for training.
        public let input: TestingData?
        /// The subset of the dataset that was actually tested. Some images (assets) might not be tested due to file formatting and other issues.
        public let output: TestingData?
        /// The location of the data validation manifest. The data validation manifest is created for the test dataset during model training.
        public let validation: ValidationData?

        public init(input: TestingData? = nil, output: TestingData? = nil, validation: ValidationData? = nil) {
            self.input = input
            self.output = output
            self.validation = validation
        }

        private enum CodingKeys: String, CodingKey {
            case input = "Input"
            case output = "Output"
            case validation = "Validation"
        }
    }

    public struct TextDetection: AWSDecodableShape {
        /// The confidence that Amazon Rekognition has in the accuracy of the detected text and the accuracy of the geometry points around the detected text.
        public let confidence: Float?
        /// The word or line of text recognized by Amazon Rekognition.
        public let detectedText: String?
        /// The location of the detected text on the image. Includes an axis aligned coarse bounding box surrounding the text and a finer grain polygon for more accurate spatial information.
        public let geometry: Geometry?
        /// The identifier for the detected text. The identifier is only unique for a single call to DetectText.
        public let id: Int?
        /// The Parent identifier for the detected text identified by the value of ID. If the type of detected text is LINE, the value of ParentId is Null.
        public let parentId: Int?
        /// The type of text that was detected.
        public let type: TextTypes?

        public init(confidence: Float? = nil, detectedText: String? = nil, geometry: Geometry? = nil, id: Int? = nil, parentId: Int? = nil, type: TextTypes? = nil) {
            self.confidence = confidence
            self.detectedText = detectedText
            self.geometry = geometry
            self.id = id
            self.parentId = parentId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case detectedText = "DetectedText"
            case geometry = "Geometry"
            case id = "Id"
            case parentId = "ParentId"
            case type = "Type"
        }
    }

    public struct TextDetectionResult: AWSDecodableShape {
        /// Details about text detected in a video.
        public let textDetection: TextDetection?
        /// The time, in milliseconds from the start of the video, that the text was detected.
        public let timestamp: Int64?

        public init(textDetection: TextDetection? = nil, timestamp: Int64? = nil) {
            self.textDetection = textDetection
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case textDetection = "TextDetection"
            case timestamp = "Timestamp"
        }
    }

    public struct TrainingData: AWSEncodableShape & AWSDecodableShape {
        /// A Sagemaker GroundTruth manifest file that contains the training images (assets).
        public let assets: [Asset]?

        public init(assets: [Asset]? = nil) {
            self.assets = assets
        }

        public func validate(name: String) throws {
            try self.assets?.forEach {
                try $0.validate(name: "\(name).assets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "Assets"
        }
    }

    public struct TrainingDataResult: AWSDecodableShape {
        /// The training assets that you supplied for training.
        public let input: TrainingData?
        /// The images (assets) that were actually trained by Amazon Rekognition Custom Labels.
        public let output: TrainingData?
        /// The location of the data validation manifest. The data validation manifest is created for the training dataset during model training.
        public let validation: ValidationData?

        public init(input: TrainingData? = nil, output: TrainingData? = nil, validation: ValidationData? = nil) {
            self.input = input
            self.output = output
            self.validation = validation
        }

        private enum CodingKeys: String, CodingKey {
            case input = "Input"
            case output = "Output"
            case validation = "Validation"
        }
    }

    public struct UnindexedFace: AWSDecodableShape {
        /// The structure that contains attributes of a face that IndexFacesdetected, but didn't index.
        public let faceDetail: FaceDetail?
        /// An array of reasons that specify why a face wasn't indexed.    EXTREME_POSE - The face is at a pose that can't be detected. For example, the head is turned too far away from the camera.   EXCEEDS_MAX_FACES - The number of faces detected is already higher than that specified by the MaxFaces input parameter for IndexFaces.   LOW_BRIGHTNESS - The image is too dark.   LOW_SHARPNESS - The image is too blurry.   LOW_CONFIDENCE - The face was detected with a low confidence.   SMALL_BOUNDING_BOX - The bounding box around the face is too small.
        public let reasons: [Reason]?

        public init(faceDetail: FaceDetail? = nil, reasons: [Reason]? = nil) {
            self.faceDetail = faceDetail
            self.reasons = reasons
        }

        private enum CodingKeys: String, CodingKey {
            case faceDetail = "FaceDetail"
            case reasons = "Reasons"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        ///  Amazon Resource Name (ARN) of the model, collection, or stream processor that you want to remove the tags from.
        public let resourceArn: String
        ///  A list of the tags that you want to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ValidationData: AWSDecodableShape {
        /// The assets that comprise the validation data.
        public let assets: [Asset]?

        public init(assets: [Asset]? = nil) {
            self.assets = assets
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "Assets"
        }
    }

    public struct Video: AWSEncodableShape {
        /// The Amazon S3 bucket name and file name for the video.
        public let s3Object: S3Object?

        public init(s3Object: S3Object? = nil) {
            self.s3Object = s3Object
        }

        public func validate(name: String) throws {
            try self.s3Object?.validate(name: "\(name).s3Object")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Object = "S3Object"
        }
    }

    public struct VideoMetadata: AWSDecodableShape {
        /// Type of compression used in the analyzed video.
        public let codec: String?
        /// Length of the video in milliseconds.
        public let durationMillis: Int64?
        /// Format of the analyzed video. Possible values are MP4, MOV and AVI.
        public let format: String?
        /// Vertical pixel dimension of the video.
        public let frameHeight: Int64?
        /// Number of frames per second in the video.
        public let frameRate: Float?
        /// Horizontal pixel dimension of the video.
        public let frameWidth: Int64?

        public init(codec: String? = nil, durationMillis: Int64? = nil, format: String? = nil, frameHeight: Int64? = nil, frameRate: Float? = nil, frameWidth: Int64? = nil) {
            self.codec = codec
            self.durationMillis = durationMillis
            self.format = format
            self.frameHeight = frameHeight
            self.frameRate = frameRate
            self.frameWidth = frameWidth
        }

        private enum CodingKeys: String, CodingKey {
            case codec = "Codec"
            case durationMillis = "DurationMillis"
            case format = "Format"
            case frameHeight = "FrameHeight"
            case frameRate = "FrameRate"
            case frameWidth = "FrameWidth"
        }
    }
}
