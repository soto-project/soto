//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ConfigService {
    // MARK: Enums

    public enum AggregateConformancePackComplianceSummaryGroupKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "ACCOUNT_ID"
        case awsRegion = "AWS_REGION"
        public var description: String { return self.rawValue }
    }

    public enum AggregatedSourceStatusType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case outdated = "OUTDATED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum AggregatedSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case account = "ACCOUNT"
        case organization = "ORGANIZATION"
        public var description: String { return self.rawValue }
    }

    public enum AggregatorFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case include = "INCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum ChronologicalOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case forward = "Forward"
        case reverse = "Reverse"
        public var description: String { return self.rawValue }
    }

    public enum ComplianceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case compliant = "COMPLIANT"
        case insufficientData = "INSUFFICIENT_DATA"
        case nonCompliant = "NON_COMPLIANT"
        case notApplicable = "NOT_APPLICABLE"
        public var description: String { return self.rawValue }
    }

    public enum ConfigRuleComplianceSummaryGroupKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "ACCOUNT_ID"
        case awsRegion = "AWS_REGION"
        public var description: String { return self.rawValue }
    }

    public enum ConfigRuleState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        case deletingResults = "DELETING_RESULTS"
        case evaluating = "EVALUATING"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ok = "OK"
        case resourceDeleted = "ResourceDeleted"
        case resourceDeletedNotRecorded = "ResourceDeletedNotRecorded"
        case resourceDiscovered = "ResourceDiscovered"
        case resourceNotRecorded = "ResourceNotRecorded"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationRecorderFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case recordingScope = "recordingScope"
        public var description: String { return self.rawValue }
    }

    public enum ConformancePackComplianceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case compliant = "COMPLIANT"
        case insufficientData = "INSUFFICIENT_DATA"
        case nonCompliant = "NON_COMPLIANT"
        public var description: String { return self.rawValue }
    }

    public enum ConformancePackState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createComplete = "CREATE_COMPLETE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum DeliveryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failure = "Failure"
        case notApplicable = "Not_Applicable"
        case success = "Success"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case detective = "DETECTIVE"
        case proactive = "PROACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum EventSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsConfig = "aws.config"
        public var description: String { return self.rawValue }
    }

    public enum MaximumExecutionFrequency: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oneHour = "One_Hour"
        case sixHours = "Six_Hours"
        case threeHours = "Three_Hours"
        case twelveHours = "Twelve_Hours"
        case twentyFourHours = "TwentyFour_Hours"
        public var description: String { return self.rawValue }
    }

    public enum MemberAccountRuleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createSuccessful = "CREATE_SUCCESSFUL"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleteSuccessful = "DELETE_SUCCESSFUL"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum MessageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configurationItemChangeNotification = "ConfigurationItemChangeNotification"
        case configurationSnapshotDeliveryCompleted = "ConfigurationSnapshotDeliveryCompleted"
        case oversizedConfigurationItemChangeNotification = "OversizedConfigurationItemChangeNotification"
        case scheduledNotification = "ScheduledNotification"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationConfigRuleTriggerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configurationItemChangeNotification = "ConfigurationItemChangeNotification"
        case oversizedConfigurationItemChangeNotifcation = "OversizedConfigurationItemChangeNotification"
        case scheduledNotification = "ScheduledNotification"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationConfigRuleTriggerTypeNoSN: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configurationItemChangeNotification = "ConfigurationItemChangeNotification"
        case oversizedConfigurationItemChangeNotifcation = "OversizedConfigurationItemChangeNotification"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationResourceDetailedStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createSuccessful = "CREATE_SUCCESSFUL"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleteSuccessful = "DELETE_SUCCESSFUL"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationResourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createSuccessful = "CREATE_SUCCESSFUL"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleteSuccessful = "DELETE_SUCCESSFUL"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationRuleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createSuccessful = "CREATE_SUCCESSFUL"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleteSuccessful = "DELETE_SUCCESSFUL"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum Owner: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aws = "AWS"
        case customLambda = "CUSTOM_LAMBDA"
        case customPolicy = "CUSTOM_POLICY"
        public var description: String { return self.rawValue }
    }

    public enum RecorderStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failure = "Failure"
        case notApplicable = "NotApplicable"
        case pending = "Pending"
        case success = "Success"
        public var description: String { return self.rawValue }
    }

    public enum RecordingFrequency: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case continuous = "CONTINUOUS"
        case daily = "DAILY"
        public var description: String { return self.rawValue }
    }

    public enum RecordingScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `internal` = "INTERNAL"
        case paid = "PAID"
        public var description: String { return self.rawValue }
    }

    public enum RecordingStrategyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allSupportedResourceTypes = "ALL_SUPPORTED_RESOURCE_TYPES"
        case exclusionByResourceTypes = "EXCLUSION_BY_RESOURCE_TYPES"
        case inclusionByResourceTypes = "INCLUSION_BY_RESOURCE_TYPES"
        public var description: String { return self.rawValue }
    }

    public enum RemediationExecutionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case queued = "QUEUED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum RemediationExecutionStepState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case pending = "PENDING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum RemediationTargetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ssmDocument = "SSM_DOCUMENT"
        public var description: String { return self.rawValue }
    }

    public enum ResourceConfigurationSchemaType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cfnResourceSchema = "CFN_RESOURCE_SCHEMA"
        public var description: String { return self.rawValue }
    }

    public enum ResourceCountGroupKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "ACCOUNT_ID"
        case awsRegion = "AWS_REGION"
        case resourceType = "RESOURCE_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceEvaluationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessAnalyzerAnalyzer = "AWS::AccessAnalyzer::Analyzer"
        case accountPublicAccessBlock = "AWS::S3::AccountPublicAccessBlock"
        case acmpcaCertificateAuthority = "AWS::ACMPCA::CertificateAuthority"
        case acmpcaCertificateAuthorityActivation = "AWS::ACMPCA::CertificateAuthorityActivation"
        case alarm = "AWS::CloudWatch::Alarm"
        case amazonMQBroker = "AWS::AmazonMQ::Broker"
        case amplifyApp = "AWS::Amplify::App"
        case amplifyBranch = "AWS::Amplify::Branch"
        case api = "AWS::ApiGatewayV2::Api"
        case appConfigApplication = "AWS::AppConfig::Application"
        case appConfigConfigurationProfile = "AWS::AppConfig::ConfigurationProfile"
        case appConfigDeploymentStrategy = "AWS::AppConfig::DeploymentStrategy"
        case appConfigEnvironment = "AWS::AppConfig::Environment"
        case appConfigHostedConfigurationVersion = "AWS::AppConfig::HostedConfigurationVersion"
        case appFlowFlow = "AWS::AppFlow::Flow"
        case appIntegrationsEventIntegration = "AWS::AppIntegrations::EventIntegration"
        case appMeshGatewayRoute = "AWS::AppMesh::GatewayRoute"
        case appMeshMesh = "AWS::AppMesh::Mesh"
        case appMeshRoute = "AWS::AppMesh::Route"
        case appMeshVirtualGateway = "AWS::AppMesh::VirtualGateway"
        case appMeshVirtualNode = "AWS::AppMesh::VirtualNode"
        case appMeshVirtualRouter = "AWS::AppMesh::VirtualRouter"
        case appMeshVirtualService = "AWS::AppMesh::VirtualService"
        case appRunnerService = "AWS::AppRunner::Service"
        case appRunnerVpcConnector = "AWS::AppRunner::VpcConnector"
        case appStreamApplication = "AWS::AppStream::Application"
        case appStreamDirectoryConfig = "AWS::AppStream::DirectoryConfig"
        case appStreamFleet = "AWS::AppStream::Fleet"
        case appStreamStack = "AWS::AppStream::Stack"
        case appSyncGraphQLApi = "AWS::AppSync::GraphQLApi"
        case application = "AWS::ElasticBeanstalk::Application"
        case applicationVersion = "AWS::ElasticBeanstalk::ApplicationVersion"
        case apsRuleGroupsNamespace = "AWS::APS::RuleGroupsNamespace"
        case associationCompliance = "AWS::SSM::AssociationCompliance"
        case athenaDataCatalog = "AWS::Athena::DataCatalog"
        case athenaPreparedStatement = "AWS::Athena::PreparedStatement"
        case athenaWorkGroup = "AWS::Athena::WorkGroup"
        case auditManagerAssessment = "AWS::AuditManager::Assessment"
        case autoScalingGroup = "AWS::AutoScaling::AutoScalingGroup"
        case autoScalingWarmPool = "AWS::AutoScaling::WarmPool"
        case backupPlan = "AWS::Backup::BackupPlan"
        case backupRecoveryPoint = "AWS::Backup::RecoveryPoint"
        case backupReportPlan = "AWS::Backup::ReportPlan"
        case backupSelection = "AWS::Backup::BackupSelection"
        case backupVault = "AWS::Backup::BackupVault"
        case batchComputeEnvironment = "AWS::Batch::ComputeEnvironment"
        case batchJobQueue = "AWS::Batch::JobQueue"
        case batchSchedulingPolicy = "AWS::Batch::SchedulingPolicy"
        case bucket = "AWS::S3::Bucket"
        case budgetsBudgetsAction = "AWS::Budgets::BudgetsAction"
        case cassandraKeyspace = "AWS::Cassandra::Keyspace"
        case certificate = "AWS::ACM::Certificate"
        case cloud9EnvironmentEC2 = "AWS::Cloud9::EnvironmentEC2"
        case cloudFormationProduct = "AWS::ServiceCatalog::CloudFormationProduct"
        case cloudFormationProvisionedProduct = "AWS::ServiceCatalog::CloudFormationProvisionedProduct"
        case cloudWatchMetricStream = "AWS::CloudWatch::MetricStream"
        case cluster = "AWS::Redshift::Cluster"
        case clusterParameterGroup = "AWS::Redshift::ClusterParameterGroup"
        case clusterSecurityGroup = "AWS::Redshift::ClusterSecurityGroup"
        case clusterSnapshot = "AWS::Redshift::ClusterSnapshot"
        case clusterSubnetGroup = "AWS::Redshift::ClusterSubnetGroup"
        case codeArtifactRepository = "AWS::CodeArtifact::Repository"
        case codeBuildReportGroup = "AWS::CodeBuild::ReportGroup"
        case codeDeployApplication = "AWS::CodeDeploy::Application"
        case codeDeployDeploymentConfig = "AWS::CodeDeploy::DeploymentConfig"
        case codeDeployDeploymentGroup = "AWS::CodeDeploy::DeploymentGroup"
        case codeGuruProfilerProfilingGroup = "AWS::CodeGuruProfiler::ProfilingGroup"
        case codeGuruReviewerRepositoryAssociation = "AWS::CodeGuruReviewer::RepositoryAssociation"
        case cognitoUserPool = "AWS::Cognito::UserPool"
        case cognitoUserPoolClient = "AWS::Cognito::UserPoolClient"
        case cognitoUserPoolGroup = "AWS::Cognito::UserPoolGroup"
        case conformancePackCompliance = "AWS::Config::ConformancePackCompliance"
        case connectInstance = "AWS::Connect::Instance"
        case connectPhoneNumber = "AWS::Connect::PhoneNumber"
        case connectQuickConnect = "AWS::Connect::QuickConnect"
        case customerGateway = "AWS::EC2::CustomerGateway"
        case customerProfilesDomain = "AWS::CustomerProfiles::Domain"
        case customerProfilesObjectType = "AWS::CustomerProfiles::ObjectType"
        case dataSyncLocationEFS = "AWS::DataSync::LocationEFS"
        case dataSyncLocationFSxLustre = "AWS::DataSync::LocationFSxLustre"
        case dataSyncLocationFSxWindows = "AWS::DataSync::LocationFSxWindows"
        case dataSyncLocationHDFS = "AWS::DataSync::LocationHDFS"
        case dataSyncLocationNFS = "AWS::DataSync::LocationNFS"
        case dataSyncLocationObjectStorage = "AWS::DataSync::LocationObjectStorage"
        case dataSyncLocationS3 = "AWS::DataSync::LocationS3"
        case dataSyncLocationSMB = "AWS::DataSync::LocationSMB"
        case dataSyncTask = "AWS::DataSync::Task"
        case dbCluster = "AWS::RDS::DBCluster"
        case dbClusterSnapshot = "AWS::RDS::DBClusterSnapshot"
        case dbInstance = "AWS::RDS::DBInstance"
        case dbSecurityGroup = "AWS::RDS::DBSecurityGroup"
        case dbSnapshot = "AWS::RDS::DBSnapshot"
        case dbSubnetGroup = "AWS::RDS::DBSubnetGroup"
        case detectiveGraph = "AWS::Detective::Graph"
        case deviceFarmInstanceProfile = "AWS::DeviceFarm::InstanceProfile"
        case deviceFarmProject = "AWS::DeviceFarm::Project"
        case deviceFarmTestGridProject = "AWS::DeviceFarm::TestGridProject"
        case distribution = "AWS::CloudFront::Distribution"
        case dmsCertificate = "AWS::DMS::Certificate"
        case dmsEndpoint = "AWS::DMS::Endpoint"
        case dmsEventSubscription = "AWS::DMS::EventSubscription"
        case dmsReplicationSubnetGroup = "AWS::DMS::ReplicationSubnetGroup"
        case domain = "AWS::Elasticsearch::Domain"
        case ec2CapacityReservation = "AWS::EC2::CapacityReservation"
        case ec2CarrierGateway = "AWS::EC2::CarrierGateway"
        case ec2ClientVpnEndpoint = "AWS::EC2::ClientVpnEndpoint"
        case ec2NetworkInsightsAccessScope = "AWS::EC2::NetworkInsightsAccessScope"
        case ec2NetworkInsightsAnalysis = "AWS::EC2::NetworkInsightsAnalysis"
        case ec2NetworkInsightsPath = "AWS::EC2::NetworkInsightsPath"
        case ec2PrefixList = "AWS::EC2::PrefixList"
        case ec2SpotFleet = "AWS::EC2::SpotFleet"
        case ec2SubnetRouteTableAssociation = "AWS::EC2::SubnetRouteTableAssociation"
        case ec2TrafficMirrorFilter = "AWS::EC2::TrafficMirrorFilter"
        case ec2TrafficMirrorSession = "AWS::EC2::TrafficMirrorSession"
        case ec2TrafficMirrorTarget = "AWS::EC2::TrafficMirrorTarget"
        case ec2TransitGatewayConnect = "AWS::EC2::TransitGatewayConnect"
        case ec2TransitGatewayMulticastDomain = "AWS::EC2::TransitGatewayMulticastDomain"
        case ec2dhcpOptions = "AWS::EC2::DHCPOptions"
        case ec2ec2Fleet = "AWS::EC2::EC2Fleet"
        case ec2ipam = "AWS::EC2::IPAM"
        case ec2ipamPool = "AWS::EC2::IPAMPool"
        case ec2ipamScope = "AWS::EC2::IPAMScope"
        case ecrPublicRepository = "AWS::ECR::PublicRepository"
        case ecrPullThroughCacheRule = "AWS::ECR::PullThroughCacheRule"
        case ecrRegistryPolicy = "AWS::ECR::RegistryPolicy"
        case ecrRepository = "AWS::ECR::Repository"
        case ecsCapacityProvider = "AWS::ECS::CapacityProvider"
        case ecsCluster = "AWS::ECS::Cluster"
        case ecsService = "AWS::ECS::Service"
        case ecsTaskDefinition = "AWS::ECS::TaskDefinition"
        case ecsTaskSet = "AWS::ECS::TaskSet"
        case efsAccessPoint = "AWS::EFS::AccessPoint"
        case efsFileSystem = "AWS::EFS::FileSystem"
        case egressOnlyInternetGateway = "AWS::EC2::EgressOnlyInternetGateway"
        case eip = "AWS::EC2::EIP"
        case eksAddon = "AWS::EKS::Addon"
        case eksCluster = "AWS::EKS::Cluster"
        case eksFargateProfile = "AWS::EKS::FargateProfile"
        case eksIdentityProviderConfig = "AWS::EKS::IdentityProviderConfig"
        case emrSecurityConfiguration = "AWS::EMR::SecurityConfiguration"
        case encryptionConfig = "AWS::XRay::EncryptionConfig"
        case environment = "AWS::ElasticBeanstalk::Environment"
        case eventSchemasDiscoverer = "AWS::EventSchemas::Discoverer"
        case eventSchemasRegistry = "AWS::EventSchemas::Registry"
        case eventSchemasRegistryPolicy = "AWS::EventSchemas::RegistryPolicy"
        case eventSchemasSchema = "AWS::EventSchemas::Schema"
        case eventSubscription = "AWS::RDS::EventSubscription"
        case eventsApiDestination = "AWS::Events::ApiDestination"
        case eventsArchive = "AWS::Events::Archive"
        case eventsConnection = "AWS::Events::Connection"
        case eventsEndpoint = "AWS::Events::Endpoint"
        case eventsEventBus = "AWS::Events::EventBus"
        case eventsRule = "AWS::Events::Rule"
        case evidentlyLaunch = "AWS::Evidently::Launch"
        case evidentlyProject = "AWS::Evidently::Project"
        case fileData = "AWS::SSM::FileData"
        case fisExperimentTemplate = "AWS::FIS::ExperimentTemplate"
        case flowLog = "AWS::EC2::FlowLog"
        case forecastDataset = "AWS::Forecast::Dataset"
        case forecastDatasetGroup = "AWS::Forecast::DatasetGroup"
        case fraudDetectorEntityType = "AWS::FraudDetector::EntityType"
        case fraudDetectorLabel = "AWS::FraudDetector::Label"
        case fraudDetectorOutcome = "AWS::FraudDetector::Outcome"
        case fraudDetectorVariable = "AWS::FraudDetector::Variable"
        case function = "AWS::Lambda::Function"
        case globalAcceleratorAccelerator = "AWS::GlobalAccelerator::Accelerator"
        case globalAcceleratorEndpointGroup = "AWS::GlobalAccelerator::EndpointGroup"
        case globalAcceleratorListener = "AWS::GlobalAccelerator::Listener"
        case glueClassifier = "AWS::Glue::Classifier"
        case glueJob = "AWS::Glue::Job"
        case glueMLTransform = "AWS::Glue::MLTransform"
        case grafanaWorkspace = "AWS::Grafana::Workspace"
        case greengrassV2ComponentVersion = "AWS::GreengrassV2::ComponentVersion"
        case groundStationConfig = "AWS::GroundStation::Config"
        case groundStationDataflowEndpointGroup = "AWS::GroundStation::DataflowEndpointGroup"
        case groundStationMissionProfile = "AWS::GroundStation::MissionProfile"
        case group = "AWS::IAM::Group"
        case guardDutyDetector = "AWS::GuardDuty::Detector"
        case guardDutyFilter = "AWS::GuardDuty::Filter"
        case guardDutyIPSet = "AWS::GuardDuty::IPSet"
        case guardDutyThreatIntelSet = "AWS::GuardDuty::ThreatIntelSet"
        case healthLakeFHIRDatastore = "AWS::HealthLake::FHIRDatastore"
        case host = "AWS::EC2::Host"
        case iamInstanceProfile = "AWS::IAM::InstanceProfile"
        case iamServerCertificate = "AWS::IAM::ServerCertificate"
        case iamsamlProvider = "AWS::IAM::SAMLProvider"
        case imageBuilderContainerRecipe = "AWS::ImageBuilder::ContainerRecipe"
        case imageBuilderDistributionConfiguration = "AWS::ImageBuilder::DistributionConfiguration"
        case imageBuilderImagePipeline = "AWS::ImageBuilder::ImagePipeline"
        case imageBuilderImageRecipe = "AWS::ImageBuilder::ImageRecipe"
        case imageBuilderInfrastructureConfiguration = "AWS::ImageBuilder::InfrastructureConfiguration"
        case inspectorV2Filter = "AWS::InspectorV2::Filter"
        case instance = "AWS::EC2::Instance"
        case internetGateway = "AWS::EC2::InternetGateway"
        case ioTAccountAuditConfiguration = "AWS::IoT::AccountAuditConfiguration"
        case ioTAnalyticsChannel = "AWS::IoTAnalytics::Channel"
        case ioTAnalyticsDataset = "AWS::IoTAnalytics::Dataset"
        case ioTAnalyticsDatastore = "AWS::IoTAnalytics::Datastore"
        case ioTAnalyticsPipeline = "AWS::IoTAnalytics::Pipeline"
        case ioTAuthorizer = "AWS::IoT::Authorizer"
        case ioTCACertificate = "AWS::IoT::CACertificate"
        case ioTCustomMetric = "AWS::IoT::CustomMetric"
        case ioTDimension = "AWS::IoT::Dimension"
        case ioTEventsAlarmModel = "AWS::IoTEvents::AlarmModel"
        case ioTEventsDetectorModel = "AWS::IoTEvents::DetectorModel"
        case ioTEventsInput = "AWS::IoTEvents::Input"
        case ioTFleetMetric = "AWS::IoT::FleetMetric"
        case ioTJobTemplate = "AWS::IoT::JobTemplate"
        case ioTMitigationAction = "AWS::IoT::MitigationAction"
        case ioTPolicy = "AWS::IoT::Policy"
        case ioTProvisioningTemplate = "AWS::IoT::ProvisioningTemplate"
        case ioTRoleAlias = "AWS::IoT::RoleAlias"
        case ioTScheduledAudit = "AWS::IoT::ScheduledAudit"
        case ioTSecurityProfile = "AWS::IoT::SecurityProfile"
        case ioTSiteWiseAssetModel = "AWS::IoTSiteWise::AssetModel"
        case ioTSiteWiseDashboard = "AWS::IoTSiteWise::Dashboard"
        case ioTSiteWiseGateway = "AWS::IoTSiteWise::Gateway"
        case ioTSiteWisePortal = "AWS::IoTSiteWise::Portal"
        case ioTSiteWiseProject = "AWS::IoTSiteWise::Project"
        case ioTTwinMakerComponentType = "AWS::IoTTwinMaker::ComponentType"
        case ioTTwinMakerEntity = "AWS::IoTTwinMaker::Entity"
        case ioTTwinMakerScene = "AWS::IoTTwinMaker::Scene"
        case ioTTwinMakerSyncJob = "AWS::IoTTwinMaker::SyncJob"
        case ioTTwinMakerWorkspace = "AWS::IoTTwinMaker::Workspace"
        case ioTWirelessFuotaTask = "AWS::IoTWireless::FuotaTask"
        case ioTWirelessMulticastGroup = "AWS::IoTWireless::MulticastGroup"
        case ioTWirelessServiceProfile = "AWS::IoTWireless::ServiceProfile"
        case ipSetV2 = "AWS::WAFv2::IPSet"
        case ivsChannel = "AWS::IVS::Channel"
        case ivsPlaybackKeyPair = "AWS::IVS::PlaybackKeyPair"
        case ivsRecordingConfiguration = "AWS::IVS::RecordingConfiguration"
        case kafkaConnectConnector = "AWS::KafkaConnect::Connector"
        case kendraIndex = "AWS::Kendra::Index"
        case key = "AWS::KMS::Key"
        case kinesisAnalyticsV2Application = "AWS::KinesisAnalyticsV2::Application"
        case kinesisFirehoseDeliveryStream = "AWS::KinesisFirehose::DeliveryStream"
        case kinesisStream = "AWS::Kinesis::Stream"
        case kinesisStreamConsumer = "AWS::Kinesis::StreamConsumer"
        case kinesisVideoSignalingChannel = "AWS::KinesisVideo::SignalingChannel"
        case kinesisVideoStream = "AWS::KinesisVideo::Stream"
        case kmsAlias = "AWS::KMS::Alias"
        case lambdaCodeSigningConfig = "AWS::Lambda::CodeSigningConfig"
        case launchConfiguration = "AWS::AutoScaling::LaunchConfiguration"
        case launchTemplate = "AWS::EC2::LaunchTemplate"
        case lexBot = "AWS::Lex::Bot"
        case lexBotAlias = "AWS::Lex::BotAlias"
        case lightsailBucket = "AWS::Lightsail::Bucket"
        case lightsailCertificate = "AWS::Lightsail::Certificate"
        case lightsailDisk = "AWS::Lightsail::Disk"
        case lightsailStaticIp = "AWS::Lightsail::StaticIp"
        case listenerV2 = "AWS::ElasticLoadBalancingV2::Listener"
        case loadBalancer = "AWS::ElasticLoadBalancing::LoadBalancer"
        case loadBalancerV2 = "AWS::ElasticLoadBalancingV2::LoadBalancer"
        case logsDestination = "AWS::Logs::Destination"
        case lookoutMetricsAlert = "AWS::LookoutMetrics::Alert"
        case lookoutVisionProject = "AWS::LookoutVision::Project"
        case m2Environment = "AWS::M2::Environment"
        case managedInstanceInventory = "AWS::SSM::ManagedInstanceInventory"
        case managedRuleSetV2 = "AWS::WAFv2::ManagedRuleSet"
        case mediaConnectFlowEntitlement = "AWS::MediaConnect::FlowEntitlement"
        case mediaConnectFlowSource = "AWS::MediaConnect::FlowSource"
        case mediaConnectFlowVpcInterface = "AWS::MediaConnect::FlowVpcInterface"
        case mediaPackagePackagingConfiguration = "AWS::MediaPackage::PackagingConfiguration"
        case mediaPackagePackagingGroup = "AWS::MediaPackage::PackagingGroup"
        case mediaTailorPlaybackConfiguration = "AWS::MediaTailor::PlaybackConfiguration"
        case mskBatchScramSecret = "AWS::MSK::BatchScramSecret"
        case mskCluster = "AWS::MSK::Cluster"
        case mskConfiguration = "AWS::MSK::Configuration"
        case natGateway = "AWS::EC2::NatGateway"
        case networkAcl = "AWS::EC2::NetworkAcl"
        case networkFirewallFirewall = "AWS::NetworkFirewall::Firewall"
        case networkFirewallFirewallPolicy = "AWS::NetworkFirewall::FirewallPolicy"
        case networkFirewallRuleGroup = "AWS::NetworkFirewall::RuleGroup"
        case networkInsightsAccessScopeAnalysis = "AWS::EC2::NetworkInsightsAccessScopeAnalysis"
        case networkInterface = "AWS::EC2::NetworkInterface"
        case networkManagerConnectPeer = "AWS::NetworkManager::ConnectPeer"
        case networkManagerCustomerGatewayAssociation = "AWS::NetworkManager::CustomerGatewayAssociation"
        case networkManagerDevice = "AWS::NetworkManager::Device"
        case networkManagerGlobalNetwork = "AWS::NetworkManager::GlobalNetwork"
        case networkManagerLink = "AWS::NetworkManager::Link"
        case networkManagerLinkAssociation = "AWS::NetworkManager::LinkAssociation"
        case networkManagerSite = "AWS::NetworkManager::Site"
        case networkManagerTransitGatewayRegistration = "AWS::NetworkManager::TransitGatewayRegistration"
        case openSearchDomain = "AWS::OpenSearch::Domain"
        case panoramaPackage = "AWS::Panorama::Package"
        case patchCompliance = "AWS::SSM::PatchCompliance"
        case personalizeDataset = "AWS::Personalize::Dataset"
        case personalizeDatasetGroup = "AWS::Personalize::DatasetGroup"
        case personalizeSchema = "AWS::Personalize::Schema"
        case personalizeSolution = "AWS::Personalize::Solution"
        case pinpointApp = "AWS::Pinpoint::App"
        case pinpointApplicationSettings = "AWS::Pinpoint::ApplicationSettings"
        case pinpointCampaign = "AWS::Pinpoint::Campaign"
        case pinpointEmailChannel = "AWS::Pinpoint::EmailChannel"
        case pinpointEmailTemplate = "AWS::Pinpoint::EmailTemplate"
        case pinpointEventStream = "AWS::Pinpoint::EventStream"
        case pinpointInAppTemplate = "AWS::Pinpoint::InAppTemplate"
        case pinpointSegment = "AWS::Pinpoint::Segment"
        case pipeline = "AWS::CodePipeline::Pipeline"
        case policy = "AWS::IAM::Policy"
        case portfolio = "AWS::ServiceCatalog::Portfolio"
        case project = "AWS::CodeBuild::Project"
        case protection = "AWS::Shield::Protection"
        case qldbLedger = "AWS::QLDB::Ledger"
        case queue = "AWS::SQS::Queue"
        case quickSightDataSource = "AWS::QuickSight::DataSource"
        case quickSightTemplate = "AWS::QuickSight::Template"
        case quickSightTheme = "AWS::QuickSight::Theme"
        case rateBasedRule = "AWS::WAF::RateBasedRule"
        case rdsGlobalCluster = "AWS::RDS::GlobalCluster"
        case rdsOptionGroup = "AWS::RDS::OptionGroup"
        case redshiftEndpointAccess = "AWS::Redshift::EndpointAccess"
        case redshiftEventSubscription = "AWS::Redshift::EventSubscription"
        case redshiftScheduledAction = "AWS::Redshift::ScheduledAction"
        case regexPatternSetV2 = "AWS::WAFv2::RegexPatternSet"
        case regionalProtection = "AWS::ShieldRegional::Protection"
        case regionalRateBasedRule = "AWS::WAFRegional::RateBasedRule"
        case regionalRule = "AWS::WAFRegional::Rule"
        case regionalRuleGroup = "AWS::WAFRegional::RuleGroup"
        case regionalWebACL = "AWS::WAFRegional::WebACL"
        case registeredHAInstance = "AWS::EC2::RegisteredHAInstance"
        case resilienceHubApp = "AWS::ResilienceHub::App"
        case resilienceHubResiliencyPolicy = "AWS::ResilienceHub::ResiliencyPolicy"
        case resourceCompliance = "AWS::Config::ResourceCompliance"
        case resourceExplorer2Index = "AWS::ResourceExplorer2::Index"
        case restApi = "AWS::ApiGateway::RestApi"
        case roboMakerRobotApplication = "AWS::RoboMaker::RobotApplication"
        case roboMakerRobotApplicationVersion = "AWS::RoboMaker::RobotApplicationVersion"
        case roboMakerSimulationApplication = "AWS::RoboMaker::SimulationApplication"
        case role = "AWS::IAM::Role"
        case route53HostedZone = "AWS::Route53::HostedZone"
        case route53RecoveryControlCluster = "AWS::Route53RecoveryControl::Cluster"
        case route53RecoveryControlControlPanel = "AWS::Route53RecoveryControl::ControlPanel"
        case route53RecoveryControlRoutingControl = "AWS::Route53RecoveryControl::RoutingControl"
        case route53RecoveryControlSafetyRule = "AWS::Route53RecoveryControl::SafetyRule"
        case route53RecoveryReadinessCell = "AWS::Route53RecoveryReadiness::Cell"
        case route53RecoveryReadinessReadinessCheck = "AWS::Route53RecoveryReadiness::ReadinessCheck"
        case route53RecoveryReadinessRecoveryGroup = "AWS::Route53RecoveryReadiness::RecoveryGroup"
        case route53RecoveryReadinessResourceSet = "AWS::Route53RecoveryReadiness::ResourceSet"
        case route53ResolverFirewallDomainList = "AWS::Route53Resolver::FirewallDomainList"
        case route53ResolverFirewallRuleGroup = "AWS::Route53Resolver::FirewallRuleGroup"
        case route53ResolverFirewallRuleGroupAssociation = "AWS::Route53Resolver::FirewallRuleGroupAssociation"
        case route53ResolverResolverEndpoint = "AWS::Route53Resolver::ResolverEndpoint"
        case route53ResolverResolverQueryLoggingConfig = "AWS::Route53Resolver::ResolverQueryLoggingConfig"
        case route53ResolverResolverQueryLoggingConfigAssociation = "AWS::Route53Resolver::ResolverQueryLoggingConfigAssociation"
        case route53ResolverResolverRule = "AWS::Route53Resolver::ResolverRule"
        case route53ResolverResolverRuleAssociation = "AWS::Route53Resolver::ResolverRuleAssociation"
        case routeTable = "AWS::EC2::RouteTable"
        case rule = "AWS::WAF::Rule"
        case ruleGroup = "AWS::WAF::RuleGroup"
        case ruleGroupV2 = "AWS::WAFv2::RuleGroup"
        case rumAppMonitor = "AWS::RUM::AppMonitor"
        case s3AccessPoint = "AWS::S3::AccessPoint"
        case s3MultiRegionAccessPoint = "AWS::S3::MultiRegionAccessPoint"
        case s3StorageLens = "AWS::S3::StorageLens"
        case sageMakerAppImageConfig = "AWS::SageMaker::AppImageConfig"
        case sageMakerCodeRepository = "AWS::SageMaker::CodeRepository"
        case sageMakerDomain = "AWS::SageMaker::Domain"
        case sageMakerFeatureGroup = "AWS::SageMaker::FeatureGroup"
        case sageMakerImage = "AWS::SageMaker::Image"
        case sageMakerModel = "AWS::SageMaker::Model"
        case sageMakerNotebookInstanceLifecycleConfig = "AWS::SageMaker::NotebookInstanceLifecycleConfig"
        case sageMakerWorkteam = "AWS::SageMaker::Workteam"
        case scalingPolicy = "AWS::AutoScaling::ScalingPolicy"
        case scheduledAction = "AWS::AutoScaling::ScheduledAction"
        case secret = "AWS::SecretsManager::Secret"
        case securityGroup = "AWS::EC2::SecurityGroup"
        case serviceDiscoveryHttpNamespace = "AWS::ServiceDiscovery::HttpNamespace"
        case serviceDiscoveryInstance = "AWS::ServiceDiscovery::Instance"
        case serviceDiscoveryPublicDnsNamespace = "AWS::ServiceDiscovery::PublicDnsNamespace"
        case serviceDiscoveryService = "AWS::ServiceDiscovery::Service"
        case sesConfigurationSet = "AWS::SES::ConfigurationSet"
        case sesContactList = "AWS::SES::ContactList"
        case sesReceiptFilter = "AWS::SES::ReceiptFilter"
        case sesReceiptRuleSet = "AWS::SES::ReceiptRuleSet"
        case sesTemplate = "AWS::SES::Template"
        case signerSigningProfile = "AWS::Signer::SigningProfile"
        case ssmDocument = "AWS::SSM::Document"
        case stack = "AWS::CloudFormation::Stack"
        case stage = "AWS::ApiGateway::Stage"
        case stageV2 = "AWS::ApiGatewayV2::Stage"
        case stepFunctionsActivity = "AWS::StepFunctions::Activity"
        case stepFunctionsStateMachine = "AWS::StepFunctions::StateMachine"
        case streamingDistribution = "AWS::CloudFront::StreamingDistribution"
        case subnet = "AWS::EC2::Subnet"
        case table = "AWS::DynamoDB::Table"
        case topic = "AWS::SNS::Topic"
        case trail = "AWS::CloudTrail::Trail"
        case transferAgreement = "AWS::Transfer::Agreement"
        case transferCertificate = "AWS::Transfer::Certificate"
        case transferConnector = "AWS::Transfer::Connector"
        case transferWorkflow = "AWS::Transfer::Workflow"
        case transitGateway = "AWS::EC2::TransitGateway"
        case transitGatewayAttachment = "AWS::EC2::TransitGatewayAttachment"
        case transitGatewayRouteTable = "AWS::EC2::TransitGatewayRouteTable"
        case user = "AWS::IAM::User"
        case volume = "AWS::EC2::Volume"
        case vpc = "AWS::EC2::VPC"
        case vpcEndpoint = "AWS::EC2::VPCEndpoint"
        case vpcEndpointService = "AWS::EC2::VPCEndpointService"
        case vpcPeeringConnection = "AWS::EC2::VPCPeeringConnection"
        case vpnConnection = "AWS::EC2::VPNConnection"
        case vpnGateway = "AWS::EC2::VPNGateway"
        case webACL = "AWS::WAF::WebACL"
        case webACLV2 = "AWS::WAFv2::WebACL"
        case workSpacesConnectionAlias = "AWS::WorkSpaces::ConnectionAlias"
        case workSpacesWorkspace = "AWS::WorkSpaces::Workspace"
        public var description: String { return self.rawValue }
    }

    public enum ResourceValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case resourceId = "RESOURCE_ID"
        public var description: String { return self.rawValue }
    }

    public enum SortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case score = "SCORE"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountAggregationSource: AWSEncodableShape & AWSDecodableShape {
        /// The 12-digit account ID of the account being aggregated.
        ///
        public let accountIds: [String]
        /// If true, aggregate existing Config regions and future
        /// 			regions.
        public let allAwsRegions: Bool?
        /// The source regions being aggregated.
        public let awsRegions: [String]?

        @inlinable
        public init(accountIds: [String], allAwsRegions: Bool? = nil, awsRegions: [String]? = nil) {
            self.accountIds = accountIds
            self.allAwsRegions = allAwsRegions
            self.awsRegions = awsRegions
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.awsRegions, name: "awsRegions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case allAwsRegions = "AllAwsRegions"
            case awsRegions = "AwsRegions"
        }
    }

    public struct AggregateComplianceByConfigRule: AWSDecodableShape {
        /// The 12-digit account ID of the source account.
        public let accountId: String?
        /// The source region from where the data is aggregated.
        public let awsRegion: String?
        /// Indicates whether an Amazon Web Services resource or Config rule is
        /// 			compliant and provides the number of contributors that affect the
        /// 			compliance.
        public let compliance: Compliance?
        /// The name of the Config rule.
        public let configRuleName: String?

        @inlinable
        public init(accountId: String? = nil, awsRegion: String? = nil, compliance: Compliance? = nil, configRuleName: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.compliance = compliance
            self.configRuleName = configRuleName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case compliance = "Compliance"
            case configRuleName = "ConfigRuleName"
        }
    }

    public struct AggregateComplianceByConformancePack: AWSDecodableShape {
        /// The 12-digit Amazon Web Services account ID of the source account.
        public let accountId: String?
        /// The source Amazon Web Services Region from where the data is aggregated.
        public let awsRegion: String?
        /// The compliance status of the conformance pack.
        public let compliance: AggregateConformancePackCompliance?
        /// The name of the conformance pack.
        public let conformancePackName: String?

        @inlinable
        public init(accountId: String? = nil, awsRegion: String? = nil, compliance: AggregateConformancePackCompliance? = nil, conformancePackName: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.compliance = compliance
            self.conformancePackName = conformancePackName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case compliance = "Compliance"
            case conformancePackName = "ConformancePackName"
        }
    }

    public struct AggregateComplianceCount: AWSDecodableShape {
        /// The number of compliant and noncompliant Config
        /// 			rules.
        public let complianceSummary: ComplianceSummary?
        /// The 12-digit account ID or region based on the GroupByKey
        /// 			value.
        public let groupName: String?

        @inlinable
        public init(complianceSummary: ComplianceSummary? = nil, groupName: String? = nil) {
            self.complianceSummary = complianceSummary
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummary = "ComplianceSummary"
            case groupName = "GroupName"
        }
    }

    public struct AggregateConformancePackCompliance: AWSDecodableShape {
        /// The compliance status of the conformance pack.
        public let complianceType: ConformancePackComplianceType?
        /// The number of compliant Config Rules.
        public let compliantRuleCount: Int?
        /// The number of noncompliant Config Rules.
        public let nonCompliantRuleCount: Int?
        /// Total number of compliant rules, noncompliant rules, and the rules that do not have any applicable resources to evaluate upon resulting in insufficient data.
        public let totalRuleCount: Int?

        @inlinable
        public init(complianceType: ConformancePackComplianceType? = nil, compliantRuleCount: Int? = nil, nonCompliantRuleCount: Int? = nil, totalRuleCount: Int? = nil) {
            self.complianceType = complianceType
            self.compliantRuleCount = compliantRuleCount
            self.nonCompliantRuleCount = nonCompliantRuleCount
            self.totalRuleCount = totalRuleCount
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "ComplianceType"
            case compliantRuleCount = "CompliantRuleCount"
            case nonCompliantRuleCount = "NonCompliantRuleCount"
            case totalRuleCount = "TotalRuleCount"
        }
    }

    public struct AggregateConformancePackComplianceCount: AWSDecodableShape {
        /// Number of compliant conformance packs.
        public let compliantConformancePackCount: Int?
        /// Number of noncompliant conformance packs.
        public let nonCompliantConformancePackCount: Int?

        @inlinable
        public init(compliantConformancePackCount: Int? = nil, nonCompliantConformancePackCount: Int? = nil) {
            self.compliantConformancePackCount = compliantConformancePackCount
            self.nonCompliantConformancePackCount = nonCompliantConformancePackCount
        }

        private enum CodingKeys: String, CodingKey {
            case compliantConformancePackCount = "CompliantConformancePackCount"
            case nonCompliantConformancePackCount = "NonCompliantConformancePackCount"
        }
    }

    public struct AggregateConformancePackComplianceFilters: AWSEncodableShape {
        /// The 12-digit Amazon Web Services account ID of the source account.
        public let accountId: String?
        /// The source Amazon Web Services Region from where the data is aggregated.
        public let awsRegion: String?
        /// The compliance status of the conformance pack.
        public let complianceType: ConformancePackComplianceType?
        /// The name of the conformance pack.
        public let conformancePackName: String?

        @inlinable
        public init(accountId: String? = nil, awsRegion: String? = nil, complianceType: ConformancePackComplianceType? = nil, conformancePackName: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.conformancePackName = conformancePackName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 64)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, max: 256)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case complianceType = "ComplianceType"
            case conformancePackName = "ConformancePackName"
        }
    }

    public struct AggregateConformancePackComplianceSummary: AWSDecodableShape {
        /// Returns an AggregateConformancePackComplianceCount object.
        public let complianceSummary: AggregateConformancePackComplianceCount?
        /// Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.
        public let groupName: String?

        @inlinable
        public init(complianceSummary: AggregateConformancePackComplianceCount? = nil, groupName: String? = nil) {
            self.complianceSummary = complianceSummary
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummary = "ComplianceSummary"
            case groupName = "GroupName"
        }
    }

    public struct AggregateConformancePackComplianceSummaryFilters: AWSEncodableShape {
        /// The 12-digit Amazon Web Services account ID of the source account.
        public let accountId: String?
        /// The source Amazon Web Services Region from where the data is aggregated.
        public let awsRegion: String?

        @inlinable
        public init(accountId: String? = nil, awsRegion: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 64)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
        }
    }

    public struct AggregateEvaluationResult: AWSDecodableShape {
        /// The 12-digit account ID of the source account.
        public let accountId: String?
        /// Supplementary information about how the agrregate evaluation
        /// 			determined the compliance.
        public let annotation: String?
        /// The source region from where the data is aggregated.
        public let awsRegion: String?
        /// The resource compliance status. For the AggregationEvaluationResult data type, Config supports only the COMPLIANT and
        /// 				NON_COMPLIANT. Config does not support the
        /// 				NOT_APPLICABLE and INSUFFICIENT_DATA
        /// 			value.
        public let complianceType: ComplianceType?
        /// The time when the Config rule evaluated the Amazon Web Services
        /// 			resource.
        public let configRuleInvokedTime: Date?
        /// Uniquely identifies the evaluation result.
        public let evaluationResultIdentifier: EvaluationResultIdentifier?
        /// The time when Config recorded the aggregate evaluation
        /// 			result.
        public let resultRecordedTime: Date?

        @inlinable
        public init(accountId: String? = nil, annotation: String? = nil, awsRegion: String? = nil, complianceType: ComplianceType? = nil, configRuleInvokedTime: Date? = nil, evaluationResultIdentifier: EvaluationResultIdentifier? = nil, resultRecordedTime: Date? = nil) {
            self.accountId = accountId
            self.annotation = annotation
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case annotation = "Annotation"
            case awsRegion = "AwsRegion"
            case complianceType = "ComplianceType"
            case configRuleInvokedTime = "ConfigRuleInvokedTime"
            case evaluationResultIdentifier = "EvaluationResultIdentifier"
            case resultRecordedTime = "ResultRecordedTime"
        }
    }

    public struct AggregateResourceIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the Amazon Web Services resource.
        public let resourceId: String
        /// The name of the Amazon Web Services resource.
        public let resourceName: String?
        /// The type of the Amazon Web Services resource.
        public let resourceType: ResourceType
        /// The 12-digit account ID of the source account.
        public let sourceAccountId: String
        /// The source region where data is aggregated.
        public let sourceRegion: String

        @inlinable
        public init(resourceId: String, resourceName: String? = nil, resourceType: ResourceType, sourceAccountId: String, sourceRegion: String) {
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceAccountId = sourceAccountId
            self.sourceRegion = sourceRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.sourceAccountId, name: "sourceAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.sourceRegion, name: "sourceRegion", parent: name, max: 64)
            try self.validate(self.sourceRegion, name: "sourceRegion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
            case resourceName = "ResourceName"
            case resourceType = "ResourceType"
            case sourceAccountId = "SourceAccountId"
            case sourceRegion = "SourceRegion"
        }
    }

    public struct AggregatedSourceStatus: AWSDecodableShape {
        /// The region authorized to collect aggregated data.
        public let awsRegion: String?
        /// The error code that Config returned when the source account
        /// 			aggregation last failed.
        public let lastErrorCode: String?
        /// The message indicating that the source account aggregation
        /// 			failed due to an error.
        public let lastErrorMessage: String?
        /// Filters the last updated status type.   Valid value FAILED indicates errors while moving
        /// 					data.   Valid value SUCCEEDED indicates the data was
        /// 					successfully moved.   Valid value OUTDATED indicates the data is not the most
        /// 					recent.
        public let lastUpdateStatus: AggregatedSourceStatusType?
        /// The time of the last update.
        public let lastUpdateTime: Date?
        /// The source account ID or an organization.
        public let sourceId: String?
        /// The source account or an organization.
        public let sourceType: AggregatedSourceType?

        @inlinable
        public init(awsRegion: String? = nil, lastErrorCode: String? = nil, lastErrorMessage: String? = nil, lastUpdateStatus: AggregatedSourceStatusType? = nil, lastUpdateTime: Date? = nil, sourceId: String? = nil, sourceType: AggregatedSourceType? = nil) {
            self.awsRegion = awsRegion
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastUpdateStatus = lastUpdateStatus
            self.lastUpdateTime = lastUpdateTime
            self.sourceId = sourceId
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case awsRegion = "AwsRegion"
            case lastErrorCode = "LastErrorCode"
            case lastErrorMessage = "LastErrorMessage"
            case lastUpdateStatus = "LastUpdateStatus"
            case lastUpdateTime = "LastUpdateTime"
            case sourceId = "SourceId"
            case sourceType = "SourceType"
        }
    }

    public struct AggregationAuthorization: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the aggregation
        /// 			object.
        public let aggregationAuthorizationArn: String?
        /// The 12-digit account ID of the account authorized to aggregate
        /// 			data.
        public let authorizedAccountId: String?
        /// The region authorized to collect aggregated data.
        public let authorizedAwsRegion: String?
        /// The time stamp when the aggregation authorization was
        /// 			created.
        public let creationTime: Date?

        @inlinable
        public init(aggregationAuthorizationArn: String? = nil, authorizedAccountId: String? = nil, authorizedAwsRegion: String? = nil, creationTime: Date? = nil) {
            self.aggregationAuthorizationArn = aggregationAuthorizationArn
            self.authorizedAccountId = authorizedAccountId
            self.authorizedAwsRegion = authorizedAwsRegion
            self.creationTime = creationTime
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationAuthorizationArn = "AggregationAuthorizationArn"
            case authorizedAccountId = "AuthorizedAccountId"
            case authorizedAwsRegion = "AuthorizedAwsRegion"
            case creationTime = "CreationTime"
        }
    }

    public struct AggregatorFilterResourceType: AWSEncodableShape & AWSDecodableShape {
        /// The type of resource type filter to apply. INCLUDE specifies that the list of resource types in the Value field will be aggregated and no other resource types will be filtered.
        public let type: AggregatorFilterType?
        /// Comma-separate list of resource types to filter your aggregated configuration recorders.
        public let value: [String]?

        @inlinable
        public init(type: AggregatorFilterType? = nil, value: [String]? = nil) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.value?.forEach {
                try validate($0, name: "value[]", parent: name, max: 256)
                try validate($0, name: "value[]", parent: name, min: 1)
                try validate($0, name: "value[]", parent: name, pattern: "^[a-zA-Z0-9]{2,64}::[a-zA-Z0-9]{2,64}::[a-zA-Z0-9]{2,64}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct AggregatorFilterServicePrincipal: AWSEncodableShape & AWSDecodableShape {
        /// The type of service principal filter to apply. INCLUDE specifies that the list of service principals in the Value field will be aggregated and no other service principals will be filtered.
        public let type: AggregatorFilterType?
        /// Comma-separated list of service principals for the linked Amazon Web Services services to filter your aggregated service-linked configuration recorders.
        public let value: [String]?

        @inlinable
        public init(type: AggregatorFilterType? = nil, value: [String]? = nil) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.value?.forEach {
                try validate($0, name: "value[]", parent: name, max: 128)
                try validate($0, name: "value[]", parent: name, min: 1)
                try validate($0, name: "value[]", parent: name, pattern: "^[\\w+=,.@-]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct AggregatorFilters: AWSEncodableShape & AWSDecodableShape {
        /// An object to filter the configuration recorders based on the resource types in scope for recording.
        public let resourceType: AggregatorFilterResourceType?
        /// An object to filter service-linked configuration recorders in an aggregator based on the linked Amazon Web Services service.
        public let servicePrincipal: AggregatorFilterServicePrincipal?

        @inlinable
        public init(resourceType: AggregatorFilterResourceType? = nil, servicePrincipal: AggregatorFilterServicePrincipal? = nil) {
            self.resourceType = resourceType
            self.servicePrincipal = servicePrincipal
        }

        public func validate(name: String) throws {
            try self.resourceType?.validate(name: "\(name).resourceType")
            try self.servicePrincipal?.validate(name: "\(name).servicePrincipal")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "ResourceType"
            case servicePrincipal = "ServicePrincipal"
        }
    }

    public struct AssociateResourceTypesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the specified configuration recorder.
        public let configurationRecorderArn: String
        /// The list of resource types you want to add to the recording group of the specified configuration recorder.
        public let resourceTypes: [ResourceType]

        @inlinable
        public init(configurationRecorderArn: String, resourceTypes: [ResourceType]) {
            self.configurationRecorderArn = configurationRecorderArn
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationRecorderArn, name: "configurationRecorderArn", parent: name, max: 1000)
            try self.validate(self.configurationRecorderArn, name: "configurationRecorderArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorderArn = "ConfigurationRecorderArn"
            case resourceTypes = "ResourceTypes"
        }
    }

    public struct AssociateResourceTypesResponse: AWSDecodableShape {
        public let configurationRecorder: ConfigurationRecorder

        @inlinable
        public init(configurationRecorder: ConfigurationRecorder) {
            self.configurationRecorder = configurationRecorder
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorder = "ConfigurationRecorder"
        }
    }

    public struct BaseConfigurationItem: AWSDecodableShape {
        /// The 12-digit Amazon Web Services account ID associated with the resource.
        public let accountId: String?
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The Availability Zone associated with the resource.
        public let availabilityZone: String?
        /// The region where the resource resides.
        public let awsRegion: String?
        /// The description of the resource configuration.
        public let configuration: String?
        /// The time when the recording of configuration changes was initiated for the resource.
        public let configurationItemCaptureTime: Date?
        /// The time when configuration changes for the resource were delivered.  This field is optional and is not guaranteed to be present in a configuration item  (CI). If you are using daily recording,
        /// 			this field will be populated. However, if you are using continuous recording,
        /// 			this field will be omitted since the delivery time is instantaneous as the CI is available right away. For more information on daily recording and continuous recording, see Recording Frequency in the Config
        /// 					Developer Guide.
        public let configurationItemDeliveryTime: Date?
        /// The configuration item status. Valid values include:   OK  The resource configuration has been updated.   ResourceDiscovered  The resource was newly discovered.   ResourceNotRecorded  The resource was discovered, but its configuration was not recorded since the recorder doesn't record resources of this type.   ResourceDeleted  The resource was deleted   ResourceDeletedNotRecorded  The resource was deleted, but its configuration was not recorded since the recorder doesn't record resources of this type.
        public let configurationItemStatus: ConfigurationItemStatus?
        /// An identifier that indicates the ordering of the configuration
        /// 			items of a resource.
        public let configurationStateId: String?
        /// The recording frequency that Config uses to record configuration changes for the resource.
        public let recordingFrequency: RecordingFrequency?
        /// The time stamp when the resource was created.
        public let resourceCreationTime: Date?
        /// The ID of the resource (for example., sg-xxxxxx).
        public let resourceId: String?
        /// The custom name of the resource, if available.
        public let resourceName: String?
        /// The type of Amazon Web Services resource.
        public let resourceType: ResourceType?
        /// Configuration attributes that Config returns for certain
        /// 			resource types to supplement the information returned for the
        /// 			configuration parameter.
        public let supplementaryConfiguration: [String: String]?
        /// The version number of the resource configuration.
        public let version: String?

        @inlinable
        public init(accountId: String? = nil, arn: String? = nil, availabilityZone: String? = nil, awsRegion: String? = nil, configuration: String? = nil, configurationItemCaptureTime: Date? = nil, configurationItemDeliveryTime: Date? = nil, configurationItemStatus: ConfigurationItemStatus? = nil, configurationStateId: String? = nil, recordingFrequency: RecordingFrequency? = nil, resourceCreationTime: Date? = nil, resourceId: String? = nil, resourceName: String? = nil, resourceType: ResourceType? = nil, supplementaryConfiguration: [String: String]? = nil, version: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.awsRegion = awsRegion
            self.configuration = configuration
            self.configurationItemCaptureTime = configurationItemCaptureTime
            self.configurationItemDeliveryTime = configurationItemDeliveryTime
            self.configurationItemStatus = configurationItemStatus
            self.configurationStateId = configurationStateId
            self.recordingFrequency = recordingFrequency
            self.resourceCreationTime = resourceCreationTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.supplementaryConfiguration = supplementaryConfiguration
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case arn = "arn"
            case availabilityZone = "availabilityZone"
            case awsRegion = "awsRegion"
            case configuration = "configuration"
            case configurationItemCaptureTime = "configurationItemCaptureTime"
            case configurationItemDeliveryTime = "configurationItemDeliveryTime"
            case configurationItemStatus = "configurationItemStatus"
            case configurationStateId = "configurationStateId"
            case recordingFrequency = "recordingFrequency"
            case resourceCreationTime = "resourceCreationTime"
            case resourceId = "resourceId"
            case resourceName = "resourceName"
            case resourceType = "resourceType"
            case supplementaryConfiguration = "supplementaryConfiguration"
            case version = "version"
        }
    }

    public struct BatchGetAggregateResourceConfigRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// A list of aggregate ResourceIdentifiers objects.
        public let resourceIdentifiers: [AggregateResourceIdentifier]

        @inlinable
        public init(configurationAggregatorName: String, resourceIdentifiers: [AggregateResourceIdentifier]) {
            self.configurationAggregatorName = configurationAggregatorName
            self.resourceIdentifiers = resourceIdentifiers
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.resourceIdentifiers.forEach {
                try $0.validate(name: "\(name).resourceIdentifiers[]")
            }
            try self.validate(self.resourceIdentifiers, name: "resourceIdentifiers", parent: name, max: 100)
            try self.validate(self.resourceIdentifiers, name: "resourceIdentifiers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case resourceIdentifiers = "ResourceIdentifiers"
        }
    }

    public struct BatchGetAggregateResourceConfigResponse: AWSDecodableShape {
        /// A list that contains the current configuration of one or more resources.
        public let baseConfigurationItems: [BaseConfigurationItem]?
        /// A list of resource identifiers that were not processed with current scope. The list is empty if all the resources are processed.
        public let unprocessedResourceIdentifiers: [AggregateResourceIdentifier]?

        @inlinable
        public init(baseConfigurationItems: [BaseConfigurationItem]? = nil, unprocessedResourceIdentifiers: [AggregateResourceIdentifier]? = nil) {
            self.baseConfigurationItems = baseConfigurationItems
            self.unprocessedResourceIdentifiers = unprocessedResourceIdentifiers
        }

        private enum CodingKeys: String, CodingKey {
            case baseConfigurationItems = "BaseConfigurationItems"
            case unprocessedResourceIdentifiers = "UnprocessedResourceIdentifiers"
        }
    }

    public struct BatchGetResourceConfigRequest: AWSEncodableShape {
        /// A list of resource keys to be processed with the current
        /// 			request. Each element in the list consists of the resource type and
        /// 			resource ID.
        public let resourceKeys: [ResourceKey]

        @inlinable
        public init(resourceKeys: [ResourceKey]) {
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.resourceKeys.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceKeys = "resourceKeys"
        }
    }

    public struct BatchGetResourceConfigResponse: AWSDecodableShape {
        /// A list that contains the current configuration of one or more
        /// 			resources.
        public let baseConfigurationItems: [BaseConfigurationItem]?
        /// A list of resource keys that were not processed with the
        /// 			current response. The unprocessesResourceKeys value is in the same
        /// 			form as ResourceKeys, so the value can be directly provided to a
        /// 			subsequent BatchGetResourceConfig operation.
        ///
        /// 			If there are no unprocessed resource keys, the response contains an
        /// 			empty unprocessedResourceKeys list.
        public let unprocessedResourceKeys: [ResourceKey]?

        @inlinable
        public init(baseConfigurationItems: [BaseConfigurationItem]? = nil, unprocessedResourceKeys: [ResourceKey]? = nil) {
            self.baseConfigurationItems = baseConfigurationItems
            self.unprocessedResourceKeys = unprocessedResourceKeys
        }

        private enum CodingKeys: String, CodingKey {
            case baseConfigurationItems = "baseConfigurationItems"
            case unprocessedResourceKeys = "unprocessedResourceKeys"
        }
    }

    public struct Compliance: AWSDecodableShape {
        /// The number of Amazon Web Services resources or Config rules that cause a
        /// 			result of NON_COMPLIANT, up to a maximum
        /// 			number.
        public let complianceContributorCount: ComplianceContributorCount?
        /// Indicates whether an Amazon Web Services resource or Config rule is
        /// 			compliant. A resource is compliant if it complies with all of the Config rules that evaluate it. A resource is noncompliant if it does
        /// 			not comply with one or more of these rules. A rule is compliant if all of the resources that the rule
        /// 			evaluates comply with it. A rule is noncompliant if any of these
        /// 			resources do not comply. Config returns the INSUFFICIENT_DATA value
        /// 			when no evaluation results are available for the Amazon Web Services resource or Config rule. For the Compliance data type, Config supports
        /// 			only COMPLIANT, NON_COMPLIANT, and
        /// 				INSUFFICIENT_DATA values. Config does not
        /// 			support the NOT_APPLICABLE value for the
        /// 				Compliance data type.
        public let complianceType: ComplianceType?

        @inlinable
        public init(complianceContributorCount: ComplianceContributorCount? = nil, complianceType: ComplianceType? = nil) {
            self.complianceContributorCount = complianceContributorCount
            self.complianceType = complianceType
        }

        private enum CodingKeys: String, CodingKey {
            case complianceContributorCount = "ComplianceContributorCount"
            case complianceType = "ComplianceType"
        }
    }

    public struct ComplianceByConfigRule: AWSDecodableShape {
        /// Indicates whether the Config rule is compliant.
        public let compliance: Compliance?
        /// The name of the Config rule.
        public let configRuleName: String?

        @inlinable
        public init(compliance: Compliance? = nil, configRuleName: String? = nil) {
            self.compliance = compliance
            self.configRuleName = configRuleName
        }

        private enum CodingKeys: String, CodingKey {
            case compliance = "Compliance"
            case configRuleName = "ConfigRuleName"
        }
    }

    public struct ComplianceByResource: AWSDecodableShape {
        /// Indicates whether the Amazon Web Services resource complies with all of the Config rules that evaluated it.
        public let compliance: Compliance?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public let resourceId: String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public let resourceType: String?

        @inlinable
        public init(compliance: Compliance? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.compliance = compliance
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case compliance = "Compliance"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ComplianceContributorCount: AWSDecodableShape {
        /// Indicates whether the maximum count is reached.
        public let capExceeded: Bool?
        /// The number of Amazon Web Services resources or Config rules responsible for
        /// 			the current compliance of the item.
        public let cappedCount: Int?

        @inlinable
        public init(capExceeded: Bool? = nil, cappedCount: Int? = nil) {
            self.capExceeded = capExceeded
            self.cappedCount = cappedCount
        }

        private enum CodingKeys: String, CodingKey {
            case capExceeded = "CapExceeded"
            case cappedCount = "CappedCount"
        }
    }

    public struct ComplianceSummary: AWSDecodableShape {
        /// The time that Config created the compliance
        /// 			summary.
        public let complianceSummaryTimestamp: Date?
        /// The number of Config rules or Amazon Web Services resources that are
        /// 			compliant, up to a maximum of 25 for rules and 100 for
        /// 			resources.
        public let compliantResourceCount: ComplianceContributorCount?
        /// The number of Config rules or Amazon Web Services resources that are
        /// 			noncompliant, up to a maximum of 25 for rules and 100 for
        /// 			resources.
        public let nonCompliantResourceCount: ComplianceContributorCount?

        @inlinable
        public init(complianceSummaryTimestamp: Date? = nil, compliantResourceCount: ComplianceContributorCount? = nil, nonCompliantResourceCount: ComplianceContributorCount? = nil) {
            self.complianceSummaryTimestamp = complianceSummaryTimestamp
            self.compliantResourceCount = compliantResourceCount
            self.nonCompliantResourceCount = nonCompliantResourceCount
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummaryTimestamp = "ComplianceSummaryTimestamp"
            case compliantResourceCount = "CompliantResourceCount"
            case nonCompliantResourceCount = "NonCompliantResourceCount"
        }
    }

    public struct ComplianceSummaryByResourceType: AWSDecodableShape {
        /// The number of Amazon Web Services resources that are compliant or noncompliant,
        /// 			up to a maximum of 100 for each.
        public let complianceSummary: ComplianceSummary?
        /// The type of Amazon Web Services resource.
        public let resourceType: String?

        @inlinable
        public init(complianceSummary: ComplianceSummary? = nil, resourceType: String? = nil) {
            self.complianceSummary = complianceSummary
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummary = "ComplianceSummary"
            case resourceType = "ResourceType"
        }
    }

    public struct ConfigExportDeliveryInfo: AWSDecodableShape {
        /// The time of the last attempted delivery.
        public let lastAttemptTime: Date?
        /// The error code from the last attempted delivery.
        public let lastErrorCode: String?
        /// The error message from the last attempted delivery.
        public let lastErrorMessage: String?
        /// Status of the last attempted delivery.
        public let lastStatus: DeliveryStatus?
        /// The time of the last successful delivery.
        public let lastSuccessfulTime: Date?
        /// The time that the next delivery occurs.
        public let nextDeliveryTime: Date?

        @inlinable
        public init(lastAttemptTime: Date? = nil, lastErrorCode: String? = nil, lastErrorMessage: String? = nil, lastStatus: DeliveryStatus? = nil, lastSuccessfulTime: Date? = nil, nextDeliveryTime: Date? = nil) {
            self.lastAttemptTime = lastAttemptTime
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStatus = lastStatus
            self.lastSuccessfulTime = lastSuccessfulTime
            self.nextDeliveryTime = nextDeliveryTime
        }

        private enum CodingKeys: String, CodingKey {
            case lastAttemptTime = "lastAttemptTime"
            case lastErrorCode = "lastErrorCode"
            case lastErrorMessage = "lastErrorMessage"
            case lastStatus = "lastStatus"
            case lastSuccessfulTime = "lastSuccessfulTime"
            case nextDeliveryTime = "nextDeliveryTime"
        }
    }

    public struct ConfigRule: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Config
        /// 			rule.
        public let configRuleArn: String?
        /// The ID of the Config rule.
        public let configRuleId: String?
        /// The name that you assign to the Config rule. The name is
        /// 			required if you are adding a new rule.
        public let configRuleName: String?
        /// Indicates whether the Config rule is active or is currently
        /// 			being deleted by Config. It can also indicate the evaluation
        /// 			status for the Config rule. Config sets the state of the rule to
        /// 				EVALUATING temporarily after you use the
        /// 				StartConfigRulesEvaluation request to evaluate your
        /// 			resources against the Config rule. Config sets the state of the rule to
        /// 				DELETING_RESULTS temporarily after you use the
        /// 				DeleteEvaluationResults request to delete the
        /// 			current evaluation results for the Config rule. Config temporarily sets the state of a rule to
        /// 				DELETING after you use the
        /// 				DeleteConfigRule request to delete the rule. After
        /// 			Config deletes the rule, the rule and all of its evaluations are
        /// 			erased and are no longer available.
        public let configRuleState: ConfigRuleState?
        /// Service principal name of the service that created the
        /// 			rule.  The field is populated only if the service-linked rule is
        /// 				created by a service. The field is empty if you create your own
        /// 				rule.
        public let createdBy: String?
        /// The description that you provide for the Config
        /// 			rule.
        public let description: String?
        /// The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.
        public let evaluationModes: [EvaluationModeConfiguration]?
        /// A string, in JSON format, that is passed to the Config rule
        /// 			Lambda function.
        public let inputParameters: String?
        /// The maximum frequency with which Config runs evaluations
        /// 			for a rule. You can specify a value for
        /// 				MaximumExecutionFrequency when:   This is for an Config managed rule that is triggered at
        /// 					a periodic frequency.   Your custom rule is triggered when Config delivers
        /// 					the configuration snapshot. For more information, see ConfigSnapshotDeliveryProperties.    By default, rules with a periodic trigger are evaluated
        /// 				every 24 hours. To change the frequency, specify a valid value
        /// 				for the MaximumExecutionFrequency
        /// 				parameter.
        public let maximumExecutionFrequency: MaximumExecutionFrequency?
        /// Defines which resources can trigger an evaluation for the rule.
        /// 			The scope can include one or more resource types, a combination of
        /// 			one resource type and one resource ID, or a combination of a tag key
        /// 			and value. Specify a scope to constrain the resources that can
        /// 			trigger an evaluation for the rule. If you do not specify a scope,
        /// 			evaluations are triggered when any resource in the recording group
        /// 			changes.  The scope can be empty.
        public let scope: Scope?
        /// Provides the rule owner (Amazon Web Services for managed rules, CUSTOM_POLICY for Custom Policy rules, and CUSTOM_LAMBDA for Custom Lambda rules), the rule identifier,
        /// 			and the notifications that cause the function to evaluate your Amazon Web Services
        /// 			resources.
        public let source: Source

        @inlinable
        public init(configRuleArn: String? = nil, configRuleId: String? = nil, configRuleName: String? = nil, configRuleState: ConfigRuleState? = nil, createdBy: String? = nil, description: String? = nil, evaluationModes: [EvaluationModeConfiguration]? = nil, inputParameters: String? = nil, maximumExecutionFrequency: MaximumExecutionFrequency? = nil, scope: Scope? = nil, source: Source) {
            self.configRuleArn = configRuleArn
            self.configRuleId = configRuleId
            self.configRuleName = configRuleName
            self.configRuleState = configRuleState
            self.createdBy = createdBy
            self.description = description
            self.evaluationModes = evaluationModes
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.scope = scope
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleArn, name: "configRuleArn", parent: name, max: 256)
            try self.validate(self.configRuleArn, name: "configRuleArn", parent: name, min: 1)
            try self.validate(self.configRuleId, name: "configRuleId", parent: name, max: 64)
            try self.validate(self.configRuleId, name: "configRuleId", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
            try self.validate(self.createdBy, name: "createdBy", parent: name, max: 256)
            try self.validate(self.createdBy, name: "createdBy", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, max: 1024)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, min: 1)
            try self.scope?.validate(name: "\(name).scope")
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleArn = "ConfigRuleArn"
            case configRuleId = "ConfigRuleId"
            case configRuleName = "ConfigRuleName"
            case configRuleState = "ConfigRuleState"
            case createdBy = "CreatedBy"
            case description = "Description"
            case evaluationModes = "EvaluationModes"
            case inputParameters = "InputParameters"
            case maximumExecutionFrequency = "MaximumExecutionFrequency"
            case scope = "Scope"
            case source = "Source"
        }
    }

    public struct ConfigRuleComplianceFilters: AWSEncodableShape {
        /// The 12-digit account ID of the source account.
        ///
        public let accountId: String?
        /// The source region where the data is aggregated.
        ///
        public let awsRegion: String?
        /// The rule compliance status. For the ConfigRuleComplianceFilters data type, Config supports only COMPLIANT and
        /// 				NON_COMPLIANT. Config does not support the
        /// 				NOT_APPLICABLE and the
        /// 				INSUFFICIENT_DATA values.
        public let complianceType: ComplianceType?
        /// The name of the Config rule.
        public let configRuleName: String?

        @inlinable
        public init(accountId: String? = nil, awsRegion: String? = nil, complianceType: ComplianceType? = nil, configRuleName: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.configRuleName = configRuleName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 64)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case complianceType = "ComplianceType"
            case configRuleName = "ConfigRuleName"
        }
    }

    public struct ConfigRuleComplianceSummaryFilters: AWSEncodableShape {
        /// The 12-digit account ID of the source account.
        public let accountId: String?
        /// The source region where the data is aggregated.
        public let awsRegion: String?

        @inlinable
        public init(accountId: String? = nil, awsRegion: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 64)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
        }
    }

    public struct ConfigRuleEvaluationStatus: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Config
        /// 			rule.
        public let configRuleArn: String?
        /// The ID of the Config rule.
        public let configRuleId: String?
        /// The name of the Config rule.
        public let configRuleName: String?
        /// The time that you first activated the Config
        /// 			rule.
        public let firstActivatedTime: Date?
        /// Indicates whether Config has evaluated your resources
        /// 			against the rule at least once.    true - Config has evaluated your Amazon Web Services
        /// 					resources against the rule at least once.    false - Config has not finished evaluating your Amazon Web Services resources against the
        /// 					rule
        /// 					at least once.
        public let firstEvaluationStarted: Bool?
        /// The time that you last turned off the Config rule.
        public let lastDeactivatedTime: Date?
        /// The status of the last attempted delivery of a debug log for your Config Custom Policy rules. Either Successful or Failed.
        public let lastDebugLogDeliveryStatus: String?
        /// The reason Config was not able to deliver a debug log. This is for the last
        /// 			failed attempt to retrieve a debug log for your Config Custom Policy rules.
        public let lastDebugLogDeliveryStatusReason: String?
        /// The time Config last attempted to deliver a debug log for your Config Custom Policy rules.
        public let lastDebugLogDeliveryTime: Date?
        /// The error code that Config returned when the rule last
        /// 			failed.
        public let lastErrorCode: String?
        /// The error message that Config returned when the rule last
        /// 			failed.
        public let lastErrorMessage: String?
        /// The time that Config last failed to evaluate your Amazon Web Services
        /// 			resources against the rule.
        public let lastFailedEvaluationTime: Date?
        /// The time that Config last failed to invoke the Config
        /// 			rule to evaluate your Amazon Web Services resources.
        public let lastFailedInvocationTime: Date?
        /// The time that Config last successfully evaluated your Amazon Web Services
        /// 			resources against the rule.
        public let lastSuccessfulEvaluationTime: Date?
        /// The time that Config last successfully invoked the Config rule to evaluate your Amazon Web Services resources.
        public let lastSuccessfulInvocationTime: Date?

        @inlinable
        public init(configRuleArn: String? = nil, configRuleId: String? = nil, configRuleName: String? = nil, firstActivatedTime: Date? = nil, firstEvaluationStarted: Bool? = nil, lastDeactivatedTime: Date? = nil, lastDebugLogDeliveryStatus: String? = nil, lastDebugLogDeliveryStatusReason: String? = nil, lastDebugLogDeliveryTime: Date? = nil, lastErrorCode: String? = nil, lastErrorMessage: String? = nil, lastFailedEvaluationTime: Date? = nil, lastFailedInvocationTime: Date? = nil, lastSuccessfulEvaluationTime: Date? = nil, lastSuccessfulInvocationTime: Date? = nil) {
            self.configRuleArn = configRuleArn
            self.configRuleId = configRuleId
            self.configRuleName = configRuleName
            self.firstActivatedTime = firstActivatedTime
            self.firstEvaluationStarted = firstEvaluationStarted
            self.lastDeactivatedTime = lastDeactivatedTime
            self.lastDebugLogDeliveryStatus = lastDebugLogDeliveryStatus
            self.lastDebugLogDeliveryStatusReason = lastDebugLogDeliveryStatusReason
            self.lastDebugLogDeliveryTime = lastDebugLogDeliveryTime
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastFailedEvaluationTime = lastFailedEvaluationTime
            self.lastFailedInvocationTime = lastFailedInvocationTime
            self.lastSuccessfulEvaluationTime = lastSuccessfulEvaluationTime
            self.lastSuccessfulInvocationTime = lastSuccessfulInvocationTime
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleArn = "ConfigRuleArn"
            case configRuleId = "ConfigRuleId"
            case configRuleName = "ConfigRuleName"
            case firstActivatedTime = "FirstActivatedTime"
            case firstEvaluationStarted = "FirstEvaluationStarted"
            case lastDeactivatedTime = "LastDeactivatedTime"
            case lastDebugLogDeliveryStatus = "LastDebugLogDeliveryStatus"
            case lastDebugLogDeliveryStatusReason = "LastDebugLogDeliveryStatusReason"
            case lastDebugLogDeliveryTime = "LastDebugLogDeliveryTime"
            case lastErrorCode = "LastErrorCode"
            case lastErrorMessage = "LastErrorMessage"
            case lastFailedEvaluationTime = "LastFailedEvaluationTime"
            case lastFailedInvocationTime = "LastFailedInvocationTime"
            case lastSuccessfulEvaluationTime = "LastSuccessfulEvaluationTime"
            case lastSuccessfulInvocationTime = "LastSuccessfulInvocationTime"
        }
    }

    public struct ConfigSnapshotDeliveryProperties: AWSEncodableShape & AWSDecodableShape {
        /// The frequency with which Config delivers configuration
        /// 			snapshots.
        public let deliveryFrequency: MaximumExecutionFrequency?

        @inlinable
        public init(deliveryFrequency: MaximumExecutionFrequency? = nil) {
            self.deliveryFrequency = deliveryFrequency
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryFrequency = "deliveryFrequency"
        }
    }

    public struct ConfigStreamDeliveryInfo: AWSDecodableShape {
        /// The error code from the last attempted delivery.
        public let lastErrorCode: String?
        /// The error message from the last attempted delivery.
        public let lastErrorMessage: String?
        /// Status of the last attempted delivery.  Note Providing an SNS topic on a
        /// 				DeliveryChannel for Config is optional. If the SNS
        /// 			delivery is turned off, the last status will be Not_Applicable.
        public let lastStatus: DeliveryStatus?
        /// The time from the last status change.
        public let lastStatusChangeTime: Date?

        @inlinable
        public init(lastErrorCode: String? = nil, lastErrorMessage: String? = nil, lastStatus: DeliveryStatus? = nil, lastStatusChangeTime: Date? = nil) {
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStatus = lastStatus
            self.lastStatusChangeTime = lastStatusChangeTime
        }

        private enum CodingKeys: String, CodingKey {
            case lastErrorCode = "lastErrorCode"
            case lastErrorMessage = "lastErrorMessage"
            case lastStatus = "lastStatus"
            case lastStatusChangeTime = "lastStatusChangeTime"
        }
    }

    public struct ConfigurationAggregator: AWSDecodableShape {
        /// Provides a list of source accounts and regions to be
        /// 			aggregated.
        public let accountAggregationSources: [AccountAggregationSource]?
        /// An object to filter the data you specify for an aggregator.
        public let aggregatorFilters: AggregatorFilters?
        /// The Amazon Resource Name (ARN) of the aggregator.
        public let configurationAggregatorArn: String?
        /// The name of the aggregator.
        public let configurationAggregatorName: String?
        /// Amazon Web Services service that created the configuration aggregator.
        public let createdBy: String?
        /// The time stamp when the configuration aggregator was
        /// 			created.
        public let creationTime: Date?
        /// The time of the last update.
        public let lastUpdatedTime: Date?
        /// Provides an organization and list of regions to be
        /// 			aggregated.
        public let organizationAggregationSource: OrganizationAggregationSource?

        @inlinable
        public init(accountAggregationSources: [AccountAggregationSource]? = nil, aggregatorFilters: AggregatorFilters? = nil, configurationAggregatorArn: String? = nil, configurationAggregatorName: String? = nil, createdBy: String? = nil, creationTime: Date? = nil, lastUpdatedTime: Date? = nil, organizationAggregationSource: OrganizationAggregationSource? = nil) {
            self.accountAggregationSources = accountAggregationSources
            self.aggregatorFilters = aggregatorFilters
            self.configurationAggregatorArn = configurationAggregatorArn
            self.configurationAggregatorName = configurationAggregatorName
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.organizationAggregationSource = organizationAggregationSource
        }

        private enum CodingKeys: String, CodingKey {
            case accountAggregationSources = "AccountAggregationSources"
            case aggregatorFilters = "AggregatorFilters"
            case configurationAggregatorArn = "ConfigurationAggregatorArn"
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case organizationAggregationSource = "OrganizationAggregationSource"
        }
    }

    public struct ConfigurationItem: AWSDecodableShape {
        /// The 12-digit Amazon Web Services account ID associated with the
        /// 			resource.
        public let accountId: String?
        /// Amazon Resource Name (ARN) associated with the resource.
        public let arn: String?
        /// The Availability Zone associated with the resource.
        public let availabilityZone: String?
        /// The region where the resource resides.
        public let awsRegion: String?
        /// The description of the resource configuration.
        public let configuration: String?
        /// The time when the recording of configuration changes was
        /// 			initiated for the resource.
        public let configurationItemCaptureTime: Date?
        /// The time when configuration changes for the resource were delivered.  This field is optional and is not guaranteed to be present in a configuration item  (CI). If you are using daily recording,
        /// 			this field will be populated. However, if you are using continuous recording,
        /// 			this field will be omitted since the delivery time is instantaneous as the CI is available right away. For more information on daily recording and continuous recording, see Recording Frequency in the Config
        /// 					Developer Guide.
        public let configurationItemDeliveryTime: Date?
        /// Unique MD5 hash that represents the configuration item's
        /// 			state. You can use MD5 hash to compare the states of two or more
        /// 			configuration items that are associated with the same
        /// 			resource.
        public let configurationItemMD5Hash: String?
        /// The configuration item status. Valid values include:   OK  The resource configuration has been updated   ResourceDiscovered  The resource was newly discovered   ResourceNotRecorded  The resource was discovered but its configuration was not recorded since the recorder doesn't record resources of this type   ResourceDeleted  The resource was deleted   ResourceDeletedNotRecorded  The resource was deleted but its configuration was not recorded since the recorder doesn't  record resources of this type
        public let configurationItemStatus: ConfigurationItemStatus?
        /// An identifier that indicates the ordering of the configuration
        /// 			items of a resource.
        public let configurationStateId: String?
        /// The recording frequency that Config uses to record configuration changes for the resource.
        public let recordingFrequency: RecordingFrequency?
        /// A list of CloudTrail event IDs. A populated field indicates that the current configuration was
        /// 			initiated by the events recorded in the CloudTrail log. For more
        /// 			information about CloudTrail, see What Is CloudTrail. An empty field indicates that the current configuration was not
        /// 			initiated by any event. As of Version 1.3, the relatedEvents field is empty.
        /// 			You can access the LookupEvents API in the CloudTrail API Reference to retrieve the events for the resource.
        public let relatedEvents: [String]?
        /// A list of related Amazon Web Services resources.
        public let relationships: [Relationship]?
        /// The time stamp when the resource was created.
        public let resourceCreationTime: Date?
        /// The ID of the resource (for example,
        /// 			sg-xxxxxx).
        public let resourceId: String?
        /// The custom name of the resource, if available.
        public let resourceName: String?
        /// The type of Amazon Web Services resource.
        public let resourceType: ResourceType?
        /// Configuration attributes that Config returns for certain
        /// 			resource types to supplement the information returned for the
        /// 				configuration parameter.
        public let supplementaryConfiguration: [String: String]?
        /// A mapping of key value tags associated with the
        /// 			resource.
        public let tags: [String: String]?
        /// The version number of the resource configuration.
        public let version: String?

        @inlinable
        public init(accountId: String? = nil, arn: String? = nil, availabilityZone: String? = nil, awsRegion: String? = nil, configuration: String? = nil, configurationItemCaptureTime: Date? = nil, configurationItemDeliveryTime: Date? = nil, configurationItemMD5Hash: String? = nil, configurationItemStatus: ConfigurationItemStatus? = nil, configurationStateId: String? = nil, recordingFrequency: RecordingFrequency? = nil, relatedEvents: [String]? = nil, relationships: [Relationship]? = nil, resourceCreationTime: Date? = nil, resourceId: String? = nil, resourceName: String? = nil, resourceType: ResourceType? = nil, supplementaryConfiguration: [String: String]? = nil, tags: [String: String]? = nil, version: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.awsRegion = awsRegion
            self.configuration = configuration
            self.configurationItemCaptureTime = configurationItemCaptureTime
            self.configurationItemDeliveryTime = configurationItemDeliveryTime
            self.configurationItemMD5Hash = configurationItemMD5Hash
            self.configurationItemStatus = configurationItemStatus
            self.configurationStateId = configurationStateId
            self.recordingFrequency = recordingFrequency
            self.relatedEvents = relatedEvents
            self.relationships = relationships
            self.resourceCreationTime = resourceCreationTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.supplementaryConfiguration = supplementaryConfiguration
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case arn = "arn"
            case availabilityZone = "availabilityZone"
            case awsRegion = "awsRegion"
            case configuration = "configuration"
            case configurationItemCaptureTime = "configurationItemCaptureTime"
            case configurationItemDeliveryTime = "configurationItemDeliveryTime"
            case configurationItemMD5Hash = "configurationItemMD5Hash"
            case configurationItemStatus = "configurationItemStatus"
            case configurationStateId = "configurationStateId"
            case recordingFrequency = "recordingFrequency"
            case relatedEvents = "relatedEvents"
            case relationships = "relationships"
            case resourceCreationTime = "resourceCreationTime"
            case resourceId = "resourceId"
            case resourceName = "resourceName"
            case resourceType = "resourceType"
            case supplementaryConfiguration = "supplementaryConfiguration"
            case tags = "tags"
            case version = "version"
        }
    }

    public struct ConfigurationRecorder: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the specified configuration recorder.
        public let arn: String?
        /// The name of the configuration recorder. For customer managed configuration recorders, Config automatically assigns the name of "default" when creating a configuration recorder if you do not specify a name at creation time. For service-linked configuration recorders, Config automatically assigns a name that has the prefix "AWS" to a new service-linked configuration recorder.   Changing the name of a configuration recorder  To change the name of the customer managed configuration recorder, you must delete it and create a new customer managed configuration recorder with a new name. You cannot change the name of a service-linked configuration recorder.
        public let name: String?
        /// Specifies which resource types are in scope for the configuration recorder to record.   High Number of Config Evaluations  You might notice increased activity in your account during your initial month recording with Config when compared to subsequent months. During the
        /// 				initial bootstrapping process, Config runs evaluations on all the resources in your account that you have selected
        /// 				for Config to record. If you are running ephemeral workloads, you may see increased activity from Config as it records configuration changes associated with creating and deleting these
        /// 				temporary resources. An ephemeral workload is a temporary use of computing resources that are loaded
        /// 				and run when needed. Examples include Amazon Elastic Compute Cloud (Amazon EC2)
        /// 				Spot Instances, Amazon EMR jobs, and Auto Scaling. If you want to avoid the increased activity from running ephemeral workloads, you can set up the configuration recorder to exclude these resource types from being recorded, or run these types of workloads in a separate account with Config turned off to avoid
        /// 				increased configuration recording and rule evaluations.
        public let recordingGroup: RecordingGroup?
        /// Specifies the default recording frequency for the configuration recorder.
        ///
        /// 			Config supports Continuous recording and Daily recording.   Continuous recording allows you to record configuration changes continuously whenever a change occurs.   Daily recording allows you to receive a configuration item (CI) representing the most recent state of your resources over the last 24-hour period, only if its different from the previous CI recorded.
        /// 			     Some resource types require continuous recording  Firewall Manager depends on continuous recording to monitor your resources. If you are using Firewall Manager,
        /// 			it is recommended that you set the recording frequency to Continuous.  You can also override the recording frequency for specific resource types.
        public let recordingMode: RecordingMode?
        /// Specifies whether the ConfigurationItems in scope for the specified configuration recorder are recorded for free (INTERNAL) or if it impacts the costs to your bill (PAID).
        public let recordingScope: RecordingScope?
        /// The Amazon Resource Name (ARN) of the IAM role assumed by Config and used by the specified configuration recorder.   The server will reject a request without a defined roleARN for the configuration recorder  While the API model does not require this field, the server will reject a request without a defined roleARN for the configuration recorder.  Policies and compliance results   IAM policies
        /// 				and other policies managed in Organizations
        /// 				can impact whether Config
        /// 				has permissions to record configuration changes for your resources. Additionally, rules directly evaluate the configuration of a resource and rules don't take into account these policies when running evaluations.
        /// 				Make sure that the policies in effect align with how you intend to use Config.  Keep Minimum Permisions When Reusing an IAM role  If you use an Amazon Web Services service that uses Config, such as Security Hub or
        /// 				Control Tower, and an IAM role has already been created, make sure that the
        /// 				IAM role that you use when setting up Config keeps the same minimum
        /// 				permissions as the pre-existing IAM role. You must do this to ensure that the
        /// 				other Amazon Web Services service continues to run as expected.  For example, if Control Tower has an IAM role that allows Config to read
        /// 				S3 objects, make sure that the same permissions are granted
        /// 				to the IAM role you use when setting up Config. Otherwise, it may
        /// 				interfere with how Control Tower operates.  The service-linked IAM role for Config must be used for service-linked configuration recorders  For service-linked configuration recorders, you must use the service-linked IAM role for Config: AWSServiceRoleForConfig.
        public let roleARN: String?
        /// For service-linked configuration recorders, specifies the linked Amazon Web Services service for the configuration recorder.
        public let servicePrincipal: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil, recordingGroup: RecordingGroup? = nil, recordingMode: RecordingMode? = nil, recordingScope: RecordingScope? = nil, roleARN: String? = nil, servicePrincipal: String? = nil) {
            self.arn = arn
            self.name = name
            self.recordingGroup = recordingGroup
            self.recordingMode = recordingMode
            self.recordingScope = recordingScope
            self.roleARN = roleARN
            self.servicePrincipal = servicePrincipal
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.recordingMode?.validate(name: "\(name).recordingMode")
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, max: 128)
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, min: 1)
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, pattern: "^[\\w+=,.@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case recordingGroup = "recordingGroup"
            case recordingMode = "recordingMode"
            case recordingScope = "recordingScope"
            case roleARN = "roleARN"
            case servicePrincipal = "servicePrincipal"
        }
    }

    public struct ConfigurationRecorderFilter: AWSEncodableShape {
        /// The name of the type of filter. Currently, only recordingScope is supported.
        public let filterName: ConfigurationRecorderFilterName?
        /// The value of the filter. For recordingScope, valid values include: INTERNAL and PAID.  INTERNAL indicates that the ConfigurationItems in scope for the configuration recorder are recorded for free.  PAID indicates that the ConfigurationItems in scope for the configuration recorder impact the costs to your bill.
        public let filterValue: [String]?

        @inlinable
        public init(filterName: ConfigurationRecorderFilterName? = nil, filterValue: [String]? = nil) {
            self.filterName = filterName
            self.filterValue = filterValue
        }

        public func validate(name: String) throws {
            try self.filterValue?.forEach {
                try validate($0, name: "filterValue[]", parent: name, pattern: "^[0-9a-zA-Z\\\\*\\\\.\\\\\\/\\\\?-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filterName = "filterName"
            case filterValue = "filterValue"
        }
    }

    public struct ConfigurationRecorderStatus: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration recorder.
        public let arn: String?
        /// The latest error code from when the recorder last failed.
        public let lastErrorCode: String?
        /// The latest error message from when the recorder last failed.
        public let lastErrorMessage: String?
        /// The time the recorder was last started.
        public let lastStartTime: Date?
        /// The status of the latest recording event processed by the recorder.
        public let lastStatus: RecorderStatus?
        /// The time of the latest change in status of an recording event processed by the recorder.
        public let lastStatusChangeTime: Date?
        /// The time the recorder was last stopped.
        public let lastStopTime: Date?
        /// The name of the configuration recorder.
        public let name: String?
        /// Specifies whether or not the recorder is currently
        /// 			recording.
        public let recording: Bool?
        /// For service-linked configuration recorders, the service principal of the linked Amazon Web Services service.
        public let servicePrincipal: String?

        @inlinable
        public init(arn: String? = nil, lastErrorCode: String? = nil, lastErrorMessage: String? = nil, lastStartTime: Date? = nil, lastStatus: RecorderStatus? = nil, lastStatusChangeTime: Date? = nil, lastStopTime: Date? = nil, name: String? = nil, recording: Bool? = nil, servicePrincipal: String? = nil) {
            self.arn = arn
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStartTime = lastStartTime
            self.lastStatus = lastStatus
            self.lastStatusChangeTime = lastStatusChangeTime
            self.lastStopTime = lastStopTime
            self.name = name
            self.recording = recording
            self.servicePrincipal = servicePrincipal
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case lastErrorCode = "lastErrorCode"
            case lastErrorMessage = "lastErrorMessage"
            case lastStartTime = "lastStartTime"
            case lastStatus = "lastStatus"
            case lastStatusChangeTime = "lastStatusChangeTime"
            case lastStopTime = "lastStopTime"
            case name = "name"
            case recording = "recording"
            case servicePrincipal = "servicePrincipal"
        }
    }

    public struct ConfigurationRecorderSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration recorder.
        public let arn: String
        /// The name of the configuration recorder.
        public let name: String
        /// Indicates whether the ConfigurationItems in scope for the configuration recorder are recorded for free (INTERNAL) or if you are charged a service fee for recording (PAID).
        public let recordingScope: RecordingScope
        /// For service-linked configuration recorders, indicates which Amazon Web Services service the configuration recorder is linked to.
        public let servicePrincipal: String?

        @inlinable
        public init(arn: String, name: String, recordingScope: RecordingScope, servicePrincipal: String? = nil) {
            self.arn = arn
            self.name = name
            self.recordingScope = recordingScope
            self.servicePrincipal = servicePrincipal
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case recordingScope = "recordingScope"
            case servicePrincipal = "servicePrincipal"
        }
    }

    public struct ConformancePackComplianceFilters: AWSEncodableShape {
        /// Filters the results by compliance. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        public let complianceType: ConformancePackComplianceType?
        /// Filters the results by Config rule names.
        public let configRuleNames: [String]?

        @inlinable
        public init(complianceType: ConformancePackComplianceType? = nil, configRuleNames: [String]? = nil) {
            self.complianceType = complianceType
            self.configRuleNames = configRuleNames
        }

        public func validate(name: String) throws {
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 64)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "ComplianceType"
            case configRuleNames = "ConfigRuleNames"
        }
    }

    public struct ConformancePackComplianceScore: AWSDecodableShape {
        /// The name of the conformance pack.
        public let conformancePackName: String?
        /// The time that the conformance pack compliance score was last updated.
        public let lastUpdatedTime: Date?
        /// Compliance score for the conformance pack. Conformance packs with no evaluation results will have a compliance score of INSUFFICIENT_DATA.
        public let score: String?

        @inlinable
        public init(conformancePackName: String? = nil, lastUpdatedTime: Date? = nil, score: String? = nil) {
            self.conformancePackName = conformancePackName
            self.lastUpdatedTime = lastUpdatedTime
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackName = "ConformancePackName"
            case lastUpdatedTime = "LastUpdatedTime"
            case score = "Score"
        }
    }

    public struct ConformancePackComplianceScoresFilters: AWSEncodableShape {
        /// The names of the conformance packs whose compliance scores you want to include in the conformance pack compliance score result set.
        /// 			You can include up to 25 conformance packs in the ConformancePackNames array of strings, each with a character limit of 256 characters for the conformance pack name.
        public let conformancePackNames: [String]

        @inlinable
        public init(conformancePackNames: [String]) {
            self.conformancePackNames = conformancePackNames
        }

        public func validate(name: String) throws {
            try self.conformancePackNames.forEach {
                try validate($0, name: "conformancePackNames[]", parent: name, max: 256)
                try validate($0, name: "conformancePackNames[]", parent: name, min: 1)
                try validate($0, name: "conformancePackNames[]", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            }
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, max: 25)
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackNames = "ConformancePackNames"
        }
    }

    public struct ConformancePackComplianceSummary: AWSDecodableShape {
        /// The status of the conformance pack.
        public let conformancePackComplianceStatus: ConformancePackComplianceType
        /// The name of the conformance pack name.
        public let conformancePackName: String

        @inlinable
        public init(conformancePackComplianceStatus: ConformancePackComplianceType, conformancePackName: String) {
            self.conformancePackComplianceStatus = conformancePackComplianceStatus
            self.conformancePackName = conformancePackName
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackComplianceStatus = "ConformancePackComplianceStatus"
            case conformancePackName = "ConformancePackName"
        }
    }

    public struct ConformancePackDetail: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the conformance pack.
        public let conformancePackArn: String
        /// ID of the conformance pack.
        public let conformancePackId: String
        /// A list of ConformancePackInputParameter objects.
        public let conformancePackInputParameters: [ConformancePackInputParameter]?
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// The Amazon Web Services service that created the conformance pack.
        public let createdBy: String?
        /// The name of the Amazon S3 bucket where Config stores conformance pack templates.   This field is optional.
        public let deliveryS3Bucket: String?
        /// The prefix for the Amazon S3 bucket.  This field is optional.
        public let deliveryS3KeyPrefix: String?
        /// The last time a conformation pack update was requested.
        public let lastUpdateRequestedTime: Date?
        /// An object that contains the name or Amazon Resource Name (ARN) of the Amazon Web Services Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.
        public let templateSSMDocumentDetails: TemplateSSMDocumentDetails?

        @inlinable
        public init(conformancePackArn: String, conformancePackId: String, conformancePackInputParameters: [ConformancePackInputParameter]? = nil, conformancePackName: String, createdBy: String? = nil, deliveryS3Bucket: String? = nil, deliveryS3KeyPrefix: String? = nil, lastUpdateRequestedTime: Date? = nil, templateSSMDocumentDetails: TemplateSSMDocumentDetails? = nil) {
            self.conformancePackArn = conformancePackArn
            self.conformancePackId = conformancePackId
            self.conformancePackInputParameters = conformancePackInputParameters
            self.conformancePackName = conformancePackName
            self.createdBy = createdBy
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.lastUpdateRequestedTime = lastUpdateRequestedTime
            self.templateSSMDocumentDetails = templateSSMDocumentDetails
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackArn = "ConformancePackArn"
            case conformancePackId = "ConformancePackId"
            case conformancePackInputParameters = "ConformancePackInputParameters"
            case conformancePackName = "ConformancePackName"
            case createdBy = "CreatedBy"
            case deliveryS3Bucket = "DeliveryS3Bucket"
            case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
            case lastUpdateRequestedTime = "LastUpdateRequestedTime"
            case templateSSMDocumentDetails = "TemplateSSMDocumentDetails"
        }
    }

    public struct ConformancePackEvaluationFilters: AWSEncodableShape {
        /// Filters the results by compliance. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        public let complianceType: ConformancePackComplianceType?
        /// Filters the results by Config rule names.
        public let configRuleNames: [String]?
        /// Filters the results by resource IDs.  This is valid only when you provide resource type. If there is no resource type, you will see an error.
        public let resourceIds: [String]?
        /// Filters the results by the resource type (for example, "AWS::EC2::Instance").
        public let resourceType: String?

        @inlinable
        public init(complianceType: ConformancePackComplianceType? = nil, configRuleNames: [String]? = nil, resourceIds: [String]? = nil, resourceType: String? = nil) {
            self.complianceType = complianceType
            self.configRuleNames = configRuleNames
            self.resourceIds = resourceIds
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 64)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 10)
            try self.resourceIds?.forEach {
                try validate($0, name: "resourceIds[]", parent: name, max: 256)
                try validate($0, name: "resourceIds[]", parent: name, min: 1)
            }
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 5)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "ComplianceType"
            case configRuleNames = "ConfigRuleNames"
            case resourceIds = "ResourceIds"
            case resourceType = "ResourceType"
        }
    }

    public struct ConformancePackEvaluationResult: AWSDecodableShape {
        /// Supplementary information about how the evaluation determined the compliance.
        public let annotation: String?
        /// The compliance type. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        public let complianceType: ConformancePackComplianceType
        /// The time when Config rule evaluated Amazon Web Services resource.
        public let configRuleInvokedTime: Date
        public let evaluationResultIdentifier: EvaluationResultIdentifier
        /// The time when Config recorded the evaluation result.
        public let resultRecordedTime: Date

        @inlinable
        public init(annotation: String? = nil, complianceType: ConformancePackComplianceType, configRuleInvokedTime: Date, evaluationResultIdentifier: EvaluationResultIdentifier, resultRecordedTime: Date) {
            self.annotation = annotation
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
        }

        private enum CodingKeys: String, CodingKey {
            case annotation = "Annotation"
            case complianceType = "ComplianceType"
            case configRuleInvokedTime = "ConfigRuleInvokedTime"
            case evaluationResultIdentifier = "EvaluationResultIdentifier"
            case resultRecordedTime = "ResultRecordedTime"
        }
    }

    public struct ConformancePackInputParameter: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair.
        public let parameterName: String
        /// Another part of the key-value pair.
        public let parameterValue: String

        @inlinable
        public init(parameterName: String, parameterValue: String) {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }

        public func validate(name: String) throws {
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 255)
            try self.validate(self.parameterValue, name: "parameterValue", parent: name, max: 4096)
        }

        private enum CodingKeys: String, CodingKey {
            case parameterName = "ParameterName"
            case parameterValue = "ParameterValue"
        }
    }

    public struct ConformancePackRuleCompliance: AWSDecodableShape {
        /// Compliance of the Config rule.
        public let complianceType: ConformancePackComplianceType?
        /// Name of the Config rule.
        public let configRuleName: String?
        /// Controls for the conformance pack. A control is a process to prevent or detect problems while meeting objectives.
        /// 			A control can align with a specific compliance regime or map to internal controls defined by an organization.
        public let controls: [String]?

        @inlinable
        public init(complianceType: ConformancePackComplianceType? = nil, configRuleName: String? = nil, controls: [String]? = nil) {
            self.complianceType = complianceType
            self.configRuleName = configRuleName
            self.controls = controls
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "ComplianceType"
            case configRuleName = "ConfigRuleName"
            case controls = "Controls"
        }
    }

    public struct ConformancePackStatusDetail: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of comformance pack.
        public let conformancePackArn: String
        /// ID of the conformance pack.
        public let conformancePackId: String
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// Indicates deployment status of conformance pack. Config sets the state of the conformance pack to:   CREATE_IN_PROGRESS when a conformance pack creation is in progress for an account.   CREATE_COMPLETE when a conformance pack has been successfully created in your account.   CREATE_FAILED when a conformance pack creation failed in your account.   DELETE_IN_PROGRESS when a conformance pack deletion is in progress.    DELETE_FAILED when a conformance pack deletion failed in your account.
        public let conformancePackState: ConformancePackState
        /// The reason of conformance pack creation failure.
        public let conformancePackStatusReason: String?
        /// Last time when conformation pack creation and update was successful.
        public let lastUpdateCompletedTime: Date?
        /// Last time when conformation pack creation and update was requested.
        public let lastUpdateRequestedTime: Date
        /// Amazon Resource Name (ARN) of CloudFormation stack.
        public let stackArn: String

        @inlinable
        public init(conformancePackArn: String, conformancePackId: String, conformancePackName: String, conformancePackState: ConformancePackState, conformancePackStatusReason: String? = nil, lastUpdateCompletedTime: Date? = nil, lastUpdateRequestedTime: Date, stackArn: String) {
            self.conformancePackArn = conformancePackArn
            self.conformancePackId = conformancePackId
            self.conformancePackName = conformancePackName
            self.conformancePackState = conformancePackState
            self.conformancePackStatusReason = conformancePackStatusReason
            self.lastUpdateCompletedTime = lastUpdateCompletedTime
            self.lastUpdateRequestedTime = lastUpdateRequestedTime
            self.stackArn = stackArn
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackArn = "ConformancePackArn"
            case conformancePackId = "ConformancePackId"
            case conformancePackName = "ConformancePackName"
            case conformancePackState = "ConformancePackState"
            case conformancePackStatusReason = "ConformancePackStatusReason"
            case lastUpdateCompletedTime = "LastUpdateCompletedTime"
            case lastUpdateRequestedTime = "LastUpdateRequestedTime"
            case stackArn = "StackArn"
        }
    }

    public struct CustomPolicyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The boolean expression for enabling debug logging for your Config Custom Policy rule. The default value is false.
        public let enableDebugLogDelivery: Bool?
        /// The runtime system for your Config Custom Policy rule. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the Guard GitHub
        /// 					Repository.
        public let policyRuntime: String
        /// The policy definition containing the logic for your Config Custom Policy rule.
        public let policyText: String

        @inlinable
        public init(enableDebugLogDelivery: Bool? = nil, policyRuntime: String, policyText: String) {
            self.enableDebugLogDelivery = enableDebugLogDelivery
            self.policyRuntime = policyRuntime
            self.policyText = policyText
        }

        public func validate(name: String) throws {
            try self.validate(self.policyRuntime, name: "policyRuntime", parent: name, max: 64)
            try self.validate(self.policyRuntime, name: "policyRuntime", parent: name, min: 1)
            try self.validate(self.policyRuntime, name: "policyRuntime", parent: name, pattern: "^guard\\-2\\.x\\.x$")
            try self.validate(self.policyText, name: "policyText", parent: name, max: 10000)
        }

        private enum CodingKeys: String, CodingKey {
            case enableDebugLogDelivery = "EnableDebugLogDelivery"
            case policyRuntime = "PolicyRuntime"
            case policyText = "PolicyText"
        }
    }

    public struct DeleteAggregationAuthorizationRequest: AWSEncodableShape {
        /// The 12-digit account ID of the account authorized to aggregate
        /// 			data.
        public let authorizedAccountId: String
        /// The region authorized to collect aggregated data.
        public let authorizedAwsRegion: String

        @inlinable
        public init(authorizedAccountId: String, authorizedAwsRegion: String) {
            self.authorizedAccountId = authorizedAccountId
            self.authorizedAwsRegion = authorizedAwsRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.authorizedAccountId, name: "authorizedAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.authorizedAwsRegion, name: "authorizedAwsRegion", parent: name, max: 64)
            try self.validate(self.authorizedAwsRegion, name: "authorizedAwsRegion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedAccountId = "AuthorizedAccountId"
            case authorizedAwsRegion = "AuthorizedAwsRegion"
        }
    }

    public struct DeleteConfigRuleRequest: AWSEncodableShape {
        /// The name of the Config rule that you want to
        /// 			delete.
        public let configRuleName: String

        @inlinable
        public init(configRuleName: String) {
            self.configRuleName = configRuleName
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
        }
    }

    public struct DeleteConfigurationAggregatorRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String

        @inlinable
        public init(configurationAggregatorName: String) {
            self.configurationAggregatorName = configurationAggregatorName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
        }
    }

    public struct DeleteConfigurationRecorderRequest: AWSEncodableShape {
        /// The name of the customer managed configuration recorder that you want to delete. You can
        /// 			retrieve the name of your configuration recorders by using the DescribeConfigurationRecorders operation.
        public let configurationRecorderName: String

        @inlinable
        public init(configurationRecorderName: String) {
            self.configurationRecorderName = configurationRecorderName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, max: 256)
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorderName = "ConfigurationRecorderName"
        }
    }

    public struct DeleteConformancePackRequest: AWSEncodableShape {
        /// Name of the conformance pack you want to delete.
        public let conformancePackName: String

        @inlinable
        public init(conformancePackName: String) {
            self.conformancePackName = conformancePackName
        }

        public func validate(name: String) throws {
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, max: 256)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackName = "ConformancePackName"
        }
    }

    public struct DeleteDeliveryChannelRequest: AWSEncodableShape {
        /// The name of the delivery channel that you want to delete.
        public let deliveryChannelName: String

        @inlinable
        public init(deliveryChannelName: String) {
            self.deliveryChannelName = deliveryChannelName
        }

        public func validate(name: String) throws {
            try self.validate(self.deliveryChannelName, name: "deliveryChannelName", parent: name, max: 256)
            try self.validate(self.deliveryChannelName, name: "deliveryChannelName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannelName = "DeliveryChannelName"
        }
    }

    public struct DeleteEvaluationResultsRequest: AWSEncodableShape {
        /// The name of the Config rule for which you want to delete
        /// 			the evaluation results.
        public let configRuleName: String

        @inlinable
        public init(configRuleName: String) {
            self.configRuleName = configRuleName
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 64)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
        }
    }

    public struct DeleteEvaluationResultsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOrganizationConfigRuleRequest: AWSEncodableShape {
        /// The name of organization Config rule that you want to delete.
        public let organizationConfigRuleName: String

        @inlinable
        public init(organizationConfigRuleName: String) {
            self.organizationConfigRuleName = organizationConfigRuleName
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, max: 64)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, min: 1)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, pattern: "^[A-Za-z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationConfigRuleName = "OrganizationConfigRuleName"
        }
    }

    public struct DeleteOrganizationConformancePackRequest: AWSEncodableShape {
        /// The name of organization conformance pack that you want to delete.
        public let organizationConformancePackName: String

        @inlinable
        public init(organizationConformancePackName: String) {
            self.organizationConformancePackName = organizationConformancePackName
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, max: 128)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, min: 1)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationConformancePackName = "OrganizationConformancePackName"
        }
    }

    public struct DeletePendingAggregationRequestRequest: AWSEncodableShape {
        /// The 12-digit account ID of the account requesting to aggregate
        /// 			data.
        public let requesterAccountId: String
        /// The region requesting to aggregate data.
        public let requesterAwsRegion: String

        @inlinable
        public init(requesterAccountId: String, requesterAwsRegion: String) {
            self.requesterAccountId = requesterAccountId
            self.requesterAwsRegion = requesterAwsRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.requesterAccountId, name: "requesterAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.requesterAwsRegion, name: "requesterAwsRegion", parent: name, max: 64)
            try self.validate(self.requesterAwsRegion, name: "requesterAwsRegion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case requesterAccountId = "RequesterAccountId"
            case requesterAwsRegion = "RequesterAwsRegion"
        }
    }

    public struct DeleteRemediationConfigurationRequest: AWSEncodableShape {
        /// The name of the Config rule for which you want to delete remediation configuration.
        public let configRuleName: String
        /// The type of a resource.
        public let resourceType: String?

        @inlinable
        public init(configRuleName: String, resourceType: String? = nil) {
            self.configRuleName = configRuleName
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case resourceType = "ResourceType"
        }
    }

    public struct DeleteRemediationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRemediationExceptionsRequest: AWSEncodableShape {
        /// The name of the Config rule for which you want to delete remediation exception configuration.
        public let configRuleName: String
        /// An exception list of resource exception keys to be processed with the current request. Config adds exception for each resource key. For example, Config adds 3 exceptions for 3 resource keys.
        public let resourceKeys: [RemediationExceptionResourceKey]

        @inlinable
        public init(configRuleName: String, resourceKeys: [RemediationExceptionResourceKey]) {
            self.configRuleName = configRuleName
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
            try self.resourceKeys.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case resourceKeys = "ResourceKeys"
        }
    }

    public struct DeleteRemediationExceptionsResponse: AWSDecodableShape {
        /// Returns a list of failed delete remediation exceptions batch objects. Each object in the batch consists of a list of failed items and failure messages.
        public let failedBatches: [FailedDeleteRemediationExceptionsBatch]?

        @inlinable
        public init(failedBatches: [FailedDeleteRemediationExceptionsBatch]? = nil) {
            self.failedBatches = failedBatches
        }

        private enum CodingKeys: String, CodingKey {
            case failedBatches = "FailedBatches"
        }
    }

    public struct DeleteResourceConfigRequest: AWSEncodableShape {
        /// Unique identifier of the resource.
        public let resourceId: String
        /// The type of the resource.
        public let resourceType: String

        @inlinable
        public init(resourceId: String, resourceType: String) {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 196)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct DeleteRetentionConfigurationRequest: AWSEncodableShape {
        /// The name of the retention configuration to delete.
        public let retentionConfigurationName: String

        @inlinable
        public init(retentionConfigurationName: String) {
            self.retentionConfigurationName = retentionConfigurationName
        }

        public func validate(name: String) throws {
            try self.validate(self.retentionConfigurationName, name: "retentionConfigurationName", parent: name, max: 256)
            try self.validate(self.retentionConfigurationName, name: "retentionConfigurationName", parent: name, min: 1)
            try self.validate(self.retentionConfigurationName, name: "retentionConfigurationName", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case retentionConfigurationName = "RetentionConfigurationName"
        }
    }

    public struct DeleteServiceLinkedConfigurationRecorderRequest: AWSEncodableShape {
        /// The service principal of the Amazon Web Services service for the service-linked configuration recorder that you want to delete.
        public let servicePrincipal: String

        @inlinable
        public init(servicePrincipal: String) {
            self.servicePrincipal = servicePrincipal
        }

        public func validate(name: String) throws {
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, max: 128)
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, min: 1)
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, pattern: "^[\\w+=,.@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case servicePrincipal = "ServicePrincipal"
        }
    }

    public struct DeleteServiceLinkedConfigurationRecorderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the specified configuration recorder.
        public let arn: String
        /// The name of the specified configuration recorder.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct DeleteStoredQueryRequest: AWSEncodableShape {
        /// The name of the query that you want to delete.
        public let queryName: String

        @inlinable
        public init(queryName: String) {
            self.queryName = queryName
        }

        public func validate(name: String) throws {
            try self.validate(self.queryName, name: "queryName", parent: name, max: 64)
            try self.validate(self.queryName, name: "queryName", parent: name, min: 1)
            try self.validate(self.queryName, name: "queryName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case queryName = "QueryName"
        }
    }

    public struct DeleteStoredQueryResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeliverConfigSnapshotRequest: AWSEncodableShape {
        /// The name of the delivery channel through which the snapshot is
        /// 			delivered.
        public let deliveryChannelName: String

        @inlinable
        public init(deliveryChannelName: String) {
            self.deliveryChannelName = deliveryChannelName
        }

        public func validate(name: String) throws {
            try self.validate(self.deliveryChannelName, name: "deliveryChannelName", parent: name, max: 256)
            try self.validate(self.deliveryChannelName, name: "deliveryChannelName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannelName = "deliveryChannelName"
        }
    }

    public struct DeliverConfigSnapshotResponse: AWSDecodableShape {
        /// The ID of the snapshot that is being created.
        public let configSnapshotId: String?

        @inlinable
        public init(configSnapshotId: String? = nil) {
            self.configSnapshotId = configSnapshotId
        }

        private enum CodingKeys: String, CodingKey {
            case configSnapshotId = "configSnapshotId"
        }
    }

    public struct DeliveryChannel: AWSEncodableShape & AWSDecodableShape {
        /// The options for how often Config delivers configuration
        /// 			snapshots to the Amazon S3 bucket.
        public let configSnapshotDeliveryProperties: ConfigSnapshotDeliveryProperties?
        /// The name of the delivery channel. By default, Config
        /// 			assigns the name "default" when creating the delivery channel. To
        /// 			change the delivery channel name, you must use the
        /// 			DeleteDeliveryChannel action to delete your current delivery
        /// 			channel, and then you must use the PutDeliveryChannel command to
        /// 			create a delivery channel that has the desired name.
        public let name: String?
        /// The name of the Amazon S3 bucket to which Config delivers
        /// 			configuration snapshots and configuration history files. If you specify a bucket that belongs to another Amazon Web Services account,
        /// 			that bucket must have policies that grant access permissions to Config. For more information, see Permissions for the Amazon S3 Bucket in the Config
        /// 			Developer Guide.
        public let s3BucketName: String?
        /// The prefix for the specified Amazon S3 bucket.
        public let s3KeyPrefix: String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS ) KMS key (KMS key) used to encrypt objects delivered by Config.
        /// 			Must belong to the same Region as the destination S3 bucket.
        public let s3KmsKeyArn: String?
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic to which
        /// 			Config sends notifications about configuration
        /// 			changes. If you choose a topic from another account, the topic must have
        /// 			policies that grant access permissions to Config. For more
        /// 			information, see Permissions for the Amazon SNS Topic in the Config
        /// 			Developer Guide.
        public let snsTopicARN: String?

        @inlinable
        public init(configSnapshotDeliveryProperties: ConfigSnapshotDeliveryProperties? = nil, name: String? = nil, s3BucketName: String? = nil, s3KeyPrefix: String? = nil, s3KmsKeyArn: String? = nil, snsTopicARN: String? = nil) {
            self.configSnapshotDeliveryProperties = configSnapshotDeliveryProperties
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.s3KmsKeyArn = s3KmsKeyArn
            self.snsTopicARN = snsTopicARN
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configSnapshotDeliveryProperties = "configSnapshotDeliveryProperties"
            case name = "name"
            case s3BucketName = "s3BucketName"
            case s3KeyPrefix = "s3KeyPrefix"
            case s3KmsKeyArn = "s3KmsKeyArn"
            case snsTopicARN = "snsTopicARN"
        }
    }

    public struct DeliveryChannelStatus: AWSDecodableShape {
        /// A list that contains the status of the delivery of the
        /// 			configuration history to the specified Amazon S3 bucket.
        public let configHistoryDeliveryInfo: ConfigExportDeliveryInfo?
        /// A list containing the status of the delivery of the snapshot to
        /// 			the specified Amazon S3 bucket.
        public let configSnapshotDeliveryInfo: ConfigExportDeliveryInfo?
        /// A list containing the status of the delivery of the
        /// 			configuration stream notification to the specified Amazon SNS
        /// 			topic.
        public let configStreamDeliveryInfo: ConfigStreamDeliveryInfo?
        /// The name of the delivery channel.
        public let name: String?

        @inlinable
        public init(configHistoryDeliveryInfo: ConfigExportDeliveryInfo? = nil, configSnapshotDeliveryInfo: ConfigExportDeliveryInfo? = nil, configStreamDeliveryInfo: ConfigStreamDeliveryInfo? = nil, name: String? = nil) {
            self.configHistoryDeliveryInfo = configHistoryDeliveryInfo
            self.configSnapshotDeliveryInfo = configSnapshotDeliveryInfo
            self.configStreamDeliveryInfo = configStreamDeliveryInfo
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case configHistoryDeliveryInfo = "configHistoryDeliveryInfo"
            case configSnapshotDeliveryInfo = "configSnapshotDeliveryInfo"
            case configStreamDeliveryInfo = "configStreamDeliveryInfo"
            case name = "name"
        }
    }

    public struct DescribeAggregateComplianceByConfigRulesRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the results by ConfigRuleComplianceFilters object.
        ///
        public let filters: ConfigRuleComplianceFilters?
        /// The maximum number of evaluation results returned on each page.
        /// 			The default is
        /// 			maximum.
        /// 			If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configurationAggregatorName: String, filters: ConfigRuleComplianceFilters? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 1000)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAggregateComplianceByConfigRulesResponse: AWSDecodableShape {
        /// Returns a list of AggregateComplianceByConfigRule
        /// 			object.
        public let aggregateComplianceByConfigRules: [AggregateComplianceByConfigRule]?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(aggregateComplianceByConfigRules: [AggregateComplianceByConfigRule]? = nil, nextToken: String? = nil) {
            self.aggregateComplianceByConfigRules = aggregateComplianceByConfigRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateComplianceByConfigRules = "AggregateComplianceByConfigRules"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAggregateComplianceByConformancePacksRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the result by AggregateConformancePackComplianceFilters object.
        public let filters: AggregateConformancePackComplianceFilters?
        /// The maximum number of conformance packs compliance details returned on each page. The default is maximum. If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configurationAggregatorName: String, filters: AggregateConformancePackComplianceFilters? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAggregateComplianceByConformancePacksResponse: AWSDecodableShape {
        /// Returns the AggregateComplianceByConformancePack object.
        public let aggregateComplianceByConformancePacks: [AggregateComplianceByConformancePack]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(aggregateComplianceByConformancePacks: [AggregateComplianceByConformancePack]? = nil, nextToken: String? = nil) {
            self.aggregateComplianceByConformancePacks = aggregateComplianceByConformancePacks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateComplianceByConformancePacks = "AggregateComplianceByConformancePacks"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAggregationAuthorizationsRequest: AWSEncodableShape {
        /// The maximum number of AggregationAuthorizations returned on
        /// 			each page. The default is maximum. If you specify 0, Config uses
        /// 			the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(limit: Int? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAggregationAuthorizationsResponse: AWSDecodableShape {
        /// Returns a list of authorizations granted to various aggregator
        /// 			accounts and regions.
        public let aggregationAuthorizations: [AggregationAuthorization]?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(aggregationAuthorizations: [AggregationAuthorization]? = nil, nextToken: String? = nil) {
            self.aggregationAuthorizations = aggregationAuthorizations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationAuthorizations = "AggregationAuthorizations"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeComplianceByConfigRuleRequest: AWSEncodableShape {
        /// Filters the results by compliance.
        public let complianceTypes: [ComplianceType]?
        /// Specify one or more Config rule names to filter the results
        /// 			by rule.
        public let configRuleNames: [String]?
        /// The nextToken string returned on a previous page
        /// 			that you use to get the next page of results in a paginated
        /// 			response.
        public let nextToken: String?

        @inlinable
        public init(complianceTypes: [ComplianceType]? = nil, configRuleNames: [String]? = nil, nextToken: String? = nil) {
            self.complianceTypes = complianceTypes
            self.configRuleNames = configRuleNames
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, max: 3)
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 128)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
                try validate($0, name: "configRuleNames[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceTypes = "ComplianceTypes"
            case configRuleNames = "ConfigRuleNames"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeComplianceByConfigRuleResponse: AWSDecodableShape {
        /// Indicates whether each of the specified Config rules is
        /// 			compliant.
        public let complianceByConfigRules: [ComplianceByConfigRule]?
        /// The string that you use in a subsequent request to get the next
        /// 			page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(complianceByConfigRules: [ComplianceByConfigRule]? = nil, nextToken: String? = nil) {
            self.complianceByConfigRules = complianceByConfigRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case complianceByConfigRules = "ComplianceByConfigRules"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeComplianceByResourceRequest: AWSEncodableShape {
        /// Filters the results by compliance.
        public let complianceTypes: [ComplianceType]?
        /// The maximum number of evaluation results returned on each page.
        /// 			The default is 10. You cannot specify a number greater than 100. If
        /// 			you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page
        /// 			that you use to get the next page of results in a paginated
        /// 			response.
        public let nextToken: String?
        /// The ID of the Amazon Web Services resource for which you want compliance
        /// 			information. You can specify only one resource ID. If you specify a
        /// 			resource ID, you must also specify a type for
        /// 				ResourceType.
        public let resourceId: String?
        /// The types of Amazon Web Services resources for which you want compliance
        /// 			information (for example, AWS::EC2::Instance). For this operation, you can specify that the resource type is an Amazon Web Services account by
        /// 			specifying AWS::::Account.
        public let resourceType: String?

        @inlinable
        public init(complianceTypes: [ComplianceType]? = nil, limit: Int? = nil, nextToken: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.complianceTypes = complianceTypes
            self.limit = limit
            self.nextToken = nextToken
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, max: 3)
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceTypes = "ComplianceTypes"
            case limit = "Limit"
            case nextToken = "NextToken"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct DescribeComplianceByResourceResponse: AWSDecodableShape {
        /// Indicates whether the specified Amazon Web Services resource complies with all
        /// 			of the Config rules that evaluate it.
        public let complianceByResources: [ComplianceByResource]?
        /// The string that you use in a subsequent request to get the next
        /// 			page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(complianceByResources: [ComplianceByResource]? = nil, nextToken: String? = nil) {
            self.complianceByResources = complianceByResources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case complianceByResources = "ComplianceByResources"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigRuleEvaluationStatusRequest: AWSEncodableShape {
        /// The name of the Config managed rules for which you want
        /// 			status information. If you do not specify any names, Config
        /// 			returns status information for all Config managed rules that you
        /// 			use.
        public let configRuleNames: [String]?
        /// The number of rule evaluation results that you want
        /// 			returned. This parameter is required if the rule limit for your account
        /// 			is more than the default of 1000 rules. For information about requesting a rule limit increase, see
        /// 				Config Limits in the Amazon Web Services General
        /// 				Reference Guide.
        public let limit: Int?
        /// The nextToken string returned on a previous page
        /// 			that you use to get the next page of results in a paginated
        /// 			response.
        public let nextToken: String?

        @inlinable
        public init(configRuleNames: [String]? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configRuleNames = configRuleNames
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 128)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
                try validate($0, name: "configRuleNames[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 25)
            try self.validate(self.limit, name: "limit", parent: name, max: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleNames = "ConfigRuleNames"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigRuleEvaluationStatusResponse: AWSDecodableShape {
        /// Status information about your Config managed rules.
        public let configRulesEvaluationStatus: [ConfigRuleEvaluationStatus]?
        /// The string that you use in a subsequent request to get the next
        /// 			page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configRulesEvaluationStatus: [ConfigRuleEvaluationStatus]? = nil, nextToken: String? = nil) {
            self.configRulesEvaluationStatus = configRulesEvaluationStatus
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configRulesEvaluationStatus = "ConfigRulesEvaluationStatus"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigRulesFilters: AWSEncodableShape {
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public let evaluationMode: EvaluationMode?

        @inlinable
        public init(evaluationMode: EvaluationMode? = nil) {
            self.evaluationMode = evaluationMode
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationMode = "EvaluationMode"
        }
    }

    public struct DescribeConfigRulesRequest: AWSEncodableShape {
        /// The names of the Config rules for which you want details.
        /// 			If you do not specify any names, Config returns details for all
        /// 			your rules.
        public let configRuleNames: [String]?
        /// Returns a list of Detective or Proactive Config rules. By default, this API returns an unfiltered list. For more information on Detective or Proactive Config rules,
        /// 			see  Evaluation Mode in the Config Developer Guide.
        public let filters: DescribeConfigRulesFilters?
        /// The nextToken string returned on a previous page
        /// 			that you use to get the next page of results in a paginated
        /// 			response.
        public let nextToken: String?

        @inlinable
        public init(configRuleNames: [String]? = nil, filters: DescribeConfigRulesFilters? = nil, nextToken: String? = nil) {
            self.configRuleNames = configRuleNames
            self.filters = filters
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 128)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
                try validate($0, name: "configRuleNames[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleNames = "ConfigRuleNames"
            case filters = "Filters"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigRulesResponse: AWSDecodableShape {
        /// The details about your Config rules.
        public let configRules: [ConfigRule]?
        /// The string that you use in a subsequent request to get the next
        /// 			page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configRules: [ConfigRule]? = nil, nextToken: String? = nil) {
            self.configRules = configRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configRules = "ConfigRules"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationAggregatorSourcesStatusRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// The maximum number of AggregatorSourceStatus returned on each
        /// 			page. The default is maximum. If you specify 0, Config uses the
        /// 			default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Filters the status type.   Valid value FAILED indicates errors while moving
        /// 					data.   Valid value SUCCEEDED indicates the data was
        /// 					successfully moved.   Valid value OUTDATED indicates the data is not the most
        /// 					recent.
        public let updateStatus: [AggregatedSourceStatusType]?

        @inlinable
        public init(configurationAggregatorName: String, limit: Int? = nil, nextToken: String? = nil, updateStatus: [AggregatedSourceStatusType]? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.limit = limit
            self.nextToken = nextToken
            self.updateStatus = updateStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.updateStatus, name: "updateStatus", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case limit = "Limit"
            case nextToken = "NextToken"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct DescribeConfigurationAggregatorSourcesStatusResponse: AWSDecodableShape {
        /// Returns an AggregatedSourceStatus object.
        ///
        public let aggregatedSourceStatusList: [AggregatedSourceStatus]?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(aggregatedSourceStatusList: [AggregatedSourceStatus]? = nil, nextToken: String? = nil) {
            self.aggregatedSourceStatusList = aggregatedSourceStatusList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedSourceStatusList = "AggregatedSourceStatusList"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationAggregatorsRequest: AWSEncodableShape {
        /// The name of the configuration aggregators.
        public let configurationAggregatorNames: [String]?
        /// The maximum number of configuration aggregators returned on
        /// 			each page. The default is maximum. If you specify 0, Config uses
        /// 			the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configurationAggregatorNames: [String]? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorNames = configurationAggregatorNames
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.configurationAggregatorNames?.forEach {
                try validate($0, name: "configurationAggregatorNames[]", parent: name, max: 256)
                try validate($0, name: "configurationAggregatorNames[]", parent: name, min: 1)
                try validate($0, name: "configurationAggregatorNames[]", parent: name, pattern: "^[\\w\\-]+$")
            }
            try self.validate(self.configurationAggregatorNames, name: "configurationAggregatorNames", parent: name, max: 10)
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorNames = "ConfigurationAggregatorNames"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationAggregatorsResponse: AWSDecodableShape {
        /// Returns a ConfigurationAggregators object.
        public let configurationAggregators: [ConfigurationAggregator]?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configurationAggregators: [ConfigurationAggregator]? = nil, nextToken: String? = nil) {
            self.configurationAggregators = configurationAggregators
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregators = "ConfigurationAggregators"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationRecorderStatusRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the configuration recorder that you want to specify.
        public let arn: String?
        /// The name of the configuration recorder. If the name is not
        /// 			specified, the opertation returns the status for the customer managed configuration recorder configured for the
        /// 			account, if applicable.  When making a request to this operation, you can only specify one configuration recorder.
        public let configurationRecorderNames: [String]?
        /// For service-linked configuration recorders, you can use the service principal of the linked Amazon Web Services service to specify the configuration recorder.
        public let servicePrincipal: String?

        @inlinable
        public init(arn: String? = nil, configurationRecorderNames: [String]? = nil, servicePrincipal: String? = nil) {
            self.arn = arn
            self.configurationRecorderNames = configurationRecorderNames
            self.servicePrincipal = servicePrincipal
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.configurationRecorderNames?.forEach {
                try validate($0, name: "configurationRecorderNames[]", parent: name, max: 256)
                try validate($0, name: "configurationRecorderNames[]", parent: name, min: 1)
            }
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, max: 128)
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, min: 1)
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, pattern: "^[\\w+=,.@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case configurationRecorderNames = "ConfigurationRecorderNames"
            case servicePrincipal = "ServicePrincipal"
        }
    }

    public struct DescribeConfigurationRecorderStatusResponse: AWSDecodableShape {
        /// A list that contains status of the specified
        /// 			recorders.
        public let configurationRecordersStatus: [ConfigurationRecorderStatus]?

        @inlinable
        public init(configurationRecordersStatus: [ConfigurationRecorderStatus]? = nil) {
            self.configurationRecordersStatus = configurationRecordersStatus
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecordersStatus = "ConfigurationRecordersStatus"
        }
    }

    public struct DescribeConfigurationRecordersRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the configuration recorder that you want to specify.
        public let arn: String?
        /// A list of names of the configuration recorders that you want to specify.
        public let configurationRecorderNames: [String]?
        /// For service-linked configuration recorders, you can use the service principal of the linked Amazon Web Services service to specify the configuration recorder.
        public let servicePrincipal: String?

        @inlinable
        public init(arn: String? = nil, configurationRecorderNames: [String]? = nil, servicePrincipal: String? = nil) {
            self.arn = arn
            self.configurationRecorderNames = configurationRecorderNames
            self.servicePrincipal = servicePrincipal
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.configurationRecorderNames?.forEach {
                try validate($0, name: "configurationRecorderNames[]", parent: name, max: 256)
                try validate($0, name: "configurationRecorderNames[]", parent: name, min: 1)
            }
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, max: 128)
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, min: 1)
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, pattern: "^[\\w+=,.@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case configurationRecorderNames = "ConfigurationRecorderNames"
            case servicePrincipal = "ServicePrincipal"
        }
    }

    public struct DescribeConfigurationRecordersResponse: AWSDecodableShape {
        /// A list that contains the descriptions of the specified
        /// 			configuration recorders.
        public let configurationRecorders: [ConfigurationRecorder]?

        @inlinable
        public init(configurationRecorders: [ConfigurationRecorder]? = nil) {
            self.configurationRecorders = configurationRecorders
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorders = "ConfigurationRecorders"
        }
    }

    public struct DescribeConformancePackComplianceRequest: AWSEncodableShape {
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// A ConformancePackComplianceFilters object.
        public let filters: ConformancePackComplianceFilters?
        /// The maximum number of Config rules within a conformance pack are returned on each page.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(conformancePackName: String, filters: ConformancePackComplianceFilters? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.conformancePackName = conformancePackName
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, max: 256)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 1000)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackName = "ConformancePackName"
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConformancePackComplianceResponse: AWSDecodableShape {
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// Returns a list of ConformancePackRuleCompliance objects.
        public let conformancePackRuleComplianceList: [ConformancePackRuleCompliance]
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(conformancePackName: String, conformancePackRuleComplianceList: [ConformancePackRuleCompliance], nextToken: String? = nil) {
            self.conformancePackName = conformancePackName
            self.conformancePackRuleComplianceList = conformancePackRuleComplianceList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackName = "ConformancePackName"
            case conformancePackRuleComplianceList = "ConformancePackRuleComplianceList"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConformancePackStatusRequest: AWSEncodableShape {
        /// Comma-separated list of conformance pack names.
        public let conformancePackNames: [String]?
        /// The maximum number of conformance packs status returned on each page.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(conformancePackNames: [String]? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.conformancePackNames = conformancePackNames
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.conformancePackNames?.forEach {
                try validate($0, name: "conformancePackNames[]", parent: name, max: 256)
                try validate($0, name: "conformancePackNames[]", parent: name, min: 1)
                try validate($0, name: "conformancePackNames[]", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            }
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, max: 25)
            try self.validate(self.limit, name: "limit", parent: name, max: 20)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackNames = "ConformancePackNames"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConformancePackStatusResponse: AWSDecodableShape {
        /// A list of ConformancePackStatusDetail objects.
        public let conformancePackStatusDetails: [ConformancePackStatusDetail]?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(conformancePackStatusDetails: [ConformancePackStatusDetail]? = nil, nextToken: String? = nil) {
            self.conformancePackStatusDetails = conformancePackStatusDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackStatusDetails = "ConformancePackStatusDetails"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConformancePacksRequest: AWSEncodableShape {
        /// Comma-separated list of conformance pack names for which you want details. If you do not specify any names, Config returns details for all your conformance packs.
        public let conformancePackNames: [String]?
        /// The maximum number of conformance packs returned on each page.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(conformancePackNames: [String]? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.conformancePackNames = conformancePackNames
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.conformancePackNames?.forEach {
                try validate($0, name: "conformancePackNames[]", parent: name, max: 256)
                try validate($0, name: "conformancePackNames[]", parent: name, min: 1)
                try validate($0, name: "conformancePackNames[]", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            }
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, max: 25)
            try self.validate(self.limit, name: "limit", parent: name, max: 20)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackNames = "ConformancePackNames"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConformancePacksResponse: AWSDecodableShape {
        /// Returns a list of ConformancePackDetail objects.
        public let conformancePackDetails: [ConformancePackDetail]?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(conformancePackDetails: [ConformancePackDetail]? = nil, nextToken: String? = nil) {
            self.conformancePackDetails = conformancePackDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackDetails = "ConformancePackDetails"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeDeliveryChannelStatusRequest: AWSEncodableShape {
        /// A list of delivery channel names.
        public let deliveryChannelNames: [String]?

        @inlinable
        public init(deliveryChannelNames: [String]? = nil) {
            self.deliveryChannelNames = deliveryChannelNames
        }

        public func validate(name: String) throws {
            try self.deliveryChannelNames?.forEach {
                try validate($0, name: "deliveryChannelNames[]", parent: name, max: 256)
                try validate($0, name: "deliveryChannelNames[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannelNames = "DeliveryChannelNames"
        }
    }

    public struct DescribeDeliveryChannelStatusResponse: AWSDecodableShape {
        /// A list that contains the status of a specified delivery
        /// 			channel.
        public let deliveryChannelsStatus: [DeliveryChannelStatus]?

        @inlinable
        public init(deliveryChannelsStatus: [DeliveryChannelStatus]? = nil) {
            self.deliveryChannelsStatus = deliveryChannelsStatus
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannelsStatus = "DeliveryChannelsStatus"
        }
    }

    public struct DescribeDeliveryChannelsRequest: AWSEncodableShape {
        /// A list of delivery channel names.
        public let deliveryChannelNames: [String]?

        @inlinable
        public init(deliveryChannelNames: [String]? = nil) {
            self.deliveryChannelNames = deliveryChannelNames
        }

        public func validate(name: String) throws {
            try self.deliveryChannelNames?.forEach {
                try validate($0, name: "deliveryChannelNames[]", parent: name, max: 256)
                try validate($0, name: "deliveryChannelNames[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannelNames = "DeliveryChannelNames"
        }
    }

    public struct DescribeDeliveryChannelsResponse: AWSDecodableShape {
        /// A list that contains the descriptions of the specified delivery
        /// 			channel.
        public let deliveryChannels: [DeliveryChannel]?

        @inlinable
        public init(deliveryChannels: [DeliveryChannel]? = nil) {
            self.deliveryChannels = deliveryChannels
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannels = "DeliveryChannels"
        }
    }

    public struct DescribeOrganizationConfigRuleStatusesRequest: AWSEncodableShape {
        /// The maximum number of OrganizationConfigRuleStatuses returned on each page. If you do no specify a number, Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The names of organization Config rules for which you want status details. If you do not specify any names, Config returns details for all your organization Config rules.
        public let organizationConfigRuleNames: [String]?

        @inlinable
        public init(limit: Int? = nil, nextToken: String? = nil, organizationConfigRuleNames: [String]? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConfigRuleNames = organizationConfigRuleNames
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.organizationConfigRuleNames?.forEach {
                try validate($0, name: "organizationConfigRuleNames[]", parent: name, max: 64)
                try validate($0, name: "organizationConfigRuleNames[]", parent: name, min: 1)
            }
            try self.validate(self.organizationConfigRuleNames, name: "organizationConfigRuleNames", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConfigRuleNames = "OrganizationConfigRuleNames"
        }
    }

    public struct DescribeOrganizationConfigRuleStatusesResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of OrganizationConfigRuleStatus objects.
        public let organizationConfigRuleStatuses: [OrganizationConfigRuleStatus]?

        @inlinable
        public init(nextToken: String? = nil, organizationConfigRuleStatuses: [OrganizationConfigRuleStatus]? = nil) {
            self.nextToken = nextToken
            self.organizationConfigRuleStatuses = organizationConfigRuleStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConfigRuleStatuses = "OrganizationConfigRuleStatuses"
        }
    }

    public struct DescribeOrganizationConfigRulesRequest: AWSEncodableShape {
        /// The maximum number of organization Config rules returned on each page. If you do no specify a number, Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The names of organization Config rules for which you want details. If you do not specify any names, Config returns details for all your organization Config rules.
        public let organizationConfigRuleNames: [String]?

        @inlinable
        public init(limit: Int? = nil, nextToken: String? = nil, organizationConfigRuleNames: [String]? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConfigRuleNames = organizationConfigRuleNames
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.organizationConfigRuleNames?.forEach {
                try validate($0, name: "organizationConfigRuleNames[]", parent: name, max: 64)
                try validate($0, name: "organizationConfigRuleNames[]", parent: name, min: 1)
            }
            try self.validate(self.organizationConfigRuleNames, name: "organizationConfigRuleNames", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConfigRuleNames = "OrganizationConfigRuleNames"
        }
    }

    public struct DescribeOrganizationConfigRulesResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a list of OrganizationConfigRule objects.
        public let organizationConfigRules: [OrganizationConfigRule]?

        @inlinable
        public init(nextToken: String? = nil, organizationConfigRules: [OrganizationConfigRule]? = nil) {
            self.nextToken = nextToken
            self.organizationConfigRules = organizationConfigRules
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConfigRules = "OrganizationConfigRules"
        }
    }

    public struct DescribeOrganizationConformancePackStatusesRequest: AWSEncodableShape {
        /// The maximum number of OrganizationConformancePackStatuses returned on each page.
        /// 			If you do no specify a number, Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The names of organization conformance packs for which you want status details.
        /// 			If you do not specify any names, Config returns details for all your organization conformance packs.
        public let organizationConformancePackNames: [String]?

        @inlinable
        public init(limit: Int? = nil, nextToken: String? = nil, organizationConformancePackNames: [String]? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConformancePackNames = organizationConformancePackNames
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.organizationConformancePackNames?.forEach {
                try validate($0, name: "organizationConformancePackNames[]", parent: name, max: 128)
                try validate($0, name: "organizationConformancePackNames[]", parent: name, min: 1)
                try validate($0, name: "organizationConformancePackNames[]", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            }
            try self.validate(self.organizationConformancePackNames, name: "organizationConformancePackNames", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConformancePackNames = "OrganizationConformancePackNames"
        }
    }

    public struct DescribeOrganizationConformancePackStatusesResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of OrganizationConformancePackStatus objects.
        public let organizationConformancePackStatuses: [OrganizationConformancePackStatus]?

        @inlinable
        public init(nextToken: String? = nil, organizationConformancePackStatuses: [OrganizationConformancePackStatus]? = nil) {
            self.nextToken = nextToken
            self.organizationConformancePackStatuses = organizationConformancePackStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConformancePackStatuses = "OrganizationConformancePackStatuses"
        }
    }

    public struct DescribeOrganizationConformancePacksRequest: AWSEncodableShape {
        /// The maximum number of organization config packs returned on each page. If you do no specify a
        /// 			number, Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a
        /// 			paginated response.
        public let nextToken: String?
        /// The name that you assign to an organization conformance pack.
        public let organizationConformancePackNames: [String]?

        @inlinable
        public init(limit: Int? = nil, nextToken: String? = nil, organizationConformancePackNames: [String]? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConformancePackNames = organizationConformancePackNames
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.organizationConformancePackNames?.forEach {
                try validate($0, name: "organizationConformancePackNames[]", parent: name, max: 128)
                try validate($0, name: "organizationConformancePackNames[]", parent: name, min: 1)
                try validate($0, name: "organizationConformancePackNames[]", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            }
            try self.validate(self.organizationConformancePackNames, name: "organizationConformancePackNames", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConformancePackNames = "OrganizationConformancePackNames"
        }
    }

    public struct DescribeOrganizationConformancePacksResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a
        /// 			paginated response.
        public let nextToken: String?
        /// Returns a list of OrganizationConformancePacks objects.
        public let organizationConformancePacks: [OrganizationConformancePack]?

        @inlinable
        public init(nextToken: String? = nil, organizationConformancePacks: [OrganizationConformancePack]? = nil) {
            self.nextToken = nextToken
            self.organizationConformancePacks = organizationConformancePacks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConformancePacks = "OrganizationConformancePacks"
        }
    }

    public struct DescribePendingAggregationRequestsRequest: AWSEncodableShape {
        /// The maximum number of evaluation results returned on each page.
        /// 			The default is maximum. If you specify 0, Config uses the
        /// 			default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(limit: Int? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 20)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribePendingAggregationRequestsResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a PendingAggregationRequests object.
        public let pendingAggregationRequests: [PendingAggregationRequest]?

        @inlinable
        public init(nextToken: String? = nil, pendingAggregationRequests: [PendingAggregationRequest]? = nil) {
            self.nextToken = nextToken
            self.pendingAggregationRequests = pendingAggregationRequests
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pendingAggregationRequests = "PendingAggregationRequests"
        }
    }

    public struct DescribeRemediationConfigurationsRequest: AWSEncodableShape {
        /// A list of Config rule names of remediation configurations for which you want details.
        public let configRuleNames: [String]

        @inlinable
        public init(configRuleNames: [String]) {
            self.configRuleNames = configRuleNames
        }

        public func validate(name: String) throws {
            try self.configRuleNames.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 128)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
                try validate($0, name: "configRuleNames[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleNames = "ConfigRuleNames"
        }
    }

    public struct DescribeRemediationConfigurationsResponse: AWSDecodableShape {
        /// Returns a remediation configuration object.
        public let remediationConfigurations: [RemediationConfiguration]?

        @inlinable
        public init(remediationConfigurations: [RemediationConfiguration]? = nil) {
            self.remediationConfigurations = remediationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case remediationConfigurations = "RemediationConfigurations"
        }
    }

    public struct DescribeRemediationExceptionsRequest: AWSEncodableShape {
        /// The name of the Config rule.
        public let configRuleName: String
        /// The maximum number of RemediationExceptionResourceKey returned on each page. The default is 25. If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?
        /// An exception list of resource exception keys to be processed with the current request. Config adds exception for each resource key. For example, Config adds 3 exceptions for 3 resource keys.
        public let resourceKeys: [RemediationExceptionResourceKey]?

        @inlinable
        public init(configRuleName: String, limit: Int? = nil, nextToken: String? = nil, resourceKeys: [RemediationExceptionResourceKey]? = nil) {
            self.configRuleName = configRuleName
            self.limit = limit
            self.nextToken = nextToken
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.resourceKeys?.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case limit = "Limit"
            case nextToken = "NextToken"
            case resourceKeys = "ResourceKeys"
        }
    }

    public struct DescribeRemediationExceptionsResponse: AWSDecodableShape {
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a list of remediation exception objects.
        public let remediationExceptions: [RemediationException]?

        @inlinable
        public init(nextToken: String? = nil, remediationExceptions: [RemediationException]? = nil) {
            self.nextToken = nextToken
            self.remediationExceptions = remediationExceptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case remediationExceptions = "RemediationExceptions"
        }
    }

    public struct DescribeRemediationExecutionStatusRequest: AWSEncodableShape {
        /// The name of the Config rule.
        public let configRuleName: String
        /// The maximum number of RemediationExecutionStatuses returned on each page. The default is maximum. If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID.
        public let resourceKeys: [ResourceKey]?

        @inlinable
        public init(configRuleName: String, limit: Int? = nil, nextToken: String? = nil, resourceKeys: [ResourceKey]? = nil) {
            self.configRuleName = configRuleName
            self.limit = limit
            self.nextToken = nextToken
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.resourceKeys?.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case limit = "Limit"
            case nextToken = "NextToken"
            case resourceKeys = "ResourceKeys"
        }
    }

    public struct DescribeRemediationExecutionStatusResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a list of remediation execution statuses objects.
        public let remediationExecutionStatuses: [RemediationExecutionStatus]?

        @inlinable
        public init(nextToken: String? = nil, remediationExecutionStatuses: [RemediationExecutionStatus]? = nil) {
            self.nextToken = nextToken
            self.remediationExecutionStatuses = remediationExecutionStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case remediationExecutionStatuses = "RemediationExecutionStatuses"
        }
    }

    public struct DescribeRetentionConfigurationsRequest: AWSEncodableShape {
        /// The nextToken string returned on a previous page
        /// 			that you use to get the next page of results in a paginated
        /// 			response.
        public let nextToken: String?
        /// A list of names of retention configurations for which you want
        /// 			details. If you do not specify a name, Config returns details
        /// 			for all the retention configurations for that account.  Currently, Config supports only one retention
        /// 				configuration per region in your account.
        public let retentionConfigurationNames: [String]?

        @inlinable
        public init(nextToken: String? = nil, retentionConfigurationNames: [String]? = nil) {
            self.nextToken = nextToken
            self.retentionConfigurationNames = retentionConfigurationNames
        }

        public func validate(name: String) throws {
            try self.retentionConfigurationNames?.forEach {
                try validate($0, name: "retentionConfigurationNames[]", parent: name, max: 256)
                try validate($0, name: "retentionConfigurationNames[]", parent: name, min: 1)
                try validate($0, name: "retentionConfigurationNames[]", parent: name, pattern: "^[\\w\\-]+$")
            }
            try self.validate(self.retentionConfigurationNames, name: "retentionConfigurationNames", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case retentionConfigurationNames = "RetentionConfigurationNames"
        }
    }

    public struct DescribeRetentionConfigurationsResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page
        /// 			that you use to get the next page of results in a paginated
        /// 			response.
        public let nextToken: String?
        /// Returns a retention configuration object.
        public let retentionConfigurations: [RetentionConfiguration]?

        @inlinable
        public init(nextToken: String? = nil, retentionConfigurations: [RetentionConfiguration]? = nil) {
            self.nextToken = nextToken
            self.retentionConfigurations = retentionConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case retentionConfigurations = "RetentionConfigurations"
        }
    }

    public struct DisassociateResourceTypesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the specified configuration recorder.
        public let configurationRecorderArn: String
        /// The list of resource types you want to remove from the recording group of the specified configuration recorder.
        public let resourceTypes: [ResourceType]

        @inlinable
        public init(configurationRecorderArn: String, resourceTypes: [ResourceType]) {
            self.configurationRecorderArn = configurationRecorderArn
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationRecorderArn, name: "configurationRecorderArn", parent: name, max: 1000)
            try self.validate(self.configurationRecorderArn, name: "configurationRecorderArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorderArn = "ConfigurationRecorderArn"
            case resourceTypes = "ResourceTypes"
        }
    }

    public struct DisassociateResourceTypesResponse: AWSDecodableShape {
        public let configurationRecorder: ConfigurationRecorder

        @inlinable
        public init(configurationRecorder: ConfigurationRecorder) {
            self.configurationRecorder = configurationRecorder
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorder = "ConfigurationRecorder"
        }
    }

    public struct Evaluation: AWSEncodableShape & AWSDecodableShape {
        /// Supplementary information about how the evaluation determined
        /// 			the compliance.
        public let annotation: String?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public let complianceResourceId: String
        /// The type of Amazon Web Services resource that was evaluated.
        public let complianceResourceType: String
        /// Indicates whether the Amazon Web Services resource complies with the Config
        /// 			rule that it was evaluated against. For the Evaluation data type, Config supports
        /// 			only the COMPLIANT, NON_COMPLIANT, and
        /// 				NOT_APPLICABLE values. Config does not support
        /// 			the INSUFFICIENT_DATA value for this data
        /// 			type. Similarly, Config does not accept
        /// 				INSUFFICIENT_DATA as the value for
        /// 				ComplianceType from a PutEvaluations
        /// 			request. For example, an Lambda function for a custom Config
        /// 			rule cannot pass an INSUFFICIENT_DATA value to Config.
        public let complianceType: ComplianceType
        /// The time of the event in Config that triggered the
        /// 			evaluation. For event-based evaluations, the time indicates when Config created the configuration item that triggered the evaluation.
        /// 			For periodic evaluations, the time indicates when Config
        /// 			triggered the evaluation at the frequency that you specified (for
        /// 			example, every 24 hours).
        public let orderingTimestamp: Date

        @inlinable
        public init(annotation: String? = nil, complianceResourceId: String, complianceResourceType: String, complianceType: ComplianceType, orderingTimestamp: Date) {
            self.annotation = annotation
            self.complianceResourceId = complianceResourceId
            self.complianceResourceType = complianceResourceType
            self.complianceType = complianceType
            self.orderingTimestamp = orderingTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.annotation, name: "annotation", parent: name, max: 256)
            try self.validate(self.annotation, name: "annotation", parent: name, min: 1)
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, max: 768)
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, min: 1)
            try self.validate(self.complianceResourceType, name: "complianceResourceType", parent: name, max: 256)
            try self.validate(self.complianceResourceType, name: "complianceResourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case annotation = "Annotation"
            case complianceResourceId = "ComplianceResourceId"
            case complianceResourceType = "ComplianceResourceType"
            case complianceType = "ComplianceType"
            case orderingTimestamp = "OrderingTimestamp"
        }
    }

    public struct EvaluationContext: AWSEncodableShape & AWSDecodableShape {
        /// A unique EvaluationContextIdentifier ID for an EvaluationContext.
        public let evaluationContextIdentifier: String?

        @inlinable
        public init(evaluationContextIdentifier: String? = nil) {
            self.evaluationContextIdentifier = evaluationContextIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluationContextIdentifier, name: "evaluationContextIdentifier", parent: name, max: 128)
            try self.validate(self.evaluationContextIdentifier, name: "evaluationContextIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationContextIdentifier = "EvaluationContextIdentifier"
        }
    }

    public struct EvaluationModeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public let mode: EvaluationMode?

        @inlinable
        public init(mode: EvaluationMode? = nil) {
            self.mode = mode
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct EvaluationResult: AWSDecodableShape {
        /// Supplementary information about how the evaluation determined
        /// 			the compliance.
        public let annotation: String?
        /// Indicates whether the Amazon Web Services resource complies with the Config
        /// 			rule that evaluated it. For the EvaluationResult data type, Config
        /// 			supports only the COMPLIANT,
        /// 			NON_COMPLIANT, and NOT_APPLICABLE values.
        /// 			Config does not support the INSUFFICIENT_DATA value
        /// 			for the EvaluationResult data type.
        public let complianceType: ComplianceType?
        /// The time when the Config rule evaluated the Amazon Web Services
        /// 			resource.
        public let configRuleInvokedTime: Date?
        /// Uniquely identifies the evaluation result.
        public let evaluationResultIdentifier: EvaluationResultIdentifier?
        /// The time when Config recorded the evaluation
        /// 			result.
        public let resultRecordedTime: Date?
        /// An encrypted token that associates an evaluation with an Config rule. The token identifies the rule, the Amazon Web Services resource being
        /// 			evaluated, and the event that triggered the evaluation.
        public let resultToken: String?

        @inlinable
        public init(annotation: String? = nil, complianceType: ComplianceType? = nil, configRuleInvokedTime: Date? = nil, evaluationResultIdentifier: EvaluationResultIdentifier? = nil, resultRecordedTime: Date? = nil, resultToken: String? = nil) {
            self.annotation = annotation
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
            self.resultToken = resultToken
        }

        private enum CodingKeys: String, CodingKey {
            case annotation = "Annotation"
            case complianceType = "ComplianceType"
            case configRuleInvokedTime = "ConfigRuleInvokedTime"
            case evaluationResultIdentifier = "EvaluationResultIdentifier"
            case resultRecordedTime = "ResultRecordedTime"
            case resultToken = "ResultToken"
        }
    }

    public struct EvaluationResultIdentifier: AWSDecodableShape {
        /// Identifies an Config rule used to evaluate an Amazon Web Services resource,
        /// 			and provides the type and ID of the evaluated resource.
        public let evaluationResultQualifier: EvaluationResultQualifier?
        /// The time of the event that triggered the evaluation of your Amazon Web Services
        /// 			resources. The time can indicate when Config delivered a
        /// 			configuration item change notification, or it can indicate when Config delivered the configuration snapshot, depending on which
        /// 			event triggered the evaluation.
        public let orderingTimestamp: Date?
        /// A Unique ID for an evaluation result.
        public let resourceEvaluationId: String?

        @inlinable
        public init(evaluationResultQualifier: EvaluationResultQualifier? = nil, orderingTimestamp: Date? = nil, resourceEvaluationId: String? = nil) {
            self.evaluationResultQualifier = evaluationResultQualifier
            self.orderingTimestamp = orderingTimestamp
            self.resourceEvaluationId = resourceEvaluationId
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationResultQualifier = "EvaluationResultQualifier"
            case orderingTimestamp = "OrderingTimestamp"
            case resourceEvaluationId = "ResourceEvaluationId"
        }
    }

    public struct EvaluationResultQualifier: AWSDecodableShape {
        /// The name of the Config rule that was used in the
        /// 			evaluation.
        public let configRuleName: String?
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public let evaluationMode: EvaluationMode?
        /// The ID of the evaluated Amazon Web Services resource.
        public let resourceId: String?
        /// The type of Amazon Web Services resource that was evaluated.
        public let resourceType: String?

        @inlinable
        public init(configRuleName: String? = nil, evaluationMode: EvaluationMode? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.configRuleName = configRuleName
            self.evaluationMode = evaluationMode
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case evaluationMode = "EvaluationMode"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct EvaluationStatus: AWSDecodableShape {
        /// An explanation for failed execution status.
        public let failureReason: String?
        /// The status of an execution. The valid values are In_Progress, Succeeded or Failed.
        public let status: ResourceEvaluationStatus

        @inlinable
        public init(failureReason: String? = nil, status: ResourceEvaluationStatus) {
            self.failureReason = failureReason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "FailureReason"
            case status = "Status"
        }
    }

    public struct ExclusionByResourceTypes: AWSEncodableShape & AWSDecodableShape {
        /// A comma-separated list of resource types to exclude from recording by the configuration
        /// 			recorder.
        public let resourceTypes: [ResourceType]?

        @inlinable
        public init(resourceTypes: [ResourceType]? = nil) {
            self.resourceTypes = resourceTypes
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTypes = "resourceTypes"
        }
    }

    public struct ExecutionControls: AWSEncodableShape & AWSDecodableShape {
        /// A SsmControls object.
        public let ssmControls: SsmControls?

        @inlinable
        public init(ssmControls: SsmControls? = nil) {
            self.ssmControls = ssmControls
        }

        public func validate(name: String) throws {
            try self.ssmControls?.validate(name: "\(name).ssmControls")
        }

        private enum CodingKeys: String, CodingKey {
            case ssmControls = "SsmControls"
        }
    }

    public struct ExternalEvaluation: AWSEncodableShape {
        /// Supplementary information about the reason of compliance. For example, this task was completed on a specific date.
        public let annotation: String?
        /// The evaluated compliance resource ID. Config accepts only Amazon Web Services account ID.
        public let complianceResourceId: String
        /// The evaluated compliance resource type. Config accepts AWS::::Account resource type.
        public let complianceResourceType: String
        /// The compliance of the Amazon Web Services resource. The valid values are COMPLIANT, NON_COMPLIANT,  and NOT_APPLICABLE.
        public let complianceType: ComplianceType
        /// The time when the compliance was recorded.
        public let orderingTimestamp: Date

        @inlinable
        public init(annotation: String? = nil, complianceResourceId: String, complianceResourceType: String, complianceType: ComplianceType, orderingTimestamp: Date) {
            self.annotation = annotation
            self.complianceResourceId = complianceResourceId
            self.complianceResourceType = complianceResourceType
            self.complianceType = complianceType
            self.orderingTimestamp = orderingTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.annotation, name: "annotation", parent: name, max: 256)
            try self.validate(self.annotation, name: "annotation", parent: name, min: 1)
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, max: 768)
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, min: 1)
            try self.validate(self.complianceResourceType, name: "complianceResourceType", parent: name, max: 256)
            try self.validate(self.complianceResourceType, name: "complianceResourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case annotation = "Annotation"
            case complianceResourceId = "ComplianceResourceId"
            case complianceResourceType = "ComplianceResourceType"
            case complianceType = "ComplianceType"
            case orderingTimestamp = "OrderingTimestamp"
        }
    }

    public struct FailedDeleteRemediationExceptionsBatch: AWSDecodableShape {
        /// Returns remediation exception resource key object of the failed items.
        public let failedItems: [RemediationExceptionResourceKey]?
        /// Returns a failure message for delete remediation exception. For example, Config creates an exception due to an internal error.
        public let failureMessage: String?

        @inlinable
        public init(failedItems: [RemediationExceptionResourceKey]? = nil, failureMessage: String? = nil) {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }

        private enum CodingKeys: String, CodingKey {
            case failedItems = "FailedItems"
            case failureMessage = "FailureMessage"
        }
    }

    public struct FailedRemediationBatch: AWSDecodableShape {
        /// Returns remediation configurations of the failed items.
        public let failedItems: [RemediationConfiguration]?
        /// Returns a failure message. For example, the resource is already compliant.
        public let failureMessage: String?

        @inlinable
        public init(failedItems: [RemediationConfiguration]? = nil, failureMessage: String? = nil) {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }

        private enum CodingKeys: String, CodingKey {
            case failedItems = "FailedItems"
            case failureMessage = "FailureMessage"
        }
    }

    public struct FailedRemediationExceptionBatch: AWSDecodableShape {
        /// Returns remediation exception resource key object of the failed items.
        public let failedItems: [RemediationException]?
        /// Returns a failure message. For example, the auto-remediation has failed.
        public let failureMessage: String?

        @inlinable
        public init(failedItems: [RemediationException]? = nil, failureMessage: String? = nil) {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }

        private enum CodingKeys: String, CodingKey {
            case failedItems = "FailedItems"
            case failureMessage = "FailureMessage"
        }
    }

    public struct FieldInfo: AWSDecodableShape {
        /// Name of the field.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetAggregateComplianceDetailsByConfigRuleRequest: AWSEncodableShape {
        /// The 12-digit account ID of the source account.
        public let accountId: String
        /// The source region from where the data is aggregated.
        public let awsRegion: String
        /// The resource compliance status.  For the
        /// 					GetAggregateComplianceDetailsByConfigRuleRequest
        /// 				data type, Config supports only the COMPLIANT
        /// 				and NON_COMPLIANT. Config does not support the
        /// 					NOT_APPLICABLE and
        /// 					INSUFFICIENT_DATA values.
        public let complianceType: ComplianceType?
        /// The name of the Config rule for which you want compliance
        /// 			information.
        public let configRuleName: String
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// The maximum number of evaluation results returned on each page.
        /// 			The default is 50. You cannot specify a number greater than 100. If
        /// 			you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(accountId: String, awsRegion: String, complianceType: ComplianceType? = nil, configRuleName: String, configurationAggregatorName: String, limit: Int? = nil, nextToken: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.configRuleName = configRuleName
            self.configurationAggregatorName = configurationAggregatorName
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 64)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case complianceType = "ComplianceType"
            case configRuleName = "ConfigRuleName"
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateComplianceDetailsByConfigRuleResponse: AWSDecodableShape {
        /// Returns an AggregateEvaluationResults object.
        public let aggregateEvaluationResults: [AggregateEvaluationResult]?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(aggregateEvaluationResults: [AggregateEvaluationResult]? = nil, nextToken: String? = nil) {
            self.aggregateEvaluationResults = aggregateEvaluationResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateEvaluationResults = "AggregateEvaluationResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateConfigRuleComplianceSummaryRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the results based on the
        /// 			ConfigRuleComplianceSummaryFilters object.
        public let filters: ConfigRuleComplianceSummaryFilters?
        /// Groups the result based on ACCOUNT_ID or AWS_REGION.
        public let groupByKey: ConfigRuleComplianceSummaryGroupKey?
        /// The maximum number of evaluation results returned on each page.
        /// 			The default is 1000. You cannot specify a number greater than 1000.
        /// 			If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configurationAggregatorName: String, filters: ConfigRuleComplianceSummaryFilters? = nil, groupByKey: ConfigRuleComplianceSummaryGroupKey? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.groupByKey = groupByKey
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 1000)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case groupByKey = "GroupByKey"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateConfigRuleComplianceSummaryResponse: AWSDecodableShape {
        /// Returns a list of AggregateComplianceCounts object.
        public let aggregateComplianceCounts: [AggregateComplianceCount]?
        /// Groups the result based on ACCOUNT_ID or AWS_REGION.
        public let groupByKey: String?
        /// The nextToken string returned on a previous page that you use
        /// 			to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(aggregateComplianceCounts: [AggregateComplianceCount]? = nil, groupByKey: String? = nil, nextToken: String? = nil) {
            self.aggregateComplianceCounts = aggregateComplianceCounts
            self.groupByKey = groupByKey
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateComplianceCounts = "AggregateComplianceCounts"
            case groupByKey = "GroupByKey"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateConformancePackComplianceSummaryRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the results based on the AggregateConformancePackComplianceSummaryFilters object.
        public let filters: AggregateConformancePackComplianceSummaryFilters?
        /// Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.
        public let groupByKey: AggregateConformancePackComplianceSummaryGroupKey?
        /// The maximum number of results returned on each page. The default is maximum. If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configurationAggregatorName: String, filters: AggregateConformancePackComplianceSummaryFilters? = nil, groupByKey: AggregateConformancePackComplianceSummaryGroupKey? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.groupByKey = groupByKey
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case groupByKey = "GroupByKey"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateConformancePackComplianceSummaryResponse: AWSDecodableShape {
        /// Returns a list of AggregateConformancePackComplianceSummary object.
        public let aggregateConformancePackComplianceSummaries: [AggregateConformancePackComplianceSummary]?
        /// Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.
        public let groupByKey: String?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(aggregateConformancePackComplianceSummaries: [AggregateConformancePackComplianceSummary]? = nil, groupByKey: String? = nil, nextToken: String? = nil) {
            self.aggregateConformancePackComplianceSummaries = aggregateConformancePackComplianceSummaries
            self.groupByKey = groupByKey
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateConformancePackComplianceSummaries = "AggregateConformancePackComplianceSummaries"
            case groupByKey = "GroupByKey"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateDiscoveredResourceCountsRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the results based on the ResourceCountFilters object.
        public let filters: ResourceCountFilters?
        /// The key to group the resource counts.
        public let groupByKey: ResourceCountGroupKey?
        /// The maximum number of GroupedResourceCount objects returned on each page. The default is 1000. You cannot specify a number greater than 1000. If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configurationAggregatorName: String, filters: ResourceCountFilters? = nil, groupByKey: ResourceCountGroupKey? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.groupByKey = groupByKey
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 1000)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case groupByKey = "GroupByKey"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateDiscoveredResourceCountsResponse: AWSDecodableShape {
        /// The key passed into the request object. If GroupByKey is not provided, the result will be empty.
        public let groupByKey: String?
        /// Returns a list of GroupedResourceCount objects.
        public let groupedResourceCounts: [GroupedResourceCount]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The total number of resources that are present in an aggregator with the filters that you provide.
        public let totalDiscoveredResources: Int64

        @inlinable
        public init(groupByKey: String? = nil, groupedResourceCounts: [GroupedResourceCount]? = nil, nextToken: String? = nil, totalDiscoveredResources: Int64) {
            self.groupByKey = groupByKey
            self.groupedResourceCounts = groupedResourceCounts
            self.nextToken = nextToken
            self.totalDiscoveredResources = totalDiscoveredResources
        }

        private enum CodingKeys: String, CodingKey {
            case groupByKey = "GroupByKey"
            case groupedResourceCounts = "GroupedResourceCounts"
            case nextToken = "NextToken"
            case totalDiscoveredResources = "TotalDiscoveredResources"
        }
    }

    public struct GetAggregateResourceConfigRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// An object that identifies aggregate resource.
        public let resourceIdentifier: AggregateResourceIdentifier

        @inlinable
        public init(configurationAggregatorName: String, resourceIdentifier: AggregateResourceIdentifier) {
            self.configurationAggregatorName = configurationAggregatorName
            self.resourceIdentifier = resourceIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.resourceIdentifier.validate(name: "\(name).resourceIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case resourceIdentifier = "ResourceIdentifier"
        }
    }

    public struct GetAggregateResourceConfigResponse: AWSDecodableShape {
        /// Returns a ConfigurationItem object.
        public let configurationItem: ConfigurationItem?

        @inlinable
        public init(configurationItem: ConfigurationItem? = nil) {
            self.configurationItem = configurationItem
        }

        private enum CodingKeys: String, CodingKey {
            case configurationItem = "ConfigurationItem"
        }
    }

    public struct GetComplianceDetailsByConfigRuleRequest: AWSEncodableShape {
        /// Filters the results by compliance.  INSUFFICIENT_DATA is a valid ComplianceType that is returned when an Config rule cannot be evaluated. However, INSUFFICIENT_DATA cannot be used as a ComplianceType for filtering results.
        public let complianceTypes: [ComplianceType]?
        /// The name of the Config rule for which you want compliance
        /// 			information.
        public let configRuleName: String
        /// The maximum number of evaluation results returned on each page.
        /// 			The default is 10. You cannot specify a number greater than 100. If
        /// 			you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page
        /// 			that you use to get the next page of results in a paginated
        /// 			response.
        public let nextToken: String?

        @inlinable
        public init(complianceTypes: [ComplianceType]? = nil, configRuleName: String, limit: Int? = nil, nextToken: String? = nil) {
            self.complianceTypes = complianceTypes
            self.configRuleName = configRuleName
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, max: 3)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 64)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceTypes = "ComplianceTypes"
            case configRuleName = "ConfigRuleName"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetComplianceDetailsByConfigRuleResponse: AWSDecodableShape {
        /// Indicates whether the Amazon Web Services resource complies with the specified
        /// 			Config rule.
        public let evaluationResults: [EvaluationResult]?
        /// The string that you use in a subsequent request to get the next
        /// 			page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(evaluationResults: [EvaluationResult]? = nil, nextToken: String? = nil) {
            self.evaluationResults = evaluationResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationResults = "EvaluationResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetComplianceDetailsByResourceRequest: AWSEncodableShape {
        /// Filters the results by compliance.  INSUFFICIENT_DATA is a valid ComplianceType that is returned when an Config rule cannot be evaluated. However, INSUFFICIENT_DATA cannot be used as a ComplianceType for filtering results.
        public let complianceTypes: [ComplianceType]?
        /// The nextToken string returned on a previous page
        /// 			that you use to get the next page of results in a paginated
        /// 			response.
        public let nextToken: String?
        /// The unique ID of Amazon Web Services resource execution for which you want to retrieve evaluation results.   You need to only provide either a ResourceEvaluationID or a ResourceID and ResourceType.
        public let resourceEvaluationId: String?
        /// The ID of the Amazon Web Services resource for which you want compliance
        /// 			information.
        public let resourceId: String?
        /// The type of the Amazon Web Services resource for which you want compliance
        /// 			information.
        public let resourceType: String?

        @inlinable
        public init(complianceTypes: [ComplianceType]? = nil, nextToken: String? = nil, resourceEvaluationId: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.complianceTypes = complianceTypes
            self.nextToken = nextToken
            self.resourceEvaluationId = resourceEvaluationId
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, max: 3)
            try self.validate(self.resourceEvaluationId, name: "resourceEvaluationId", parent: name, max: 128)
            try self.validate(self.resourceEvaluationId, name: "resourceEvaluationId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceTypes = "ComplianceTypes"
            case nextToken = "NextToken"
            case resourceEvaluationId = "ResourceEvaluationId"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct GetComplianceDetailsByResourceResponse: AWSDecodableShape {
        /// Indicates whether the specified Amazon Web Services resource complies each Config rule.
        public let evaluationResults: [EvaluationResult]?
        /// The string that you use in a subsequent request to get the next
        /// 			page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(evaluationResults: [EvaluationResult]? = nil, nextToken: String? = nil) {
            self.evaluationResults = evaluationResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationResults = "EvaluationResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetComplianceSummaryByConfigRuleResponse: AWSDecodableShape {
        /// The number of Config rules that are compliant and the
        /// 			number that are noncompliant, up to a maximum of 25 for
        /// 			each.
        public let complianceSummary: ComplianceSummary?

        @inlinable
        public init(complianceSummary: ComplianceSummary? = nil) {
            self.complianceSummary = complianceSummary
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummary = "ComplianceSummary"
        }
    }

    public struct GetComplianceSummaryByResourceTypeRequest: AWSEncodableShape {
        /// Specify one or more resource types to get the number of
        /// 			resources that are compliant and the number that are noncompliant
        /// 			for each resource type. For this request, you can specify an Amazon Web Services resource type such as
        /// 				AWS::EC2::Instance. You can specify that the
        /// 			resource type is an Amazon Web Services account by specifying
        /// 				AWS::::Account.
        public let resourceTypes: [String]?

        @inlinable
        public init(resourceTypes: [String]? = nil) {
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.resourceTypes?.forEach {
                try validate($0, name: "resourceTypes[]", parent: name, max: 256)
                try validate($0, name: "resourceTypes[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTypes = "ResourceTypes"
        }
    }

    public struct GetComplianceSummaryByResourceTypeResponse: AWSDecodableShape {
        /// The number of resources that are compliant and the number that
        /// 			are noncompliant. If one or more resource types were provided with
        /// 			the request, the numbers are returned for each resource type. The
        /// 			maximum number returned is 100.
        public let complianceSummariesByResourceType: [ComplianceSummaryByResourceType]?

        @inlinable
        public init(complianceSummariesByResourceType: [ComplianceSummaryByResourceType]? = nil) {
            self.complianceSummariesByResourceType = complianceSummariesByResourceType
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummariesByResourceType = "ComplianceSummariesByResourceType"
        }
    }

    public struct GetConformancePackComplianceDetailsRequest: AWSEncodableShape {
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// A ConformancePackEvaluationFilters object.
        public let filters: ConformancePackEvaluationFilters?
        /// The maximum number of evaluation results returned on each page. If you do no specify a number, Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(conformancePackName: String, filters: ConformancePackEvaluationFilters? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.conformancePackName = conformancePackName
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, max: 256)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackName = "ConformancePackName"
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetConformancePackComplianceDetailsResponse: AWSDecodableShape {
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// Returns a list of ConformancePackEvaluationResult objects.
        public let conformancePackRuleEvaluationResults: [ConformancePackEvaluationResult]?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(conformancePackName: String, conformancePackRuleEvaluationResults: [ConformancePackEvaluationResult]? = nil, nextToken: String? = nil) {
            self.conformancePackName = conformancePackName
            self.conformancePackRuleEvaluationResults = conformancePackRuleEvaluationResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackName = "ConformancePackName"
            case conformancePackRuleEvaluationResults = "ConformancePackRuleEvaluationResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetConformancePackComplianceSummaryRequest: AWSEncodableShape {
        /// Names of conformance packs.
        public let conformancePackNames: [String]
        /// The maximum number of conformance packs returned on each page.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(conformancePackNames: [String], limit: Int? = nil, nextToken: String? = nil) {
            self.conformancePackNames = conformancePackNames
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.conformancePackNames.forEach {
                try validate($0, name: "conformancePackNames[]", parent: name, max: 256)
                try validate($0, name: "conformancePackNames[]", parent: name, min: 1)
                try validate($0, name: "conformancePackNames[]", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            }
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, max: 5)
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 20)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackNames = "ConformancePackNames"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetConformancePackComplianceSummaryResponse: AWSDecodableShape {
        /// A list of ConformancePackComplianceSummary objects.
        public let conformancePackComplianceSummaryList: [ConformancePackComplianceSummary]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(conformancePackComplianceSummaryList: [ConformancePackComplianceSummary]? = nil, nextToken: String? = nil) {
            self.conformancePackComplianceSummaryList = conformancePackComplianceSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackComplianceSummaryList = "ConformancePackComplianceSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct GetCustomRulePolicyRequest: AWSEncodableShape {
        /// The name of your Config Custom Policy rule.
        public let configRuleName: String?

        @inlinable
        public init(configRuleName: String? = nil) {
            self.configRuleName = configRuleName
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
        }
    }

    public struct GetCustomRulePolicyResponse: AWSDecodableShape {
        /// The policy definition containing the logic for your Config Custom Policy rule.
        public let policyText: String?

        @inlinable
        public init(policyText: String? = nil) {
            self.policyText = policyText
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "PolicyText"
        }
    }

    public struct GetDiscoveredResourceCountsRequest: AWSEncodableShape {
        /// The maximum number of ResourceCount objects
        /// 			returned on each page. The default is 100. You cannot specify a
        /// 			number greater than 100. If you specify 0, Config uses the
        /// 			default.
        public let limit: Int?
        /// The nextToken string returned on a previous page
        /// 			that you use to get the next page of results in a paginated
        /// 			response.
        public let nextToken: String?
        /// The comma-separated list that specifies the resource types that
        /// 			you want Config to return (for example,
        /// 				"AWS::EC2::Instance",
        /// 			"AWS::IAM::User"). If a value for resourceTypes is not specified, Config returns all resource types that Config is recording in
        /// 			the region for your account.  If the configuration recorder is turned off, Config
        /// 				returns an empty list of ResourceCount
        /// 				objects. If the configuration recorder is not recording a
        /// 				specific resource type (for example, S3 buckets), that resource
        /// 				type is not returned in the list of ResourceCount objects.
        public let resourceTypes: [String]?

        @inlinable
        public init(limit: Int? = nil, nextToken: String? = nil, resourceTypes: [String]? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.resourceTypes?.forEach {
                try validate($0, name: "resourceTypes[]", parent: name, max: 256)
                try validate($0, name: "resourceTypes[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case nextToken = "nextToken"
            case resourceTypes = "resourceTypes"
        }
    }

    public struct GetDiscoveredResourceCountsResponse: AWSDecodableShape {
        /// The string that you use in a subsequent request to get the next
        /// 			page of results in a paginated response.
        public let nextToken: String?
        /// The list of ResourceCount objects. Each object is
        /// 			listed in descending order by the number of resources.
        public let resourceCounts: [ResourceCount]?
        /// The total number of resources that Config is recording in
        /// 			the region for your account. If you specify resource types in the
        /// 			request, Config returns only the total number of resources for
        /// 			those resource types.  Example    Config is recording three resource types in the US
        /// 					East (Ohio) Region for your account: 25 EC2 instances, 20
        /// 					IAM users, and 15 S3 buckets, for a total of 60
        /// 					resources.   You make a call to the
        /// 						GetDiscoveredResourceCounts action and
        /// 					specify the resource type,
        /// 						"AWS::EC2::Instances", in the
        /// 					request.   Config returns 25 for
        /// 						totalDiscoveredResources.
        public let totalDiscoveredResources: Int64?

        @inlinable
        public init(nextToken: String? = nil, resourceCounts: [ResourceCount]? = nil, totalDiscoveredResources: Int64? = nil) {
            self.nextToken = nextToken
            self.resourceCounts = resourceCounts
            self.totalDiscoveredResources = totalDiscoveredResources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resourceCounts = "resourceCounts"
            case totalDiscoveredResources = "totalDiscoveredResources"
        }
    }

    public struct GetOrganizationConfigRuleDetailedStatusRequest: AWSEncodableShape {
        /// A StatusDetailFilters object.
        public let filters: StatusDetailFilters?
        /// The maximum number of OrganizationConfigRuleDetailedStatus returned on each page. If you do not specify a number, Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The name of your organization Config rule for which you want status details for member accounts.
        public let organizationConfigRuleName: String

        @inlinable
        public init(filters: StatusDetailFilters? = nil, limit: Int? = nil, nextToken: String? = nil, organizationConfigRuleName: String) {
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConfigRuleName = organizationConfigRuleName
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, max: 64)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, min: 1)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, pattern: "^[A-Za-z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConfigRuleName = "OrganizationConfigRuleName"
        }
    }

    public struct GetOrganizationConfigRuleDetailedStatusResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of MemberAccountStatus objects.
        public let organizationConfigRuleDetailedStatus: [MemberAccountStatus]?

        @inlinable
        public init(nextToken: String? = nil, organizationConfigRuleDetailedStatus: [MemberAccountStatus]? = nil) {
            self.nextToken = nextToken
            self.organizationConfigRuleDetailedStatus = organizationConfigRuleDetailedStatus
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConfigRuleDetailedStatus = "OrganizationConfigRuleDetailedStatus"
        }
    }

    public struct GetOrganizationConformancePackDetailedStatusRequest: AWSEncodableShape {
        /// An OrganizationResourceDetailedStatusFilters object.
        public let filters: OrganizationResourceDetailedStatusFilters?
        /// The maximum number of OrganizationConformancePackDetailedStatuses returned on each page.
        /// 			If you do not specify a number, Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The name of organization conformance pack for which you want status details for member accounts.
        public let organizationConformancePackName: String

        @inlinable
        public init(filters: OrganizationResourceDetailedStatusFilters? = nil, limit: Int? = nil, nextToken: String? = nil, organizationConformancePackName: String) {
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConformancePackName = organizationConformancePackName
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, max: 128)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, min: 1)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConformancePackName = "OrganizationConformancePackName"
        }
    }

    public struct GetOrganizationConformancePackDetailedStatusResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of OrganizationConformancePackDetailedStatus objects.
        public let organizationConformancePackDetailedStatuses: [OrganizationConformancePackDetailedStatus]?

        @inlinable
        public init(nextToken: String? = nil, organizationConformancePackDetailedStatuses: [OrganizationConformancePackDetailedStatus]? = nil) {
            self.nextToken = nextToken
            self.organizationConformancePackDetailedStatuses = organizationConformancePackDetailedStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConformancePackDetailedStatuses = "OrganizationConformancePackDetailedStatuses"
        }
    }

    public struct GetOrganizationCustomRulePolicyRequest: AWSEncodableShape {
        /// The name of your organization Config Custom Policy rule.
        public let organizationConfigRuleName: String

        @inlinable
        public init(organizationConfigRuleName: String) {
            self.organizationConfigRuleName = organizationConfigRuleName
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, max: 64)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, min: 1)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, pattern: "^[A-Za-z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationConfigRuleName = "OrganizationConfigRuleName"
        }
    }

    public struct GetOrganizationCustomRulePolicyResponse: AWSDecodableShape {
        /// The policy definition containing the logic for your organization Config Custom Policy rule.
        public let policyText: String?

        @inlinable
        public init(policyText: String? = nil) {
            self.policyText = policyText
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "PolicyText"
        }
    }

    public struct GetResourceConfigHistoryRequest: AWSEncodableShape {
        /// The chronological order for configuration items listed. By
        /// 			default, the results are listed in reverse chronological
        /// 			order.
        public let chronologicalOrder: ChronologicalOrder?
        /// The chronologically earliest time in the time range for which the history requested. If not
        /// 			specified, the action returns paginated results that contain
        /// 			configuration items that start when the first configuration item was
        /// 			recorded.
        public let earlierTime: Date?
        /// The chronologically latest time in the time range for which the history requested. If not specified,
        /// 			current time is taken.
        public let laterTime: Date?
        /// The maximum number of configuration items returned on each
        /// 			page. The default is 10. You cannot specify a number greater than
        /// 			100. If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page
        /// 			that you use to get the next page of results in a paginated
        /// 			response.
        public let nextToken: String?
        /// The ID of the resource (for example.,
        /// 			sg-xxxxxx).
        public let resourceId: String
        /// The resource type.
        public let resourceType: ResourceType

        @inlinable
        public init(chronologicalOrder: ChronologicalOrder? = nil, earlierTime: Date? = nil, laterTime: Date? = nil, limit: Int? = nil, nextToken: String? = nil, resourceId: String, resourceType: ResourceType) {
            self.chronologicalOrder = chronologicalOrder
            self.earlierTime = earlierTime
            self.laterTime = laterTime
            self.limit = limit
            self.nextToken = nextToken
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case chronologicalOrder = "chronologicalOrder"
            case earlierTime = "earlierTime"
            case laterTime = "laterTime"
            case limit = "limit"
            case nextToken = "nextToken"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct GetResourceConfigHistoryResponse: AWSDecodableShape {
        /// A list that contains the configuration history of one or more
        /// 			resources.
        public let configurationItems: [ConfigurationItem]?
        /// The string that you use in a subsequent request to get the next
        /// 			page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configurationItems: [ConfigurationItem]? = nil, nextToken: String? = nil) {
            self.configurationItems = configurationItems
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurationItems = "configurationItems"
            case nextToken = "nextToken"
        }
    }

    public struct GetResourceEvaluationSummaryRequest: AWSEncodableShape {
        /// The unique ResourceEvaluationId of Amazon Web Services resource execution for which you want to retrieve the evaluation summary.
        public let resourceEvaluationId: String

        @inlinable
        public init(resourceEvaluationId: String) {
            self.resourceEvaluationId = resourceEvaluationId
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceEvaluationId, name: "resourceEvaluationId", parent: name, max: 128)
            try self.validate(self.resourceEvaluationId, name: "resourceEvaluationId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceEvaluationId = "ResourceEvaluationId"
        }
    }

    public struct GetResourceEvaluationSummaryResponse: AWSDecodableShape {
        /// The compliance status of the resource evaluation summary.
        public let compliance: ComplianceType?
        /// Returns an EvaluationContext object.
        public let evaluationContext: EvaluationContext?
        /// Lists results of the mode that you requested to retrieve the resource evaluation summary. The valid values are Detective or Proactive.
        public let evaluationMode: EvaluationMode?
        /// The start timestamp when Config rule starts evaluating compliance for the provided resource details.
        public let evaluationStartTimestamp: Date?
        /// Returns an EvaluationStatus object.
        public let evaluationStatus: EvaluationStatus?
        /// Returns a ResourceDetails object.
        public let resourceDetails: ResourceDetails?
        /// The unique ResourceEvaluationId of Amazon Web Services resource execution for which you want to retrieve the evaluation summary.
        public let resourceEvaluationId: String?

        @inlinable
        public init(compliance: ComplianceType? = nil, evaluationContext: EvaluationContext? = nil, evaluationMode: EvaluationMode? = nil, evaluationStartTimestamp: Date? = nil, evaluationStatus: EvaluationStatus? = nil, resourceDetails: ResourceDetails? = nil, resourceEvaluationId: String? = nil) {
            self.compliance = compliance
            self.evaluationContext = evaluationContext
            self.evaluationMode = evaluationMode
            self.evaluationStartTimestamp = evaluationStartTimestamp
            self.evaluationStatus = evaluationStatus
            self.resourceDetails = resourceDetails
            self.resourceEvaluationId = resourceEvaluationId
        }

        private enum CodingKeys: String, CodingKey {
            case compliance = "Compliance"
            case evaluationContext = "EvaluationContext"
            case evaluationMode = "EvaluationMode"
            case evaluationStartTimestamp = "EvaluationStartTimestamp"
            case evaluationStatus = "EvaluationStatus"
            case resourceDetails = "ResourceDetails"
            case resourceEvaluationId = "ResourceEvaluationId"
        }
    }

    public struct GetStoredQueryRequest: AWSEncodableShape {
        /// The name of the query.
        public let queryName: String

        @inlinable
        public init(queryName: String) {
            self.queryName = queryName
        }

        public func validate(name: String) throws {
            try self.validate(self.queryName, name: "queryName", parent: name, max: 64)
            try self.validate(self.queryName, name: "queryName", parent: name, min: 1)
            try self.validate(self.queryName, name: "queryName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case queryName = "QueryName"
        }
    }

    public struct GetStoredQueryResponse: AWSDecodableShape {
        /// Returns a StoredQuery object.
        public let storedQuery: StoredQuery?

        @inlinable
        public init(storedQuery: StoredQuery? = nil) {
            self.storedQuery = storedQuery
        }

        private enum CodingKeys: String, CodingKey {
            case storedQuery = "StoredQuery"
        }
    }

    public struct GroupedResourceCount: AWSDecodableShape {
        /// The name of the group that can be region, account ID, or resource type. For example, region1, region2 if the region was chosen as GroupByKey.
        public let groupName: String
        /// The number of resources in the group.
        public let resourceCount: Int64

        @inlinable
        public init(groupName: String, resourceCount: Int64) {
            self.groupName = groupName
            self.resourceCount = resourceCount
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "GroupName"
            case resourceCount = "ResourceCount"
        }
    }

    public struct ListAggregateDiscoveredResourcesRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the results based on the ResourceFilters object.
        public let filters: ResourceFilters?
        /// The maximum number of resource identifiers returned on each page. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The type of resources that you want Config to list in the response.
        public let resourceType: ResourceType

        @inlinable
        public init(configurationAggregatorName: String, filters: ResourceFilters? = nil, limit: Int? = nil, nextToken: String? = nil, resourceType: ResourceType) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
            case resourceType = "ResourceType"
        }
    }

    public struct ListAggregateDiscoveredResourcesResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a list of ResourceIdentifiers objects.
        public let resourceIdentifiers: [AggregateResourceIdentifier]?

        @inlinable
        public init(nextToken: String? = nil, resourceIdentifiers: [AggregateResourceIdentifier]? = nil) {
            self.nextToken = nextToken
            self.resourceIdentifiers = resourceIdentifiers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourceIdentifiers = "ResourceIdentifiers"
        }
    }

    public struct ListConfigurationRecordersRequest: AWSEncodableShape {
        /// Filters the results based on a list of ConfigurationRecorderFilter objects that you specify.
        public let filters: [ConfigurationRecorderFilter]?
        /// The maximum number of results to include in the response.
        public let maxResults: Int?
        /// The NextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(filters: [ConfigurationRecorderFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListConfigurationRecordersResponse: AWSDecodableShape {
        /// A list of ConfigurationRecorderSummary objects that includes.
        public let configurationRecorderSummaries: [ConfigurationRecorderSummary]
        /// The NextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configurationRecorderSummaries: [ConfigurationRecorderSummary], nextToken: String? = nil) {
            self.configurationRecorderSummaries = configurationRecorderSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorderSummaries = "ConfigurationRecorderSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListConformancePackComplianceScoresRequest: AWSEncodableShape {
        /// Filters the results based on the ConformancePackComplianceScoresFilters.
        public let filters: ConformancePackComplianceScoresFilters?
        /// The maximum number of conformance pack compliance scores returned on each page.
        public let limit: Int?
        /// The nextToken string in a prior request that you can use to get the paginated response for the next set of conformance pack compliance scores.
        public let nextToken: String?
        /// Sorts your conformance pack compliance scores in either ascending or descending order, depending on SortOrder. By default, conformance pack compliance scores are sorted in alphabetical order by name of the conformance pack.
        /// 			Enter SCORE, to sort conformance pack compliance scores by the numerical value of the compliance score.
        public let sortBy: SortBy?
        /// Determines the order in which conformance pack compliance scores are sorted. Either in ascending or descending order. By default, conformance pack compliance scores are sorted in alphabetical order by name of the conformance pack. Conformance pack compliance scores are sorted in reverse alphabetical order if you enter DESCENDING. You can sort conformance pack compliance scores by the numerical value of the compliance score by entering SCORE in the SortBy action. When compliance scores are sorted by SCORE, conformance packs with a compliance score of INSUFFICIENT_DATA will be last when sorting by ascending order and first when sorting by descending order.
        public let sortOrder: SortOrder?

        @inlinable
        public init(filters: ConformancePackComplianceScoresFilters? = nil, limit: Int? = nil, nextToken: String? = nil, sortBy: SortBy? = nil, sortOrder: SortOrder? = nil) {
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 20)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListConformancePackComplianceScoresResponse: AWSDecodableShape {
        /// A list of ConformancePackComplianceScore objects.
        public let conformancePackComplianceScores: [ConformancePackComplianceScore]
        /// The nextToken string that you can use to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(conformancePackComplianceScores: [ConformancePackComplianceScore], nextToken: String? = nil) {
            self.conformancePackComplianceScores = conformancePackComplianceScores
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackComplianceScores = "ConformancePackComplianceScores"
            case nextToken = "NextToken"
        }
    }

    public struct ListDiscoveredResourcesRequest: AWSEncodableShape {
        /// Specifies whether Config includes deleted resources in the
        /// 			results. By default, deleted resources are not included.
        public let includeDeletedResources: Bool?
        /// The maximum number of resource identifiers returned on each
        /// 			page. The default is 100. You cannot specify a number greater than
        /// 			100. If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page
        /// 			that you use to get the next page of results in a paginated
        /// 			response.
        public let nextToken: String?
        /// The IDs of only those resources that you want Config to
        /// 			list in the response. If you do not specify this parameter, Config lists all resources of the specified type that it has
        /// 			discovered. You can list a minimum of 1 resourceID and a maximum of 20 resourceIds.
        public let resourceIds: [String]?
        /// The custom name of only those resources that you want Config to list in the response. If you do not specify this
        /// 			parameter, Config lists all resources of the specified type that
        /// 			it has discovered.
        public let resourceName: String?
        /// The type of resources that you want Config to list in the
        /// 			response.
        public let resourceType: ResourceType

        @inlinable
        public init(includeDeletedResources: Bool? = nil, limit: Int? = nil, nextToken: String? = nil, resourceIds: [String]? = nil, resourceName: String? = nil, resourceType: ResourceType) {
            self.includeDeletedResources = includeDeletedResources
            self.limit = limit
            self.nextToken = nextToken
            self.resourceIds = resourceIds
            self.resourceName = resourceName
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.resourceIds?.forEach {
                try validate($0, name: "resourceIds[]", parent: name, max: 768)
                try validate($0, name: "resourceIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case includeDeletedResources = "includeDeletedResources"
            case limit = "limit"
            case nextToken = "nextToken"
            case resourceIds = "resourceIds"
            case resourceName = "resourceName"
            case resourceType = "resourceType"
        }
    }

    public struct ListDiscoveredResourcesResponse: AWSDecodableShape {
        /// The string that you use in a subsequent request to get the next
        /// 			page of results in a paginated response.
        public let nextToken: String?
        /// The details that identify a resource that is discovered by Config, including the resource type, ID, and (if available) the
        /// 			custom resource name.
        public let resourceIdentifiers: [ResourceIdentifier]?

        @inlinable
        public init(nextToken: String? = nil, resourceIdentifiers: [ResourceIdentifier]? = nil) {
            self.nextToken = nextToken
            self.resourceIdentifiers = resourceIdentifiers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resourceIdentifiers = "resourceIdentifiers"
        }
    }

    public struct ListResourceEvaluationsRequest: AWSEncodableShape {
        /// Returns a ResourceEvaluationFilters object.
        public let filters: ResourceEvaluationFilters?
        /// The maximum number of evaluations returned on each page. The default is 10.
        /// 			You cannot specify a number greater than 100. If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(filters: ResourceEvaluationFilters? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct ListResourceEvaluationsResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a ResourceEvaluations object.
        public let resourceEvaluations: [ResourceEvaluation]?

        @inlinable
        public init(nextToken: String? = nil, resourceEvaluations: [ResourceEvaluation]? = nil) {
            self.nextToken = nextToken
            self.resourceEvaluations = resourceEvaluations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourceEvaluations = "ResourceEvaluations"
        }
    }

    public struct ListStoredQueriesRequest: AWSEncodableShape {
        /// The maximum number of results to be returned with a single call.
        public let maxResults: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListStoredQueriesResponse: AWSDecodableShape {
        /// If the previous paginated request didn't return all of the remaining results, the response object's NextToken parameter value is set to a token.
        /// 			To retrieve the next set of results, call this operation again and assign that token to the request object's NextToken parameter.
        /// 			If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// A list of StoredQueryMetadata objects.
        public let storedQueryMetadata: [StoredQueryMetadata]?

        @inlinable
        public init(nextToken: String? = nil, storedQueryMetadata: [StoredQueryMetadata]? = nil) {
            self.nextToken = nextToken
            self.storedQueryMetadata = storedQueryMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case storedQueryMetadata = "StoredQueryMetadata"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The maximum number of tags returned on each page. The limit maximum is 50. You cannot specify a number greater than 50. If you specify 0, Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. The following resources are supported:    ConfigurationRecorder     ConfigRule     OrganizationConfigRule     ConformancePack     OrganizationConformancePack     ConfigurationAggregator     AggregationAuthorization     StoredQuery
        public let resourceArn: String

        @inlinable
        public init(limit: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.limit = limit
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The tags for the resource.
        public let tags: [Tag]?

        @inlinable
        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct MemberAccountStatus: AWSDecodableShape {
        /// The 12-digit account ID of a member account.
        public let accountId: String
        /// The name of Config rule deployed in the member account.
        public let configRuleName: String
        /// An error code that is returned when Config rule creation or deletion failed in the member account.
        public let errorCode: String?
        /// An error message indicating that Config rule account creation or deletion has failed due to an error in the member account.
        public let errorMessage: String?
        /// The timestamp of the last status update.
        public let lastUpdateTime: Date?
        /// Indicates deployment status for Config rule in the member account.
        /// 			When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in the member account.
        /// 			When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in the member account.
        /// 			Config rule status is deleted when the management account deletes OrganizationConfigRule and disables service access for config-multiaccountsetup.amazonaws.com.
        /// 		 Config sets the state of the rule to:    CREATE_SUCCESSFUL when Config rule has been created in the member account.     CREATE_IN_PROGRESS when Config rule is being created in the member account.    CREATE_FAILED when Config rule creation has failed in the member account.    DELETE_FAILED when Config rule deletion has failed in the member account.    DELETE_IN_PROGRESS when Config rule is being deleted in the member account.    DELETE_SUCCESSFUL when Config rule has been deleted in the member account.     UPDATE_SUCCESSFUL when Config rule has been updated in the member account.    UPDATE_IN_PROGRESS when Config rule is being updated in the member account.    UPDATE_FAILED when Config rule deletion has failed in the member account.
        public let memberAccountRuleStatus: MemberAccountRuleStatus

        @inlinable
        public init(accountId: String, configRuleName: String, errorCode: String? = nil, errorMessage: String? = nil, lastUpdateTime: Date? = nil, memberAccountRuleStatus: MemberAccountRuleStatus) {
            self.accountId = accountId
            self.configRuleName = configRuleName
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.memberAccountRuleStatus = memberAccountRuleStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case configRuleName = "ConfigRuleName"
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case lastUpdateTime = "LastUpdateTime"
            case memberAccountRuleStatus = "MemberAccountRuleStatus"
        }
    }

    public struct OrganizationAggregationSource: AWSEncodableShape & AWSDecodableShape {
        /// If true, aggregate existing Config regions and future
        /// 			regions.
        public let allAwsRegions: Bool?
        /// The source regions being aggregated.
        public let awsRegions: [String]?
        /// ARN of the IAM role used to retrieve Amazon Web Services Organization details
        /// 			associated with the aggregator account.
        public let roleArn: String

        @inlinable
        public init(allAwsRegions: Bool? = nil, awsRegions: [String]? = nil, roleArn: String) {
            self.allAwsRegions = allAwsRegions
            self.awsRegions = awsRegions
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.awsRegions, name: "awsRegions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allAwsRegions = "AllAwsRegions"
            case awsRegions = "AwsRegions"
            case roleArn = "RoleArn"
        }
    }

    public struct OrganizationConfigRule: AWSDecodableShape {
        /// A comma-separated list of accounts excluded from organization Config rule.
        public let excludedAccounts: [String]?
        /// The timestamp of the last update.
        public let lastUpdateTime: Date?
        /// Amazon Resource Name (ARN) of organization Config rule.
        public let organizationConfigRuleArn: String
        /// The name that you assign to organization Config rule.
        public let organizationConfigRuleName: String
        /// An
        /// 			object that specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have
        /// 			debug logging enabled, and other custom rule metadata, such as resource type, resource
        /// 			ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.
        public let organizationCustomPolicyRuleMetadata: OrganizationCustomPolicyRuleMetadataNoPolicy?
        /// An OrganizationCustomRuleMetadata object.
        public let organizationCustomRuleMetadata: OrganizationCustomRuleMetadata?
        /// An OrganizationManagedRuleMetadata object.
        public let organizationManagedRuleMetadata: OrganizationManagedRuleMetadata?

        @inlinable
        public init(excludedAccounts: [String]? = nil, lastUpdateTime: Date? = nil, organizationConfigRuleArn: String, organizationConfigRuleName: String, organizationCustomPolicyRuleMetadata: OrganizationCustomPolicyRuleMetadataNoPolicy? = nil, organizationCustomRuleMetadata: OrganizationCustomRuleMetadata? = nil, organizationManagedRuleMetadata: OrganizationManagedRuleMetadata? = nil) {
            self.excludedAccounts = excludedAccounts
            self.lastUpdateTime = lastUpdateTime
            self.organizationConfigRuleArn = organizationConfigRuleArn
            self.organizationConfigRuleName = organizationConfigRuleName
            self.organizationCustomPolicyRuleMetadata = organizationCustomPolicyRuleMetadata
            self.organizationCustomRuleMetadata = organizationCustomRuleMetadata
            self.organizationManagedRuleMetadata = organizationManagedRuleMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case excludedAccounts = "ExcludedAccounts"
            case lastUpdateTime = "LastUpdateTime"
            case organizationConfigRuleArn = "OrganizationConfigRuleArn"
            case organizationConfigRuleName = "OrganizationConfigRuleName"
            case organizationCustomPolicyRuleMetadata = "OrganizationCustomPolicyRuleMetadata"
            case organizationCustomRuleMetadata = "OrganizationCustomRuleMetadata"
            case organizationManagedRuleMetadata = "OrganizationManagedRuleMetadata"
        }
    }

    public struct OrganizationConfigRuleStatus: AWSDecodableShape {
        /// An error code that is returned when organization Config rule creation or deletion has failed.
        public let errorCode: String?
        /// An error message indicating that organization Config rule creation or deletion failed due to an error.
        public let errorMessage: String?
        /// The timestamp of the last update.
        public let lastUpdateTime: Date?
        /// The name that you assign to organization Config rule.
        public let organizationConfigRuleName: String
        /// Indicates deployment status of an organization Config rule.
        /// 			When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in all the member accounts.
        /// 			When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in all the member accounts. Additionally, Config rule status is updated when one or more member accounts join or leave an organization.
        /// 			Config rule status is deleted when the management account deletes OrganizationConfigRule in all the member accounts and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the rule to:    CREATE_SUCCESSFUL when an organization Config rule has been successfully created in all the member accounts.     CREATE_IN_PROGRESS when an organization Config rule creation is in progress.    CREATE_FAILED when an organization Config rule creation failed in one or more member accounts within that organization.    DELETE_FAILED when an organization Config rule deletion failed in one or more member accounts within that organization.    DELETE_IN_PROGRESS when an organization Config rule deletion is in progress.    DELETE_SUCCESSFUL when an organization Config rule has been successfully deleted from all the member accounts.    UPDATE_SUCCESSFUL when an organization Config rule has been successfully updated in all the member accounts.    UPDATE_IN_PROGRESS when an organization Config rule update is in progress.    UPDATE_FAILED when an organization Config rule update failed in one or more member accounts within that organization.
        public let organizationRuleStatus: OrganizationRuleStatus

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil, lastUpdateTime: Date? = nil, organizationConfigRuleName: String, organizationRuleStatus: OrganizationRuleStatus) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.organizationConfigRuleName = organizationConfigRuleName
            self.organizationRuleStatus = organizationRuleStatus
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case lastUpdateTime = "LastUpdateTime"
            case organizationConfigRuleName = "OrganizationConfigRuleName"
            case organizationRuleStatus = "OrganizationRuleStatus"
        }
    }

    public struct OrganizationConformancePack: AWSDecodableShape {
        /// A list of ConformancePackInputParameter objects.
        public let conformancePackInputParameters: [ConformancePackInputParameter]?
        /// The name of the Amazon S3 bucket where Config stores conformance pack templates.    This field is optional.
        public let deliveryS3Bucket: String?
        /// Any folder structure you want to add to an Amazon S3 bucket.  This field is optional.
        public let deliveryS3KeyPrefix: String?
        /// A comma-separated list of accounts excluded from organization conformance pack.
        public let excludedAccounts: [String]?
        /// Last time when organization conformation pack was updated.
        public let lastUpdateTime: Date
        /// Amazon Resource Name (ARN) of organization conformance pack.
        public let organizationConformancePackArn: String
        /// The name you assign to an organization conformance pack.
        public let organizationConformancePackName: String

        @inlinable
        public init(conformancePackInputParameters: [ConformancePackInputParameter]? = nil, deliveryS3Bucket: String? = nil, deliveryS3KeyPrefix: String? = nil, excludedAccounts: [String]? = nil, lastUpdateTime: Date, organizationConformancePackArn: String, organizationConformancePackName: String) {
            self.conformancePackInputParameters = conformancePackInputParameters
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.excludedAccounts = excludedAccounts
            self.lastUpdateTime = lastUpdateTime
            self.organizationConformancePackArn = organizationConformancePackArn
            self.organizationConformancePackName = organizationConformancePackName
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackInputParameters = "ConformancePackInputParameters"
            case deliveryS3Bucket = "DeliveryS3Bucket"
            case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
            case excludedAccounts = "ExcludedAccounts"
            case lastUpdateTime = "LastUpdateTime"
            case organizationConformancePackArn = "OrganizationConformancePackArn"
            case organizationConformancePackName = "OrganizationConformancePackName"
        }
    }

    public struct OrganizationConformancePackDetailedStatus: AWSDecodableShape {
        /// The 12-digit account ID of a member account.
        public let accountId: String
        /// The name of conformance pack deployed in the member account.
        public let conformancePackName: String
        /// An error code that is returned when conformance pack creation or
        /// 			deletion failed in the member account.
        public let errorCode: String?
        /// An error message indicating that conformance pack account creation or deletion
        /// 			has failed due to an error in the member account.
        public let errorMessage: String?
        /// The timestamp of the last status update.
        public let lastUpdateTime: Date?
        /// Indicates deployment status for conformance pack in a member account.
        /// 			When management account calls PutOrganizationConformancePack action for the first time, conformance pack status is created in the member account.
        /// 			When management account calls PutOrganizationConformancePack action for the second time, conformance pack status is updated in the member account.
        /// 			Conformance pack status is deleted when the management account deletes OrganizationConformancePack and disables service access for config-multiaccountsetup.amazonaws.com.
        /// 		 Config sets the state of the conformance pack to:    CREATE_SUCCESSFUL when conformance pack has been created in the member account.     CREATE_IN_PROGRESS when conformance pack is being created in the member account.    CREATE_FAILED when conformance pack creation has failed in the member account.    DELETE_FAILED when conformance pack deletion has failed in the member account.    DELETE_IN_PROGRESS when conformance pack is being deleted in the member account.    DELETE_SUCCESSFUL when conformance pack has been deleted in the member account.     UPDATE_SUCCESSFUL when conformance pack has been updated in the member account.    UPDATE_IN_PROGRESS when conformance pack is being updated in the member account.    UPDATE_FAILED when conformance pack deletion has failed in the member account.
        public let status: OrganizationResourceDetailedStatus

        @inlinable
        public init(accountId: String, conformancePackName: String, errorCode: String? = nil, errorMessage: String? = nil, lastUpdateTime: Date? = nil, status: OrganizationResourceDetailedStatus) {
            self.accountId = accountId
            self.conformancePackName = conformancePackName
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case conformancePackName = "ConformancePackName"
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case lastUpdateTime = "LastUpdateTime"
            case status = "Status"
        }
    }

    public struct OrganizationConformancePackStatus: AWSDecodableShape {
        /// An error code that is returned when organization conformance pack creation or deletion has failed in a member account.
        public let errorCode: String?
        /// An error message indicating that organization conformance pack creation or deletion failed due to an error.
        public let errorMessage: String?
        /// The timestamp of the last update.
        public let lastUpdateTime: Date?
        /// The name that you assign to organization conformance pack.
        public let organizationConformancePackName: String
        /// Indicates deployment status of an organization conformance pack.
        /// 			When management account calls PutOrganizationConformancePack for the first time,
        /// 			conformance pack status is created in all the member accounts.
        /// 			When management account calls PutOrganizationConformancePack for the second time,
        /// 			conformance pack status is updated in all the member accounts.
        /// 			Additionally, conformance pack status is updated when one or more member accounts join or leave an
        /// 			organization.
        /// 			Conformance pack status is deleted when the management account deletes
        /// 			OrganizationConformancePack in all the member accounts and disables service
        /// 			access for config-multiaccountsetup.amazonaws.com. Config sets the state of the conformance pack to:    CREATE_SUCCESSFUL when an organization conformance pack has been successfully created in all the member accounts.     CREATE_IN_PROGRESS when an organization conformance pack creation is in progress.    CREATE_FAILED when an organization conformance pack creation failed in one or more member accounts within that organization.    DELETE_FAILED when an organization conformance pack deletion failed in one or more member accounts within that organization.    DELETE_IN_PROGRESS when an organization conformance pack deletion is in progress.    DELETE_SUCCESSFUL when an organization conformance pack has been successfully deleted from all the member accounts.    UPDATE_SUCCESSFUL when an organization conformance pack has been successfully updated in all the member accounts.    UPDATE_IN_PROGRESS when an organization conformance pack update is in progress.    UPDATE_FAILED when an organization conformance pack update failed in one or more member accounts within that organization.
        public let status: OrganizationResourceStatus

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil, lastUpdateTime: Date? = nil, organizationConformancePackName: String, status: OrganizationResourceStatus) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.organizationConformancePackName = organizationConformancePackName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case lastUpdateTime = "LastUpdateTime"
            case organizationConformancePackName = "OrganizationConformancePackName"
            case status = "Status"
        }
    }

    public struct OrganizationCustomPolicyRuleMetadata: AWSEncodableShape {
        /// A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.
        public let debugLogDeliveryAccounts: [String]?
        /// The description that you provide for your organization Config Custom Policy rule.
        public let description: String?
        /// A string, in JSON format, that is passed to your organization Config Custom Policy rule.
        public let inputParameters: String?
        /// The maximum frequency with which Config runs evaluations for a rule. Your
        /// 			Config Custom Policy rule is triggered when Config delivers
        /// 			the configuration snapshot. For more information, see ConfigSnapshotDeliveryProperties.
        public let maximumExecutionFrequency: MaximumExecutionFrequency?
        /// The type of notification that initiates Config to run an evaluation for a rule.
        /// 			For Config Custom Policy rules, Config supports change-initiated notification types:    ConfigurationItemChangeNotification - Initiates an evaluation when Config delivers a configuration item as a result of a resource
        /// 					change.    OversizedConfigurationItemChangeNotification - Initiates an evaluation when
        /// 						Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the
        /// 					notification exceeds the maximum size allowed by Amazon SNS.
        public let organizationConfigRuleTriggerTypes: [OrganizationConfigRuleTriggerTypeNoSN]?
        /// The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the Guard GitHub
        /// 			Repository.
        public let policyRuntime: String
        /// The policy definition containing the logic for your organization Config Custom Policy rule.
        public let policyText: String
        /// The ID of the Amazon Web Services resource that was evaluated.
        public let resourceIdScope: String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public let resourceTypesScope: [String]?
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let tagKeyScope: String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public let tagValueScope: String?

        @inlinable
        public init(debugLogDeliveryAccounts: [String]? = nil, description: String? = nil, inputParameters: String? = nil, maximumExecutionFrequency: MaximumExecutionFrequency? = nil, organizationConfigRuleTriggerTypes: [OrganizationConfigRuleTriggerTypeNoSN]? = nil, policyRuntime: String, policyText: String, resourceIdScope: String? = nil, resourceTypesScope: [String]? = nil, tagKeyScope: String? = nil, tagValueScope: String? = nil) {
            self.debugLogDeliveryAccounts = debugLogDeliveryAccounts
            self.description = description
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes
            self.policyRuntime = policyRuntime
            self.policyText = policyText
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }

        public func validate(name: String) throws {
            try self.debugLogDeliveryAccounts?.forEach {
                try validate($0, name: "debugLogDeliveryAccounts[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.debugLogDeliveryAccounts, name: "debugLogDeliveryAccounts", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, max: 2048)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, min: 1)
            try self.validate(self.policyRuntime, name: "policyRuntime", parent: name, max: 64)
            try self.validate(self.policyRuntime, name: "policyRuntime", parent: name, min: 1)
            try self.validate(self.policyRuntime, name: "policyRuntime", parent: name, pattern: "^guard\\-2\\.x\\.x$")
            try self.validate(self.policyText, name: "policyText", parent: name, max: 10000)
            try self.validate(self.resourceIdScope, name: "resourceIdScope", parent: name, max: 768)
            try self.validate(self.resourceIdScope, name: "resourceIdScope", parent: name, min: 1)
            try self.resourceTypesScope?.forEach {
                try validate($0, name: "resourceTypesScope[]", parent: name, max: 256)
                try validate($0, name: "resourceTypesScope[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTypesScope, name: "resourceTypesScope", parent: name, max: 100)
            try self.validate(self.tagKeyScope, name: "tagKeyScope", parent: name, max: 128)
            try self.validate(self.tagKeyScope, name: "tagKeyScope", parent: name, min: 1)
            try self.validate(self.tagValueScope, name: "tagValueScope", parent: name, max: 256)
            try self.validate(self.tagValueScope, name: "tagValueScope", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case debugLogDeliveryAccounts = "DebugLogDeliveryAccounts"
            case description = "Description"
            case inputParameters = "InputParameters"
            case maximumExecutionFrequency = "MaximumExecutionFrequency"
            case organizationConfigRuleTriggerTypes = "OrganizationConfigRuleTriggerTypes"
            case policyRuntime = "PolicyRuntime"
            case policyText = "PolicyText"
            case resourceIdScope = "ResourceIdScope"
            case resourceTypesScope = "ResourceTypesScope"
            case tagKeyScope = "TagKeyScope"
            case tagValueScope = "TagValueScope"
        }
    }

    public struct OrganizationCustomPolicyRuleMetadataNoPolicy: AWSDecodableShape {
        /// A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.
        public let debugLogDeliveryAccounts: [String]?
        /// The description that you provide for your organization Config Custom Policy rule.
        public let description: String?
        /// A string, in JSON format, that is passed to your organization Config Custom Policy rule.
        public let inputParameters: String?
        /// The maximum frequency with which Config runs evaluations for a rule. Your
        /// 			Config Custom Policy rule is triggered when Config delivers
        /// 			the configuration snapshot. For more information, see ConfigSnapshotDeliveryProperties.
        public let maximumExecutionFrequency: MaximumExecutionFrequency?
        /// The type of notification that triggers Config to run an evaluation for a rule.
        /// 			For Config Custom Policy rules, Config supports change
        /// 			triggered notification types:    ConfigurationItemChangeNotification - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.    OversizedConfigurationItemChangeNotification - Triggers an evaluation when Config delivers an oversized configuration item.
        /// 				Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.
        public let organizationConfigRuleTriggerTypes: [OrganizationConfigRuleTriggerTypeNoSN]?
        /// The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the Guard GitHub
        /// 			Repository.
        public let policyRuntime: String?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public let resourceIdScope: String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public let resourceTypesScope: [String]?
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let tagKeyScope: String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public let tagValueScope: String?

        @inlinable
        public init(debugLogDeliveryAccounts: [String]? = nil, description: String? = nil, inputParameters: String? = nil, maximumExecutionFrequency: MaximumExecutionFrequency? = nil, organizationConfigRuleTriggerTypes: [OrganizationConfigRuleTriggerTypeNoSN]? = nil, policyRuntime: String? = nil, resourceIdScope: String? = nil, resourceTypesScope: [String]? = nil, tagKeyScope: String? = nil, tagValueScope: String? = nil) {
            self.debugLogDeliveryAccounts = debugLogDeliveryAccounts
            self.description = description
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes
            self.policyRuntime = policyRuntime
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }

        private enum CodingKeys: String, CodingKey {
            case debugLogDeliveryAccounts = "DebugLogDeliveryAccounts"
            case description = "Description"
            case inputParameters = "InputParameters"
            case maximumExecutionFrequency = "MaximumExecutionFrequency"
            case organizationConfigRuleTriggerTypes = "OrganizationConfigRuleTriggerTypes"
            case policyRuntime = "PolicyRuntime"
            case resourceIdScope = "ResourceIdScope"
            case resourceTypesScope = "ResourceTypesScope"
            case tagKeyScope = "TagKeyScope"
            case tagValueScope = "TagValueScope"
        }
    }

    public struct OrganizationCustomRuleMetadata: AWSEncodableShape & AWSDecodableShape {
        /// The description that you provide for your organization Config rule.
        public let description: String?
        /// A string, in JSON format, that is passed to your organization Config rule Lambda function.
        public let inputParameters: String?
        /// The lambda function ARN.
        public let lambdaFunctionArn: String
        /// The maximum frequency with which Config runs evaluations for a rule.
        /// 			Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see ConfigSnapshotDeliveryProperties.  By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid
        /// 			value for the MaximumExecutionFrequency parameter.
        public let maximumExecutionFrequency: MaximumExecutionFrequency?
        /// The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:    ConfigurationItemChangeNotification - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.    OversizedConfigurationItemChangeNotification - Triggers an evaluation when Config delivers an oversized configuration item.
        /// 			         	Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.    ScheduledNotification - Triggers a periodic evaluation at the frequency specified for MaximumExecutionFrequency.
        public let organizationConfigRuleTriggerTypes: [OrganizationConfigRuleTriggerType]
        /// The ID of the Amazon Web Services resource that was evaluated.
        public let resourceIdScope: String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public let resourceTypesScope: [String]?
        /// One part of a key-value pair that make up a tag.
        /// 			A key is a general label that acts like a category for more specific tag values.
        public let tagKeyScope: String?
        /// The optional part of a key-value pair that make up a tag.
        /// 			A value acts as a descriptor within a tag category (key).
        public let tagValueScope: String?

        @inlinable
        public init(description: String? = nil, inputParameters: String? = nil, lambdaFunctionArn: String, maximumExecutionFrequency: MaximumExecutionFrequency? = nil, organizationConfigRuleTriggerTypes: [OrganizationConfigRuleTriggerType], resourceIdScope: String? = nil, resourceTypesScope: [String]? = nil, tagKeyScope: String? = nil, tagValueScope: String? = nil) {
            self.description = description
            self.inputParameters = inputParameters
            self.lambdaFunctionArn = lambdaFunctionArn
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, max: 2048)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, min: 1)
            try self.validate(self.lambdaFunctionArn, name: "lambdaFunctionArn", parent: name, max: 256)
            try self.validate(self.lambdaFunctionArn, name: "lambdaFunctionArn", parent: name, min: 1)
            try self.validate(self.resourceIdScope, name: "resourceIdScope", parent: name, max: 768)
            try self.validate(self.resourceIdScope, name: "resourceIdScope", parent: name, min: 1)
            try self.resourceTypesScope?.forEach {
                try validate($0, name: "resourceTypesScope[]", parent: name, max: 256)
                try validate($0, name: "resourceTypesScope[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTypesScope, name: "resourceTypesScope", parent: name, max: 100)
            try self.validate(self.tagKeyScope, name: "tagKeyScope", parent: name, max: 128)
            try self.validate(self.tagKeyScope, name: "tagKeyScope", parent: name, min: 1)
            try self.validate(self.tagValueScope, name: "tagValueScope", parent: name, max: 256)
            try self.validate(self.tagValueScope, name: "tagValueScope", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case inputParameters = "InputParameters"
            case lambdaFunctionArn = "LambdaFunctionArn"
            case maximumExecutionFrequency = "MaximumExecutionFrequency"
            case organizationConfigRuleTriggerTypes = "OrganizationConfigRuleTriggerTypes"
            case resourceIdScope = "ResourceIdScope"
            case resourceTypesScope = "ResourceTypesScope"
            case tagKeyScope = "TagKeyScope"
            case tagValueScope = "TagValueScope"
        }
    }

    public struct OrganizationManagedRuleMetadata: AWSEncodableShape & AWSDecodableShape {
        /// The description that you provide for your organization Config rule.
        public let description: String?
        /// A string, in JSON format, that is passed to your organization Config rule Lambda function.
        public let inputParameters: String?
        /// The maximum frequency with which Config runs evaluations for a rule. This is for an Config managed rule that is triggered at a periodic frequency.  By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid
        /// 			value for the MaximumExecutionFrequency parameter.
        public let maximumExecutionFrequency: MaximumExecutionFrequency?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public let resourceIdScope: String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public let resourceTypesScope: [String]?
        /// For organization config managed rules, a predefined identifier from a
        /// 			list. For example, IAM_PASSWORD_POLICY is a managed
        /// 			rule. To reference a managed rule, see Using Config managed rules.
        public let ruleIdentifier: String
        /// One part of a key-value pair that make up a tag.
        /// 			A key is a general label that acts like a category for more specific tag values.
        public let tagKeyScope: String?
        /// The optional part of a key-value pair that make up a tag.
        /// 			A value acts as a descriptor within a tag category (key).
        public let tagValueScope: String?

        @inlinable
        public init(description: String? = nil, inputParameters: String? = nil, maximumExecutionFrequency: MaximumExecutionFrequency? = nil, resourceIdScope: String? = nil, resourceTypesScope: [String]? = nil, ruleIdentifier: String, tagKeyScope: String? = nil, tagValueScope: String? = nil) {
            self.description = description
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.ruleIdentifier = ruleIdentifier
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, max: 2048)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, min: 1)
            try self.validate(self.resourceIdScope, name: "resourceIdScope", parent: name, max: 768)
            try self.validate(self.resourceIdScope, name: "resourceIdScope", parent: name, min: 1)
            try self.resourceTypesScope?.forEach {
                try validate($0, name: "resourceTypesScope[]", parent: name, max: 256)
                try validate($0, name: "resourceTypesScope[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTypesScope, name: "resourceTypesScope", parent: name, max: 100)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 256)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 1)
            try self.validate(self.tagKeyScope, name: "tagKeyScope", parent: name, max: 128)
            try self.validate(self.tagKeyScope, name: "tagKeyScope", parent: name, min: 1)
            try self.validate(self.tagValueScope, name: "tagValueScope", parent: name, max: 256)
            try self.validate(self.tagValueScope, name: "tagValueScope", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case inputParameters = "InputParameters"
            case maximumExecutionFrequency = "MaximumExecutionFrequency"
            case resourceIdScope = "ResourceIdScope"
            case resourceTypesScope = "ResourceTypesScope"
            case ruleIdentifier = "RuleIdentifier"
            case tagKeyScope = "TagKeyScope"
            case tagValueScope = "TagValueScope"
        }
    }

    public struct OrganizationResourceDetailedStatusFilters: AWSEncodableShape {
        /// The 12-digit account ID of the member account within an organization.
        public let accountId: String?
        /// Indicates deployment status for conformance pack in a member account.
        /// 			When management account calls PutOrganizationConformancePack action for the first time, conformance pack status is created in the member account.
        /// 			When management account calls PutOrganizationConformancePack action for the second time, conformance pack status is updated in the member account.
        /// 			Conformance pack status is deleted when the management account deletes OrganizationConformancePack and disables service access for config-multiaccountsetup.amazonaws.com.
        /// 		 Config sets the state of the conformance pack to:    CREATE_SUCCESSFUL when conformance pack has been created in the member account.     CREATE_IN_PROGRESS when conformance pack is being created in the member account.    CREATE_FAILED when conformance pack creation has failed in the member account.    DELETE_FAILED when conformance pack deletion has failed in the member account.    DELETE_IN_PROGRESS when conformance pack is being deleted in the member account.    DELETE_SUCCESSFUL when conformance pack has been deleted in the member account.     UPDATE_SUCCESSFUL when conformance pack has been updated in the member account.    UPDATE_IN_PROGRESS when conformance pack is being updated in the member account.    UPDATE_FAILED when conformance pack deletion has failed in the member account.
        public let status: OrganizationResourceDetailedStatus?

        @inlinable
        public init(accountId: String? = nil, status: OrganizationResourceDetailedStatus? = nil) {
            self.accountId = accountId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case status = "Status"
        }
    }

    public struct PendingAggregationRequest: AWSDecodableShape {
        /// The 12-digit account ID of the account requesting to aggregate
        /// 			data.
        public let requesterAccountId: String?
        /// The region requesting to aggregate data.
        public let requesterAwsRegion: String?

        @inlinable
        public init(requesterAccountId: String? = nil, requesterAwsRegion: String? = nil) {
            self.requesterAccountId = requesterAccountId
            self.requesterAwsRegion = requesterAwsRegion
        }

        private enum CodingKeys: String, CodingKey {
            case requesterAccountId = "RequesterAccountId"
            case requesterAwsRegion = "RequesterAwsRegion"
        }
    }

    public struct PutAggregationAuthorizationRequest: AWSEncodableShape {
        /// The 12-digit account ID of the account authorized to aggregate data.
        public let authorizedAccountId: String
        /// The region authorized to collect aggregated data.
        public let authorizedAwsRegion: String
        /// An array of tag object.
        public let tags: [Tag]?

        @inlinable
        public init(authorizedAccountId: String, authorizedAwsRegion: String, tags: [Tag]? = nil) {
            self.authorizedAccountId = authorizedAccountId
            self.authorizedAwsRegion = authorizedAwsRegion
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.authorizedAccountId, name: "authorizedAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.authorizedAwsRegion, name: "authorizedAwsRegion", parent: name, max: 64)
            try self.validate(self.authorizedAwsRegion, name: "authorizedAwsRegion", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedAccountId = "AuthorizedAccountId"
            case authorizedAwsRegion = "AuthorizedAwsRegion"
            case tags = "Tags"
        }
    }

    public struct PutAggregationAuthorizationResponse: AWSDecodableShape {
        /// Returns an AggregationAuthorization object.
        ///
        ///
        public let aggregationAuthorization: AggregationAuthorization?

        @inlinable
        public init(aggregationAuthorization: AggregationAuthorization? = nil) {
            self.aggregationAuthorization = aggregationAuthorization
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationAuthorization = "AggregationAuthorization"
        }
    }

    public struct PutConfigRuleRequest: AWSEncodableShape {
        /// The rule that you want to add to your account.
        public let configRule: ConfigRule
        /// An array of tag object.
        public let tags: [Tag]?

        @inlinable
        public init(configRule: ConfigRule, tags: [Tag]? = nil) {
            self.configRule = configRule
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configRule.validate(name: "\(name).configRule")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case configRule = "ConfigRule"
            case tags = "Tags"
        }
    }

    public struct PutConfigurationAggregatorRequest: AWSEncodableShape {
        /// A list of AccountAggregationSource object.
        ///
        ///
        public let accountAggregationSources: [AccountAggregationSource]?
        /// An object to filter configuration recorders in an aggregator. Either ResourceType or ServicePrincipal is required.
        public let aggregatorFilters: AggregatorFilters?
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// An OrganizationAggregationSource object.
        public let organizationAggregationSource: OrganizationAggregationSource?
        /// An array of tag object.
        public let tags: [Tag]?

        @inlinable
        public init(accountAggregationSources: [AccountAggregationSource]? = nil, aggregatorFilters: AggregatorFilters? = nil, configurationAggregatorName: String, organizationAggregationSource: OrganizationAggregationSource? = nil, tags: [Tag]? = nil) {
            self.accountAggregationSources = accountAggregationSources
            self.aggregatorFilters = aggregatorFilters
            self.configurationAggregatorName = configurationAggregatorName
            self.organizationAggregationSource = organizationAggregationSource
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.accountAggregationSources?.forEach {
                try $0.validate(name: "\(name).accountAggregationSources[]")
            }
            try self.validate(self.accountAggregationSources, name: "accountAggregationSources", parent: name, max: 1)
            try self.aggregatorFilters?.validate(name: "\(name).aggregatorFilters")
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.organizationAggregationSource?.validate(name: "\(name).organizationAggregationSource")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case accountAggregationSources = "AccountAggregationSources"
            case aggregatorFilters = "AggregatorFilters"
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case organizationAggregationSource = "OrganizationAggregationSource"
            case tags = "Tags"
        }
    }

    public struct PutConfigurationAggregatorResponse: AWSDecodableShape {
        /// Returns a ConfigurationAggregator object.
        public let configurationAggregator: ConfigurationAggregator?

        @inlinable
        public init(configurationAggregator: ConfigurationAggregator? = nil) {
            self.configurationAggregator = configurationAggregator
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregator = "ConfigurationAggregator"
        }
    }

    public struct PutConfigurationRecorderRequest: AWSEncodableShape {
        /// An object for the configuration recorder. A configuration recorder records configuration changes for the resource types in scope.
        public let configurationRecorder: ConfigurationRecorder
        /// The tags for the customer managed configuration recorder. Each tag consists of a key and an optional value, both of which you define.
        public let tags: [Tag]?

        @inlinable
        public init(configurationRecorder: ConfigurationRecorder, tags: [Tag]? = nil) {
            self.configurationRecorder = configurationRecorder
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configurationRecorder.validate(name: "\(name).configurationRecorder")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorder = "ConfigurationRecorder"
            case tags = "Tags"
        }
    }

    public struct PutConformancePackRequest: AWSEncodableShape {
        /// A list of ConformancePackInputParameter objects.
        public let conformancePackInputParameters: [ConformancePackInputParameter]?
        /// The unique name of the conformance pack you want to deploy.
        public let conformancePackName: String
        /// The name of the Amazon S3 bucket where Config stores conformance pack templates.  This field is optional.
        public let deliveryS3Bucket: String?
        /// The prefix for the Amazon S3 bucket.   This field is optional.
        public let deliveryS3KeyPrefix: String?
        /// A string containing the full conformance pack template body. The structure containing the template body has a minimum length of 1 byte and a maximum length of 51,200 bytes.  You can use a YAML template with two resource types: Config rule (AWS::Config::ConfigRule) and remediation action (AWS::Config::RemediationConfiguration).
        public let templateBody: String?
        /// The location of the file containing the template body (s3://bucketname/prefix). The uri must point to a conformance pack template (max size: 300 KB) that is located in an Amazon S3 bucket in the same Region as the conformance pack.   You must have access to read Amazon S3 bucket.
        /// 			In addition, in order to ensure a successful deployment, the template object must not be in an archived storage class if this parameter is passed.
        public let templateS3Uri: String?
        /// An object of type TemplateSSMDocumentDetails, which contains the name or the Amazon Resource Name (ARN) of the Amazon Web Services Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.
        public let templateSSMDocumentDetails: TemplateSSMDocumentDetails?

        @inlinable
        public init(conformancePackInputParameters: [ConformancePackInputParameter]? = nil, conformancePackName: String, deliveryS3Bucket: String? = nil, deliveryS3KeyPrefix: String? = nil, templateBody: String? = nil, templateS3Uri: String? = nil, templateSSMDocumentDetails: TemplateSSMDocumentDetails? = nil) {
            self.conformancePackInputParameters = conformancePackInputParameters
            self.conformancePackName = conformancePackName
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.templateBody = templateBody
            self.templateS3Uri = templateS3Uri
            self.templateSSMDocumentDetails = templateSSMDocumentDetails
        }

        public func validate(name: String) throws {
            try self.conformancePackInputParameters?.forEach {
                try $0.validate(name: "\(name).conformancePackInputParameters[]")
            }
            try self.validate(self.conformancePackInputParameters, name: "conformancePackInputParameters", parent: name, max: 60)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, max: 256)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            try self.validate(self.deliveryS3Bucket, name: "deliveryS3Bucket", parent: name, max: 63)
            try self.validate(self.deliveryS3KeyPrefix, name: "deliveryS3KeyPrefix", parent: name, max: 1024)
            try self.validate(self.templateBody, name: "templateBody", parent: name, max: 51200)
            try self.validate(self.templateBody, name: "templateBody", parent: name, min: 1)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, max: 1024)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, min: 1)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, pattern: "^s3://")
            try self.templateSSMDocumentDetails?.validate(name: "\(name).templateSSMDocumentDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackInputParameters = "ConformancePackInputParameters"
            case conformancePackName = "ConformancePackName"
            case deliveryS3Bucket = "DeliveryS3Bucket"
            case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
            case templateBody = "TemplateBody"
            case templateS3Uri = "TemplateS3Uri"
            case templateSSMDocumentDetails = "TemplateSSMDocumentDetails"
        }
    }

    public struct PutConformancePackResponse: AWSDecodableShape {
        /// ARN of the conformance pack.
        public let conformancePackArn: String?

        @inlinable
        public init(conformancePackArn: String? = nil) {
            self.conformancePackArn = conformancePackArn
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackArn = "ConformancePackArn"
        }
    }

    public struct PutDeliveryChannelRequest: AWSEncodableShape {
        /// An object for the delivery channel. A delivery channel sends notifications and updated configuration states.
        ///
        public let deliveryChannel: DeliveryChannel

        @inlinable
        public init(deliveryChannel: DeliveryChannel) {
            self.deliveryChannel = deliveryChannel
        }

        public func validate(name: String) throws {
            try self.deliveryChannel.validate(name: "\(name).deliveryChannel")
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannel = "DeliveryChannel"
        }
    }

    public struct PutEvaluationsRequest: AWSEncodableShape {
        /// The assessments that the Lambda function performs. Each
        /// 			evaluation identifies an Amazon Web Services resource and indicates whether it
        /// 			complies with the Config rule that invokes the Lambda
        /// 			function.
        public let evaluations: [Evaluation]?
        /// An encrypted token that associates an evaluation with an Config rule. Identifies the rule and the event that triggered the
        /// 			evaluation.
        public let resultToken: String
        /// Use this parameter to specify a test run for
        /// 			PutEvaluations. You can verify whether your Lambda function will deliver evaluation results to Config. No
        /// 			updates occur to your existing evaluations, and evaluation results
        /// 			are not sent to Config.  When TestMode is true,
        /// 					PutEvaluations doesn't require a valid value
        /// 				for the ResultToken parameter, but the value cannot
        /// 				be null.
        public let testMode: Bool?

        @inlinable
        public init(evaluations: [Evaluation]? = nil, resultToken: String, testMode: Bool? = nil) {
            self.evaluations = evaluations
            self.resultToken = resultToken
            self.testMode = testMode
        }

        public func validate(name: String) throws {
            try self.evaluations?.forEach {
                try $0.validate(name: "\(name).evaluations[]")
            }
            try self.validate(self.evaluations, name: "evaluations", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case evaluations = "Evaluations"
            case resultToken = "ResultToken"
            case testMode = "TestMode"
        }
    }

    public struct PutEvaluationsResponse: AWSDecodableShape {
        /// Requests that failed because of a client or server
        /// 			error.
        public let failedEvaluations: [Evaluation]?

        @inlinable
        public init(failedEvaluations: [Evaluation]? = nil) {
            self.failedEvaluations = failedEvaluations
        }

        private enum CodingKeys: String, CodingKey {
            case failedEvaluations = "FailedEvaluations"
        }
    }

    public struct PutExternalEvaluationRequest: AWSEncodableShape {
        /// The name of the Config rule.
        public let configRuleName: String
        /// An ExternalEvaluation object that provides details about compliance.
        public let externalEvaluation: ExternalEvaluation

        @inlinable
        public init(configRuleName: String, externalEvaluation: ExternalEvaluation) {
            self.configRuleName = configRuleName
            self.externalEvaluation = externalEvaluation
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
            try self.externalEvaluation.validate(name: "\(name).externalEvaluation")
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case externalEvaluation = "ExternalEvaluation"
        }
    }

    public struct PutExternalEvaluationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutOrganizationConfigRuleRequest: AWSEncodableShape {
        /// A comma-separated list of accounts that you want to exclude from an organization Config rule.
        public let excludedAccounts: [String]?
        /// The name that you assign to an organization Config rule.
        public let organizationConfigRuleName: String
        /// An OrganizationCustomPolicyRuleMetadata object. This object specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug
        /// 			logging enabled, and other custom rule metadata, such as resource type, resource ID of
        /// 			Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.
        public let organizationCustomPolicyRuleMetadata: OrganizationCustomPolicyRuleMetadata?
        /// An OrganizationCustomRuleMetadata object. This object specifies organization custom rule metadata such as resource type,
        /// 			resource ID of Amazon Web Services resource, Lambda function ARN, and organization trigger types that trigger Config to evaluate your Amazon Web Services resources against a rule.
        /// 			It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.
        public let organizationCustomRuleMetadata: OrganizationCustomRuleMetadata?
        /// An OrganizationManagedRuleMetadata object. This object specifies organization
        /// 			managed rule metadata such as resource type and ID of Amazon Web Services resource along with the rule identifier.
        /// 			It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.
        public let organizationManagedRuleMetadata: OrganizationManagedRuleMetadata?

        @inlinable
        public init(excludedAccounts: [String]? = nil, organizationConfigRuleName: String, organizationCustomPolicyRuleMetadata: OrganizationCustomPolicyRuleMetadata? = nil, organizationCustomRuleMetadata: OrganizationCustomRuleMetadata? = nil, organizationManagedRuleMetadata: OrganizationManagedRuleMetadata? = nil) {
            self.excludedAccounts = excludedAccounts
            self.organizationConfigRuleName = organizationConfigRuleName
            self.organizationCustomPolicyRuleMetadata = organizationCustomPolicyRuleMetadata
            self.organizationCustomRuleMetadata = organizationCustomRuleMetadata
            self.organizationManagedRuleMetadata = organizationManagedRuleMetadata
        }

        public func validate(name: String) throws {
            try self.excludedAccounts?.forEach {
                try validate($0, name: "excludedAccounts[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.excludedAccounts, name: "excludedAccounts", parent: name, max: 1000)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, max: 64)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, min: 1)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.organizationCustomPolicyRuleMetadata?.validate(name: "\(name).organizationCustomPolicyRuleMetadata")
            try self.organizationCustomRuleMetadata?.validate(name: "\(name).organizationCustomRuleMetadata")
            try self.organizationManagedRuleMetadata?.validate(name: "\(name).organizationManagedRuleMetadata")
        }

        private enum CodingKeys: String, CodingKey {
            case excludedAccounts = "ExcludedAccounts"
            case organizationConfigRuleName = "OrganizationConfigRuleName"
            case organizationCustomPolicyRuleMetadata = "OrganizationCustomPolicyRuleMetadata"
            case organizationCustomRuleMetadata = "OrganizationCustomRuleMetadata"
            case organizationManagedRuleMetadata = "OrganizationManagedRuleMetadata"
        }
    }

    public struct PutOrganizationConfigRuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an organization Config rule.
        public let organizationConfigRuleArn: String?

        @inlinable
        public init(organizationConfigRuleArn: String? = nil) {
            self.organizationConfigRuleArn = organizationConfigRuleArn
        }

        private enum CodingKeys: String, CodingKey {
            case organizationConfigRuleArn = "OrganizationConfigRuleArn"
        }
    }

    public struct PutOrganizationConformancePackRequest: AWSEncodableShape {
        /// A list of ConformancePackInputParameter objects.
        public let conformancePackInputParameters: [ConformancePackInputParameter]?
        /// The name of the Amazon S3 bucket where Config stores conformance pack templates.  This field is optional. If used, it must be prefixed with awsconfigconforms.
        public let deliveryS3Bucket: String?
        /// The prefix for the Amazon S3 bucket.  This field is optional.
        public let deliveryS3KeyPrefix: String?
        /// A list of Amazon Web Services accounts to be excluded from an organization conformance pack while deploying a conformance pack.
        public let excludedAccounts: [String]?
        /// Name of the organization conformance pack you want to create.
        public let organizationConformancePackName: String
        /// A string containing full conformance pack template body. Structure containing the template body
        /// 			with a minimum length of 1 byte and a maximum length of 51,200 bytes.
        public let templateBody: String?
        /// Location of file containing the template body. The uri must point to the conformance pack template
        /// 			(max size: 300 KB).  You must have access to read Amazon S3 bucket.
        /// 			In addition, in order to ensure a successful deployment, the template object must not be in an archived storage class if this parameter is passed.
        public let templateS3Uri: String?

        @inlinable
        public init(conformancePackInputParameters: [ConformancePackInputParameter]? = nil, deliveryS3Bucket: String? = nil, deliveryS3KeyPrefix: String? = nil, excludedAccounts: [String]? = nil, organizationConformancePackName: String, templateBody: String? = nil, templateS3Uri: String? = nil) {
            self.conformancePackInputParameters = conformancePackInputParameters
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.excludedAccounts = excludedAccounts
            self.organizationConformancePackName = organizationConformancePackName
            self.templateBody = templateBody
            self.templateS3Uri = templateS3Uri
        }

        public func validate(name: String) throws {
            try self.conformancePackInputParameters?.forEach {
                try $0.validate(name: "\(name).conformancePackInputParameters[]")
            }
            try self.validate(self.conformancePackInputParameters, name: "conformancePackInputParameters", parent: name, max: 60)
            try self.validate(self.deliveryS3Bucket, name: "deliveryS3Bucket", parent: name, max: 63)
            try self.validate(self.deliveryS3KeyPrefix, name: "deliveryS3KeyPrefix", parent: name, max: 1024)
            try self.excludedAccounts?.forEach {
                try validate($0, name: "excludedAccounts[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.excludedAccounts, name: "excludedAccounts", parent: name, max: 1000)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, max: 128)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, min: 1)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, pattern: "^[a-zA-Z][-a-zA-Z0-9]*$")
            try self.validate(self.templateBody, name: "templateBody", parent: name, max: 51200)
            try self.validate(self.templateBody, name: "templateBody", parent: name, min: 1)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, max: 1024)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, min: 1)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, pattern: "^s3://")
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackInputParameters = "ConformancePackInputParameters"
            case deliveryS3Bucket = "DeliveryS3Bucket"
            case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
            case excludedAccounts = "ExcludedAccounts"
            case organizationConformancePackName = "OrganizationConformancePackName"
            case templateBody = "TemplateBody"
            case templateS3Uri = "TemplateS3Uri"
        }
    }

    public struct PutOrganizationConformancePackResponse: AWSDecodableShape {
        /// ARN of the organization conformance pack.
        public let organizationConformancePackArn: String?

        @inlinable
        public init(organizationConformancePackArn: String? = nil) {
            self.organizationConformancePackArn = organizationConformancePackArn
        }

        private enum CodingKeys: String, CodingKey {
            case organizationConformancePackArn = "OrganizationConformancePackArn"
        }
    }

    public struct PutRemediationConfigurationsRequest: AWSEncodableShape {
        /// A list of remediation configuration objects.
        public let remediationConfigurations: [RemediationConfiguration]

        @inlinable
        public init(remediationConfigurations: [RemediationConfiguration]) {
            self.remediationConfigurations = remediationConfigurations
        }

        public func validate(name: String) throws {
            try self.remediationConfigurations.forEach {
                try $0.validate(name: "\(name).remediationConfigurations[]")
            }
            try self.validate(self.remediationConfigurations, name: "remediationConfigurations", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case remediationConfigurations = "RemediationConfigurations"
        }
    }

    public struct PutRemediationConfigurationsResponse: AWSDecodableShape {
        /// Returns a list of failed remediation batch objects.
        public let failedBatches: [FailedRemediationBatch]?

        @inlinable
        public init(failedBatches: [FailedRemediationBatch]? = nil) {
            self.failedBatches = failedBatches
        }

        private enum CodingKeys: String, CodingKey {
            case failedBatches = "FailedBatches"
        }
    }

    public struct PutRemediationExceptionsRequest: AWSEncodableShape {
        /// The name of the Config rule for which you want to create remediation exception.
        public let configRuleName: String
        /// The exception is automatically deleted after the expiration date.
        public let expirationTime: Date?
        /// The message contains an explanation of the exception.
        public let message: String?
        /// An exception list of resource exception keys to be processed with the current request. Config adds exception for each resource key. For example, Config adds 3 exceptions for 3 resource keys.
        public let resourceKeys: [RemediationExceptionResourceKey]

        @inlinable
        public init(configRuleName: String, expirationTime: Date? = nil, message: String? = nil, resourceKeys: [RemediationExceptionResourceKey]) {
            self.configRuleName = configRuleName
            self.expirationTime = expirationTime
            self.message = message
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
            try self.validate(self.message, name: "message", parent: name, max: 1024)
            try self.validate(self.message, name: "message", parent: name, min: 1)
            try self.resourceKeys.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case expirationTime = "ExpirationTime"
            case message = "Message"
            case resourceKeys = "ResourceKeys"
        }
    }

    public struct PutRemediationExceptionsResponse: AWSDecodableShape {
        /// Returns a list of failed remediation exceptions batch objects. Each object in the batch consists of a list of failed items and failure messages.
        public let failedBatches: [FailedRemediationExceptionBatch]?

        @inlinable
        public init(failedBatches: [FailedRemediationExceptionBatch]? = nil) {
            self.failedBatches = failedBatches
        }

        private enum CodingKeys: String, CodingKey {
            case failedBatches = "FailedBatches"
        }
    }

    public struct PutResourceConfigRequest: AWSEncodableShape {
        /// The configuration object of the resource in valid JSON format. It must match the schema registered with CloudFormation.  The configuration JSON must not exceed 64 KB.
        public let configuration: String
        /// Unique identifier of the resource.
        public let resourceId: String
        /// Name of the resource.
        public let resourceName: String?
        /// The type of the resource. The custom resource type must be registered with CloudFormation.   You cannot use the organization names amzn, amazon, alexa, custom with custom resource types. It is the first part of the ResourceType up to the first ::.
        public let resourceType: String
        /// Version of the schema registered for the ResourceType in CloudFormation.
        public let schemaVersionId: String
        /// Tags associated with the resource.  This field is not to be confused with the Amazon Web Services-wide tag feature for Amazon Web Services resources.
        /// 			Tags for PutResourceConfig are tags that you supply for the configuration items of your custom resources.
        public let tags: [String: String]?

        @inlinable
        public init(configuration: String, resourceId: String, resourceName: String? = nil, resourceType: String, schemaVersionId: String, tags: [String: String]? = nil) {
            self.configuration = configuration
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.schemaVersionId = schemaVersionId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 196)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 128)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 1)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "^[A-Za-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case resourceId = "ResourceId"
            case resourceName = "ResourceName"
            case resourceType = "ResourceType"
            case schemaVersionId = "SchemaVersionId"
            case tags = "Tags"
        }
    }

    public struct PutRetentionConfigurationRequest: AWSEncodableShape {
        /// Number of days Config stores your historical
        /// 			information.  Currently, only applicable to the configuration item
        /// 				history.
        public let retentionPeriodInDays: Int

        @inlinable
        public init(retentionPeriodInDays: Int) {
            self.retentionPeriodInDays = retentionPeriodInDays
        }

        public func validate(name: String) throws {
            try self.validate(self.retentionPeriodInDays, name: "retentionPeriodInDays", parent: name, max: 2557)
            try self.validate(self.retentionPeriodInDays, name: "retentionPeriodInDays", parent: name, min: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case retentionPeriodInDays = "RetentionPeriodInDays"
        }
    }

    public struct PutRetentionConfigurationResponse: AWSDecodableShape {
        /// Returns a retention configuration object.
        public let retentionConfiguration: RetentionConfiguration?

        @inlinable
        public init(retentionConfiguration: RetentionConfiguration? = nil) {
            self.retentionConfiguration = retentionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case retentionConfiguration = "RetentionConfiguration"
        }
    }

    public struct PutServiceLinkedConfigurationRecorderRequest: AWSEncodableShape {
        /// The service principal of the Amazon Web Services service for the service-linked configuration recorder that you want to create.
        public let servicePrincipal: String
        /// The tags for a service-linked configuration recorder. Each tag consists of a key and an optional value, both of which you define.
        public let tags: [Tag]?

        @inlinable
        public init(servicePrincipal: String, tags: [Tag]? = nil) {
            self.servicePrincipal = servicePrincipal
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, max: 128)
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, min: 1)
            try self.validate(self.servicePrincipal, name: "servicePrincipal", parent: name, pattern: "^[\\w+=,.@-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case servicePrincipal = "ServicePrincipal"
            case tags = "Tags"
        }
    }

    public struct PutServiceLinkedConfigurationRecorderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the specified configuration recorder.
        public let arn: String?
        /// The name of the specified configuration recorder. For service-linked configuration recorders, Config automatically assigns a name that has the prefix "AWS" to the new service-linked configuration recorder.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct PutStoredQueryRequest: AWSEncodableShape {
        /// A list of StoredQuery objects.
        /// 			The mandatory fields are QueryName and Expression.  When you are creating a query, you must provide a query name and an expression.
        /// 			When you are updating a query, you must provide a query name but updating the description is optional.
        public let storedQuery: StoredQuery
        /// A list of Tags object.
        public let tags: [Tag]?

        @inlinable
        public init(storedQuery: StoredQuery, tags: [Tag]? = nil) {
            self.storedQuery = storedQuery
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.storedQuery.validate(name: "\(name).storedQuery")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case storedQuery = "StoredQuery"
            case tags = "Tags"
        }
    }

    public struct PutStoredQueryResponse: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the query.
        /// 			For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
        public let queryArn: String?

        @inlinable
        public init(queryArn: String? = nil) {
            self.queryArn = queryArn
        }

        private enum CodingKeys: String, CodingKey {
            case queryArn = "QueryArn"
        }
    }

    public struct QueryInfo: AWSDecodableShape {
        /// Returns a FieldInfo object.
        public let selectFields: [FieldInfo]?

        @inlinable
        public init(selectFields: [FieldInfo]? = nil) {
            self.selectFields = selectFields
        }

        private enum CodingKeys: String, CodingKey {
            case selectFields = "SelectFields"
        }
    }

    public struct RecordingGroup: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether Config records configuration changes for all supported resource types, excluding the global IAM resource types. If you set this field to true, when Config
        /// 			adds support for a new resource type, Config starts recording resources of that type automatically. If you set this field to true,
        /// 			you cannot enumerate specific resource types to record in the resourceTypes field of RecordingGroup, or to exclude in the resourceTypes field of ExclusionByResourceTypes.   Region availability  Check Resource Coverage by Region Availability
        /// 				to see if a resource type is supported in the Amazon Web Services Region where you set up Config.
        public let allSupported: Bool?
        /// An object that specifies how Config excludes resource types from being recorded by the configuration recorder.   Required fields  To use this option, you must set the useOnly field of RecordingStrategy to EXCLUSION_BY_RESOURCE_TYPES.
        public let exclusionByResourceTypes: ExclusionByResourceTypes?
        /// This option is a bundle which only applies to the global IAM resource types:
        /// 			IAM users, groups, roles, and customer managed policies. These global IAM resource types can only be recorded
        /// 			by Config in Regions where Config was available before February 2022.
        /// 			You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. For a list of those Regions,
        /// 			see Recording Amazon Web Services Resources | Global Resources.   Aurora global clusters are recorded in all enabled Regions  The AWS::RDS::GlobalCluster resource type will be recorded in all supported Config Regions where the configuration recorder is enabled, even if includeGlobalResourceTypes is setfalse.
        /// 				The includeGlobalResourceTypes option is a bundle which only applies to IAM users, groups, roles, and customer managed policies.
        /// 			 If you do not want to record AWS::RDS::GlobalCluster in all enabled Regions, use one of the following recording strategies:    Record all current and future resource types with exclusions (EXCLUSION_BY_RESOURCE_TYPES), or    Record specific resource types (INCLUSION_BY_RESOURCE_TYPES).   For more information, see Selecting Which Resources are Recorded in the Config developer guide.    includeGlobalResourceTypes and the exclusion recording strategy  The includeGlobalResourceTypes field has no impact on the EXCLUSION_BY_RESOURCE_TYPES recording strategy.
        /// 				This means that the global IAM resource types (IAM users, groups, roles, and customer managed policies) will
        /// 				not be automatically added as exclusions for exclusionByResourceTypes when includeGlobalResourceTypes is set to false. The includeGlobalResourceTypes field should only be used to modify the AllSupported field, as the default for
        /// 				the AllSupported field is to record configuration changes for all supported resource types excluding the global
        /// 				IAM resource types. To include the global IAM resource types when AllSupported is set to true, make sure to set includeGlobalResourceTypes to true. To exclude the global IAM resource types for the EXCLUSION_BY_RESOURCE_TYPES recording strategy, you need to manually add them to the resourceTypes field of exclusionByResourceTypes.    Required and optional fields  Before you set this field to true,
        /// 			set the allSupported field of RecordingGroup to
        /// 			true. Optionally, you can set the useOnly field of RecordingStrategy to ALL_SUPPORTED_RESOURCE_TYPES.    Overriding fields  If you set this field to false but list global IAM resource types in the resourceTypes field of RecordingGroup,
        /// 			Config will still record configuration changes for those specified resource types regardless of if you set the includeGlobalResourceTypes field to false. If you do not want to record configuration changes to the global IAM resource types (IAM users, groups, roles, and customer managed policies), make sure to not list them in the resourceTypes field
        /// 			in addition to setting the includeGlobalResourceTypes field to false.
        public let includeGlobalResourceTypes: Bool?
        /// An object that specifies the recording strategy for the configuration recorder.   If you set the useOnly field of RecordingStrategy to ALL_SUPPORTED_RESOURCE_TYPES, Config records configuration changes for all supported resource types, excluding the global IAM resource types. You also must set the allSupported field of RecordingGroup to true. When Config adds support for a new resource type, Config automatically starts recording resources of that type.   If you set the useOnly field of RecordingStrategy to INCLUSION_BY_RESOURCE_TYPES, Config records configuration changes for only the resource types you specify in the resourceTypes field of RecordingGroup.   If you set the useOnly field of RecordingStrategy to EXCLUSION_BY_RESOURCE_TYPES, Config records configuration changes for all supported resource types
        /// 				except the resource types that you specify to exclude from being recorded in the resourceTypes field of ExclusionByResourceTypes.     Required and optional fields  The recordingStrategy field is optional when you set the
        /// 			allSupported field of RecordingGroup to true. The recordingStrategy field is optional when you list resource types in the
        /// 				resourceTypes field of RecordingGroup. The recordingStrategy field is required if you list resource types to exclude from recording in the resourceTypes field of ExclusionByResourceTypes.    Overriding fields  If you choose EXCLUSION_BY_RESOURCE_TYPES for the recording strategy, the exclusionByResourceTypes field will override other properties in the request. For example, even if you set includeGlobalResourceTypes to false, global IAM resource types will still be automatically
        /// 			recorded in this option unless those resource types are specifically listed as exclusions in the resourceTypes field of exclusionByResourceTypes.    Global resources types and the resource exclusion recording strategy  By default, if you choose the EXCLUSION_BY_RESOURCE_TYPES recording strategy,
        /// 			when Config adds support for a new resource type in the Region where you set up the configuration recorder, including global resource types,
        /// 			Config starts recording resources of that type automatically. Unless specifically listed as exclusions,
        /// 				AWS::RDS::GlobalCluster will be recorded automatically in all supported Config Regions were the configuration recorder is enabled. IAM users, groups, roles, and customer managed policies will be recorded in the Region where you set up the configuration recorder if that is a Region where Config  was available before February 2022.
        /// 				You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. For a list of those Regions,
        /// 				see Recording Amazon Web Services Resources | Global Resources.
        public let recordingStrategy: RecordingStrategy?
        /// A comma-separated list that specifies which resource types Config
        /// 			records. For a list of valid resourceTypes values, see the
        /// 				Resource Type Value column in
        /// 				Supported Amazon Web Services resource Types in the Config developer guide.   Required and optional fields  Optionally, you can set the useOnly field of RecordingStrategy to INCLUSION_BY_RESOURCE_TYPES. To record all configuration changes,
        /// 				set the allSupported field of RecordingGroup to
        /// 				true, and either omit this field or don't specify any resource types in this field. If you set the allSupported field to false and specify values for resourceTypes,
        /// 				when Config adds support for a new type of resource,
        /// 				it will not record resources of that type unless you manually add that type to your recording group.    Region availability  Before specifying a resource type for Config to track,
        /// 				check Resource Coverage by Region Availability
        /// 				to see if the resource type is supported in the Amazon Web Services Region where you set up Config.
        /// 				If a resource type is supported by Config in at least one Region,
        /// 				you can enable the recording of that resource type in all Regions supported by Config,
        /// 				even if the specified resource type is not supported in the Amazon Web Services Region where you set up Config.
        public let resourceTypes: [ResourceType]?

        @inlinable
        public init(allSupported: Bool? = nil, exclusionByResourceTypes: ExclusionByResourceTypes? = nil, includeGlobalResourceTypes: Bool? = nil, recordingStrategy: RecordingStrategy? = nil, resourceTypes: [ResourceType]? = nil) {
            self.allSupported = allSupported
            self.exclusionByResourceTypes = exclusionByResourceTypes
            self.includeGlobalResourceTypes = includeGlobalResourceTypes
            self.recordingStrategy = recordingStrategy
            self.resourceTypes = resourceTypes
        }

        private enum CodingKeys: String, CodingKey {
            case allSupported = "allSupported"
            case exclusionByResourceTypes = "exclusionByResourceTypes"
            case includeGlobalResourceTypes = "includeGlobalResourceTypes"
            case recordingStrategy = "recordingStrategy"
            case resourceTypes = "resourceTypes"
        }
    }

    public struct RecordingMode: AWSEncodableShape & AWSDecodableShape {
        /// The default recording frequency that Config uses to record configuration changes.  Daily recording cannot be specified for the following resource types:    AWS::Config::ResourceCompliance     AWS::Config::ConformancePackCompliance     AWS::Config::ConfigurationRecorder    For the allSupported (ALL_SUPPORTED_RESOURCE_TYPES) recording strategy, these resource types will be set to Continuous recording.
        public let recordingFrequency: RecordingFrequency
        /// An array of recordingModeOverride objects for you to specify your overrides for the recording mode.
        /// 			The recordingModeOverride object in the recordingModeOverrides array consists of three fields: a description, the new recordingFrequency, and an array of resourceTypes to override.
        public let recordingModeOverrides: [RecordingModeOverride]?

        @inlinable
        public init(recordingFrequency: RecordingFrequency, recordingModeOverrides: [RecordingModeOverride]? = nil) {
            self.recordingFrequency = recordingFrequency
            self.recordingModeOverrides = recordingModeOverrides
        }

        public func validate(name: String) throws {
            try self.recordingModeOverrides?.forEach {
                try $0.validate(name: "\(name).recordingModeOverrides[]")
            }
            try self.validate(self.recordingModeOverrides, name: "recordingModeOverrides", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case recordingFrequency = "recordingFrequency"
            case recordingModeOverrides = "recordingModeOverrides"
        }
    }

    public struct RecordingModeOverride: AWSEncodableShape & AWSDecodableShape {
        /// A description that you provide for the override.
        public let description: String?
        /// The recording frequency that will be applied to all the resource types specified in the override.   Continuous recording allows you to record configuration changes continuously whenever a change occurs.   Daily recording allows you to receive a configuration item (CI) representing the most recent state of your resources over the last 24-hour period, only if its different from the previous CI recorded.
        /// 			    Firewall Manager depends on continuous recording to monitor your resources. If you are using Firewall Manager,
        /// 			it is recommended that you set the recording frequency to Continuous.
        public let recordingFrequency: RecordingFrequency
        /// A comma-separated list that specifies which resource types Config
        /// 			includes in the override.  Daily recording cannot be specified for the following resource types:    AWS::Config::ResourceCompliance     AWS::Config::ConformancePackCompliance     AWS::Config::ConfigurationRecorder
        public let resourceTypes: [ResourceType]

        @inlinable
        public init(description: String? = nil, recordingFrequency: RecordingFrequency, resourceTypes: [ResourceType]) {
            self.description = description
            self.recordingFrequency = recordingFrequency
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case recordingFrequency = "recordingFrequency"
            case resourceTypes = "resourceTypes"
        }
    }

    public struct RecordingStrategy: AWSEncodableShape & AWSDecodableShape {
        /// The recording strategy for the configuration recorder.   If you set this option to ALL_SUPPORTED_RESOURCE_TYPES, Config records configuration changes for all supported resource types, excluding the global IAM resource types.
        /// 				You also must set the allSupported field of RecordingGroup to true.
        /// 				When Config adds support for a new resource type, Config automatically starts recording resources of that type. For a list of supported resource types,
        /// 				see Supported Resource Types in the Config developer guide.   If you set this option to INCLUSION_BY_RESOURCE_TYPES, Config records
        /// 					configuration changes for only the resource types that you specify in the
        /// 						resourceTypes field of RecordingGroup.   If you set this option to EXCLUSION_BY_RESOURCE_TYPES, Config records
        /// 					configuration changes for all supported resource types, except the resource
        /// 					types that you specify to exclude from being recorded in the
        /// 						resourceTypes field of ExclusionByResourceTypes.     Required and optional fields  The recordingStrategy field is optional when you set the
        /// 			allSupported field of RecordingGroup to true. The recordingStrategy field is optional when you list resource types in the
        /// 				resourceTypes field of RecordingGroup. The recordingStrategy field is required if you list resource types to exclude from recording in the resourceTypes field of ExclusionByResourceTypes.    Overriding fields  If you choose EXCLUSION_BY_RESOURCE_TYPES for the recording strategy, the exclusionByResourceTypes field will override other properties in the request. For example, even if you set includeGlobalResourceTypes to false, global IAM resource types will still be automatically
        /// 			recorded in this option unless those resource types are specifically listed as exclusions in the resourceTypes field of exclusionByResourceTypes.    Global resource types and the exclusion recording strategy  By default, if you choose the EXCLUSION_BY_RESOURCE_TYPES recording strategy,
        /// 				when Config adds support for a new resource type in the Region where you set up the configuration recorder, including global resource types,
        /// 				Config starts recording resources of that type automatically. Unless specifically listed as exclusions,
        /// 				AWS::RDS::GlobalCluster will be recorded automatically in all supported Config Regions were the configuration recorder is enabled. IAM users, groups, roles, and customer managed policies will be recorded in the Region where you set up the configuration recorder if that is a Region where Config was available before February 2022.
        /// 				You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. This list where you cannot record the global IAM resource types includes the following Regions:   Asia Pacific (Hyderabad)   Asia Pacific (Melbourne)   Canada West (Calgary)   Europe (Spain)   Europe (Zurich)   Israel (Tel Aviv)   Middle East (UAE)
        public let useOnly: RecordingStrategyType?

        @inlinable
        public init(useOnly: RecordingStrategyType? = nil) {
            self.useOnly = useOnly
        }

        private enum CodingKeys: String, CodingKey {
            case useOnly = "useOnly"
        }
    }

    public struct Relationship: AWSDecodableShape {
        /// The type of relationship with the related resource.
        public let relationshipName: String?
        /// The ID of the related resource (for example,
        /// 				sg-xxxxxx).
        public let resourceId: String?
        /// The custom name of the related resource, if
        /// 			available.
        public let resourceName: String?
        /// The resource type of the related resource.
        public let resourceType: ResourceType?

        @inlinable
        public init(relationshipName: String? = nil, resourceId: String? = nil, resourceName: String? = nil, resourceType: ResourceType? = nil) {
            self.relationshipName = relationshipName
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case relationshipName = "relationshipName"
            case resourceId = "resourceId"
            case resourceName = "resourceName"
            case resourceType = "resourceType"
        }
    }

    public struct RemediationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Amazon Resource Name (ARN) of remediation configuration.
        public let arn: String?
        /// The remediation is triggered automatically.
        public let automatic: Bool?
        /// The name of the Config rule.
        public let configRuleName: String
        /// Name of the service that owns the service-linked rule, if applicable.
        public let createdByService: String?
        /// An ExecutionControls object.
        public let executionControls: ExecutionControls?
        /// The maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5. For example, if you specify MaximumAutomaticAttempts as 5 with RetryAttemptSeconds as 50 seconds,
        ///
        /// 			Config will put a RemediationException on your behalf for the failing resource after the 5th failed attempt within 50 seconds.
        public let maximumAutomaticAttempts: Int?
        /// An object of the RemediationParameterValue.
        public let parameters: [String: RemediationParameterValue]?
        /// The type of a resource.
        public let resourceType: String?
        /// Time window to determine whether or not to add a remediation exception to prevent infinite remediation attempts.
        /// 			If MaximumAutomaticAttempts remediation attempts have been made under RetryAttemptSeconds, a remediation exception will be added to the resource.
        /// 			If you do not select a number, the default is 60 seconds.
        /// 		 For example, if you specify RetryAttemptSeconds as 50 seconds and MaximumAutomaticAttempts as 5,
        /// 			Config will run auto-remediations 5 times within 50 seconds before adding a remediation exception to the resource.
        public let retryAttemptSeconds: Int64?
        /// Target ID is the name of the SSM document.
        public let targetId: String
        /// The type of the target. Target executes remediation. For example, SSM document.
        public let targetType: RemediationTargetType
        /// Version of the target. For example, version of the SSM document.  If you make backward incompatible changes to the SSM document,
        /// 			you must call PutRemediationConfiguration API again to ensure the remediations can run.
        public let targetVersion: String?

        @inlinable
        public init(arn: String? = nil, automatic: Bool? = nil, configRuleName: String, createdByService: String? = nil, executionControls: ExecutionControls? = nil, maximumAutomaticAttempts: Int? = nil, parameters: [String: RemediationParameterValue]? = nil, resourceType: String? = nil, retryAttemptSeconds: Int64? = nil, targetId: String, targetType: RemediationTargetType, targetVersion: String? = nil) {
            self.arn = arn
            self.automatic = automatic
            self.configRuleName = configRuleName
            self.createdByService = createdByService
            self.executionControls = executionControls
            self.maximumAutomaticAttempts = maximumAutomaticAttempts
            self.parameters = parameters
            self.resourceType = resourceType
            self.retryAttemptSeconds = retryAttemptSeconds
            self.targetId = targetId
            self.targetType = targetType
            self.targetVersion = targetVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1024)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
            try self.validate(self.createdByService, name: "createdByService", parent: name, max: 1024)
            try self.validate(self.createdByService, name: "createdByService", parent: name, min: 1)
            try self.executionControls?.validate(name: "\(name).executionControls")
            try self.validate(self.maximumAutomaticAttempts, name: "maximumAutomaticAttempts", parent: name, max: 25)
            try self.validate(self.maximumAutomaticAttempts, name: "maximumAutomaticAttempts", parent: name, min: 1)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 256)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 25)
            try self.validate(self.retryAttemptSeconds, name: "retryAttemptSeconds", parent: name, max: 2678000)
            try self.validate(self.retryAttemptSeconds, name: "retryAttemptSeconds", parent: name, min: 1)
            try self.validate(self.targetId, name: "targetId", parent: name, max: 256)
            try self.validate(self.targetId, name: "targetId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case automatic = "Automatic"
            case configRuleName = "ConfigRuleName"
            case createdByService = "CreatedByService"
            case executionControls = "ExecutionControls"
            case maximumAutomaticAttempts = "MaximumAutomaticAttempts"
            case parameters = "Parameters"
            case resourceType = "ResourceType"
            case retryAttemptSeconds = "RetryAttemptSeconds"
            case targetId = "TargetId"
            case targetType = "TargetType"
            case targetVersion = "TargetVersion"
        }
    }

    public struct RemediationException: AWSDecodableShape {
        /// The name of the Config rule.
        public let configRuleName: String
        /// The time when the remediation exception will be deleted.
        public let expirationTime: Date?
        /// An explanation of an remediation exception.
        public let message: String?
        /// The ID of the resource (for example., sg-xxxxxx).
        public let resourceId: String
        /// The type of a resource.
        public let resourceType: String

        @inlinable
        public init(configRuleName: String, expirationTime: Date? = nil, message: String? = nil, resourceId: String, resourceType: String) {
            self.configRuleName = configRuleName
            self.expirationTime = expirationTime
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case expirationTime = "ExpirationTime"
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct RemediationExceptionResourceKey: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the resource (for example., sg-xxxxxx).
        public let resourceId: String?
        /// The type of a resource.
        public let resourceType: String?

        @inlinable
        public init(resourceId: String? = nil, resourceType: String? = nil) {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 1024)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct RemediationExecutionStatus: AWSDecodableShape {
        /// Start time when the remediation was executed.
        public let invocationTime: Date?
        /// The time when the remediation execution was last updated.
        public let lastUpdatedTime: Date?
        public let resourceKey: ResourceKey?
        /// ENUM of the values.
        public let state: RemediationExecutionState?
        /// Details of every step.
        public let stepDetails: [RemediationExecutionStep]?

        @inlinable
        public init(invocationTime: Date? = nil, lastUpdatedTime: Date? = nil, resourceKey: ResourceKey? = nil, state: RemediationExecutionState? = nil, stepDetails: [RemediationExecutionStep]? = nil) {
            self.invocationTime = invocationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceKey = resourceKey
            self.state = state
            self.stepDetails = stepDetails
        }

        private enum CodingKeys: String, CodingKey {
            case invocationTime = "InvocationTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case resourceKey = "ResourceKey"
            case state = "State"
            case stepDetails = "StepDetails"
        }
    }

    public struct RemediationExecutionStep: AWSDecodableShape {
        /// An error message if the step was interrupted during execution.
        public let errorMessage: String?
        /// The details of the step.
        public let name: String?
        /// The time when the step started.
        public let startTime: Date?
        /// The valid status of the step.
        public let state: RemediationExecutionStepState?
        /// The time when the step stopped.
        public let stopTime: Date?

        @inlinable
        public init(errorMessage: String? = nil, name: String? = nil, startTime: Date? = nil, state: RemediationExecutionStepState? = nil, stopTime: Date? = nil) {
            self.errorMessage = errorMessage
            self.name = name
            self.startTime = startTime
            self.state = state
            self.stopTime = stopTime
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case name = "Name"
            case startTime = "StartTime"
            case state = "State"
            case stopTime = "StopTime"
        }
    }

    public struct RemediationParameterValue: AWSEncodableShape & AWSDecodableShape {
        /// The value is dynamic and changes at run-time.
        public let resourceValue: ResourceValue?
        /// The value is static and does not change at run-time.
        public let staticValue: StaticValue?

        @inlinable
        public init(resourceValue: ResourceValue? = nil, staticValue: StaticValue? = nil) {
            self.resourceValue = resourceValue
            self.staticValue = staticValue
        }

        public func validate(name: String) throws {
            try self.staticValue?.validate(name: "\(name).staticValue")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceValue = "ResourceValue"
            case staticValue = "StaticValue"
        }
    }

    public struct ResourceCount: AWSDecodableShape {
        /// The number of resources.
        public let count: Int64?
        /// The resource type (for example,
        /// 				"AWS::EC2::Instance").
        public let resourceType: ResourceType?

        @inlinable
        public init(count: Int64? = nil, resourceType: ResourceType? = nil) {
            self.count = count
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case resourceType = "resourceType"
        }
    }

    public struct ResourceCountFilters: AWSEncodableShape {
        /// The 12-digit ID of the account.
        public let accountId: String?
        /// The region where the account is located.
        public let region: String?
        /// The type of the Amazon Web Services resource.
        public let resourceType: ResourceType?

        @inlinable
        public init(accountId: String? = nil, region: String? = nil, resourceType: ResourceType? = nil) {
            self.accountId = accountId
            self.region = region
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.region, name: "region", parent: name, max: 64)
            try self.validate(self.region, name: "region", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case region = "Region"
            case resourceType = "ResourceType"
        }
    }

    public struct ResourceDetails: AWSEncodableShape & AWSDecodableShape {
        /// The resource definition to be evaluated as per the resource configuration schema type.
        public let resourceConfiguration: String
        /// The schema type of the resource configuration.  You can find the
        /// 			Resource type schema, or CFN_RESOURCE_SCHEMA, in "Amazon Web Services public extensions" within the CloudFormation registry or with the following CLI commmand:
        /// 			aws cloudformation describe-type --type-name "AWS::S3::Bucket" --type RESOURCE. For more information, see Managing extensions through the CloudFormation registry
        /// 				and Amazon Web Services resource and property types reference in the CloudFormation User Guide.
        public let resourceConfigurationSchemaType: ResourceConfigurationSchemaType?
        /// A unique resource ID for an evaluation.
        public let resourceId: String
        /// The type of resource being evaluated.
        public let resourceType: String

        @inlinable
        public init(resourceConfiguration: String, resourceConfigurationSchemaType: ResourceConfigurationSchemaType? = nil, resourceId: String, resourceType: String) {
            self.resourceConfiguration = resourceConfiguration
            self.resourceConfigurationSchemaType = resourceConfigurationSchemaType
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceConfiguration, name: "resourceConfiguration", parent: name, max: 51200)
            try self.validate(self.resourceConfiguration, name: "resourceConfiguration", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceConfiguration = "ResourceConfiguration"
            case resourceConfigurationSchemaType = "ResourceConfigurationSchemaType"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ResourceEvaluation: AWSDecodableShape {
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public let evaluationMode: EvaluationMode?
        /// The starting time of an execution.
        public let evaluationStartTimestamp: Date?
        /// The ResourceEvaluationId of a evaluation.
        public let resourceEvaluationId: String?

        @inlinable
        public init(evaluationMode: EvaluationMode? = nil, evaluationStartTimestamp: Date? = nil, resourceEvaluationId: String? = nil) {
            self.evaluationMode = evaluationMode
            self.evaluationStartTimestamp = evaluationStartTimestamp
            self.resourceEvaluationId = resourceEvaluationId
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationMode = "EvaluationMode"
            case evaluationStartTimestamp = "EvaluationStartTimestamp"
            case resourceEvaluationId = "ResourceEvaluationId"
        }
    }

    public struct ResourceEvaluationFilters: AWSEncodableShape {
        /// Filters evaluations for a given infrastructure deployment. For example: CFN Stack.
        public let evaluationContextIdentifier: String?
        /// Filters all resource evaluations results based on an evaluation mode.  Currently, DECTECTIVE is not supported as a valid value. Ignore other documentation stating otherwise.
        public let evaluationMode: EvaluationMode?
        /// Returns a TimeWindow object.
        public let timeWindow: TimeWindow?

        @inlinable
        public init(evaluationContextIdentifier: String? = nil, evaluationMode: EvaluationMode? = nil, timeWindow: TimeWindow? = nil) {
            self.evaluationContextIdentifier = evaluationContextIdentifier
            self.evaluationMode = evaluationMode
            self.timeWindow = timeWindow
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluationContextIdentifier, name: "evaluationContextIdentifier", parent: name, max: 128)
            try self.validate(self.evaluationContextIdentifier, name: "evaluationContextIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationContextIdentifier = "EvaluationContextIdentifier"
            case evaluationMode = "EvaluationMode"
            case timeWindow = "TimeWindow"
        }
    }

    public struct ResourceFilters: AWSEncodableShape {
        /// The 12-digit source account ID.
        public let accountId: String?
        /// The source region.
        public let region: String?
        /// The ID of the resource.
        public let resourceId: String?
        /// The name of the resource.
        public let resourceName: String?

        @inlinable
        public init(accountId: String? = nil, region: String? = nil, resourceId: String? = nil, resourceName: String? = nil) {
            self.accountId = accountId
            self.region = region
            self.resourceId = resourceId
            self.resourceName = resourceName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.region, name: "region", parent: name, max: 64)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case region = "Region"
            case resourceId = "ResourceId"
            case resourceName = "ResourceName"
        }
    }

    public struct ResourceIdentifier: AWSDecodableShape {
        /// The time that the resource was deleted.
        public let resourceDeletionTime: Date?
        /// The ID of the resource (for example,
        /// 			sg-xxxxxx).
        public let resourceId: String?
        /// The custom name of the resource (if available).
        public let resourceName: String?
        /// The type of resource.
        public let resourceType: ResourceType?

        @inlinable
        public init(resourceDeletionTime: Date? = nil, resourceId: String? = nil, resourceName: String? = nil, resourceType: ResourceType? = nil) {
            self.resourceDeletionTime = resourceDeletionTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case resourceDeletionTime = "resourceDeletionTime"
            case resourceId = "resourceId"
            case resourceName = "resourceName"
            case resourceType = "resourceType"
        }
    }

    public struct ResourceKey: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the resource (for example., sg-xxxxxx).
        public let resourceId: String
        /// The resource type.
        public let resourceType: ResourceType

        @inlinable
        public init(resourceId: String, resourceType: ResourceType) {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ResourceValue: AWSEncodableShape & AWSDecodableShape {
        /// The value is a resource ID.
        public let value: ResourceValueType

        @inlinable
        public init(value: ResourceValueType) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct RetentionConfiguration: AWSDecodableShape {
        /// The name of the retention configuration object.
        public let name: String
        /// Number of days Config stores your historical information.  Currently, only applicable to the configuration item history.
        public let retentionPeriodInDays: Int

        @inlinable
        public init(name: String, retentionPeriodInDays: Int) {
            self.name = name
            self.retentionPeriodInDays = retentionPeriodInDays
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case retentionPeriodInDays = "RetentionPeriodInDays"
        }
    }

    public struct Scope: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the only Amazon Web Services resource that you want to trigger an
        /// 			evaluation for the rule. If you specify a resource ID, you must
        /// 			specify one resource type for
        /// 			ComplianceResourceTypes.
        public let complianceResourceId: String?
        /// The resource types of only those Amazon Web Services resources that you want to
        /// 			trigger an evaluation for the rule. You can only specify one type if
        /// 			you also specify a resource ID for
        /// 			ComplianceResourceId.
        public let complianceResourceTypes: [String]?
        /// The tag key that is applied to only those Amazon Web Services resources that
        /// 			you want to trigger an evaluation for the rule.
        public let tagKey: String?
        /// The tag value applied to only those Amazon Web Services resources that you want
        /// 			to trigger an evaluation for the rule. If you specify a value for
        /// 				TagValue, you must also specify a value for
        /// 				TagKey.
        public let tagValue: String?

        @inlinable
        public init(complianceResourceId: String? = nil, complianceResourceTypes: [String]? = nil, tagKey: String? = nil, tagValue: String? = nil) {
            self.complianceResourceId = complianceResourceId
            self.complianceResourceTypes = complianceResourceTypes
            self.tagKey = tagKey
            self.tagValue = tagValue
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, max: 768)
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, min: 1)
            try self.complianceResourceTypes?.forEach {
                try validate($0, name: "complianceResourceTypes[]", parent: name, max: 256)
                try validate($0, name: "complianceResourceTypes[]", parent: name, min: 1)
            }
            try self.validate(self.complianceResourceTypes, name: "complianceResourceTypes", parent: name, max: 100)
            try self.validate(self.tagKey, name: "tagKey", parent: name, max: 128)
            try self.validate(self.tagKey, name: "tagKey", parent: name, min: 1)
            try self.validate(self.tagValue, name: "tagValue", parent: name, max: 256)
            try self.validate(self.tagValue, name: "tagValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceResourceId = "ComplianceResourceId"
            case complianceResourceTypes = "ComplianceResourceTypes"
            case tagKey = "TagKey"
            case tagValue = "TagValue"
        }
    }

    public struct SelectAggregateResourceConfigRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// The SQL query SELECT command.
        public let expression: String
        /// The maximum number of query results returned on each page.
        public let limit: Int?
        /// The maximum number of query results returned on each page. Config also allows the Limit request parameter.
        public let maxResults: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(configurationAggregatorName: String, expression: String, limit: Int? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.expression = expression
            self.limit = limit
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case expression = "Expression"
            case limit = "Limit"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SelectAggregateResourceConfigResponse: AWSDecodableShape {
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?
        public let queryInfo: QueryInfo?
        /// Returns the results for the SQL query.
        public let results: [String]?

        @inlinable
        public init(nextToken: String? = nil, queryInfo: QueryInfo? = nil, results: [String]? = nil) {
            self.nextToken = nextToken
            self.queryInfo = queryInfo
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case queryInfo = "QueryInfo"
            case results = "Results"
        }
    }

    public struct SelectResourceConfigRequest: AWSEncodableShape {
        /// The SQL query SELECT command.
        public let expression: String
        /// The maximum number of query results returned on each page.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        @inlinable
        public init(expression: String, limit: Int? = nil, nextToken: String? = nil) {
            self.expression = expression
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct SelectResourceConfigResponse: AWSDecodableShape {
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns the QueryInfo object.
        public let queryInfo: QueryInfo?
        /// Returns the results for the SQL query.
        public let results: [String]?

        @inlinable
        public init(nextToken: String? = nil, queryInfo: QueryInfo? = nil, results: [String]? = nil) {
            self.nextToken = nextToken
            self.queryInfo = queryInfo
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case queryInfo = "QueryInfo"
            case results = "Results"
        }
    }

    public struct Source: AWSEncodableShape & AWSDecodableShape {
        /// Provides the runtime system, policy definition, and whether debug logging is enabled. Required when owner is set to CUSTOM_POLICY.
        public let customPolicyDetails: CustomPolicyDetails?
        /// Indicates whether Amazon Web Services or the customer owns and manages the Config rule. Config Managed Rules are predefined rules owned by Amazon Web Services. For more information, see Config Managed Rules in the Config developer guide. Config Custom Rules are rules that you can develop either with Guard (CUSTOM_POLICY) or Lambda (CUSTOM_LAMBDA). For more information, see Config Custom Rules  in the Config developer guide.
        public let owner: Owner
        /// Provides the source and the message types that cause Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic. If the owner is set to CUSTOM_POLICY, the only acceptable values for the Config rule trigger message type are ConfigurationItemChangeNotification and OversizedConfigurationItemChangeNotification.
        public let sourceDetails: [SourceDetail]?
        /// For Config Managed rules, a predefined identifier from a
        /// 			list. For example, IAM_PASSWORD_POLICY is a managed
        /// 			rule. To reference a managed rule, see List of Config Managed Rules. For Config Custom Lambda rules, the identifier is the Amazon Resource Name
        /// 			(ARN) of the rule's Lambda function, such as
        /// 			arn:aws:lambda:us-east-2:123456789012:function:custom_rule_name. For Config Custom Policy rules, this field will be ignored.
        public let sourceIdentifier: String?

        @inlinable
        public init(customPolicyDetails: CustomPolicyDetails? = nil, owner: Owner, sourceDetails: [SourceDetail]? = nil, sourceIdentifier: String? = nil) {
            self.customPolicyDetails = customPolicyDetails
            self.owner = owner
            self.sourceDetails = sourceDetails
            self.sourceIdentifier = sourceIdentifier
        }

        public func validate(name: String) throws {
            try self.customPolicyDetails?.validate(name: "\(name).customPolicyDetails")
            try self.validate(self.sourceDetails, name: "sourceDetails", parent: name, max: 25)
            try self.validate(self.sourceIdentifier, name: "sourceIdentifier", parent: name, max: 256)
            try self.validate(self.sourceIdentifier, name: "sourceIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customPolicyDetails = "CustomPolicyDetails"
            case owner = "Owner"
            case sourceDetails = "SourceDetails"
            case sourceIdentifier = "SourceIdentifier"
        }
    }

    public struct SourceDetail: AWSEncodableShape & AWSDecodableShape {
        /// The source of the event, such as an Amazon Web Services service, that triggers
        /// 			Config to evaluate your Amazon Web Services resources.
        public let eventSource: EventSource?
        /// The frequency at which you want Config to run evaluations
        /// 			for a custom rule with a periodic trigger. If you specify a value
        /// 			for MaximumExecutionFrequency, then
        /// 				MessageType must use the
        /// 				ScheduledNotification value.  By default, rules with a periodic trigger are evaluated
        /// 				every 24 hours. To change the frequency, specify a valid value
        /// 				for the MaximumExecutionFrequency
        /// 				parameter. Based on the valid value you choose, Config runs
        /// 				evaluations once for each valid value. For example, if you
        /// 				choose Three_Hours, Config runs evaluations
        /// 				once every three hours. In this case, Three_Hours
        /// 				is the frequency of this rule.
        public let maximumExecutionFrequency: MaximumExecutionFrequency?
        /// The type of notification that triggers Config to run an
        /// 			evaluation for a rule. You can specify the following notification
        /// 			types:    ConfigurationItemChangeNotification - Triggers
        /// 					an evaluation when Config delivers a configuration item
        /// 					as a result of a resource change.    OversizedConfigurationItemChangeNotification
        /// 					- Triggers an evaluation when Config delivers an
        /// 					oversized configuration item. Config may generate this
        /// 					notification type when a resource changes and the
        /// 					notification exceeds the maximum size allowed by Amazon
        /// 					SNS.    ScheduledNotification - Triggers a
        /// 					periodic evaluation at the frequency specified for
        /// 						MaximumExecutionFrequency.    ConfigurationSnapshotDeliveryCompleted -
        /// 					Triggers a periodic evaluation when Config delivers a
        /// 					configuration snapshot.   If you want your custom rule to be triggered by configuration
        /// 			changes, specify two SourceDetail objects, one for
        /// 				ConfigurationItemChangeNotification and one for
        /// 				OversizedConfigurationItemChangeNotification.
        public let messageType: MessageType?

        @inlinable
        public init(eventSource: EventSource? = nil, maximumExecutionFrequency: MaximumExecutionFrequency? = nil, messageType: MessageType? = nil) {
            self.eventSource = eventSource
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.messageType = messageType
        }

        private enum CodingKeys: String, CodingKey {
            case eventSource = "EventSource"
            case maximumExecutionFrequency = "MaximumExecutionFrequency"
            case messageType = "MessageType"
        }
    }

    public struct SsmControls: AWSEncodableShape & AWSDecodableShape {
        /// The maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. You can specify a percentage, such as 10%. The default value is 10.
        public let concurrentExecutionRatePercentage: Int?
        /// The percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule.
        /// 			You can specify a percentage of errors, for example 10%. If you do not specifiy a percentage, the default is 50%.
        /// 			For example, if you set the ErrorPercentage to 40% for 10 non-compliant resources, then SSM stops running the automations when the fifth error is received.
        public let errorPercentage: Int?

        @inlinable
        public init(concurrentExecutionRatePercentage: Int? = nil, errorPercentage: Int? = nil) {
            self.concurrentExecutionRatePercentage = concurrentExecutionRatePercentage
            self.errorPercentage = errorPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.concurrentExecutionRatePercentage, name: "concurrentExecutionRatePercentage", parent: name, max: 100)
            try self.validate(self.concurrentExecutionRatePercentage, name: "concurrentExecutionRatePercentage", parent: name, min: 1)
            try self.validate(self.errorPercentage, name: "errorPercentage", parent: name, max: 100)
            try self.validate(self.errorPercentage, name: "errorPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case concurrentExecutionRatePercentage = "ConcurrentExecutionRatePercentage"
            case errorPercentage = "ErrorPercentage"
        }
    }

    public struct StartConfigRulesEvaluationRequest: AWSEncodableShape {
        /// The list of names of Config rules that you want to run
        /// 			evaluations for.
        public let configRuleNames: [String]?

        @inlinable
        public init(configRuleNames: [String]? = nil) {
            self.configRuleNames = configRuleNames
        }

        public func validate(name: String) throws {
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 128)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
                try validate($0, name: "configRuleNames[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 25)
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleNames = "ConfigRuleNames"
        }
    }

    public struct StartConfigRulesEvaluationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartConfigurationRecorderRequest: AWSEncodableShape {
        /// The name of the customer managed configuration recorder that you want to start.
        public let configurationRecorderName: String

        @inlinable
        public init(configurationRecorderName: String) {
            self.configurationRecorderName = configurationRecorderName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, max: 256)
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorderName = "ConfigurationRecorderName"
        }
    }

    public struct StartRemediationExecutionRequest: AWSEncodableShape {
        /// The list of names of Config rules that you want to run remediation execution for.
        public let configRuleName: String
        /// A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID.
        public let resourceKeys: [ResourceKey]

        @inlinable
        public init(configRuleName: String, resourceKeys: [ResourceKey]) {
            self.configRuleName = configRuleName
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: "\\S")
            try self.resourceKeys.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case resourceKeys = "ResourceKeys"
        }
    }

    public struct StartRemediationExecutionResponse: AWSDecodableShape {
        /// For resources that have failed to start execution, the API returns a resource key object.
        public let failedItems: [ResourceKey]?
        /// Returns a failure message. For example, the resource is already compliant.
        public let failureMessage: String?

        @inlinable
        public init(failedItems: [ResourceKey]? = nil, failureMessage: String? = nil) {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }

        private enum CodingKeys: String, CodingKey {
            case failedItems = "FailedItems"
            case failureMessage = "FailureMessage"
        }
    }

    public struct StartResourceEvaluationRequest: AWSEncodableShape {
        /// A client token is a unique, case-sensitive string of up to 64 ASCII characters.
        /// 			To make an idempotent API request using one of these actions, specify a client token in the request.  Avoid reusing the same client token for other API requests. If you retry
        /// 				a request that completed successfully using the same client token and the same
        /// 				parameters, the retry succeeds without performing any further actions. If you retry
        /// 				a successful request using the same client token, but one or more of the parameters
        /// 				are different, other than the Region or Availability Zone, the retry fails with an
        /// 				IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Returns an EvaluationContext object.
        public let evaluationContext: EvaluationContext?
        /// The mode of an evaluation. The valid values for this API are DETECTIVE and PROACTIVE.
        public let evaluationMode: EvaluationMode
        /// The timeout for an evaluation. The default is 900 seconds. You cannot specify a number greater than 3600. If you specify 0, Config uses the default.
        public let evaluationTimeout: Int?
        /// Returns a ResourceDetails object.
        public let resourceDetails: ResourceDetails

        @inlinable
        public init(clientToken: String? = nil, evaluationContext: EvaluationContext? = nil, evaluationMode: EvaluationMode, evaluationTimeout: Int? = nil, resourceDetails: ResourceDetails) {
            self.clientToken = clientToken
            self.evaluationContext = evaluationContext
            self.evaluationMode = evaluationMode
            self.evaluationTimeout = evaluationTimeout
            self.resourceDetails = resourceDetails
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 64)
            try self.evaluationContext?.validate(name: "\(name).evaluationContext")
            try self.validate(self.evaluationTimeout, name: "evaluationTimeout", parent: name, max: 3600)
            try self.validate(self.evaluationTimeout, name: "evaluationTimeout", parent: name, min: 0)
            try self.resourceDetails.validate(name: "\(name).resourceDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case evaluationContext = "EvaluationContext"
            case evaluationMode = "EvaluationMode"
            case evaluationTimeout = "EvaluationTimeout"
            case resourceDetails = "ResourceDetails"
        }
    }

    public struct StartResourceEvaluationResponse: AWSDecodableShape {
        /// A
        /// 			unique ResourceEvaluationId that is associated with a single execution.
        public let resourceEvaluationId: String?

        @inlinable
        public init(resourceEvaluationId: String? = nil) {
            self.resourceEvaluationId = resourceEvaluationId
        }

        private enum CodingKeys: String, CodingKey {
            case resourceEvaluationId = "ResourceEvaluationId"
        }
    }

    public struct StaticValue: AWSEncodableShape & AWSDecodableShape {
        /// A list of values. For example, the ARN of the assumed role.
        public let values: [String]

        @inlinable
        public init(values: [String]) {
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 256)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct StatusDetailFilters: AWSEncodableShape {
        /// The 12-digit account ID of the member account within an organization.
        public let accountId: String?
        /// Indicates deployment status for Config rule in the member account.
        /// 			When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in the member account.
        /// 			When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in the member account.
        /// 			Config rule status is deleted when the management account deletes OrganizationConfigRule and disables service access for config-multiaccountsetup.amazonaws.com.
        /// 			 Config sets the state of the rule to:    CREATE_SUCCESSFUL when Config rule has been created in the member account.    CREATE_IN_PROGRESS when Config rule is being created in the member account.    CREATE_FAILED when Config rule creation has failed in the member account.    DELETE_FAILED when Config rule deletion has failed in the member account.    DELETE_IN_PROGRESS when Config rule is being deleted in the member account.    DELETE_SUCCESSFUL when Config rule has been deleted in the member account.    UPDATE_SUCCESSFUL when Config rule has been updated in the member account.    UPDATE_IN_PROGRESS when Config rule is being updated in the member account.    UPDATE_FAILED when Config rule deletion has failed in the member account.
        public let memberAccountRuleStatus: MemberAccountRuleStatus?

        @inlinable
        public init(accountId: String? = nil, memberAccountRuleStatus: MemberAccountRuleStatus? = nil) {
            self.accountId = accountId
            self.memberAccountRuleStatus = memberAccountRuleStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case memberAccountRuleStatus = "MemberAccountRuleStatus"
        }
    }

    public struct StopConfigurationRecorderRequest: AWSEncodableShape {
        /// The name of the customer managed configuration recorder that you want to stop.
        public let configurationRecorderName: String

        @inlinable
        public init(configurationRecorderName: String) {
            self.configurationRecorderName = configurationRecorderName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, max: 256)
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorderName = "ConfigurationRecorderName"
        }
    }

    public struct StoredQuery: AWSEncodableShape & AWSDecodableShape {
        /// A unique description for the query.
        public let description: String?
        /// The expression of the query. For example, SELECT
        /// 			resourceId,
        /// 			resourceType,
        /// 			supplementaryConfiguration.BucketVersioningConfiguration.status
        /// 			WHERE
        /// 			resourceType = 'AWS::S3::Bucket'
        /// 			AND supplementaryConfiguration.BucketVersioningConfiguration.status = 'Off'.
        public let expression: String?
        /// Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
        public let queryArn: String?
        /// The ID of the query.
        public let queryId: String?
        /// The name of the query.
        public let queryName: String

        @inlinable
        public init(description: String? = nil, expression: String? = nil, queryArn: String? = nil, queryId: String? = nil, queryName: String) {
            self.description = description
            self.expression = expression
            self.queryArn = queryArn
            self.queryId = queryId
            self.queryName = queryName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.queryArn, name: "queryArn", parent: name, max: 500)
            try self.validate(self.queryArn, name: "queryArn", parent: name, min: 1)
            try self.validate(self.queryArn, name: "queryArn", parent: name, pattern: "^arn:aws[a-z\\-]*:config:[a-z\\-\\d]+:\\d+:stored-query/[a-zA-Z0-9-_]+/query-[a-zA-Z\\d-_/]+$")
            try self.validate(self.queryId, name: "queryId", parent: name, max: 36)
            try self.validate(self.queryId, name: "queryId", parent: name, min: 1)
            try self.validate(self.queryId, name: "queryId", parent: name, pattern: "^\\S+$")
            try self.validate(self.queryName, name: "queryName", parent: name, max: 64)
            try self.validate(self.queryName, name: "queryName", parent: name, min: 1)
            try self.validate(self.queryName, name: "queryName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case expression = "Expression"
            case queryArn = "QueryArn"
            case queryId = "QueryId"
            case queryName = "QueryName"
        }
    }

    public struct StoredQueryMetadata: AWSDecodableShape {
        /// A unique description for the query.
        public let description: String?
        /// Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
        public let queryArn: String
        /// The ID of the query.
        public let queryId: String
        /// The name of the query.
        public let queryName: String

        @inlinable
        public init(description: String? = nil, queryArn: String, queryId: String, queryName: String) {
            self.description = description
            self.queryArn = queryArn
            self.queryId = queryId
            self.queryName = queryName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case queryArn = "QueryArn"
            case queryId = "QueryId"
            case queryName = "QueryName"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let key: String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. The following resources are supported:    ConfigurationRecorder     ConfigRule     OrganizationConfigRule     ConformancePack     OrganizationConformancePack     ConfigurationAggregator     AggregationAuthorization     StoredQuery
        public let resourceArn: String
        /// An array of tag object.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TemplateSSMDocumentDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name or Amazon Resource Name (ARN) of the SSM document to use to create a conformance pack.
        /// 			If you use the document name, Config checks only your account and Amazon Web Services Region for the SSM document.
        public let documentName: String
        /// The version of the SSM document to use to create a conformance pack. By default, Config uses the latest version.  This field is optional.
        public let documentVersion: String?

        @inlinable
        public init(documentName: String, documentVersion: String? = nil) {
            self.documentName = documentName
            self.documentVersion = documentVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.documentName, name: "documentName", parent: name, pattern: "^[a-zA-Z0-9_\\-.:/]{3,200}$")
            try self.validate(self.documentVersion, name: "documentVersion", parent: name, pattern: "^([$]LATEST|[$]DEFAULT|^[1-9][0-9]*$)$")
        }

        private enum CodingKeys: String, CodingKey {
            case documentName = "DocumentName"
            case documentVersion = "DocumentVersion"
        }
    }

    public struct TimeWindow: AWSEncodableShape {
        /// The end time of an execution. The end time must be after the start date.
        public let endTime: Date?
        /// The start time of an execution.
        public let startTime: Date?

        @inlinable
        public init(endTime: Date? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. The following resources are supported:    ConfigurationRecorder     ConfigRule     OrganizationConfigRule     ConformancePack     OrganizationConformancePack     ConfigurationAggregator     AggregationAuthorization     StoredQuery
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }
}

// MARK: - Errors

/// Error enum for ConfigService
public struct ConfigServiceErrorType: AWSErrorType {
    enum Code: String {
        case conflictException = "ConflictException"
        case conformancePackTemplateValidationException = "ConformancePackTemplateValidationException"
        case idempotentParameterMismatch = "IdempotentParameterMismatch"
        case insufficientDeliveryPolicyException = "InsufficientDeliveryPolicyException"
        case insufficientPermissionsException = "InsufficientPermissionsException"
        case invalidConfigurationRecorderNameException = "InvalidConfigurationRecorderNameException"
        case invalidDeliveryChannelNameException = "InvalidDeliveryChannelNameException"
        case invalidExpressionException = "InvalidExpressionException"
        case invalidLimitException = "InvalidLimitException"
        case invalidNextTokenException = "InvalidNextTokenException"
        case invalidParameterValueException = "InvalidParameterValueException"
        case invalidRecordingGroupException = "InvalidRecordingGroupException"
        case invalidResultTokenException = "InvalidResultTokenException"
        case invalidRoleException = "InvalidRoleException"
        case invalidS3KeyPrefixException = "InvalidS3KeyPrefixException"
        case invalidS3KmsKeyArnException = "InvalidS3KmsKeyArnException"
        case invalidSNSTopicARNException = "InvalidSNSTopicARNException"
        case invalidTimeRangeException = "InvalidTimeRangeException"
        case lastDeliveryChannelDeleteFailedException = "LastDeliveryChannelDeleteFailedException"
        case limitExceededException = "LimitExceededException"
        case maxActiveResourcesExceededException = "MaxActiveResourcesExceededException"
        case maxNumberOfConfigRulesExceededException = "MaxNumberOfConfigRulesExceededException"
        case maxNumberOfConfigurationRecordersExceededException = "MaxNumberOfConfigurationRecordersExceededException"
        case maxNumberOfConformancePacksExceededException = "MaxNumberOfConformancePacksExceededException"
        case maxNumberOfDeliveryChannelsExceededException = "MaxNumberOfDeliveryChannelsExceededException"
        case maxNumberOfOrganizationConfigRulesExceededException = "MaxNumberOfOrganizationConfigRulesExceededException"
        case maxNumberOfOrganizationConformancePacksExceededException = "MaxNumberOfOrganizationConformancePacksExceededException"
        case maxNumberOfRetentionConfigurationsExceededException = "MaxNumberOfRetentionConfigurationsExceededException"
        case noAvailableConfigurationRecorderException = "NoAvailableConfigurationRecorderException"
        case noAvailableDeliveryChannelException = "NoAvailableDeliveryChannelException"
        case noAvailableOrganizationException = "NoAvailableOrganizationException"
        case noRunningConfigurationRecorderException = "NoRunningConfigurationRecorderException"
        case noSuchBucketException = "NoSuchBucketException"
        case noSuchConfigRuleException = "NoSuchConfigRuleException"
        case noSuchConfigRuleInConformancePackException = "NoSuchConfigRuleInConformancePackException"
        case noSuchConfigurationAggregatorException = "NoSuchConfigurationAggregatorException"
        case noSuchConfigurationRecorderException = "NoSuchConfigurationRecorderException"
        case noSuchConformancePackException = "NoSuchConformancePackException"
        case noSuchDeliveryChannelException = "NoSuchDeliveryChannelException"
        case noSuchOrganizationConfigRuleException = "NoSuchOrganizationConfigRuleException"
        case noSuchOrganizationConformancePackException = "NoSuchOrganizationConformancePackException"
        case noSuchRemediationConfigurationException = "NoSuchRemediationConfigurationException"
        case noSuchRemediationExceptionException = "NoSuchRemediationExceptionException"
        case noSuchRetentionConfigurationException = "NoSuchRetentionConfigurationException"
        case organizationAccessDeniedException = "OrganizationAccessDeniedException"
        case organizationAllFeaturesNotEnabledException = "OrganizationAllFeaturesNotEnabledException"
        case organizationConformancePackTemplateValidationException = "OrganizationConformancePackTemplateValidationException"
        case oversizedConfigurationItemException = "OversizedConfigurationItemException"
        case remediationInProgressException = "RemediationInProgressException"
        case resourceConcurrentModificationException = "ResourceConcurrentModificationException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotDiscoveredException = "ResourceNotDiscoveredException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case tooManyTagsException = "TooManyTagsException"
        case unmodifiableEntityException = "UnmodifiableEntityException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ConfigService
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// For PutServiceLinkedConfigurationRecorder, you cannot create a service-linked recorder because a service-linked recorder already exists for the specified service. For DeleteServiceLinkedConfigurationRecorder, you cannot delete the service-linked recorder because it is currently in use by the linked Amazon Web Services service. For DeleteDeliveryChannel, you cannot delete the specified delivery channel because the customer managed configuration recorder is running. Use the StopConfigurationRecorder operation to stop the customer managed configuration
    /// 			recorder. For AssociateResourceTypes and DisassociateResourceTypes, one of the following errors:   For service-linked configuration recorders, the configuration recorder is not in use by the service. No association or dissociation of resource types is permitted.   For service-linked configuration recorders, your requested change to the configuration recorder has been denied by its linked Amazon Web Services service.
    public static var conflictException: Self { .init(.conflictException) }
    /// You have specified a template that is not valid or supported.
    public static var conformancePackTemplateValidationException: Self { .init(.conformancePackTemplateValidationException) }
    /// Using the same client token with one or more different parameters. Specify a new client token with the parameter changes and try again.
    public static var idempotentParameterMismatch: Self { .init(.idempotentParameterMismatch) }
    /// Your Amazon S3 bucket policy does not allow Config to
    /// 			write to it.
    public static var insufficientDeliveryPolicyException: Self { .init(.insufficientDeliveryPolicyException) }
    /// Indicates one of the following errors:   For PutConfigRule, the rule cannot be created because the IAM role assigned to Config lacks permissions to perform the config:Put* action.   For PutConfigRule, the Lambda function cannot be invoked. Check the function ARN, and check the function's permissions.   For PutOrganizationConfigRule, organization Config rule cannot be created because you do not have permissions to call IAM GetRole action or create a service-linked role.   For PutConformancePack and PutOrganizationConformancePack, a conformance pack cannot be created because you do not have the following permissions:    You do not have permission to call IAM GetRole action or create a service-linked role.   You do not have permission to read Amazon S3 bucket or call SSM:GetDocument.     For PutServiceLinkedConfigurationRecorder, a service-linked configuration recorder cannot be created because you do not have the following permissions: IAM CreateServiceLinkedRole.
    public static var insufficientPermissionsException: Self { .init(.insufficientPermissionsException) }
    /// You have provided a name for the customer managed configuration recorder that is not
    /// 			valid.
    public static var invalidConfigurationRecorderNameException: Self { .init(.invalidConfigurationRecorderNameException) }
    /// The specified delivery channel name is not valid.
    public static var invalidDeliveryChannelNameException: Self { .init(.invalidDeliveryChannelNameException) }
    /// The syntax of the query is incorrect.
    public static var invalidExpressionException: Self { .init(.invalidExpressionException) }
    /// The specified limit is outside the allowable range.
    public static var invalidLimitException: Self { .init(.invalidLimitException) }
    /// The specified next token is not valid. Specify the
    /// 				nextToken string that was returned in the previous
    /// 			response to get the next page of results.
    public static var invalidNextTokenException: Self { .init(.invalidNextTokenException) }
    /// One or more of the specified parameters are not valid. Verify
    /// 			that your parameters are valid and try again.
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    /// One of the following errors:   You have provided a combination of parameter values that is not valid. For example:   Setting the allSupported field of RecordingGroup to true,
    /// 						but providing a non-empty list for the resourceTypesfield of RecordingGroup.   Setting the allSupported field of RecordingGroup to true, but also setting the useOnly field of RecordingStrategy to EXCLUSION_BY_RESOURCE_TYPES.     Every parameter is either null, false, or empty.   You have reached the limit of the number of resource types you can provide for the recording group.   You have provided resource types or a recording strategy that are not valid.
    public static var invalidRecordingGroupException: Self { .init(.invalidRecordingGroupException) }
    /// The specified ResultToken is not valid.
    public static var invalidResultTokenException: Self { .init(.invalidResultTokenException) }
    /// You have provided a null or empty Amazon Resource Name (ARN) for the IAM role assumed by Config and used by the customer managed configuration recorder.
    public static var invalidRoleException: Self { .init(.invalidRoleException) }
    /// The specified Amazon S3 key prefix is not valid.
    public static var invalidS3KeyPrefixException: Self { .init(.invalidS3KeyPrefixException) }
    /// The specified Amazon KMS Key ARN is not valid.
    public static var invalidS3KmsKeyArnException: Self { .init(.invalidS3KmsKeyArnException) }
    /// The specified Amazon SNS topic does not exist.
    public static var invalidSNSTopicARNException: Self { .init(.invalidSNSTopicARNException) }
    /// The specified time range is not valid. The earlier time is not
    /// 			chronologically before the later time.
    public static var invalidTimeRangeException: Self { .init(.invalidTimeRangeException) }
    /// You cannot delete the delivery channel you specified because the customer managed configuration recorder is running.
    public static var lastDeliveryChannelDeleteFailedException: Self { .init(.lastDeliveryChannelDeleteFailedException) }
    /// For PutServiceLinkedConfigurationRecorder API, this exception
    /// 			is thrown if the number of service-linked roles in the account exceeds the limit. For StartConfigRulesEvaluation API, this exception
    /// 			is thrown if an evaluation is in progress or if you call the StartConfigRulesEvaluation API more than once per
    /// 			minute. For PutConfigurationAggregator API, this exception
    /// 			is thrown if the number of accounts and aggregators exceeds the
    /// 			limit.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// You have reached the limit of active custom resource types in your account. There is a limit of 100,000.
    /// 			Delete unused resources using DeleteResourceConfig .
    public static var maxActiveResourcesExceededException: Self { .init(.maxActiveResourcesExceededException) }
    /// Failed to add the Config rule because the account already
    /// 			contains the maximum number of 1000 rules. Consider deleting any
    /// 			deactivated rules before you add new rules.
    public static var maxNumberOfConfigRulesExceededException: Self { .init(.maxNumberOfConfigRulesExceededException) }
    /// You have reached the limit of the number of configuration recorders you can
    /// 			create.
    public static var maxNumberOfConfigurationRecordersExceededException: Self { .init(.maxNumberOfConfigurationRecordersExceededException) }
    /// You have reached the limit of the number of conformance packs you can create in an account. For more information, see  Service Limits in the Config Developer Guide.
    public static var maxNumberOfConformancePacksExceededException: Self { .init(.maxNumberOfConformancePacksExceededException) }
    /// You have reached the limit of the number of delivery channels
    /// 			you can create.
    public static var maxNumberOfDeliveryChannelsExceededException: Self { .init(.maxNumberOfDeliveryChannelsExceededException) }
    /// You have reached the limit of the number of organization Config rules you can create. For more information, see see  Service Limits in the Config Developer Guide.
    public static var maxNumberOfOrganizationConfigRulesExceededException: Self { .init(.maxNumberOfOrganizationConfigRulesExceededException) }
    /// You have reached the limit of the number of organization conformance packs you can create in an account. For more information, see  Service Limits in the Config Developer Guide.
    public static var maxNumberOfOrganizationConformancePacksExceededException: Self { .init(.maxNumberOfOrganizationConformancePacksExceededException) }
    /// Failed to add the retention configuration because a retention configuration with that name already exists.
    public static var maxNumberOfRetentionConfigurationsExceededException: Self { .init(.maxNumberOfRetentionConfigurationsExceededException) }
    /// There are no customer managed configuration recorders available to record your resources. Use the PutConfigurationRecorder operation to create the customer managed configuration
    /// 			recorder.
    public static var noAvailableConfigurationRecorderException: Self { .init(.noAvailableConfigurationRecorderException) }
    /// There is no delivery channel available to record
    /// 			configurations.
    public static var noAvailableDeliveryChannelException: Self { .init(.noAvailableDeliveryChannelException) }
    /// Organization is no longer available.
    public static var noAvailableOrganizationException: Self { .init(.noAvailableOrganizationException) }
    /// There is no configuration recorder running.
    public static var noRunningConfigurationRecorderException: Self { .init(.noRunningConfigurationRecorderException) }
    /// The specified Amazon S3 bucket does not exist.
    public static var noSuchBucketException: Self { .init(.noSuchBucketException) }
    /// The Config rule in the request is not valid. Verify that the rule is an Config Process Check rule, that the rule name is correct, and that valid Amazon Resouce Names (ARNs) are used before trying again.
    public static var noSuchConfigRuleException: Self { .init(.noSuchConfigRuleException) }
    /// Config rule that you passed in the filter does not exist.
    public static var noSuchConfigRuleInConformancePackException: Self { .init(.noSuchConfigRuleInConformancePackException) }
    /// You have specified a configuration aggregator that does not exist.
    public static var noSuchConfigurationAggregatorException: Self { .init(.noSuchConfigurationAggregatorException) }
    /// You have specified a configuration recorder that does not
    /// 			exist.
    public static var noSuchConfigurationRecorderException: Self { .init(.noSuchConfigurationRecorderException) }
    /// You specified one or more conformance packs that do not exist.
    public static var noSuchConformancePackException: Self { .init(.noSuchConformancePackException) }
    /// You have specified a delivery channel that does not
    /// 			exist.
    public static var noSuchDeliveryChannelException: Self { .init(.noSuchDeliveryChannelException) }
    /// The Config rule in the request is not valid. Verify that the rule is an organization Config Process Check rule, that the rule name is correct, and that valid Amazon Resouce Names (ARNs) are used before trying again.
    public static var noSuchOrganizationConfigRuleException: Self { .init(.noSuchOrganizationConfigRuleException) }
    /// Config organization conformance pack that you passed in the filter does not exist. For DeleteOrganizationConformancePack, you tried to delete an organization conformance pack that does not exist.
    public static var noSuchOrganizationConformancePackException: Self { .init(.noSuchOrganizationConformancePackException) }
    /// You specified an Config rule without a remediation configuration.
    public static var noSuchRemediationConfigurationException: Self { .init(.noSuchRemediationConfigurationException) }
    /// You tried to delete a remediation exception that does not exist.
    public static var noSuchRemediationExceptionException: Self { .init(.noSuchRemediationExceptionException) }
    /// You have specified a retention configuration that does not exist.
    public static var noSuchRetentionConfigurationException: Self { .init(.noSuchRetentionConfigurationException) }
    /// For PutConfigurationAggregator API, you can see this exception for the following reasons:   No permission to call EnableAWSServiceAccess API   The configuration aggregator cannot be updated because your Amazon Web Services Organization management account or the delegated administrator role changed.
    /// 				Delete this aggregator and create a new one with the current Amazon Web Services Organization.   The configuration aggregator is associated with a previous Amazon Web Services Organization and Config cannot aggregate data with current Amazon Web Services Organization.
    /// 				Delete this aggregator and create a new one with the current Amazon Web Services Organization.   You are not a registered delegated administrator for Config with permissions to call ListDelegatedAdministrators API.
    /// 			Ensure that the management account registers delagated administrator for Config service principal name before the delegated administrator creates an aggregator.   For all OrganizationConfigRule and OrganizationConformancePack APIs, Config throws an exception if APIs are called from member accounts. All APIs must be called from organization management account.
    public static var organizationAccessDeniedException: Self { .init(.organizationAccessDeniedException) }
    /// Config resource cannot be created because your organization does not have all features enabled.
    public static var organizationAllFeaturesNotEnabledException: Self { .init(.organizationAllFeaturesNotEnabledException) }
    /// You have specified a template that is not valid or supported.
    public static var organizationConformancePackTemplateValidationException: Self { .init(.organizationConformancePackTemplateValidationException) }
    /// The configuration item size is outside the allowable range.
    public static var oversizedConfigurationItemException: Self { .init(.oversizedConfigurationItemException) }
    /// Remediation action is in progress. You can either cancel execution in Amazon Web Services Systems Manager or wait and try again later.
    public static var remediationInProgressException: Self { .init(.remediationInProgressException) }
    /// Two users are trying to modify the same query at the same time. Wait for a moment and try again.
    public static var resourceConcurrentModificationException: Self { .init(.resourceConcurrentModificationException) }
    /// You see this exception in the following cases:    For DeleteConfigRule, Config is deleting this rule. Try your request again later.   For DeleteConfigRule, the rule is deleting your evaluation results. Try your request again later.   For DeleteConfigRule, a remediation action is associated with the rule and Config cannot delete this rule. Delete the remediation action associated with the rule before deleting the rule and try your request again later.   For PutConfigOrganizationRule, organization Config rule deletion is in progress. Try your request again later.   For DeleteOrganizationConfigRule, organization Config rule creation is in progress. Try your request again later.   For PutConformancePack and PutOrganizationConformancePack, a conformance pack creation, update, and deletion is in progress. Try your request again later.   For DeleteConformancePack, a conformance pack creation, update, and deletion is in progress. Try your request again later.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// You have specified a resource that is either unknown or has not
    /// 			been discovered.
    public static var resourceNotDiscoveredException: Self { .init(.resourceNotDiscoveredException) }
    /// You have specified a resource that does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have reached the limit of the number of tags you can use.
    /// 			For more information, see  Service Limits in the Config Developer Guide.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The requested operation is not valid. For PutConfigurationRecorder,
    /// 			you will see this exception because you cannot use this operation to create a service-linked configuration recorder. Use the PutServiceLinkedConfigurationRecorder operation to create a service-linked configuration
    /// 			recorder. For DeleteConfigurationRecorder, you will see this exception because you cannot use this operation to delete a service-linked configuration recorder. Use the DeleteServiceLinkedConfigurationRecorder operation to delete a service-linked configuration
    /// 			recorder. For StartConfigurationRecorder and StopConfigurationRecorder, you will see this exception because these operations do not affect service-linked configuration recorders.
    /// 			Service-linked configuration recorders are always recording. To stop recording, you must delete the service-linked configuration recorder. Use the DeleteServiceLinkedConfigurationRecorder operation to delete a service-linked configuration
    /// 			recorder.
    public static var unmodifiableEntityException: Self { .init(.unmodifiableEntityException) }
    /// The requested operation is not valid. You will see this exception if there are missing required fields or if the input value fails the validation. For PutStoredQuery, one of the following errors:   There are missing required fields.   The input value fails the validation.   You are trying to create more than 300 queries.   For DescribeConfigurationRecorders and DescribeConfigurationRecorderStatus, one of the following errors:   You have specified more than one configuration recorder.   You have provided a service principal for service-linked configuration recorder that is not valid.   For AssociateResourceTypes and DisassociateResourceTypes, one of the following errors:   Your configuraiton recorder has a recording strategy that does not allow the association or disassociation of resource types.   One or more of the specified resource types are already associated or disassociated with the configuration recorder.   For service-linked configuration recorders, the configuration recorder does not record one or more of the specified resource types.
    public static var validationException: Self { .init(.validationException) }
}

extension ConfigServiceErrorType: Equatable {
    public static func == (lhs: ConfigServiceErrorType, rhs: ConfigServiceErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ConfigServiceErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
