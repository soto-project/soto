//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension ConfigService {
    // MARK: Enums

    public enum AggregateConformancePackComplianceSummaryGroupKey: String, CustomStringConvertible, Codable {
        case accountId = "ACCOUNT_ID"
        case awsRegion = "AWS_REGION"
        public var description: String { return self.rawValue }
    }

    public enum AggregatedSourceStatusType: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case outdated = "OUTDATED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum AggregatedSourceType: String, CustomStringConvertible, Codable {
        case account = "ACCOUNT"
        case organization = "ORGANIZATION"
        public var description: String { return self.rawValue }
    }

    public enum ChronologicalOrder: String, CustomStringConvertible, Codable {
        case forward = "Forward"
        case reverse = "Reverse"
        public var description: String { return self.rawValue }
    }

    public enum ComplianceType: String, CustomStringConvertible, Codable {
        case compliant = "COMPLIANT"
        case insufficientData = "INSUFFICIENT_DATA"
        case nonCompliant = "NON_COMPLIANT"
        case notApplicable = "NOT_APPLICABLE"
        public var description: String { return self.rawValue }
    }

    public enum ConfigRuleComplianceSummaryGroupKey: String, CustomStringConvertible, Codable {
        case accountId = "ACCOUNT_ID"
        case awsRegion = "AWS_REGION"
        public var description: String { return self.rawValue }
    }

    public enum ConfigRuleState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        case deletingResults = "DELETING_RESULTS"
        case evaluating = "EVALUATING"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationItemStatus: String, CustomStringConvertible, Codable {
        case ok = "OK"
        case resourcedeleted = "ResourceDeleted"
        case resourcedeletednotrecorded = "ResourceDeletedNotRecorded"
        case resourcediscovered = "ResourceDiscovered"
        case resourcenotrecorded = "ResourceNotRecorded"
        public var description: String { return self.rawValue }
    }

    public enum ConformancePackComplianceType: String, CustomStringConvertible, Codable {
        case compliant = "COMPLIANT"
        case insufficientData = "INSUFFICIENT_DATA"
        case nonCompliant = "NON_COMPLIANT"
        public var description: String { return self.rawValue }
    }

    public enum ConformancePackState: String, CustomStringConvertible, Codable {
        case createComplete = "CREATE_COMPLETE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum DeliveryStatus: String, CustomStringConvertible, Codable {
        case failure = "Failure"
        case notApplicable = "Not_Applicable"
        case success = "Success"
        public var description: String { return self.rawValue }
    }

    public enum EventSource: String, CustomStringConvertible, Codable {
        case awsConfig = "aws.config"
        public var description: String { return self.rawValue }
    }

    public enum MaximumExecutionFrequency: String, CustomStringConvertible, Codable {
        case oneHour = "One_Hour"
        case sixHours = "Six_Hours"
        case threeHours = "Three_Hours"
        case twelveHours = "Twelve_Hours"
        case twentyfourHours = "TwentyFour_Hours"
        public var description: String { return self.rawValue }
    }

    public enum MemberAccountRuleStatus: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createSuccessful = "CREATE_SUCCESSFUL"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleteSuccessful = "DELETE_SUCCESSFUL"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum MessageType: String, CustomStringConvertible, Codable {
        case configurationitemchangenotification = "ConfigurationItemChangeNotification"
        case configurationsnapshotdeliverycompleted = "ConfigurationSnapshotDeliveryCompleted"
        case oversizedconfigurationitemchangenotification = "OversizedConfigurationItemChangeNotification"
        case schedulednotification = "ScheduledNotification"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationConfigRuleTriggerType: String, CustomStringConvertible, Codable {
        case configurationitemchangenotification = "ConfigurationItemChangeNotification"
        case oversizedconfigurationitemchangenotification = "OversizedConfigurationItemChangeNotification"
        case schedulednotification = "ScheduledNotification"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationResourceDetailedStatus: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createSuccessful = "CREATE_SUCCESSFUL"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleteSuccessful = "DELETE_SUCCESSFUL"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationResourceStatus: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createSuccessful = "CREATE_SUCCESSFUL"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleteSuccessful = "DELETE_SUCCESSFUL"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationRuleStatus: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createSuccessful = "CREATE_SUCCESSFUL"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleteSuccessful = "DELETE_SUCCESSFUL"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum Owner: String, CustomStringConvertible, Codable {
        case aws = "AWS"
        case customLambda = "CUSTOM_LAMBDA"
        public var description: String { return self.rawValue }
    }

    public enum RecorderStatus: String, CustomStringConvertible, Codable {
        case failure = "Failure"
        case pending = "Pending"
        case success = "Success"
        public var description: String { return self.rawValue }
    }

    public enum RemediationExecutionState: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case queued = "QUEUED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum RemediationExecutionStepState: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case pending = "PENDING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum RemediationTargetType: String, CustomStringConvertible, Codable {
        case ssmDocument = "SSM_DOCUMENT"
        public var description: String { return self.rawValue }
    }

    public enum ResourceCountGroupKey: String, CustomStringConvertible, Codable {
        case accountId = "ACCOUNT_ID"
        case awsRegion = "AWS_REGION"
        case resourceType = "RESOURCE_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable {
        case awsAcmCertificate = "AWS::ACM::Certificate"
        case awsApigatewayRestapi = "AWS::ApiGateway::RestApi"
        case awsApigatewayStage = "AWS::ApiGateway::Stage"
        case awsApigatewayv2Api = "AWS::ApiGatewayV2::Api"
        case awsApigatewayv2Stage = "AWS::ApiGatewayV2::Stage"
        case awsAutoscalingAutoscalinggroup = "AWS::AutoScaling::AutoScalingGroup"
        case awsAutoscalingLaunchconfiguration = "AWS::AutoScaling::LaunchConfiguration"
        case awsAutoscalingScalingpolicy = "AWS::AutoScaling::ScalingPolicy"
        case awsAutoscalingScheduledaction = "AWS::AutoScaling::ScheduledAction"
        case awsCloudformationStack = "AWS::CloudFormation::Stack"
        case awsCloudfrontDistribution = "AWS::CloudFront::Distribution"
        case awsCloudfrontStreamingdistribution = "AWS::CloudFront::StreamingDistribution"
        case awsCloudtrailTrail = "AWS::CloudTrail::Trail"
        case awsCloudwatchAlarm = "AWS::CloudWatch::Alarm"
        case awsCodebuildProject = "AWS::CodeBuild::Project"
        case awsCodepipelinePipeline = "AWS::CodePipeline::Pipeline"
        case awsConfigConformancepackcompliance = "AWS::Config::ConformancePackCompliance"
        case awsConfigResourcecompliance = "AWS::Config::ResourceCompliance"
        case awsDynamodbTable = "AWS::DynamoDB::Table"
        case awsEc2Customergateway = "AWS::EC2::CustomerGateway"
        case awsEc2Egressonlyinternetgateway = "AWS::EC2::EgressOnlyInternetGateway"
        case awsEc2Eip = "AWS::EC2::EIP"
        case awsEc2Flowlog = "AWS::EC2::FlowLog"
        case awsEc2Host = "AWS::EC2::Host"
        case awsEc2Instance = "AWS::EC2::Instance"
        case awsEc2Internetgateway = "AWS::EC2::InternetGateway"
        case awsEc2Natgateway = "AWS::EC2::NatGateway"
        case awsEc2Networkacl = "AWS::EC2::NetworkAcl"
        case awsEc2Networkinterface = "AWS::EC2::NetworkInterface"
        case awsEc2Registeredhainstance = "AWS::EC2::RegisteredHAInstance"
        case awsEc2Routetable = "AWS::EC2::RouteTable"
        case awsEc2Securitygroup = "AWS::EC2::SecurityGroup"
        case awsEc2Subnet = "AWS::EC2::Subnet"
        case awsEc2Volume = "AWS::EC2::Volume"
        case awsEc2Vpc = "AWS::EC2::VPC"
        case awsEc2Vpcendpoint = "AWS::EC2::VPCEndpoint"
        case awsEc2Vpcendpointservice = "AWS::EC2::VPCEndpointService"
        case awsEc2Vpcpeeringconnection = "AWS::EC2::VPCPeeringConnection"
        case awsEc2Vpnconnection = "AWS::EC2::VPNConnection"
        case awsEc2Vpngateway = "AWS::EC2::VPNGateway"
        case awsElasticbeanstalkApplication = "AWS::ElasticBeanstalk::Application"
        case awsElasticbeanstalkApplicationversion = "AWS::ElasticBeanstalk::ApplicationVersion"
        case awsElasticbeanstalkEnvironment = "AWS::ElasticBeanstalk::Environment"
        case awsElasticloadbalancingLoadbalancer = "AWS::ElasticLoadBalancing::LoadBalancer"
        case awsElasticloadbalancingv2Loadbalancer = "AWS::ElasticLoadBalancingV2::LoadBalancer"
        case awsElasticsearchDomain = "AWS::Elasticsearch::Domain"
        case awsIamGroup = "AWS::IAM::Group"
        case awsIamPolicy = "AWS::IAM::Policy"
        case awsIamRole = "AWS::IAM::Role"
        case awsIamUser = "AWS::IAM::User"
        case awsKmsKey = "AWS::KMS::Key"
        case awsLambdaFunction = "AWS::Lambda::Function"
        case awsNetworkfirewallFirewall = "AWS::NetworkFirewall::Firewall"
        case awsNetworkfirewallFirewallpolicy = "AWS::NetworkFirewall::FirewallPolicy"
        case awsNetworkfirewallRulegroup = "AWS::NetworkFirewall::RuleGroup"
        case awsQldbLedger = "AWS::QLDB::Ledger"
        case awsRdsDbcluster = "AWS::RDS::DBCluster"
        case awsRdsDbclustersnapshot = "AWS::RDS::DBClusterSnapshot"
        case awsRdsDbinstance = "AWS::RDS::DBInstance"
        case awsRdsDbsecuritygroup = "AWS::RDS::DBSecurityGroup"
        case awsRdsDbsnapshot = "AWS::RDS::DBSnapshot"
        case awsRdsDbsubnetgroup = "AWS::RDS::DBSubnetGroup"
        case awsRdsEventsubscription = "AWS::RDS::EventSubscription"
        case awsRedshiftCluster = "AWS::Redshift::Cluster"
        case awsRedshiftClusterparametergroup = "AWS::Redshift::ClusterParameterGroup"
        case awsRedshiftClustersecuritygroup = "AWS::Redshift::ClusterSecurityGroup"
        case awsRedshiftClustersnapshot = "AWS::Redshift::ClusterSnapshot"
        case awsRedshiftClustersubnetgroup = "AWS::Redshift::ClusterSubnetGroup"
        case awsRedshiftEventsubscription = "AWS::Redshift::EventSubscription"
        case awsS3Accountpublicaccessblock = "AWS::S3::AccountPublicAccessBlock"
        case awsS3Bucket = "AWS::S3::Bucket"
        case awsSecretsmanagerSecret = "AWS::SecretsManager::Secret"
        case awsServicecatalogCloudformationproduct = "AWS::ServiceCatalog::CloudFormationProduct"
        case awsServicecatalogCloudformationprovisionedproduct = "AWS::ServiceCatalog::CloudFormationProvisionedProduct"
        case awsServicecatalogPortfolio = "AWS::ServiceCatalog::Portfolio"
        case awsShieldProtection = "AWS::Shield::Protection"
        case awsShieldregionalProtection = "AWS::ShieldRegional::Protection"
        case awsSnsTopic = "AWS::SNS::Topic"
        case awsSqsQueue = "AWS::SQS::Queue"
        case awsSsmAssociationcompliance = "AWS::SSM::AssociationCompliance"
        case awsSsmFiledata = "AWS::SSM::FileData"
        case awsSsmManagedinstanceinventory = "AWS::SSM::ManagedInstanceInventory"
        case awsSsmPatchcompliance = "AWS::SSM::PatchCompliance"
        case awsWafRatebasedrule = "AWS::WAF::RateBasedRule"
        case awsWafRule = "AWS::WAF::Rule"
        case awsWafRulegroup = "AWS::WAF::RuleGroup"
        case awsWafWebacl = "AWS::WAF::WebACL"
        case awsWafregionalRatebasedrule = "AWS::WAFRegional::RateBasedRule"
        case awsWafregionalRule = "AWS::WAFRegional::Rule"
        case awsWafregionalRulegroup = "AWS::WAFRegional::RuleGroup"
        case awsWafregionalWebacl = "AWS::WAFRegional::WebACL"
        case awsWafv2Ipset = "AWS::WAFv2::IPSet"
        case awsWafv2Managedruleset = "AWS::WAFv2::ManagedRuleSet"
        case awsWafv2Regexpatternset = "AWS::WAFv2::RegexPatternSet"
        case awsWafv2Rulegroup = "AWS::WAFv2::RuleGroup"
        case awsWafv2Webacl = "AWS::WAFv2::WebACL"
        case awsXrayEncryptionconfig = "AWS::XRay::EncryptionConfig"
        public var description: String { return self.rawValue }
    }

    public enum ResourceValueType: String, CustomStringConvertible, Codable {
        case resourceId = "RESOURCE_ID"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountAggregationSource: AWSEncodableShape & AWSDecodableShape {
        /// The 12-digit account ID of the account being aggregated.
        public let accountIds: [String]
        /// If true, aggregate existing AWS Config regions and future regions.
        public let allAwsRegions: Bool?
        /// The source regions being aggregated.
        public let awsRegions: [String]?

        public init(accountIds: [String], allAwsRegions: Bool? = nil, awsRegions: [String]? = nil) {
            self.accountIds = accountIds
            self.allAwsRegions = allAwsRegions
            self.awsRegions = awsRegions
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\d{12}")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.awsRegions, name: "awsRegions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case allAwsRegions = "AllAwsRegions"
            case awsRegions = "AwsRegions"
        }
    }

    public struct AggregateComplianceByConfigRule: AWSDecodableShape {
        /// The 12-digit account ID of the source account.
        public let accountId: String?
        /// The source region from where the data is aggregated.
        public let awsRegion: String?
        /// Indicates whether an AWS resource or AWS Config rule is compliant and provides the number of contributors that affect the compliance.
        public let compliance: Compliance?
        /// The name of the AWS Config rule.
        public let configRuleName: String?

        public init(accountId: String? = nil, awsRegion: String? = nil, compliance: Compliance? = nil, configRuleName: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.compliance = compliance
            self.configRuleName = configRuleName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case compliance = "Compliance"
            case configRuleName = "ConfigRuleName"
        }
    }

    public struct AggregateComplianceByConformancePack: AWSDecodableShape {
        /// The 12-digit AWS account ID of the source account.
        public let accountId: String?
        /// The source AWS Region from where the data is aggregated.
        public let awsRegion: String?
        /// The compliance status of the conformance pack.
        public let compliance: AggregateConformancePackCompliance?
        /// The name of the conformance pack.
        public let conformancePackName: String?

        public init(accountId: String? = nil, awsRegion: String? = nil, compliance: AggregateConformancePackCompliance? = nil, conformancePackName: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.compliance = compliance
            self.conformancePackName = conformancePackName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case compliance = "Compliance"
            case conformancePackName = "ConformancePackName"
        }
    }

    public struct AggregateComplianceCount: AWSDecodableShape {
        /// The number of compliant and noncompliant AWS Config rules.
        public let complianceSummary: ComplianceSummary?
        /// The 12-digit account ID or region based on the GroupByKey value.
        public let groupName: String?

        public init(complianceSummary: ComplianceSummary? = nil, groupName: String? = nil) {
            self.complianceSummary = complianceSummary
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummary = "ComplianceSummary"
            case groupName = "GroupName"
        }
    }

    public struct AggregateConformancePackCompliance: AWSDecodableShape {
        /// The compliance status of the conformance pack.
        public let complianceType: ConformancePackComplianceType?
        /// The number of compliant AWS Config Rules.
        public let compliantRuleCount: Int?
        /// The number of noncompliant AWS Config Rules.
        public let nonCompliantRuleCount: Int?
        /// Total number of compliant rules, noncompliant rules, and the rules that do not have any applicable resources to evaluate upon resulting in insufficient data.
        public let totalRuleCount: Int?

        public init(complianceType: ConformancePackComplianceType? = nil, compliantRuleCount: Int? = nil, nonCompliantRuleCount: Int? = nil, totalRuleCount: Int? = nil) {
            self.complianceType = complianceType
            self.compliantRuleCount = compliantRuleCount
            self.nonCompliantRuleCount = nonCompliantRuleCount
            self.totalRuleCount = totalRuleCount
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "ComplianceType"
            case compliantRuleCount = "CompliantRuleCount"
            case nonCompliantRuleCount = "NonCompliantRuleCount"
            case totalRuleCount = "TotalRuleCount"
        }
    }

    public struct AggregateConformancePackComplianceCount: AWSDecodableShape {
        /// Number of compliant conformance packs.
        public let compliantConformancePackCount: Int?
        /// Number of noncompliant conformance packs.
        public let nonCompliantConformancePackCount: Int?

        public init(compliantConformancePackCount: Int? = nil, nonCompliantConformancePackCount: Int? = nil) {
            self.compliantConformancePackCount = compliantConformancePackCount
            self.nonCompliantConformancePackCount = nonCompliantConformancePackCount
        }

        private enum CodingKeys: String, CodingKey {
            case compliantConformancePackCount = "CompliantConformancePackCount"
            case nonCompliantConformancePackCount = "NonCompliantConformancePackCount"
        }
    }

    public struct AggregateConformancePackComplianceFilters: AWSEncodableShape {
        /// The 12-digit AWS account ID of the source account.
        public let accountId: String?
        /// The source AWS Region from where the data is aggregated.
        public let awsRegion: String?
        /// The compliance status of the conformance pack.
        public let complianceType: ConformancePackComplianceType?
        /// The name of the conformance pack.
        public let conformancePackName: String?

        public init(accountId: String? = nil, awsRegion: String? = nil, complianceType: ConformancePackComplianceType? = nil, conformancePackName: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.conformancePackName = conformancePackName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\d{12}")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 64)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, max: 256)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case complianceType = "ComplianceType"
            case conformancePackName = "ConformancePackName"
        }
    }

    public struct AggregateConformancePackComplianceSummary: AWSDecodableShape {
        /// Returns an AggregateConformancePackComplianceCount object.
        public let complianceSummary: AggregateConformancePackComplianceCount?
        /// Groups the result based on AWS Account ID or AWS Region.
        public let groupName: String?

        public init(complianceSummary: AggregateConformancePackComplianceCount? = nil, groupName: String? = nil) {
            self.complianceSummary = complianceSummary
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummary = "ComplianceSummary"
            case groupName = "GroupName"
        }
    }

    public struct AggregateConformancePackComplianceSummaryFilters: AWSEncodableShape {
        /// The 12-digit AWS account ID of the source account.
        public let accountId: String?
        /// The source AWS Region from where the data is aggregated.
        public let awsRegion: String?

        public init(accountId: String? = nil, awsRegion: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\d{12}")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 64)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
        }
    }

    public struct AggregateEvaluationResult: AWSDecodableShape {
        /// The 12-digit account ID of the source account.
        public let accountId: String?
        /// Supplementary information about how the agrregate evaluation determined the compliance.
        public let annotation: String?
        /// The source region from where the data is aggregated.
        public let awsRegion: String?
        /// The resource compliance status. For the AggregationEvaluationResult data type, AWS Config supports only the COMPLIANT and NON_COMPLIANT. AWS Config does not support the NOT_APPLICABLE and INSUFFICIENT_DATA value.
        public let complianceType: ComplianceType?
        /// The time when the AWS Config rule evaluated the AWS resource.
        public let configRuleInvokedTime: Date?
        /// Uniquely identifies the evaluation result.
        public let evaluationResultIdentifier: EvaluationResultIdentifier?
        /// The time when AWS Config recorded the aggregate evaluation result.
        public let resultRecordedTime: Date?

        public init(accountId: String? = nil, annotation: String? = nil, awsRegion: String? = nil, complianceType: ComplianceType? = nil, configRuleInvokedTime: Date? = nil, evaluationResultIdentifier: EvaluationResultIdentifier? = nil, resultRecordedTime: Date? = nil) {
            self.accountId = accountId
            self.annotation = annotation
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case annotation = "Annotation"
            case awsRegion = "AwsRegion"
            case complianceType = "ComplianceType"
            case configRuleInvokedTime = "ConfigRuleInvokedTime"
            case evaluationResultIdentifier = "EvaluationResultIdentifier"
            case resultRecordedTime = "ResultRecordedTime"
        }
    }

    public struct AggregateResourceIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the AWS resource.
        public let resourceId: String
        /// The name of the AWS resource.
        public let resourceName: String?
        /// The type of the AWS resource.
        public let resourceType: ResourceType
        /// The 12-digit account ID of the source account.
        public let sourceAccountId: String
        /// The source region where data is aggregated.
        public let sourceRegion: String

        public init(resourceId: String, resourceName: String? = nil, resourceType: ResourceType, sourceAccountId: String, sourceRegion: String) {
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceAccountId = sourceAccountId
            self.sourceRegion = sourceRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.sourceAccountId, name: "sourceAccountId", parent: name, pattern: "\\d{12}")
            try self.validate(self.sourceRegion, name: "sourceRegion", parent: name, max: 64)
            try self.validate(self.sourceRegion, name: "sourceRegion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
            case resourceName = "ResourceName"
            case resourceType = "ResourceType"
            case sourceAccountId = "SourceAccountId"
            case sourceRegion = "SourceRegion"
        }
    }

    public struct AggregatedSourceStatus: AWSDecodableShape {
        /// The region authorized to collect aggregated data.
        public let awsRegion: String?
        /// The error code that AWS Config returned when the source account aggregation last failed.
        public let lastErrorCode: String?
        /// The message indicating that the source account aggregation failed due to an error.
        public let lastErrorMessage: String?
        /// Filters the last updated status type.   Valid value FAILED indicates errors while moving data.   Valid value SUCCEEDED indicates the data was successfully moved.   Valid value OUTDATED indicates the data is not the most recent.
        public let lastUpdateStatus: AggregatedSourceStatusType?
        /// The time of the last update.
        public let lastUpdateTime: Date?
        /// The source account ID or an organization.
        public let sourceId: String?
        /// The source account or an organization.
        public let sourceType: AggregatedSourceType?

        public init(awsRegion: String? = nil, lastErrorCode: String? = nil, lastErrorMessage: String? = nil, lastUpdateStatus: AggregatedSourceStatusType? = nil, lastUpdateTime: Date? = nil, sourceId: String? = nil, sourceType: AggregatedSourceType? = nil) {
            self.awsRegion = awsRegion
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastUpdateStatus = lastUpdateStatus
            self.lastUpdateTime = lastUpdateTime
            self.sourceId = sourceId
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case awsRegion = "AwsRegion"
            case lastErrorCode = "LastErrorCode"
            case lastErrorMessage = "LastErrorMessage"
            case lastUpdateStatus = "LastUpdateStatus"
            case lastUpdateTime = "LastUpdateTime"
            case sourceId = "SourceId"
            case sourceType = "SourceType"
        }
    }

    public struct AggregationAuthorization: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the aggregation object.
        public let aggregationAuthorizationArn: String?
        /// The 12-digit account ID of the account authorized to aggregate data.
        public let authorizedAccountId: String?
        /// The region authorized to collect aggregated data.
        public let authorizedAwsRegion: String?
        /// The time stamp when the aggregation authorization was created.
        public let creationTime: Date?

        public init(aggregationAuthorizationArn: String? = nil, authorizedAccountId: String? = nil, authorizedAwsRegion: String? = nil, creationTime: Date? = nil) {
            self.aggregationAuthorizationArn = aggregationAuthorizationArn
            self.authorizedAccountId = authorizedAccountId
            self.authorizedAwsRegion = authorizedAwsRegion
            self.creationTime = creationTime
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationAuthorizationArn = "AggregationAuthorizationArn"
            case authorizedAccountId = "AuthorizedAccountId"
            case authorizedAwsRegion = "AuthorizedAwsRegion"
            case creationTime = "CreationTime"
        }
    }

    public struct BaseConfigurationItem: AWSDecodableShape {
        /// The 12-digit AWS account ID associated with the resource.
        public let accountId: String?
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The Availability Zone associated with the resource.
        public let availabilityZone: String?
        /// The region where the resource resides.
        public let awsRegion: String?
        /// The description of the resource configuration.
        public let configuration: String?
        /// The time when the configuration recording was initiated.
        public let configurationItemCaptureTime: Date?
        /// The configuration item status. The valid values are:   OK – The resource configuration has been updated   ResourceDiscovered – The resource was newly discovered   ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type   ResourceDeleted – The resource was deleted   ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type    The CIs do not incur any cost.
        public let configurationItemStatus: ConfigurationItemStatus?
        /// An identifier that indicates the ordering of the configuration items of a resource.
        public let configurationStateId: String?
        /// The time stamp when the resource was created.
        public let resourceCreationTime: Date?
        /// The ID of the resource (for example., sg-xxxxxx).
        public let resourceId: String?
        /// The custom name of the resource, if available.
        public let resourceName: String?
        /// The type of AWS resource.
        public let resourceType: ResourceType?
        /// Configuration attributes that AWS Config returns for certain resource types to supplement the information returned for the configuration parameter.
        public let supplementaryConfiguration: [String: String]?
        /// The version number of the resource configuration.
        public let version: String?

        public init(accountId: String? = nil, arn: String? = nil, availabilityZone: String? = nil, awsRegion: String? = nil, configuration: String? = nil, configurationItemCaptureTime: Date? = nil, configurationItemStatus: ConfigurationItemStatus? = nil, configurationStateId: String? = nil, resourceCreationTime: Date? = nil, resourceId: String? = nil, resourceName: String? = nil, resourceType: ResourceType? = nil, supplementaryConfiguration: [String: String]? = nil, version: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.awsRegion = awsRegion
            self.configuration = configuration
            self.configurationItemCaptureTime = configurationItemCaptureTime
            self.configurationItemStatus = configurationItemStatus
            self.configurationStateId = configurationStateId
            self.resourceCreationTime = resourceCreationTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.supplementaryConfiguration = supplementaryConfiguration
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case arn
            case availabilityZone
            case awsRegion
            case configuration
            case configurationItemCaptureTime
            case configurationItemStatus
            case configurationStateId
            case resourceCreationTime
            case resourceId
            case resourceName
            case resourceType
            case supplementaryConfiguration
            case version
        }
    }

    public struct BatchGetAggregateResourceConfigRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// A list of aggregate ResourceIdentifiers objects.
        public let resourceIdentifiers: [AggregateResourceIdentifier]

        public init(configurationAggregatorName: String, resourceIdentifiers: [AggregateResourceIdentifier]) {
            self.configurationAggregatorName = configurationAggregatorName
            self.resourceIdentifiers = resourceIdentifiers
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.resourceIdentifiers.forEach {
                try $0.validate(name: "\(name).resourceIdentifiers[]")
            }
            try self.validate(self.resourceIdentifiers, name: "resourceIdentifiers", parent: name, max: 100)
            try self.validate(self.resourceIdentifiers, name: "resourceIdentifiers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case resourceIdentifiers = "ResourceIdentifiers"
        }
    }

    public struct BatchGetAggregateResourceConfigResponse: AWSDecodableShape {
        /// A list that contains the current configuration of one or more resources.
        public let baseConfigurationItems: [BaseConfigurationItem]?
        /// A list of resource identifiers that were not processed with current scope. The list is empty if all the resources are processed.
        public let unprocessedResourceIdentifiers: [AggregateResourceIdentifier]?

        public init(baseConfigurationItems: [BaseConfigurationItem]? = nil, unprocessedResourceIdentifiers: [AggregateResourceIdentifier]? = nil) {
            self.baseConfigurationItems = baseConfigurationItems
            self.unprocessedResourceIdentifiers = unprocessedResourceIdentifiers
        }

        private enum CodingKeys: String, CodingKey {
            case baseConfigurationItems = "BaseConfigurationItems"
            case unprocessedResourceIdentifiers = "UnprocessedResourceIdentifiers"
        }
    }

    public struct BatchGetResourceConfigRequest: AWSEncodableShape {
        /// A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID.
        public let resourceKeys: [ResourceKey]

        public init(resourceKeys: [ResourceKey]) {
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.resourceKeys.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceKeys
        }
    }

    public struct BatchGetResourceConfigResponse: AWSDecodableShape {
        /// A list that contains the current configuration of one or more resources.
        public let baseConfigurationItems: [BaseConfigurationItem]?
        /// A list of resource keys that were not processed with the current response. The unprocessesResourceKeys value is in the same form as ResourceKeys, so the value can be directly provided to a subsequent BatchGetResourceConfig operation. If there are no unprocessed resource keys, the response contains an empty unprocessedResourceKeys list.
        public let unprocessedResourceKeys: [ResourceKey]?

        public init(baseConfigurationItems: [BaseConfigurationItem]? = nil, unprocessedResourceKeys: [ResourceKey]? = nil) {
            self.baseConfigurationItems = baseConfigurationItems
            self.unprocessedResourceKeys = unprocessedResourceKeys
        }

        private enum CodingKeys: String, CodingKey {
            case baseConfigurationItems
            case unprocessedResourceKeys
        }
    }

    public struct Compliance: AWSDecodableShape {
        /// The number of AWS resources or AWS Config rules that cause a result of NON_COMPLIANT, up to a maximum number.
        public let complianceContributorCount: ComplianceContributorCount?
        /// Indicates whether an AWS resource or AWS Config rule is compliant. A resource is compliant if it complies with all of the AWS Config rules that evaluate it. A resource is noncompliant if it does not comply with one or more of these rules. A rule is compliant if all of the resources that the rule evaluates comply with it. A rule is noncompliant if any of these resources do not comply. AWS Config returns the INSUFFICIENT_DATA value when no evaluation results are available for the AWS resource or AWS Config rule. For the Compliance data type, AWS Config supports only COMPLIANT, NON_COMPLIANT, and INSUFFICIENT_DATA values. AWS Config does not support the NOT_APPLICABLE value for the Compliance data type.
        public let complianceType: ComplianceType?

        public init(complianceContributorCount: ComplianceContributorCount? = nil, complianceType: ComplianceType? = nil) {
            self.complianceContributorCount = complianceContributorCount
            self.complianceType = complianceType
        }

        private enum CodingKeys: String, CodingKey {
            case complianceContributorCount = "ComplianceContributorCount"
            case complianceType = "ComplianceType"
        }
    }

    public struct ComplianceByConfigRule: AWSDecodableShape {
        /// Indicates whether the AWS Config rule is compliant.
        public let compliance: Compliance?
        /// The name of the AWS Config rule.
        public let configRuleName: String?

        public init(compliance: Compliance? = nil, configRuleName: String? = nil) {
            self.compliance = compliance
            self.configRuleName = configRuleName
        }

        private enum CodingKeys: String, CodingKey {
            case compliance = "Compliance"
            case configRuleName = "ConfigRuleName"
        }
    }

    public struct ComplianceByResource: AWSDecodableShape {
        /// Indicates whether the AWS resource complies with all of the AWS Config rules that evaluated it.
        public let compliance: Compliance?
        /// The ID of the AWS resource that was evaluated.
        public let resourceId: String?
        /// The type of the AWS resource that was evaluated.
        public let resourceType: String?

        public init(compliance: Compliance? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.compliance = compliance
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case compliance = "Compliance"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ComplianceContributorCount: AWSDecodableShape {
        /// Indicates whether the maximum count is reached.
        public let capExceeded: Bool?
        /// The number of AWS resources or AWS Config rules responsible for the current compliance of the item.
        public let cappedCount: Int?

        public init(capExceeded: Bool? = nil, cappedCount: Int? = nil) {
            self.capExceeded = capExceeded
            self.cappedCount = cappedCount
        }

        private enum CodingKeys: String, CodingKey {
            case capExceeded = "CapExceeded"
            case cappedCount = "CappedCount"
        }
    }

    public struct ComplianceSummary: AWSDecodableShape {
        /// The time that AWS Config created the compliance summary.
        public let complianceSummaryTimestamp: Date?
        /// The number of AWS Config rules or AWS resources that are compliant, up to a maximum of 25 for rules and 100 for resources.
        public let compliantResourceCount: ComplianceContributorCount?
        /// The number of AWS Config rules or AWS resources that are noncompliant, up to a maximum of 25 for rules and 100 for resources.
        public let nonCompliantResourceCount: ComplianceContributorCount?

        public init(complianceSummaryTimestamp: Date? = nil, compliantResourceCount: ComplianceContributorCount? = nil, nonCompliantResourceCount: ComplianceContributorCount? = nil) {
            self.complianceSummaryTimestamp = complianceSummaryTimestamp
            self.compliantResourceCount = compliantResourceCount
            self.nonCompliantResourceCount = nonCompliantResourceCount
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummaryTimestamp = "ComplianceSummaryTimestamp"
            case compliantResourceCount = "CompliantResourceCount"
            case nonCompliantResourceCount = "NonCompliantResourceCount"
        }
    }

    public struct ComplianceSummaryByResourceType: AWSDecodableShape {
        /// The number of AWS resources that are compliant or noncompliant, up to a maximum of 100 for each.
        public let complianceSummary: ComplianceSummary?
        /// The type of AWS resource.
        public let resourceType: String?

        public init(complianceSummary: ComplianceSummary? = nil, resourceType: String? = nil) {
            self.complianceSummary = complianceSummary
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummary = "ComplianceSummary"
            case resourceType = "ResourceType"
        }
    }

    public struct ConfigExportDeliveryInfo: AWSDecodableShape {
        /// The time of the last attempted delivery.
        public let lastAttemptTime: Date?
        /// The error code from the last attempted delivery.
        public let lastErrorCode: String?
        /// The error message from the last attempted delivery.
        public let lastErrorMessage: String?
        /// Status of the last attempted delivery.
        public let lastStatus: DeliveryStatus?
        /// The time of the last successful delivery.
        public let lastSuccessfulTime: Date?
        /// The time that the next delivery occurs.
        public let nextDeliveryTime: Date?

        public init(lastAttemptTime: Date? = nil, lastErrorCode: String? = nil, lastErrorMessage: String? = nil, lastStatus: DeliveryStatus? = nil, lastSuccessfulTime: Date? = nil, nextDeliveryTime: Date? = nil) {
            self.lastAttemptTime = lastAttemptTime
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStatus = lastStatus
            self.lastSuccessfulTime = lastSuccessfulTime
            self.nextDeliveryTime = nextDeliveryTime
        }

        private enum CodingKeys: String, CodingKey {
            case lastAttemptTime
            case lastErrorCode
            case lastErrorMessage
            case lastStatus
            case lastSuccessfulTime
            case nextDeliveryTime
        }
    }

    public struct ConfigRule: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AWS Config rule.
        public let configRuleArn: String?
        /// The ID of the AWS Config rule.
        public let configRuleId: String?
        /// The name that you assign to the AWS Config rule. The name is required if you are adding a new rule.
        public let configRuleName: String?
        /// Indicates whether the AWS Config rule is active or is currently being deleted by AWS Config. It can also indicate the evaluation status for the AWS Config rule. AWS Config sets the state of the rule to EVALUATING temporarily after you use the StartConfigRulesEvaluation request to evaluate your resources against the AWS Config rule. AWS Config sets the state of the rule to DELETING_RESULTS temporarily after you use the DeleteEvaluationResults request to delete the current evaluation results for the AWS Config rule. AWS Config temporarily sets the state of a rule to DELETING after you use the DeleteConfigRule request to delete the rule. After AWS Config deletes the rule, the rule and all of its evaluations are erased and are no longer available.
        public let configRuleState: ConfigRuleState?
        /// Service principal name of the service that created the rule.  The field is populated only if the service linked rule is created by a service. The field is empty if you create your own rule.
        public let createdBy: String?
        /// The description that you provide for the AWS Config rule.
        public let description: String?
        /// A string, in JSON format, that is passed to the AWS Config rule Lambda function.
        public let inputParameters: String?
        /// The maximum frequency with which AWS Config runs evaluations for a rule. You can specify a value for MaximumExecutionFrequency when:   You are using an AWS managed rule that is triggered at a periodic frequency.   Your custom rule is triggered when AWS Config delivers the configuration snapshot. For more information, see ConfigSnapshotDeliveryProperties.    By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter.
        public let maximumExecutionFrequency: MaximumExecutionFrequency?
        /// Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes.  The scope can be empty.
        public let scope: Scope?
        /// Provides the rule owner (AWS or customer), the rule identifier, and the notifications that cause the function to evaluate your AWS resources.
        public let source: Source

        public init(configRuleArn: String? = nil, configRuleId: String? = nil, configRuleName: String? = nil, configRuleState: ConfigRuleState? = nil, createdBy: String? = nil, description: String? = nil, inputParameters: String? = nil, maximumExecutionFrequency: MaximumExecutionFrequency? = nil, scope: Scope? = nil, source: Source) {
            self.configRuleArn = configRuleArn
            self.configRuleId = configRuleId
            self.configRuleName = configRuleName
            self.configRuleState = configRuleState
            self.createdBy = createdBy
            self.description = description
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.scope = scope
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleArn, name: "configRuleArn", parent: name, max: 256)
            try self.validate(self.configRuleArn, name: "configRuleArn", parent: name, min: 1)
            try self.validate(self.configRuleId, name: "configRuleId", parent: name, max: 64)
            try self.validate(self.configRuleId, name: "configRuleId", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
            try self.validate(self.createdBy, name: "createdBy", parent: name, max: 256)
            try self.validate(self.createdBy, name: "createdBy", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, max: 1024)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, min: 1)
            try self.scope?.validate(name: "\(name).scope")
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleArn = "ConfigRuleArn"
            case configRuleId = "ConfigRuleId"
            case configRuleName = "ConfigRuleName"
            case configRuleState = "ConfigRuleState"
            case createdBy = "CreatedBy"
            case description = "Description"
            case inputParameters = "InputParameters"
            case maximumExecutionFrequency = "MaximumExecutionFrequency"
            case scope = "Scope"
            case source = "Source"
        }
    }

    public struct ConfigRuleComplianceFilters: AWSEncodableShape {
        /// The 12-digit account ID of the source account.
        public let accountId: String?
        /// The source region where the data is aggregated.
        public let awsRegion: String?
        /// The rule compliance status. For the ConfigRuleComplianceFilters data type, AWS Config supports only COMPLIANT and NON_COMPLIANT. AWS Config does not support the NOT_APPLICABLE and the INSUFFICIENT_DATA values.
        public let complianceType: ComplianceType?
        /// The name of the AWS Config rule.
        public let configRuleName: String?

        public init(accountId: String? = nil, awsRegion: String? = nil, complianceType: ComplianceType? = nil, configRuleName: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.configRuleName = configRuleName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\d{12}")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 64)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case complianceType = "ComplianceType"
            case configRuleName = "ConfigRuleName"
        }
    }

    public struct ConfigRuleComplianceSummaryFilters: AWSEncodableShape {
        /// The 12-digit account ID of the source account.
        public let accountId: String?
        /// The source region where the data is aggregated.
        public let awsRegion: String?

        public init(accountId: String? = nil, awsRegion: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\d{12}")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 64)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
        }
    }

    public struct ConfigRuleEvaluationStatus: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AWS Config rule.
        public let configRuleArn: String?
        /// The ID of the AWS Config rule.
        public let configRuleId: String?
        /// The name of the AWS Config rule.
        public let configRuleName: String?
        /// The time that you first activated the AWS Config rule.
        public let firstActivatedTime: Date?
        /// Indicates whether AWS Config has evaluated your resources against the rule at least once.    true - AWS Config has evaluated your AWS resources against the rule at least once.    false - AWS Config has not once finished evaluating your AWS resources against the rule.
        public let firstEvaluationStarted: Bool?
        /// The time that you last turned off the AWS Config rule.
        public let lastDeactivatedTime: Date?
        /// The error code that AWS Config returned when the rule last failed.
        public let lastErrorCode: String?
        /// The error message that AWS Config returned when the rule last failed.
        public let lastErrorMessage: String?
        /// The time that AWS Config last failed to evaluate your AWS resources against the rule.
        public let lastFailedEvaluationTime: Date?
        /// The time that AWS Config last failed to invoke the AWS Config rule to evaluate your AWS resources.
        public let lastFailedInvocationTime: Date?
        /// The time that AWS Config last successfully evaluated your AWS resources against the rule.
        public let lastSuccessfulEvaluationTime: Date?
        /// The time that AWS Config last successfully invoked the AWS Config rule to evaluate your AWS resources.
        public let lastSuccessfulInvocationTime: Date?

        public init(configRuleArn: String? = nil, configRuleId: String? = nil, configRuleName: String? = nil, firstActivatedTime: Date? = nil, firstEvaluationStarted: Bool? = nil, lastDeactivatedTime: Date? = nil, lastErrorCode: String? = nil, lastErrorMessage: String? = nil, lastFailedEvaluationTime: Date? = nil, lastFailedInvocationTime: Date? = nil, lastSuccessfulEvaluationTime: Date? = nil, lastSuccessfulInvocationTime: Date? = nil) {
            self.configRuleArn = configRuleArn
            self.configRuleId = configRuleId
            self.configRuleName = configRuleName
            self.firstActivatedTime = firstActivatedTime
            self.firstEvaluationStarted = firstEvaluationStarted
            self.lastDeactivatedTime = lastDeactivatedTime
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastFailedEvaluationTime = lastFailedEvaluationTime
            self.lastFailedInvocationTime = lastFailedInvocationTime
            self.lastSuccessfulEvaluationTime = lastSuccessfulEvaluationTime
            self.lastSuccessfulInvocationTime = lastSuccessfulInvocationTime
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleArn = "ConfigRuleArn"
            case configRuleId = "ConfigRuleId"
            case configRuleName = "ConfigRuleName"
            case firstActivatedTime = "FirstActivatedTime"
            case firstEvaluationStarted = "FirstEvaluationStarted"
            case lastDeactivatedTime = "LastDeactivatedTime"
            case lastErrorCode = "LastErrorCode"
            case lastErrorMessage = "LastErrorMessage"
            case lastFailedEvaluationTime = "LastFailedEvaluationTime"
            case lastFailedInvocationTime = "LastFailedInvocationTime"
            case lastSuccessfulEvaluationTime = "LastSuccessfulEvaluationTime"
            case lastSuccessfulInvocationTime = "LastSuccessfulInvocationTime"
        }
    }

    public struct ConfigSnapshotDeliveryProperties: AWSEncodableShape & AWSDecodableShape {
        /// The frequency with which AWS Config delivers configuration snapshots.
        public let deliveryFrequency: MaximumExecutionFrequency?

        public init(deliveryFrequency: MaximumExecutionFrequency? = nil) {
            self.deliveryFrequency = deliveryFrequency
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryFrequency
        }
    }

    public struct ConfigStreamDeliveryInfo: AWSDecodableShape {
        /// The error code from the last attempted delivery.
        public let lastErrorCode: String?
        /// The error message from the last attempted delivery.
        public let lastErrorMessage: String?
        /// Status of the last attempted delivery.  Note Providing an SNS topic on a DeliveryChannel for AWS Config is optional. If the SNS delivery is turned off, the last status will be Not_Applicable.
        public let lastStatus: DeliveryStatus?
        /// The time from the last status change.
        public let lastStatusChangeTime: Date?

        public init(lastErrorCode: String? = nil, lastErrorMessage: String? = nil, lastStatus: DeliveryStatus? = nil, lastStatusChangeTime: Date? = nil) {
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStatus = lastStatus
            self.lastStatusChangeTime = lastStatusChangeTime
        }

        private enum CodingKeys: String, CodingKey {
            case lastErrorCode
            case lastErrorMessage
            case lastStatus
            case lastStatusChangeTime
        }
    }

    public struct ConfigurationAggregator: AWSDecodableShape {
        /// Provides a list of source accounts and regions to be aggregated.
        public let accountAggregationSources: [AccountAggregationSource]?
        /// The Amazon Resource Name (ARN) of the aggregator.
        public let configurationAggregatorArn: String?
        /// The name of the aggregator.
        public let configurationAggregatorName: String?
        /// AWS service that created the configuration aggregator.
        public let createdBy: String?
        /// The time stamp when the configuration aggregator was created.
        public let creationTime: Date?
        /// The time of the last update.
        public let lastUpdatedTime: Date?
        /// Provides an organization and list of regions to be aggregated.
        public let organizationAggregationSource: OrganizationAggregationSource?

        public init(accountAggregationSources: [AccountAggregationSource]? = nil, configurationAggregatorArn: String? = nil, configurationAggregatorName: String? = nil, createdBy: String? = nil, creationTime: Date? = nil, lastUpdatedTime: Date? = nil, organizationAggregationSource: OrganizationAggregationSource? = nil) {
            self.accountAggregationSources = accountAggregationSources
            self.configurationAggregatorArn = configurationAggregatorArn
            self.configurationAggregatorName = configurationAggregatorName
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.organizationAggregationSource = organizationAggregationSource
        }

        private enum CodingKeys: String, CodingKey {
            case accountAggregationSources = "AccountAggregationSources"
            case configurationAggregatorArn = "ConfigurationAggregatorArn"
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case organizationAggregationSource = "OrganizationAggregationSource"
        }
    }

    public struct ConfigurationItem: AWSDecodableShape {
        /// The 12-digit AWS account ID associated with the resource.
        public let accountId: String?
        /// Amazon Resource Name (ARN) associated with the resource.
        public let arn: String?
        /// The Availability Zone associated with the resource.
        public let availabilityZone: String?
        /// The region where the resource resides.
        public let awsRegion: String?
        /// The description of the resource configuration.
        public let configuration: String?
        /// The time when the configuration recording was initiated.
        public let configurationItemCaptureTime: Date?
        /// Unique MD5 hash that represents the configuration item's state. You can use MD5 hash to compare the states of two or more configuration items that are associated with the same resource.
        public let configurationItemMD5Hash: String?
        /// The configuration item status. The valid values are:   OK – The resource configuration has been updated   ResourceDiscovered – The resource was newly discovered   ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type   ResourceDeleted – The resource was deleted   ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type    The CIs do not incur any cost.
        public let configurationItemStatus: ConfigurationItemStatus?
        /// An identifier that indicates the ordering of the configuration items of a resource.
        public let configurationStateId: String?
        /// A list of CloudTrail event IDs. A populated field indicates that the current configuration was initiated by the events recorded in the CloudTrail log. For more information about CloudTrail, see What Is AWS CloudTrail. An empty field indicates that the current configuration was not initiated by any event. As of Version 1.3, the relatedEvents field is empty. You can access the LookupEvents API in the AWS CloudTrail API Reference to retrieve the events for the resource.
        public let relatedEvents: [String]?
        /// A list of related AWS resources.
        public let relationships: [Relationship]?
        /// The time stamp when the resource was created.
        public let resourceCreationTime: Date?
        /// The ID of the resource (for example, sg-xxxxxx).
        public let resourceId: String?
        /// The custom name of the resource, if available.
        public let resourceName: String?
        /// The type of AWS resource.
        public let resourceType: ResourceType?
        /// Configuration attributes that AWS Config returns for certain resource types to supplement the information returned for the configuration parameter.
        public let supplementaryConfiguration: [String: String]?
        /// A mapping of key value tags associated with the resource.
        public let tags: [String: String]?
        /// The version number of the resource configuration.
        public let version: String?

        public init(accountId: String? = nil, arn: String? = nil, availabilityZone: String? = nil, awsRegion: String? = nil, configuration: String? = nil, configurationItemCaptureTime: Date? = nil, configurationItemMD5Hash: String? = nil, configurationItemStatus: ConfigurationItemStatus? = nil, configurationStateId: String? = nil, relatedEvents: [String]? = nil, relationships: [Relationship]? = nil, resourceCreationTime: Date? = nil, resourceId: String? = nil, resourceName: String? = nil, resourceType: ResourceType? = nil, supplementaryConfiguration: [String: String]? = nil, tags: [String: String]? = nil, version: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.awsRegion = awsRegion
            self.configuration = configuration
            self.configurationItemCaptureTime = configurationItemCaptureTime
            self.configurationItemMD5Hash = configurationItemMD5Hash
            self.configurationItemStatus = configurationItemStatus
            self.configurationStateId = configurationStateId
            self.relatedEvents = relatedEvents
            self.relationships = relationships
            self.resourceCreationTime = resourceCreationTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.supplementaryConfiguration = supplementaryConfiguration
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case arn
            case availabilityZone
            case awsRegion
            case configuration
            case configurationItemCaptureTime
            case configurationItemMD5Hash
            case configurationItemStatus
            case configurationStateId
            case relatedEvents
            case relationships
            case resourceCreationTime
            case resourceId
            case resourceName
            case resourceType
            case supplementaryConfiguration
            case tags
            case version
        }
    }

    public struct ConfigurationRecorder: AWSEncodableShape & AWSDecodableShape {
        /// The name of the recorder. By default, AWS Config automatically assigns the name "default" when creating the configuration recorder. You cannot change the assigned name.
        public let name: String?
        /// Specifies the types of AWS resources for which AWS Config records configuration changes.
        public let recordingGroup: RecordingGroup?
        /// Amazon Resource Name (ARN) of the IAM role used to describe the AWS resources associated with the account.
        public let roleARN: String?

        public init(name: String? = nil, recordingGroup: RecordingGroup? = nil, roleARN: String? = nil) {
            self.name = name
            self.recordingGroup = recordingGroup
            self.roleARN = roleARN
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case recordingGroup
            case roleARN
        }
    }

    public struct ConfigurationRecorderStatus: AWSDecodableShape {
        /// The error code indicating that the recording failed.
        public let lastErrorCode: String?
        /// The message indicating that the recording failed due to an error.
        public let lastErrorMessage: String?
        /// The time the recorder was last started.
        public let lastStartTime: Date?
        /// The last (previous) status of the recorder.
        public let lastStatus: RecorderStatus?
        /// The time when the status was last changed.
        public let lastStatusChangeTime: Date?
        /// The time the recorder was last stopped.
        public let lastStopTime: Date?
        /// The name of the configuration recorder.
        public let name: String?
        /// Specifies whether or not the recorder is currently recording.
        public let recording: Bool?

        public init(lastErrorCode: String? = nil, lastErrorMessage: String? = nil, lastStartTime: Date? = nil, lastStatus: RecorderStatus? = nil, lastStatusChangeTime: Date? = nil, lastStopTime: Date? = nil, name: String? = nil, recording: Bool? = nil) {
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStartTime = lastStartTime
            self.lastStatus = lastStatus
            self.lastStatusChangeTime = lastStatusChangeTime
            self.lastStopTime = lastStopTime
            self.name = name
            self.recording = recording
        }

        private enum CodingKeys: String, CodingKey {
            case lastErrorCode
            case lastErrorMessage
            case lastStartTime
            case lastStatus
            case lastStatusChangeTime
            case lastStopTime
            case name
            case recording
        }
    }

    public struct ConformancePackComplianceFilters: AWSEncodableShape {
        /// Filters the results by compliance. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        public let complianceType: ConformancePackComplianceType?
        /// Filters the results by AWS Config rule names.
        public let configRuleNames: [String]?

        public init(complianceType: ConformancePackComplianceType? = nil, configRuleNames: [String]? = nil) {
            self.complianceType = complianceType
            self.configRuleNames = configRuleNames
        }

        public func validate(name: String) throws {
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 64)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 10)
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "ComplianceType"
            case configRuleNames = "ConfigRuleNames"
        }
    }

    public struct ConformancePackComplianceSummary: AWSDecodableShape {
        /// The status of the conformance pack. The allowed values are COMPLIANT, NON_COMPLIANT and INSUFFICIENT_DATA.
        public let conformancePackComplianceStatus: ConformancePackComplianceType
        /// The name of the conformance pack name.
        public let conformancePackName: String

        public init(conformancePackComplianceStatus: ConformancePackComplianceType, conformancePackName: String) {
            self.conformancePackComplianceStatus = conformancePackComplianceStatus
            self.conformancePackName = conformancePackName
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackComplianceStatus = "ConformancePackComplianceStatus"
            case conformancePackName = "ConformancePackName"
        }
    }

    public struct ConformancePackDetail: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the conformance pack.
        public let conformancePackArn: String
        /// ID of the conformance pack.
        public let conformancePackId: String
        /// A list of ConformancePackInputParameter objects.
        public let conformancePackInputParameters: [ConformancePackInputParameter]?
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// AWS service that created the conformance pack.
        public let createdBy: String?
        /// Amazon S3 bucket where AWS Config stores conformance pack templates.   This field is optional.
        public let deliveryS3Bucket: String?
        /// The prefix for the Amazon S3 bucket.  This field is optional.
        public let deliveryS3KeyPrefix: String?
        /// Last time when conformation pack update was requested.
        public let lastUpdateRequestedTime: Date?

        public init(conformancePackArn: String, conformancePackId: String, conformancePackInputParameters: [ConformancePackInputParameter]? = nil, conformancePackName: String, createdBy: String? = nil, deliveryS3Bucket: String? = nil, deliveryS3KeyPrefix: String? = nil, lastUpdateRequestedTime: Date? = nil) {
            self.conformancePackArn = conformancePackArn
            self.conformancePackId = conformancePackId
            self.conformancePackInputParameters = conformancePackInputParameters
            self.conformancePackName = conformancePackName
            self.createdBy = createdBy
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.lastUpdateRequestedTime = lastUpdateRequestedTime
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackArn = "ConformancePackArn"
            case conformancePackId = "ConformancePackId"
            case conformancePackInputParameters = "ConformancePackInputParameters"
            case conformancePackName = "ConformancePackName"
            case createdBy = "CreatedBy"
            case deliveryS3Bucket = "DeliveryS3Bucket"
            case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
            case lastUpdateRequestedTime = "LastUpdateRequestedTime"
        }
    }

    public struct ConformancePackEvaluationFilters: AWSEncodableShape {
        /// Filters the results by compliance. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        public let complianceType: ConformancePackComplianceType?
        /// Filters the results by AWS Config rule names.
        public let configRuleNames: [String]?
        /// Filters the results by resource IDs.  This is valid only when you provide resource type. If there is no resource type, you will see an error.
        public let resourceIds: [String]?
        /// Filters the results by the resource type (for example, "AWS::EC2::Instance").
        public let resourceType: String?

        public init(complianceType: ConformancePackComplianceType? = nil, configRuleNames: [String]? = nil, resourceIds: [String]? = nil, resourceType: String? = nil) {
            self.complianceType = complianceType
            self.configRuleNames = configRuleNames
            self.resourceIds = resourceIds
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 64)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 10)
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, min: 0)
            try self.resourceIds?.forEach {
                try validate($0, name: "resourceIds[]", parent: name, max: 256)
                try validate($0, name: "resourceIds[]", parent: name, min: 1)
            }
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 5)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, min: 0)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "ComplianceType"
            case configRuleNames = "ConfigRuleNames"
            case resourceIds = "ResourceIds"
            case resourceType = "ResourceType"
        }
    }

    public struct ConformancePackEvaluationResult: AWSDecodableShape {
        /// Supplementary information about how the evaluation determined the compliance.
        public let annotation: String?
        /// The compliance type. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        public let complianceType: ConformancePackComplianceType
        /// The time when AWS Config rule evaluated AWS resource.
        public let configRuleInvokedTime: Date
        public let evaluationResultIdentifier: EvaluationResultIdentifier
        /// The time when AWS Config recorded the evaluation result.
        public let resultRecordedTime: Date

        public init(annotation: String? = nil, complianceType: ConformancePackComplianceType, configRuleInvokedTime: Date, evaluationResultIdentifier: EvaluationResultIdentifier, resultRecordedTime: Date) {
            self.annotation = annotation
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
        }

        private enum CodingKeys: String, CodingKey {
            case annotation = "Annotation"
            case complianceType = "ComplianceType"
            case configRuleInvokedTime = "ConfigRuleInvokedTime"
            case evaluationResultIdentifier = "EvaluationResultIdentifier"
            case resultRecordedTime = "ResultRecordedTime"
        }
    }

    public struct ConformancePackInputParameter: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair.
        public let parameterName: String
        /// Another part of the key-value pair.
        public let parameterValue: String

        public init(parameterName: String, parameterValue: String) {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }

        public func validate(name: String) throws {
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 255)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 0)
            try self.validate(self.parameterValue, name: "parameterValue", parent: name, max: 4096)
            try self.validate(self.parameterValue, name: "parameterValue", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case parameterName = "ParameterName"
            case parameterValue = "ParameterValue"
        }
    }

    public struct ConformancePackRuleCompliance: AWSDecodableShape {
        /// Compliance of the AWS Config rule. The allowed values are COMPLIANT, NON_COMPLIANT, and INSUFFICIENT_DATA.
        public let complianceType: ConformancePackComplianceType?
        /// Name of the config rule.
        public let configRuleName: String?
        /// Controls for the conformance pack. A control is a process to prevent or detect problems while meeting objectives. A control can align with a specific compliance regime or map to internal controls defined by an organization.
        public let controls: [String]?

        public init(complianceType: ConformancePackComplianceType? = nil, configRuleName: String? = nil, controls: [String]? = nil) {
            self.complianceType = complianceType
            self.configRuleName = configRuleName
            self.controls = controls
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "ComplianceType"
            case configRuleName = "ConfigRuleName"
            case controls = "Controls"
        }
    }

    public struct ConformancePackStatusDetail: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of comformance pack.
        public let conformancePackArn: String
        /// ID of the conformance pack.
        public let conformancePackId: String
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// Indicates deployment status of conformance pack. AWS Config sets the state of the conformance pack to:   CREATE_IN_PROGRESS when a conformance pack creation is in progress for an account.   CREATE_COMPLETE when a conformance pack has been successfully created in your account.   CREATE_FAILED when a conformance pack creation failed in your account.   DELETE_IN_PROGRESS when a conformance pack deletion is in progress.    DELETE_FAILED when a conformance pack deletion failed in your account.
        public let conformancePackState: ConformancePackState
        /// The reason of conformance pack creation failure.
        public let conformancePackStatusReason: String?
        /// Last time when conformation pack creation and update was successful.
        public let lastUpdateCompletedTime: Date?
        /// Last time when conformation pack creation and update was requested.
        public let lastUpdateRequestedTime: Date
        /// Amazon Resource Name (ARN) of AWS CloudFormation stack.
        public let stackArn: String

        public init(conformancePackArn: String, conformancePackId: String, conformancePackName: String, conformancePackState: ConformancePackState, conformancePackStatusReason: String? = nil, lastUpdateCompletedTime: Date? = nil, lastUpdateRequestedTime: Date, stackArn: String) {
            self.conformancePackArn = conformancePackArn
            self.conformancePackId = conformancePackId
            self.conformancePackName = conformancePackName
            self.conformancePackState = conformancePackState
            self.conformancePackStatusReason = conformancePackStatusReason
            self.lastUpdateCompletedTime = lastUpdateCompletedTime
            self.lastUpdateRequestedTime = lastUpdateRequestedTime
            self.stackArn = stackArn
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackArn = "ConformancePackArn"
            case conformancePackId = "ConformancePackId"
            case conformancePackName = "ConformancePackName"
            case conformancePackState = "ConformancePackState"
            case conformancePackStatusReason = "ConformancePackStatusReason"
            case lastUpdateCompletedTime = "LastUpdateCompletedTime"
            case lastUpdateRequestedTime = "LastUpdateRequestedTime"
            case stackArn = "StackArn"
        }
    }

    public struct DeleteAggregationAuthorizationRequest: AWSEncodableShape {
        /// The 12-digit account ID of the account authorized to aggregate data.
        public let authorizedAccountId: String
        /// The region authorized to collect aggregated data.
        public let authorizedAwsRegion: String

        public init(authorizedAccountId: String, authorizedAwsRegion: String) {
            self.authorizedAccountId = authorizedAccountId
            self.authorizedAwsRegion = authorizedAwsRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.authorizedAccountId, name: "authorizedAccountId", parent: name, pattern: "\\d{12}")
            try self.validate(self.authorizedAwsRegion, name: "authorizedAwsRegion", parent: name, max: 64)
            try self.validate(self.authorizedAwsRegion, name: "authorizedAwsRegion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedAccountId = "AuthorizedAccountId"
            case authorizedAwsRegion = "AuthorizedAwsRegion"
        }
    }

    public struct DeleteConfigRuleRequest: AWSEncodableShape {
        /// The name of the AWS Config rule that you want to delete.
        public let configRuleName: String

        public init(configRuleName: String) {
            self.configRuleName = configRuleName
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
        }
    }

    public struct DeleteConfigurationAggregatorRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String

        public init(configurationAggregatorName: String) {
            self.configurationAggregatorName = configurationAggregatorName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
        }
    }

    public struct DeleteConfigurationRecorderRequest: AWSEncodableShape {
        /// The name of the configuration recorder to be deleted. You can retrieve the name of your configuration recorder by using the DescribeConfigurationRecorders action.
        public let configurationRecorderName: String

        public init(configurationRecorderName: String) {
            self.configurationRecorderName = configurationRecorderName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, max: 256)
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorderName = "ConfigurationRecorderName"
        }
    }

    public struct DeleteConformancePackRequest: AWSEncodableShape {
        /// Name of the conformance pack you want to delete.
        public let conformancePackName: String

        public init(conformancePackName: String) {
            self.conformancePackName = conformancePackName
        }

        public func validate(name: String) throws {
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, max: 256)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackName = "ConformancePackName"
        }
    }

    public struct DeleteDeliveryChannelRequest: AWSEncodableShape {
        /// The name of the delivery channel to delete.
        public let deliveryChannelName: String

        public init(deliveryChannelName: String) {
            self.deliveryChannelName = deliveryChannelName
        }

        public func validate(name: String) throws {
            try self.validate(self.deliveryChannelName, name: "deliveryChannelName", parent: name, max: 256)
            try self.validate(self.deliveryChannelName, name: "deliveryChannelName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannelName = "DeliveryChannelName"
        }
    }

    public struct DeleteEvaluationResultsRequest: AWSEncodableShape {
        /// The name of the AWS Config rule for which you want to delete the evaluation results.
        public let configRuleName: String

        public init(configRuleName: String) {
            self.configRuleName = configRuleName
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 64)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
        }
    }

    public struct DeleteEvaluationResultsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOrganizationConfigRuleRequest: AWSEncodableShape {
        /// The name of organization config rule that you want to delete.
        public let organizationConfigRuleName: String

        public init(organizationConfigRuleName: String) {
            self.organizationConfigRuleName = organizationConfigRuleName
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, max: 64)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, min: 1)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationConfigRuleName = "OrganizationConfigRuleName"
        }
    }

    public struct DeleteOrganizationConformancePackRequest: AWSEncodableShape {
        /// The name of organization conformance pack that you want to delete.
        public let organizationConformancePackName: String

        public init(organizationConformancePackName: String) {
            self.organizationConformancePackName = organizationConformancePackName
        }

        public func validate(name: String) throws {
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, max: 128)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, min: 1)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
        }

        private enum CodingKeys: String, CodingKey {
            case organizationConformancePackName = "OrganizationConformancePackName"
        }
    }

    public struct DeletePendingAggregationRequestRequest: AWSEncodableShape {
        /// The 12-digit account ID of the account requesting to aggregate data.
        public let requesterAccountId: String
        /// The region requesting to aggregate data.
        public let requesterAwsRegion: String

        public init(requesterAccountId: String, requesterAwsRegion: String) {
            self.requesterAccountId = requesterAccountId
            self.requesterAwsRegion = requesterAwsRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.requesterAccountId, name: "requesterAccountId", parent: name, pattern: "\\d{12}")
            try self.validate(self.requesterAwsRegion, name: "requesterAwsRegion", parent: name, max: 64)
            try self.validate(self.requesterAwsRegion, name: "requesterAwsRegion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case requesterAccountId = "RequesterAccountId"
            case requesterAwsRegion = "RequesterAwsRegion"
        }
    }

    public struct DeleteRemediationConfigurationRequest: AWSEncodableShape {
        /// The name of the AWS Config rule for which you want to delete remediation configuration.
        public let configRuleName: String
        /// The type of a resource.
        public let resourceType: String?

        public init(configRuleName: String, resourceType: String? = nil) {
            self.configRuleName = configRuleName
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case resourceType = "ResourceType"
        }
    }

    public struct DeleteRemediationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRemediationExceptionsRequest: AWSEncodableShape {
        /// The name of the AWS Config rule for which you want to delete remediation exception configuration.
        public let configRuleName: String
        /// An exception list of resource exception keys to be processed with the current request. AWS Config adds exception for each resource key. For example, AWS Config adds 3 exceptions for 3 resource keys.
        public let resourceKeys: [RemediationExceptionResourceKey]

        public init(configRuleName: String, resourceKeys: [RemediationExceptionResourceKey]) {
            self.configRuleName = configRuleName
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
            try self.resourceKeys.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case resourceKeys = "ResourceKeys"
        }
    }

    public struct DeleteRemediationExceptionsResponse: AWSDecodableShape {
        /// Returns a list of failed delete remediation exceptions batch objects. Each object in the batch consists of a list of failed items and failure messages.
        public let failedBatches: [FailedDeleteRemediationExceptionsBatch]?

        public init(failedBatches: [FailedDeleteRemediationExceptionsBatch]? = nil) {
            self.failedBatches = failedBatches
        }

        private enum CodingKeys: String, CodingKey {
            case failedBatches = "FailedBatches"
        }
    }

    public struct DeleteResourceConfigRequest: AWSEncodableShape {
        /// Unique identifier of the resource.
        public let resourceId: String
        /// The type of the resource.
        public let resourceType: String

        public init(resourceId: String, resourceType: String) {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 196)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct DeleteRetentionConfigurationRequest: AWSEncodableShape {
        /// The name of the retention configuration to delete.
        public let retentionConfigurationName: String

        public init(retentionConfigurationName: String) {
            self.retentionConfigurationName = retentionConfigurationName
        }

        public func validate(name: String) throws {
            try self.validate(self.retentionConfigurationName, name: "retentionConfigurationName", parent: name, max: 256)
            try self.validate(self.retentionConfigurationName, name: "retentionConfigurationName", parent: name, min: 1)
            try self.validate(self.retentionConfigurationName, name: "retentionConfigurationName", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case retentionConfigurationName = "RetentionConfigurationName"
        }
    }

    public struct DeleteStoredQueryRequest: AWSEncodableShape {
        /// The name of the query that you want to delete.
        public let queryName: String

        public init(queryName: String) {
            self.queryName = queryName
        }

        public func validate(name: String) throws {
            try self.validate(self.queryName, name: "queryName", parent: name, max: 64)
            try self.validate(self.queryName, name: "queryName", parent: name, min: 1)
            try self.validate(self.queryName, name: "queryName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case queryName = "QueryName"
        }
    }

    public struct DeleteStoredQueryResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeliverConfigSnapshotRequest: AWSEncodableShape {
        /// The name of the delivery channel through which the snapshot is delivered.
        public let deliveryChannelName: String

        public init(deliveryChannelName: String) {
            self.deliveryChannelName = deliveryChannelName
        }

        public func validate(name: String) throws {
            try self.validate(self.deliveryChannelName, name: "deliveryChannelName", parent: name, max: 256)
            try self.validate(self.deliveryChannelName, name: "deliveryChannelName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannelName
        }
    }

    public struct DeliverConfigSnapshotResponse: AWSDecodableShape {
        /// The ID of the snapshot that is being created.
        public let configSnapshotId: String?

        public init(configSnapshotId: String? = nil) {
            self.configSnapshotId = configSnapshotId
        }

        private enum CodingKeys: String, CodingKey {
            case configSnapshotId
        }
    }

    public struct DeliveryChannel: AWSEncodableShape & AWSDecodableShape {
        /// The options for how often AWS Config delivers configuration snapshots to the Amazon S3 bucket.
        public let configSnapshotDeliveryProperties: ConfigSnapshotDeliveryProperties?
        /// The name of the delivery channel. By default, AWS Config assigns the name "default" when creating the delivery channel. To change the delivery channel name, you must use the DeleteDeliveryChannel action to delete your current delivery channel, and then you must use the PutDeliveryChannel command to create a delivery channel that has the desired name.
        public let name: String?
        /// The name of the Amazon S3 bucket to which AWS Config delivers configuration snapshots and configuration history files. If you specify a bucket that belongs to another AWS account, that bucket must have policies that grant access permissions to AWS Config. For more information, see Permissions for the Amazon S3 Bucket in the AWS Config Developer Guide.
        public let s3BucketName: String?
        /// The prefix for the specified Amazon S3 bucket.
        public let s3KeyPrefix: String?
        /// The Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) customer managed key (CMK) used to encrypt objects delivered by AWS Config. Must belong to the same Region as the destination S3 bucket.
        public let s3KmsKeyArn: String?
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic to which AWS Config sends notifications about configuration changes. If you choose a topic from another account, the topic must have policies that grant access permissions to AWS Config. For more information, see Permissions for the Amazon SNS Topic in the AWS Config Developer Guide.
        public let snsTopicARN: String?

        public init(configSnapshotDeliveryProperties: ConfigSnapshotDeliveryProperties? = nil, name: String? = nil, s3BucketName: String? = nil, s3KeyPrefix: String? = nil, s3KmsKeyArn: String? = nil, snsTopicARN: String? = nil) {
            self.configSnapshotDeliveryProperties = configSnapshotDeliveryProperties
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.s3KmsKeyArn = s3KmsKeyArn
            self.snsTopicARN = snsTopicARN
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configSnapshotDeliveryProperties
            case name
            case s3BucketName
            case s3KeyPrefix
            case s3KmsKeyArn
            case snsTopicARN
        }
    }

    public struct DeliveryChannelStatus: AWSDecodableShape {
        /// A list that contains the status of the delivery of the configuration history to the specified Amazon S3 bucket.
        public let configHistoryDeliveryInfo: ConfigExportDeliveryInfo?
        /// A list containing the status of the delivery of the snapshot to the specified Amazon S3 bucket.
        public let configSnapshotDeliveryInfo: ConfigExportDeliveryInfo?
        /// A list containing the status of the delivery of the configuration stream notification to the specified Amazon SNS topic.
        public let configStreamDeliveryInfo: ConfigStreamDeliveryInfo?
        /// The name of the delivery channel.
        public let name: String?

        public init(configHistoryDeliveryInfo: ConfigExportDeliveryInfo? = nil, configSnapshotDeliveryInfo: ConfigExportDeliveryInfo? = nil, configStreamDeliveryInfo: ConfigStreamDeliveryInfo? = nil, name: String? = nil) {
            self.configHistoryDeliveryInfo = configHistoryDeliveryInfo
            self.configSnapshotDeliveryInfo = configSnapshotDeliveryInfo
            self.configStreamDeliveryInfo = configStreamDeliveryInfo
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case configHistoryDeliveryInfo
            case configSnapshotDeliveryInfo
            case configStreamDeliveryInfo
            case name
        }
    }

    public struct DescribeAggregateComplianceByConfigRulesRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the results by ConfigRuleComplianceFilters object.
        public let filters: ConfigRuleComplianceFilters?
        /// The maximum number of evaluation results returned on each page. The default is maximum. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configurationAggregatorName: String, filters: ConfigRuleComplianceFilters? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 1000)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAggregateComplianceByConfigRulesResponse: AWSDecodableShape {
        /// Returns a list of AggregateComplianceByConfigRule object.
        public let aggregateComplianceByConfigRules: [AggregateComplianceByConfigRule]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(aggregateComplianceByConfigRules: [AggregateComplianceByConfigRule]? = nil, nextToken: String? = nil) {
            self.aggregateComplianceByConfigRules = aggregateComplianceByConfigRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateComplianceByConfigRules = "AggregateComplianceByConfigRules"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAggregateComplianceByConformancePacksRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the result by AggregateConformancePackComplianceFilters object.
        public let filters: AggregateConformancePackComplianceFilters?
        /// The maximum number of conformance packs compliance details returned on each page. The default is maximum. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configurationAggregatorName: String, filters: AggregateConformancePackComplianceFilters? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAggregateComplianceByConformancePacksResponse: AWSDecodableShape {
        /// Returns the AggregateComplianceByConformancePack object.
        public let aggregateComplianceByConformancePacks: [AggregateComplianceByConformancePack]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(aggregateComplianceByConformancePacks: [AggregateComplianceByConformancePack]? = nil, nextToken: String? = nil) {
            self.aggregateComplianceByConformancePacks = aggregateComplianceByConformancePacks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateComplianceByConformancePacks = "AggregateComplianceByConformancePacks"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAggregationAuthorizationsRequest: AWSEncodableShape {
        /// The maximum number of AggregationAuthorizations returned on each page. The default is maximum. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(limit: Int? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAggregationAuthorizationsResponse: AWSDecodableShape {
        /// Returns a list of authorizations granted to various aggregator accounts and regions.
        public let aggregationAuthorizations: [AggregationAuthorization]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(aggregationAuthorizations: [AggregationAuthorization]? = nil, nextToken: String? = nil) {
            self.aggregationAuthorizations = aggregationAuthorizations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationAuthorizations = "AggregationAuthorizations"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeComplianceByConfigRuleRequest: AWSEncodableShape {
        /// Filters the results by compliance. The allowed values are COMPLIANT and NON_COMPLIANT.
        public let complianceTypes: [ComplianceType]?
        /// Specify one or more AWS Config rule names to filter the results by rule.
        public let configRuleNames: [String]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(complianceTypes: [ComplianceType]? = nil, configRuleNames: [String]? = nil, nextToken: String? = nil) {
            self.complianceTypes = complianceTypes
            self.configRuleNames = configRuleNames
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, max: 3)
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, min: 0)
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 128)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
                try validate($0, name: "configRuleNames[]", parent: name, pattern: ".*\\S.*")
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 25)
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceTypes = "ComplianceTypes"
            case configRuleNames = "ConfigRuleNames"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeComplianceByConfigRuleResponse: AWSDecodableShape {
        /// Indicates whether each of the specified AWS Config rules is compliant.
        public let complianceByConfigRules: [ComplianceByConfigRule]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(complianceByConfigRules: [ComplianceByConfigRule]? = nil, nextToken: String? = nil) {
            self.complianceByConfigRules = complianceByConfigRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case complianceByConfigRules = "ComplianceByConfigRules"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeComplianceByResourceRequest: AWSEncodableShape {
        /// Filters the results by compliance. The allowed values are COMPLIANT, NON_COMPLIANT, and INSUFFICIENT_DATA.
        public let complianceTypes: [ComplianceType]?
        /// The maximum number of evaluation results returned on each page. The default is 10. You cannot specify a number greater than 100. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The ID of the AWS resource for which you want compliance information. You can specify only one resource ID. If you specify a resource ID, you must also specify a type for ResourceType.
        public let resourceId: String?
        /// The types of AWS resources for which you want compliance information (for example, AWS::EC2::Instance). For this action, you can specify that the resource type is an AWS account by specifying AWS::::Account.
        public let resourceType: String?

        public init(complianceTypes: [ComplianceType]? = nil, limit: Int? = nil, nextToken: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.complianceTypes = complianceTypes
            self.limit = limit
            self.nextToken = nextToken
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, max: 3)
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, min: 0)
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceTypes = "ComplianceTypes"
            case limit = "Limit"
            case nextToken = "NextToken"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct DescribeComplianceByResourceResponse: AWSDecodableShape {
        /// Indicates whether the specified AWS resource complies with all of the AWS Config rules that evaluate it.
        public let complianceByResources: [ComplianceByResource]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(complianceByResources: [ComplianceByResource]? = nil, nextToken: String? = nil) {
            self.complianceByResources = complianceByResources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case complianceByResources = "ComplianceByResources"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigRuleEvaluationStatusRequest: AWSEncodableShape {
        /// The name of the AWS managed Config rules for which you want status information. If you do not specify any names, AWS Config returns status information for all AWS managed Config rules that you use.
        public let configRuleNames: [String]?
        /// The number of rule evaluation results that you want returned. This parameter is required if the rule limit for your account is more than the default of 150 rules. For information about requesting a rule limit increase, see AWS Config Limits in the AWS General Reference Guide.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configRuleNames: [String]? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configRuleNames = configRuleNames
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 128)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
                try validate($0, name: "configRuleNames[]", parent: name, pattern: ".*\\S.*")
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 25)
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, min: 0)
            try self.validate(self.limit, name: "limit", parent: name, max: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleNames = "ConfigRuleNames"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigRuleEvaluationStatusResponse: AWSDecodableShape {
        /// Status information about your AWS managed Config rules.
        public let configRulesEvaluationStatus: [ConfigRuleEvaluationStatus]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configRulesEvaluationStatus: [ConfigRuleEvaluationStatus]? = nil, nextToken: String? = nil) {
            self.configRulesEvaluationStatus = configRulesEvaluationStatus
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configRulesEvaluationStatus = "ConfigRulesEvaluationStatus"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigRulesRequest: AWSEncodableShape {
        /// The names of the AWS Config rules for which you want details. If you do not specify any names, AWS Config returns details for all your rules.
        public let configRuleNames: [String]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configRuleNames: [String]? = nil, nextToken: String? = nil) {
            self.configRuleNames = configRuleNames
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 128)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
                try validate($0, name: "configRuleNames[]", parent: name, pattern: ".*\\S.*")
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 25)
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleNames = "ConfigRuleNames"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigRulesResponse: AWSDecodableShape {
        /// The details about your AWS Config rules.
        public let configRules: [ConfigRule]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configRules: [ConfigRule]? = nil, nextToken: String? = nil) {
            self.configRules = configRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configRules = "ConfigRules"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationAggregatorSourcesStatusRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// The maximum number of AggregatorSourceStatus returned on each page. The default is maximum. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Filters the status type.   Valid value FAILED indicates errors while moving data.   Valid value SUCCEEDED indicates the data was successfully moved.   Valid value OUTDATED indicates the data is not the most recent.
        public let updateStatus: [AggregatedSourceStatusType]?

        public init(configurationAggregatorName: String, limit: Int? = nil, nextToken: String? = nil, updateStatus: [AggregatedSourceStatusType]? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.limit = limit
            self.nextToken = nextToken
            self.updateStatus = updateStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.updateStatus, name: "updateStatus", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case limit = "Limit"
            case nextToken = "NextToken"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct DescribeConfigurationAggregatorSourcesStatusResponse: AWSDecodableShape {
        /// Returns an AggregatedSourceStatus object.
        public let aggregatedSourceStatusList: [AggregatedSourceStatus]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(aggregatedSourceStatusList: [AggregatedSourceStatus]? = nil, nextToken: String? = nil) {
            self.aggregatedSourceStatusList = aggregatedSourceStatusList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedSourceStatusList = "AggregatedSourceStatusList"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationAggregatorsRequest: AWSEncodableShape {
        /// The name of the configuration aggregators.
        public let configurationAggregatorNames: [String]?
        /// The maximum number of configuration aggregators returned on each page. The default is maximum. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configurationAggregatorNames: [String]? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorNames = configurationAggregatorNames
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.configurationAggregatorNames?.forEach {
                try validate($0, name: "configurationAggregatorNames[]", parent: name, max: 256)
                try validate($0, name: "configurationAggregatorNames[]", parent: name, min: 1)
                try validate($0, name: "configurationAggregatorNames[]", parent: name, pattern: "[\\w\\-]+")
            }
            try self.validate(self.configurationAggregatorNames, name: "configurationAggregatorNames", parent: name, max: 10)
            try self.validate(self.configurationAggregatorNames, name: "configurationAggregatorNames", parent: name, min: 0)
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorNames = "ConfigurationAggregatorNames"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationAggregatorsResponse: AWSDecodableShape {
        /// Returns a ConfigurationAggregators object.
        public let configurationAggregators: [ConfigurationAggregator]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configurationAggregators: [ConfigurationAggregator]? = nil, nextToken: String? = nil) {
            self.configurationAggregators = configurationAggregators
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregators = "ConfigurationAggregators"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationRecorderStatusRequest: AWSEncodableShape {
        /// The name(s) of the configuration recorder. If the name is not specified, the action returns the current status of all the configuration recorders associated with the account.
        public let configurationRecorderNames: [String]?

        public init(configurationRecorderNames: [String]? = nil) {
            self.configurationRecorderNames = configurationRecorderNames
        }

        public func validate(name: String) throws {
            try self.configurationRecorderNames?.forEach {
                try validate($0, name: "configurationRecorderNames[]", parent: name, max: 256)
                try validate($0, name: "configurationRecorderNames[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorderNames = "ConfigurationRecorderNames"
        }
    }

    public struct DescribeConfigurationRecorderStatusResponse: AWSDecodableShape {
        /// A list that contains status of the specified recorders.
        public let configurationRecordersStatus: [ConfigurationRecorderStatus]?

        public init(configurationRecordersStatus: [ConfigurationRecorderStatus]? = nil) {
            self.configurationRecordersStatus = configurationRecordersStatus
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecordersStatus = "ConfigurationRecordersStatus"
        }
    }

    public struct DescribeConfigurationRecordersRequest: AWSEncodableShape {
        /// A list of configuration recorder names.
        public let configurationRecorderNames: [String]?

        public init(configurationRecorderNames: [String]? = nil) {
            self.configurationRecorderNames = configurationRecorderNames
        }

        public func validate(name: String) throws {
            try self.configurationRecorderNames?.forEach {
                try validate($0, name: "configurationRecorderNames[]", parent: name, max: 256)
                try validate($0, name: "configurationRecorderNames[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorderNames = "ConfigurationRecorderNames"
        }
    }

    public struct DescribeConfigurationRecordersResponse: AWSDecodableShape {
        /// A list that contains the descriptions of the specified configuration recorders.
        public let configurationRecorders: [ConfigurationRecorder]?

        public init(configurationRecorders: [ConfigurationRecorder]? = nil) {
            self.configurationRecorders = configurationRecorders
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorders = "ConfigurationRecorders"
        }
    }

    public struct DescribeConformancePackComplianceRequest: AWSEncodableShape {
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// A ConformancePackComplianceFilters object.
        public let filters: ConformancePackComplianceFilters?
        /// The maximum number of AWS Config rules within a conformance pack are returned on each page.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        public init(conformancePackName: String, filters: ConformancePackComplianceFilters? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.conformancePackName = conformancePackName
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, max: 256)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 1000)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackName = "ConformancePackName"
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConformancePackComplianceResponse: AWSDecodableShape {
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// Returns a list of ConformancePackRuleCompliance objects.
        public let conformancePackRuleComplianceList: [ConformancePackRuleCompliance]
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        public init(conformancePackName: String, conformancePackRuleComplianceList: [ConformancePackRuleCompliance], nextToken: String? = nil) {
            self.conformancePackName = conformancePackName
            self.conformancePackRuleComplianceList = conformancePackRuleComplianceList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackName = "ConformancePackName"
            case conformancePackRuleComplianceList = "ConformancePackRuleComplianceList"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConformancePackStatusRequest: AWSEncodableShape {
        /// Comma-separated list of conformance pack names.
        public let conformancePackNames: [String]?
        /// The maximum number of conformance packs status returned on each page.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        public init(conformancePackNames: [String]? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.conformancePackNames = conformancePackNames
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.conformancePackNames?.forEach {
                try validate($0, name: "conformancePackNames[]", parent: name, max: 256)
                try validate($0, name: "conformancePackNames[]", parent: name, min: 1)
                try validate($0, name: "conformancePackNames[]", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
            }
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, max: 25)
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, min: 0)
            try self.validate(self.limit, name: "limit", parent: name, max: 20)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackNames = "ConformancePackNames"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConformancePackStatusResponse: AWSDecodableShape {
        /// A list of ConformancePackStatusDetail objects.
        public let conformancePackStatusDetails: [ConformancePackStatusDetail]?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        public init(conformancePackStatusDetails: [ConformancePackStatusDetail]? = nil, nextToken: String? = nil) {
            self.conformancePackStatusDetails = conformancePackStatusDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackStatusDetails = "ConformancePackStatusDetails"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConformancePacksRequest: AWSEncodableShape {
        /// Comma-separated list of conformance pack names for which you want details. If you do not specify any names, AWS Config returns details for all your conformance packs.
        public let conformancePackNames: [String]?
        /// The maximum number of conformance packs returned on each page.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        public init(conformancePackNames: [String]? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.conformancePackNames = conformancePackNames
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.conformancePackNames?.forEach {
                try validate($0, name: "conformancePackNames[]", parent: name, max: 256)
                try validate($0, name: "conformancePackNames[]", parent: name, min: 1)
                try validate($0, name: "conformancePackNames[]", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
            }
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, max: 25)
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, min: 0)
            try self.validate(self.limit, name: "limit", parent: name, max: 20)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackNames = "ConformancePackNames"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConformancePacksResponse: AWSDecodableShape {
        /// Returns a list of ConformancePackDetail objects.
        public let conformancePackDetails: [ConformancePackDetail]?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        public init(conformancePackDetails: [ConformancePackDetail]? = nil, nextToken: String? = nil) {
            self.conformancePackDetails = conformancePackDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackDetails = "ConformancePackDetails"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeDeliveryChannelStatusRequest: AWSEncodableShape {
        /// A list of delivery channel names.
        public let deliveryChannelNames: [String]?

        public init(deliveryChannelNames: [String]? = nil) {
            self.deliveryChannelNames = deliveryChannelNames
        }

        public func validate(name: String) throws {
            try self.deliveryChannelNames?.forEach {
                try validate($0, name: "deliveryChannelNames[]", parent: name, max: 256)
                try validate($0, name: "deliveryChannelNames[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannelNames = "DeliveryChannelNames"
        }
    }

    public struct DescribeDeliveryChannelStatusResponse: AWSDecodableShape {
        /// A list that contains the status of a specified delivery channel.
        public let deliveryChannelsStatus: [DeliveryChannelStatus]?

        public init(deliveryChannelsStatus: [DeliveryChannelStatus]? = nil) {
            self.deliveryChannelsStatus = deliveryChannelsStatus
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannelsStatus = "DeliveryChannelsStatus"
        }
    }

    public struct DescribeDeliveryChannelsRequest: AWSEncodableShape {
        /// A list of delivery channel names.
        public let deliveryChannelNames: [String]?

        public init(deliveryChannelNames: [String]? = nil) {
            self.deliveryChannelNames = deliveryChannelNames
        }

        public func validate(name: String) throws {
            try self.deliveryChannelNames?.forEach {
                try validate($0, name: "deliveryChannelNames[]", parent: name, max: 256)
                try validate($0, name: "deliveryChannelNames[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannelNames = "DeliveryChannelNames"
        }
    }

    public struct DescribeDeliveryChannelsResponse: AWSDecodableShape {
        /// A list that contains the descriptions of the specified delivery channel.
        public let deliveryChannels: [DeliveryChannel]?

        public init(deliveryChannels: [DeliveryChannel]? = nil) {
            self.deliveryChannels = deliveryChannels
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannels = "DeliveryChannels"
        }
    }

    public struct DescribeOrganizationConfigRuleStatusesRequest: AWSEncodableShape {
        /// The maximum number of OrganizationConfigRuleStatuses returned on each page. If you do no specify a number, AWS Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The names of organization config rules for which you want status details. If you do not specify any names, AWS Config returns details for all your organization AWS Confg rules.
        public let organizationConfigRuleNames: [String]?

        public init(limit: Int? = nil, nextToken: String? = nil, organizationConfigRuleNames: [String]? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConfigRuleNames = organizationConfigRuleNames
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.organizationConfigRuleNames?.forEach {
                try validate($0, name: "organizationConfigRuleNames[]", parent: name, max: 64)
                try validate($0, name: "organizationConfigRuleNames[]", parent: name, min: 1)
            }
            try self.validate(self.organizationConfigRuleNames, name: "organizationConfigRuleNames", parent: name, max: 25)
            try self.validate(self.organizationConfigRuleNames, name: "organizationConfigRuleNames", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConfigRuleNames = "OrganizationConfigRuleNames"
        }
    }

    public struct DescribeOrganizationConfigRuleStatusesResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of OrganizationConfigRuleStatus objects.
        public let organizationConfigRuleStatuses: [OrganizationConfigRuleStatus]?

        public init(nextToken: String? = nil, organizationConfigRuleStatuses: [OrganizationConfigRuleStatus]? = nil) {
            self.nextToken = nextToken
            self.organizationConfigRuleStatuses = organizationConfigRuleStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConfigRuleStatuses = "OrganizationConfigRuleStatuses"
        }
    }

    public struct DescribeOrganizationConfigRulesRequest: AWSEncodableShape {
        /// The maximum number of organization config rules returned on each page. If you do no specify a number, AWS Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The names of organization config rules for which you want details. If you do not specify any names, AWS Config returns details for all your organization config rules.
        public let organizationConfigRuleNames: [String]?

        public init(limit: Int? = nil, nextToken: String? = nil, organizationConfigRuleNames: [String]? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConfigRuleNames = organizationConfigRuleNames
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.organizationConfigRuleNames?.forEach {
                try validate($0, name: "organizationConfigRuleNames[]", parent: name, max: 64)
                try validate($0, name: "organizationConfigRuleNames[]", parent: name, min: 1)
            }
            try self.validate(self.organizationConfigRuleNames, name: "organizationConfigRuleNames", parent: name, max: 25)
            try self.validate(self.organizationConfigRuleNames, name: "organizationConfigRuleNames", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConfigRuleNames = "OrganizationConfigRuleNames"
        }
    }

    public struct DescribeOrganizationConfigRulesResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a list of OrganizationConfigRule objects.
        public let organizationConfigRules: [OrganizationConfigRule]?

        public init(nextToken: String? = nil, organizationConfigRules: [OrganizationConfigRule]? = nil) {
            self.nextToken = nextToken
            self.organizationConfigRules = organizationConfigRules
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConfigRules = "OrganizationConfigRules"
        }
    }

    public struct DescribeOrganizationConformancePackStatusesRequest: AWSEncodableShape {
        /// The maximum number of OrganizationConformancePackStatuses returned on each page. If you do no specify a number, AWS Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The names of organization conformance packs for which you want status details. If you do not specify any names, AWS Config returns details for all your organization conformance packs.
        public let organizationConformancePackNames: [String]?

        public init(limit: Int? = nil, nextToken: String? = nil, organizationConformancePackNames: [String]? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConformancePackNames = organizationConformancePackNames
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.organizationConformancePackNames?.forEach {
                try validate($0, name: "organizationConformancePackNames[]", parent: name, max: 128)
                try validate($0, name: "organizationConformancePackNames[]", parent: name, min: 1)
                try validate($0, name: "organizationConformancePackNames[]", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
            }
            try self.validate(self.organizationConformancePackNames, name: "organizationConformancePackNames", parent: name, max: 25)
            try self.validate(self.organizationConformancePackNames, name: "organizationConformancePackNames", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConformancePackNames = "OrganizationConformancePackNames"
        }
    }

    public struct DescribeOrganizationConformancePackStatusesResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of OrganizationConformancePackStatus objects.
        public let organizationConformancePackStatuses: [OrganizationConformancePackStatus]?

        public init(nextToken: String? = nil, organizationConformancePackStatuses: [OrganizationConformancePackStatus]? = nil) {
            self.nextToken = nextToken
            self.organizationConformancePackStatuses = organizationConformancePackStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConformancePackStatuses = "OrganizationConformancePackStatuses"
        }
    }

    public struct DescribeOrganizationConformancePacksRequest: AWSEncodableShape {
        /// The maximum number of organization config packs returned on each page. If you do no specify a number, AWS Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The name that you assign to an organization conformance pack.
        public let organizationConformancePackNames: [String]?

        public init(limit: Int? = nil, nextToken: String? = nil, organizationConformancePackNames: [String]? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConformancePackNames = organizationConformancePackNames
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.organizationConformancePackNames?.forEach {
                try validate($0, name: "organizationConformancePackNames[]", parent: name, max: 128)
                try validate($0, name: "organizationConformancePackNames[]", parent: name, min: 1)
                try validate($0, name: "organizationConformancePackNames[]", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
            }
            try self.validate(self.organizationConformancePackNames, name: "organizationConformancePackNames", parent: name, max: 25)
            try self.validate(self.organizationConformancePackNames, name: "organizationConformancePackNames", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConformancePackNames = "OrganizationConformancePackNames"
        }
    }

    public struct DescribeOrganizationConformancePacksResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a list of OrganizationConformancePacks objects.
        public let organizationConformancePacks: [OrganizationConformancePack]?

        public init(nextToken: String? = nil, organizationConformancePacks: [OrganizationConformancePack]? = nil) {
            self.nextToken = nextToken
            self.organizationConformancePacks = organizationConformancePacks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConformancePacks = "OrganizationConformancePacks"
        }
    }

    public struct DescribePendingAggregationRequestsRequest: AWSEncodableShape {
        /// The maximum number of evaluation results returned on each page. The default is maximum. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(limit: Int? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 20)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribePendingAggregationRequestsResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a PendingAggregationRequests object.
        public let pendingAggregationRequests: [PendingAggregationRequest]?

        public init(nextToken: String? = nil, pendingAggregationRequests: [PendingAggregationRequest]? = nil) {
            self.nextToken = nextToken
            self.pendingAggregationRequests = pendingAggregationRequests
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pendingAggregationRequests = "PendingAggregationRequests"
        }
    }

    public struct DescribeRemediationConfigurationsRequest: AWSEncodableShape {
        /// A list of AWS Config rule names of remediation configurations for which you want details.
        public let configRuleNames: [String]

        public init(configRuleNames: [String]) {
            self.configRuleNames = configRuleNames
        }

        public func validate(name: String) throws {
            try self.configRuleNames.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 128)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
                try validate($0, name: "configRuleNames[]", parent: name, pattern: ".*\\S.*")
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 25)
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleNames = "ConfigRuleNames"
        }
    }

    public struct DescribeRemediationConfigurationsResponse: AWSDecodableShape {
        /// Returns a remediation configuration object.
        public let remediationConfigurations: [RemediationConfiguration]?

        public init(remediationConfigurations: [RemediationConfiguration]? = nil) {
            self.remediationConfigurations = remediationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case remediationConfigurations = "RemediationConfigurations"
        }
    }

    public struct DescribeRemediationExceptionsRequest: AWSEncodableShape {
        /// The name of the AWS Config rule.
        public let configRuleName: String
        /// The maximum number of RemediationExceptionResourceKey returned on each page. The default is 25. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?
        /// An exception list of resource exception keys to be processed with the current request. AWS Config adds exception for each resource key. For example, AWS Config adds 3 exceptions for 3 resource keys.
        public let resourceKeys: [RemediationExceptionResourceKey]?

        public init(configRuleName: String, limit: Int? = nil, nextToken: String? = nil, resourceKeys: [RemediationExceptionResourceKey]? = nil) {
            self.configRuleName = configRuleName
            self.limit = limit
            self.nextToken = nextToken
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.resourceKeys?.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case limit = "Limit"
            case nextToken = "NextToken"
            case resourceKeys = "ResourceKeys"
        }
    }

    public struct DescribeRemediationExceptionsResponse: AWSDecodableShape {
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a list of remediation exception objects.
        public let remediationExceptions: [RemediationException]?

        public init(nextToken: String? = nil, remediationExceptions: [RemediationException]? = nil) {
            self.nextToken = nextToken
            self.remediationExceptions = remediationExceptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case remediationExceptions = "RemediationExceptions"
        }
    }

    public struct DescribeRemediationExecutionStatusRequest: AWSEncodableShape {
        /// A list of AWS Config rule names.
        public let configRuleName: String
        /// The maximum number of RemediationExecutionStatuses returned on each page. The default is maximum. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID.
        public let resourceKeys: [ResourceKey]?

        public init(configRuleName: String, limit: Int? = nil, nextToken: String? = nil, resourceKeys: [ResourceKey]? = nil) {
            self.configRuleName = configRuleName
            self.limit = limit
            self.nextToken = nextToken
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.resourceKeys?.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case limit = "Limit"
            case nextToken = "NextToken"
            case resourceKeys = "ResourceKeys"
        }
    }

    public struct DescribeRemediationExecutionStatusResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a list of remediation execution statuses objects.
        public let remediationExecutionStatuses: [RemediationExecutionStatus]?

        public init(nextToken: String? = nil, remediationExecutionStatuses: [RemediationExecutionStatus]? = nil) {
            self.nextToken = nextToken
            self.remediationExecutionStatuses = remediationExecutionStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case remediationExecutionStatuses = "RemediationExecutionStatuses"
        }
    }

    public struct DescribeRetentionConfigurationsRequest: AWSEncodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of names of retention configurations for which you want details. If you do not specify a name, AWS Config returns details for all the retention configurations for that account.  Currently, AWS Config supports only one retention configuration per region in your account.
        public let retentionConfigurationNames: [String]?

        public init(nextToken: String? = nil, retentionConfigurationNames: [String]? = nil) {
            self.nextToken = nextToken
            self.retentionConfigurationNames = retentionConfigurationNames
        }

        public func validate(name: String) throws {
            try self.retentionConfigurationNames?.forEach {
                try validate($0, name: "retentionConfigurationNames[]", parent: name, max: 256)
                try validate($0, name: "retentionConfigurationNames[]", parent: name, min: 1)
                try validate($0, name: "retentionConfigurationNames[]", parent: name, pattern: "[\\w\\-]+")
            }
            try self.validate(self.retentionConfigurationNames, name: "retentionConfigurationNames", parent: name, max: 1)
            try self.validate(self.retentionConfigurationNames, name: "retentionConfigurationNames", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case retentionConfigurationNames = "RetentionConfigurationNames"
        }
    }

    public struct DescribeRetentionConfigurationsResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a retention configuration object.
        public let retentionConfigurations: [RetentionConfiguration]?

        public init(nextToken: String? = nil, retentionConfigurations: [RetentionConfiguration]? = nil) {
            self.nextToken = nextToken
            self.retentionConfigurations = retentionConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case retentionConfigurations = "RetentionConfigurations"
        }
    }

    public struct Evaluation: AWSEncodableShape & AWSDecodableShape {
        /// Supplementary information about how the evaluation determined the compliance.
        public let annotation: String?
        /// The ID of the AWS resource that was evaluated.
        public let complianceResourceId: String
        /// The type of AWS resource that was evaluated.
        public let complianceResourceType: String
        /// Indicates whether the AWS resource complies with the AWS Config rule that it was evaluated against. For the Evaluation data type, AWS Config supports only the COMPLIANT, NON_COMPLIANT, and NOT_APPLICABLE values. AWS Config does not support the INSUFFICIENT_DATA value for this data type. Similarly, AWS Config does not accept INSUFFICIENT_DATA as the value for ComplianceType from a PutEvaluations request. For example, an AWS Lambda function for a custom AWS Config rule cannot pass an INSUFFICIENT_DATA value to AWS Config.
        public let complianceType: ComplianceType
        /// The time of the event in AWS Config that triggered the evaluation. For event-based evaluations, the time indicates when AWS Config created the configuration item that triggered the evaluation. For periodic evaluations, the time indicates when AWS Config triggered the evaluation at the frequency that you specified (for example, every 24 hours).
        public let orderingTimestamp: Date

        public init(annotation: String? = nil, complianceResourceId: String, complianceResourceType: String, complianceType: ComplianceType, orderingTimestamp: Date) {
            self.annotation = annotation
            self.complianceResourceId = complianceResourceId
            self.complianceResourceType = complianceResourceType
            self.complianceType = complianceType
            self.orderingTimestamp = orderingTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.annotation, name: "annotation", parent: name, max: 256)
            try self.validate(self.annotation, name: "annotation", parent: name, min: 1)
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, max: 768)
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, min: 1)
            try self.validate(self.complianceResourceType, name: "complianceResourceType", parent: name, max: 256)
            try self.validate(self.complianceResourceType, name: "complianceResourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case annotation = "Annotation"
            case complianceResourceId = "ComplianceResourceId"
            case complianceResourceType = "ComplianceResourceType"
            case complianceType = "ComplianceType"
            case orderingTimestamp = "OrderingTimestamp"
        }
    }

    public struct EvaluationResult: AWSDecodableShape {
        /// Supplementary information about how the evaluation determined the compliance.
        public let annotation: String?
        /// Indicates whether the AWS resource complies with the AWS Config rule that evaluated it. For the EvaluationResult data type, AWS Config supports only the COMPLIANT, NON_COMPLIANT, and NOT_APPLICABLE values. AWS Config does not support the INSUFFICIENT_DATA value for the EvaluationResult data type.
        public let complianceType: ComplianceType?
        /// The time when the AWS Config rule evaluated the AWS resource.
        public let configRuleInvokedTime: Date?
        /// Uniquely identifies the evaluation result.
        public let evaluationResultIdentifier: EvaluationResultIdentifier?
        /// The time when AWS Config recorded the evaluation result.
        public let resultRecordedTime: Date?
        /// An encrypted token that associates an evaluation with an AWS Config rule. The token identifies the rule, the AWS resource being evaluated, and the event that triggered the evaluation.
        public let resultToken: String?

        public init(annotation: String? = nil, complianceType: ComplianceType? = nil, configRuleInvokedTime: Date? = nil, evaluationResultIdentifier: EvaluationResultIdentifier? = nil, resultRecordedTime: Date? = nil, resultToken: String? = nil) {
            self.annotation = annotation
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
            self.resultToken = resultToken
        }

        private enum CodingKeys: String, CodingKey {
            case annotation = "Annotation"
            case complianceType = "ComplianceType"
            case configRuleInvokedTime = "ConfigRuleInvokedTime"
            case evaluationResultIdentifier = "EvaluationResultIdentifier"
            case resultRecordedTime = "ResultRecordedTime"
            case resultToken = "ResultToken"
        }
    }

    public struct EvaluationResultIdentifier: AWSDecodableShape {
        /// Identifies an AWS Config rule used to evaluate an AWS resource, and provides the type and ID of the evaluated resource.
        public let evaluationResultQualifier: EvaluationResultQualifier?
        /// The time of the event that triggered the evaluation of your AWS resources. The time can indicate when AWS Config delivered a configuration item change notification, or it can indicate when AWS Config delivered the configuration snapshot, depending on which event triggered the evaluation.
        public let orderingTimestamp: Date?

        public init(evaluationResultQualifier: EvaluationResultQualifier? = nil, orderingTimestamp: Date? = nil) {
            self.evaluationResultQualifier = evaluationResultQualifier
            self.orderingTimestamp = orderingTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationResultQualifier = "EvaluationResultQualifier"
            case orderingTimestamp = "OrderingTimestamp"
        }
    }

    public struct EvaluationResultQualifier: AWSDecodableShape {
        /// The name of the AWS Config rule that was used in the evaluation.
        public let configRuleName: String?
        /// The ID of the evaluated AWS resource.
        public let resourceId: String?
        /// The type of AWS resource that was evaluated.
        public let resourceType: String?

        public init(configRuleName: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.configRuleName = configRuleName
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ExecutionControls: AWSEncodableShape & AWSDecodableShape {
        /// A SsmControls object.
        public let ssmControls: SsmControls?

        public init(ssmControls: SsmControls? = nil) {
            self.ssmControls = ssmControls
        }

        public func validate(name: String) throws {
            try self.ssmControls?.validate(name: "\(name).ssmControls")
        }

        private enum CodingKeys: String, CodingKey {
            case ssmControls = "SsmControls"
        }
    }

    public struct ExternalEvaluation: AWSEncodableShape {
        /// Supplementary information about the reason of compliance. For example, this task was completed on a specific date.
        public let annotation: String?
        /// The evaluated compliance resource ID. AWS Config accepts only AWS account ID.
        public let complianceResourceId: String
        /// The evaluated compliance resource type. AWS Config accepts AWS::::Account resource type.
        public let complianceResourceType: String
        /// The compliance of the AWS resource. The valid values are COMPLIANT, NON_COMPLIANT,  and NOT_APPLICABLE.
        public let complianceType: ComplianceType
        /// The time when the compliance was recorded.
        public let orderingTimestamp: Date

        public init(annotation: String? = nil, complianceResourceId: String, complianceResourceType: String, complianceType: ComplianceType, orderingTimestamp: Date) {
            self.annotation = annotation
            self.complianceResourceId = complianceResourceId
            self.complianceResourceType = complianceResourceType
            self.complianceType = complianceType
            self.orderingTimestamp = orderingTimestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.annotation, name: "annotation", parent: name, max: 256)
            try self.validate(self.annotation, name: "annotation", parent: name, min: 1)
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, max: 768)
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, min: 1)
            try self.validate(self.complianceResourceType, name: "complianceResourceType", parent: name, max: 256)
            try self.validate(self.complianceResourceType, name: "complianceResourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case annotation = "Annotation"
            case complianceResourceId = "ComplianceResourceId"
            case complianceResourceType = "ComplianceResourceType"
            case complianceType = "ComplianceType"
            case orderingTimestamp = "OrderingTimestamp"
        }
    }

    public struct FailedDeleteRemediationExceptionsBatch: AWSDecodableShape {
        /// Returns remediation exception resource key object of the failed items.
        public let failedItems: [RemediationExceptionResourceKey]?
        /// Returns a failure message for delete remediation exception. For example, AWS Config creates an exception due to an internal error.
        public let failureMessage: String?

        public init(failedItems: [RemediationExceptionResourceKey]? = nil, failureMessage: String? = nil) {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }

        private enum CodingKeys: String, CodingKey {
            case failedItems = "FailedItems"
            case failureMessage = "FailureMessage"
        }
    }

    public struct FailedRemediationBatch: AWSDecodableShape {
        /// Returns remediation configurations of the failed items.
        public let failedItems: [RemediationConfiguration]?
        /// Returns a failure message. For example, the resource is already compliant.
        public let failureMessage: String?

        public init(failedItems: [RemediationConfiguration]? = nil, failureMessage: String? = nil) {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }

        private enum CodingKeys: String, CodingKey {
            case failedItems = "FailedItems"
            case failureMessage = "FailureMessage"
        }
    }

    public struct FailedRemediationExceptionBatch: AWSDecodableShape {
        /// Returns remediation exception resource key object of the failed items.
        public let failedItems: [RemediationException]?
        /// Returns a failure message. For example, the auto-remediation has failed.
        public let failureMessage: String?

        public init(failedItems: [RemediationException]? = nil, failureMessage: String? = nil) {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }

        private enum CodingKeys: String, CodingKey {
            case failedItems = "FailedItems"
            case failureMessage = "FailureMessage"
        }
    }

    public struct FieldInfo: AWSDecodableShape {
        /// Name of the field.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetAggregateComplianceDetailsByConfigRuleRequest: AWSEncodableShape {
        /// The 12-digit account ID of the source account.
        public let accountId: String
        /// The source region from where the data is aggregated.
        public let awsRegion: String
        /// The resource compliance status.  For the GetAggregateComplianceDetailsByConfigRuleRequest data type, AWS Config supports only the COMPLIANT and NON_COMPLIANT. AWS Config does not support the NOT_APPLICABLE and INSUFFICIENT_DATA values.
        public let complianceType: ComplianceType?
        /// The name of the AWS Config rule for which you want compliance information.
        public let configRuleName: String
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// The maximum number of evaluation results returned on each page. The default is 50. You cannot specify a number greater than 100. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(accountId: String, awsRegion: String, complianceType: ComplianceType? = nil, configRuleName: String, configurationAggregatorName: String, limit: Int? = nil, nextToken: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.configRuleName = configRuleName
            self.configurationAggregatorName = configurationAggregatorName
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\d{12}")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 64)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case complianceType = "ComplianceType"
            case configRuleName = "ConfigRuleName"
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateComplianceDetailsByConfigRuleResponse: AWSDecodableShape {
        /// Returns an AggregateEvaluationResults object.
        public let aggregateEvaluationResults: [AggregateEvaluationResult]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(aggregateEvaluationResults: [AggregateEvaluationResult]? = nil, nextToken: String? = nil) {
            self.aggregateEvaluationResults = aggregateEvaluationResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateEvaluationResults = "AggregateEvaluationResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateConfigRuleComplianceSummaryRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the results based on the ConfigRuleComplianceSummaryFilters object.
        public let filters: ConfigRuleComplianceSummaryFilters?
        /// Groups the result based on ACCOUNT_ID or AWS_REGION.
        public let groupByKey: ConfigRuleComplianceSummaryGroupKey?
        /// The maximum number of evaluation results returned on each page. The default is 1000. You cannot specify a number greater than 1000. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configurationAggregatorName: String, filters: ConfigRuleComplianceSummaryFilters? = nil, groupByKey: ConfigRuleComplianceSummaryGroupKey? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.groupByKey = groupByKey
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 1000)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case groupByKey = "GroupByKey"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateConfigRuleComplianceSummaryResponse: AWSDecodableShape {
        /// Returns a list of AggregateComplianceCounts object.
        public let aggregateComplianceCounts: [AggregateComplianceCount]?
        /// Groups the result based on ACCOUNT_ID or AWS_REGION.
        public let groupByKey: String?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(aggregateComplianceCounts: [AggregateComplianceCount]? = nil, groupByKey: String? = nil, nextToken: String? = nil) {
            self.aggregateComplianceCounts = aggregateComplianceCounts
            self.groupByKey = groupByKey
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateComplianceCounts = "AggregateComplianceCounts"
            case groupByKey = "GroupByKey"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateConformancePackComplianceSummaryRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the results based on the AggregateConformancePackComplianceSummaryFilters object.
        public let filters: AggregateConformancePackComplianceSummaryFilters?
        /// Groups the result based on AWS Account ID or AWS Region.
        public let groupByKey: AggregateConformancePackComplianceSummaryGroupKey?
        /// The maximum number of results returned on each page. The default is maximum. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configurationAggregatorName: String, filters: AggregateConformancePackComplianceSummaryFilters? = nil, groupByKey: AggregateConformancePackComplianceSummaryGroupKey? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.groupByKey = groupByKey
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case groupByKey = "GroupByKey"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateConformancePackComplianceSummaryResponse: AWSDecodableShape {
        /// Returns a list of AggregateConformancePackComplianceSummary object.
        public let aggregateConformancePackComplianceSummaries: [AggregateConformancePackComplianceSummary]?
        /// Groups the result based on AWS Account ID or AWS Region.
        public let groupByKey: String?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(aggregateConformancePackComplianceSummaries: [AggregateConformancePackComplianceSummary]? = nil, groupByKey: String? = nil, nextToken: String? = nil) {
            self.aggregateConformancePackComplianceSummaries = aggregateConformancePackComplianceSummaries
            self.groupByKey = groupByKey
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateConformancePackComplianceSummaries = "AggregateConformancePackComplianceSummaries"
            case groupByKey = "GroupByKey"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateDiscoveredResourceCountsRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the results based on the ResourceCountFilters object.
        public let filters: ResourceCountFilters?
        /// The key to group the resource counts.
        public let groupByKey: ResourceCountGroupKey?
        /// The maximum number of GroupedResourceCount objects returned on each page. The default is 1000. You cannot specify a number greater than 1000. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configurationAggregatorName: String, filters: ResourceCountFilters? = nil, groupByKey: ResourceCountGroupKey? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.groupByKey = groupByKey
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 1000)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case groupByKey = "GroupByKey"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetAggregateDiscoveredResourceCountsResponse: AWSDecodableShape {
        /// The key passed into the request object. If GroupByKey is not provided, the result will be empty.
        public let groupByKey: String?
        /// Returns a list of GroupedResourceCount objects.
        public let groupedResourceCounts: [GroupedResourceCount]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The total number of resources that are present in an aggregator with the filters that you provide.
        public let totalDiscoveredResources: Int64

        public init(groupByKey: String? = nil, groupedResourceCounts: [GroupedResourceCount]? = nil, nextToken: String? = nil, totalDiscoveredResources: Int64) {
            self.groupByKey = groupByKey
            self.groupedResourceCounts = groupedResourceCounts
            self.nextToken = nextToken
            self.totalDiscoveredResources = totalDiscoveredResources
        }

        private enum CodingKeys: String, CodingKey {
            case groupByKey = "GroupByKey"
            case groupedResourceCounts = "GroupedResourceCounts"
            case nextToken = "NextToken"
            case totalDiscoveredResources = "TotalDiscoveredResources"
        }
    }

    public struct GetAggregateResourceConfigRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// An object that identifies aggregate resource.
        public let resourceIdentifier: AggregateResourceIdentifier

        public init(configurationAggregatorName: String, resourceIdentifier: AggregateResourceIdentifier) {
            self.configurationAggregatorName = configurationAggregatorName
            self.resourceIdentifier = resourceIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.resourceIdentifier.validate(name: "\(name).resourceIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case resourceIdentifier = "ResourceIdentifier"
        }
    }

    public struct GetAggregateResourceConfigResponse: AWSDecodableShape {
        /// Returns a ConfigurationItem object.
        public let configurationItem: ConfigurationItem?

        public init(configurationItem: ConfigurationItem? = nil) {
            self.configurationItem = configurationItem
        }

        private enum CodingKeys: String, CodingKey {
            case configurationItem = "ConfigurationItem"
        }
    }

    public struct GetComplianceDetailsByConfigRuleRequest: AWSEncodableShape {
        /// Filters the results by compliance. The allowed values are COMPLIANT, NON_COMPLIANT, and NOT_APPLICABLE.
        public let complianceTypes: [ComplianceType]?
        /// The name of the AWS Config rule for which you want compliance information.
        public let configRuleName: String
        /// The maximum number of evaluation results returned on each page. The default is 10. You cannot specify a number greater than 100. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(complianceTypes: [ComplianceType]? = nil, configRuleName: String, limit: Int? = nil, nextToken: String? = nil) {
            self.complianceTypes = complianceTypes
            self.configRuleName = configRuleName
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, max: 3)
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, min: 0)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 64)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceTypes = "ComplianceTypes"
            case configRuleName = "ConfigRuleName"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetComplianceDetailsByConfigRuleResponse: AWSDecodableShape {
        /// Indicates whether the AWS resource complies with the specified AWS Config rule.
        public let evaluationResults: [EvaluationResult]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(evaluationResults: [EvaluationResult]? = nil, nextToken: String? = nil) {
            self.evaluationResults = evaluationResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationResults = "EvaluationResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetComplianceDetailsByResourceRequest: AWSEncodableShape {
        /// Filters the results by compliance. The allowed values are COMPLIANT, NON_COMPLIANT, and NOT_APPLICABLE.
        public let complianceTypes: [ComplianceType]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The ID of the AWS resource for which you want compliance information.
        public let resourceId: String
        /// The type of the AWS resource for which you want compliance information.
        public let resourceType: String

        public init(complianceTypes: [ComplianceType]? = nil, nextToken: String? = nil, resourceId: String, resourceType: String) {
            self.complianceTypes = complianceTypes
            self.nextToken = nextToken
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, max: 3)
            try self.validate(self.complianceTypes, name: "complianceTypes", parent: name, min: 0)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceTypes = "ComplianceTypes"
            case nextToken = "NextToken"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct GetComplianceDetailsByResourceResponse: AWSDecodableShape {
        /// Indicates whether the specified AWS resource complies each AWS Config rule.
        public let evaluationResults: [EvaluationResult]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(evaluationResults: [EvaluationResult]? = nil, nextToken: String? = nil) {
            self.evaluationResults = evaluationResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationResults = "EvaluationResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetComplianceSummaryByConfigRuleResponse: AWSDecodableShape {
        /// The number of AWS Config rules that are compliant and the number that are noncompliant, up to a maximum of 25 for each.
        public let complianceSummary: ComplianceSummary?

        public init(complianceSummary: ComplianceSummary? = nil) {
            self.complianceSummary = complianceSummary
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummary = "ComplianceSummary"
        }
    }

    public struct GetComplianceSummaryByResourceTypeRequest: AWSEncodableShape {
        /// Specify one or more resource types to get the number of resources that are compliant and the number that are noncompliant for each resource type. For this request, you can specify an AWS resource type such as AWS::EC2::Instance. You can specify that the resource type is an AWS account by specifying AWS::::Account.
        public let resourceTypes: [String]?

        public init(resourceTypes: [String]? = nil) {
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.resourceTypes?.forEach {
                try validate($0, name: "resourceTypes[]", parent: name, max: 256)
                try validate($0, name: "resourceTypes[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 20)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTypes = "ResourceTypes"
        }
    }

    public struct GetComplianceSummaryByResourceTypeResponse: AWSDecodableShape {
        /// The number of resources that are compliant and the number that are noncompliant. If one or more resource types were provided with the request, the numbers are returned for each resource type. The maximum number returned is 100.
        public let complianceSummariesByResourceType: [ComplianceSummaryByResourceType]?

        public init(complianceSummariesByResourceType: [ComplianceSummaryByResourceType]? = nil) {
            self.complianceSummariesByResourceType = complianceSummariesByResourceType
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummariesByResourceType = "ComplianceSummariesByResourceType"
        }
    }

    public struct GetConformancePackComplianceDetailsRequest: AWSEncodableShape {
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// A ConformancePackEvaluationFilters object.
        public let filters: ConformancePackEvaluationFilters?
        /// The maximum number of evaluation results returned on each page. If you do no specify a number, AWS Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        public init(conformancePackName: String, filters: ConformancePackEvaluationFilters? = nil, limit: Int? = nil, nextToken: String? = nil) {
            self.conformancePackName = conformancePackName
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, max: 256)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackName = "ConformancePackName"
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetConformancePackComplianceDetailsResponse: AWSDecodableShape {
        /// Name of the conformance pack.
        public let conformancePackName: String
        /// Returns a list of ConformancePackEvaluationResult objects.
        public let conformancePackRuleEvaluationResults: [ConformancePackEvaluationResult]?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        public init(conformancePackName: String, conformancePackRuleEvaluationResults: [ConformancePackEvaluationResult]? = nil, nextToken: String? = nil) {
            self.conformancePackName = conformancePackName
            self.conformancePackRuleEvaluationResults = conformancePackRuleEvaluationResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackName = "ConformancePackName"
            case conformancePackRuleEvaluationResults = "ConformancePackRuleEvaluationResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetConformancePackComplianceSummaryRequest: AWSEncodableShape {
        /// Names of conformance packs.
        public let conformancePackNames: [String]
        /// The maximum number of conformance packs returned on each page.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(conformancePackNames: [String], limit: Int? = nil, nextToken: String? = nil) {
            self.conformancePackNames = conformancePackNames
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.conformancePackNames.forEach {
                try validate($0, name: "conformancePackNames[]", parent: name, max: 256)
                try validate($0, name: "conformancePackNames[]", parent: name, min: 1)
                try validate($0, name: "conformancePackNames[]", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
            }
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, max: 5)
            try self.validate(self.conformancePackNames, name: "conformancePackNames", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 20)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackNames = "ConformancePackNames"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct GetConformancePackComplianceSummaryResponse: AWSDecodableShape {
        /// A list of ConformancePackComplianceSummary objects.
        public let conformancePackComplianceSummaryList: [ConformancePackComplianceSummary]?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(conformancePackComplianceSummaryList: [ConformancePackComplianceSummary]? = nil, nextToken: String? = nil) {
            self.conformancePackComplianceSummaryList = conformancePackComplianceSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackComplianceSummaryList = "ConformancePackComplianceSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct GetDiscoveredResourceCountsRequest: AWSEncodableShape {
        /// The maximum number of ResourceCount objects returned on each page. The default is 100. You cannot specify a number greater than 100. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The comma-separated list that specifies the resource types that you want AWS Config to return (for example, "AWS::EC2::Instance", "AWS::IAM::User"). If a value for resourceTypes is not specified, AWS Config returns all resource types that AWS Config is recording in the region for your account.  If the configuration recorder is turned off, AWS Config returns an empty list of ResourceCount objects. If the configuration recorder is not recording a specific resource type (for example, S3 buckets), that resource type is not returned in the list of ResourceCount objects.
        public let resourceTypes: [String]?

        public init(limit: Int? = nil, nextToken: String? = nil, resourceTypes: [String]? = nil) {
            self.limit = limit
            self.nextToken = nextToken
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.resourceTypes?.forEach {
                try validate($0, name: "resourceTypes[]", parent: name, max: 256)
                try validate($0, name: "resourceTypes[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 20)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case limit
            case nextToken
            case resourceTypes
        }
    }

    public struct GetDiscoveredResourceCountsResponse: AWSDecodableShape {
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The list of ResourceCount objects. Each object is listed in descending order by the number of resources.
        public let resourceCounts: [ResourceCount]?
        /// The total number of resources that AWS Config is recording in the region for your account. If you specify resource types in the request, AWS Config returns only the total number of resources for those resource types.  Example    AWS Config is recording three resource types in the US East (Ohio) Region for your account: 25 EC2 instances, 20 IAM users, and 15 S3 buckets, for a total of 60 resources.   You make a call to the GetDiscoveredResourceCounts action and specify the resource type, "AWS::EC2::Instances", in the request.   AWS Config returns 25 for totalDiscoveredResources.
        public let totalDiscoveredResources: Int64?

        public init(nextToken: String? = nil, resourceCounts: [ResourceCount]? = nil, totalDiscoveredResources: Int64? = nil) {
            self.nextToken = nextToken
            self.resourceCounts = resourceCounts
            self.totalDiscoveredResources = totalDiscoveredResources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case resourceCounts
            case totalDiscoveredResources
        }
    }

    public struct GetOrganizationConfigRuleDetailedStatusRequest: AWSEncodableShape {
        /// A StatusDetailFilters object.
        public let filters: StatusDetailFilters?
        /// The maximum number of OrganizationConfigRuleDetailedStatus returned on each page. If you do not specify a number, AWS Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The name of organization config rule for which you want status details for member accounts.
        public let organizationConfigRuleName: String

        public init(filters: StatusDetailFilters? = nil, limit: Int? = nil, nextToken: String? = nil, organizationConfigRuleName: String) {
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConfigRuleName = organizationConfigRuleName
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, max: 64)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, min: 1)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConfigRuleName = "OrganizationConfigRuleName"
        }
    }

    public struct GetOrganizationConfigRuleDetailedStatusResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of MemberAccountStatus objects.
        public let organizationConfigRuleDetailedStatus: [MemberAccountStatus]?

        public init(nextToken: String? = nil, organizationConfigRuleDetailedStatus: [MemberAccountStatus]? = nil) {
            self.nextToken = nextToken
            self.organizationConfigRuleDetailedStatus = organizationConfigRuleDetailedStatus
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConfigRuleDetailedStatus = "OrganizationConfigRuleDetailedStatus"
        }
    }

    public struct GetOrganizationConformancePackDetailedStatusRequest: AWSEncodableShape {
        /// An OrganizationResourceDetailedStatusFilters object.
        public let filters: OrganizationResourceDetailedStatusFilters?
        /// The maximum number of OrganizationConformancePackDetailedStatuses returned on each page. If you do not specify a number, AWS Config uses the default. The default is 100.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The name of organization conformance pack for which you want status details for member accounts.
        public let organizationConformancePackName: String

        public init(filters: OrganizationResourceDetailedStatusFilters? = nil, limit: Int? = nil, nextToken: String? = nil, organizationConformancePackName: String) {
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
            self.organizationConformancePackName = organizationConformancePackName
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, max: 128)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, min: 1)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
            case organizationConformancePackName = "OrganizationConformancePackName"
        }
    }

    public struct GetOrganizationConformancePackDetailedStatusResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of OrganizationConformancePackDetailedStatus objects.
        public let organizationConformancePackDetailedStatuses: [OrganizationConformancePackDetailedStatus]?

        public init(nextToken: String? = nil, organizationConformancePackDetailedStatuses: [OrganizationConformancePackDetailedStatus]? = nil) {
            self.nextToken = nextToken
            self.organizationConformancePackDetailedStatuses = organizationConformancePackDetailedStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationConformancePackDetailedStatuses = "OrganizationConformancePackDetailedStatuses"
        }
    }

    public struct GetResourceConfigHistoryRequest: AWSEncodableShape {
        /// The chronological order for configuration items listed. By default, the results are listed in reverse chronological order.
        public let chronologicalOrder: ChronologicalOrder?
        /// The time stamp that indicates an earlier time. If not specified, the action returns paginated results that contain configuration items that start when the first configuration item was recorded.
        public let earlierTime: Date?
        /// The time stamp that indicates a later time. If not specified, current time is taken.
        public let laterTime: Date?
        /// The maximum number of configuration items returned on each page. The default is 10. You cannot specify a number greater than 100. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The ID of the resource (for example., sg-xxxxxx).
        public let resourceId: String
        /// The resource type.
        public let resourceType: ResourceType

        public init(chronologicalOrder: ChronologicalOrder? = nil, earlierTime: Date? = nil, laterTime: Date? = nil, limit: Int? = nil, nextToken: String? = nil, resourceId: String, resourceType: ResourceType) {
            self.chronologicalOrder = chronologicalOrder
            self.earlierTime = earlierTime
            self.laterTime = laterTime
            self.limit = limit
            self.nextToken = nextToken
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case chronologicalOrder
            case earlierTime
            case laterTime
            case limit
            case nextToken
            case resourceId
            case resourceType
        }
    }

    public struct GetResourceConfigHistoryResponse: AWSDecodableShape {
        /// A list that contains the configuration history of one or more resources.
        public let configurationItems: [ConfigurationItem]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(configurationItems: [ConfigurationItem]? = nil, nextToken: String? = nil) {
            self.configurationItems = configurationItems
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurationItems
            case nextToken
        }
    }

    public struct GetStoredQueryRequest: AWSEncodableShape {
        /// The name of the query.
        public let queryName: String

        public init(queryName: String) {
            self.queryName = queryName
        }

        public func validate(name: String) throws {
            try self.validate(self.queryName, name: "queryName", parent: name, max: 64)
            try self.validate(self.queryName, name: "queryName", parent: name, min: 1)
            try self.validate(self.queryName, name: "queryName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case queryName = "QueryName"
        }
    }

    public struct GetStoredQueryResponse: AWSDecodableShape {
        /// Returns a StoredQuery object.
        public let storedQuery: StoredQuery?

        public init(storedQuery: StoredQuery? = nil) {
            self.storedQuery = storedQuery
        }

        private enum CodingKeys: String, CodingKey {
            case storedQuery = "StoredQuery"
        }
    }

    public struct GroupedResourceCount: AWSDecodableShape {
        /// The name of the group that can be region, account ID, or resource type. For example, region1, region2 if the region was chosen as GroupByKey.
        public let groupName: String
        /// The number of resources in the group.
        public let resourceCount: Int64

        public init(groupName: String, resourceCount: Int64) {
            self.groupName = groupName
            self.resourceCount = resourceCount
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "GroupName"
            case resourceCount = "ResourceCount"
        }
    }

    public struct ListAggregateDiscoveredResourcesRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// Filters the results based on the ResourceFilters object.
        public let filters: ResourceFilters?
        /// The maximum number of resource identifiers returned on each page. You cannot specify a number greater than 100. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The type of resources that you want AWS Config to list in the response.
        public let resourceType: ResourceType

        public init(configurationAggregatorName: String, filters: ResourceFilters? = nil, limit: Int? = nil, nextToken: String? = nil, resourceType: ResourceType) {
            self.configurationAggregatorName = configurationAggregatorName
            self.filters = filters
            self.limit = limit
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case filters = "Filters"
            case limit = "Limit"
            case nextToken = "NextToken"
            case resourceType = "ResourceType"
        }
    }

    public struct ListAggregateDiscoveredResourcesResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns a list of ResourceIdentifiers objects.
        public let resourceIdentifiers: [AggregateResourceIdentifier]?

        public init(nextToken: String? = nil, resourceIdentifiers: [AggregateResourceIdentifier]? = nil) {
            self.nextToken = nextToken
            self.resourceIdentifiers = resourceIdentifiers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourceIdentifiers = "ResourceIdentifiers"
        }
    }

    public struct ListDiscoveredResourcesRequest: AWSEncodableShape {
        /// Specifies whether AWS Config includes deleted resources in the results. By default, deleted resources are not included.
        public let includeDeletedResources: Bool?
        /// The maximum number of resource identifiers returned on each page. The default is 100. You cannot specify a number greater than 100. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The IDs of only those resources that you want AWS Config to list in the response. If you do not specify this parameter, AWS Config lists all resources of the specified type that it has discovered.
        public let resourceIds: [String]?
        /// The custom name of only those resources that you want AWS Config to list in the response. If you do not specify this parameter, AWS Config lists all resources of the specified type that it has discovered.
        public let resourceName: String?
        /// The type of resources that you want AWS Config to list in the response.
        public let resourceType: ResourceType

        public init(includeDeletedResources: Bool? = nil, limit: Int? = nil, nextToken: String? = nil, resourceIds: [String]? = nil, resourceName: String? = nil, resourceType: ResourceType) {
            self.includeDeletedResources = includeDeletedResources
            self.limit = limit
            self.nextToken = nextToken
            self.resourceIds = resourceIds
            self.resourceName = resourceName
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.resourceIds?.forEach {
                try validate($0, name: "resourceIds[]", parent: name, max: 768)
                try validate($0, name: "resourceIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case includeDeletedResources
            case limit
            case nextToken
            case resourceIds
            case resourceName
            case resourceType
        }
    }

    public struct ListDiscoveredResourcesResponse: AWSDecodableShape {
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The details that identify a resource that is discovered by AWS Config, including the resource type, ID, and (if available) the custom resource name.
        public let resourceIdentifiers: [ResourceIdentifier]?

        public init(nextToken: String? = nil, resourceIdentifiers: [ResourceIdentifier]? = nil) {
            self.nextToken = nextToken
            self.resourceIdentifiers = resourceIdentifiers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case resourceIdentifiers
        }
    }

    public struct ListStoredQueriesRequest: AWSEncodableShape {
        /// The maximum number of results to be returned with a single call.
        public let maxResults: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListStoredQueriesResponse: AWSDecodableShape {
        /// If the previous paginated request didn't return all of the remaining results, the response object's NextToken parameter value is set to a token. To retrieve the next set of results, call this action again and assign that token to the request object's NextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// A list of StoredQueryMetadata objects.
        public let storedQueryMetadata: [StoredQueryMetadata]?

        public init(nextToken: String? = nil, storedQueryMetadata: [StoredQueryMetadata]? = nil) {
            self.nextToken = nextToken
            self.storedQueryMetadata = storedQueryMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case storedQueryMetadata = "StoredQueryMetadata"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The maximum number of tags returned on each page. The limit maximum is 50. You cannot specify a number greater than 50. If you specify 0, AWS Config uses the default.
        public let limit: Int?
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are ConfigRule, ConfigurationAggregator and AggregatorAuthorization.
        public let resourceArn: String

        public init(limit: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.limit = limit
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextToken = "NextToken"
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
        public let nextToken: String?
        /// The tags for the resource.
        public let tags: [Tag]?

        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct MemberAccountStatus: AWSDecodableShape {
        /// The 12-digit account ID of a member account.
        public let accountId: String
        /// The name of config rule deployed in the member account.
        public let configRuleName: String
        /// An error code that is returned when config rule creation or deletion failed in the member account.
        public let errorCode: String?
        /// An error message indicating that config rule account creation or deletion has failed due to an error in the member account.
        public let errorMessage: String?
        /// The timestamp of the last status update.
        public let lastUpdateTime: Date?
        /// Indicates deployment status for config rule in the member account. When master account calls PutOrganizationConfigRule action for the first time, config rule status is created in the member account. When master account calls PutOrganizationConfigRule action for the second time, config rule status is updated in the member account. Config rule status is deleted when the master account deletes OrganizationConfigRule and disables service access for config-multiaccountsetup.amazonaws.com.   AWS Config sets the state of the rule to:    CREATE_SUCCESSFUL when config rule has been created in the member account.     CREATE_IN_PROGRESS when config rule is being created in the member account.    CREATE_FAILED when config rule creation has failed in the member account.    DELETE_FAILED when config rule deletion has failed in the member account.    DELETE_IN_PROGRESS when config rule is being deleted in the member account.    DELETE_SUCCESSFUL when config rule has been deleted in the member account.     UPDATE_SUCCESSFUL when config rule has been updated in the member account.    UPDATE_IN_PROGRESS when config rule is being updated in the member account.    UPDATE_FAILED when config rule deletion has failed in the member account.
        public let memberAccountRuleStatus: MemberAccountRuleStatus

        public init(accountId: String, configRuleName: String, errorCode: String? = nil, errorMessage: String? = nil, lastUpdateTime: Date? = nil, memberAccountRuleStatus: MemberAccountRuleStatus) {
            self.accountId = accountId
            self.configRuleName = configRuleName
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.memberAccountRuleStatus = memberAccountRuleStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case configRuleName = "ConfigRuleName"
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case lastUpdateTime = "LastUpdateTime"
            case memberAccountRuleStatus = "MemberAccountRuleStatus"
        }
    }

    public struct OrganizationAggregationSource: AWSEncodableShape & AWSDecodableShape {
        /// If true, aggregate existing AWS Config regions and future regions.
        public let allAwsRegions: Bool?
        /// The source regions being aggregated.
        public let awsRegions: [String]?
        /// ARN of the IAM role used to retrieve AWS Organization details associated with the aggregator account.
        public let roleArn: String

        public init(allAwsRegions: Bool? = nil, awsRegions: [String]? = nil, roleArn: String) {
            self.allAwsRegions = allAwsRegions
            self.awsRegions = awsRegions
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.awsRegions, name: "awsRegions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allAwsRegions = "AllAwsRegions"
            case awsRegions = "AwsRegions"
            case roleArn = "RoleArn"
        }
    }

    public struct OrganizationConfigRule: AWSDecodableShape {
        /// A comma-separated list of accounts excluded from organization config rule.
        public let excludedAccounts: [String]?
        /// The timestamp of the last update.
        public let lastUpdateTime: Date?
        /// Amazon Resource Name (ARN) of organization config rule.
        public let organizationConfigRuleArn: String
        /// The name that you assign to organization config rule.
        public let organizationConfigRuleName: String
        /// An OrganizationCustomRuleMetadata object.
        public let organizationCustomRuleMetadata: OrganizationCustomRuleMetadata?
        /// An OrganizationManagedRuleMetadata object.
        public let organizationManagedRuleMetadata: OrganizationManagedRuleMetadata?

        public init(excludedAccounts: [String]? = nil, lastUpdateTime: Date? = nil, organizationConfigRuleArn: String, organizationConfigRuleName: String, organizationCustomRuleMetadata: OrganizationCustomRuleMetadata? = nil, organizationManagedRuleMetadata: OrganizationManagedRuleMetadata? = nil) {
            self.excludedAccounts = excludedAccounts
            self.lastUpdateTime = lastUpdateTime
            self.organizationConfigRuleArn = organizationConfigRuleArn
            self.organizationConfigRuleName = organizationConfigRuleName
            self.organizationCustomRuleMetadata = organizationCustomRuleMetadata
            self.organizationManagedRuleMetadata = organizationManagedRuleMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case excludedAccounts = "ExcludedAccounts"
            case lastUpdateTime = "LastUpdateTime"
            case organizationConfigRuleArn = "OrganizationConfigRuleArn"
            case organizationConfigRuleName = "OrganizationConfigRuleName"
            case organizationCustomRuleMetadata = "OrganizationCustomRuleMetadata"
            case organizationManagedRuleMetadata = "OrganizationManagedRuleMetadata"
        }
    }

    public struct OrganizationConfigRuleStatus: AWSDecodableShape {
        /// An error code that is returned when organization config rule creation or deletion has failed.
        public let errorCode: String?
        /// An error message indicating that organization config rule creation or deletion failed due to an error.
        public let errorMessage: String?
        /// The timestamp of the last update.
        public let lastUpdateTime: Date?
        /// The name that you assign to organization config rule.
        public let organizationConfigRuleName: String
        /// Indicates deployment status of an organization config rule. When master account calls PutOrganizationConfigRule action for the first time, config rule status is created in all the member accounts. When master account calls PutOrganizationConfigRule action for the second time, config rule status is updated in all the member accounts. Additionally, config rule status is updated when one or more member accounts join or leave an organization. Config rule status is deleted when the master account deletes OrganizationConfigRule in all the member accounts and disables service access for config-multiaccountsetup.amazonaws.com. AWS Config sets the state of the rule to:    CREATE_SUCCESSFUL when an organization config rule has been successfully created in all the member accounts.     CREATE_IN_PROGRESS when an organization config rule creation is in progress.    CREATE_FAILED when an organization config rule creation failed in one or more member accounts within that organization.    DELETE_FAILED when an organization config rule deletion failed in one or more member accounts within that organization.    DELETE_IN_PROGRESS when an organization config rule deletion is in progress.    DELETE_SUCCESSFUL when an organization config rule has been successfully deleted from all the member accounts.    UPDATE_SUCCESSFUL when an organization config rule has been successfully updated in all the member accounts.    UPDATE_IN_PROGRESS when an organization config rule update is in progress.    UPDATE_FAILED when an organization config rule update failed in one or more member accounts within that organization.
        public let organizationRuleStatus: OrganizationRuleStatus

        public init(errorCode: String? = nil, errorMessage: String? = nil, lastUpdateTime: Date? = nil, organizationConfigRuleName: String, organizationRuleStatus: OrganizationRuleStatus) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.organizationConfigRuleName = organizationConfigRuleName
            self.organizationRuleStatus = organizationRuleStatus
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case lastUpdateTime = "LastUpdateTime"
            case organizationConfigRuleName = "OrganizationConfigRuleName"
            case organizationRuleStatus = "OrganizationRuleStatus"
        }
    }

    public struct OrganizationConformancePack: AWSDecodableShape {
        /// A list of ConformancePackInputParameter objects.
        public let conformancePackInputParameters: [ConformancePackInputParameter]?
        /// Amazon S3 bucket where AWS Config stores conformance pack templates.   This field is optional.
        public let deliveryS3Bucket: String?
        /// Any folder structure you want to add to an Amazon S3 bucket.  This field is optional.
        public let deliveryS3KeyPrefix: String?
        /// A comma-separated list of accounts excluded from organization conformance pack.
        public let excludedAccounts: [String]?
        /// Last time when organization conformation pack was updated.
        public let lastUpdateTime: Date
        /// Amazon Resource Name (ARN) of organization conformance pack.
        public let organizationConformancePackArn: String
        /// The name you assign to an organization conformance pack.
        public let organizationConformancePackName: String

        public init(conformancePackInputParameters: [ConformancePackInputParameter]? = nil, deliveryS3Bucket: String? = nil, deliveryS3KeyPrefix: String? = nil, excludedAccounts: [String]? = nil, lastUpdateTime: Date, organizationConformancePackArn: String, organizationConformancePackName: String) {
            self.conformancePackInputParameters = conformancePackInputParameters
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.excludedAccounts = excludedAccounts
            self.lastUpdateTime = lastUpdateTime
            self.organizationConformancePackArn = organizationConformancePackArn
            self.organizationConformancePackName = organizationConformancePackName
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackInputParameters = "ConformancePackInputParameters"
            case deliveryS3Bucket = "DeliveryS3Bucket"
            case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
            case excludedAccounts = "ExcludedAccounts"
            case lastUpdateTime = "LastUpdateTime"
            case organizationConformancePackArn = "OrganizationConformancePackArn"
            case organizationConformancePackName = "OrganizationConformancePackName"
        }
    }

    public struct OrganizationConformancePackDetailedStatus: AWSDecodableShape {
        /// The 12-digit account ID of a member account.
        public let accountId: String
        /// The name of conformance pack deployed in the member account.
        public let conformancePackName: String
        /// An error code that is returned when conformance pack creation or deletion failed in the member account.
        public let errorCode: String?
        /// An error message indicating that conformance pack account creation or deletion has failed due to an error in the member account.
        public let errorMessage: String?
        /// The timestamp of the last status update.
        public let lastUpdateTime: Date?
        /// Indicates deployment status for conformance pack in a member account. When master account calls PutOrganizationConformancePack action for the first time, conformance pack status is created in the member account. When master account calls PutOrganizationConformancePack action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the master account deletes OrganizationConformancePack and disables service access for config-multiaccountsetup.amazonaws.com.   AWS Config sets the state of the conformance pack to:    CREATE_SUCCESSFUL when conformance pack has been created in the member account.     CREATE_IN_PROGRESS when conformance pack is being created in the member account.    CREATE_FAILED when conformance pack creation has failed in the member account.    DELETE_FAILED when conformance pack deletion has failed in the member account.    DELETE_IN_PROGRESS when conformance pack is being deleted in the member account.    DELETE_SUCCESSFUL when conformance pack has been deleted in the member account.     UPDATE_SUCCESSFUL when conformance pack has been updated in the member account.    UPDATE_IN_PROGRESS when conformance pack is being updated in the member account.    UPDATE_FAILED when conformance pack deletion has failed in the member account.
        public let status: OrganizationResourceDetailedStatus

        public init(accountId: String, conformancePackName: String, errorCode: String? = nil, errorMessage: String? = nil, lastUpdateTime: Date? = nil, status: OrganizationResourceDetailedStatus) {
            self.accountId = accountId
            self.conformancePackName = conformancePackName
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case conformancePackName = "ConformancePackName"
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case lastUpdateTime = "LastUpdateTime"
            case status = "Status"
        }
    }

    public struct OrganizationConformancePackStatus: AWSDecodableShape {
        /// An error code that is returned when organization conformance pack creation or deletion has failed in a member account.
        public let errorCode: String?
        /// An error message indicating that organization conformance pack creation or deletion failed due to an error.
        public let errorMessage: String?
        /// The timestamp of the last update.
        public let lastUpdateTime: Date?
        /// The name that you assign to organization conformance pack.
        public let organizationConformancePackName: String
        /// Indicates deployment status of an organization conformance pack. When master account calls PutOrganizationConformancePack for the first time, conformance pack status is created in all the member accounts. When master account calls PutOrganizationConformancePack for the second time, conformance pack status is updated in all the member accounts. Additionally, conformance pack status is updated when one or more member accounts join or leave an organization. Conformance pack status is deleted when the master account deletes OrganizationConformancePack in all the member accounts and disables service access for config-multiaccountsetup.amazonaws.com. AWS Config sets the state of the conformance pack to:    CREATE_SUCCESSFUL when an organization conformance pack has been successfully created in all the member accounts.     CREATE_IN_PROGRESS when an organization conformance pack creation is in progress.    CREATE_FAILED when an organization conformance pack creation failed in one or more member accounts within that organization.    DELETE_FAILED when an organization conformance pack deletion failed in one or more member accounts within that organization.    DELETE_IN_PROGRESS when an organization conformance pack deletion is in progress.    DELETE_SUCCESSFUL when an organization conformance pack has been successfully deleted from all the member accounts.    UPDATE_SUCCESSFUL when an organization conformance pack has been successfully updated in all the member accounts.    UPDATE_IN_PROGRESS when an organization conformance pack update is in progress.    UPDATE_FAILED when an organization conformance pack update failed in one or more member accounts within that organization.
        public let status: OrganizationResourceStatus

        public init(errorCode: String? = nil, errorMessage: String? = nil, lastUpdateTime: Date? = nil, organizationConformancePackName: String, status: OrganizationResourceStatus) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.organizationConformancePackName = organizationConformancePackName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case lastUpdateTime = "LastUpdateTime"
            case organizationConformancePackName = "OrganizationConformancePackName"
            case status = "Status"
        }
    }

    public struct OrganizationCustomRuleMetadata: AWSEncodableShape & AWSDecodableShape {
        /// The description that you provide for organization config rule.
        public let description: String?
        /// A string, in JSON format, that is passed to organization config rule Lambda function.
        public let inputParameters: String?
        /// The lambda function ARN.
        public let lambdaFunctionArn: String
        /// The maximum frequency with which AWS Config runs evaluations for a rule. Your custom rule is triggered when AWS Config delivers the configuration snapshot. For more information, see ConfigSnapshotDeliveryProperties.  By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter.
        public let maximumExecutionFrequency: MaximumExecutionFrequency?
        /// The type of notification that triggers AWS Config to run an evaluation for a rule. You can specify the following notification types:    ConfigurationItemChangeNotification - Triggers an evaluation when AWS Config delivers a configuration item as a result of a resource change.    OversizedConfigurationItemChangeNotification - Triggers an evaluation when AWS Config delivers an oversized configuration item. AWS Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.    ScheduledNotification - Triggers a periodic evaluation at the frequency specified for MaximumExecutionFrequency.
        public let organizationConfigRuleTriggerTypes: [OrganizationConfigRuleTriggerType]
        /// The ID of the AWS resource that was evaluated.
        public let resourceIdScope: String?
        /// The type of the AWS resource that was evaluated.
        public let resourceTypesScope: [String]?
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let tagKeyScope: String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public let tagValueScope: String?

        public init(description: String? = nil, inputParameters: String? = nil, lambdaFunctionArn: String, maximumExecutionFrequency: MaximumExecutionFrequency? = nil, organizationConfigRuleTriggerTypes: [OrganizationConfigRuleTriggerType], resourceIdScope: String? = nil, resourceTypesScope: [String]? = nil, tagKeyScope: String? = nil, tagValueScope: String? = nil) {
            self.description = description
            self.inputParameters = inputParameters
            self.lambdaFunctionArn = lambdaFunctionArn
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, max: 2048)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, min: 1)
            try self.validate(self.lambdaFunctionArn, name: "lambdaFunctionArn", parent: name, max: 256)
            try self.validate(self.lambdaFunctionArn, name: "lambdaFunctionArn", parent: name, min: 1)
            try self.validate(self.resourceIdScope, name: "resourceIdScope", parent: name, max: 768)
            try self.validate(self.resourceIdScope, name: "resourceIdScope", parent: name, min: 1)
            try self.resourceTypesScope?.forEach {
                try validate($0, name: "resourceTypesScope[]", parent: name, max: 256)
                try validate($0, name: "resourceTypesScope[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTypesScope, name: "resourceTypesScope", parent: name, max: 100)
            try self.validate(self.resourceTypesScope, name: "resourceTypesScope", parent: name, min: 0)
            try self.validate(self.tagKeyScope, name: "tagKeyScope", parent: name, max: 128)
            try self.validate(self.tagKeyScope, name: "tagKeyScope", parent: name, min: 1)
            try self.validate(self.tagValueScope, name: "tagValueScope", parent: name, max: 256)
            try self.validate(self.tagValueScope, name: "tagValueScope", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case inputParameters = "InputParameters"
            case lambdaFunctionArn = "LambdaFunctionArn"
            case maximumExecutionFrequency = "MaximumExecutionFrequency"
            case organizationConfigRuleTriggerTypes = "OrganizationConfigRuleTriggerTypes"
            case resourceIdScope = "ResourceIdScope"
            case resourceTypesScope = "ResourceTypesScope"
            case tagKeyScope = "TagKeyScope"
            case tagValueScope = "TagValueScope"
        }
    }

    public struct OrganizationManagedRuleMetadata: AWSEncodableShape & AWSDecodableShape {
        /// The description that you provide for organization config rule.
        public let description: String?
        /// A string, in JSON format, that is passed to organization config rule Lambda function.
        public let inputParameters: String?
        /// The maximum frequency with which AWS Config runs evaluations for a rule. You are using an AWS managed rule that is triggered at a periodic frequency.  By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter.
        public let maximumExecutionFrequency: MaximumExecutionFrequency?
        /// The ID of the AWS resource that was evaluated.
        public let resourceIdScope: String?
        /// The type of the AWS resource that was evaluated.
        public let resourceTypesScope: [String]?
        /// For organization config managed rules, a predefined identifier from a list. For example, IAM_PASSWORD_POLICY is a managed rule. To reference a managed rule, see Using AWS Managed Config Rules.
        public let ruleIdentifier: String
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let tagKeyScope: String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public let tagValueScope: String?

        public init(description: String? = nil, inputParameters: String? = nil, maximumExecutionFrequency: MaximumExecutionFrequency? = nil, resourceIdScope: String? = nil, resourceTypesScope: [String]? = nil, ruleIdentifier: String, tagKeyScope: String? = nil, tagValueScope: String? = nil) {
            self.description = description
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.ruleIdentifier = ruleIdentifier
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, max: 2048)
            try self.validate(self.inputParameters, name: "inputParameters", parent: name, min: 1)
            try self.validate(self.resourceIdScope, name: "resourceIdScope", parent: name, max: 768)
            try self.validate(self.resourceIdScope, name: "resourceIdScope", parent: name, min: 1)
            try self.resourceTypesScope?.forEach {
                try validate($0, name: "resourceTypesScope[]", parent: name, max: 256)
                try validate($0, name: "resourceTypesScope[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTypesScope, name: "resourceTypesScope", parent: name, max: 100)
            try self.validate(self.resourceTypesScope, name: "resourceTypesScope", parent: name, min: 0)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 256)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 1)
            try self.validate(self.tagKeyScope, name: "tagKeyScope", parent: name, max: 128)
            try self.validate(self.tagKeyScope, name: "tagKeyScope", parent: name, min: 1)
            try self.validate(self.tagValueScope, name: "tagValueScope", parent: name, max: 256)
            try self.validate(self.tagValueScope, name: "tagValueScope", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case inputParameters = "InputParameters"
            case maximumExecutionFrequency = "MaximumExecutionFrequency"
            case resourceIdScope = "ResourceIdScope"
            case resourceTypesScope = "ResourceTypesScope"
            case ruleIdentifier = "RuleIdentifier"
            case tagKeyScope = "TagKeyScope"
            case tagValueScope = "TagValueScope"
        }
    }

    public struct OrganizationResourceDetailedStatusFilters: AWSEncodableShape {
        /// The 12-digit account ID of the member account within an organization.
        public let accountId: String?
        /// Indicates deployment status for conformance pack in a member account. When master account calls PutOrganizationConformancePack action for the first time, conformance pack status is created in the member account. When master account calls PutOrganizationConformancePack action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the master account deletes OrganizationConformancePack and disables service access for config-multiaccountsetup.amazonaws.com.   AWS Config sets the state of the conformance pack to:    CREATE_SUCCESSFUL when conformance pack has been created in the member account.     CREATE_IN_PROGRESS when conformance pack is being created in the member account.    CREATE_FAILED when conformance pack creation has failed in the member account.    DELETE_FAILED when conformance pack deletion has failed in the member account.    DELETE_IN_PROGRESS when conformance pack is being deleted in the member account.    DELETE_SUCCESSFUL when conformance pack has been deleted in the member account.     UPDATE_SUCCESSFUL when conformance pack has been updated in the member account.    UPDATE_IN_PROGRESS when conformance pack is being updated in the member account.    UPDATE_FAILED when conformance pack deletion has failed in the member account.
        public let status: OrganizationResourceDetailedStatus?

        public init(accountId: String? = nil, status: OrganizationResourceDetailedStatus? = nil) {
            self.accountId = accountId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\d{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case status = "Status"
        }
    }

    public struct PendingAggregationRequest: AWSDecodableShape {
        /// The 12-digit account ID of the account requesting to aggregate data.
        public let requesterAccountId: String?
        /// The region requesting to aggregate data.
        public let requesterAwsRegion: String?

        public init(requesterAccountId: String? = nil, requesterAwsRegion: String? = nil) {
            self.requesterAccountId = requesterAccountId
            self.requesterAwsRegion = requesterAwsRegion
        }

        private enum CodingKeys: String, CodingKey {
            case requesterAccountId = "RequesterAccountId"
            case requesterAwsRegion = "RequesterAwsRegion"
        }
    }

    public struct PutAggregationAuthorizationRequest: AWSEncodableShape {
        /// The 12-digit account ID of the account authorized to aggregate data.
        public let authorizedAccountId: String
        /// The region authorized to collect aggregated data.
        public let authorizedAwsRegion: String
        /// An array of tag object.
        public let tags: [Tag]?

        public init(authorizedAccountId: String, authorizedAwsRegion: String, tags: [Tag]? = nil) {
            self.authorizedAccountId = authorizedAccountId
            self.authorizedAwsRegion = authorizedAwsRegion
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.authorizedAccountId, name: "authorizedAccountId", parent: name, pattern: "\\d{12}")
            try self.validate(self.authorizedAwsRegion, name: "authorizedAwsRegion", parent: name, max: 64)
            try self.validate(self.authorizedAwsRegion, name: "authorizedAwsRegion", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedAccountId = "AuthorizedAccountId"
            case authorizedAwsRegion = "AuthorizedAwsRegion"
            case tags = "Tags"
        }
    }

    public struct PutAggregationAuthorizationResponse: AWSDecodableShape {
        /// Returns an AggregationAuthorization object.
        public let aggregationAuthorization: AggregationAuthorization?

        public init(aggregationAuthorization: AggregationAuthorization? = nil) {
            self.aggregationAuthorization = aggregationAuthorization
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationAuthorization = "AggregationAuthorization"
        }
    }

    public struct PutConfigRuleRequest: AWSEncodableShape {
        /// The rule that you want to add to your account.
        public let configRule: ConfigRule
        /// An array of tag object.
        public let tags: [Tag]?

        public init(configRule: ConfigRule, tags: [Tag]? = nil) {
            self.configRule = configRule
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configRule.validate(name: "\(name).configRule")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configRule = "ConfigRule"
            case tags = "Tags"
        }
    }

    public struct PutConfigurationAggregatorRequest: AWSEncodableShape {
        /// A list of AccountAggregationSource object.
        public let accountAggregationSources: [AccountAggregationSource]?
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// An OrganizationAggregationSource object.
        public let organizationAggregationSource: OrganizationAggregationSource?
        /// An array of tag object.
        public let tags: [Tag]?

        public init(accountAggregationSources: [AccountAggregationSource]? = nil, configurationAggregatorName: String, organizationAggregationSource: OrganizationAggregationSource? = nil, tags: [Tag]? = nil) {
            self.accountAggregationSources = accountAggregationSources
            self.configurationAggregatorName = configurationAggregatorName
            self.organizationAggregationSource = organizationAggregationSource
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.accountAggregationSources?.forEach {
                try $0.validate(name: "\(name).accountAggregationSources[]")
            }
            try self.validate(self.accountAggregationSources, name: "accountAggregationSources", parent: name, max: 1)
            try self.validate(self.accountAggregationSources, name: "accountAggregationSources", parent: name, min: 0)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.organizationAggregationSource?.validate(name: "\(name).organizationAggregationSource")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case accountAggregationSources = "AccountAggregationSources"
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case organizationAggregationSource = "OrganizationAggregationSource"
            case tags = "Tags"
        }
    }

    public struct PutConfigurationAggregatorResponse: AWSDecodableShape {
        /// Returns a ConfigurationAggregator object.
        public let configurationAggregator: ConfigurationAggregator?

        public init(configurationAggregator: ConfigurationAggregator? = nil) {
            self.configurationAggregator = configurationAggregator
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregator = "ConfigurationAggregator"
        }
    }

    public struct PutConfigurationRecorderRequest: AWSEncodableShape {
        /// The configuration recorder object that records each configuration change made to the resources.
        public let configurationRecorder: ConfigurationRecorder

        public init(configurationRecorder: ConfigurationRecorder) {
            self.configurationRecorder = configurationRecorder
        }

        public func validate(name: String) throws {
            try self.configurationRecorder.validate(name: "\(name).configurationRecorder")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorder = "ConfigurationRecorder"
        }
    }

    public struct PutConformancePackRequest: AWSEncodableShape {
        /// A list of ConformancePackInputParameter objects.
        public let conformancePackInputParameters: [ConformancePackInputParameter]?
        /// Name of the conformance pack you want to create.
        public let conformancePackName: String
        /// Amazon S3 bucket where AWS Config stores conformance pack templates.  This field is optional.
        public let deliveryS3Bucket: String?
        /// The prefix for the Amazon S3 bucket.   This field is optional.
        public let deliveryS3KeyPrefix: String?
        /// A string containing full conformance pack template body. Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes.  You can only use a YAML template with one resource type, that is, config rule and a remediation action.
        public let templateBody: String?
        /// Location of file containing the template body (s3://bucketname/prefix). The uri must point to the conformance pack template (max size: 300 KB) that is located in an Amazon S3 bucket in the same region as the conformance pack.   You must have access to read Amazon S3 bucket.
        public let templateS3Uri: String?

        public init(conformancePackInputParameters: [ConformancePackInputParameter]? = nil, conformancePackName: String, deliveryS3Bucket: String? = nil, deliveryS3KeyPrefix: String? = nil, templateBody: String? = nil, templateS3Uri: String? = nil) {
            self.conformancePackInputParameters = conformancePackInputParameters
            self.conformancePackName = conformancePackName
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.templateBody = templateBody
            self.templateS3Uri = templateS3Uri
        }

        public func validate(name: String) throws {
            try self.conformancePackInputParameters?.forEach {
                try $0.validate(name: "\(name).conformancePackInputParameters[]")
            }
            try self.validate(self.conformancePackInputParameters, name: "conformancePackInputParameters", parent: name, max: 60)
            try self.validate(self.conformancePackInputParameters, name: "conformancePackInputParameters", parent: name, min: 0)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, max: 256)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, min: 1)
            try self.validate(self.conformancePackName, name: "conformancePackName", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
            try self.validate(self.deliveryS3Bucket, name: "deliveryS3Bucket", parent: name, max: 63)
            try self.validate(self.deliveryS3Bucket, name: "deliveryS3Bucket", parent: name, min: 0)
            try self.validate(self.deliveryS3KeyPrefix, name: "deliveryS3KeyPrefix", parent: name, max: 1024)
            try self.validate(self.deliveryS3KeyPrefix, name: "deliveryS3KeyPrefix", parent: name, min: 0)
            try self.validate(self.templateBody, name: "templateBody", parent: name, max: 51200)
            try self.validate(self.templateBody, name: "templateBody", parent: name, min: 1)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, max: 1024)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, min: 1)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, pattern: "s3://.*")
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackInputParameters = "ConformancePackInputParameters"
            case conformancePackName = "ConformancePackName"
            case deliveryS3Bucket = "DeliveryS3Bucket"
            case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
            case templateBody = "TemplateBody"
            case templateS3Uri = "TemplateS3Uri"
        }
    }

    public struct PutConformancePackResponse: AWSDecodableShape {
        /// ARN of the conformance pack.
        public let conformancePackArn: String?

        public init(conformancePackArn: String? = nil) {
            self.conformancePackArn = conformancePackArn
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackArn = "ConformancePackArn"
        }
    }

    public struct PutDeliveryChannelRequest: AWSEncodableShape {
        /// The configuration delivery channel object that delivers the configuration information to an Amazon S3 bucket and to an Amazon SNS topic.
        public let deliveryChannel: DeliveryChannel

        public init(deliveryChannel: DeliveryChannel) {
            self.deliveryChannel = deliveryChannel
        }

        public func validate(name: String) throws {
            try self.deliveryChannel.validate(name: "\(name).deliveryChannel")
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryChannel = "DeliveryChannel"
        }
    }

    public struct PutEvaluationsRequest: AWSEncodableShape {
        /// The assessments that the AWS Lambda function performs. Each evaluation identifies an AWS resource and indicates whether it complies with the AWS Config rule that invokes the AWS Lambda function.
        public let evaluations: [Evaluation]?
        /// An encrypted token that associates an evaluation with an AWS Config rule. Identifies the rule and the event that triggered the evaluation.
        public let resultToken: String
        /// Use this parameter to specify a test run for PutEvaluations. You can verify whether your AWS Lambda function will deliver evaluation results to AWS Config. No updates occur to your existing evaluations, and evaluation results are not sent to AWS Config.  When TestMode is true, PutEvaluations doesn't require a valid value for the ResultToken parameter, but the value cannot be null.
        public let testMode: Bool?

        public init(evaluations: [Evaluation]? = nil, resultToken: String, testMode: Bool? = nil) {
            self.evaluations = evaluations
            self.resultToken = resultToken
            self.testMode = testMode
        }

        public func validate(name: String) throws {
            try self.evaluations?.forEach {
                try $0.validate(name: "\(name).evaluations[]")
            }
            try self.validate(self.evaluations, name: "evaluations", parent: name, max: 100)
            try self.validate(self.evaluations, name: "evaluations", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case evaluations = "Evaluations"
            case resultToken = "ResultToken"
            case testMode = "TestMode"
        }
    }

    public struct PutEvaluationsResponse: AWSDecodableShape {
        /// Requests that failed because of a client or server error.
        public let failedEvaluations: [Evaluation]?

        public init(failedEvaluations: [Evaluation]? = nil) {
            self.failedEvaluations = failedEvaluations
        }

        private enum CodingKeys: String, CodingKey {
            case failedEvaluations = "FailedEvaluations"
        }
    }

    public struct PutExternalEvaluationRequest: AWSEncodableShape {
        /// The name of the AWS Config rule.
        public let configRuleName: String
        /// An ExternalEvaluation object that provides details about compliance.
        public let externalEvaluation: ExternalEvaluation

        public init(configRuleName: String, externalEvaluation: ExternalEvaluation) {
            self.configRuleName = configRuleName
            self.externalEvaluation = externalEvaluation
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
            try self.externalEvaluation.validate(name: "\(name).externalEvaluation")
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case externalEvaluation = "ExternalEvaluation"
        }
    }

    public struct PutExternalEvaluationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutOrganizationConfigRuleRequest: AWSEncodableShape {
        /// A comma-separated list of accounts that you want to exclude from an organization config rule.
        public let excludedAccounts: [String]?
        /// The name that you assign to an organization config rule.
        public let organizationConfigRuleName: String
        /// An OrganizationCustomRuleMetadata object.
        public let organizationCustomRuleMetadata: OrganizationCustomRuleMetadata?
        /// An OrganizationManagedRuleMetadata object.
        public let organizationManagedRuleMetadata: OrganizationManagedRuleMetadata?

        public init(excludedAccounts: [String]? = nil, organizationConfigRuleName: String, organizationCustomRuleMetadata: OrganizationCustomRuleMetadata? = nil, organizationManagedRuleMetadata: OrganizationManagedRuleMetadata? = nil) {
            self.excludedAccounts = excludedAccounts
            self.organizationConfigRuleName = organizationConfigRuleName
            self.organizationCustomRuleMetadata = organizationCustomRuleMetadata
            self.organizationManagedRuleMetadata = organizationManagedRuleMetadata
        }

        public func validate(name: String) throws {
            try self.excludedAccounts?.forEach {
                try validate($0, name: "excludedAccounts[]", parent: name, pattern: "\\d{12}")
            }
            try self.validate(self.excludedAccounts, name: "excludedAccounts", parent: name, max: 1000)
            try self.validate(self.excludedAccounts, name: "excludedAccounts", parent: name, min: 0)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, max: 64)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, min: 1)
            try self.validate(self.organizationConfigRuleName, name: "organizationConfigRuleName", parent: name, pattern: ".*\\S.*")
            try self.organizationCustomRuleMetadata?.validate(name: "\(name).organizationCustomRuleMetadata")
            try self.organizationManagedRuleMetadata?.validate(name: "\(name).organizationManagedRuleMetadata")
        }

        private enum CodingKeys: String, CodingKey {
            case excludedAccounts = "ExcludedAccounts"
            case organizationConfigRuleName = "OrganizationConfigRuleName"
            case organizationCustomRuleMetadata = "OrganizationCustomRuleMetadata"
            case organizationManagedRuleMetadata = "OrganizationManagedRuleMetadata"
        }
    }

    public struct PutOrganizationConfigRuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an organization config rule.
        public let organizationConfigRuleArn: String?

        public init(organizationConfigRuleArn: String? = nil) {
            self.organizationConfigRuleArn = organizationConfigRuleArn
        }

        private enum CodingKeys: String, CodingKey {
            case organizationConfigRuleArn = "OrganizationConfigRuleArn"
        }
    }

    public struct PutOrganizationConformancePackRequest: AWSEncodableShape {
        /// A list of ConformancePackInputParameter objects.
        public let conformancePackInputParameters: [ConformancePackInputParameter]?
        /// Amazon S3 bucket where AWS Config stores conformance pack templates.  This field is optional. If used, it must be prefixed with awsconfigconforms.
        public let deliveryS3Bucket: String?
        /// The prefix for the Amazon S3 bucket.  This field is optional.
        public let deliveryS3KeyPrefix: String?
        /// A list of AWS accounts to be excluded from an organization conformance pack while deploying a conformance pack.
        public let excludedAccounts: [String]?
        /// Name of the organization conformance pack you want to create.
        public let organizationConformancePackName: String
        /// A string containing full conformance pack template body. Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes.
        public let templateBody: String?
        /// Location of file containing the template body. The uri must point to the conformance pack template (max size: 300 KB).  You must have access to read Amazon S3 bucket.
        public let templateS3Uri: String?

        public init(conformancePackInputParameters: [ConformancePackInputParameter]? = nil, deliveryS3Bucket: String? = nil, deliveryS3KeyPrefix: String? = nil, excludedAccounts: [String]? = nil, organizationConformancePackName: String, templateBody: String? = nil, templateS3Uri: String? = nil) {
            self.conformancePackInputParameters = conformancePackInputParameters
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.excludedAccounts = excludedAccounts
            self.organizationConformancePackName = organizationConformancePackName
            self.templateBody = templateBody
            self.templateS3Uri = templateS3Uri
        }

        public func validate(name: String) throws {
            try self.conformancePackInputParameters?.forEach {
                try $0.validate(name: "\(name).conformancePackInputParameters[]")
            }
            try self.validate(self.conformancePackInputParameters, name: "conformancePackInputParameters", parent: name, max: 60)
            try self.validate(self.conformancePackInputParameters, name: "conformancePackInputParameters", parent: name, min: 0)
            try self.validate(self.deliveryS3Bucket, name: "deliveryS3Bucket", parent: name, max: 63)
            try self.validate(self.deliveryS3Bucket, name: "deliveryS3Bucket", parent: name, min: 0)
            try self.validate(self.deliveryS3KeyPrefix, name: "deliveryS3KeyPrefix", parent: name, max: 1024)
            try self.validate(self.deliveryS3KeyPrefix, name: "deliveryS3KeyPrefix", parent: name, min: 0)
            try self.excludedAccounts?.forEach {
                try validate($0, name: "excludedAccounts[]", parent: name, pattern: "\\d{12}")
            }
            try self.validate(self.excludedAccounts, name: "excludedAccounts", parent: name, max: 1000)
            try self.validate(self.excludedAccounts, name: "excludedAccounts", parent: name, min: 0)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, max: 128)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, min: 1)
            try self.validate(self.organizationConformancePackName, name: "organizationConformancePackName", parent: name, pattern: "[a-zA-Z][-a-zA-Z0-9]*")
            try self.validate(self.templateBody, name: "templateBody", parent: name, max: 51200)
            try self.validate(self.templateBody, name: "templateBody", parent: name, min: 1)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, max: 1024)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, min: 1)
            try self.validate(self.templateS3Uri, name: "templateS3Uri", parent: name, pattern: "s3://.*")
        }

        private enum CodingKeys: String, CodingKey {
            case conformancePackInputParameters = "ConformancePackInputParameters"
            case deliveryS3Bucket = "DeliveryS3Bucket"
            case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
            case excludedAccounts = "ExcludedAccounts"
            case organizationConformancePackName = "OrganizationConformancePackName"
            case templateBody = "TemplateBody"
            case templateS3Uri = "TemplateS3Uri"
        }
    }

    public struct PutOrganizationConformancePackResponse: AWSDecodableShape {
        /// ARN of the organization conformance pack.
        public let organizationConformancePackArn: String?

        public init(organizationConformancePackArn: String? = nil) {
            self.organizationConformancePackArn = organizationConformancePackArn
        }

        private enum CodingKeys: String, CodingKey {
            case organizationConformancePackArn = "OrganizationConformancePackArn"
        }
    }

    public struct PutRemediationConfigurationsRequest: AWSEncodableShape {
        /// A list of remediation configuration objects.
        public let remediationConfigurations: [RemediationConfiguration]

        public init(remediationConfigurations: [RemediationConfiguration]) {
            self.remediationConfigurations = remediationConfigurations
        }

        public func validate(name: String) throws {
            try self.remediationConfigurations.forEach {
                try $0.validate(name: "\(name).remediationConfigurations[]")
            }
            try self.validate(self.remediationConfigurations, name: "remediationConfigurations", parent: name, max: 25)
            try self.validate(self.remediationConfigurations, name: "remediationConfigurations", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case remediationConfigurations = "RemediationConfigurations"
        }
    }

    public struct PutRemediationConfigurationsResponse: AWSDecodableShape {
        /// Returns a list of failed remediation batch objects.
        public let failedBatches: [FailedRemediationBatch]?

        public init(failedBatches: [FailedRemediationBatch]? = nil) {
            self.failedBatches = failedBatches
        }

        private enum CodingKeys: String, CodingKey {
            case failedBatches = "FailedBatches"
        }
    }

    public struct PutRemediationExceptionsRequest: AWSEncodableShape {
        /// The name of the AWS Config rule for which you want to create remediation exception.
        public let configRuleName: String
        /// The exception is automatically deleted after the expiration date.
        public let expirationTime: Date?
        /// The message contains an explanation of the exception.
        public let message: String?
        /// An exception list of resource exception keys to be processed with the current request. AWS Config adds exception for each resource key. For example, AWS Config adds 3 exceptions for 3 resource keys.
        public let resourceKeys: [RemediationExceptionResourceKey]

        public init(configRuleName: String, expirationTime: Date? = nil, message: String? = nil, resourceKeys: [RemediationExceptionResourceKey]) {
            self.configRuleName = configRuleName
            self.expirationTime = expirationTime
            self.message = message
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
            try self.validate(self.message, name: "message", parent: name, max: 1024)
            try self.validate(self.message, name: "message", parent: name, min: 1)
            try self.resourceKeys.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case expirationTime = "ExpirationTime"
            case message = "Message"
            case resourceKeys = "ResourceKeys"
        }
    }

    public struct PutRemediationExceptionsResponse: AWSDecodableShape {
        /// Returns a list of failed remediation exceptions batch objects. Each object in the batch consists of a list of failed items and failure messages.
        public let failedBatches: [FailedRemediationExceptionBatch]?

        public init(failedBatches: [FailedRemediationExceptionBatch]? = nil) {
            self.failedBatches = failedBatches
        }

        private enum CodingKeys: String, CodingKey {
            case failedBatches = "FailedBatches"
        }
    }

    public struct PutResourceConfigRequest: AWSEncodableShape {
        /// The configuration object of the resource in valid JSON format. It must match the schema registered with AWS CloudFormation.  The configuration JSON must not exceed 64 KB.
        public let configuration: String
        /// Unique identifier of the resource.
        public let resourceId: String
        /// Name of the resource.
        public let resourceName: String?
        /// The type of the resource. The custom resource type must be registered with AWS CloudFormation.   You cannot use the organization names “aws”, “amzn”, “amazon”, “alexa”, “custom” with custom resource types. It is the first part of the ResourceType up to the first ::.
        public let resourceType: String
        /// Version of the schema registered for the ResourceType in AWS CloudFormation.
        public let schemaVersionId: String
        /// Tags associated with the resource.
        public let tags: [String: String]?

        public init(configuration: String, resourceId: String, resourceName: String? = nil, resourceType: String, schemaVersionId: String, tags: [String: String]? = nil) {
            self.configuration = configuration
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.schemaVersionId = schemaVersionId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 196)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 128)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 1)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "[A-Za-z0-9-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case resourceId = "ResourceId"
            case resourceName = "ResourceName"
            case resourceType = "ResourceType"
            case schemaVersionId = "SchemaVersionId"
            case tags = "Tags"
        }
    }

    public struct PutRetentionConfigurationRequest: AWSEncodableShape {
        /// Number of days AWS Config stores your historical information.  Currently, only applicable to the configuration item history.
        public let retentionPeriodInDays: Int

        public init(retentionPeriodInDays: Int) {
            self.retentionPeriodInDays = retentionPeriodInDays
        }

        public func validate(name: String) throws {
            try self.validate(self.retentionPeriodInDays, name: "retentionPeriodInDays", parent: name, max: 2557)
            try self.validate(self.retentionPeriodInDays, name: "retentionPeriodInDays", parent: name, min: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case retentionPeriodInDays = "RetentionPeriodInDays"
        }
    }

    public struct PutRetentionConfigurationResponse: AWSDecodableShape {
        /// Returns a retention configuration object.
        public let retentionConfiguration: RetentionConfiguration?

        public init(retentionConfiguration: RetentionConfiguration? = nil) {
            self.retentionConfiguration = retentionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case retentionConfiguration = "RetentionConfiguration"
        }
    }

    public struct PutStoredQueryRequest: AWSEncodableShape {
        /// A list of StoredQuery objects. The mandatory fields are QueryName and Expression.  When you are creating a query, you must provide a query name and an expression. When you are updating a query, you must provide a query name but updating the description is optional.
        public let storedQuery: StoredQuery
        /// A list of Tags object.
        public let tags: [Tag]?

        public init(storedQuery: StoredQuery, tags: [Tag]? = nil) {
            self.storedQuery = storedQuery
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.storedQuery.validate(name: "\(name).storedQuery")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case storedQuery = "StoredQuery"
            case tags = "Tags"
        }
    }

    public struct PutStoredQueryResponse: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
        public let queryArn: String?

        public init(queryArn: String? = nil) {
            self.queryArn = queryArn
        }

        private enum CodingKeys: String, CodingKey {
            case queryArn = "QueryArn"
        }
    }

    public struct QueryInfo: AWSDecodableShape {
        /// Returns a FieldInfo object.
        public let selectFields: [FieldInfo]?

        public init(selectFields: [FieldInfo]? = nil) {
            self.selectFields = selectFields
        }

        private enum CodingKeys: String, CodingKey {
            case selectFields = "SelectFields"
        }
    }

    public struct RecordingGroup: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether AWS Config records configuration changes for every supported type of regional resource. If you set this option to true, when AWS Config adds support for a new type of regional resource, it starts recording resources of that type automatically. If you set this option to true, you cannot enumerate a list of resourceTypes.
        public let allSupported: Bool?
        /// Specifies whether AWS Config includes all supported types of global resources (for example, IAM resources) with the resources that it records. Before you can set this option to true, you must set the allSupported option to true. If you set this option to true, when AWS Config adds support for a new type of global resource, it starts recording resources of that type automatically. The configuration details for any global resource are the same in all regions. To prevent duplicate configuration items, you should consider customizing AWS Config in only one region to record global resources.
        public let includeGlobalResourceTypes: Bool?
        /// A comma-separated list that specifies the types of AWS resources for which AWS Config records configuration changes (for example, AWS::EC2::Instance or AWS::CloudTrail::Trail). To record all configuration changes, you must set the allSupported option to true. If you set this option to false, when AWS Config adds support for a new type of resource, it will not record resources of that type unless you manually add that type to your recording group. For a list of valid resourceTypes values, see the resourceType Value column in Supported AWS Resource Types.
        public let resourceTypes: [ResourceType]?

        public init(allSupported: Bool? = nil, includeGlobalResourceTypes: Bool? = nil, resourceTypes: [ResourceType]? = nil) {
            self.allSupported = allSupported
            self.includeGlobalResourceTypes = includeGlobalResourceTypes
            self.resourceTypes = resourceTypes
        }

        private enum CodingKeys: String, CodingKey {
            case allSupported
            case includeGlobalResourceTypes
            case resourceTypes
        }
    }

    public struct Relationship: AWSDecodableShape {
        /// The type of relationship with the related resource.
        public let relationshipName: String?
        /// The ID of the related resource (for example, sg-xxxxxx).
        public let resourceId: String?
        /// The custom name of the related resource, if available.
        public let resourceName: String?
        /// The resource type of the related resource.
        public let resourceType: ResourceType?

        public init(relationshipName: String? = nil, resourceId: String? = nil, resourceName: String? = nil, resourceType: ResourceType? = nil) {
            self.relationshipName = relationshipName
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case relationshipName
            case resourceId
            case resourceName
            case resourceType
        }
    }

    public struct RemediationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Amazon Resource Name (ARN) of remediation configuration.
        public let arn: String?
        /// The remediation is triggered automatically.
        public let automatic: Bool?
        /// The name of the AWS Config rule.
        public let configRuleName: String
        /// Name of the service that owns the service linked rule, if applicable.
        public let createdByService: String?
        /// An ExecutionControls object.
        public let executionControls: ExecutionControls?
        /// The maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5. For example, if you specify MaximumAutomaticAttempts as 5 with RetryAttemptSeconds as 50 seconds, AWS Config will put a RemediationException on your behalf for the failing resource after the 5th failed attempt within 50 seconds.
        public let maximumAutomaticAttempts: Int?
        /// An object of the RemediationParameterValue.
        public let parameters: [String: RemediationParameterValue]?
        /// The type of a resource.
        public let resourceType: String?
        /// Maximum time in seconds that AWS Config runs auto-remediation. If you do not select a number, the default is 60 seconds.  For example, if you specify RetryAttemptSeconds as 50 seconds and MaximumAutomaticAttempts as 5, AWS Config will run auto-remediations 5 times within 50 seconds before throwing an exception.
        public let retryAttemptSeconds: Int64?
        /// Target ID is the name of the public document.
        public let targetId: String
        /// The type of the target. Target executes remediation. For example, SSM document.
        public let targetType: RemediationTargetType
        /// Version of the target. For example, version of the SSM document.  If you make backward incompatible changes to the SSM document, you must call PutRemediationConfiguration API again to ensure the remediations can run.
        public let targetVersion: String?

        public init(arn: String? = nil, automatic: Bool? = nil, configRuleName: String, createdByService: String? = nil, executionControls: ExecutionControls? = nil, maximumAutomaticAttempts: Int? = nil, parameters: [String: RemediationParameterValue]? = nil, resourceType: String? = nil, retryAttemptSeconds: Int64? = nil, targetId: String, targetType: RemediationTargetType, targetVersion: String? = nil) {
            self.arn = arn
            self.automatic = automatic
            self.configRuleName = configRuleName
            self.createdByService = createdByService
            self.executionControls = executionControls
            self.maximumAutomaticAttempts = maximumAutomaticAttempts
            self.parameters = parameters
            self.resourceType = resourceType
            self.retryAttemptSeconds = retryAttemptSeconds
            self.targetId = targetId
            self.targetType = targetType
            self.targetVersion = targetVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1024)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
            try self.validate(self.createdByService, name: "createdByService", parent: name, max: 1024)
            try self.validate(self.createdByService, name: "createdByService", parent: name, min: 1)
            try self.executionControls?.validate(name: "\(name).executionControls")
            try self.validate(self.maximumAutomaticAttempts, name: "maximumAutomaticAttempts", parent: name, max: 25)
            try self.validate(self.maximumAutomaticAttempts, name: "maximumAutomaticAttempts", parent: name, min: 1)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 256)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
            try self.validate(self.retryAttemptSeconds, name: "retryAttemptSeconds", parent: name, max: 2_678_000)
            try self.validate(self.retryAttemptSeconds, name: "retryAttemptSeconds", parent: name, min: 1)
            try self.validate(self.targetId, name: "targetId", parent: name, max: 256)
            try self.validate(self.targetId, name: "targetId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case automatic = "Automatic"
            case configRuleName = "ConfigRuleName"
            case createdByService = "CreatedByService"
            case executionControls = "ExecutionControls"
            case maximumAutomaticAttempts = "MaximumAutomaticAttempts"
            case parameters = "Parameters"
            case resourceType = "ResourceType"
            case retryAttemptSeconds = "RetryAttemptSeconds"
            case targetId = "TargetId"
            case targetType = "TargetType"
            case targetVersion = "TargetVersion"
        }
    }

    public struct RemediationException: AWSDecodableShape {
        /// The name of the AWS Config rule.
        public let configRuleName: String
        /// The time when the remediation exception will be deleted.
        public let expirationTime: Date?
        /// An explanation of an remediation exception.
        public let message: String?
        /// The ID of the resource (for example., sg-xxxxxx).
        public let resourceId: String
        /// The type of a resource.
        public let resourceType: String

        public init(configRuleName: String, expirationTime: Date? = nil, message: String? = nil, resourceId: String, resourceType: String) {
            self.configRuleName = configRuleName
            self.expirationTime = expirationTime
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case expirationTime = "ExpirationTime"
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct RemediationExceptionResourceKey: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the resource (for example., sg-xxxxxx).
        public let resourceId: String?
        /// The type of a resource.
        public let resourceType: String?

        public init(resourceId: String? = nil, resourceType: String? = nil) {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 1024)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct RemediationExecutionStatus: AWSDecodableShape {
        /// Start time when the remediation was executed.
        public let invocationTime: Date?
        /// The time when the remediation execution was last updated.
        public let lastUpdatedTime: Date?
        public let resourceKey: ResourceKey?
        /// ENUM of the values.
        public let state: RemediationExecutionState?
        /// Details of every step.
        public let stepDetails: [RemediationExecutionStep]?

        public init(invocationTime: Date? = nil, lastUpdatedTime: Date? = nil, resourceKey: ResourceKey? = nil, state: RemediationExecutionState? = nil, stepDetails: [RemediationExecutionStep]? = nil) {
            self.invocationTime = invocationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceKey = resourceKey
            self.state = state
            self.stepDetails = stepDetails
        }

        private enum CodingKeys: String, CodingKey {
            case invocationTime = "InvocationTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case resourceKey = "ResourceKey"
            case state = "State"
            case stepDetails = "StepDetails"
        }
    }

    public struct RemediationExecutionStep: AWSDecodableShape {
        /// An error message if the step was interrupted during execution.
        public let errorMessage: String?
        /// The details of the step.
        public let name: String?
        /// The time when the step started.
        public let startTime: Date?
        /// The valid status of the step.
        public let state: RemediationExecutionStepState?
        /// The time when the step stopped.
        public let stopTime: Date?

        public init(errorMessage: String? = nil, name: String? = nil, startTime: Date? = nil, state: RemediationExecutionStepState? = nil, stopTime: Date? = nil) {
            self.errorMessage = errorMessage
            self.name = name
            self.startTime = startTime
            self.state = state
            self.stopTime = stopTime
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case name = "Name"
            case startTime = "StartTime"
            case state = "State"
            case stopTime = "StopTime"
        }
    }

    public struct RemediationParameterValue: AWSEncodableShape & AWSDecodableShape {
        /// The value is dynamic and changes at run-time.
        public let resourceValue: ResourceValue?
        /// The value is static and does not change at run-time.
        public let staticValue: StaticValue?

        public init(resourceValue: ResourceValue? = nil, staticValue: StaticValue? = nil) {
            self.resourceValue = resourceValue
            self.staticValue = staticValue
        }

        public func validate(name: String) throws {
            try self.staticValue?.validate(name: "\(name).staticValue")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceValue = "ResourceValue"
            case staticValue = "StaticValue"
        }
    }

    public struct ResourceCount: AWSDecodableShape {
        /// The number of resources.
        public let count: Int64?
        /// The resource type (for example, "AWS::EC2::Instance").
        public let resourceType: ResourceType?

        public init(count: Int64? = nil, resourceType: ResourceType? = nil) {
            self.count = count
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case count
            case resourceType
        }
    }

    public struct ResourceCountFilters: AWSEncodableShape {
        /// The 12-digit ID of the account.
        public let accountId: String?
        /// The region where the account is located.
        public let region: String?
        /// The type of the AWS resource.
        public let resourceType: ResourceType?

        public init(accountId: String? = nil, region: String? = nil, resourceType: ResourceType? = nil) {
            self.accountId = accountId
            self.region = region
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\d{12}")
            try self.validate(self.region, name: "region", parent: name, max: 64)
            try self.validate(self.region, name: "region", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case region = "Region"
            case resourceType = "ResourceType"
        }
    }

    public struct ResourceFilters: AWSEncodableShape {
        /// The 12-digit source account ID.
        public let accountId: String?
        /// The source region.
        public let region: String?
        /// The ID of the resource.
        public let resourceId: String?
        /// The name of the resource.
        public let resourceName: String?

        public init(accountId: String? = nil, region: String? = nil, resourceId: String? = nil, resourceName: String? = nil) {
            self.accountId = accountId
            self.region = region
            self.resourceId = resourceId
            self.resourceName = resourceName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\d{12}")
            try self.validate(self.region, name: "region", parent: name, max: 64)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case region = "Region"
            case resourceId = "ResourceId"
            case resourceName = "ResourceName"
        }
    }

    public struct ResourceIdentifier: AWSDecodableShape {
        /// The time that the resource was deleted.
        public let resourceDeletionTime: Date?
        /// The ID of the resource (for example, sg-xxxxxx).
        public let resourceId: String?
        /// The custom name of the resource (if available).
        public let resourceName: String?
        /// The type of resource.
        public let resourceType: ResourceType?

        public init(resourceDeletionTime: Date? = nil, resourceId: String? = nil, resourceName: String? = nil, resourceType: ResourceType? = nil) {
            self.resourceDeletionTime = resourceDeletionTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case resourceDeletionTime
            case resourceId
            case resourceName
            case resourceType
        }
    }

    public struct ResourceKey: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the resource (for example., sg-xxxxxx).
        public let resourceId: String
        /// The resource type.
        public let resourceType: ResourceType

        public init(resourceId: String, resourceType: ResourceType) {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 768)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId
            case resourceType
        }
    }

    public struct ResourceValue: AWSEncodableShape & AWSDecodableShape {
        /// The value is a resource ID.
        public let value: ResourceValueType

        public init(value: ResourceValueType) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct RetentionConfiguration: AWSDecodableShape {
        /// The name of the retention configuration object.
        public let name: String
        /// Number of days AWS Config stores your historical information.  Currently, only applicable to the configuration item history.
        public let retentionPeriodInDays: Int

        public init(name: String, retentionPeriodInDays: Int) {
            self.name = name
            self.retentionPeriodInDays = retentionPeriodInDays
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case retentionPeriodInDays = "RetentionPeriodInDays"
        }
    }

    public struct Scope: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the only AWS resource that you want to trigger an evaluation for the rule. If you specify a resource ID, you must specify one resource type for ComplianceResourceTypes.
        public let complianceResourceId: String?
        /// The resource types of only those AWS resources that you want to trigger an evaluation for the rule. You can only specify one type if you also specify a resource ID for ComplianceResourceId.
        public let complianceResourceTypes: [String]?
        /// The tag key that is applied to only those AWS resources that you want to trigger an evaluation for the rule.
        public let tagKey: String?
        /// The tag value applied to only those AWS resources that you want to trigger an evaluation for the rule. If you specify a value for TagValue, you must also specify a value for TagKey.
        public let tagValue: String?

        public init(complianceResourceId: String? = nil, complianceResourceTypes: [String]? = nil, tagKey: String? = nil, tagValue: String? = nil) {
            self.complianceResourceId = complianceResourceId
            self.complianceResourceTypes = complianceResourceTypes
            self.tagKey = tagKey
            self.tagValue = tagValue
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, max: 768)
            try self.validate(self.complianceResourceId, name: "complianceResourceId", parent: name, min: 1)
            try self.complianceResourceTypes?.forEach {
                try validate($0, name: "complianceResourceTypes[]", parent: name, max: 256)
                try validate($0, name: "complianceResourceTypes[]", parent: name, min: 1)
            }
            try self.validate(self.complianceResourceTypes, name: "complianceResourceTypes", parent: name, max: 100)
            try self.validate(self.complianceResourceTypes, name: "complianceResourceTypes", parent: name, min: 0)
            try self.validate(self.tagKey, name: "tagKey", parent: name, max: 128)
            try self.validate(self.tagKey, name: "tagKey", parent: name, min: 1)
            try self.validate(self.tagValue, name: "tagValue", parent: name, max: 256)
            try self.validate(self.tagValue, name: "tagValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case complianceResourceId = "ComplianceResourceId"
            case complianceResourceTypes = "ComplianceResourceTypes"
            case tagKey = "TagKey"
            case tagValue = "TagValue"
        }
    }

    public struct SelectAggregateResourceConfigRequest: AWSEncodableShape {
        /// The name of the configuration aggregator.
        public let configurationAggregatorName: String
        /// The SQL query SELECT command.
        public let expression: String
        /// The maximum number of query results returned on each page.
        public let limit: Int?
        /// The maximum number of query results returned on each page. AWS Config also allows the Limit request parameter.
        public let maxResults: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        public init(configurationAggregatorName: String, expression: String, limit: Int? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.configurationAggregatorName = configurationAggregatorName
            self.expression = expression
            self.limit = limit
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, max: 256)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, min: 1)
            try self.validate(self.configurationAggregatorName, name: "configurationAggregatorName", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationAggregatorName = "ConfigurationAggregatorName"
            case expression = "Expression"
            case limit = "Limit"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SelectAggregateResourceConfigResponse: AWSDecodableShape {
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?
        public let queryInfo: QueryInfo?
        /// Returns the results for the SQL query.
        public let results: [String]?

        public init(nextToken: String? = nil, queryInfo: QueryInfo? = nil, results: [String]? = nil) {
            self.nextToken = nextToken
            self.queryInfo = queryInfo
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case queryInfo = "QueryInfo"
            case results = "Results"
        }
    }

    public struct SelectResourceConfigRequest: AWSEncodableShape {
        /// The SQL query SELECT command.
        public let expression: String
        /// The maximum number of query results returned on each page.
        public let limit: Int?
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?

        public init(expression: String, limit: Int? = nil, nextToken: String? = nil) {
            self.expression = expression
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct SelectResourceConfigResponse: AWSDecodableShape {
        /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
        public let nextToken: String?
        /// Returns the QueryInfo object.
        public let queryInfo: QueryInfo?
        /// Returns the results for the SQL query.
        public let results: [String]?

        public init(nextToken: String? = nil, queryInfo: QueryInfo? = nil, results: [String]? = nil) {
            self.nextToken = nextToken
            self.queryInfo = queryInfo
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case queryInfo = "QueryInfo"
            case results = "Results"
        }
    }

    public struct Source: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether AWS or the customer owns and manages the AWS Config rule.
        public let owner: Owner
        /// Provides the source and type of the event that causes AWS Config to evaluate your AWS resources.
        public let sourceDetails: [SourceDetail]?
        /// For AWS Config managed rules, a predefined identifier from a list. For example, IAM_PASSWORD_POLICY is a managed rule. To reference a managed rule, see Using AWS Managed Config Rules. For custom rules, the identifier is the Amazon Resource Name (ARN) of the rule's AWS Lambda function, such as arn:aws:lambda:us-east-2:123456789012:function:custom_rule_name.
        public let sourceIdentifier: String

        public init(owner: Owner, sourceDetails: [SourceDetail]? = nil, sourceIdentifier: String) {
            self.owner = owner
            self.sourceDetails = sourceDetails
            self.sourceIdentifier = sourceIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceDetails, name: "sourceDetails", parent: name, max: 25)
            try self.validate(self.sourceDetails, name: "sourceDetails", parent: name, min: 0)
            try self.validate(self.sourceIdentifier, name: "sourceIdentifier", parent: name, max: 256)
            try self.validate(self.sourceIdentifier, name: "sourceIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case owner = "Owner"
            case sourceDetails = "SourceDetails"
            case sourceIdentifier = "SourceIdentifier"
        }
    }

    public struct SourceDetail: AWSEncodableShape & AWSDecodableShape {
        /// The source of the event, such as an AWS service, that triggers AWS Config to evaluate your AWS resources.
        public let eventSource: EventSource?
        /// The frequency at which you want AWS Config to run evaluations for a custom rule with a periodic trigger. If you specify a value for MaximumExecutionFrequency, then MessageType must use the ScheduledNotification value.  By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter. Based on the valid value you choose, AWS Config runs evaluations once for each valid value. For example, if you choose Three_Hours, AWS Config runs evaluations once every three hours. In this case, Three_Hours is the frequency of this rule.
        public let maximumExecutionFrequency: MaximumExecutionFrequency?
        /// The type of notification that triggers AWS Config to run an evaluation for a rule. You can specify the following notification types:    ConfigurationItemChangeNotification - Triggers an evaluation when AWS Config delivers a configuration item as a result of a resource change.    OversizedConfigurationItemChangeNotification - Triggers an evaluation when AWS Config delivers an oversized configuration item. AWS Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.    ScheduledNotification - Triggers a periodic evaluation at the frequency specified for MaximumExecutionFrequency.    ConfigurationSnapshotDeliveryCompleted - Triggers a periodic evaluation when AWS Config delivers a configuration snapshot.   If you want your custom rule to be triggered by configuration changes, specify two SourceDetail objects, one for ConfigurationItemChangeNotification and one for OversizedConfigurationItemChangeNotification.
        public let messageType: MessageType?

        public init(eventSource: EventSource? = nil, maximumExecutionFrequency: MaximumExecutionFrequency? = nil, messageType: MessageType? = nil) {
            self.eventSource = eventSource
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.messageType = messageType
        }

        private enum CodingKeys: String, CodingKey {
            case eventSource = "EventSource"
            case maximumExecutionFrequency = "MaximumExecutionFrequency"
            case messageType = "MessageType"
        }
    }

    public struct SsmControls: AWSEncodableShape & AWSDecodableShape {
        /// The maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. You can specify a percentage, such as 10%. The default value is 10.
        public let concurrentExecutionRatePercentage: Int?
        /// The percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule. You can specify a percentage of errors, for example 10%. If you do not specifiy a percentage, the default is 50%. For example, if you set the ErrorPercentage to 40% for 10 non-compliant resources, then SSM stops running the automations when the fifth error is received.
        public let errorPercentage: Int?

        public init(concurrentExecutionRatePercentage: Int? = nil, errorPercentage: Int? = nil) {
            self.concurrentExecutionRatePercentage = concurrentExecutionRatePercentage
            self.errorPercentage = errorPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.concurrentExecutionRatePercentage, name: "concurrentExecutionRatePercentage", parent: name, max: 100)
            try self.validate(self.concurrentExecutionRatePercentage, name: "concurrentExecutionRatePercentage", parent: name, min: 1)
            try self.validate(self.errorPercentage, name: "errorPercentage", parent: name, max: 100)
            try self.validate(self.errorPercentage, name: "errorPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case concurrentExecutionRatePercentage = "ConcurrentExecutionRatePercentage"
            case errorPercentage = "ErrorPercentage"
        }
    }

    public struct StartConfigRulesEvaluationRequest: AWSEncodableShape {
        /// The list of names of AWS Config rules that you want to run evaluations for.
        public let configRuleNames: [String]?

        public init(configRuleNames: [String]? = nil) {
            self.configRuleNames = configRuleNames
        }

        public func validate(name: String) throws {
            try self.configRuleNames?.forEach {
                try validate($0, name: "configRuleNames[]", parent: name, max: 128)
                try validate($0, name: "configRuleNames[]", parent: name, min: 1)
                try validate($0, name: "configRuleNames[]", parent: name, pattern: ".*\\S.*")
            }
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, max: 25)
            try self.validate(self.configRuleNames, name: "configRuleNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleNames = "ConfigRuleNames"
        }
    }

    public struct StartConfigRulesEvaluationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartConfigurationRecorderRequest: AWSEncodableShape {
        /// The name of the recorder object that records each configuration change made to the resources.
        public let configurationRecorderName: String

        public init(configurationRecorderName: String) {
            self.configurationRecorderName = configurationRecorderName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, max: 256)
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorderName = "ConfigurationRecorderName"
        }
    }

    public struct StartRemediationExecutionRequest: AWSEncodableShape {
        /// The list of names of AWS Config rules that you want to run remediation execution for.
        public let configRuleName: String
        /// A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID.
        public let resourceKeys: [ResourceKey]

        public init(configRuleName: String, resourceKeys: [ResourceKey]) {
            self.configRuleName = configRuleName
            self.resourceKeys = resourceKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, max: 128)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, min: 1)
            try self.validate(self.configRuleName, name: "configRuleName", parent: name, pattern: ".*\\S.*")
            try self.resourceKeys.forEach {
                try $0.validate(name: "\(name).resourceKeys[]")
            }
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, max: 100)
            try self.validate(self.resourceKeys, name: "resourceKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configRuleName = "ConfigRuleName"
            case resourceKeys = "ResourceKeys"
        }
    }

    public struct StartRemediationExecutionResponse: AWSDecodableShape {
        /// For resources that have failed to start execution, the API returns a resource key object.
        public let failedItems: [ResourceKey]?
        /// Returns a failure message. For example, the resource is already compliant.
        public let failureMessage: String?

        public init(failedItems: [ResourceKey]? = nil, failureMessage: String? = nil) {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }

        private enum CodingKeys: String, CodingKey {
            case failedItems = "FailedItems"
            case failureMessage = "FailureMessage"
        }
    }

    public struct StaticValue: AWSEncodableShape & AWSDecodableShape {
        /// A list of values. For example, the ARN of the assumed role.
        public let values: [String]

        public init(values: [String]) {
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 256)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 25)
            try self.validate(self.values, name: "values", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct StatusDetailFilters: AWSEncodableShape {
        /// The 12-digit account ID of the member account within an organization.
        public let accountId: String?
        /// Indicates deployment status for config rule in the member account. When master account calls PutOrganizationConfigRule action for the first time, config rule status is created in the member account. When master account calls PutOrganizationConfigRule action for the second time, config rule status is updated in the member account. Config rule status is deleted when the master account deletes OrganizationConfigRule and disables service access for config-multiaccountsetup.amazonaws.com.  AWS Config sets the state of the rule to:    CREATE_SUCCESSFUL when config rule has been created in the member account.    CREATE_IN_PROGRESS when config rule is being created in the member account.    CREATE_FAILED when config rule creation has failed in the member account.    DELETE_FAILED when config rule deletion has failed in the member account.    DELETE_IN_PROGRESS when config rule is being deleted in the member account.    DELETE_SUCCESSFUL when config rule has been deleted in the member account.    UPDATE_SUCCESSFUL when config rule has been updated in the member account.    UPDATE_IN_PROGRESS when config rule is being updated in the member account.    UPDATE_FAILED when config rule deletion has failed in the member account.
        public let memberAccountRuleStatus: MemberAccountRuleStatus?

        public init(accountId: String? = nil, memberAccountRuleStatus: MemberAccountRuleStatus? = nil) {
            self.accountId = accountId
            self.memberAccountRuleStatus = memberAccountRuleStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\d{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case memberAccountRuleStatus = "MemberAccountRuleStatus"
        }
    }

    public struct StopConfigurationRecorderRequest: AWSEncodableShape {
        /// The name of the recorder object that records each configuration change made to the resources.
        public let configurationRecorderName: String

        public init(configurationRecorderName: String) {
            self.configurationRecorderName = configurationRecorderName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, max: 256)
            try self.validate(self.configurationRecorderName, name: "configurationRecorderName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationRecorderName = "ConfigurationRecorderName"
        }
    }

    public struct StoredQuery: AWSEncodableShape & AWSDecodableShape {
        /// A unique description for the query.
        public let description: String?
        /// The expression of the query. For example, SELECT resourceId, resourceType, supplementaryConfiguration.BucketVersioningConfiguration.status WHERE resourceType = 'AWS::S3::Bucket' AND supplementaryConfiguration.BucketVersioningConfiguration.status = 'Off'.
        public let expression: String?
        /// Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
        public let queryArn: String?
        /// The ID of the query.
        public let queryId: String?
        /// The name of the query.
        public let queryName: String

        public init(description: String? = nil, expression: String? = nil, queryArn: String? = nil, queryId: String? = nil, queryName: String) {
            self.description = description
            self.expression = expression
            self.queryArn = queryArn
            self.queryId = queryId
            self.queryName = queryName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\s\\S]*")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "[\\s\\S]*")
            try self.validate(self.queryArn, name: "queryArn", parent: name, max: 500)
            try self.validate(self.queryArn, name: "queryArn", parent: name, min: 1)
            try self.validate(self.queryArn, name: "queryArn", parent: name, pattern: "^arn:aws[a-z\\-]*:config:[a-z\\-\\d]+:\\d+:stored-query/[a-zA-Z0-9-_]+/query-[a-zA-Z\\d-_/]+$")
            try self.validate(self.queryId, name: "queryId", parent: name, max: 36)
            try self.validate(self.queryId, name: "queryId", parent: name, min: 1)
            try self.validate(self.queryId, name: "queryId", parent: name, pattern: "^\\S+$")
            try self.validate(self.queryName, name: "queryName", parent: name, max: 64)
            try self.validate(self.queryName, name: "queryName", parent: name, min: 1)
            try self.validate(self.queryName, name: "queryName", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case expression = "Expression"
            case queryArn = "QueryArn"
            case queryId = "QueryId"
            case queryName = "QueryName"
        }
    }

    public struct StoredQueryMetadata: AWSDecodableShape {
        /// A unique description for the query.
        public let description: String?
        /// Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
        public let queryArn: String
        /// The ID of the query.
        public let queryId: String
        /// The name of the query.
        public let queryName: String

        public init(description: String? = nil, queryArn: String, queryId: String, queryName: String) {
            self.description = description
            self.queryArn = queryArn
            self.queryId = queryId
            self.queryName = queryName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case queryArn = "QueryArn"
            case queryId = "QueryId"
            case queryName = "QueryName"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let key: String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are ConfigRule, ConfigurationAggregator and AggregatorAuthorization.
        public let resourceArn: String
        /// An array of tag object.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are ConfigRule, ConfigurationAggregator and AggregatorAuthorization.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }
}
