//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IoTEventsData {
    // MARK: Enums

    public enum AlarmStateName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case acknowledged = "ACKNOWLEDGED"
        case active = "ACTIVE"
        case disabled = "DISABLED"
        case latched = "LATCHED"
        case normal = "NORMAL"
        case snoozeDisabled = "SNOOZE_DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum ComparisonOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equal = "EQUAL"
        case greater = "GREATER"
        case greaterOrEqual = "GREATER_OR_EQUAL"
        case less = "LESS"
        case lessOrEqual = "LESS_OR_EQUAL"
        case notEqual = "NOT_EQUAL"
        public var description: String { return self.rawValue }
    }

    public enum CustomerActionName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case acknowledge = "ACKNOWLEDGE"
        case disable = "DISABLE"
        case enable = "ENABLE"
        case reset = "RESET"
        case snooze = "SNOOZE"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalFailureException = "InternalFailureException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        public var description: String { return self.rawValue }
    }

    public enum EventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case stateChange = "STATE_CHANGE"
        public var description: String { return self.rawValue }
    }

    public enum TriggerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case snoozeTimeout = "SNOOZE_TIMEOUT"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcknowledgeActionConfiguration: AWSDecodableShape {
        /// The note that you can leave when you acknowledge the alarm.
        public let note: String?

        public init(note: String? = nil) {
            self.note = note
        }

        private enum CodingKeys: String, CodingKey {
            case note = "note"
        }
    }

    public struct AcknowledgeAlarmActionRequest: AWSEncodableShape {
        /// The name of the alarm model.
        public let alarmModelName: String
        /// The value of the key used as a filter to select only the alarms associated with the
        /// key.
        public let keyValue: String?
        /// The note that you can leave when you acknowledge the alarm.
        public let note: String?
        /// The request ID. Each ID must be unique within each batch.
        public let requestId: String

        public init(alarmModelName: String, keyValue: String? = nil, note: String? = nil, requestId: String) {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyValue, name: "keyValue", parent: name, max: 128)
            try self.validate(self.keyValue, name: "keyValue", parent: name, min: 1)
            try self.validate(self.keyValue, name: "keyValue", parent: name, pattern: "^[a-zA-Z0-9\\-_:]+$")
            try self.validate(self.note, name: "note", parent: name, max: 256)
            try self.validate(self.requestId, name: "requestId", parent: name, max: 64)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelName = "alarmModelName"
            case keyValue = "keyValue"
            case note = "note"
            case requestId = "requestId"
        }
    }

    public struct Alarm: AWSDecodableShape {
        /// The name of the alarm model.
        public let alarmModelName: String?
        /// The version of the alarm model.
        public let alarmModelVersion: String?
        /// Contains information about the current state of the alarm.
        public let alarmState: AlarmState?
        /// The time the alarm was created, in the Unix epoch format.
        public let creationTime: Date?
        /// The value of the key used as a filter to select only the alarms associated with the
        /// key.
        public let keyValue: String?
        /// The time the alarm was last updated, in the Unix epoch format.
        public let lastUpdateTime: Date?
        /// A non-negative integer that reflects the severity level of the alarm.
        public let severity: Int?

        public init(alarmModelName: String? = nil, alarmModelVersion: String? = nil, alarmState: AlarmState? = nil, creationTime: Date? = nil, keyValue: String? = nil, lastUpdateTime: Date? = nil, severity: Int? = nil) {
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.alarmState = alarmState
            self.creationTime = creationTime
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.severity = severity
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelName = "alarmModelName"
            case alarmModelVersion = "alarmModelVersion"
            case alarmState = "alarmState"
            case creationTime = "creationTime"
            case keyValue = "keyValue"
            case lastUpdateTime = "lastUpdateTime"
            case severity = "severity"
        }
    }

    public struct AlarmState: AWSDecodableShape {
        /// Contains information about the action that you can take to respond to the alarm.
        public let customerAction: CustomerAction?
        /// Information needed to evaluate data.
        public let ruleEvaluation: RuleEvaluation?
        /// The name of the alarm state. The state name can be one of the following values:    DISABLED - When the alarm is in the DISABLED state,
        /// 		it isn't ready to evaluate data. To enable the alarm,
        /// 		you must change the alarm to the NORMAL state.    NORMAL - When the alarm is in the NORMAL state,
        /// 		it's ready to evaluate data.    ACTIVE - If the alarm is in the ACTIVE state,
        /// 		the alarm is invoked.    ACKNOWLEDGED - When the alarm is in the ACKNOWLEDGED state,
        /// 		the alarm was invoked and you acknowledged the alarm.    SNOOZE_DISABLED - When the alarm is in the SNOOZE_DISABLED state,
        /// 		the alarm is disabled for a specified period of time. After the snooze time,
        /// 		the alarm automatically changes to the NORMAL state.     LATCHED - When the alarm is in the LATCHED state,
        /// 		the alarm was invoked. However, the data that the alarm is currently evaluating is within the specified range.
        /// 		To change the alarm to the NORMAL state, you must acknowledge the alarm.
        public let stateName: AlarmStateName?
        /// Contains information about alarm state changes.
        public let systemEvent: SystemEvent?

        public init(customerAction: CustomerAction? = nil, ruleEvaluation: RuleEvaluation? = nil, stateName: AlarmStateName? = nil, systemEvent: SystemEvent? = nil) {
            self.customerAction = customerAction
            self.ruleEvaluation = ruleEvaluation
            self.stateName = stateName
            self.systemEvent = systemEvent
        }

        private enum CodingKeys: String, CodingKey {
            case customerAction = "customerAction"
            case ruleEvaluation = "ruleEvaluation"
            case stateName = "stateName"
            case systemEvent = "systemEvent"
        }
    }

    public struct AlarmSummary: AWSDecodableShape {
        /// The name of the alarm model.
        public let alarmModelName: String?
        /// The version of the alarm model.
        public let alarmModelVersion: String?
        /// The time the alarm was created, in the Unix epoch format.
        public let creationTime: Date?
        /// The value of the key used as a filter to select only the alarms associated with the
        /// key.
        public let keyValue: String?
        /// The time the alarm was last updated, in the Unix epoch format.
        public let lastUpdateTime: Date?
        /// The name of the alarm state. The state name can be one of the following values:    DISABLED - When the alarm is in the DISABLED state,
        /// 		it isn't ready to evaluate data. To enable the alarm,
        /// 		you must change the alarm to the NORMAL state.    NORMAL - When the alarm is in the NORMAL state,
        /// 		it's ready to evaluate data.    ACTIVE - If the alarm is in the ACTIVE state,
        /// 		the alarm is invoked.    ACKNOWLEDGED - When the alarm is in the ACKNOWLEDGED state,
        /// 		the alarm was invoked and you acknowledged the alarm.    SNOOZE_DISABLED - When the alarm is in the SNOOZE_DISABLED state,
        /// 		the alarm is disabled for a specified period of time. After the snooze time,
        /// 		the alarm automatically changes to the NORMAL state.     LATCHED - When the alarm is in the LATCHED state,
        /// 		the alarm was invoked. However, the data that the alarm is currently evaluating is within the specified range.
        /// 		To change the alarm to the NORMAL state, you must acknowledge the alarm.
        public let stateName: AlarmStateName?

        public init(alarmModelName: String? = nil, alarmModelVersion: String? = nil, creationTime: Date? = nil, keyValue: String? = nil, lastUpdateTime: Date? = nil, stateName: AlarmStateName? = nil) {
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.creationTime = creationTime
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.stateName = stateName
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelName = "alarmModelName"
            case alarmModelVersion = "alarmModelVersion"
            case creationTime = "creationTime"
            case keyValue = "keyValue"
            case lastUpdateTime = "lastUpdateTime"
            case stateName = "stateName"
        }
    }

    public struct BatchAcknowledgeAlarmRequest: AWSEncodableShape {
        /// The list of acknowledge action requests. You can specify up to 10 requests per operation.
        public let acknowledgeActionRequests: [AcknowledgeAlarmActionRequest]

        public init(acknowledgeActionRequests: [AcknowledgeAlarmActionRequest]) {
            self.acknowledgeActionRequests = acknowledgeActionRequests
        }

        public func validate(name: String) throws {
            try self.acknowledgeActionRequests.forEach {
                try $0.validate(name: "\(name).acknowledgeActionRequests[]")
            }
            try self.validate(self.acknowledgeActionRequests, name: "acknowledgeActionRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acknowledgeActionRequests = "acknowledgeActionRequests"
        }
    }

    public struct BatchAcknowledgeAlarmResponse: AWSDecodableShape {
        /// A list of errors associated with the request, or null if there are no errors.
        /// Each error entry contains an entry ID that helps you identify the entry that failed.
        public let errorEntries: [BatchAlarmActionErrorEntry]?

        public init(errorEntries: [BatchAlarmActionErrorEntry]? = nil) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
        }
    }

    public struct BatchAlarmActionErrorEntry: AWSDecodableShape {
        /// The error code.
        public let errorCode: ErrorCode?
        /// A message that describes the error.
        public let errorMessage: String?
        /// The request ID. Each ID must be unique within each batch.
        public let requestId: String?

        public init(errorCode: ErrorCode? = nil, errorMessage: String? = nil, requestId: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case requestId = "requestId"
        }
    }

    public struct BatchDeleteDetectorErrorEntry: AWSDecodableShape {
        /// The error code.
        public let errorCode: ErrorCode?
        /// A message that describes the error.
        public let errorMessage: String?
        /// The ID of the message that caused the error. (See the value of the "messageId" in the detectors object of the DeleteDetectorRequest.)
        public let messageId: String?

        public init(errorCode: ErrorCode? = nil, errorMessage: String? = nil, messageId: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case messageId = "messageId"
        }
    }

    public struct BatchDeleteDetectorRequest: AWSEncodableShape {
        /// The list of one or more detectors to be deleted.
        public let detectors: [DeleteDetectorRequest]

        public init(detectors: [DeleteDetectorRequest]) {
            self.detectors = detectors
        }

        public func validate(name: String) throws {
            try self.detectors.forEach {
                try $0.validate(name: "\(name).detectors[]")
            }
            try self.validate(self.detectors, name: "detectors", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectors = "detectors"
        }
    }

    public struct BatchDeleteDetectorResponse: AWSDecodableShape {
        /// A list of errors associated with the request, or an empty array ([]) if there are no errors. Each error entry contains a messageId that helps you identify the entry that failed.
        public let batchDeleteDetectorErrorEntries: [BatchDeleteDetectorErrorEntry]?

        public init(batchDeleteDetectorErrorEntries: [BatchDeleteDetectorErrorEntry]? = nil) {
            self.batchDeleteDetectorErrorEntries = batchDeleteDetectorErrorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case batchDeleteDetectorErrorEntries = "batchDeleteDetectorErrorEntries"
        }
    }

    public struct BatchDisableAlarmRequest: AWSEncodableShape {
        /// The list of disable action requests. You can specify up to 10 requests per operation.
        public let disableActionRequests: [DisableAlarmActionRequest]

        public init(disableActionRequests: [DisableAlarmActionRequest]) {
            self.disableActionRequests = disableActionRequests
        }

        public func validate(name: String) throws {
            try self.disableActionRequests.forEach {
                try $0.validate(name: "\(name).disableActionRequests[]")
            }
            try self.validate(self.disableActionRequests, name: "disableActionRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case disableActionRequests = "disableActionRequests"
        }
    }

    public struct BatchDisableAlarmResponse: AWSDecodableShape {
        /// A list of errors associated with the request, or null if there are no errors.
        /// Each error entry contains an entry ID that helps you identify the entry that failed.
        public let errorEntries: [BatchAlarmActionErrorEntry]?

        public init(errorEntries: [BatchAlarmActionErrorEntry]? = nil) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
        }
    }

    public struct BatchEnableAlarmRequest: AWSEncodableShape {
        /// The list of enable action requests. You can specify up to 10 requests per operation.
        public let enableActionRequests: [EnableAlarmActionRequest]

        public init(enableActionRequests: [EnableAlarmActionRequest]) {
            self.enableActionRequests = enableActionRequests
        }

        public func validate(name: String) throws {
            try self.enableActionRequests.forEach {
                try $0.validate(name: "\(name).enableActionRequests[]")
            }
            try self.validate(self.enableActionRequests, name: "enableActionRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case enableActionRequests = "enableActionRequests"
        }
    }

    public struct BatchEnableAlarmResponse: AWSDecodableShape {
        /// A list of errors associated with the request, or null if there are no errors.
        /// Each error entry contains an entry ID that helps you identify the entry that failed.
        public let errorEntries: [BatchAlarmActionErrorEntry]?

        public init(errorEntries: [BatchAlarmActionErrorEntry]? = nil) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
        }
    }

    public struct BatchPutMessageErrorEntry: AWSDecodableShape {
        /// The error code.
        public let errorCode: ErrorCode?
        /// A message that describes the error.
        public let errorMessage: String?
        /// The ID of the message that caused the error. (See the value corresponding to the "messageId" key in the "message" object.)
        public let messageId: String?

        public init(errorCode: ErrorCode? = nil, errorMessage: String? = nil, messageId: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case messageId = "messageId"
        }
    }

    public struct BatchPutMessageRequest: AWSEncodableShape {
        /// The list of messages to send. Each message has the following format: '{ "messageId": "string", "inputName": "string", "payload": "string"}'
        public let messages: [Message]

        public init(messages: [Message]) {
            self.messages = messages
        }

        public func validate(name: String) throws {
            try self.messages.forEach {
                try $0.validate(name: "\(name).messages[]")
            }
            try self.validate(self.messages, name: "messages", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case messages = "messages"
        }
    }

    public struct BatchPutMessageResponse: AWSDecodableShape {
        /// A list of any errors encountered when sending the messages.
        public let batchPutMessageErrorEntries: [BatchPutMessageErrorEntry]?

        public init(batchPutMessageErrorEntries: [BatchPutMessageErrorEntry]? = nil) {
            self.batchPutMessageErrorEntries = batchPutMessageErrorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case batchPutMessageErrorEntries = "BatchPutMessageErrorEntries"
        }
    }

    public struct BatchResetAlarmRequest: AWSEncodableShape {
        /// The list of reset action requests. You can specify up to 10 requests per operation.
        public let resetActionRequests: [ResetAlarmActionRequest]

        public init(resetActionRequests: [ResetAlarmActionRequest]) {
            self.resetActionRequests = resetActionRequests
        }

        public func validate(name: String) throws {
            try self.resetActionRequests.forEach {
                try $0.validate(name: "\(name).resetActionRequests[]")
            }
            try self.validate(self.resetActionRequests, name: "resetActionRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resetActionRequests = "resetActionRequests"
        }
    }

    public struct BatchResetAlarmResponse: AWSDecodableShape {
        /// A list of errors associated with the request, or null if there are no errors.
        /// Each error entry contains an entry ID that helps you identify the entry that failed.
        public let errorEntries: [BatchAlarmActionErrorEntry]?

        public init(errorEntries: [BatchAlarmActionErrorEntry]? = nil) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
        }
    }

    public struct BatchSnoozeAlarmRequest: AWSEncodableShape {
        /// The list of snooze action requests. You can specify up to 10 requests per operation.
        public let snoozeActionRequests: [SnoozeAlarmActionRequest]

        public init(snoozeActionRequests: [SnoozeAlarmActionRequest]) {
            self.snoozeActionRequests = snoozeActionRequests
        }

        public func validate(name: String) throws {
            try self.snoozeActionRequests.forEach {
                try $0.validate(name: "\(name).snoozeActionRequests[]")
            }
            try self.validate(self.snoozeActionRequests, name: "snoozeActionRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case snoozeActionRequests = "snoozeActionRequests"
        }
    }

    public struct BatchSnoozeAlarmResponse: AWSDecodableShape {
        /// A list of errors associated with the request, or null if there are no errors.
        /// Each error entry contains an entry ID that helps you identify the entry that failed.
        public let errorEntries: [BatchAlarmActionErrorEntry]?

        public init(errorEntries: [BatchAlarmActionErrorEntry]? = nil) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
        }
    }

    public struct BatchUpdateDetectorErrorEntry: AWSDecodableShape {
        /// The error code.
        public let errorCode: ErrorCode?
        /// A message that describes the error.
        public let errorMessage: String?
        /// The "messageId" of the update request that caused the error. (The value of the "messageId" in the update request "Detector" object.)
        public let messageId: String?

        public init(errorCode: ErrorCode? = nil, errorMessage: String? = nil, messageId: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case messageId = "messageId"
        }
    }

    public struct BatchUpdateDetectorRequest: AWSEncodableShape {
        /// The list of detectors (instances) to update, along with the values to update.
        public let detectors: [UpdateDetectorRequest]

        public init(detectors: [UpdateDetectorRequest]) {
            self.detectors = detectors
        }

        public func validate(name: String) throws {
            try self.detectors.forEach {
                try $0.validate(name: "\(name).detectors[]")
            }
            try self.validate(self.detectors, name: "detectors", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectors = "detectors"
        }
    }

    public struct BatchUpdateDetectorResponse: AWSDecodableShape {
        /// A list of those detector updates that resulted in errors. (If an error is listed here, the specific update did not occur.)
        public let batchUpdateDetectorErrorEntries: [BatchUpdateDetectorErrorEntry]?

        public init(batchUpdateDetectorErrorEntries: [BatchUpdateDetectorErrorEntry]? = nil) {
            self.batchUpdateDetectorErrorEntries = batchUpdateDetectorErrorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case batchUpdateDetectorErrorEntries = "batchUpdateDetectorErrorEntries"
        }
    }

    public struct CustomerAction: AWSDecodableShape {
        /// Contains the configuration information of an acknowledge action.
        public let acknowledgeActionConfiguration: AcknowledgeActionConfiguration?
        /// The name of the action. The action name can be one of the following values:    SNOOZE - When you snooze the alarm, the alarm state changes to SNOOZE_DISABLED.    ENABLE - When you enable the alarm, the alarm state changes to NORMAL.    DISABLE - When you disable the alarm, the alarm state changes to DISABLED.    ACKNOWLEDGE - When you acknowledge the alarm, the alarm state changes to ACKNOWLEDGED.    RESET - When you reset the alarm, the alarm state changes to NORMAL.   For more information, see the AlarmState API.
        public let actionName: CustomerActionName?
        /// Contains the configuration information of a disable action.
        public let disableActionConfiguration: DisableActionConfiguration?
        /// Contains the configuration information of an enable action.
        public let enableActionConfiguration: EnableActionConfiguration?
        /// Contains the configuration information of a reset action.
        public let resetActionConfiguration: ResetActionConfiguration?
        /// Contains the configuration information of a snooze action.
        public let snoozeActionConfiguration: SnoozeActionConfiguration?

        public init(acknowledgeActionConfiguration: AcknowledgeActionConfiguration? = nil, actionName: CustomerActionName? = nil, disableActionConfiguration: DisableActionConfiguration? = nil, enableActionConfiguration: EnableActionConfiguration? = nil, resetActionConfiguration: ResetActionConfiguration? = nil, snoozeActionConfiguration: SnoozeActionConfiguration? = nil) {
            self.acknowledgeActionConfiguration = acknowledgeActionConfiguration
            self.actionName = actionName
            self.disableActionConfiguration = disableActionConfiguration
            self.enableActionConfiguration = enableActionConfiguration
            self.resetActionConfiguration = resetActionConfiguration
            self.snoozeActionConfiguration = snoozeActionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case acknowledgeActionConfiguration = "acknowledgeActionConfiguration"
            case actionName = "actionName"
            case disableActionConfiguration = "disableActionConfiguration"
            case enableActionConfiguration = "enableActionConfiguration"
            case resetActionConfiguration = "resetActionConfiguration"
            case snoozeActionConfiguration = "snoozeActionConfiguration"
        }
    }

    public struct DeleteDetectorRequest: AWSEncodableShape {
        /// The name of the detector model that was used to create the detector instance.
        public let detectorModelName: String
        /// The value of the key used to identify the detector.
        public let keyValue: String?
        /// The ID to assign to the DeleteDetectorRequest. Each "messageId" must be unique within each batch sent.
        public let messageId: String

        public init(detectorModelName: String, keyValue: String? = nil, messageId: String) {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
            self.messageId = messageId
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, min: 1)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyValue, name: "keyValue", parent: name, max: 128)
            try self.validate(self.keyValue, name: "keyValue", parent: name, min: 1)
            try self.validate(self.keyValue, name: "keyValue", parent: name, pattern: "^[a-zA-Z0-9\\-_:]+$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 64)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModelName = "detectorModelName"
            case keyValue = "keyValue"
            case messageId = "messageId"
        }
    }

    public struct DescribeAlarmRequest: AWSEncodableShape {
        /// The name of the alarm model.
        public let alarmModelName: String
        /// The value of the key used as a filter to select only the alarms associated with the
        /// key.
        public let keyValue: String?

        public init(alarmModelName: String, keyValue: String? = nil) {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.alarmModelName, key: "alarmModelName")
            request.encodeQuery(self.keyValue, key: "keyValue")
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyValue, name: "keyValue", parent: name, max: 128)
            try self.validate(self.keyValue, name: "keyValue", parent: name, min: 1)
            try self.validate(self.keyValue, name: "keyValue", parent: name, pattern: "^[a-zA-Z0-9\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAlarmResponse: AWSDecodableShape {
        /// Contains information about an alarm.
        public let alarm: Alarm?

        public init(alarm: Alarm? = nil) {
            self.alarm = alarm
        }

        private enum CodingKeys: String, CodingKey {
            case alarm = "alarm"
        }
    }

    public struct DescribeDetectorRequest: AWSEncodableShape {
        /// The name of the detector model whose detectors (instances) you want information about.
        public let detectorModelName: String
        /// A filter used to limit results to detectors (instances) created because of the given key ID.
        public let keyValue: String?

        public init(detectorModelName: String, keyValue: String? = nil) {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorModelName, key: "detectorModelName")
            request.encodeQuery(self.keyValue, key: "keyValue")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, min: 1)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyValue, name: "keyValue", parent: name, max: 128)
            try self.validate(self.keyValue, name: "keyValue", parent: name, min: 1)
            try self.validate(self.keyValue, name: "keyValue", parent: name, pattern: "^[a-zA-Z0-9\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDetectorResponse: AWSDecodableShape {
        /// Information about the detector (instance).
        public let detector: Detector?

        public init(detector: Detector? = nil) {
            self.detector = detector
        }

        private enum CodingKeys: String, CodingKey {
            case detector = "detector"
        }
    }

    public struct Detector: AWSDecodableShape {
        /// The time the detector (instance) was created.
        public let creationTime: Date?
        /// The name of the detector model that created this detector (instance).
        public let detectorModelName: String?
        /// The version of the detector model that created this detector (instance).
        public let detectorModelVersion: String?
        /// The value of the key (identifying the device or system) that caused the creation of this detector (instance).
        public let keyValue: String?
        /// The time the detector (instance) was last updated.
        public let lastUpdateTime: Date?
        /// The current state of the detector (instance).
        public let state: DetectorState?

        public init(creationTime: Date? = nil, detectorModelName: String? = nil, detectorModelVersion: String? = nil, keyValue: String? = nil, lastUpdateTime: Date? = nil, state: DetectorState? = nil) {
            self.creationTime = creationTime
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case detectorModelName = "detectorModelName"
            case detectorModelVersion = "detectorModelVersion"
            case keyValue = "keyValue"
            case lastUpdateTime = "lastUpdateTime"
            case state = "state"
        }
    }

    public struct DetectorState: AWSDecodableShape {
        /// The name of the state.
        public let stateName: String
        /// The current state of the detector's timers.
        public let timers: [Timer]
        /// The current values of the detector's variables.
        public let variables: [Variable]

        public init(stateName: String, timers: [Timer], variables: [Variable]) {
            self.stateName = stateName
            self.timers = timers
            self.variables = variables
        }

        private enum CodingKeys: String, CodingKey {
            case stateName = "stateName"
            case timers = "timers"
            case variables = "variables"
        }
    }

    public struct DetectorStateDefinition: AWSEncodableShape {
        /// The name of the new state of the detector (instance).
        public let stateName: String
        /// The new values of the detector's timers. Any timer whose value isn't specified is cleared, and its timeout event won't occur.
        public let timers: [TimerDefinition]
        /// The new values of the detector's variables. Any variable whose value isn't specified is cleared.
        public let variables: [VariableDefinition]

        public init(stateName: String, timers: [TimerDefinition], variables: [VariableDefinition]) {
            self.stateName = stateName
            self.timers = timers
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.validate(self.stateName, name: "stateName", parent: name, max: 128)
            try self.validate(self.stateName, name: "stateName", parent: name, min: 1)
            try self.timers.forEach {
                try $0.validate(name: "\(name).timers[]")
            }
            try self.variables.forEach {
                try $0.validate(name: "\(name).variables[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case stateName = "stateName"
            case timers = "timers"
            case variables = "variables"
        }
    }

    public struct DetectorStateSummary: AWSDecodableShape {
        /// The name of the state.
        public let stateName: String?

        public init(stateName: String? = nil) {
            self.stateName = stateName
        }

        private enum CodingKeys: String, CodingKey {
            case stateName = "stateName"
        }
    }

    public struct DetectorSummary: AWSDecodableShape {
        /// The time the detector (instance) was created.
        public let creationTime: Date?
        /// The name of the detector model that created this detector (instance).
        public let detectorModelName: String?
        /// The version of the detector model that created this detector (instance).
        public let detectorModelVersion: String?
        /// The value of the key (identifying the device or system) that caused the creation of this detector (instance).
        public let keyValue: String?
        /// The time the detector (instance) was last updated.
        public let lastUpdateTime: Date?
        /// The current state of the detector (instance).
        public let state: DetectorStateSummary?

        public init(creationTime: Date? = nil, detectorModelName: String? = nil, detectorModelVersion: String? = nil, keyValue: String? = nil, lastUpdateTime: Date? = nil, state: DetectorStateSummary? = nil) {
            self.creationTime = creationTime
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case detectorModelName = "detectorModelName"
            case detectorModelVersion = "detectorModelVersion"
            case keyValue = "keyValue"
            case lastUpdateTime = "lastUpdateTime"
            case state = "state"
        }
    }

    public struct DisableActionConfiguration: AWSDecodableShape {
        /// The note that you can leave when you disable the alarm.
        public let note: String?

        public init(note: String? = nil) {
            self.note = note
        }

        private enum CodingKeys: String, CodingKey {
            case note = "note"
        }
    }

    public struct DisableAlarmActionRequest: AWSEncodableShape {
        /// The name of the alarm model.
        public let alarmModelName: String
        /// The value of the key used as a filter to select only the alarms associated with the
        /// key.
        public let keyValue: String?
        /// The note that you can leave when you disable the alarm.
        public let note: String?
        /// The request ID. Each ID must be unique within each batch.
        public let requestId: String

        public init(alarmModelName: String, keyValue: String? = nil, note: String? = nil, requestId: String) {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyValue, name: "keyValue", parent: name, max: 128)
            try self.validate(self.keyValue, name: "keyValue", parent: name, min: 1)
            try self.validate(self.keyValue, name: "keyValue", parent: name, pattern: "^[a-zA-Z0-9\\-_:]+$")
            try self.validate(self.note, name: "note", parent: name, max: 256)
            try self.validate(self.requestId, name: "requestId", parent: name, max: 64)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelName = "alarmModelName"
            case keyValue = "keyValue"
            case note = "note"
            case requestId = "requestId"
        }
    }

    public struct EnableActionConfiguration: AWSDecodableShape {
        /// The note that you can leave when you enable the alarm.
        public let note: String?

        public init(note: String? = nil) {
            self.note = note
        }

        private enum CodingKeys: String, CodingKey {
            case note = "note"
        }
    }

    public struct EnableAlarmActionRequest: AWSEncodableShape {
        /// The name of the alarm model.
        public let alarmModelName: String
        /// The value of the key used as a filter to select only the alarms associated with the
        /// key.
        public let keyValue: String?
        /// The note that you can leave when you enable the alarm.
        public let note: String?
        /// The request ID. Each ID must be unique within each batch.
        public let requestId: String

        public init(alarmModelName: String, keyValue: String? = nil, note: String? = nil, requestId: String) {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyValue, name: "keyValue", parent: name, max: 128)
            try self.validate(self.keyValue, name: "keyValue", parent: name, min: 1)
            try self.validate(self.keyValue, name: "keyValue", parent: name, pattern: "^[a-zA-Z0-9\\-_:]+$")
            try self.validate(self.note, name: "note", parent: name, max: 256)
            try self.validate(self.requestId, name: "requestId", parent: name, max: 64)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelName = "alarmModelName"
            case keyValue = "keyValue"
            case note = "note"
            case requestId = "requestId"
        }
    }

    public struct ListAlarmsRequest: AWSEncodableShape {
        /// The name of the alarm model.
        public let alarmModelName: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token that you can use to return the next set of results.
        public let nextToken: String?

        public init(alarmModelName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.alarmModelName = alarmModelName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.alarmModelName, key: "alarmModelName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAlarmsResponse: AWSDecodableShape {
        /// A list that summarizes each alarm.
        public let alarmSummaries: [AlarmSummary]?
        /// The token that you can use to return the next set of results,
        /// or null if there are no more results.
        public let nextToken: String?

        public init(alarmSummaries: [AlarmSummary]? = nil, nextToken: String? = nil) {
            self.alarmSummaries = alarmSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case alarmSummaries = "alarmSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDetectorsRequest: AWSEncodableShape {
        /// The name of the detector model whose detectors (instances) are listed.
        public let detectorModelName: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token that you can use to return the next set of results.
        public let nextToken: String?
        /// A filter that limits results to those detectors (instances) in the given state.
        public let stateName: String?

        public init(detectorModelName: String, maxResults: Int? = nil, nextToken: String? = nil, stateName: String? = nil) {
            self.detectorModelName = detectorModelName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.stateName = stateName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.detectorModelName, key: "detectorModelName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.stateName, key: "stateName")
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, min: 1)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.stateName, name: "stateName", parent: name, max: 128)
            try self.validate(self.stateName, name: "stateName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDetectorsResponse: AWSDecodableShape {
        /// A list of summary information about the detectors (instances).
        public let detectorSummaries: [DetectorSummary]?
        /// The token that you can use to return the next set of results,
        /// or null if there are no more results.
        public let nextToken: String?

        public init(detectorSummaries: [DetectorSummary]? = nil, nextToken: String? = nil) {
            self.detectorSummaries = detectorSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case detectorSummaries = "detectorSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct Message: AWSEncodableShape {
        /// The name of the input into which the message payload is transformed.
        public let inputName: String
        /// The ID to assign to the message. Within each batch sent, each "messageId" must be unique.
        public let messageId: String
        /// The payload of the message. This can be a JSON string or a Base-64-encoded string representing binary data (in which case you must decode it).
        public let payload: AWSBase64Data
        /// The timestamp associated with the message.
        public let timestamp: TimestampValue?

        public init(inputName: String, messageId: String, payload: AWSBase64Data, timestamp: TimestampValue? = nil) {
            self.inputName = inputName
            self.messageId = messageId
            self.payload = payload
            self.timestamp = timestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.inputName, name: "inputName", parent: name, max: 128)
            try self.validate(self.inputName, name: "inputName", parent: name, min: 1)
            try self.validate(self.inputName, name: "inputName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_.-]*$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 64)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.timestamp?.validate(name: "\(name).timestamp")
        }

        private enum CodingKeys: String, CodingKey {
            case inputName = "inputName"
            case messageId = "messageId"
            case payload = "payload"
            case timestamp = "timestamp"
        }
    }

    public struct ResetActionConfiguration: AWSDecodableShape {
        /// The note that you can leave when you reset the alarm.
        public let note: String?

        public init(note: String? = nil) {
            self.note = note
        }

        private enum CodingKeys: String, CodingKey {
            case note = "note"
        }
    }

    public struct ResetAlarmActionRequest: AWSEncodableShape {
        /// The name of the alarm model.
        public let alarmModelName: String
        /// The value of the key used as a filter to select only the alarms associated with the
        /// key.
        public let keyValue: String?
        /// The note that you can leave when you reset the alarm.
        public let note: String?
        /// The request ID. Each ID must be unique within each batch.
        public let requestId: String

        public init(alarmModelName: String, keyValue: String? = nil, note: String? = nil, requestId: String) {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyValue, name: "keyValue", parent: name, max: 128)
            try self.validate(self.keyValue, name: "keyValue", parent: name, min: 1)
            try self.validate(self.keyValue, name: "keyValue", parent: name, pattern: "^[a-zA-Z0-9\\-_:]+$")
            try self.validate(self.note, name: "note", parent: name, max: 256)
            try self.validate(self.requestId, name: "requestId", parent: name, max: 64)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelName = "alarmModelName"
            case keyValue = "keyValue"
            case note = "note"
            case requestId = "requestId"
        }
    }

    public struct RuleEvaluation: AWSDecodableShape {
        /// Information needed to compare two values with a comparison operator.
        public let simpleRuleEvaluation: SimpleRuleEvaluation?

        public init(simpleRuleEvaluation: SimpleRuleEvaluation? = nil) {
            self.simpleRuleEvaluation = simpleRuleEvaluation
        }

        private enum CodingKeys: String, CodingKey {
            case simpleRuleEvaluation = "simpleRuleEvaluation"
        }
    }

    public struct SimpleRuleEvaluation: AWSDecodableShape {
        /// The value of the input property, on the left side of the comparison operator.
        public let inputPropertyValue: String?
        /// The comparison operator.
        public let `operator`: ComparisonOperator?
        /// The threshold value, on the right side of the comparison operator.
        public let thresholdValue: String?

        public init(inputPropertyValue: String? = nil, operator: ComparisonOperator? = nil, thresholdValue: String? = nil) {
            self.inputPropertyValue = inputPropertyValue
            self.`operator` = `operator`
            self.thresholdValue = thresholdValue
        }

        private enum CodingKeys: String, CodingKey {
            case inputPropertyValue = "inputPropertyValue"
            case `operator` = "operator"
            case thresholdValue = "thresholdValue"
        }
    }

    public struct SnoozeActionConfiguration: AWSDecodableShape {
        /// The note that you can leave when you snooze the alarm.
        public let note: String?
        /// The snooze time in seconds. The alarm automatically changes to the NORMAL state after this duration.
        public let snoozeDuration: Int?

        public init(note: String? = nil, snoozeDuration: Int? = nil) {
            self.note = note
            self.snoozeDuration = snoozeDuration
        }

        private enum CodingKeys: String, CodingKey {
            case note = "note"
            case snoozeDuration = "snoozeDuration"
        }
    }

    public struct SnoozeAlarmActionRequest: AWSEncodableShape {
        /// The name of the alarm model.
        public let alarmModelName: String
        /// The value of the key used as a filter to select only the alarms associated with the
        /// key.
        public let keyValue: String?
        /// The note that you can leave when you snooze the alarm.
        public let note: String?
        /// The request ID. Each ID must be unique within each batch.
        public let requestId: String
        /// The snooze time in seconds. The alarm automatically changes to the NORMAL state after this duration.
        public let snoozeDuration: Int

        public init(alarmModelName: String, keyValue: String? = nil, note: String? = nil, requestId: String, snoozeDuration: Int) {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
            self.snoozeDuration = snoozeDuration
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, max: 128)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, min: 1)
            try self.validate(self.alarmModelName, name: "alarmModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyValue, name: "keyValue", parent: name, max: 128)
            try self.validate(self.keyValue, name: "keyValue", parent: name, min: 1)
            try self.validate(self.keyValue, name: "keyValue", parent: name, pattern: "^[a-zA-Z0-9\\-_:]+$")
            try self.validate(self.note, name: "note", parent: name, max: 256)
            try self.validate(self.requestId, name: "requestId", parent: name, max: 64)
            try self.validate(self.requestId, name: "requestId", parent: name, min: 1)
            try self.validate(self.requestId, name: "requestId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmModelName = "alarmModelName"
            case keyValue = "keyValue"
            case note = "note"
            case requestId = "requestId"
            case snoozeDuration = "snoozeDuration"
        }
    }

    public struct StateChangeConfiguration: AWSDecodableShape {
        /// The trigger type. If the value is SNOOZE_TIMEOUT, the snooze duration ends and the alarm automatically changes to the NORMAL state.
        public let triggerType: TriggerType?

        public init(triggerType: TriggerType? = nil) {
            self.triggerType = triggerType
        }

        private enum CodingKeys: String, CodingKey {
            case triggerType = "triggerType"
        }
    }

    public struct SystemEvent: AWSDecodableShape {
        /// The event type. If the value is STATE_CHANGE, the event contains information about alarm state changes.
        public let eventType: EventType?
        /// Contains the configuration information of alarm state changes.
        public let stateChangeConfiguration: StateChangeConfiguration?

        public init(eventType: EventType? = nil, stateChangeConfiguration: StateChangeConfiguration? = nil) {
            self.eventType = eventType
            self.stateChangeConfiguration = stateChangeConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case eventType = "eventType"
            case stateChangeConfiguration = "stateChangeConfiguration"
        }
    }

    public struct Timer: AWSDecodableShape {
        /// The name of the timer.
        public let name: String
        /// The expiration time for the timer.
        public let timestamp: Date

        public init(name: String, timestamp: Date) {
            self.name = name
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case timestamp = "timestamp"
        }
    }

    public struct TimerDefinition: AWSEncodableShape {
        /// The name of the timer.
        public let name: String
        /// The new setting of the timer (the number of seconds before the timer elapses).
        public let seconds: Int

        public init(name: String, seconds: Int) {
            self.name = name
            self.seconds = seconds
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case seconds = "seconds"
        }
    }

    public struct TimestampValue: AWSEncodableShape {
        /// The value of the timestamp, in the Unix epoch format.
        public let timeInMillis: Int64?

        public init(timeInMillis: Int64? = nil) {
            self.timeInMillis = timeInMillis
        }

        public func validate(name: String) throws {
            try self.validate(self.timeInMillis, name: "timeInMillis", parent: name, max: -9223372036854775808)
            try self.validate(self.timeInMillis, name: "timeInMillis", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case timeInMillis = "timeInMillis"
        }
    }

    public struct UpdateDetectorRequest: AWSEncodableShape {
        /// The name of the detector model that created the detectors (instances).
        public let detectorModelName: String
        /// The value of the input key attribute (identifying the device or system) that caused the creation of this detector (instance).
        public let keyValue: String?
        /// The ID to assign to the detector update "message". Each "messageId" must be unique within each batch sent.
        public let messageId: String
        /// The new state, variable values, and timer settings of the detector (instance).
        public let state: DetectorStateDefinition

        public init(detectorModelName: String, keyValue: String? = nil, messageId: String, state: DetectorStateDefinition) {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
            self.messageId = messageId
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, max: 128)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, min: 1)
            try self.validate(self.detectorModelName, name: "detectorModelName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyValue, name: "keyValue", parent: name, max: 128)
            try self.validate(self.keyValue, name: "keyValue", parent: name, min: 1)
            try self.validate(self.keyValue, name: "keyValue", parent: name, pattern: "^[a-zA-Z0-9\\-_:]+$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 64)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.state.validate(name: "\(name).state")
        }

        private enum CodingKeys: String, CodingKey {
            case detectorModelName = "detectorModelName"
            case keyValue = "keyValue"
            case messageId = "messageId"
            case state = "state"
        }
    }

    public struct Variable: AWSDecodableShape {
        /// The name of the variable.
        public let name: String
        /// The current value of the variable.
        public let value: String

        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct VariableDefinition: AWSEncodableShape {
        /// The name of the variable.
        public let name: String
        /// The new value of the variable.
        public let value: String

        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }
}

// MARK: - Errors

/// Error enum for IoTEventsData
public struct IoTEventsDataErrorType: AWSErrorType {
    enum Code: String {
        case internalFailureException = "InternalFailureException"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTEventsData
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An internal failure occurred.
    public static var internalFailureException: Self { .init(.internalFailureException) }
    /// The request was invalid.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// The resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service is currently unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The request could not be completed due to throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
}

extension IoTEventsDataErrorType: Equatable {
    public static func == (lhs: IoTEventsDataErrorType, rhs: IoTEventsDataErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTEventsDataErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
