//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Location {
    // MARK: Enums

    public enum BatchItemErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        /// Access to the resource was denied.
        case accessDeniedError = "AccessDeniedError"
        /// The target resource already exists.
        case conflictError = "ConflictError"
        /// Internal server error.
        case internalServerError = "InternalServerError"
        /// The target resource does not exist.
        case resourceNotFoundError = "ResourceNotFoundError"
        /// Too many requests.
        case throttlingError = "ThrottlingError"
        /// Input fails to satisfy the constraints specified by the service.
        case validationError = "ValidationError"
        public var description: String { return self.rawValue }
    }

    public enum DimensionUnit: String, CustomStringConvertible, Codable, _SotoSendable {
        case feet = "Feet"
        case meters = "Meters"
        public var description: String { return self.rawValue }
    }

    public enum DistanceUnit: String, CustomStringConvertible, Codable, _SotoSendable {
        case kilometers = "Kilometers"
        case miles = "Miles"
        public var description: String { return self.rawValue }
    }

    public enum IntendedUse: String, CustomStringConvertible, Codable, _SotoSendable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse = "SingleUse"
        /// Indicates that results of the operation may be stored locally.
        case storage = "Storage"
        public var description: String { return self.rawValue }
    }

    public enum PositionFiltering: String, CustomStringConvertible, Codable, _SotoSendable {
        /// Filters device position updates according to their accuracy
        case accuracyBased = "AccuracyBased"
        /// Filters device position updates according to the distance between them
        case distanceBased = "DistanceBased"
        /// Filters device position updates according to their sample time
        case timeBased = "TimeBased"
        public var description: String { return self.rawValue }
    }

    public enum PricingPlan: String, CustomStringConvertible, Codable, _SotoSendable {
        /// This pricing plan must be picked for mobile asset management use cases
        case mobileAssetManagement = "MobileAssetManagement"
        /// This pricing plan must be picked for mobile asset tracking use cases.
        case mobileAssetTracking = "MobileAssetTracking"
        /// This pricing plan should be used for request based billing.
        case requestBasedUsage = "RequestBasedUsage"
        public var description: String { return self.rawValue }
    }

    public enum RouteMatrixErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case departurePositionNotFound = "DeparturePositionNotFound"
        case destinationPositionNotFound = "DestinationPositionNotFound"
        case otherValidationError = "OtherValidationError"
        case positionsNotFound = "PositionsNotFound"
        case routeNotFound = "RouteNotFound"
        case routeTooLong = "RouteTooLong"
        public var description: String { return self.rawValue }
    }

    public enum TravelMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case car = "Car"
        case truck = "Truck"
        case walking = "Walking"
        public var description: String { return self.rawValue }
    }

    public enum VehicleWeightUnit: String, CustomStringConvertible, Codable, _SotoSendable {
        case kilograms = "Kilograms"
        case pounds = "Pounds"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateTrackerConsumerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker resource. Used when you need to specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
        public let consumerArn: String
        /// The name of the tracker resource to be associated with a geofence collection.
        public let trackerName: String

        public init(consumerArn: String, trackerName: String) {
            self.consumerArn = consumerArn
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, max: 1600)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case consumerArn = "ConsumerArn"
        }
    }

    public struct AssociateTrackerConsumerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct BatchDeleteDevicePositionHistoryError: AWSDecodableShape {
        /// The ID of the device for this position.
        public let deviceId: String
        public let error: BatchItemError

        public init(deviceId: String, error: BatchItemError) {
            self.deviceId = deviceId
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
        }
    }

    public struct BatchDeleteDevicePositionHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// Devices whose position history you want to delete.   For example, for two devices: “DeviceIds” : [DeviceId1,DeviceId2]
        public let deviceIds: [String]
        /// The name of the tracker resource to delete the device position history from.
        public let trackerName: String

        public init(deviceIds: [String], trackerName: String) {
            self.deviceIds = deviceIds
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.deviceIds.forEach {
                try validate($0, name: "deviceIds[]", parent: name, max: 100)
                try validate($0, name: "deviceIds[]", parent: name, min: 1)
                try validate($0, name: "deviceIds[]", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            }
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceIds = "DeviceIds"
        }
    }

    public struct BatchDeleteDevicePositionHistoryResponse: AWSDecodableShape {
        /// Contains error details for each device history that failed to delete.
        public let errors: [BatchDeleteDevicePositionHistoryError]

        public init(errors: [BatchDeleteDevicePositionHistoryError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteGeofenceError: AWSDecodableShape {
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// The geofence associated with the error message.
        public let geofenceId: String

        public init(error: BatchItemError, geofenceId: String) {
            self.error = error
            self.geofenceId = geofenceId
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case geofenceId = "GeofenceId"
        }
    }

    public struct BatchDeleteGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri("CollectionName"))
        ]

        /// The geofence collection storing the geofences to be deleted.
        public let collectionName: String
        /// The batch of geofences to be deleted.
        public let geofenceIds: [String]

        public init(collectionName: String, geofenceIds: [String]) {
            self.collectionName = collectionName
            self.geofenceIds = geofenceIds
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.geofenceIds.forEach {
                try validate($0, name: "geofenceIds[]", parent: name, max: 100)
                try validate($0, name: "geofenceIds[]", parent: name, min: 1)
                try validate($0, name: "geofenceIds[]", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case geofenceIds = "GeofenceIds"
        }
    }

    public struct BatchDeleteGeofenceResponse: AWSDecodableShape {
        /// Contains error details for each geofence that failed to delete.
        public let errors: [BatchDeleteGeofenceError]

        public init(errors: [BatchDeleteGeofenceError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchEvaluateGeofencesError: AWSDecodableShape {
        /// The device associated with the position evaluation error.
        public let deviceId: String
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// Specifies a timestamp for when the error occurred in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String, error: BatchItemError, sampleTime: Date) {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
            case sampleTime = "SampleTime"
        }
    }

    public struct BatchEvaluateGeofencesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri("CollectionName"))
        ]

        /// The geofence collection used in evaluating the position of devices against its geofences.
        public let collectionName: String
        /// Contains device details for each device to be evaluated against the given geofence collection.
        public let devicePositionUpdates: [DevicePositionUpdate]

        public init(collectionName: String, devicePositionUpdates: [DevicePositionUpdate]) {
            self.collectionName = collectionName
            self.devicePositionUpdates = devicePositionUpdates
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.devicePositionUpdates.forEach {
                try $0.validate(name: "\(name).devicePositionUpdates[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositionUpdates = "DevicePositionUpdates"
        }
    }

    public struct BatchEvaluateGeofencesResponse: AWSDecodableShape {
        /// Contains error details for each device that failed to evaluate its position against the given geofence collection.
        public let errors: [BatchEvaluateGeofencesError]

        public init(errors: [BatchEvaluateGeofencesError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchGetDevicePositionError: AWSDecodableShape {
        /// The ID of the device that didn't return a position.
        public let deviceId: String
        /// Contains details related to the error code.
        public let error: BatchItemError

        public init(deviceId: String, error: BatchItemError) {
            self.deviceId = deviceId
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
        }
    }

    public struct BatchGetDevicePositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// Devices whose position you want to retrieve.   For example, for two devices: device-ids=DeviceId1&amp;device-ids=DeviceId2
        public let deviceIds: [String]
        /// The tracker resource retrieving the device position.
        public let trackerName: String

        public init(deviceIds: [String], trackerName: String) {
            self.deviceIds = deviceIds
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.deviceIds.forEach {
                try validate($0, name: "deviceIds[]", parent: name, max: 100)
                try validate($0, name: "deviceIds[]", parent: name, min: 1)
                try validate($0, name: "deviceIds[]", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            }
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceIds = "DeviceIds"
        }
    }

    public struct BatchGetDevicePositionResponse: AWSDecodableShape {
        /// Contains device position details such as the device ID, position, and timestamps for when the position was received and sampled.
        public let devicePositions: [DevicePosition]
        /// Contains  error details for each device that failed to send its position to the tracker resource.
        public let errors: [BatchGetDevicePositionError]

        public init(devicePositions: [DevicePosition], errors: [BatchGetDevicePositionError]) {
            self.devicePositions = devicePositions
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositions = "DevicePositions"
            case errors = "Errors"
        }
    }

    public struct BatchItemError: AWSDecodableShape {
        /// The error code associated with the batch request error.
        public let code: BatchItemErrorCode?
        /// A message with the reason for the batch request error.
        public let message: String?

        public init(code: BatchItemErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct BatchPutGeofenceError: AWSDecodableShape {
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// The geofence associated with the error message.
        public let geofenceId: String

        public init(error: BatchItemError, geofenceId: String) {
            self.error = error
            self.geofenceId = geofenceId
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case geofenceId = "GeofenceId"
        }
    }

    public struct BatchPutGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri("CollectionName"))
        ]

        /// The geofence collection storing the geofences.
        public let collectionName: String
        /// The batch of geofences to be stored in a geofence collection.
        public let entries: [BatchPutGeofenceRequestEntry]

        public init(collectionName: String, entries: [BatchPutGeofenceRequestEntry]) {
            self.collectionName = collectionName
            self.entries = entries
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
        }
    }

    public struct BatchPutGeofenceRequestEntry: AWSEncodableShape {
        /// The identifier for the geofence to be stored in a given geofence collection.
        public let geofenceId: String
        /// Contains the details of the position of the geofence. Can be either a  polygon or a circle. Including both will return a validation error.  Each  geofence polygon can have a maximum of 1,000 vertices.
        public let geometry: GeofenceGeometry

        public init(geofenceId: String, geometry: GeofenceGeometry) {
            self.geofenceId = geofenceId
            self.geometry = geometry
        }

        public func validate(name: String) throws {
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case geofenceId = "GeofenceId"
            case geometry = "Geometry"
        }
    }

    public struct BatchPutGeofenceResponse: AWSDecodableShape {
        /// Contains additional error details for each geofence that failed to be stored in a geofence collection.
        public let errors: [BatchPutGeofenceError]
        /// Contains each geofence that was successfully stored in a geofence collection.
        public let successes: [BatchPutGeofenceSuccess]

        public init(errors: [BatchPutGeofenceError], successes: [BatchPutGeofenceSuccess]) {
            self.errors = errors
            self.successes = successes
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case successes = "Successes"
        }
    }

    public struct BatchPutGeofenceSuccess: AWSDecodableShape {
        /// The timestamp for when the geofence was stored in a geofence collection in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence successfully stored in a geofence collection.
        public let geofenceId: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case updateTime = "UpdateTime"
        }
    }

    public struct BatchUpdateDevicePositionError: AWSDecodableShape {
        /// The device associated with the failed location update.
        public let deviceId: String
        /// Contains details related to the error code such as the error code and error message.
        public let error: BatchItemError
        /// The timestamp at which the device position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String, error: BatchItemError, sampleTime: Date) {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
            case sampleTime = "SampleTime"
        }
    }

    public struct BatchUpdateDevicePositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// The name of the tracker resource to update.
        public let trackerName: String
        /// Contains the position update details for each device.
        public let updates: [DevicePositionUpdate]

        public init(trackerName: String, updates: [DevicePositionUpdate]) {
            self.trackerName = trackerName
            self.updates = updates
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
            try self.updates.forEach {
                try $0.validate(name: "\(name).updates[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case updates = "Updates"
        }
    }

    public struct BatchUpdateDevicePositionResponse: AWSDecodableShape {
        /// Contains  error details for each device that failed to update its position.
        public let errors: [BatchUpdateDevicePositionError]

        public init(errors: [BatchUpdateDevicePositionError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct CalculateRouteCarModeOptions: AWSEncodableShape {
        /// Avoids ferries when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidFerries: Bool?
        /// Avoids tolls when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidTolls: Bool?

        public init(avoidFerries: Bool? = nil, avoidTolls: Bool? = nil) {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
        }

        private enum CodingKeys: String, CodingKey {
            case avoidFerries = "AvoidFerries"
            case avoidTolls = "AvoidTolls"
        }
    }

    public struct CalculateRouteMatrixRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "calculatorName", location: .uri("CalculatorName"))
        ]

        /// The name of the route calculator resource that you want to use to calculate the route matrix.
        public let calculatorName: String
        /// Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
        public let carModeOptions: CalculateRouteCarModeOptions?
        /// Sets the time of departure as the current time. Uses the current time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix. Default Value: false  Valid Values: false | true
        public let departNow: Bool?
        /// The list of departure (origin) positions for the route matrix. An array of points, each of which is itself a 2-value array defined in WGS 84 format: [longitude, latitude]. For example, [-123.115, 49.285].  Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See  Position restrictions in the Amazon Location Service Developer Guide.   For route calculators that use Esri as the data provider, if you specify a departure that's not located on a road, Amazon Location  moves the position to the nearest road. The snapped value is available in the result in SnappedDeparturePositions.  Valid Values: [-180 to 180,-90 to 90]
        public let departurePositions: [[Double]]
        /// Specifies the desired time of departure. Uses the given time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix.  Setting a departure time in the past returns a 400 ValidationException error.    In ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
        @OptionalCustomCoding<ISO8601DateCoder>
        public var departureTime: Date?
        /// The list of destination positions for the route matrix. An array of points, each of which is itself a 2-value array defined in WGS 84 format: [longitude, latitude]. For example, [-122.339, 47.615]   Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See  Position restrictions in the Amazon Location Service Developer Guide.   For route calculators that use Esri as the data provider, if you specify a destination that's not located on a road, Amazon Location  moves the position to the nearest road. The snapped value is available in the result in SnappedDestinationPositions.  Valid Values: [-180 to 180,-90 to 90]
        public let destinationPositions: [[Double]]
        /// Set the unit system to specify the distance. Default Value: Kilometers
        public let distanceUnit: DistanceUnit?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. The TravelMode you specify also determines how you specify route preferences:    If traveling by Car use the CarModeOptions parameter.   If traveling by Truck use the TruckModeOptions parameter.   Default Value: Car
        public let travelMode: TravelMode?
        /// Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
        public let truckModeOptions: CalculateRouteTruckModeOptions?

        public init(calculatorName: String, carModeOptions: CalculateRouteCarModeOptions? = nil, departNow: Bool? = nil, departurePositions: [[Double]], departureTime: Date? = nil, destinationPositions: [[Double]], distanceUnit: DistanceUnit? = nil, travelMode: TravelMode? = nil, truckModeOptions: CalculateRouteTruckModeOptions? = nil) {
            self.calculatorName = calculatorName
            self.carModeOptions = carModeOptions
            self.departNow = departNow
            self.departurePositions = departurePositions
            self.departureTime = departureTime
            self.destinationPositions = destinationPositions
            self.distanceUnit = distanceUnit
            self.travelMode = travelMode
            self.truckModeOptions = truckModeOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
            try self.departurePositions.forEach {
                try validate($0, name: "departurePositions[]", parent: name, max: 2)
                try validate($0, name: "departurePositions[]", parent: name, min: 2)
            }
            try self.destinationPositions.forEach {
                try validate($0, name: "destinationPositions[]", parent: name, max: 2)
                try validate($0, name: "destinationPositions[]", parent: name, min: 2)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case carModeOptions = "CarModeOptions"
            case departNow = "DepartNow"
            case departurePositions = "DeparturePositions"
            case departureTime = "DepartureTime"
            case destinationPositions = "DestinationPositions"
            case distanceUnit = "DistanceUnit"
            case travelMode = "TravelMode"
            case truckModeOptions = "TruckModeOptions"
        }
    }

    public struct CalculateRouteMatrixResponse: AWSDecodableShape {
        /// The calculated route matrix containing the results for all pairs of DeparturePositions to DestinationPositions. Each row corresponds to one entry in DeparturePositions. Each entry in the row corresponds to the route from that entry in DeparturePositions to an entry in DestinationPositions.
        public let routeMatrix: [[RouteMatrixEntry]]
        /// For routes calculated using an Esri route calculator resource, departure positions are snapped to the closest road. For Esri route calculator resources, this returns the list of departure/origin positions used for calculation of the RouteMatrix.
        public let snappedDeparturePositions: [[Double]]?
        /// The list of destination positions for the route matrix used for calculation of the RouteMatrix.
        public let snappedDestinationPositions: [[Double]]?
        /// Contains information about the route matrix, DataSource, DistanceUnit, RouteCount and ErrorCount.
        public let summary: CalculateRouteMatrixSummary

        public init(routeMatrix: [[RouteMatrixEntry]], snappedDeparturePositions: [[Double]]? = nil, snappedDestinationPositions: [[Double]]? = nil, summary: CalculateRouteMatrixSummary) {
            self.routeMatrix = routeMatrix
            self.snappedDeparturePositions = snappedDeparturePositions
            self.snappedDestinationPositions = snappedDestinationPositions
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case routeMatrix = "RouteMatrix"
            case snappedDeparturePositions = "SnappedDeparturePositions"
            case snappedDestinationPositions = "SnappedDestinationPositions"
            case summary = "Summary"
        }
    }

    public struct CalculateRouteMatrixSummary: AWSDecodableShape {
        /// The data provider of traffic and road network data used to calculate the routes. Indicates one of the available providers:    Esri     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The unit of measurement for route distances.
        public let distanceUnit: DistanceUnit
        /// The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.
        public let errorCount: Int
        /// The count of cells in the route matrix. Equal to the number of DeparturePositions multiplied by the number of DestinationPositions.
        public let routeCount: Int

        public init(dataSource: String, distanceUnit: DistanceUnit, errorCount: Int, routeCount: Int) {
            self.dataSource = dataSource
            self.distanceUnit = distanceUnit
            self.errorCount = errorCount
            self.routeCount = routeCount
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case distanceUnit = "DistanceUnit"
            case errorCount = "ErrorCount"
            case routeCount = "RouteCount"
        }
    }

    public struct CalculateRouteRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "calculatorName", location: .uri("CalculatorName"))
        ]

        /// The name of the route calculator resource that you want to use to calculate the route.
        public let calculatorName: String
        /// Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
        public let carModeOptions: CalculateRouteCarModeOptions?
        /// Sets the time of departure as the current time. Uses the current time to calculate a route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route. Default Value: false  Valid Values: false | true
        public let departNow: Bool?
        /// The start position for the route. Defined in World Geodetic System (WGS 84) format: [longitude, latitude].   For example, [-123.115, 49.285]     If you specify a departure that's not located on a road, Amazon Location moves the position to the nearest road. If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error.  Valid Values: [-180 to 180,-90 to 90]
        public let departurePosition: [Double]
        /// Specifies the desired time of departure. Uses the given time to calculate the route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.  Setting a departure time in the past returns a 400 ValidationException error.    In ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
        @OptionalCustomCoding<ISO8601DateCoder>
        public var departureTime: Date?
        /// The finish position for the route. Defined in World Geodetic System (WGS 84) format: [longitude, latitude].   For example, [-122.339, 47.615]     If you specify a destination that's not located on a road, Amazon Location moves the position to the nearest road.   Valid Values: [-180 to 180,-90 to 90]
        public let destinationPosition: [Double]
        /// Set the unit system to specify the distance. Default Value: Kilometers
        public let distanceUnit: DistanceUnit?
        /// Set to include the geometry details in the result for each path between a pair of positions. Default Value: false  Valid Values: false | true
        public let includeLegGeometry: Bool?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. You can choose Car, Truck,  or Walking as options for the TravelMode. The TravelMode you specify also determines how you specify route preferences:    If traveling by Car use the CarModeOptions parameter.   If traveling by Truck use the TruckModeOptions parameter.   Default Value: Car
        public let travelMode: TravelMode?
        /// Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
        public let truckModeOptions: CalculateRouteTruckModeOptions?
        /// Specifies an ordered list of up to 23 intermediate positions to include along a route between the departure position and destination position.    For example, from the DeparturePosition [-123.115, 49.285], the route follows the order that the waypoint positions are given [[-122.757, 49.0021],[-122.349, 47.620]]     If you specify a waypoint position that's not located on a road, Amazon Location moves the position to the nearest road.  Specifying more than 23 waypoints returns a 400 ValidationException error. If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error.  Valid Values: [-180 to 180,-90 to 90]
        public let waypointPositions: [[Double]]?

        public init(calculatorName: String, carModeOptions: CalculateRouteCarModeOptions? = nil, departNow: Bool? = nil, departurePosition: [Double], departureTime: Date? = nil, destinationPosition: [Double], distanceUnit: DistanceUnit? = nil, includeLegGeometry: Bool? = nil, travelMode: TravelMode? = nil, truckModeOptions: CalculateRouteTruckModeOptions? = nil, waypointPositions: [[Double]]? = nil) {
            self.calculatorName = calculatorName
            self.carModeOptions = carModeOptions
            self.departNow = departNow
            self.departurePosition = departurePosition
            self.departureTime = departureTime
            self.destinationPosition = destinationPosition
            self.distanceUnit = distanceUnit
            self.includeLegGeometry = includeLegGeometry
            self.travelMode = travelMode
            self.truckModeOptions = truckModeOptions
            self.waypointPositions = waypointPositions
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.departurePosition, name: "departurePosition", parent: name, max: 2)
            try self.validate(self.departurePosition, name: "departurePosition", parent: name, min: 2)
            try self.validate(self.destinationPosition, name: "destinationPosition", parent: name, max: 2)
            try self.validate(self.destinationPosition, name: "destinationPosition", parent: name, min: 2)
            try self.waypointPositions?.forEach {
                try validate($0, name: "waypointPositions[]", parent: name, max: 2)
                try validate($0, name: "waypointPositions[]", parent: name, min: 2)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case carModeOptions = "CarModeOptions"
            case departNow = "DepartNow"
            case departurePosition = "DeparturePosition"
            case departureTime = "DepartureTime"
            case destinationPosition = "DestinationPosition"
            case distanceUnit = "DistanceUnit"
            case includeLegGeometry = "IncludeLegGeometry"
            case travelMode = "TravelMode"
            case truckModeOptions = "TruckModeOptions"
            case waypointPositions = "WaypointPositions"
        }
    }

    public struct CalculateRouteResponse: AWSDecodableShape {
        /// Contains details about each path between a pair of positions included along a route such as: StartPosition, EndPosition, Distance, DurationSeconds, Geometry, and Steps. The number of legs returned corresponds to one fewer than the total number of positions in the request.  For example, a route with a departure position and destination position returns one leg with the positions snapped to a nearby road:   The StartPosition is the departure position.   The EndPosition is the destination position.   A route with a waypoint between the departure and destination position returns two legs with the positions snapped to a nearby road:   Leg 1: The StartPosition is the departure position . The EndPosition is the waypoint positon.   Leg 2: The StartPosition is the waypoint position. The EndPosition is the destination position.
        public let legs: [Leg]
        /// Contains information about the whole route, such as: RouteBBox, DataSource, Distance, DistanceUnit, and DurationSeconds.
        public let summary: CalculateRouteSummary

        public init(legs: [Leg], summary: CalculateRouteSummary) {
            self.legs = legs
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case legs = "Legs"
            case summary = "Summary"
        }
    }

    public struct CalculateRouteSummary: AWSDecodableShape {
        /// The data provider of traffic and road network data used to calculate the route. Indicates one of the available providers:    Esri     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The total distance covered by the route. The sum of the distance travelled between every stop on the route.  If Esri is the data source for the route calculator, the route distance can’t be greater than 400 km. If the route exceeds 400 km, the response is a 400 RoutesValidationException error.
        public let distance: Double
        /// The unit of measurement for route distances.
        public let distanceUnit: DistanceUnit
        /// The total travel time for the route measured in seconds. The sum of the travel time between every stop on the route.
        public let durationSeconds: Double
        /// Specifies a geographical box surrounding a route. Used to zoom into a route when displaying it in a map. For example, [min x, min y, max x, max y]. The first 2 bbox parameters describe the lower southwest corner:    The first bbox position is the X coordinate or longitude of the lower southwest corner.    The second bbox position is the Y coordinate or latitude of the lower southwest corner.    The next 2 bbox parameters describe the upper northeast corner:    The third bbox position is the X coordinate, or longitude of the upper northeast corner.    The fourth bbox position is the Y coordinate, or latitude of the upper northeast corner.
        public let routeBBox: [Double]

        public init(dataSource: String, distance: Double, distanceUnit: DistanceUnit, durationSeconds: Double, routeBBox: [Double]) {
            self.dataSource = dataSource
            self.distance = distance
            self.distanceUnit = distanceUnit
            self.durationSeconds = durationSeconds
            self.routeBBox = routeBBox
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case distance = "Distance"
            case distanceUnit = "DistanceUnit"
            case durationSeconds = "DurationSeconds"
            case routeBBox = "RouteBBox"
        }
    }

    public struct CalculateRouteTruckModeOptions: AWSEncodableShape {
        /// Avoids ferries when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidFerries: Bool?
        /// Avoids tolls when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidTolls: Bool?
        /// Specifies the truck's dimension specifications including length, height, width, and unit of measurement. Used to avoid roads that can't support the truck's dimensions.
        public let dimensions: TruckDimensions?
        /// Specifies the truck's weight specifications including total weight and unit of measurement. Used to avoid roads that can't support the truck's weight.
        public let weight: TruckWeight?

        public init(avoidFerries: Bool? = nil, avoidTolls: Bool? = nil, dimensions: TruckDimensions? = nil, weight: TruckWeight? = nil) {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
            self.dimensions = dimensions
            self.weight = weight
        }

        private enum CodingKeys: String, CodingKey {
            case avoidFerries = "AvoidFerries"
            case avoidTolls = "AvoidTolls"
            case dimensions = "Dimensions"
            case weight = "Weight"
        }
    }

    public struct Circle: AWSEncodableShape & AWSDecodableShape {
        /// A single point geometry, specifying the center of the circle, using WGS 84 coordinates, in the form [longitude, latitude].
        public let center: [Double]
        /// The radius of the circle in meters. Must be greater than zero and no  larger than 100,000 (100 kilometers).
        public let radius: Double

        public init(center: [Double], radius: Double) {
            self.center = center
            self.radius = radius
        }

        public func validate(name: String) throws {
            try self.validate(self.center, name: "center", parent: name, max: 2)
            try self.validate(self.center, name: "center", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case center = "Center"
            case radius = "Radius"
        }
    }

    public struct CreateGeofenceCollectionRequest: AWSEncodableShape {
        /// A custom name for the geofence collection. Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).    Must be a unique geofence collection name.   No spaces allowed. For example, ExampleGeofenceCollection.
        public let collectionName: String
        /// An optional description for the geofence collection.
        public let description: String?
        /// A key identifier for an AWS KMS customer managed key. Enter a key ID, key ARN, alias name, or alias ARN.
        ///
        public let kmsKeyId: String?
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// This parameter is no longer used.
        public let pricingPlanDataSource: String?
        /// Applies one or more tags to the geofence collection. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]?

        public init(collectionName: String, description: String? = nil, kmsKeyId: String? = nil, tags: [String: String]? = nil) {
            self.collectionName = collectionName
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = tags
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        public init(collectionName: String, description: String? = nil, kmsKeyId: String? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil) {
            self.collectionName = collectionName
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "CollectionName"
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
        }
    }

    public struct CreateGeofenceCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all AWS.    Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
        public let collectionArn: String
        /// The name for the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date

        public init(collectionArn: String, collectionName: String, createTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.createTime = createTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
        }
    }

    public struct CreateMapRequest: AWSEncodableShape {
        /// Specifies the MapConfiguration, including the map style, for the  map resource that you create. The map style defines the look of maps and the data  provider for your map resource.
        public let configuration: MapConfiguration
        /// An optional description for the map resource.
        public let description: String?
        /// The name for the map resource. Requirements:   Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).    Must be a unique map resource name.    No spaces allowed. For example, ExampleMap.
        public let mapName: String
        /// No longer used. If included, the only allowed value is  RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Applies one or more tags to the map resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length:  256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]?

        public init(configuration: MapConfiguration, description: String? = nil, mapName: String, tags: [String: String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.mapName = mapName
            self.pricingPlan = nil
            self.tags = tags
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(configuration: MapConfiguration, description: String? = nil, mapName: String, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case description = "Description"
            case mapName = "MapName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
        }
    }

    public struct CreateMapResponse: AWSDecodableShape {
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:map/ExampleMap
        public let mapArn: String
        /// The name of the map resource.
        public let mapName: String

        public init(createTime: Date, mapArn: String, mapName: String) {
            self.createTime = createTime
            self.mapArn = mapArn
            self.mapName = mapName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case mapArn = "MapArn"
            case mapName = "MapName"
        }
    }

    public struct CreatePlaceIndexRequest: AWSEncodableShape {
        /// Specifies the geospatial data provider for the new place index.  This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error.  Valid values include:    Esri – For additional information about Esri's coverage in your region of interest, see Esri details on geocoding coverage.    Here – For additional information about HERE Technologies' coverage in your region of interest, see HERE details on goecoding coverage.  If you specify HERE Technologies (Here) as the data provider, you may not store results for locations in Japan. For more information, see the AWS Service Terms for Amazon Location Service.    For additional information , see Data providers on the Amazon Location Service Developer Guide.
        public let dataSource: String
        /// Specifies the data storage option requesting Places.
        public let dataSourceConfiguration: DataSourceConfiguration?
        /// The optional description for the place index resource.
        public let description: String?
        /// The name of the place index resource.  Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).   Must be a unique place index resource name.   No spaces allowed. For example, ExamplePlaceIndex.
        public let indexName: String
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Applies one or more tags to the place index resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource.   Each tag key must be unique and must have exactly one associated value.   Maximum key length: 128 Unicode characters in UTF-8.   Maximum value length: 256 Unicode characters in UTF-8.   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @   Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]?

        public init(dataSource: String, dataSourceConfiguration: DataSourceConfiguration? = nil, description: String? = nil, indexName: String, tags: [String: String]? = nil) {
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexName = indexName
            self.pricingPlan = nil
            self.tags = tags
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(dataSource: String, dataSourceConfiguration: DataSourceConfiguration? = nil, description: String? = nil, indexName: String, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil) {
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case dataSourceConfiguration = "DataSourceConfiguration"
            case description = "Description"
            case indexName = "IndexName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
        }
    }

    public struct CreatePlaceIndexResponse: AWSDecodableShape {
        /// The timestamp for when the place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across AWS.    Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
        public let indexArn: String
        /// The name for the place index resource.
        public let indexName: String

        public init(createTime: Date, indexArn: String, indexName: String) {
            self.createTime = createTime
            self.indexArn = indexArn
            self.indexName = indexName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case indexArn = "IndexArn"
            case indexName = "IndexName"
        }
    }

    public struct CreateRouteCalculatorRequest: AWSEncodableShape {
        /// The name of the route calculator resource.  Requirements:   Can use alphanumeric characters (A–Z, a–z, 0–9) , hyphens (-), periods (.), and underscores (_).   Must be a unique Route calculator resource name.   No spaces allowed. For example, ExampleRouteCalculator.
        public let calculatorName: String
        /// Specifies the data provider of traffic and road network data.  This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error. Route calculators that use Esri as a data source only calculate routes that are shorter than 400 km.  Valid values include:    Esri – For additional information about Esri's coverage in your region of interest, see Esri details on street networks and traffic coverage.    Here – For additional information about HERE Technologies' coverage in your region of interest, see HERE car routing coverage and HERE truck routing coverage.   For additional information , see Data providers on the Amazon Location Service Developer Guide.
        public let dataSource: String
        /// The optional description for the route calculator resource.
        public let description: String?
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Applies one or more tags to the route calculator resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.   For example: { "tag1" : "value1", "tag2" : "value2"}   Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]?

        public init(calculatorName: String, dataSource: String, description: String? = nil, tags: [String: String]? = nil) {
            self.calculatorName = calculatorName
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = nil
            self.tags = tags
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(calculatorName: String, dataSource: String, description: String? = nil, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil) {
            self.calculatorName = calculatorName
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorName = "CalculatorName"
            case dataSource = "DataSource"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
        }
    }

    public struct CreateRouteCalculatorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the route calculator resource. Use the ARN when you specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
        public let calculatorArn: String
        /// The name of the route calculator resource.    For example, ExampleRouteCalculator.
        public let calculatorName: String
        /// The timestamp when the route calculator resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date

        public init(calculatorArn: String, calculatorName: String, createTime: Date) {
            self.calculatorArn = calculatorArn
            self.calculatorName = calculatorName
            self.createTime = createTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorArn = "CalculatorArn"
            case calculatorName = "CalculatorName"
            case createTime = "CreateTime"
        }
    }

    public struct CreateTrackerRequest: AWSEncodableShape {
        /// An optional description for the tracker resource.
        public let description: String?
        /// A key identifier for an AWS KMS customer managed key. Enter a key ID, key ARN, alias name, or alias ARN.
        public let kmsKeyId: String?
        /// Specifies the position filtering for the tracker resource. Valid values:    TimeBased - Location updates are evaluated against linked geofence collections,  but not every location update is stored. If your update frequency is more often than 30 seconds,  only one update per 30 seconds is stored for each unique device ID.     DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are  ignored. Location updates within this area are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.     AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This can reduce the effects of GPS noise when displaying device trajectories on a map, and can help control your costs by reducing the number of geofence evaluations.    This field is optional. If not specified, the default value is TimeBased.
        public let positionFiltering: PositionFiltering?
        /// No longer used. If included, the only allowed value is  RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// This parameter is no longer used.
        public let pricingPlanDataSource: String?
        /// Applies one or more tags to the tracker resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]?
        /// The name for the tracker resource. Requirements:   Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).   Must be a unique tracker resource name.   No spaces allowed. For example, ExampleTracker.
        public let trackerName: String

        public init(description: String? = nil, kmsKeyId: String? = nil, positionFiltering: PositionFiltering? = nil, tags: [String: String]? = nil, trackerName: String) {
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.positionFiltering = positionFiltering
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = tags
            self.trackerName = trackerName
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        public init(description: String? = nil, kmsKeyId: String? = nil, positionFiltering: PositionFiltering? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil, trackerName: String) {
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.positionFiltering = positionFiltering
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case positionFiltering = "PositionFiltering"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
            case trackerName = "TrackerName"
        }
    }

    public struct CreateTrackerResponse: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
        public let trackerArn: String
        /// The name of the tracker resource.
        public let trackerName: String

        public init(createTime: Date, trackerArn: String, trackerName: String) {
            self.createTime = createTime
            self.trackerArn = trackerArn
            self.trackerName = trackerName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case trackerArn = "TrackerArn"
            case trackerName = "TrackerName"
        }
    }

    public struct DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how the results of an operation will be stored by the caller.  Valid values include:    SingleUse specifies that the results won't be stored.     Storage specifies that the result can be cached or stored in a database.   Default value: SingleUse
        public let intendedUse: IntendedUse?

        public init(intendedUse: IntendedUse? = nil) {
            self.intendedUse = intendedUse
        }

        private enum CodingKeys: String, CodingKey {
            case intendedUse = "IntendedUse"
        }
    }

    public struct DeleteGeofenceCollectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri("CollectionName"))
        ]

        /// The name of the geofence collection to be deleted.
        public let collectionName: String

        public init(collectionName: String) {
            self.collectionName = collectionName
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGeofenceCollectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMapRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri("MapName"))
        ]

        /// The name of the map resource to be deleted.
        public let mapName: String

        public init(mapName: String) {
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMapResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePlaceIndexRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri("IndexName"))
        ]

        /// The name of the place index resource to be deleted.
        public let indexName: String

        public init(indexName: String) {
            self.indexName = indexName
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePlaceIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRouteCalculatorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "calculatorName", location: .uri("CalculatorName"))
        ]

        /// The name of the route calculator resource to be deleted.
        public let calculatorName: String

        public init(calculatorName: String) {
            self.calculatorName = calculatorName
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRouteCalculatorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTrackerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// The name of the tracker resource to be deleted.
        public let trackerName: String

        public init(trackerName: String) {
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTrackerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeGeofenceCollectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri("CollectionName"))
        ]

        /// The name of the geofence collection.
        public let collectionName: String

        public init(collectionName: String) {
            self.collectionName = collectionName
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGeofenceCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all AWS.    Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
        public let collectionArn: String
        /// The name of the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The optional description for the geofence collection.
        public let description: String
        /// A key identifier for an AWS KMS customer managed key assigned to the Amazon Location resource
        public let kmsKeyId: String?
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// No longer used. Always returns an empty string.
        public let pricingPlanDataSource: String?
        /// Displays the key, value pairs of tags associated with this resource.
        public let tags: [String: String]?
        /// The timestamp for when the geofence collection was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(collectionArn: String, collectionName: String, createTime: Date, description: String, kmsKeyId: String? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = tags
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        public init(collectionArn: String, collectionName: String, createTime: Date, description: String, kmsKeyId: String? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeMapRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri("MapName"))
        ]

        /// The name of the map resource.
        public let mapName: String

        public init(mapName: String) {
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeMapResponse: AWSDecodableShape {
        /// Specifies the map tile style selected from a partner data provider.
        public let configuration: MapConfiguration
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// Specifies the data provider for the associated map tiles.
        public let dataSource: String
        /// The optional description for the map resource.
        public let description: String
        /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:map/ExampleMap
        public let mapArn: String
        /// The map style selected from an available provider.
        public let mapName: String
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Tags associated with the map resource.
        public let tags: [String: String]?
        /// The timestamp for when the map resource was last update in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(configuration: MapConfiguration, createTime: Date, dataSource: String, description: String, mapArn: String, mapName: String, tags: [String: String]? = nil, updateTime: Date) {
            self.configuration = configuration
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapArn = mapArn
            self.mapName = mapName
            self.pricingPlan = nil
            self.tags = tags
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(configuration: MapConfiguration, createTime: Date, dataSource: String, description: String, mapArn: String, mapName: String, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.configuration = configuration
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapArn = mapArn
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case mapArn = "MapArn"
            case mapName = "MapName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribePlaceIndexRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri("IndexName"))
        ]

        /// The name of the place index resource.
        public let indexName: String

        public init(indexName: String) {
            self.indexName = indexName
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePlaceIndexResponse: AWSDecodableShape {
        /// The timestamp for when the place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of geospatial data. Values can be one of the following:    Esri     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The specified data storage option for requesting Places.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// The optional description for the place index resource.
        public let description: String
        /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across AWS.    Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
        public let indexArn: String
        /// The name of the place index resource being described.
        public let indexName: String
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Tags associated with place index resource.
        public let tags: [String: String]?
        /// The timestamp for when the place index resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, dataSource: String, dataSourceConfiguration: DataSourceConfiguration, description: String, indexArn: String, indexName: String, tags: [String: String]? = nil, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexArn = indexArn
            self.indexName = indexName
            self.pricingPlan = nil
            self.tags = tags
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(createTime: Date, dataSource: String, dataSourceConfiguration: DataSourceConfiguration, description: String, indexArn: String, indexName: String, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexArn = indexArn
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case dataSourceConfiguration = "DataSourceConfiguration"
            case description = "Description"
            case indexArn = "IndexArn"
            case indexName = "IndexName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeRouteCalculatorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "calculatorName", location: .uri("CalculatorName"))
        ]

        /// The name of the route calculator resource.
        public let calculatorName: String

        public init(calculatorName: String) {
            self.calculatorName = calculatorName
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRouteCalculatorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the Route calculator resource. Use the ARN when you specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
        public let calculatorArn: String
        /// The name of the route calculator resource being described.
        public let calculatorName: String
        /// The timestamp when the route calculator resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of traffic and road network data. Indicates one of the available providers:    Esri     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The optional description of the route calculator resource.
        public let description: String
        /// Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Tags associated with route calculator resource.
        public let tags: [String: String]?
        /// The timestamp when the route calculator resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(calculatorArn: String, calculatorName: String, createTime: Date, dataSource: String, description: String, tags: [String: String]? = nil, updateTime: Date) {
            self.calculatorArn = calculatorArn
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = nil
            self.tags = tags
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(calculatorArn: String, calculatorName: String, createTime: Date, dataSource: String, description: String, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.calculatorArn = calculatorArn
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorArn = "CalculatorArn"
            case calculatorName = "CalculatorName"
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeTrackerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// The name of the tracker resource.
        public let trackerName: String

        public init(trackerName: String) {
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTrackerResponse: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The optional description for the tracker resource.
        public let description: String
        /// A key identifier for an AWS KMS customer managed key assigned to the Amazon Location resource.
        public let kmsKeyId: String?
        /// The position filtering method of the tracker resource.
        public let positionFiltering: PositionFiltering?
        /// Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// No longer used. Always returns an empty string.
        public let pricingPlanDataSource: String?
        /// The tags associated with the tracker resource.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all AWS.   Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
        public let trackerArn: String
        /// The name of the tracker resource.
        public let trackerName: String
        /// The timestamp for when the tracker resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, description: String, kmsKeyId: String? = nil, positionFiltering: PositionFiltering? = nil, tags: [String: String]? = nil, trackerArn: String, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.positionFiltering = positionFiltering
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = tags
            self.trackerArn = trackerArn
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        public init(createTime: Date, description: String, kmsKeyId: String? = nil, positionFiltering: PositionFiltering? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil, trackerArn: String, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.positionFiltering = positionFiltering
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
            self.trackerArn = trackerArn
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case positionFiltering = "PositionFiltering"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
            case trackerArn = "TrackerArn"
            case trackerName = "TrackerName"
            case updateTime = "UpdateTime"
        }
    }

    public struct DevicePosition: AWSDecodableShape {
        /// The accuracy of the device position.
        public let accuracy: PositionalAccuracy?
        /// The device whose position you retrieved.
        public let deviceId: String?
        /// The last known device position.
        public let position: [Double]
        /// The properties associated with the position.
        public let positionProperties: [String: String]?
        /// The timestamp for when the tracker resource received the device position in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var receivedTime: Date
        /// The timestamp at which the device's position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(accuracy: PositionalAccuracy? = nil, deviceId: String? = nil, position: [Double], positionProperties: [String: String]? = nil, receivedTime: Date, sampleTime: Date) {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case accuracy = "Accuracy"
            case deviceId = "DeviceId"
            case position = "Position"
            case positionProperties = "PositionProperties"
            case receivedTime = "ReceivedTime"
            case sampleTime = "SampleTime"
        }
    }

    public struct DevicePositionUpdate: AWSEncodableShape {
        /// The accuracy of the device position.
        public let accuracy: PositionalAccuracy?
        /// The device associated to the position update.
        public let deviceId: String
        /// The latest device position defined in WGS 84 format: [X or longitude, Y or latitude].
        public let position: [Double]
        /// Associates one of more properties with the position update. A property is a key-value pair stored with the position update and added to any geofence event the update may trigger. Format: "key" : "value"
        public let positionProperties: [String: String]?
        /// The timestamp at which the device's position was determined. Uses ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(accuracy: PositionalAccuracy? = nil, deviceId: String, position: [Double], positionProperties: [String: String]? = nil, sampleTime: Date) {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.sampleTime = sampleTime
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
            try self.validate(self.positionProperties, name: "positionProperties", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case accuracy = "Accuracy"
            case deviceId = "DeviceId"
            case position = "Position"
            case positionProperties = "PositionProperties"
            case sampleTime = "SampleTime"
        }
    }

    public struct DisassociateTrackerConsumerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "consumerArn", location: .uri("ConsumerArn")),
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// The Amazon Resource Name (ARN) for the geofence collection to be disassociated from the tracker resource. Used when you need to specify a resource across all AWS.    Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
        public let consumerArn: String
        /// The name of the tracker resource to be dissociated from the consumer.
        public let trackerName: String

        public init(consumerArn: String, trackerName: String) {
            self.consumerArn = consumerArn
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, max: 1600)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateTrackerConsumerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GeofenceGeometry: AWSEncodableShape & AWSDecodableShape {
        /// A circle on the earth, as defined by a center point and a radius.
        public let circle: Circle?
        /// A polygon is a list of linear rings which are each made up of a list of vertices. Each vertex is a 2-dimensional point of the form: [longitude, latitude]. This is represented as an array of doubles of length 2 (so [double, double]). An array of 4 or more vertices, where the first and last vertex are the same (to form a closed boundary), is called a linear ring. The linear ring vertices must be listed in counter-clockwise order around the ring’s interior. The linear ring is represented as an array of vertices, or an array of arrays of doubles ([[double, double], ...]). A geofence consists of a single linear ring. To allow for future expansion, the Polygon parameter takes an array of linear rings, which is represented as an array of arrays of arrays of doubles ([[[double, double], ...], ...]). A linear ring for use in geofences can consist of between 4 and 1,000 vertices.
        public let polygon: [[[Double]]]?

        public init(circle: Circle? = nil, polygon: [[[Double]]]? = nil) {
            self.circle = circle
            self.polygon = polygon
        }

        public func validate(name: String) throws {
            try self.circle?.validate(name: "\(name).circle")
            try self.polygon?.forEach {
                try validate($0, name: "polygon[]", parent: name, min: 4)
            }
            try self.validate(self.polygon, name: "polygon", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case circle = "Circle"
            case polygon = "Polygon"
        }
    }

    public struct GetDevicePositionHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "deviceId", location: .uri("DeviceId")),
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// The device whose position history you want to retrieve.
        public let deviceId: String
        /// Specify the end time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be the time that the request is made. Requirement:   The time specified for EndTimeExclusive must be after the time for StartTimeInclusive.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTimeExclusive: Date?
        /// An optional limit for the number of device positions returned in a single call. Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?
        /// Specify the start time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be 24 hours prior to the time that the request is made. Requirement:   The time specified for StartTimeInclusive must be before EndTimeExclusive.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTimeInclusive: Date?
        /// The tracker resource receiving the request for the device position history.
        public let trackerName: String

        public init(deviceId: String, endTimeExclusive: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, startTimeInclusive: Date? = nil, trackerName: String) {
            self.deviceId = deviceId
            self.endTimeExclusive = endTimeExclusive
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTimeInclusive = startTimeInclusive
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeExclusive = "EndTimeExclusive"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTimeInclusive = "StartTimeInclusive"
        }
    }

    public struct GetDevicePositionHistoryResponse: AWSDecodableShape {
        /// Contains the position history details for the requested device.
        public let devicePositions: [DevicePosition]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(devicePositions: [DevicePosition], nextToken: String? = nil) {
            self.devicePositions = devicePositions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositions = "DevicePositions"
            case nextToken = "NextToken"
        }
    }

    public struct GetDevicePositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "deviceId", location: .uri("DeviceId")),
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// The device whose position you want to retrieve.
        public let deviceId: String
        /// The tracker resource receiving the position update.
        public let trackerName: String

        public init(deviceId: String, trackerName: String) {
            self.deviceId = deviceId
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDevicePositionResponse: AWSDecodableShape {
        /// The accuracy of the device position.
        public let accuracy: PositionalAccuracy?
        /// The device whose position you retrieved.
        public let deviceId: String?
        /// The last known device position.
        public let position: [Double]
        /// The properties associated with the position.
        public let positionProperties: [String: String]?
        /// The timestamp for when the tracker resource received the device position in  ISO 8601  format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var receivedTime: Date
        /// The timestamp at which the device's position was determined. Uses  ISO 8601  format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(accuracy: PositionalAccuracy? = nil, deviceId: String? = nil, position: [Double], positionProperties: [String: String]? = nil, receivedTime: Date, sampleTime: Date) {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case accuracy = "Accuracy"
            case deviceId = "DeviceId"
            case position = "Position"
            case positionProperties = "PositionProperties"
            case receivedTime = "ReceivedTime"
            case sampleTime = "SampleTime"
        }
    }

    public struct GetGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri("CollectionName")),
            AWSMemberEncoding(label: "geofenceId", location: .uri("GeofenceId"))
        ]

        /// The geofence collection storing the target geofence.
        public let collectionName: String
        /// The geofence you're retrieving details for.
        public let geofenceId: String

        public init(collectionName: String, geofenceId: String) {
            self.collectionName = collectionName
            self.geofenceId = geofenceId
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGeofenceResponse: AWSDecodableShape {
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier.
        public let geofenceId: String
        /// Contains the geofence geometry details describing a polygon or a circle.
        public let geometry: GeofenceGeometry
        /// Identifies the state of the geofence. A geofence will hold one of the following states:    ACTIVE — The geofence has been indexed by the system.     PENDING — The geofence is being processed by the system.    FAILED — The geofence failed to be indexed by the system.    DELETED — The geofence has been deleted from the system index.    DELETING — The geofence is being deleted from the system index.
        public let status: String
        /// The timestamp for when the geofence collection was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, geometry: GeofenceGeometry, status: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case geometry = "Geometry"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct GetMapGlyphsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "fontStack", location: .uri("FontStack")),
            AWSMemberEncoding(label: "fontUnicodeRange", location: .uri("FontUnicodeRange")),
            AWSMemberEncoding(label: "mapName", location: .uri("MapName"))
        ]

        /// A comma-separated list of fonts to load glyphs from in order of preference. For example, Noto Sans Regular, Arial Unicode. Valid fonts stacks for Esri styles:    VectorEsriDarkGrayCanvas – Ubuntu Medium Italic | Ubuntu Medium | Ubuntu Italic | Ubuntu Regular | Ubuntu Bold    VectorEsriLightGrayCanvas – Ubuntu Italic | Ubuntu Regular | Ubuntu Light | Ubuntu Bold    VectorEsriTopographic – Noto Sans Italic | Noto Sans Regular | Noto Sans Bold | Noto Serif Regular | Roboto Condensed Light Italic    VectorEsriStreets – Arial Regular | Arial Italic | Arial Bold    VectorEsriNavigation – Arial Regular | Arial Italic | Arial Bold    Valid font stacks for HERE Technologies styles:   VectorHereContrast – Fira  GO Regular | Fira GO Bold    VectorHereExplore, VectorHereExploreTruck, HybridHereExploreSatellite –  Fira GO Italic | Fira GO Map |  Fira GO Map Bold | Noto Sans CJK JP Bold |  Noto Sans CJK JP Light |  Noto Sans CJK JP Regular    Valid font stacks for Open Data (Preview) styles:   VectorOpenDataStandardLight –  Amazon Ember Regular,Noto Sans Regular | Amazon Ember Bold,Noto Sans Bold |  Amazon Ember Medium,Noto Sans Medium | Amazon Ember Regular Italic,Noto Sans Italic |  Amazon Ember Condensed RC Regular,Noto Sans Regular |  Amazon Ember Condensed RC Bold,Noto Sans Bold     The fonts used by VectorOpenDataStandardLight are combined fonts that use Amazon Ember for most glyphs but Noto Sans  for glyphs unsupported by Amazon Ember.
        public let fontStack: String
        /// A Unicode range of characters to download glyphs for. Each response will contain 256 characters. For example, 0–255 includes all characters from range U+0000 to 00FF. Must be aligned to multiples of 256.
        public let fontUnicodeRange: String
        /// The map resource associated with the glyph ﬁle.
        public let mapName: String

        public init(fontStack: String, fontUnicodeRange: String, mapName: String) {
            self.fontStack = fontStack
            self.fontUnicodeRange = fontUnicodeRange
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapGlyphsResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _options: AWSShapeOptions = [.rawPayload]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body("Blob")),
            AWSMemberEncoding(label: "contentType", location: .header("Content-Type"))
        ]

        /// The blob's content type.
        public let blob: AWSPayload?
        /// The map glyph content type. For example, application/octet-stream.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct GetMapSpritesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "fileName", location: .uri("FileName")),
            AWSMemberEncoding(label: "mapName", location: .uri("MapName"))
        ]

        /// The name of the sprite ﬁle. Use the following ﬁle names for the sprite sheet:    sprites.png     sprites@2x.png for high pixel density displays   For the JSON document containing image offsets. Use the following ﬁle names:    sprites.json     sprites@2x.json for high pixel density displays
        public let fileName: String
        /// The map resource associated with the sprite ﬁle.
        public let mapName: String

        public init(fileName: String, mapName: String) {
            self.fileName = fileName
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapSpritesResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _options: AWSShapeOptions = [.rawPayload]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body("Blob")),
            AWSMemberEncoding(label: "contentType", location: .header("Content-Type"))
        ]

        /// Contains the body of the sprite sheet or JSON offset ﬁle.
        public let blob: AWSPayload?
        /// The content type of the sprite sheet and offsets. For example, the sprite sheet content type is image/png, and the sprite offset JSON document is application/json.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct GetMapStyleDescriptorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri("MapName"))
        ]

        /// The map resource to retrieve the style descriptor from.
        public let mapName: String

        public init(mapName: String) {
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapStyleDescriptorResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _options: AWSShapeOptions = [.rawPayload]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body("Blob")),
            AWSMemberEncoding(label: "contentType", location: .header("Content-Type"))
        ]

        /// Contains the body of the style descriptor.
        public let blob: AWSPayload?
        /// The style descriptor's content type. For example, application/json.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct GetMapTileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri("MapName")),
            AWSMemberEncoding(label: "x", location: .uri("X")),
            AWSMemberEncoding(label: "y", location: .uri("Y")),
            AWSMemberEncoding(label: "z", location: .uri("Z"))
        ]

        /// The map resource to retrieve the map tiles from.
        public let mapName: String
        /// The X axis value for the map tile.
        public let x: String
        /// The Y axis value for the map tile.
        public let y: String
        /// The zoom value for the map tile.
        public let z: String

        public init(mapName: String, x: String, y: String, z: String) {
            self.mapName = mapName
            self.x = x
            self.y = y
            self.z = z
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapTileResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _options: AWSShapeOptions = [.rawPayload]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body("Blob")),
            AWSMemberEncoding(label: "contentType", location: .header("Content-Type"))
        ]

        /// Contains Mapbox Vector Tile (MVT) data.
        public let blob: AWSPayload?
        /// The map tile's content type. For example, application/vnd.mapbox-vector-tile.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct GetPlaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri("IndexName")),
            AWSMemberEncoding(label: "language", location: .querystring("language")),
            AWSMemberEncoding(label: "placeId", location: .uri("PlaceId"))
        ]

        /// The name of the place index resource that you want to use for the search.
        public let indexName: String
        /// The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
        public let language: String?
        /// The identifier of the place to find.
        public let placeId: String

        public init(indexName: String, language: String? = nil, placeId: String) {
            self.indexName = indexName
            self.language = language
            self.placeId = placeId
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPlaceResponse: AWSDecodableShape {
        /// Details about the result, such as its address and position.
        public let place: Place

        public init(place: Place) {
            self.place = place
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
        }
    }

    public struct Leg: AWSDecodableShape {
        /// The distance between the leg's StartPosition and EndPosition along a calculated route.    The default measurement is Kilometers unless the request specifies a DistanceUnit of Miles.
        public let distance: Double
        /// The estimated travel time between the leg's StartPosition and EndPosition. The travel mode and departure time that you specify in the request determines the calculated time.
        public let durationSeconds: Double
        /// The terminating position of the leg. Follows the format [longitude,latitude].  If the EndPosition isn't located on a road, it's snapped to a nearby road.
        public let endPosition: [Double]
        /// Contains the calculated route's path as a linestring geometry.
        public let geometry: LegGeometry?
        /// The starting position of the leg. Follows the format [longitude,latitude].  If the StartPosition isn't located on a road, it's snapped to a nearby road.
        public let startPosition: [Double]
        /// Contains a list of steps, which represent subsections of a leg. Each step provides instructions for how to move to the next step in the leg such as the step's start position, end position, travel distance, travel duration, and geometry offset.
        public let steps: [Step]

        public init(distance: Double, durationSeconds: Double, endPosition: [Double], geometry: LegGeometry? = nil, startPosition: [Double], steps: [Step]) {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometry = geometry
            self.startPosition = startPosition
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case durationSeconds = "DurationSeconds"
            case endPosition = "EndPosition"
            case geometry = "Geometry"
            case startPosition = "StartPosition"
            case steps = "Steps"
        }
    }

    public struct LegGeometry: AWSDecodableShape {
        /// An ordered list of positions used to plot a route on a map.  The first position is closest to the start position for the leg, and the last position is the closest to the end position for the leg.   For example, [[-123.117, 49.284],[-123.115, 49.285],[-123.115, 49.285]]
        public let lineString: [[Double]]?

        public init(lineString: [[Double]]? = nil) {
            self.lineString = lineString
        }

        private enum CodingKeys: String, CodingKey {
            case lineString = "LineString"
        }
    }

    public struct ListDevicePositionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// An optional limit for the number of entries returned in a single call. Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?
        /// The tracker resource containing the requested devices.
        public let trackerName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, trackerName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevicePositionsResponse: AWSDecodableShape {
        /// Contains details about each device's last known position. These details includes the device ID, the time when the position was sampled on the device, the time that the service received the update, and the most recent coordinates.
        public let entries: [ListDevicePositionsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListDevicePositionsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevicePositionsResponseEntry: AWSDecodableShape {
        /// The accuracy of the device position.
        public let accuracy: PositionalAccuracy?
        /// The ID of the device for this position.
        public let deviceId: String
        /// The last known device position. Empty if no positions currently stored.
        public let position: [Double]
        /// The properties associated with the position.
        public let positionProperties: [String: String]?
        /// The timestamp at which the device position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(accuracy: PositionalAccuracy? = nil, deviceId: String, position: [Double], positionProperties: [String: String]? = nil, sampleTime: Date) {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case accuracy = "Accuracy"
            case deviceId = "DeviceId"
            case position = "Position"
            case positionProperties = "PositionProperties"
            case sampleTime = "SampleTime"
        }
    }

    public struct ListGeofenceCollectionsRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofenceCollectionsResponse: AWSDecodableShape {
        /// Lists the geofence collections that exist in your AWS account.
        public let entries: [ListGeofenceCollectionsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListGeofenceCollectionsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofenceCollectionsResponseEntry: AWSDecodableShape {
        /// The name of the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The description for the geofence collection
        public let description: String
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// No longer used. Always returns an empty string.
        public let pricingPlanDataSource: String?
        /// Specifies a timestamp for when the resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(collectionName: String, createTime: Date, description: String, updateTime: Date) {
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        public init(collectionName: String, createTime: Date, description: String, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, updateTime: Date) {
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListGeofenceResponseEntry: AWSDecodableShape {
        /// The timestamp for when the geofence was stored in a geofence collection in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier.
        public let geofenceId: String
        /// Contains the geofence geometry details describing a polygon or a circle.
        public let geometry: GeofenceGeometry
        /// Identifies the state of the geofence. A geofence will hold one of the following states:    ACTIVE — The geofence has been indexed by the system.     PENDING — The geofence is being processed by the system.    FAILED — The geofence failed to be indexed by the system.    DELETED — The geofence has been deleted from the system index.    DELETING — The geofence is being deleted from the system index.
        public let status: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, geometry: GeofenceGeometry, status: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case geometry = "Geometry"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListGeofencesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri("CollectionName"))
        ]

        /// The name of the geofence collection storing the list of geofences.
        public let collectionName: String
        /// An optional limit for the number of geofences returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        public init(collectionName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collectionName = collectionName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofencesResponse: AWSDecodableShape {
        /// Contains a list of geofences stored in the geofence collection.
        public let entries: [ListGeofenceResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListGeofenceResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListMapsRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListMapsResponse: AWSDecodableShape {
        /// Contains a list of maps in your AWS account
        public let entries: [ListMapsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListMapsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListMapsResponseEntry: AWSDecodableShape {
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// Specifies the data provider for the associated map tiles.
        public let dataSource: String
        /// The description for the map resource.
        public let description: String
        /// The name of the associated map resource.
        public let mapName: String
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// The timestamp for when the map resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, dataSource: String, description: String, mapName: String, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapName = mapName
            self.pricingPlan = nil
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(createTime: Date, dataSource: String, description: String, mapName: String, pricingPlan: PricingPlan? = nil, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case mapName = "MapName"
            case pricingPlan = "PricingPlan"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListPlaceIndexesRequest: AWSEncodableShape {
        /// An optional limit for the maximum number of results returned in a single call. Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPlaceIndexesResponse: AWSDecodableShape {
        /// Lists the place index resources that exist in your AWS account
        public let entries: [ListPlaceIndexesResponseEntry]
        /// A pagination token indicating that there are additional pages available. You can use the token in a new request to fetch the next page of results.
        public let nextToken: String?

        public init(entries: [ListPlaceIndexesResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListPlaceIndexesResponseEntry: AWSDecodableShape {
        /// The timestamp for when the place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of geospatial data. Values can be one of the following:    Esri     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The optional description for the place index resource.
        public let description: String
        /// The name of the place index resource.
        public let indexName: String
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// The timestamp for when the place index resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, dataSource: String, description: String, indexName: String, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.indexName = indexName
            self.pricingPlan = nil
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(createTime: Date, dataSource: String, description: String, indexName: String, pricingPlan: PricingPlan? = nil, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case indexName = "IndexName"
            case pricingPlan = "PricingPlan"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListRouteCalculatorsRequest: AWSEncodableShape {
        /// An optional maximum number of results returned in a single call. Default Value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default Value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListRouteCalculatorsResponse: AWSDecodableShape {
        /// Lists the route calculator resources that exist in your AWS account
        public let entries: [ListRouteCalculatorsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a subsequent request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListRouteCalculatorsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListRouteCalculatorsResponseEntry: AWSDecodableShape {
        /// The name of the route calculator resource.
        public let calculatorName: String
        /// The timestamp when the route calculator resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of traffic and road network data. Indicates one of the available providers:    Esri     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The optional description of the route calculator resource.
        public let description: String
        /// Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// The timestamp when the route calculator resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(calculatorName: String, createTime: Date, dataSource: String, description: String, updateTime: Date) {
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = nil
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(calculatorName: String, createTime: Date, dataSource: String, description: String, pricingPlan: PricingPlan? = nil, updateTime: Date) {
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorName = "CalculatorName"
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
        /// 	          Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Tags that have been applied to the specified resource. Tags are mapped from the tag key to the tag value: "TagKey" : "TagValue".
        /// 	          Format example: {"tag1" : "value1", "tag2" : "value2"}
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListTrackerConsumersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?
        /// The tracker resource whose associated geofence collections you want to list.
        public let trackerName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, trackerName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackerConsumersResponse: AWSDecodableShape {
        /// Contains the list of geofence collection ARNs associated to the tracker resource.
        public let consumerArns: [String]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(consumerArns: [String], nextToken: String? = nil) {
            self.consumerArns = consumerArns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case consumerArns = "ConsumerArns"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersResponse: AWSDecodableShape {
        /// Contains tracker resources in your AWS account. Details include tracker name, description and timestamps for when the tracker was created and last updated.
        public let entries: [ListTrackersResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListTrackersResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersResponseEntry: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The description for the tracker resource.
        public let description: String
        /// Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// No longer used. Always returns an empty string.
        public let pricingPlanDataSource: String?
        /// The name of the tracker resource.
        public let trackerName: String
        /// The timestamp at which the device's position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, description: String, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        public init(createTime: Date, description: String, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case trackerName = "TrackerName"
            case updateTime = "UpdateTime"
        }
    }

    public struct MapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the map style selected from an available data provider. Valid Esri map styles:    VectorEsriDarkGrayCanvas – The Esri Dark Gray Canvas map style. A vector basemap with a dark gray, neutral background with minimal colors, labels, and features that's designed to draw attention to your thematic content.     RasterEsriImagery – The Esri Imagery map style. A raster basemap that provides one meter or better satellite and aerial imagery in many parts of the world and lower resolution satellite imagery worldwide.     VectorEsriLightGrayCanvas – The Esri Light Gray Canvas map style, which provides a detailed vector basemap with a light gray, neutral background style with minimal colors, labels, and features that's designed to draw attention to your thematic content.     VectorEsriTopographic – The Esri Light map style, which provides a detailed vector basemap with a classic Esri map style.    VectorEsriStreets – The Esri World Streets map style, which provides a detailed vector basemap for the world symbolized with a classic Esri street map style. The vector tile layer is similar in content and style to the World Street Map raster map.    VectorEsriNavigation – The Esri World Navigation map style, which provides a detailed basemap for the world symbolized with a custom navigation map style that's designed for use during the day in mobile devices.   Valid HERE Technologies map styles:    VectorHereContrast – The HERE Contrast (Berlin) map style is a  high contrast detailed base map of the world that blends 3D and 2D rendering.  The VectorHereContrast style has been renamed from  VectorHereBerlin.  VectorHereBerlin has been deprecated, but will continue to work in  applications that use it.     VectorHereExplore – A default HERE map style containing a  neutral, global map and its features including roads, buildings, landmarks,  and water features. It also now includes a fully designed map of Japan.    VectorHereExploreTruck – A global map containing truck  restrictions and attributes (e.g. width / height / HAZMAT) symbolized with  highlighted segments and icons on top of HERE Explore to support use cases  within transport and logistics.    RasterHereExploreSatellite – A global map containing high resolution satellite imagery.    HybridHereExploreSatellite – A global map displaying the road  network, street names, and city labels over satellite imagery. This style  will automatically retrieve both raster and vector tiles, and your charges  will be based on total tiles retrieved.  Hybrid styles use both vector and raster tiles when rendering the  map that you see. This means that more tiles are retrieved than when using  either vector or raster tiles alone. Your charges will include all tiles  retrieved.    Valid Open Data (Preview) map styles:    VectorOpenDataStandardLight – The Open Data Standard Light  (preview) map style provides a detailed basemap for the world suitable for website and mobile application use. The map includes highways major roads,  minor roads, railways, water features, cities, parks, landmarks, building footprints, and administrative boundaries.  Open Data maps is in preview. We may add, change, or remove  features before announcing general availability. For more information, see Open Data is in preview release.
        public let style: String

        public init(style: String) {
            self.style = style
        }

        public func validate(name: String) throws {
            try self.validate(self.style, name: "style", parent: name, max: 100)
            try self.validate(self.style, name: "style", parent: name, min: 1)
            try self.validate(self.style, name: "style", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case style = "Style"
        }
    }

    public struct Place: AWSDecodableShape {
        /// The numerical portion of an address, such as a building number.
        public let addressNumber: String?
        /// A country/region specified using ISO 3166 3-digit country/region code. For example, CAN.
        public let country: String?
        public let geometry: PlaceGeometry
        ///  True if the result is interpolated from other known places.  False if the Place is a known place. Not returned when the partner does not provide the information. For example, returns False for an address location that is found in the partner data, but returns True if an address does not exist in the partner data and its location is calculated by interpolating between other known addresses.
        public let interpolated: Bool?
        /// The full name and address of the point of interest such as a city, region, or country. For example, 123 Any Street, Any Town, USA.
        public let label: String?
        /// A name for a local area, such as a city or town name. For example, Toronto.
        public let municipality: String?
        /// The name of a community district. For example, Downtown.
        public let neighborhood: String?
        /// A group of numbers and letters in a country-specific format, which accompanies the address for the purpose of identifying a location.
        public let postalCode: String?
        /// A name for an area or geographical division, such as a province or state name. For example, British Columbia.
        public let region: String?
        /// The name for a street or a road to identify a location. For example, Main Street.
        public let street: String?
        /// A country, or an area that's part of a larger region. For example, Metro Vancouver.
        public let subRegion: String?
        /// The time zone in which the Place is located. Returned only when using HERE as the selected partner.
        public let timeZone: TimeZone?
        /// For addresses with multiple units, the unit identifier. Can include numbers and letters, for example 3B or Unit 123.  Returned only for a place index that uses Esri as a data provider. Is not returned for SearchPlaceIndexForPosition.
        public let unitNumber: String?
        /// For addresses with a UnitNumber, the type of unit. For example, Apartment.
        public let unitType: String?

        public init(addressNumber: String? = nil, country: String? = nil, geometry: PlaceGeometry, interpolated: Bool? = nil, label: String? = nil, municipality: String? = nil, neighborhood: String? = nil, postalCode: String? = nil, region: String? = nil, street: String? = nil, subRegion: String? = nil, timeZone: TimeZone? = nil, unitNumber: String? = nil, unitType: String? = nil) {
            self.addressNumber = addressNumber
            self.country = country
            self.geometry = geometry
            self.interpolated = interpolated
            self.label = label
            self.municipality = municipality
            self.neighborhood = neighborhood
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subRegion = subRegion
            self.timeZone = timeZone
            self.unitNumber = unitNumber
            self.unitType = unitType
        }

        private enum CodingKeys: String, CodingKey {
            case addressNumber = "AddressNumber"
            case country = "Country"
            case geometry = "Geometry"
            case interpolated = "Interpolated"
            case label = "Label"
            case municipality = "Municipality"
            case neighborhood = "Neighborhood"
            case postalCode = "PostalCode"
            case region = "Region"
            case street = "Street"
            case subRegion = "SubRegion"
            case timeZone = "TimeZone"
            case unitNumber = "UnitNumber"
            case unitType = "UnitType"
        }
    }

    public struct PlaceGeometry: AWSDecodableShape {
        /// A single point geometry specifies a location for a Place using WGS 84 coordinates:    x — Specifies the x coordinate or longitude.     y — Specifies the y coordinate or latitude.
        public let point: [Double]?

        public init(point: [Double]? = nil) {
            self.point = point
        }

        private enum CodingKeys: String, CodingKey {
            case point = "Point"
        }
    }

    public struct PositionalAccuracy: AWSEncodableShape & AWSDecodableShape {
        /// Estimated maximum distance, in meters, between the measured position and the true position of a device, along the Earth's surface.
        public let horizontal: Double

        public init(horizontal: Double) {
            self.horizontal = horizontal
        }

        private enum CodingKeys: String, CodingKey {
            case horizontal = "Horizontal"
        }
    }

    public struct PutGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri("CollectionName")),
            AWSMemberEncoding(label: "geofenceId", location: .uri("GeofenceId"))
        ]

        /// The geofence collection to store the geofence in.
        public let collectionName: String
        /// An identifier for the geofence. For example, ExampleGeofence-1.
        public let geofenceId: String
        /// Contains the details to specify the position of the geofence. Can be either a  polygon or a circle. Including both will return a validation error.  Each  geofence polygon can have a maximum of 1,000 vertices.
        public let geometry: GeofenceGeometry

        public init(collectionName: String, geofenceId: String, geometry: GeofenceGeometry) {
            self.collectionName = collectionName
            self.geofenceId = geofenceId
            self.geometry = geometry
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case geometry = "Geometry"
        }
    }

    public struct PutGeofenceResponse: AWSDecodableShape {
        /// The timestamp for when the geofence was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier entered in the request.
        public let geofenceId: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case updateTime = "UpdateTime"
        }
    }

    public struct RouteMatrixEntry: AWSDecodableShape {
        /// The total distance of travel for the route.
        public let distance: Double?
        /// The expected duration of travel for the route.
        public let durationSeconds: Double?
        /// An error corresponding to the calculation of a route between the DeparturePosition and DestinationPosition.
        public let error: RouteMatrixEntryError?

        public init(distance: Double? = nil, durationSeconds: Double? = nil, error: RouteMatrixEntryError? = nil) {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case durationSeconds = "DurationSeconds"
            case error = "Error"
        }
    }

    public struct RouteMatrixEntryError: AWSDecodableShape {
        /// The type of error which occurred for the route calculation.
        public let code: RouteMatrixErrorCode
        /// A message about the error that occurred for the route calculation.
        public let message: String?

        public init(code: RouteMatrixErrorCode, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct SearchForPositionResult: AWSDecodableShape {
        /// The distance in meters of a great-circle arc between the query position and the result.  A great-circle arc is the shortest path on a sphere, in this case the Earth. This returns the shortest distance between two locations.
        public let distance: Double
        /// Details about the search result, such as its address and position.
        public let place: Place
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later.  For SearchPlaceIndexForPosition operations, the PlaceId is returned only by place indexes that use HERE as a data provider.
        public let placeId: String?

        public init(distance: Double, place: Place, placeId: String? = nil) {
            self.distance = distance
            self.place = place
            self.placeId = placeId
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case place = "Place"
            case placeId = "PlaceId"
        }
    }

    public struct SearchForSuggestionsResult: AWSDecodableShape {
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later.  For SearchPlaceIndexForSuggestions operations, the PlaceId is returned by place indexes that use HERE or Esri as data providers.
        public let placeId: String?
        /// The text of the place suggestion, typically formatted as an address string.
        public let text: String

        public init(placeId: String? = nil, text: String) {
            self.placeId = placeId
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case placeId = "PlaceId"
            case text = "Text"
        }
    }

    public struct SearchForTextResult: AWSDecodableShape {
        /// The distance in meters of a great-circle arc between the bias position specified and the result. Distance will be returned only if a bias position was specified in the query.  A great-circle arc is the shortest path on a sphere, in this case the Earth. This returns the shortest distance between two locations.
        public let distance: Double?
        /// Details about the search result, such as its address and position.
        public let place: Place
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later.  For SearchPlaceIndexForText operations, the PlaceId is returned only by place indexes that use HERE as a data provider.
        public let placeId: String?
        /// The relative confidence in the match for a result among the results returned. For example, if more fields for an address match (including house number, street, city, country/region, and postal code), the relevance score is closer to 1. Returned only when the partner selected is Esri.
        public let relevance: Double?

        public init(distance: Double? = nil, place: Place, placeId: String? = nil, relevance: Double? = nil) {
            self.distance = distance
            self.place = place
            self.placeId = placeId
            self.relevance = relevance
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case place = "Place"
            case placeId = "PlaceId"
            case relevance = "Relevance"
        }
    }

    public struct SearchPlaceIndexForPositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri("IndexName"))
        ]

        /// The name of the place index resource you want to use for the search.
        public let indexName: String
        /// The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
        public let language: String?
        /// An optional parameter. The maximum number of results returned per request. Default value: 50
        public let maxResults: Int?
        /// Specifies the longitude and latitude of the position to query. This parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents a position with longitude -123.1174 and latitude 49.2847.
        public let position: [Double]

        public init(indexName: String, language: String? = nil, maxResults: Int? = nil, position: [Double]) {
            self.indexName = indexName
            self.language = language
            self.maxResults = maxResults
            self.position = position
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case language = "Language"
            case maxResults = "MaxResults"
            case position = "Position"
        }
    }

    public struct SearchPlaceIndexForPositionResponse: AWSDecodableShape {
        /// Returns a list of Places closest to the specified position. Each result contains additional information about the Places returned.
        public let results: [SearchForPositionResult]
        /// Contains a summary of the request. Echoes the input values for Position, Language, MaxResults, and the DataSource of the place index.
        public let summary: SearchPlaceIndexForPositionSummary

        public init(results: [SearchForPositionResult], summary: SearchPlaceIndexForPositionSummary) {
            self.results = results
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
            case summary = "Summary"
        }
    }

    public struct SearchPlaceIndexForPositionSummary: AWSDecodableShape {
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:   Esri   Here   For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The preferred language used to return results. Matches the language in the request. The value is a valid BCP 47 language tag, for example, en for English.
        public let language: String?
        /// Contains the optional result count limit that is specified in the request. Default value: 50
        public let maxResults: Int?
        /// The position specified in the request.
        public let position: [Double]

        public init(dataSource: String, language: String? = nil, maxResults: Int? = nil, position: [Double]) {
            self.dataSource = dataSource
            self.language = language
            self.maxResults = maxResults
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case language = "Language"
            case maxResults = "MaxResults"
            case position = "Position"
        }
    }

    public struct SearchPlaceIndexForSuggestionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri("IndexName"))
        ]

        /// An optional parameter that indicates a preference for place suggestions that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.   BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
        public let biasPosition: [Double]?
        /// An optional parameter that limits the search results by returning only suggestions within a specified bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542.   FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
        public let filterBBox: [Double]?
        /// An optional parameter that limits the search results by returning only suggestions within the provided list of countries.   Use the ISO 3166 3-digit country code. For example, Australia uses three upper-case characters: AUS.
        public let filterCountries: [String]?
        /// The name of the place index resource you want to use for the search.
        public let indexName: String
        /// The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Gr to get suggestions with the language parameter set to en. The results found will most likely be returned as Athens, Greece. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα, Ελλάδα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
        public let language: String?
        /// An optional parameter. The maximum number of results returned per request.  The default: 5
        public let maxResults: Int?
        /// The free-form partial text to use to generate place suggestions. For example, eiffel tow.
        public let text: String

        public init(biasPosition: [Double]? = nil, filterBBox: [Double]? = nil, filterCountries: [String]? = nil, indexName: String, language: String? = nil, maxResults: Int? = nil, text: String) {
            self.biasPosition = biasPosition
            self.filterBBox = filterBBox
            self.filterCountries = filterCountries
            self.indexName = indexName
            self.language = language
            self.maxResults = maxResults
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, max: 2)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, min: 2)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, max: 4)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, min: 4)
            try self.filterCountries?.forEach {
                try validate($0, name: "filterCountries[]", parent: name, pattern: "^[A-Z]{3}$")
            }
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, max: 100)
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case filterBBox = "FilterBBox"
            case filterCountries = "FilterCountries"
            case language = "Language"
            case maxResults = "MaxResults"
            case text = "Text"
        }
    }

    public struct SearchPlaceIndexForSuggestionsResponse: AWSDecodableShape {
        /// A list of place suggestions that best match the search text.
        public let results: [SearchForSuggestionsResult]
        /// Contains a summary of the request. Echoes the input values for BiasPosition, FilterBBox, FilterCountries, Language, MaxResults, and Text. Also includes the DataSource of the place index.
        public let summary: SearchPlaceIndexForSuggestionsSummary

        public init(results: [SearchForSuggestionsResult], summary: SearchPlaceIndexForSuggestionsSummary) {
            self.results = results
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
            case summary = "Summary"
        }
    }

    public struct SearchPlaceIndexForSuggestionsSummary: AWSDecodableShape {
        /// Contains the coordinates for the optional bias position specified in the request. This parameter contains a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        public let biasPosition: [Double]?
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:   Esri   Here   For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// Contains the coordinates for the optional bounding box specified in the request.
        public let filterBBox: [Double]?
        /// Contains the optional country filter specified in the request.
        public let filterCountries: [String]?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid BCP 47 language tag, for example, en for English.
        public let language: String?
        /// Contains the optional result count limit specified in the request.
        public let maxResults: Int?
        /// The free-form partial text input specified in the request.
        public let text: String

        public init(biasPosition: [Double]? = nil, dataSource: String, filterBBox: [Double]? = nil, filterCountries: [String]? = nil, language: String? = nil, maxResults: Int? = nil, text: String) {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCountries = filterCountries
            self.language = language
            self.maxResults = maxResults
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case dataSource = "DataSource"
            case filterBBox = "FilterBBox"
            case filterCountries = "FilterCountries"
            case language = "Language"
            case maxResults = "MaxResults"
            case text = "Text"
        }
    }

    public struct SearchPlaceIndexForTextRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri("IndexName"))
        ]

        /// An optional parameter that indicates a preference for places that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.   BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
        public let biasPosition: [Double]?
        /// An optional parameter that limits the search results by returning only places that are within the provided bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542.   FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
        public let filterBBox: [Double]?
        /// An optional parameter that limits the search results by returning only places that are in a specified list of countries.   Valid values include ISO 3166 3-digit country codes. For example, Australia uses three upper-case characters: AUS.
        public let filterCountries: [String]?
        /// The name of the place index resource you want to use for the search.
        public let indexName: String
        /// The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Greece, with the language parameter set to en. The result found will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
        public let language: String?
        /// An optional parameter. The maximum number of results returned per request.  The default: 50
        public let maxResults: Int?
        /// The address, name, city, or region to be used in the search in free-form text format. For example, 123 Any Street.
        public let text: String

        public init(biasPosition: [Double]? = nil, filterBBox: [Double]? = nil, filterCountries: [String]? = nil, indexName: String, language: String? = nil, maxResults: Int? = nil, text: String) {
            self.biasPosition = biasPosition
            self.filterBBox = filterBBox
            self.filterCountries = filterCountries
            self.indexName = indexName
            self.language = language
            self.maxResults = maxResults
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, max: 2)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, min: 2)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, max: 4)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, min: 4)
            try self.filterCountries?.forEach {
                try validate($0, name: "filterCountries[]", parent: name, pattern: "^[A-Z]{3}$")
            }
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, max: 100)
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case filterBBox = "FilterBBox"
            case filterCountries = "FilterCountries"
            case language = "Language"
            case maxResults = "MaxResults"
            case text = "Text"
        }
    }

    public struct SearchPlaceIndexForTextResponse: AWSDecodableShape {
        /// A list of Places matching the input text. Each result contains additional information about the specific point of interest.  Not all response properties are included with all responses. Some properties may only be returned by specific data partners.
        public let results: [SearchForTextResult]
        /// Contains a summary of the request. Echoes the input values for BiasPosition, FilterBBox, FilterCountries, Language, MaxResults, and Text. Also includes the DataSource of the place index and the bounding box, ResultBBox, which surrounds the search results.
        public let summary: SearchPlaceIndexForTextSummary

        public init(results: [SearchForTextResult], summary: SearchPlaceIndexForTextSummary) {
            self.results = results
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
            case summary = "Summary"
        }
    }

    public struct SearchPlaceIndexForTextSummary: AWSDecodableShape {
        /// Contains the coordinates for the optional bias position specified in the request. This parameter contains a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        public let biasPosition: [Double]?
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:   Esri   Here   For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// Contains the coordinates for the optional bounding box specified in the request.
        public let filterBBox: [Double]?
        /// Contains the optional country filter specified in the request.
        public let filterCountries: [String]?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid BCP 47 language tag, for example, en for English.
        public let language: String?
        /// Contains the optional result count limit specified in the request.
        public let maxResults: Int?
        /// The bounding box that fully contains all search results.  If you specified the optional FilterBBox parameter in the request, ResultBBox is contained within FilterBBox.
        public let resultBBox: [Double]?
        /// The search text specified in the request.
        public let text: String

        public init(biasPosition: [Double]? = nil, dataSource: String, filterBBox: [Double]? = nil, filterCountries: [String]? = nil, language: String? = nil, maxResults: Int? = nil, resultBBox: [Double]? = nil, text: String) {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCountries = filterCountries
            self.language = language
            self.maxResults = maxResults
            self.resultBBox = resultBBox
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case dataSource = "DataSource"
            case filterBBox = "FilterBBox"
            case filterCountries = "FilterCountries"
            case language = "Language"
            case maxResults = "MaxResults"
            case resultBBox = "ResultBBox"
            case text = "Text"
        }
    }

    public struct Step: AWSDecodableShape {
        /// The travel distance between the step's StartPosition and EndPosition.
        public let distance: Double
        /// The estimated travel time, in seconds, from the step's StartPosition to the EndPosition. . The travel mode and departure time that you specify in the request determines the calculated time.
        public let durationSeconds: Double
        /// The end position of a step. If the position the last step in the leg, this position is the same as the end position of the leg.
        public let endPosition: [Double]
        /// Represents the start position, or index, in a sequence of steps within the leg's line string geometry. For example, the index of the first step in a leg geometry is 0.  Included in the response for queries that set IncludeLegGeometry to True.
        public let geometryOffset: Int?
        /// The starting position of a step. If the position is the first step in the leg, this position is the same as the start position of the leg.
        public let startPosition: [Double]

        public init(distance: Double, durationSeconds: Double, endPosition: [Double], geometryOffset: Int? = nil, startPosition: [Double]) {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometryOffset = geometryOffset
            self.startPosition = startPosition
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case durationSeconds = "DurationSeconds"
            case endPosition = "EndPosition"
            case geometryOffset = "GeometryOffset"
            case startPosition = "StartPosition"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource whose tags you want to update.
        /// 	          Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
        public let resourceArn: String
        /// Applies one or more tags to specific resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource.   Each tag key must be unique and must have exactly one associated value.   Maximum key length: 128 Unicode characters in UTF-8.   Maximum value length: 256 Unicode characters in UTF-8.   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @   Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimeZone: AWSDecodableShape {
        /// The name of the time zone, following the  IANA time zone standard. For example, America/Los_Angeles.
        public let name: String
        /// The time zone's offset, in seconds, from UTC.
        public let offset: Int?

        public init(name: String, offset: Int? = nil) {
            self.name = name
            self.offset = offset
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case offset = "Offset"
        }
    }

    public struct TruckDimensions: AWSEncodableShape {
        /// The height of the truck.   For example, 4.5.     For routes calculated with a HERE resource, this value must be between 0 and 50 meters.
        public let height: Double?
        /// The length of the truck.   For example, 15.5.     For routes calculated with a HERE resource, this value must be between 0 and 300 meters.
        public let length: Double?
        ///  Specifies the unit of measurement for the truck dimensions. Default Value: Meters
        public let unit: DimensionUnit?
        /// The width of the truck.   For example, 4.5.     For routes calculated with a HERE resource, this value must be between 0 and 50 meters.
        public let width: Double?

        public init(height: Double? = nil, length: Double? = nil, unit: DimensionUnit? = nil, width: Double? = nil) {
            self.height = height
            self.length = length
            self.unit = unit
            self.width = width
        }

        private enum CodingKeys: String, CodingKey {
            case height = "Height"
            case length = "Length"
            case unit = "Unit"
            case width = "Width"
        }
    }

    public struct TruckWeight: AWSEncodableShape {
        /// The total weight of the truck.    For example, 3500.
        public let total: Double?
        /// The unit of measurement to use for the truck weight. Default Value: Kilograms
        public let unit: VehicleWeightUnit?

        public init(total: Double? = nil, unit: VehicleWeightUnit? = nil) {
            self.total = total
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case total = "Total"
            case unit = "Unit"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource from which you want to remove tags.
        /// 	          Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
        public let resourceArn: String
        /// The list of tag keys to remove from the specified resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGeofenceCollectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri("CollectionName"))
        ]

        /// The name of the geofence collection to update.
        public let collectionName: String
        /// Updates the description for the geofence collection.
        public let description: String?
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// This parameter is no longer used.
        public let pricingPlanDataSource: String?

        public init(collectionName: String, description: String? = nil) {
            self.collectionName = collectionName
            self.description = description
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        public init(collectionName: String, description: String? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil) {
            self.collectionName = collectionName
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
        }
    }

    public struct UpdateGeofenceCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated geofence collection. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
        public let collectionArn: String
        /// The name of the updated geofence collection.
        public let collectionName: String
        /// The time when the geofence collection was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(collectionArn: String, collectionName: String, updateTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case collectionName = "CollectionName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdateMapRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri("MapName"))
        ]

        /// Updates the description for the map resource.
        public let description: String?
        /// The name of the map resource to update.
        public let mapName: String
        /// No longer used. If included, the only allowed value is  RequestBasedUsage.
        public let pricingPlan: PricingPlan?

        public init(description: String? = nil, mapName: String) {
            self.description = description
            self.mapName = mapName
            self.pricingPlan = nil
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(description: String? = nil, mapName: String, pricingPlan: PricingPlan? = nil) {
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct UpdateMapResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated map resource. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:map/ExampleMap
        public let mapArn: String
        /// The name of the updated map resource.
        public let mapName: String
        /// The timestamp for when the map resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(mapArn: String, mapName: String, updateTime: Date) {
            self.mapArn = mapArn
            self.mapName = mapName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case mapArn = "MapArn"
            case mapName = "MapName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdatePlaceIndexRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri("IndexName"))
        ]

        /// Updates the data storage option for the place index resource.
        public let dataSourceConfiguration: DataSourceConfiguration?
        /// Updates the description for the place index resource.
        public let description: String?
        /// The name of the place index resource to update.
        public let indexName: String
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?

        public init(dataSourceConfiguration: DataSourceConfiguration? = nil, description: String? = nil, indexName: String) {
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexName = indexName
            self.pricingPlan = nil
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(dataSourceConfiguration: DataSourceConfiguration? = nil, description: String? = nil, indexName: String, pricingPlan: PricingPlan? = nil) {
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceConfiguration = "DataSourceConfiguration"
            case description = "Description"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct UpdatePlaceIndexResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the upated place index resource. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:place- index/ExamplePlaceIndex
        public let indexArn: String
        /// The name of the updated place index resource.
        public let indexName: String
        /// The timestamp for when the place index resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(indexArn: String, indexName: String, updateTime: Date) {
            self.indexArn = indexArn
            self.indexName = indexName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case indexArn = "IndexArn"
            case indexName = "IndexName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdateRouteCalculatorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "calculatorName", location: .uri("CalculatorName"))
        ]

        /// The name of the route calculator resource to update.
        public let calculatorName: String
        /// Updates the description for the route calculator resource.
        public let description: String?
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?

        public init(calculatorName: String, description: String? = nil) {
            self.calculatorName = calculatorName
            self.description = description
            self.pricingPlan = nil
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        public init(calculatorName: String, description: String? = nil, pricingPlan: PricingPlan? = nil) {
            self.calculatorName = calculatorName
            self.description = description
            self.pricingPlan = pricingPlan
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct UpdateRouteCalculatorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated route calculator resource. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:route- calculator/ExampleCalculator
        public let calculatorArn: String
        /// The name of the updated route calculator resource.
        public let calculatorName: String
        /// The timestamp for when the route calculator was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(calculatorArn: String, calculatorName: String, updateTime: Date) {
            self.calculatorArn = calculatorArn
            self.calculatorName = calculatorName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorArn = "CalculatorArn"
            case calculatorName = "CalculatorName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdateTrackerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri("TrackerName"))
        ]

        /// Updates the description for the tracker resource.
        public let description: String?
        /// Updates the position filtering for the tracker resource. Valid values:    TimeBased - Location updates are evaluated against linked geofence collections,  but not every location update is stored. If your update frequency is more often than 30 seconds,  only one update per 30 seconds is stored for each unique device ID.     DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are  ignored. Location updates within this distance are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.     AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This helps educe the effects of GPS noise  when displaying device trajectories on a map, and can help control costs by reducing the number of geofence evaluations.
        public let positionFiltering: PositionFiltering?
        /// No longer used. If included, the only allowed value is  RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// This parameter is no longer used.
        public let pricingPlanDataSource: String?
        /// The name of the tracker resource to update.
        public let trackerName: String

        public init(description: String? = nil, positionFiltering: PositionFiltering? = nil, trackerName: String) {
            self.description = description
            self.positionFiltering = positionFiltering
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.trackerName = trackerName
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        public init(description: String? = nil, positionFiltering: PositionFiltering? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, trackerName: String) {
            self.description = description
            self.positionFiltering = positionFiltering
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case positionFiltering = "PositionFiltering"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
        }
    }

    public struct UpdateTrackerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated tracker resource. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
        public let trackerArn: String
        /// The name of the updated tracker resource.
        public let trackerName: String
        /// The timestamp for when the tracker resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(trackerArn: String, trackerName: String, updateTime: Date) {
            self.trackerArn = trackerArn
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case trackerArn = "TrackerArn"
            case trackerName = "TrackerName"
            case updateTime = "UpdateTime"
        }
    }
}

// MARK: - Errors

/// Error enum for Location
public struct LocationErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Location
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request was denied because of insufficient access or permissions. Check with an administrator to verify your permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request was unsuccessful because of a conflict.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request has failed to process because of an unknown server error, exception, or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource that you&#39;ve entered was not found in your AWS account.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The operation was denied because the request would exceed the maximum quota set for Amazon Location Service.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied because of request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input failed to meet the constraints specified by the AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension LocationErrorType: Equatable {
    public static func == (lhs: LocationErrorType, rhs: LocationErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension LocationErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
