//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Location {
    // MARK: Enums

    public enum BatchItemErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Access to the resource was denied.
        case accessDeniedError = "AccessDeniedError"
        /// The target resource already exists.
        case conflictError = "ConflictError"
        /// Internal server error.
        case internalServerError = "InternalServerError"
        /// The target resource does not exist.
        case resourceNotFoundError = "ResourceNotFoundError"
        /// Too many requests.
        case throttlingError = "ThrottlingError"
        /// Input fails to satisfy the constraints specified by the service.
        case validationError = "ValidationError"
        public var description: String { return self.rawValue }
    }

    public enum DimensionUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case feet = "Feet"
        case meters = "Meters"
        public var description: String { return self.rawValue }
    }

    public enum DistanceUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kilometers = "Kilometers"
        case miles = "Miles"
        public var description: String { return self.rawValue }
    }

    public enum ForecastedGeofenceEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// This event type signifies that a device is forecasted to enter the geofence
        case enter = "ENTER"
        /// This event type signifies that a device is forecasted to exit the geofence
        case exit = "EXIT"
        /// This event type signifies that a device is stationary in the geofence and an exit/enter cannot be forecasted
        case idle = "IDLE"
        public var description: String { return self.rawValue }
    }

    public enum IntendedUse: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse = "SingleUse"
        /// Indicates that results of the operation may be stored locally.
        case storage = "Storage"
        public var description: String { return self.rawValue }
    }

    public enum OptimizationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fastestRoute = "FastestRoute"
        case shortestRoute = "ShortestRoute"
        public var description: String { return self.rawValue }
    }

    public enum PositionFiltering: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Filters device position updates according to their accuracy
        case accuracyBased = "AccuracyBased"
        /// Filters device position updates according to the distance between them
        case distanceBased = "DistanceBased"
        /// Filters device position updates according to their sample time
        case timeBased = "TimeBased"
        public var description: String { return self.rawValue }
    }

    public enum PricingPlan: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// This pricing plan must be picked for mobile asset management use cases
        case mobileAssetManagement = "MobileAssetManagement"
        /// This pricing plan must be picked for mobile asset tracking use cases.
        case mobileAssetTracking = "MobileAssetTracking"
        /// This pricing plan should be used for request based billing.
        case requestBasedUsage = "RequestBasedUsage"
        public var description: String { return self.rawValue }
    }

    public enum RouteMatrixErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case departurePositionNotFound = "DeparturePositionNotFound"
        case destinationPositionNotFound = "DestinationPositionNotFound"
        case otherValidationError = "OtherValidationError"
        case positionsNotFound = "PositionsNotFound"
        case routeNotFound = "RouteNotFound"
        case routeTooLong = "RouteTooLong"
        public var description: String { return self.rawValue }
    }

    public enum SpeedUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kilometersPerHour = "KilometersPerHour"
        case milesPerHour = "MilesPerHour"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// List all active API keys.
        case active = "Active"
        /// List all expired API keys.
        case expired = "Expired"
        public var description: String { return self.rawValue }
    }

    public enum TravelMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bicycle = "Bicycle"
        case car = "Car"
        case motorcycle = "Motorcycle"
        case truck = "Truck"
        case walking = "Walking"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        ///     The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotParse = "CannotParse"
        ///     The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldValidationFailed = "FieldValidationFailed"
        /// The required input is missing.
        case missing = "Missing"
        /// The input is invalid but no more specific reason is applicable.
        case other = "Other"
        /// No such field is supported.
        case unknownField = "UnknownField"
        /// No such operation is supported.
        case unknownOperation = "UnknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum VehicleWeightUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kilograms = "Kilograms"
        case pounds = "Pounds"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ApiKeyFilter: AWSEncodableShape {
        /// Filter on Active or Expired API keys.
        public let keyStatus: Status?

        @inlinable
        public init(keyStatus: Status? = nil) {
            self.keyStatus = keyStatus
        }

        private enum CodingKeys: String, CodingKey {
            case keyStatus = "KeyStatus"
        }
    }

    public struct ApiKeyRestrictions: AWSEncodableShape & AWSDecodableShape {
        /// A list of allowed actions that an API key resource grants permissions to perform. You must have at least one action for each type of resource. For example, if you have a place resource, you must include at least one place action. The following are valid values for the actions.    Map actions     geo:GetMap* - Allows all actions needed for map rendering.      Place actions     geo:SearchPlaceIndexForText - Allows geocoding.    geo:SearchPlaceIndexForPosition - Allows reverse  geocoding.    geo:SearchPlaceIndexForSuggestions - Allows generating suggestions from text.    GetPlace - Allows finding a place by place ID.      Route actions     geo:CalculateRoute - Allows point to point routing.    geo:CalculateRouteMatrix - Allows calculating a matrix of routes.      You must use these strings exactly. For example, to provide access to map  rendering, the only valid action is geo:GetMap* as an input to  the list. ["geo:GetMap*"] is valid but ["geo:GetMapTile"] is not. Similarly, you cannot use ["geo:SearchPlaceIndexFor*"] - you must list each of the Place actions separately.
        public let allowActions: [String]
        /// An optional list of allowed HTTP referers for which requests must originate from. Requests using this API key from other domains will not be allowed. Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0–9) or any symbols in this list $\-._+!*`(),;/?:@=&amp;    May contain a percent (%) if followed by 2 hexadecimal digits (A-F, a-f, 0-9); this is used for URL encoding purposes.   May contain wildcard characters question mark (?) and asterisk (*). Question mark (?) will replace any single character (including hexadecimal digits). Asterisk (*) will replace any multiple characters (including multiple hexadecimal digits).   No spaces allowed. For example, https://example.com.
        public let allowReferers: [String]?
        /// A list of allowed resource ARNs that a API key bearer can perform actions on.   The ARN must be the correct ARN for a map, place, or route ARN. You may  include wildcards in the resource-id to match multiple resources of the  same type.   The resources must be in the same partition,  region, and account-id as the key that is being  created.   Other than wildcards, you must include the full ARN, including the  arn, partition, service, region, account-id and resource-id delimited by colons (:).   No spaces allowed, even with wildcards. For example, arn:aws:geo:region:account-id:map/ExampleMap*.   For more information about ARN format, see Amazon Resource Names (ARNs).
        public let allowResources: [String]

        @inlinable
        public init(allowActions: [String], allowReferers: [String]? = nil, allowResources: [String]) {
            self.allowActions = allowActions
            self.allowReferers = allowReferers
            self.allowResources = allowResources
        }

        public func validate(name: String) throws {
            try self.allowActions.forEach {
                try validate($0, name: "allowActions[]", parent: name, max: 200)
                try validate($0, name: "allowActions[]", parent: name, min: 5)
                try validate($0, name: "allowActions[]", parent: name, pattern: "^(geo|geo-routes|geo-places|geo-maps):\\w*\\*?$")
            }
            try self.allowReferers?.forEach {
                try validate($0, name: "allowReferers[]", parent: name, max: 253)
                try validate($0, name: "allowReferers[]", parent: name, pattern: "^([$\\-._+!*\\x{60}(),;/?:@=&\\w]|%([0-9a-fA-F?]{2}|[0-9a-fA-F?]?[*]))+$")
            }
            try self.allowResources.forEach {
                try validate($0, name: "allowResources[]", parent: name, max: 1600)
                try validate($0, name: "allowResources[]", parent: name, pattern: "(^arn(:[a-z0-9]+([.-][a-z0-9]+)*):geo(:([a-z0-9]+([.-][a-z0-9]+)*))(:[0-9]+):((\\*)|([-a-z]+[/][*-._\\w]+))$)|(^arn(:[a-z0-9]+([.-][a-z0-9]+)*):(geo-routes|geo-places|geo-maps)(:((\\*)|([a-z0-9]+([.-][a-z0-9]+)*)))::((provider[\\/][*-._\\w]+))$)")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowActions = "AllowActions"
            case allowReferers = "AllowReferers"
            case allowResources = "AllowResources"
        }
    }

    public struct AssociateTrackerConsumerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker resource. Used when you need to specify a resource across all Amazon Web Services.   Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
        public let consumerArn: String
        /// The name of the tracker resource to be associated with a geofence collection.
        public let trackerName: String

        @inlinable
        public init(consumerArn: String, trackerName: String) {
            self.consumerArn = consumerArn
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.consumerArn, forKey: .consumerArn)
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, max: 1600)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case consumerArn = "ConsumerArn"
        }
    }

    public struct AssociateTrackerConsumerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct BatchDeleteDevicePositionHistoryError: AWSDecodableShape {
        /// The ID of the device for this position.
        public let deviceId: String
        public let error: BatchItemError

        @inlinable
        public init(deviceId: String, error: BatchItemError) {
            self.deviceId = deviceId
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
        }
    }

    public struct BatchDeleteDevicePositionHistoryRequest: AWSEncodableShape {
        /// Devices whose position history you want to delete.   For example, for two devices: “DeviceIds” : [DeviceId1,DeviceId2]
        public let deviceIds: [String]
        /// The name of the tracker resource to delete the device position history from.
        public let trackerName: String

        @inlinable
        public init(deviceIds: [String], trackerName: String) {
            self.deviceIds = deviceIds
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.deviceIds, forKey: .deviceIds)
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.deviceIds.forEach {
                try validate($0, name: "deviceIds[]", parent: name, max: 100)
                try validate($0, name: "deviceIds[]", parent: name, min: 1)
                try validate($0, name: "deviceIds[]", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            }
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceIds = "DeviceIds"
        }
    }

    public struct BatchDeleteDevicePositionHistoryResponse: AWSDecodableShape {
        /// Contains error details for each device history that failed to delete.
        public let errors: [BatchDeleteDevicePositionHistoryError]

        @inlinable
        public init(errors: [BatchDeleteDevicePositionHistoryError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteGeofenceError: AWSDecodableShape {
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// The geofence associated with the error message.
        public let geofenceId: String

        @inlinable
        public init(error: BatchItemError, geofenceId: String) {
            self.error = error
            self.geofenceId = geofenceId
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case geofenceId = "GeofenceId"
        }
    }

    public struct BatchDeleteGeofenceRequest: AWSEncodableShape {
        /// The geofence collection storing the geofences to be deleted.
        public let collectionName: String
        /// The batch of geofences to be deleted.
        public let geofenceIds: [String]

        @inlinable
        public init(collectionName: String, geofenceIds: [String]) {
            self.collectionName = collectionName
            self.geofenceIds = geofenceIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collectionName, key: "CollectionName")
            try container.encode(self.geofenceIds, forKey: .geofenceIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.geofenceIds.forEach {
                try validate($0, name: "geofenceIds[]", parent: name, max: 100)
                try validate($0, name: "geofenceIds[]", parent: name, min: 1)
                try validate($0, name: "geofenceIds[]", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case geofenceIds = "GeofenceIds"
        }
    }

    public struct BatchDeleteGeofenceResponse: AWSDecodableShape {
        /// Contains error details for each geofence that failed to delete.
        public let errors: [BatchDeleteGeofenceError]

        @inlinable
        public init(errors: [BatchDeleteGeofenceError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchEvaluateGeofencesError: AWSDecodableShape {
        /// The device associated with the position evaluation error.
        public let deviceId: String
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// Specifies a timestamp for when the error occurred in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        @inlinable
        public init(deviceId: String, error: BatchItemError, sampleTime: Date) {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
            case sampleTime = "SampleTime"
        }
    }

    public struct BatchEvaluateGeofencesRequest: AWSEncodableShape {
        /// The geofence collection used in evaluating the position of devices against its geofences.
        public let collectionName: String
        /// Contains device details for each device to be evaluated against the given geofence collection.
        public let devicePositionUpdates: [DevicePositionUpdate]

        @inlinable
        public init(collectionName: String, devicePositionUpdates: [DevicePositionUpdate]) {
            self.collectionName = collectionName
            self.devicePositionUpdates = devicePositionUpdates
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collectionName, key: "CollectionName")
            try container.encode(self.devicePositionUpdates, forKey: .devicePositionUpdates)
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.devicePositionUpdates.forEach {
                try $0.validate(name: "\(name).devicePositionUpdates[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositionUpdates = "DevicePositionUpdates"
        }
    }

    public struct BatchEvaluateGeofencesResponse: AWSDecodableShape {
        /// Contains error details for each device that failed to evaluate its position against the given geofence collection.
        public let errors: [BatchEvaluateGeofencesError]

        @inlinable
        public init(errors: [BatchEvaluateGeofencesError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchGetDevicePositionError: AWSDecodableShape {
        /// The ID of the device that didn't return a position.
        public let deviceId: String
        /// Contains details related to the error code.
        public let error: BatchItemError

        @inlinable
        public init(deviceId: String, error: BatchItemError) {
            self.deviceId = deviceId
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
        }
    }

    public struct BatchGetDevicePositionRequest: AWSEncodableShape {
        /// Devices whose position you want to retrieve.   For example, for two devices: device-ids=DeviceId1&amp;device-ids=DeviceId2
        public let deviceIds: [String]
        /// The tracker resource retrieving the device position.
        public let trackerName: String

        @inlinable
        public init(deviceIds: [String], trackerName: String) {
            self.deviceIds = deviceIds
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.deviceIds, forKey: .deviceIds)
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.deviceIds.forEach {
                try validate($0, name: "deviceIds[]", parent: name, max: 100)
                try validate($0, name: "deviceIds[]", parent: name, min: 1)
                try validate($0, name: "deviceIds[]", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            }
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceIds = "DeviceIds"
        }
    }

    public struct BatchGetDevicePositionResponse: AWSDecodableShape {
        /// Contains device position details such as the device ID, position, and timestamps for when the position was received and sampled.
        public let devicePositions: [DevicePosition]
        /// Contains  error details for each device that failed to send its position to the tracker resource.
        public let errors: [BatchGetDevicePositionError]

        @inlinable
        public init(devicePositions: [DevicePosition], errors: [BatchGetDevicePositionError]) {
            self.devicePositions = devicePositions
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositions = "DevicePositions"
            case errors = "Errors"
        }
    }

    public struct BatchItemError: AWSDecodableShape {
        /// The error code associated with the batch request error.
        public let code: BatchItemErrorCode?
        /// A message with the reason for the batch request error.
        public let message: String?

        @inlinable
        public init(code: BatchItemErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct BatchPutGeofenceError: AWSDecodableShape {
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// The geofence associated with the error message.
        public let geofenceId: String

        @inlinable
        public init(error: BatchItemError, geofenceId: String) {
            self.error = error
            self.geofenceId = geofenceId
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case geofenceId = "GeofenceId"
        }
    }

    public struct BatchPutGeofenceRequest: AWSEncodableShape {
        /// The geofence collection storing the geofences.
        public let collectionName: String
        /// The batch of geofences to be stored in a geofence collection.
        public let entries: [BatchPutGeofenceRequestEntry]

        @inlinable
        public init(collectionName: String, entries: [BatchPutGeofenceRequestEntry]) {
            self.collectionName = collectionName
            self.entries = entries
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collectionName, key: "CollectionName")
            try container.encode(self.entries, forKey: .entries)
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
        }
    }

    public struct BatchPutGeofenceRequestEntry: AWSEncodableShape {
        /// The identifier for the geofence to be stored in a given geofence collection.
        public let geofenceId: String
        /// Associates one of more properties with the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
        public let geofenceProperties: [String: String]?
        /// Contains the details to specify the position of the geofence. Can be a polygon, a circle or a polygon encoded in Geobuf format. Including multiple selections will return a validation error.  The  geofence polygon format supports a maximum of 1,000 vertices. The Geofence geobuf format supports a maximum of 100,000 vertices.
        public let geometry: GeofenceGeometry

        @inlinable
        public init(geofenceId: String, geofenceProperties: [String: String]? = nil, geometry: GeofenceGeometry) {
            self.geofenceId = geofenceId
            self.geofenceProperties = geofenceProperties
            self.geometry = geometry
        }

        public func validate(name: String) throws {
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.geofenceProperties, name: "geofenceProperties", parent: name, max: 3)
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case geofenceId = "GeofenceId"
            case geofenceProperties = "GeofenceProperties"
            case geometry = "Geometry"
        }
    }

    public struct BatchPutGeofenceResponse: AWSDecodableShape {
        /// Contains additional error details for each geofence that failed to be stored in a geofence collection.
        public let errors: [BatchPutGeofenceError]
        /// Contains each geofence that was successfully stored in a geofence collection.
        public let successes: [BatchPutGeofenceSuccess]

        @inlinable
        public init(errors: [BatchPutGeofenceError], successes: [BatchPutGeofenceSuccess]) {
            self.errors = errors
            self.successes = successes
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case successes = "Successes"
        }
    }

    public struct BatchPutGeofenceSuccess: AWSDecodableShape {
        /// The timestamp for when the geofence was stored in a geofence collection in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence successfully stored in a geofence collection.
        public let geofenceId: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(createTime: Date, geofenceId: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case updateTime = "UpdateTime"
        }
    }

    public struct BatchUpdateDevicePositionError: AWSDecodableShape {
        /// The device associated with the failed location update.
        public let deviceId: String
        /// Contains details related to the error code such as the error code and error message.
        public let error: BatchItemError
        /// The timestamp at which the device position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        @inlinable
        public init(deviceId: String, error: BatchItemError, sampleTime: Date) {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
            case sampleTime = "SampleTime"
        }
    }

    public struct BatchUpdateDevicePositionRequest: AWSEncodableShape {
        /// The name of the tracker resource to update.
        public let trackerName: String
        /// Contains the position update details for each device, up to 10 devices.
        public let updates: [DevicePositionUpdate]

        @inlinable
        public init(trackerName: String, updates: [DevicePositionUpdate]) {
            self.trackerName = trackerName
            self.updates = updates
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.trackerName, key: "TrackerName")
            try container.encode(self.updates, forKey: .updates)
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
            try self.updates.forEach {
                try $0.validate(name: "\(name).updates[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case updates = "Updates"
        }
    }

    public struct BatchUpdateDevicePositionResponse: AWSDecodableShape {
        /// Contains  error details for each device that failed to update its position.
        public let errors: [BatchUpdateDevicePositionError]

        @inlinable
        public init(errors: [BatchUpdateDevicePositionError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct CalculateRouteCarModeOptions: AWSEncodableShape {
        /// Avoids ferries when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidFerries: Bool?
        /// Avoids tolls when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidTolls: Bool?

        @inlinable
        public init(avoidFerries: Bool? = nil, avoidTolls: Bool? = nil) {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
        }

        private enum CodingKeys: String, CodingKey {
            case avoidFerries = "AvoidFerries"
            case avoidTolls = "AvoidTolls"
        }
    }

    public struct CalculateRouteMatrixRequest: AWSEncodableShape {
        /// The name of the route calculator resource that you want to use to calculate the route matrix.
        public let calculatorName: String
        /// Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
        public let carModeOptions: CalculateRouteCarModeOptions?
        /// Sets the time of departure as the current time. Uses the current time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix. Default Value: false  Valid Values: false | true
        public let departNow: Bool?
        /// The list of departure (origin) positions for the route matrix. An array of points, each of which is itself a 2-value array defined in WGS 84 format: [longitude, latitude]. For example, [-123.115, 49.285].  Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See  Position restrictions in the Amazon Location Service Developer Guide.   For route calculators that use Esri as the data provider, if you specify a departure that's not located on a road, Amazon Location  moves the position to the nearest road. The snapped value is available in the result in SnappedDeparturePositions.  Valid Values: [-180 to 180,-90 to 90]
        public let departurePositions: [[Double]]
        /// Specifies the desired time of departure. Uses the given time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix.  Setting a departure time in the past returns a 400 ValidationException error.    In ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
        @OptionalCustomCoding<ISO8601DateCoder>
        public var departureTime: Date?
        /// The list of destination positions for the route matrix. An array of points, each of which is itself a 2-value array defined in WGS 84 format: [longitude, latitude]. For example, [-122.339, 47.615]   Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See  Position restrictions in the Amazon Location Service Developer Guide.   For route calculators that use Esri as the data provider, if you specify a destination that's not located on a road, Amazon Location  moves the position to the nearest road. The snapped value is available in the result in SnappedDestinationPositions.  Valid Values: [-180 to 180,-90 to 90]
        public let destinationPositions: [[Double]]
        /// Set the unit system to specify the distance. Default Value: Kilometers
        public let distanceUnit: DistanceUnit?
        /// The optional API key to authorize  the request.
        public let key: String?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. The TravelMode you specify also determines how you specify route preferences:    If traveling by Car use the CarModeOptions parameter.   If traveling by Truck use the TruckModeOptions parameter.     Bicycle or Motorcycle are only valid when using Grab as a data provider, and only within Southeast Asia.  Truck is not available for Grab. For more information about using Grab as a data provider, see GrabMaps in the Amazon Location Service Developer Guide.  Default Value: Car
        public let travelMode: TravelMode?
        /// Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
        public let truckModeOptions: CalculateRouteTruckModeOptions?

        @inlinable
        public init(calculatorName: String, carModeOptions: CalculateRouteCarModeOptions? = nil, departNow: Bool? = nil, departurePositions: [[Double]], departureTime: Date? = nil, destinationPositions: [[Double]], distanceUnit: DistanceUnit? = nil, key: String? = nil, travelMode: TravelMode? = nil, truckModeOptions: CalculateRouteTruckModeOptions? = nil) {
            self.calculatorName = calculatorName
            self.carModeOptions = carModeOptions
            self.departNow = departNow
            self.departurePositions = departurePositions
            self.departureTime = departureTime
            self.destinationPositions = destinationPositions
            self.distanceUnit = distanceUnit
            self.key = key
            self.travelMode = travelMode
            self.truckModeOptions = truckModeOptions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.calculatorName, key: "CalculatorName")
            try container.encodeIfPresent(self.carModeOptions, forKey: .carModeOptions)
            try container.encodeIfPresent(self.departNow, forKey: .departNow)
            try container.encode(self.departurePositions, forKey: .departurePositions)
            try container.encodeIfPresent(self.departureTime, forKey: .departureTime)
            try container.encode(self.destinationPositions, forKey: .destinationPositions)
            try container.encodeIfPresent(self.distanceUnit, forKey: .distanceUnit)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.travelMode, forKey: .travelMode)
            try container.encodeIfPresent(self.truckModeOptions, forKey: .truckModeOptions)
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
            try self.departurePositions.forEach {
                try validate($0, name: "departurePositions[]", parent: name, max: 2)
                try validate($0, name: "departurePositions[]", parent: name, min: 2)
            }
            try self.destinationPositions.forEach {
                try validate($0, name: "destinationPositions[]", parent: name, max: 2)
                try validate($0, name: "destinationPositions[]", parent: name, min: 2)
            }
            try self.validate(self.key, name: "key", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case carModeOptions = "CarModeOptions"
            case departNow = "DepartNow"
            case departurePositions = "DeparturePositions"
            case departureTime = "DepartureTime"
            case destinationPositions = "DestinationPositions"
            case distanceUnit = "DistanceUnit"
            case travelMode = "TravelMode"
            case truckModeOptions = "TruckModeOptions"
        }
    }

    public struct CalculateRouteMatrixResponse: AWSDecodableShape {
        /// The calculated route matrix containing the results for all pairs of DeparturePositions to DestinationPositions. Each row corresponds to one entry in DeparturePositions. Each entry in the row corresponds to the route from that entry in DeparturePositions to an entry in DestinationPositions.
        public let routeMatrix: [[RouteMatrixEntry]]
        /// For routes calculated using an Esri route calculator resource, departure positions are snapped to the closest road. For Esri route calculator resources, this returns the list of departure/origin positions used for calculation of the RouteMatrix.
        public let snappedDeparturePositions: [[Double]]?
        /// The list of destination positions for the route matrix used for calculation of the RouteMatrix.
        public let snappedDestinationPositions: [[Double]]?
        /// Contains information about the route matrix, DataSource, DistanceUnit, RouteCount and ErrorCount.
        public let summary: CalculateRouteMatrixSummary

        @inlinable
        public init(routeMatrix: [[RouteMatrixEntry]], snappedDeparturePositions: [[Double]]? = nil, snappedDestinationPositions: [[Double]]? = nil, summary: CalculateRouteMatrixSummary) {
            self.routeMatrix = routeMatrix
            self.snappedDeparturePositions = snappedDeparturePositions
            self.snappedDestinationPositions = snappedDestinationPositions
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case routeMatrix = "RouteMatrix"
            case snappedDeparturePositions = "SnappedDeparturePositions"
            case snappedDestinationPositions = "SnappedDestinationPositions"
            case summary = "Summary"
        }
    }

    public struct CalculateRouteMatrixSummary: AWSDecodableShape {
        /// The data provider of traffic and road network data used to calculate the routes. Indicates one of the available providers:    Esri     Grab     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The unit of measurement for route distances.
        public let distanceUnit: DistanceUnit
        /// The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.
        public let errorCount: Int
        /// The count of cells in the route matrix. Equal to the number of DeparturePositions multiplied by the number of DestinationPositions.
        public let routeCount: Int

        @inlinable
        public init(dataSource: String, distanceUnit: DistanceUnit, errorCount: Int, routeCount: Int) {
            self.dataSource = dataSource
            self.distanceUnit = distanceUnit
            self.errorCount = errorCount
            self.routeCount = routeCount
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case distanceUnit = "DistanceUnit"
            case errorCount = "ErrorCount"
            case routeCount = "RouteCount"
        }
    }

    public struct CalculateRouteRequest: AWSEncodableShape {
        /// Specifies the desired time of arrival. Uses the given time to calculate the route.  Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.  ArrivalTime is not supported Esri.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var arrivalTime: Date?
        /// The name of the route calculator resource that you want to use to calculate the route.
        public let calculatorName: String
        /// Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
        public let carModeOptions: CalculateRouteCarModeOptions?
        /// Sets the time of departure as the current time. Uses the current time to calculate a route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route. Default Value: false  Valid Values: false | true
        public let departNow: Bool?
        /// The start position for the route. Defined in World Geodetic System (WGS 84) format: [longitude, latitude].   For example, [-123.115, 49.285]     If you specify a departure that's not located on a road, Amazon Location moves the position to the nearest road. If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error.  Valid Values: [-180 to 180,-90 to 90]
        public let departurePosition: [Double]
        /// Specifies the desired time of departure. Uses the given time to calculate the route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.   In ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
        @OptionalCustomCoding<ISO8601DateCoder>
        public var departureTime: Date?
        /// The finish position for the route. Defined in World Geodetic System (WGS 84) format: [longitude, latitude].   For example, [-122.339, 47.615]     If you specify a destination that's not located on a road, Amazon Location moves the position to the nearest road.   Valid Values: [-180 to 180,-90 to 90]
        public let destinationPosition: [Double]
        /// Set the unit system to specify the distance. Default Value: Kilometers
        public let distanceUnit: DistanceUnit?
        /// Set to include the geometry details in the result for each path between a pair of positions. Default Value: false  Valid Values: false | true
        public let includeLegGeometry: Bool?
        /// The optional API key to authorize  the request.
        public let key: String?
        /// Specifies the distance to optimize for when calculating a route.
        public let optimizeFor: OptimizationMode?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. You can choose Car, Truck,  Walking, Bicycle or Motorcycle as options for  the TravelMode.   Bicycle and Motorcycle are only valid when using Grab as a data provider, and only within Southeast Asia.  Truck is not available for Grab. For more details on the using Grab for routing, including areas of coverage, see GrabMaps in the Amazon Location Service Developer Guide.  The TravelMode you specify also determines how you specify route preferences:    If traveling by Car use the CarModeOptions parameter.   If traveling by Truck use the TruckModeOptions parameter.   Default Value: Car
        public let travelMode: TravelMode?
        /// Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
        public let truckModeOptions: CalculateRouteTruckModeOptions?
        /// Specifies an ordered list of up to 23 intermediate positions to include along a route between the departure position and destination position.    For example, from the DeparturePosition [-123.115, 49.285], the route follows the order that the waypoint positions are given [[-122.757, 49.0021],[-122.349, 47.620]]     If you specify a waypoint position that's not located on a road, Amazon Location moves the position to the nearest road.  Specifying more than 23 waypoints returns a 400 ValidationException error. If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error.  Valid Values: [-180 to 180,-90 to 90]
        public let waypointPositions: [[Double]]?

        @inlinable
        public init(arrivalTime: Date? = nil, calculatorName: String, carModeOptions: CalculateRouteCarModeOptions? = nil, departNow: Bool? = nil, departurePosition: [Double], departureTime: Date? = nil, destinationPosition: [Double], distanceUnit: DistanceUnit? = nil, includeLegGeometry: Bool? = nil, key: String? = nil, optimizeFor: OptimizationMode? = nil, travelMode: TravelMode? = nil, truckModeOptions: CalculateRouteTruckModeOptions? = nil, waypointPositions: [[Double]]? = nil) {
            self.arrivalTime = arrivalTime
            self.calculatorName = calculatorName
            self.carModeOptions = carModeOptions
            self.departNow = departNow
            self.departurePosition = departurePosition
            self.departureTime = departureTime
            self.destinationPosition = destinationPosition
            self.distanceUnit = distanceUnit
            self.includeLegGeometry = includeLegGeometry
            self.key = key
            self.optimizeFor = optimizeFor
            self.travelMode = travelMode
            self.truckModeOptions = truckModeOptions
            self.waypointPositions = waypointPositions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.arrivalTime, forKey: .arrivalTime)
            request.encodePath(self.calculatorName, key: "CalculatorName")
            try container.encodeIfPresent(self.carModeOptions, forKey: .carModeOptions)
            try container.encodeIfPresent(self.departNow, forKey: .departNow)
            try container.encode(self.departurePosition, forKey: .departurePosition)
            try container.encodeIfPresent(self.departureTime, forKey: .departureTime)
            try container.encode(self.destinationPosition, forKey: .destinationPosition)
            try container.encodeIfPresent(self.distanceUnit, forKey: .distanceUnit)
            try container.encodeIfPresent(self.includeLegGeometry, forKey: .includeLegGeometry)
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.optimizeFor, forKey: .optimizeFor)
            try container.encodeIfPresent(self.travelMode, forKey: .travelMode)
            try container.encodeIfPresent(self.truckModeOptions, forKey: .truckModeOptions)
            try container.encodeIfPresent(self.waypointPositions, forKey: .waypointPositions)
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.departurePosition, name: "departurePosition", parent: name, max: 2)
            try self.validate(self.departurePosition, name: "departurePosition", parent: name, min: 2)
            try self.validate(self.destinationPosition, name: "destinationPosition", parent: name, max: 2)
            try self.validate(self.destinationPosition, name: "destinationPosition", parent: name, min: 2)
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.waypointPositions?.forEach {
                try validate($0, name: "waypointPositions[]", parent: name, max: 2)
                try validate($0, name: "waypointPositions[]", parent: name, min: 2)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arrivalTime = "ArrivalTime"
            case carModeOptions = "CarModeOptions"
            case departNow = "DepartNow"
            case departurePosition = "DeparturePosition"
            case departureTime = "DepartureTime"
            case destinationPosition = "DestinationPosition"
            case distanceUnit = "DistanceUnit"
            case includeLegGeometry = "IncludeLegGeometry"
            case optimizeFor = "OptimizeFor"
            case travelMode = "TravelMode"
            case truckModeOptions = "TruckModeOptions"
            case waypointPositions = "WaypointPositions"
        }
    }

    public struct CalculateRouteResponse: AWSDecodableShape {
        /// Contains details about each path between a pair of positions included along a route such as: StartPosition, EndPosition, Distance, DurationSeconds, Geometry, and Steps. The number of legs returned corresponds to one fewer than the total number of positions in the request.  For example, a route with a departure position and destination position returns one leg with the positions snapped to a nearby road:   The StartPosition is the departure position.   The EndPosition is the destination position.   A route with a waypoint between the departure and destination position returns two legs with the positions snapped to a nearby road:   Leg 1: The StartPosition is the departure position . The EndPosition is the waypoint positon.   Leg 2: The StartPosition is the waypoint position. The EndPosition is the destination position.
        public let legs: [Leg]
        /// Contains information about the whole route, such as: RouteBBox, DataSource, Distance, DistanceUnit, and DurationSeconds.
        public let summary: CalculateRouteSummary

        @inlinable
        public init(legs: [Leg], summary: CalculateRouteSummary) {
            self.legs = legs
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case legs = "Legs"
            case summary = "Summary"
        }
    }

    public struct CalculateRouteSummary: AWSDecodableShape {
        /// The data provider of traffic and road network data used to calculate the route. Indicates one of the available providers:    Esri     Grab     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The total distance covered by the route. The sum of the distance travelled between every stop on the route.  If Esri is the data source for the route calculator, the route distance can’t be greater than 400 km. If the route exceeds 400 km, the response is a 400 RoutesValidationException error.
        public let distance: Double
        /// The unit of measurement for route distances.
        public let distanceUnit: DistanceUnit
        /// The total travel time for the route measured in seconds. The sum of the travel time between every stop on the route.
        public let durationSeconds: Double
        /// Specifies a geographical box surrounding a route. Used to zoom into a route when displaying it in a map. For example, [min x, min y, max x, max y]. The first 2 bbox parameters describe the lower southwest corner:    The first bbox position is the X coordinate or longitude of the lower southwest corner.    The second bbox position is the Y coordinate or latitude of the lower southwest corner.    The next 2 bbox parameters describe the upper northeast corner:    The third bbox position is the X coordinate, or longitude of the upper northeast corner.    The fourth bbox position is the Y coordinate, or latitude of the upper northeast corner.
        public let routeBBox: [Double]

        @inlinable
        public init(dataSource: String, distance: Double, distanceUnit: DistanceUnit, durationSeconds: Double, routeBBox: [Double]) {
            self.dataSource = dataSource
            self.distance = distance
            self.distanceUnit = distanceUnit
            self.durationSeconds = durationSeconds
            self.routeBBox = routeBBox
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case distance = "Distance"
            case distanceUnit = "DistanceUnit"
            case durationSeconds = "DurationSeconds"
            case routeBBox = "RouteBBox"
        }
    }

    public struct CalculateRouteTruckModeOptions: AWSEncodableShape {
        /// Avoids ferries when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidFerries: Bool?
        /// Avoids tolls when calculating routes. Default Value: false  Valid Values: false | true
        public let avoidTolls: Bool?
        /// Specifies the truck's dimension specifications including length, height, width, and unit of measurement. Used to avoid roads that can't support the truck's dimensions.
        public let dimensions: TruckDimensions?
        /// Specifies the truck's weight specifications including total weight and unit of measurement. Used to avoid roads that can't support the truck's weight.
        public let weight: TruckWeight?

        @inlinable
        public init(avoidFerries: Bool? = nil, avoidTolls: Bool? = nil, dimensions: TruckDimensions? = nil, weight: TruckWeight? = nil) {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
            self.dimensions = dimensions
            self.weight = weight
        }

        private enum CodingKeys: String, CodingKey {
            case avoidFerries = "AvoidFerries"
            case avoidTolls = "AvoidTolls"
            case dimensions = "Dimensions"
            case weight = "Weight"
        }
    }

    public struct CellSignals: AWSEncodableShape {
        /// Information about the Long-Term Evolution (LTE) network the device is connected to.
        public let lteCellDetails: [LteCellDetails]

        @inlinable
        public init(lteCellDetails: [LteCellDetails]) {
            self.lteCellDetails = lteCellDetails
        }

        public func validate(name: String) throws {
            try self.lteCellDetails.forEach {
                try $0.validate(name: "\(name).lteCellDetails[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case lteCellDetails = "LteCellDetails"
        }
    }

    public struct Circle: AWSEncodableShape & AWSDecodableShape {
        /// A single point geometry, specifying the center of the circle, using WGS 84 coordinates, in the form [longitude, latitude].
        public let center: [Double]
        /// The radius of the circle in meters. Must be greater than zero and no  larger than 100,000 (100 kilometers).
        public let radius: Double

        @inlinable
        public init(center: [Double], radius: Double) {
            self.center = center
            self.radius = radius
        }

        public func validate(name: String) throws {
            try self.validate(self.center, name: "center", parent: name, max: 2)
            try self.validate(self.center, name: "center", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case center = "Center"
            case radius = "Radius"
        }
    }

    public struct CreateGeofenceCollectionRequest: AWSEncodableShape {
        /// A custom name for the geofence collection. Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).    Must be a unique geofence collection name.   No spaces allowed. For example, ExampleGeofenceCollection.
        public let collectionName: String
        /// An optional description for the geofence collection.
        public let description: String?
        /// A key identifier for an Amazon Web Services KMS customer managed key. Enter a key ID, key ARN, alias name, or alias ARN.
        ///
        public let kmsKeyId: String?
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// This parameter is no longer used.
        public let pricingPlanDataSource: String?
        /// Applies one or more tags to the geofence collection. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]?

        @inlinable
        public init(collectionName: String, description: String? = nil, kmsKeyId: String? = nil, tags: [String: String]? = nil) {
            self.collectionName = collectionName
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = tags
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        @inlinable
        public init(collectionName: String, description: String? = nil, kmsKeyId: String? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil) {
            self.collectionName = collectionName
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "CollectionName"
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
        }
    }

    public struct CreateGeofenceCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all Amazon Web Services.    Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
        public let collectionArn: String
        /// The name for the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date

        @inlinable
        public init(collectionArn: String, collectionName: String, createTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.createTime = createTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
        }
    }

    public struct CreateKeyRequest: AWSEncodableShape {
        /// An optional description for the API key resource.
        public let description: String?
        /// The optional timestamp for when the API key resource will expire in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. One of NoExpiry or ExpireTime must be set.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expireTime: Date?
        /// A custom name for the API key resource. Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).    Must be a unique API key name.   No spaces allowed. For example, ExampleAPIKey.
        public let keyName: String
        /// Optionally set to true to set no expiration time for the API key. One of NoExpiry or ExpireTime must be set.
        public let noExpiry: Bool?
        /// The API key restrictions for the API key resource.
        public let restrictions: ApiKeyRestrictions
        /// Applies one or more tags to the map resource. A tag is a key-value pair that helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, expireTime: Date? = nil, keyName: String, noExpiry: Bool? = nil, restrictions: ApiKeyRestrictions, tags: [String: String]? = nil) {
            self.description = description
            self.expireTime = expireTime
            self.keyName = keyName
            self.noExpiry = noExpiry
            self.restrictions = restrictions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.keyName, name: "keyName", parent: name, max: 100)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[-._\\w]+$")
            try self.restrictions.validate(name: "\(name).restrictions")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case expireTime = "ExpireTime"
            case keyName = "KeyName"
            case noExpiry = "NoExpiry"
            case restrictions = "Restrictions"
            case tags = "Tags"
        }
    }

    public struct CreateKeyResponse: AWSDecodableShape {
        /// The timestamp for when the API key resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The key value/string of an API key. This value is used when making API calls to authorize the call. For example, see GetMapGlyphs.
        public let key: String
        /// The Amazon Resource Name (ARN) for the API key resource. Used when you need to specify a resource across all Amazon Web Services.   Format example: arn:aws:geo:region:account-id:key/ExampleKey
        public let keyArn: String
        /// The name of the API key resource.
        public let keyName: String

        @inlinable
        public init(createTime: Date, key: String, keyArn: String, keyName: String) {
            self.createTime = createTime
            self.key = key
            self.keyArn = keyArn
            self.keyName = keyName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case key = "Key"
            case keyArn = "KeyArn"
            case keyName = "KeyName"
        }
    }

    public struct CreateMapRequest: AWSEncodableShape {
        /// Specifies the MapConfiguration, including the map style, for the  map resource that you create. The map style defines the look of maps and the data  provider for your map resource.
        public let configuration: MapConfiguration
        /// An optional description for the map resource.
        public let description: String?
        /// The name for the map resource. Requirements:   Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).    Must be a unique map resource name.    No spaces allowed. For example, ExampleMap.
        public let mapName: String
        /// No longer used. If included, the only allowed value is  RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Applies one or more tags to the map resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length:  256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]?

        @inlinable
        public init(configuration: MapConfiguration, description: String? = nil, mapName: String, tags: [String: String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.mapName = mapName
            self.pricingPlan = nil
            self.tags = tags
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(configuration: MapConfiguration, description: String? = nil, mapName: String, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case description = "Description"
            case mapName = "MapName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
        }
    }

    public struct CreateMapResponse: AWSDecodableShape {
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all Amazon Web Services.   Format example: arn:aws:geo:region:account-id:map/ExampleMap
        public let mapArn: String
        /// The name of the map resource.
        public let mapName: String

        @inlinable
        public init(createTime: Date, mapArn: String, mapName: String) {
            self.createTime = createTime
            self.mapArn = mapArn
            self.mapName = mapName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case mapArn = "MapArn"
            case mapName = "MapName"
        }
    }

    public struct CreatePlaceIndexRequest: AWSEncodableShape {
        /// Specifies the geospatial data provider for the new place index.  This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error.  Valid values include:    Esri – For additional information about Esri's coverage in your region of interest, see Esri details on geocoding coverage.    Grab – Grab provides place index functionality for Southeast  Asia. For additional information about GrabMaps' coverage, see GrabMaps countries and areas covered.    Here – For additional information about HERE Technologies' coverage in your region of interest, see HERE details on goecoding coverage.  If you specify HERE Technologies (Here) as the data provider, you may not store results for locations in Japan. For more information, see the Amazon Web Services Service Terms for Amazon Location Service.    For additional information , see Data providers on the Amazon Location Service Developer Guide.
        public let dataSource: String
        /// Specifies the data storage option requesting Places.
        public let dataSourceConfiguration: DataSourceConfiguration?
        /// The optional description for the place index resource.
        public let description: String?
        /// The name of the place index resource.  Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).   Must be a unique place index resource name.   No spaces allowed. For example, ExamplePlaceIndex.
        public let indexName: String
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Applies one or more tags to the place index resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource.   Each tag key must be unique and must have exactly one associated value.   Maximum key length: 128 Unicode characters in UTF-8.   Maximum value length: 256 Unicode characters in UTF-8.   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @   Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]?

        @inlinable
        public init(dataSource: String, dataSourceConfiguration: DataSourceConfiguration? = nil, description: String? = nil, indexName: String, tags: [String: String]? = nil) {
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexName = indexName
            self.pricingPlan = nil
            self.tags = tags
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(dataSource: String, dataSourceConfiguration: DataSourceConfiguration? = nil, description: String? = nil, indexName: String, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil) {
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case dataSourceConfiguration = "DataSourceConfiguration"
            case description = "Description"
            case indexName = "IndexName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
        }
    }

    public struct CreatePlaceIndexResponse: AWSDecodableShape {
        /// The timestamp for when the place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across Amazon Web Services.    Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
        public let indexArn: String
        /// The name for the place index resource.
        public let indexName: String

        @inlinable
        public init(createTime: Date, indexArn: String, indexName: String) {
            self.createTime = createTime
            self.indexArn = indexArn
            self.indexName = indexName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case indexArn = "IndexArn"
            case indexName = "IndexName"
        }
    }

    public struct CreateRouteCalculatorRequest: AWSEncodableShape {
        /// The name of the route calculator resource.  Requirements:   Can use alphanumeric characters (A–Z, a–z, 0–9) , hyphens (-), periods (.), and underscores (_).   Must be a unique Route calculator resource name.   No spaces allowed. For example, ExampleRouteCalculator.
        public let calculatorName: String
        /// Specifies the data provider of traffic and road network data.  This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error.  Valid values include:    Esri – For additional information about Esri's coverage in your region of interest, see Esri details on street networks and traffic coverage. Route calculators that use Esri as a data source only calculate routes that are shorter than 400 km.    Grab – Grab provides routing functionality for Southeast Asia. For additional information about GrabMaps' coverage, see GrabMaps countries and areas covered.    Here – For additional information about HERE Technologies' coverage in your region of interest, see HERE car routing coverage and HERE truck routing coverage.   For additional information , see Data providers on the Amazon Location Service Developer Guide.
        public let dataSource: String
        /// The optional description for the route calculator resource.
        public let description: String?
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Applies one or more tags to the route calculator resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.   For example: { "tag1" : "value1", "tag2" : "value2"}   Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]?

        @inlinable
        public init(calculatorName: String, dataSource: String, description: String? = nil, tags: [String: String]? = nil) {
            self.calculatorName = calculatorName
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = nil
            self.tags = tags
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(calculatorName: String, dataSource: String, description: String? = nil, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil) {
            self.calculatorName = calculatorName
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorName = "CalculatorName"
            case dataSource = "DataSource"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
        }
    }

    public struct CreateRouteCalculatorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the route calculator resource. Use the ARN when you specify a resource across all Amazon Web Services.   Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
        public let calculatorArn: String
        /// The name of the route calculator resource.    For example, ExampleRouteCalculator.
        public let calculatorName: String
        /// The timestamp when the route calculator resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date

        @inlinable
        public init(calculatorArn: String, calculatorName: String, createTime: Date) {
            self.calculatorArn = calculatorArn
            self.calculatorName = calculatorName
            self.createTime = createTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorArn = "CalculatorArn"
            case calculatorName = "CalculatorName"
            case createTime = "CreateTime"
        }
    }

    public struct CreateTrackerRequest: AWSEncodableShape {
        /// An optional description for the tracker resource.
        public let description: String?
        /// Whether to enable position UPDATE events from this tracker to be sent to  EventBridge.  You do not need enable this feature to get ENTER and  EXIT events for geofences with this tracker. Those events are always sent to EventBridge.
        public let eventBridgeEnabled: Bool?
        /// Enables GeospatialQueries for a tracker that uses a Amazon Web Services KMS customer managed key. This parameter is only used if you are using a KMS customer managed key.  If you wish to encrypt your data using your own KMS customer managed key, then the Bounding Polygon Queries feature will be disabled by default.  This is because by using this feature, a representation of your device positions will not be encrypted using the your KMS managed key. The exact device position, however; is still encrypted using your managed key. You can choose to opt-in to the Bounding Polygon Quseries feature. This is done by setting the KmsKeyEnableGeospatialQueries parameter to  true when creating or updating a Tracker.
        public let kmsKeyEnableGeospatialQueries: Bool?
        /// A key identifier for an  Amazon Web Services  KMS customer managed key. Enter a key ID, key ARN, alias name, or alias ARN.
        public let kmsKeyId: String?
        /// Specifies the position filtering for the tracker resource. Valid values:    TimeBased - Location updates are evaluated against linked geofence collections,  but not every location update is stored. If your update frequency is more often than 30 seconds,  only one update per 30 seconds is stored for each unique device ID.     DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are  ignored. Location updates within this area are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.     AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This can reduce the effects of GPS noise when displaying device trajectories on a map, and can help control your costs by reducing the number of geofence evaluations.    This field is optional. If not specified, the default value is TimeBased.
        public let positionFiltering: PositionFiltering?
        /// No longer used. If included, the only allowed value is  RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// This parameter is no longer used.
        public let pricingPlanDataSource: String?
        /// Applies one or more tags to the tracker resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]?
        /// The name for the tracker resource. Requirements:   Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).   Must be a unique tracker resource name.   No spaces allowed. For example, ExampleTracker.
        public let trackerName: String

        @inlinable
        public init(description: String? = nil, eventBridgeEnabled: Bool? = nil, kmsKeyEnableGeospatialQueries: Bool? = nil, kmsKeyId: String? = nil, positionFiltering: PositionFiltering? = nil, tags: [String: String]? = nil, trackerName: String) {
            self.description = description
            self.eventBridgeEnabled = eventBridgeEnabled
            self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
            self.kmsKeyId = kmsKeyId
            self.positionFiltering = positionFiltering
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = tags
            self.trackerName = trackerName
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        @inlinable
        public init(description: String? = nil, eventBridgeEnabled: Bool? = nil, kmsKeyEnableGeospatialQueries: Bool? = nil, kmsKeyId: String? = nil, positionFiltering: PositionFiltering? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil, trackerName: String) {
            self.description = description
            self.eventBridgeEnabled = eventBridgeEnabled
            self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
            self.kmsKeyId = kmsKeyId
            self.positionFiltering = positionFiltering
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case eventBridgeEnabled = "EventBridgeEnabled"
            case kmsKeyEnableGeospatialQueries = "KmsKeyEnableGeospatialQueries"
            case kmsKeyId = "KmsKeyId"
            case positionFiltering = "PositionFiltering"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
            case trackerName = "TrackerName"
        }
    }

    public struct CreateTrackerResponse: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all Amazon Web Services.   Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
        public let trackerArn: String
        /// The name of the tracker resource.
        public let trackerName: String

        @inlinable
        public init(createTime: Date, trackerArn: String, trackerName: String) {
            self.createTime = createTime
            self.trackerArn = trackerArn
            self.trackerName = trackerName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case trackerArn = "TrackerArn"
            case trackerName = "TrackerName"
        }
    }

    public struct DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how the results of an operation will be stored by the caller.  Valid values include:    SingleUse specifies that the results won't be stored.     Storage specifies that the result can be cached or stored in a database.   Default value: SingleUse
        public let intendedUse: IntendedUse?

        @inlinable
        public init(intendedUse: IntendedUse? = nil) {
            self.intendedUse = intendedUse
        }

        private enum CodingKeys: String, CodingKey {
            case intendedUse = "IntendedUse"
        }
    }

    public struct DeleteGeofenceCollectionRequest: AWSEncodableShape {
        /// The name of the geofence collection to be deleted.
        public let collectionName: String

        @inlinable
        public init(collectionName: String) {
            self.collectionName = collectionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collectionName, key: "CollectionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGeofenceCollectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKeyRequest: AWSEncodableShape {
        /// ForceDelete bypasses an API key's expiry conditions and deletes the key. Set the parameter true to delete the key or to false to not preemptively delete the API key. Valid values: true, or false. Required: No  This action is irreversible. Only use ForceDelete if you are certain the key is no longer in use.
        public let forceDelete: Bool?
        /// The name of the API key to delete.
        public let keyName: String

        @inlinable
        public init(forceDelete: Bool? = nil, keyName: String) {
            self.forceDelete = forceDelete
            self.keyName = keyName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.forceDelete, key: "forceDelete")
            request.encodePath(self.keyName, key: "KeyName")
        }

        public func validate(name: String) throws {
            try self.validate(self.keyName, name: "keyName", parent: name, max: 100)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKeyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMapRequest: AWSEncodableShape {
        /// The name of the map resource to be deleted.
        public let mapName: String

        @inlinable
        public init(mapName: String) {
            self.mapName = mapName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.mapName, key: "MapName")
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMapResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePlaceIndexRequest: AWSEncodableShape {
        /// The name of the place index resource to be deleted.
        public let indexName: String

        @inlinable
        public init(indexName: String) {
            self.indexName = indexName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.indexName, key: "IndexName")
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePlaceIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRouteCalculatorRequest: AWSEncodableShape {
        /// The name of the route calculator resource to be deleted.
        public let calculatorName: String

        @inlinable
        public init(calculatorName: String) {
            self.calculatorName = calculatorName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.calculatorName, key: "CalculatorName")
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRouteCalculatorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTrackerRequest: AWSEncodableShape {
        /// The name of the tracker resource to be deleted.
        public let trackerName: String

        @inlinable
        public init(trackerName: String) {
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTrackerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeGeofenceCollectionRequest: AWSEncodableShape {
        /// The name of the geofence collection.
        public let collectionName: String

        @inlinable
        public init(collectionName: String) {
            self.collectionName = collectionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collectionName, key: "CollectionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGeofenceCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all Amazon Web Services.    Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
        public let collectionArn: String
        /// The name of the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The optional description for the geofence collection.
        public let description: String
        /// The number of geofences in the geofence collection.
        public let geofenceCount: Int?
        /// A key identifier for an Amazon Web Services KMS customer managed key assigned to the Amazon Location resource
        public let kmsKeyId: String?
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// No longer used. Always returns an empty string.
        public let pricingPlanDataSource: String?
        /// Displays the key, value pairs of tags associated with this resource.
        public let tags: [String: String]?
        /// The timestamp for when the geofence collection was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(collectionArn: String, collectionName: String, createTime: Date, description: String, geofenceCount: Int? = nil, kmsKeyId: String? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.geofenceCount = geofenceCount
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = tags
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        @inlinable
        public init(collectionArn: String, collectionName: String, createTime: Date, description: String, geofenceCount: Int? = nil, kmsKeyId: String? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.geofenceCount = geofenceCount
            self.kmsKeyId = kmsKeyId
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
            case description = "Description"
            case geofenceCount = "GeofenceCount"
            case kmsKeyId = "KmsKeyId"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeKeyRequest: AWSEncodableShape {
        /// The name of the API key resource.
        public let keyName: String

        @inlinable
        public init(keyName: String) {
            self.keyName = keyName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.keyName, key: "KeyName")
        }

        public func validate(name: String) throws {
            try self.validate(self.keyName, name: "keyName", parent: name, max: 100)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeKeyResponse: AWSDecodableShape {
        /// The timestamp for when the API key resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The optional description for the API key resource.
        public let description: String?
        /// The timestamp for when the API key resource will expire in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var expireTime: Date
        /// The key value/string of an API key.
        public let key: String
        /// The Amazon Resource Name (ARN) for the API key resource. Used when you need to specify a resource across all Amazon Web Services.   Format example: arn:aws:geo:region:account-id:key/ExampleKey
        public let keyArn: String
        /// The name of the API key resource.
        public let keyName: String
        public let restrictions: ApiKeyRestrictions
        /// Tags associated with the API key resource.
        public let tags: [String: String]?
        /// The timestamp for when the API key resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(createTime: Date, description: String? = nil, expireTime: Date, key: String, keyArn: String, keyName: String, restrictions: ApiKeyRestrictions, tags: [String: String]? = nil, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.expireTime = expireTime
            self.key = key
            self.keyArn = keyArn
            self.keyName = keyName
            self.restrictions = restrictions
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case description = "Description"
            case expireTime = "ExpireTime"
            case key = "Key"
            case keyArn = "KeyArn"
            case keyName = "KeyName"
            case restrictions = "Restrictions"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeMapRequest: AWSEncodableShape {
        /// The name of the map resource.
        public let mapName: String

        @inlinable
        public init(mapName: String) {
            self.mapName = mapName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.mapName, key: "MapName")
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeMapResponse: AWSDecodableShape {
        /// Specifies the map tile style selected from a partner data provider.
        public let configuration: MapConfiguration
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// Specifies the data provider for the associated map tiles.
        public let dataSource: String
        /// The optional description for the map resource.
        public let description: String
        /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across all Amazon Web Services.   Format example: arn:aws:geo:region:account-id:map/ExampleMap
        public let mapArn: String
        /// The map style selected from an available provider.
        public let mapName: String
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Tags associated with the map resource.
        public let tags: [String: String]?
        /// The timestamp for when the map resource was last update in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(configuration: MapConfiguration, createTime: Date, dataSource: String, description: String, mapArn: String, mapName: String, tags: [String: String]? = nil, updateTime: Date) {
            self.configuration = configuration
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapArn = mapArn
            self.mapName = mapName
            self.pricingPlan = nil
            self.tags = tags
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(configuration: MapConfiguration, createTime: Date, dataSource: String, description: String, mapArn: String, mapName: String, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.configuration = configuration
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapArn = mapArn
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case mapArn = "MapArn"
            case mapName = "MapName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribePlaceIndexRequest: AWSEncodableShape {
        /// The name of the place index resource.
        public let indexName: String

        @inlinable
        public init(indexName: String) {
            self.indexName = indexName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.indexName, key: "IndexName")
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePlaceIndexResponse: AWSDecodableShape {
        /// The timestamp for when the place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of geospatial data. Values can be one of the following:    Esri     Grab     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The specified data storage option for requesting Places.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// The optional description for the place index resource.
        public let description: String
        /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource across Amazon Web Services.    Format example: arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
        public let indexArn: String
        /// The name of the place index resource being described.
        public let indexName: String
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Tags associated with place index resource.
        public let tags: [String: String]?
        /// The timestamp for when the place index resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(createTime: Date, dataSource: String, dataSourceConfiguration: DataSourceConfiguration, description: String, indexArn: String, indexName: String, tags: [String: String]? = nil, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexArn = indexArn
            self.indexName = indexName
            self.pricingPlan = nil
            self.tags = tags
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(createTime: Date, dataSource: String, dataSourceConfiguration: DataSourceConfiguration, description: String, indexArn: String, indexName: String, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexArn = indexArn
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case dataSourceConfiguration = "DataSourceConfiguration"
            case description = "Description"
            case indexArn = "IndexArn"
            case indexName = "IndexName"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeRouteCalculatorRequest: AWSEncodableShape {
        /// The name of the route calculator resource.
        public let calculatorName: String

        @inlinable
        public init(calculatorName: String) {
            self.calculatorName = calculatorName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.calculatorName, key: "CalculatorName")
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRouteCalculatorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the Route calculator resource. Use the ARN when you specify a resource across Amazon Web Services.   Format example: arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
        public let calculatorArn: String
        /// The name of the route calculator resource being described.
        public let calculatorName: String
        /// The timestamp when the route calculator resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of traffic and road network data. Indicates one of the available providers:    Esri     Grab     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The optional description of the route calculator resource.
        public let description: String
        /// Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// Tags associated with route calculator resource.
        public let tags: [String: String]?
        /// The timestamp when the route calculator resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(calculatorArn: String, calculatorName: String, createTime: Date, dataSource: String, description: String, tags: [String: String]? = nil, updateTime: Date) {
            self.calculatorArn = calculatorArn
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = nil
            self.tags = tags
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(calculatorArn: String, calculatorName: String, createTime: Date, dataSource: String, description: String, pricingPlan: PricingPlan? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.calculatorArn = calculatorArn
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorArn = "CalculatorArn"
            case calculatorName = "CalculatorName"
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case tags = "Tags"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeTrackerRequest: AWSEncodableShape {
        /// The name of the tracker resource.
        public let trackerName: String

        @inlinable
        public init(trackerName: String) {
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTrackerResponse: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The optional description for the tracker resource.
        public let description: String
        /// Whether UPDATE events from this tracker in EventBridge are enabled. If set to true these events will be sent to EventBridge.
        public let eventBridgeEnabled: Bool?
        /// Enables GeospatialQueries for a tracker that uses a Amazon Web Services KMS customer managed key. This parameter is only used if you are using a KMS customer managed key.  If you wish to encrypt your data using your own KMS customer managed key, then the Bounding Polygon Queries feature will be disabled by default.  This is because by using this feature, a representation of your device positions will not be encrypted using the your KMS managed key. The exact device position, however; is still encrypted using your managed key. You can choose to opt-in to the Bounding Polygon Quseries feature. This is done by setting the KmsKeyEnableGeospatialQueries parameter to  true when creating or updating a Tracker.
        public let kmsKeyEnableGeospatialQueries: Bool?
        /// A key identifier for an Amazon Web Services KMS customer managed key assigned to the Amazon Location resource.
        public let kmsKeyId: String?
        /// The position filtering method of the tracker resource.
        public let positionFiltering: PositionFiltering?
        /// Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// No longer used. Always returns an empty string.
        public let pricingPlanDataSource: String?
        /// The tags associated with the tracker resource.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all Amazon Web Services.   Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
        public let trackerArn: String
        /// The name of the tracker resource.
        public let trackerName: String
        /// The timestamp for when the tracker resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(createTime: Date, description: String, eventBridgeEnabled: Bool? = nil, kmsKeyEnableGeospatialQueries: Bool? = nil, kmsKeyId: String? = nil, positionFiltering: PositionFiltering? = nil, tags: [String: String]? = nil, trackerArn: String, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.eventBridgeEnabled = eventBridgeEnabled
            self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
            self.kmsKeyId = kmsKeyId
            self.positionFiltering = positionFiltering
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = tags
            self.trackerArn = trackerArn
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        @inlinable
        public init(createTime: Date, description: String, eventBridgeEnabled: Bool? = nil, kmsKeyEnableGeospatialQueries: Bool? = nil, kmsKeyId: String? = nil, positionFiltering: PositionFiltering? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, tags: [String: String]? = nil, trackerArn: String, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.eventBridgeEnabled = eventBridgeEnabled
            self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
            self.kmsKeyId = kmsKeyId
            self.positionFiltering = positionFiltering
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.tags = tags
            self.trackerArn = trackerArn
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case description = "Description"
            case eventBridgeEnabled = "EventBridgeEnabled"
            case kmsKeyEnableGeospatialQueries = "KmsKeyEnableGeospatialQueries"
            case kmsKeyId = "KmsKeyId"
            case positionFiltering = "PositionFiltering"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case tags = "Tags"
            case trackerArn = "TrackerArn"
            case trackerName = "TrackerName"
            case updateTime = "UpdateTime"
        }
    }

    public struct DevicePosition: AWSDecodableShape {
        /// The accuracy of the device position.
        public let accuracy: PositionalAccuracy?
        /// The device whose position you retrieved.
        public let deviceId: String?
        /// The last known device position.
        public let position: [Double]
        /// The properties associated with the position.
        public let positionProperties: [String: String]?
        /// The timestamp for when the tracker resource received the device position in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var receivedTime: Date
        /// The timestamp at which the device's position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        @inlinable
        public init(accuracy: PositionalAccuracy? = nil, deviceId: String? = nil, position: [Double], positionProperties: [String: String]? = nil, receivedTime: Date, sampleTime: Date) {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case accuracy = "Accuracy"
            case deviceId = "DeviceId"
            case position = "Position"
            case positionProperties = "PositionProperties"
            case receivedTime = "ReceivedTime"
            case sampleTime = "SampleTime"
        }
    }

    public struct DevicePositionUpdate: AWSEncodableShape {
        /// The accuracy of the device position.
        public let accuracy: PositionalAccuracy?
        /// The device associated to the position update.
        public let deviceId: String
        /// The latest device position defined in WGS 84 format: [X or longitude, Y or latitude].
        public let position: [Double]
        /// Associates one of more properties with the position update. A property is a key-value pair stored with the position update and added to any geofence event the update may trigger. Format: "key" : "value"
        public let positionProperties: [String: String]?
        /// The timestamp at which the device's position was determined. Uses ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        @inlinable
        public init(accuracy: PositionalAccuracy? = nil, deviceId: String, position: [Double], positionProperties: [String: String]? = nil, sampleTime: Date) {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.sampleTime = sampleTime
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
            try self.validate(self.positionProperties, name: "positionProperties", parent: name, max: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case accuracy = "Accuracy"
            case deviceId = "DeviceId"
            case position = "Position"
            case positionProperties = "PositionProperties"
            case sampleTime = "SampleTime"
        }
    }

    public struct DeviceState: AWSEncodableShape {
        public let accuracy: PositionalAccuracy?
        /// The cellular network infrastructure that the device is connected to.
        public let cellSignals: CellSignals?
        /// The device identifier.
        public let deviceId: String
        /// The device's Ipv4 address.
        public let ipv4Address: String?
        /// The last known device position.
        public let position: [Double]
        /// The timestamp at which the device's position was determined. Uses  ISO 8601  format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date
        /// The Wi-Fi access points the device is using.
        public let wiFiAccessPoints: [WiFiAccessPoint]?

        @inlinable
        public init(accuracy: PositionalAccuracy? = nil, cellSignals: CellSignals? = nil, deviceId: String, ipv4Address: String? = nil, position: [Double], sampleTime: Date, wiFiAccessPoints: [WiFiAccessPoint]? = nil) {
            self.accuracy = accuracy
            self.cellSignals = cellSignals
            self.deviceId = deviceId
            self.ipv4Address = ipv4Address
            self.position = position
            self.sampleTime = sampleTime
            self.wiFiAccessPoints = wiFiAccessPoints
        }

        public func validate(name: String) throws {
            try self.cellSignals?.validate(name: "\(name).cellSignals")
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case accuracy = "Accuracy"
            case cellSignals = "CellSignals"
            case deviceId = "DeviceId"
            case ipv4Address = "Ipv4Address"
            case position = "Position"
            case sampleTime = "SampleTime"
            case wiFiAccessPoints = "WiFiAccessPoints"
        }
    }

    public struct DisassociateTrackerConsumerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the geofence collection to be disassociated from the tracker resource. Used when you need to specify a resource across all Amazon Web Services.    Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
        public let consumerArn: String
        /// The name of the tracker resource to be dissociated from the consumer.
        public let trackerName: String

        @inlinable
        public init(consumerArn: String, trackerName: String) {
            self.consumerArn = consumerArn
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.consumerArn, key: "ConsumerArn")
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, max: 1600)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateTrackerConsumerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ForecastGeofenceEventsDeviceState: AWSEncodableShape {
        /// The device's position.
        public let position: [Double]
        /// The device's speed.
        public let speed: Double?

        @inlinable
        public init(position: [Double], speed: Double? = nil) {
            self.position = position
            self.speed = speed
        }

        public func validate(name: String) throws {
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case position = "Position"
            case speed = "Speed"
        }
    }

    public struct ForecastGeofenceEventsRequest: AWSEncodableShape {
        /// The name of the geofence collection.
        public let collectionName: String
        /// The device's state, including current position and speed.
        public let deviceState: ForecastGeofenceEventsDeviceState
        /// The distance unit used for the NearestDistance property returned in a forecasted event. The measurement system must match for DistanceUnit and SpeedUnit; if Kilometers is specified for DistanceUnit, then SpeedUnit must be KilometersPerHour.  Default Value: Kilometers
        public let distanceUnit: DistanceUnit?
        /// An optional limit for the number of resources returned in a single call. Default value: 20
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?
        /// The speed unit for the device captured by the device state. The measurement system must match for DistanceUnit and SpeedUnit; if Kilometers is specified for DistanceUnit, then SpeedUnit must be KilometersPerHour. Default Value: KilometersPerHour.
        public let speedUnit: SpeedUnit?
        /// Specifies the time horizon in minutes for the forecasted events.
        public let timeHorizonMinutes: Double?

        @inlinable
        public init(collectionName: String, deviceState: ForecastGeofenceEventsDeviceState, distanceUnit: DistanceUnit? = nil, maxResults: Int? = nil, nextToken: String? = nil, speedUnit: SpeedUnit? = nil, timeHorizonMinutes: Double? = nil) {
            self.collectionName = collectionName
            self.deviceState = deviceState
            self.distanceUnit = distanceUnit
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.speedUnit = speedUnit
            self.timeHorizonMinutes = timeHorizonMinutes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collectionName, key: "CollectionName")
            try container.encode(self.deviceState, forKey: .deviceState)
            try container.encodeIfPresent(self.distanceUnit, forKey: .distanceUnit)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.speedUnit, forKey: .speedUnit)
            try container.encodeIfPresent(self.timeHorizonMinutes, forKey: .timeHorizonMinutes)
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.deviceState.validate(name: "\(name).deviceState")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 60000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceState = "DeviceState"
            case distanceUnit = "DistanceUnit"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case speedUnit = "SpeedUnit"
            case timeHorizonMinutes = "TimeHorizonMinutes"
        }
    }

    public struct ForecastGeofenceEventsResponse: AWSDecodableShape {
        /// The distance unit for the forecasted events.
        public let distanceUnit: DistanceUnit
        /// The list of forecasted events.
        public let forecastedEvents: [ForecastedEvent]
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.
        public let nextToken: String?
        /// The speed unit for the forecasted events.
        public let speedUnit: SpeedUnit

        @inlinable
        public init(distanceUnit: DistanceUnit, forecastedEvents: [ForecastedEvent], nextToken: String? = nil, speedUnit: SpeedUnit) {
            self.distanceUnit = distanceUnit
            self.forecastedEvents = forecastedEvents
            self.nextToken = nextToken
            self.speedUnit = speedUnit
        }

        private enum CodingKeys: String, CodingKey {
            case distanceUnit = "DistanceUnit"
            case forecastedEvents = "ForecastedEvents"
            case nextToken = "NextToken"
            case speedUnit = "SpeedUnit"
        }
    }

    public struct ForecastedEvent: AWSDecodableShape {
        /// The forecasted event identifier.
        public let eventId: String
        /// The event type, forecasting three states for which a device can be in relative to a geofence:  ENTER: If a device is outside of a geofence, but would breach the fence if the device is moving at its current speed within time horizon window.  EXIT: If a device is inside of a geofence, but would breach the fence if the device is moving at its current speed within time horizon window.  IDLE: If a device is inside of a geofence, and the device is not moving.
        public let eventType: ForecastedGeofenceEventType
        /// The forecasted time the device will breach the geofence in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @OptionalCustomCoding<ISO8601DateCoder>
        public var forecastedBreachTime: Date?
        /// The geofence identifier pertaining to the forecasted event.
        public let geofenceId: String
        /// The geofence properties.
        public let geofenceProperties: [String: String]?
        /// Indicates if the device is located within the geofence.
        public let isDeviceInGeofence: Bool
        /// The closest distance from the device's position to the geofence.
        public let nearestDistance: Double

        @inlinable
        public init(eventId: String, eventType: ForecastedGeofenceEventType, forecastedBreachTime: Date? = nil, geofenceId: String, geofenceProperties: [String: String]? = nil, isDeviceInGeofence: Bool, nearestDistance: Double) {
            self.eventId = eventId
            self.eventType = eventType
            self.forecastedBreachTime = forecastedBreachTime
            self.geofenceId = geofenceId
            self.geofenceProperties = geofenceProperties
            self.isDeviceInGeofence = isDeviceInGeofence
            self.nearestDistance = nearestDistance
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "EventId"
            case eventType = "EventType"
            case forecastedBreachTime = "ForecastedBreachTime"
            case geofenceId = "GeofenceId"
            case geofenceProperties = "GeofenceProperties"
            case isDeviceInGeofence = "IsDeviceInGeofence"
            case nearestDistance = "NearestDistance"
        }
    }

    public struct GeofenceGeometry: AWSEncodableShape & AWSDecodableShape {
        /// A circle on the earth, as defined by a center point and a radius.
        public let circle: Circle?
        /// Geobuf is a compact binary encoding for geographic data that provides lossless compression of GeoJSON polygons. The Geobuf must be Base64-encoded. A polygon in Geobuf format can have up to 100,000 vertices.
        public let geobuf: AWSBase64Data?
        /// A polygon is a list of linear rings which are each made up of a list of vertices. Each vertex is a 2-dimensional point of the form: [longitude, latitude]. This is represented as an array of doubles of length 2 (so [double, double]). An array of 4 or more vertices, where the first and last vertex are the same (to form a closed boundary), is called a linear ring. The linear ring vertices must be listed in counter-clockwise order around the ring’s interior. The linear ring is represented as an array of vertices, or an array of arrays of doubles ([[double, double], ...]). A geofence consists of a single linear ring. To allow for future expansion, the Polygon parameter takes an array of linear rings, which is represented as an array of arrays of arrays of doubles ([[[double, double], ...], ...]). A linear ring for use in geofences can consist of between 4 and 1,000 vertices.
        public let polygon: [[[Double]]]?

        @inlinable
        public init(circle: Circle? = nil, geobuf: AWSBase64Data? = nil, polygon: [[[Double]]]? = nil) {
            self.circle = circle
            self.geobuf = geobuf
            self.polygon = polygon
        }

        public func validate(name: String) throws {
            try self.circle?.validate(name: "\(name).circle")
            try self.validate(self.geobuf, name: "geobuf", parent: name, max: 600000)
            try self.polygon?.forEach {
                try validate($0, name: "polygon[]", parent: name, min: 4)
            }
            try self.validate(self.polygon, name: "polygon", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case circle = "Circle"
            case geobuf = "Geobuf"
            case polygon = "Polygon"
        }
    }

    public struct GetDevicePositionHistoryRequest: AWSEncodableShape {
        /// The device whose position history you want to retrieve.
        public let deviceId: String
        /// Specify the end time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be the time that the request is made. Requirement:   The time specified for EndTimeExclusive must be after the time for StartTimeInclusive.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTimeExclusive: Date?
        /// An optional limit for the number of device positions returned in a single call. Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?
        /// Specify the start time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be 24 hours prior to the time that the request is made. Requirement:   The time specified for StartTimeInclusive must be before EndTimeExclusive.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTimeInclusive: Date?
        /// The tracker resource receiving the request for the device position history.
        public let trackerName: String

        @inlinable
        public init(deviceId: String, endTimeExclusive: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, startTimeInclusive: Date? = nil, trackerName: String) {
            self.deviceId = deviceId
            self.endTimeExclusive = endTimeExclusive
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTimeInclusive = startTimeInclusive
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceId, key: "DeviceId")
            try container.encodeIfPresent(self.endTimeExclusive, forKey: .endTimeExclusive)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.startTimeInclusive, forKey: .startTimeInclusive)
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeExclusive = "EndTimeExclusive"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTimeInclusive = "StartTimeInclusive"
        }
    }

    public struct GetDevicePositionHistoryResponse: AWSDecodableShape {
        /// Contains the position history details for the requested device.
        public let devicePositions: [DevicePosition]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(devicePositions: [DevicePosition], nextToken: String? = nil) {
            self.devicePositions = devicePositions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositions = "DevicePositions"
            case nextToken = "NextToken"
        }
    }

    public struct GetDevicePositionRequest: AWSEncodableShape {
        /// The device whose position you want to retrieve.
        public let deviceId: String
        /// The tracker resource receiving the position update.
        public let trackerName: String

        @inlinable
        public init(deviceId: String, trackerName: String) {
            self.deviceId = deviceId
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceId, key: "DeviceId")
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDevicePositionResponse: AWSDecodableShape {
        /// The accuracy of the device position.
        public let accuracy: PositionalAccuracy?
        /// The device whose position you retrieved.
        public let deviceId: String?
        /// The last known device position.
        public let position: [Double]
        /// The properties associated with the position.
        public let positionProperties: [String: String]?
        /// The timestamp for when the tracker resource received the device position. Uses  ISO 8601  format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var receivedTime: Date
        /// The timestamp at which the device's position was determined. Uses  ISO 8601  format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        @inlinable
        public init(accuracy: PositionalAccuracy? = nil, deviceId: String? = nil, position: [Double], positionProperties: [String: String]? = nil, receivedTime: Date, sampleTime: Date) {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case accuracy = "Accuracy"
            case deviceId = "DeviceId"
            case position = "Position"
            case positionProperties = "PositionProperties"
            case receivedTime = "ReceivedTime"
            case sampleTime = "SampleTime"
        }
    }

    public struct GetGeofenceRequest: AWSEncodableShape {
        /// The geofence collection storing the target geofence.
        public let collectionName: String
        /// The geofence you're retrieving details for.
        public let geofenceId: String

        @inlinable
        public init(collectionName: String, geofenceId: String) {
            self.collectionName = collectionName
            self.geofenceId = geofenceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collectionName, key: "CollectionName")
            request.encodePath(self.geofenceId, key: "GeofenceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGeofenceResponse: AWSDecodableShape {
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier.
        public let geofenceId: String
        /// User defined properties of the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
        public let geofenceProperties: [String: String]?
        /// Contains the geofence geometry details describing a polygon or a circle.
        public let geometry: GeofenceGeometry
        /// Identifies the state of the geofence. A geofence will hold one of the following states:    ACTIVE — The geofence has been indexed by the system.     PENDING — The geofence is being processed by the system.    FAILED — The geofence failed to be indexed by the system.    DELETED — The geofence has been deleted from the system index.    DELETING — The geofence is being deleted from the system index.
        public let status: String
        /// The timestamp for when the geofence collection was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(createTime: Date, geofenceId: String, geofenceProperties: [String: String]? = nil, geometry: GeofenceGeometry, status: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geofenceProperties = geofenceProperties
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case geofenceProperties = "GeofenceProperties"
            case geometry = "Geometry"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct GetMapGlyphsRequest: AWSEncodableShape {
        /// A comma-separated list of fonts to load glyphs from in order of preference. For example, Noto Sans Regular, Arial Unicode. Valid font stacks for Esri styles:    VectorEsriDarkGrayCanvas – Ubuntu Medium Italic | Ubuntu Medium | Ubuntu Italic | Ubuntu Regular | Ubuntu Bold    VectorEsriLightGrayCanvas – Ubuntu Italic | Ubuntu Regular | Ubuntu Light | Ubuntu Bold    VectorEsriTopographic – Noto Sans Italic | Noto Sans Regular | Noto Sans Bold | Noto Serif Regular | Roboto Condensed Light Italic    VectorEsriStreets – Arial Regular | Arial Italic | Arial Bold    VectorEsriNavigation – Arial Regular | Arial Italic | Arial Bold    Valid font stacks for HERE Technologies styles:   VectorHereContrast – Fira  GO Regular | Fira GO Bold    VectorHereExplore, VectorHereExploreTruck, HybridHereExploreSatellite –  Fira GO Italic | Fira GO Map |  Fira GO Map Bold | Noto Sans CJK JP Bold |  Noto Sans CJK JP Light |  Noto Sans CJK JP Regular    Valid font stacks for GrabMaps styles:   VectorGrabStandardLight, VectorGrabStandardDark –  Noto Sans Regular | Noto Sans Medium | Noto Sans Bold    Valid font stacks for Open Data styles:   VectorOpenDataStandardLight, VectorOpenDataStandardDark, VectorOpenDataVisualizationLight, VectorOpenDataVisualizationDark –  Amazon Ember Regular,Noto Sans Regular | Amazon Ember Bold,Noto Sans Bold |  Amazon Ember Medium,Noto Sans Medium | Amazon Ember Regular Italic,Noto Sans Italic |  Amazon Ember Condensed RC Regular,Noto Sans Regular |  Amazon Ember Condensed RC Bold,Noto Sans Bold | Amazon Ember Regular,Noto Sans Regular,Noto Sans Arabic Regular | Amazon Ember Condensed RC Bold,Noto Sans Bold,Noto Sans Arabic  Condensed Bold | Amazon Ember Bold,Noto Sans Bold,Noto Sans Arabic Bold | Amazon Ember Regular Italic,Noto Sans Italic,Noto Sans Arabic  Regular | Amazon Ember Condensed RC Regular,Noto Sans Regular,Noto Sans Arabic  Condensed Regular | Amazon Ember Medium,Noto Sans Medium,Noto Sans Arabic Medium     The fonts used by the Open Data map styles are combined fonts that use Amazon Ember for most glyphs but Noto Sans  for glyphs unsupported by Amazon Ember.
        public let fontStack: String
        /// A Unicode range of characters to download glyphs for. Each response will contain 256 characters. For example, 0–255 includes all characters from range U+0000 to 00FF. Must be aligned to multiples of 256.
        public let fontUnicodeRange: String
        /// The optional API key to authorize  the request.
        public let key: String?
        /// The map resource associated with the glyph ﬁle.
        public let mapName: String

        @inlinable
        public init(fontStack: String, fontUnicodeRange: String, key: String? = nil, mapName: String) {
            self.fontStack = fontStack
            self.fontUnicodeRange = fontUnicodeRange
            self.key = key
            self.mapName = mapName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fontStack, key: "FontStack")
            request.encodePath(self.fontUnicodeRange, key: "FontUnicodeRange")
            request.encodeQuery(self.key, key: "key")
            request.encodePath(self.mapName, key: "MapName")
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapGlyphsResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The glyph, as binary blob.
        public let blob: AWSHTTPBody
        /// The HTTP Cache-Control directive for the value.
        public let cacheControl: String?
        /// The map glyph content type. For example, application/octet-stream.
        public let contentType: String?

        @inlinable
        public init(blob: AWSHTTPBody, cacheControl: String? = nil, contentType: String? = nil) {
            self.blob = blob
            self.cacheControl = cacheControl
            self.contentType = contentType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.blob = try container.decode(AWSHTTPBody.self)
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapSpritesRequest: AWSEncodableShape {
        /// The name of the sprite ﬁle. Use the following ﬁle names for the sprite sheet:    sprites.png     sprites@2x.png for high pixel density displays   For the JSON document containing image offsets. Use the following ﬁle names:    sprites.json     sprites@2x.json for high pixel density displays
        public let fileName: String
        /// The optional API key to authorize  the request.
        public let key: String?
        /// The map resource associated with the sprite ﬁle.
        public let mapName: String

        @inlinable
        public init(fileName: String, key: String? = nil, mapName: String) {
            self.fileName = fileName
            self.key = key
            self.mapName = mapName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fileName, key: "FileName")
            request.encodeQuery(self.key, key: "key")
            request.encodePath(self.mapName, key: "MapName")
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapSpritesResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Contains the body of the sprite sheet or JSON offset ﬁle.
        public let blob: AWSHTTPBody
        /// The HTTP Cache-Control directive for the value.
        public let cacheControl: String?
        /// The content type of the sprite sheet and offsets. For example, the sprite sheet content type is image/png, and the sprite offset JSON document is application/json.
        public let contentType: String?

        @inlinable
        public init(blob: AWSHTTPBody, cacheControl: String? = nil, contentType: String? = nil) {
            self.blob = blob
            self.cacheControl = cacheControl
            self.contentType = contentType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.blob = try container.decode(AWSHTTPBody.self)
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapStyleDescriptorRequest: AWSEncodableShape {
        /// The optional API key to authorize  the request.
        public let key: String?
        /// The map resource to retrieve the style descriptor from.
        public let mapName: String

        @inlinable
        public init(key: String? = nil, mapName: String) {
            self.key = key
            self.mapName = mapName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.key, key: "key")
            request.encodePath(self.mapName, key: "MapName")
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapStyleDescriptorResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Contains the body of the style descriptor.
        public let blob: AWSHTTPBody
        /// The HTTP Cache-Control directive for the value.
        public let cacheControl: String?
        /// The style descriptor's content type. For example, application/json.
        public let contentType: String?

        @inlinable
        public init(blob: AWSHTTPBody, cacheControl: String? = nil, contentType: String? = nil) {
            self.blob = blob
            self.cacheControl = cacheControl
            self.contentType = contentType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.blob = try container.decode(AWSHTTPBody.self)
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapTileRequest: AWSEncodableShape {
        /// The optional API key to authorize  the request.
        public let key: String?
        /// The map resource to retrieve the map tiles from.
        public let mapName: String
        /// The X axis value for the map tile.
        public let x: String
        /// The Y axis value for the map tile.
        public let y: String
        /// The zoom value for the map tile.
        public let z: String

        @inlinable
        public init(key: String? = nil, mapName: String, x: String, y: String, z: String) {
            self.key = key
            self.mapName = mapName
            self.x = x
            self.y = y
            self.z = z
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.key, key: "key")
            request.encodePath(self.mapName, key: "MapName")
            request.encodePath(self.x, key: "X")
            request.encodePath(self.y, key: "Y")
            request.encodePath(self.z, key: "Z")
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapTileResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Contains Mapbox Vector Tile (MVT) data.
        public let blob: AWSHTTPBody
        /// The HTTP Cache-Control directive for the value.
        public let cacheControl: String?
        /// The map tile's content type. For example, application/vnd.mapbox-vector-tile.
        public let contentType: String?

        @inlinable
        public init(blob: AWSHTTPBody, cacheControl: String? = nil, contentType: String? = nil) {
            self.blob = blob
            self.cacheControl = cacheControl
            self.contentType = contentType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.blob = try container.decode(AWSHTTPBody.self)
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPlaceRequest: AWSEncodableShape {
        /// The name of the place index resource that you want to use for the search.
        public let indexName: String
        /// The optional API key to authorize  the request.
        public let key: String?
        /// The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
        public let language: String?
        /// The identifier of the place to find.
        public let placeId: String

        @inlinable
        public init(indexName: String, key: String? = nil, language: String? = nil, placeId: String) {
            self.indexName = indexName
            self.key = key
            self.language = language
            self.placeId = placeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.indexName, key: "IndexName")
            request.encodeQuery(self.key, key: "key")
            request.encodeQuery(self.language, key: "language")
            request.encodePath(self.placeId, key: "PlaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPlaceResponse: AWSDecodableShape {
        /// Details about the result, such as its address and position.
        public let place: Place

        @inlinable
        public init(place: Place) {
            self.place = place
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
        }
    }

    public struct InferredState: AWSDecodableShape {
        /// The level of certainty of the inferred position.
        public let accuracy: PositionalAccuracy?
        /// The distance between the inferred position and the device's self-reported position.
        public let deviationDistance: Double?
        /// The device position inferred by the provided position, IP address, cellular signals, and Wi-Fi- access points.
        public let position: [Double]?
        /// Indicates if a proxy was used.
        public let proxyDetected: Bool

        @inlinable
        public init(accuracy: PositionalAccuracy? = nil, deviationDistance: Double? = nil, position: [Double]? = nil, proxyDetected: Bool) {
            self.accuracy = accuracy
            self.deviationDistance = deviationDistance
            self.position = position
            self.proxyDetected = proxyDetected
        }

        private enum CodingKeys: String, CodingKey {
            case accuracy = "Accuracy"
            case deviationDistance = "DeviationDistance"
            case position = "Position"
            case proxyDetected = "ProxyDetected"
        }
    }

    public struct Leg: AWSDecodableShape {
        /// The distance between the leg's StartPosition and EndPosition along a calculated route.    The default measurement is Kilometers unless the request specifies a DistanceUnit of Miles.
        public let distance: Double
        /// The estimated travel time between the leg's StartPosition and EndPosition. The travel mode and departure time that you specify in the request determines the calculated time.
        public let durationSeconds: Double
        /// The terminating position of the leg. Follows the format [longitude,latitude].  If the EndPosition isn't located on a road, it's snapped to a nearby road.
        public let endPosition: [Double]
        /// Contains the calculated route's path as a linestring geometry.
        public let geometry: LegGeometry?
        /// The starting position of the leg. Follows the format [longitude,latitude].  If the StartPosition isn't located on a road, it's snapped to a nearby road.
        public let startPosition: [Double]
        /// Contains a list of steps, which represent subsections of a leg. Each step provides instructions for how to move to the next step in the leg such as the step's start position, end position, travel distance, travel duration, and geometry offset.
        public let steps: [Step]

        @inlinable
        public init(distance: Double, durationSeconds: Double, endPosition: [Double], geometry: LegGeometry? = nil, startPosition: [Double], steps: [Step]) {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometry = geometry
            self.startPosition = startPosition
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case durationSeconds = "DurationSeconds"
            case endPosition = "EndPosition"
            case geometry = "Geometry"
            case startPosition = "StartPosition"
            case steps = "Steps"
        }
    }

    public struct LegGeometry: AWSDecodableShape {
        /// An ordered list of positions used to plot a route on a map.  The first position is closest to the start position for the leg, and the last position is the closest to the end position for the leg.   For example, [[-123.117, 49.284],[-123.115, 49.285],[-123.115, 49.285]]
        public let lineString: [[Double]]?

        @inlinable
        public init(lineString: [[Double]]? = nil) {
            self.lineString = lineString
        }

        private enum CodingKeys: String, CodingKey {
            case lineString = "LineString"
        }
    }

    public struct ListDevicePositionsRequest: AWSEncodableShape {
        /// The geometry used to filter device positions.
        public let filterGeometry: TrackingFilterGeometry?
        /// An optional limit for the number of entries returned in a single call. Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?
        /// The tracker resource containing the requested devices.
        public let trackerName: String

        @inlinable
        public init(filterGeometry: TrackingFilterGeometry? = nil, maxResults: Int? = nil, nextToken: String? = nil, trackerName: String) {
            self.filterGeometry = filterGeometry
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filterGeometry, forKey: .filterGeometry)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.filterGeometry?.validate(name: "\(name).filterGeometry")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterGeometry = "FilterGeometry"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevicePositionsResponse: AWSDecodableShape {
        /// Contains details about each device's last known position.
        public let entries: [ListDevicePositionsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(entries: [ListDevicePositionsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevicePositionsResponseEntry: AWSDecodableShape {
        /// The accuracy of the device position.
        public let accuracy: PositionalAccuracy?
        /// The ID of the device for this position.
        public let deviceId: String
        /// The last known device position. Empty if no positions currently stored.
        public let position: [Double]
        /// The properties associated with the position.
        public let positionProperties: [String: String]?
        /// The timestamp at which the device position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        @inlinable
        public init(accuracy: PositionalAccuracy? = nil, deviceId: String, position: [Double], positionProperties: [String: String]? = nil, sampleTime: Date) {
            self.accuracy = accuracy
            self.deviceId = deviceId
            self.position = position
            self.positionProperties = positionProperties
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case accuracy = "Accuracy"
            case deviceId = "DeviceId"
            case position = "Position"
            case positionProperties = "PositionProperties"
            case sampleTime = "SampleTime"
        }
    }

    public struct ListGeofenceCollectionsRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofenceCollectionsResponse: AWSDecodableShape {
        /// Lists the geofence collections that exist in your Amazon Web Services account.
        public let entries: [ListGeofenceCollectionsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(entries: [ListGeofenceCollectionsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofenceCollectionsResponseEntry: AWSDecodableShape {
        /// The name of the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The description for the geofence collection
        public let description: String
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// No longer used. Always returns an empty string.
        public let pricingPlanDataSource: String?
        /// Specifies a timestamp for when the resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(collectionName: String, createTime: Date, description: String, updateTime: Date) {
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        @inlinable
        public init(collectionName: String, createTime: Date, description: String, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, updateTime: Date) {
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListGeofenceResponseEntry: AWSDecodableShape {
        /// The timestamp for when the geofence was stored in a geofence collection in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier.
        public let geofenceId: String
        /// User defined properties of the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
        public let geofenceProperties: [String: String]?
        /// Contains the geofence geometry details describing a polygon or a circle.
        public let geometry: GeofenceGeometry
        /// Identifies the state of the geofence. A geofence will hold one of the following states:    ACTIVE — The geofence has been indexed by the system.     PENDING — The geofence is being processed by the system.    FAILED — The geofence failed to be indexed by the system.    DELETED — The geofence has been deleted from the system index.    DELETING — The geofence is being deleted from the system index.
        public let status: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(createTime: Date, geofenceId: String, geofenceProperties: [String: String]? = nil, geometry: GeofenceGeometry, status: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geofenceProperties = geofenceProperties
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case geofenceProperties = "GeofenceProperties"
            case geometry = "Geometry"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListGeofencesRequest: AWSEncodableShape {
        /// The name of the geofence collection storing the list of geofences.
        public let collectionName: String
        /// An optional limit for the number of geofences returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        @inlinable
        public init(collectionName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collectionName = collectionName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collectionName, key: "CollectionName")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 60000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofencesResponse: AWSDecodableShape {
        /// Contains a list of geofences stored in the geofence collection.
        public let entries: [ListGeofenceResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(entries: [ListGeofenceResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListKeysRequest: AWSEncodableShape {
        /// Optionally filter the list to only Active or Expired API keys.
        public let filter: ApiKeyFilter?
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        @inlinable
        public init(filter: ApiKeyFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListKeysResponse: AWSDecodableShape {
        /// Contains API key resources in your Amazon Web Services account. Details include API key name, allowed referers and timestamp for when the API key will expire.
        public let entries: [ListKeysResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(entries: [ListKeysResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListKeysResponseEntry: AWSDecodableShape {
        /// The timestamp of when the API key was created, in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The optional description for the API key resource.
        public let description: String?
        /// The timestamp for when the API key resource will expire, in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var expireTime: Date
        /// The name of the API key resource.
        public let keyName: String
        public let restrictions: ApiKeyRestrictions
        /// The timestamp of when the API key was last updated, in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(createTime: Date, description: String? = nil, expireTime: Date, keyName: String, restrictions: ApiKeyRestrictions, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.expireTime = expireTime
            self.keyName = keyName
            self.restrictions = restrictions
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case description = "Description"
            case expireTime = "ExpireTime"
            case keyName = "KeyName"
            case restrictions = "Restrictions"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListMapsRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListMapsResponse: AWSDecodableShape {
        /// Contains a list of maps in your Amazon Web Services account
        public let entries: [ListMapsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(entries: [ListMapsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListMapsResponseEntry: AWSDecodableShape {
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// Specifies the data provider for the associated map tiles.
        public let dataSource: String
        /// The description for the map resource.
        public let description: String
        /// The name of the associated map resource.
        public let mapName: String
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// The timestamp for when the map resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(createTime: Date, dataSource: String, description: String, mapName: String, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapName = mapName
            self.pricingPlan = nil
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(createTime: Date, dataSource: String, description: String, mapName: String, pricingPlan: PricingPlan? = nil, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case mapName = "MapName"
            case pricingPlan = "PricingPlan"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListPlaceIndexesRequest: AWSEncodableShape {
        /// An optional limit for the maximum number of results returned in a single call. Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPlaceIndexesResponse: AWSDecodableShape {
        /// Lists the place index resources that exist in your Amazon Web Services account
        public let entries: [ListPlaceIndexesResponseEntry]
        /// A pagination token indicating that there are additional pages available. You can use the token in a new request to fetch the next page of results.
        public let nextToken: String?

        @inlinable
        public init(entries: [ListPlaceIndexesResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListPlaceIndexesResponseEntry: AWSDecodableShape {
        /// The timestamp for when the place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of geospatial data. Values can be one of the following:    Esri     Grab     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The optional description for the place index resource.
        public let description: String
        /// The name of the place index resource.
        public let indexName: String
        /// No longer used. Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// The timestamp for when the place index resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(createTime: Date, dataSource: String, description: String, indexName: String, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.indexName = indexName
            self.pricingPlan = nil
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(createTime: Date, dataSource: String, description: String, indexName: String, pricingPlan: PricingPlan? = nil, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case indexName = "IndexName"
            case pricingPlan = "PricingPlan"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListRouteCalculatorsRequest: AWSEncodableShape {
        /// An optional maximum number of results returned in a single call. Default Value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default Value: null
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListRouteCalculatorsResponse: AWSDecodableShape {
        /// Lists the route calculator resources that exist in your Amazon Web Services account
        public let entries: [ListRouteCalculatorsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a subsequent request to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(entries: [ListRouteCalculatorsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListRouteCalculatorsResponseEntry: AWSDecodableShape {
        /// The name of the route calculator resource.
        public let calculatorName: String
        /// The timestamp when the route calculator resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of traffic and road network data. Indicates one of the available providers:    Esri     Grab     Here    For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The optional description of the route calculator resource.
        public let description: String
        /// Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// The timestamp when the route calculator resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    For example, 2020–07-2T12:15:20.000Z+01:00
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(calculatorName: String, createTime: Date, dataSource: String, description: String, updateTime: Date) {
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = nil
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(calculatorName: String, createTime: Date, dataSource: String, description: String, pricingPlan: PricingPlan? = nil, updateTime: Date) {
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorName = "CalculatorName"
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.   Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Tags that have been applied to the specified resource. Tags are mapped from the tag key to the tag value: "TagKey" : "TagValue".   Format example: {"tag1" : "value1", "tag2" : "value2"}
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListTrackerConsumersRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?
        /// The tracker resource whose associated geofence collections you want to list.
        public let trackerName: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, trackerName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackerConsumersResponse: AWSDecodableShape {
        /// Contains the list of geofence collection ARNs associated to the tracker resource.
        public let consumerArns: [String]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(consumerArns: [String], nextToken: String? = nil) {
            self.consumerArns = consumerArns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case consumerArns = "ConsumerArns"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersResponse: AWSDecodableShape {
        /// Contains tracker resources in your Amazon Web Services account. Details include tracker name, description and timestamps for when the tracker was created and last updated.
        public let entries: [ListTrackersResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(entries: [ListTrackersResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersResponseEntry: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The description for the tracker resource.
        public let description: String
        /// Always returns RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// No longer used. Always returns an empty string.
        public let pricingPlanDataSource: String?
        /// The name of the tracker resource.
        public let trackerName: String
        /// The timestamp at which the device's position was determined. Uses  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(createTime: Date, description: String, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        @inlinable
        public init(createTime: Date, description: String, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
            case trackerName = "TrackerName"
            case updateTime = "UpdateTime"
        }
    }

    public struct LteCellDetails: AWSEncodableShape {
        /// The E-UTRAN Cell Identifier (ECI).
        public let cellId: Int
        /// The LTE local identification information (local ID).
        public let localId: LteLocalId?
        /// The Mobile Country Code (MCC).
        public let mcc: Int
        /// The Mobile Network Code (MNC)
        public let mnc: Int
        /// The network measurements.
        public let networkMeasurements: [LteNetworkMeasurements]?
        /// Indicates whether the LTE object is capable of supporting NR (new radio).
        public let nrCapable: Bool?
        /// Signal power of the reference signal received, measured in decibel-milliwatts (dBm).
        public let rsrp: Int?
        /// Signal quality of the reference Signal received, measured in decibels (dB).
        public let rsrq: Float?
        /// LTE Tracking Area Code (TAC).
        public let tac: Int?
        /// Timing Advance (TA).
        public let timingAdvance: Int?

        @inlinable
        public init(cellId: Int = 0, localId: LteLocalId? = nil, mcc: Int, mnc: Int, networkMeasurements: [LteNetworkMeasurements]? = nil, nrCapable: Bool? = nil, rsrp: Int? = nil, rsrq: Float? = nil, tac: Int? = nil, timingAdvance: Int? = nil) {
            self.cellId = cellId
            self.localId = localId
            self.mcc = mcc
            self.mnc = mnc
            self.networkMeasurements = networkMeasurements
            self.nrCapable = nrCapable
            self.rsrp = rsrp
            self.rsrq = rsrq
            self.tac = tac
            self.timingAdvance = timingAdvance
        }

        public func validate(name: String) throws {
            try self.validate(self.cellId, name: "cellId", parent: name, max: 268435455)
            try self.validate(self.cellId, name: "cellId", parent: name, min: 0)
            try self.localId?.validate(name: "\(name).localId")
            try self.networkMeasurements?.forEach {
                try $0.validate(name: "\(name).networkMeasurements[]")
            }
            try self.validate(self.rsrp, name: "rsrp", parent: name, max: -44)
            try self.validate(self.rsrp, name: "rsrp", parent: name, min: -140)
            try self.validate(self.rsrq, name: "rsrq", parent: name, max: -3.0)
            try self.validate(self.rsrq, name: "rsrq", parent: name, min: -19.5)
        }

        private enum CodingKeys: String, CodingKey {
            case cellId = "CellId"
            case localId = "LocalId"
            case mcc = "Mcc"
            case mnc = "Mnc"
            case networkMeasurements = "NetworkMeasurements"
            case nrCapable = "NrCapable"
            case rsrp = "Rsrp"
            case rsrq = "Rsrq"
            case tac = "Tac"
            case timingAdvance = "TimingAdvance"
        }
    }

    public struct LteLocalId: AWSEncodableShape {
        /// E-UTRA (Evolved Universal Terrestrial Radio Access) absolute radio frequency channel number (EARFCN).
        public let earfcn: Int
        /// Physical Cell ID (PCI).
        public let pci: Int

        @inlinable
        public init(earfcn: Int = 0, pci: Int = 0) {
            self.earfcn = earfcn
            self.pci = pci
        }

        public func validate(name: String) throws {
            try self.validate(self.earfcn, name: "earfcn", parent: name, max: 262143)
            try self.validate(self.earfcn, name: "earfcn", parent: name, min: 0)
            try self.validate(self.pci, name: "pci", parent: name, max: 503)
            try self.validate(self.pci, name: "pci", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case earfcn = "Earfcn"
            case pci = "Pci"
        }
    }

    public struct LteNetworkMeasurements: AWSEncodableShape {
        /// E-UTRAN Cell Identifier (ECI).
        public let cellId: Int
        /// E-UTRA (Evolved Universal Terrestrial Radio Access) absolute radio frequency channel number (EARFCN).
        public let earfcn: Int
        /// Physical Cell ID (PCI).
        public let pci: Int
        /// Signal power of the reference signal received, measured in dBm (decibel-milliwatts).
        public let rsrp: Int?
        /// Signal quality of the reference Signal received, measured in decibels (dB).
        public let rsrq: Float?

        @inlinable
        public init(cellId: Int = 0, earfcn: Int = 0, pci: Int = 0, rsrp: Int? = nil, rsrq: Float? = nil) {
            self.cellId = cellId
            self.earfcn = earfcn
            self.pci = pci
            self.rsrp = rsrp
            self.rsrq = rsrq
        }

        public func validate(name: String) throws {
            try self.validate(self.cellId, name: "cellId", parent: name, max: 268435455)
            try self.validate(self.cellId, name: "cellId", parent: name, min: 0)
            try self.validate(self.earfcn, name: "earfcn", parent: name, max: 262143)
            try self.validate(self.earfcn, name: "earfcn", parent: name, min: 0)
            try self.validate(self.pci, name: "pci", parent: name, max: 503)
            try self.validate(self.pci, name: "pci", parent: name, min: 0)
            try self.validate(self.rsrp, name: "rsrp", parent: name, max: -44)
            try self.validate(self.rsrp, name: "rsrp", parent: name, min: -140)
            try self.validate(self.rsrq, name: "rsrq", parent: name, max: -3.0)
            try self.validate(self.rsrq, name: "rsrq", parent: name, min: -19.5)
        }

        private enum CodingKeys: String, CodingKey {
            case cellId = "CellId"
            case earfcn = "Earfcn"
            case pci = "Pci"
            case rsrp = "Rsrp"
            case rsrq = "Rsrq"
        }
    }

    public struct MapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the custom layers for the style. Leave unset to not enable any custom layer, or, for styles that support custom layers, you can enable layer(s), such as POI layer for the VectorEsriNavigation style.
        /// Default is unset.  Not all map resources or styles support custom layers. See Custom Layers for more information.
        public let customLayers: [String]?
        /// Specifies the political view for the style. Leave unset to not use a political  view, or, for styles that support specific political views, you can choose a view,  such as IND for the Indian view. Default is unset.  Not all map resources or styles support political view styles. See  Political  views  for more information.
        public let politicalView: String?
        /// Specifies the map style selected from an available data provider. Valid Esri map styles:    VectorEsriDarkGrayCanvas – The Esri Dark Gray Canvas map style. A vector basemap with a dark gray, neutral background with minimal colors, labels, and features that's designed to draw attention to your thematic content.     RasterEsriImagery – The Esri Imagery map style. A raster basemap that provides one meter or better satellite and aerial imagery in many parts of the world and lower resolution satellite imagery worldwide.     VectorEsriLightGrayCanvas – The Esri Light Gray Canvas map style, which provides a detailed vector basemap with a light gray, neutral background style with minimal colors, labels, and features that's designed to draw attention to your thematic content.     VectorEsriTopographic – The Esri Light map style, which provides a detailed vector basemap with a classic Esri map style.    VectorEsriStreets – The Esri Street Map style, which provides a detailed vector basemap for the world symbolized with a classic Esri street map style. The vector tile layer is similar in content and style to the World Street Map raster map.    VectorEsriNavigation – The Esri Navigation map style, which provides a detailed basemap for the world symbolized with a custom navigation map style that's designed for use during the day in mobile devices.   Valid HERE Technologies map styles:    VectorHereContrast – The HERE Contrast (Berlin) map style is a  high contrast detailed base map of the world that blends 3D and 2D rendering.  The VectorHereContrast style has been renamed from  VectorHereBerlin.  VectorHereBerlin has been deprecated, but will continue to work in  applications that use it.     VectorHereExplore – A default HERE map style containing a  neutral, global map and its features including roads, buildings, landmarks,  and water features. It also now includes a fully designed map of Japan.    VectorHereExploreTruck – A global map containing truck  restrictions and attributes (e.g. width / height / HAZMAT) symbolized with  highlighted segments and icons on top of HERE Explore to support use cases  within transport and logistics.    RasterHereExploreSatellite – A global map containing high resolution satellite imagery.    HybridHereExploreSatellite – A global map displaying the road  network, street names, and city labels over satellite imagery. This style  will automatically retrieve both raster and vector tiles, and your charges  will be based on total tiles retrieved.  Hybrid styles use both vector and raster tiles when rendering the  map that you see. This means that more tiles are retrieved than when using  either vector or raster tiles alone. Your charges will include all tiles  retrieved.    Valid GrabMaps map styles:    VectorGrabStandardLight – The Grab Standard Light  map style provides a basemap with detailed land use coloring,  area names, roads, landmarks, and points of interest covering  Southeast Asia.    VectorGrabStandardDark – The Grab Standard Dark  map style provides a dark variation of the standard basemap  covering Southeast Asia.    Grab provides maps only for countries in Southeast Asia, and is only available  in the Asia Pacific (Singapore) Region (ap-southeast-1). For more information, see GrabMaps countries and area covered.  Valid Open Data map styles:    VectorOpenDataStandardLight – The Open Data Standard Light  map style provides a detailed basemap for the world suitable for website and mobile application use. The map includes highways major roads,  minor roads, railways, water features, cities, parks, landmarks, building footprints, and administrative boundaries.    VectorOpenDataStandardDark – Open Data Standard Dark is a dark-themed map style that provides a detailed basemap for the world  suitable for website and mobile application use. The map includes highways  major roads, minor roads, railways, water features, cities, parks,  landmarks, building footprints, and administrative boundaries.    VectorOpenDataVisualizationLight – The Open Data  Visualization Light map style is a light-themed style with muted colors and fewer features that aids in understanding overlaid data.    VectorOpenDataVisualizationDark – The Open Data  Visualization Dark map style is a dark-themed style with muted colors and fewer features that aids in understanding overlaid data.
        public let style: String

        @inlinable
        public init(customLayers: [String]? = nil, politicalView: String? = nil, style: String) {
            self.customLayers = customLayers
            self.politicalView = politicalView
            self.style = style
        }

        public func validate(name: String) throws {
            try self.customLayers?.forEach {
                try validate($0, name: "customLayers[]", parent: name, max: 100)
                try validate($0, name: "customLayers[]", parent: name, min: 1)
                try validate($0, name: "customLayers[]", parent: name, pattern: "^[-._\\w]+$")
            }
            try self.validate(self.customLayers, name: "customLayers", parent: name, max: 10)
            try self.validate(self.politicalView, name: "politicalView", parent: name, max: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, min: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, pattern: "^[A-Z]{3}$")
            try self.validate(self.style, name: "style", parent: name, max: 100)
            try self.validate(self.style, name: "style", parent: name, min: 1)
            try self.validate(self.style, name: "style", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customLayers = "CustomLayers"
            case politicalView = "PoliticalView"
            case style = "Style"
        }
    }

    public struct MapConfigurationUpdate: AWSEncodableShape {
        /// Specifies the custom layers for the style. Leave unset to not enable any custom layer, or, for styles that support custom layers, you can enable layer(s), such as POI layer for the VectorEsriNavigation style.
        /// Default is unset.  Not all map resources or styles support custom layers. See Custom Layers for more information.
        public let customLayers: [String]?
        /// Specifies the political view for the style. Set to an empty string to not use a political view, or, for styles that support specific political views, you can choose a  view, such as IND for the Indian view.  Not all map resources or styles support political view styles. See  Political  views  for more information.
        public let politicalView: String?

        @inlinable
        public init(customLayers: [String]? = nil, politicalView: String? = nil) {
            self.customLayers = customLayers
            self.politicalView = politicalView
        }

        public func validate(name: String) throws {
            try self.customLayers?.forEach {
                try validate($0, name: "customLayers[]", parent: name, max: 100)
                try validate($0, name: "customLayers[]", parent: name, min: 1)
                try validate($0, name: "customLayers[]", parent: name, pattern: "^[-._\\w]+$")
            }
            try self.validate(self.customLayers, name: "customLayers", parent: name, max: 10)
            try self.validate(self.politicalView, name: "politicalView", parent: name, max: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, pattern: "^[A-Z]{3}$|^$")
        }

        private enum CodingKeys: String, CodingKey {
            case customLayers = "CustomLayers"
            case politicalView = "PoliticalView"
        }
    }

    public struct Place: AWSDecodableShape {
        /// The numerical portion of an address, such as a building number.
        public let addressNumber: String?
        /// The Amazon Location categories that describe this Place. For more information about using categories, including a list of Amazon Location categories, see Categories and filtering, in the Amazon Location Service Developer  Guide.
        public let categories: [String]?
        /// A country/region specified using ISO 3166 3-digit country/region code. For example, CAN.
        public let country: String?
        public let geometry: PlaceGeometry
        ///  True if the result is interpolated from other known places.  False if the Place is a known place. Not returned when the partner does not provide the information. For example, returns False for an address location that is found in the partner data, but returns True if an address does not exist in the partner data and its location is calculated by interpolating between other known addresses.
        public let interpolated: Bool?
        /// The full name and address of the point of interest such as a city, region, or country. For example, 123 Any Street, Any Town, USA.
        public let label: String?
        /// A name for a local area, such as a city or town name. For example, Toronto.
        public let municipality: String?
        /// The name of a community district. For example, Downtown.
        public let neighborhood: String?
        /// A group of numbers and letters in a country-specific format, which accompanies the address for the purpose of identifying a location.
        public let postalCode: String?
        /// A name for an area or geographical division, such as a province or state name. For example, British Columbia.
        public let region: String?
        /// The name for a street or a road to identify a location. For example, Main Street.
        public let street: String?
        /// An area that's part of a larger municipality. For example, Blissville   is a submunicipality in the Queen County in New York.  This property supported by Esri and OpenData. The Esri property is district, and the OpenData property is borough.
        public let subMunicipality: String?
        /// A county, or an area that's part of a larger region. For example, Metro Vancouver.
        public let subRegion: String?
        /// Categories from the data provider that describe the Place that are not mapped to any Amazon Location categories.
        public let supplementalCategories: [String]?
        /// The time zone in which the Place is located. Returned only when using HERE or Grab as the selected partner.
        public let timeZone: TimeZone?
        /// For addresses with multiple units, the unit identifier. Can include numbers and letters, for example 3B or Unit 123.  Returned only for a place index that uses Esri or Grab as a data provider. Is  not returned for SearchPlaceIndexForPosition.
        public let unitNumber: String?
        /// For addresses with a UnitNumber, the type of unit. For example, Apartment.  Returned only for a place index that uses Esri as a data provider.
        public let unitType: String?

        @inlinable
        public init(addressNumber: String? = nil, categories: [String]? = nil, country: String? = nil, geometry: PlaceGeometry, interpolated: Bool? = nil, label: String? = nil, municipality: String? = nil, neighborhood: String? = nil, postalCode: String? = nil, region: String? = nil, street: String? = nil, subMunicipality: String? = nil, subRegion: String? = nil, supplementalCategories: [String]? = nil, timeZone: TimeZone? = nil, unitNumber: String? = nil, unitType: String? = nil) {
            self.addressNumber = addressNumber
            self.categories = categories
            self.country = country
            self.geometry = geometry
            self.interpolated = interpolated
            self.label = label
            self.municipality = municipality
            self.neighborhood = neighborhood
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subMunicipality = subMunicipality
            self.subRegion = subRegion
            self.supplementalCategories = supplementalCategories
            self.timeZone = timeZone
            self.unitNumber = unitNumber
            self.unitType = unitType
        }

        private enum CodingKeys: String, CodingKey {
            case addressNumber = "AddressNumber"
            case categories = "Categories"
            case country = "Country"
            case geometry = "Geometry"
            case interpolated = "Interpolated"
            case label = "Label"
            case municipality = "Municipality"
            case neighborhood = "Neighborhood"
            case postalCode = "PostalCode"
            case region = "Region"
            case street = "Street"
            case subMunicipality = "SubMunicipality"
            case subRegion = "SubRegion"
            case supplementalCategories = "SupplementalCategories"
            case timeZone = "TimeZone"
            case unitNumber = "UnitNumber"
            case unitType = "UnitType"
        }
    }

    public struct PlaceGeometry: AWSDecodableShape {
        /// A single point geometry specifies a location for a Place using WGS 84 coordinates:    x — Specifies the x coordinate or longitude.     y — Specifies the y coordinate or latitude.
        public let point: [Double]?

        @inlinable
        public init(point: [Double]? = nil) {
            self.point = point
        }

        private enum CodingKeys: String, CodingKey {
            case point = "Point"
        }
    }

    public struct PositionalAccuracy: AWSEncodableShape & AWSDecodableShape {
        /// Estimated maximum distance, in meters, between the measured position and the true position of a device, along the Earth's surface.
        public let horizontal: Double

        @inlinable
        public init(horizontal: Double) {
            self.horizontal = horizontal
        }

        private enum CodingKeys: String, CodingKey {
            case horizontal = "Horizontal"
        }
    }

    public struct PutGeofenceRequest: AWSEncodableShape {
        /// The geofence collection to store the geofence in.
        public let collectionName: String
        /// An identifier for the geofence. For example, ExampleGeofence-1.
        public let geofenceId: String
        /// Associates one of more properties with the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
        public let geofenceProperties: [String: String]?
        /// Contains the details to specify the position of the geofence. Can be a polygon, a circle or a polygon encoded in Geobuf format. Including multiple selections will return a validation error.  The  geofence polygon format supports a maximum of 1,000 vertices. The Geofence Geobuf format supports a maximum of 100,000 vertices.
        public let geometry: GeofenceGeometry

        @inlinable
        public init(collectionName: String, geofenceId: String, geofenceProperties: [String: String]? = nil, geometry: GeofenceGeometry) {
            self.collectionName = collectionName
            self.geofenceId = geofenceId
            self.geofenceProperties = geofenceProperties
            self.geometry = geometry
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collectionName, key: "CollectionName")
            request.encodePath(self.geofenceId, key: "GeofenceId")
            try container.encodeIfPresent(self.geofenceProperties, forKey: .geofenceProperties)
            try container.encode(self.geometry, forKey: .geometry)
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.geofenceProperties, name: "geofenceProperties", parent: name, max: 3)
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case geofenceProperties = "GeofenceProperties"
            case geometry = "Geometry"
        }
    }

    public struct PutGeofenceResponse: AWSDecodableShape {
        /// The timestamp for when the geofence was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier entered in the request.
        public let geofenceId: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(createTime: Date, geofenceId: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case updateTime = "UpdateTime"
        }
    }

    public struct RouteMatrixEntry: AWSDecodableShape {
        /// The total distance of travel for the route.
        public let distance: Double?
        /// The expected duration of travel for the route.
        public let durationSeconds: Double?
        /// An error corresponding to the calculation of a route between the DeparturePosition and DestinationPosition.
        public let error: RouteMatrixEntryError?

        @inlinable
        public init(distance: Double? = nil, durationSeconds: Double? = nil, error: RouteMatrixEntryError? = nil) {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case durationSeconds = "DurationSeconds"
            case error = "Error"
        }
    }

    public struct RouteMatrixEntryError: AWSDecodableShape {
        /// The type of error which occurred for the route calculation.
        public let code: RouteMatrixErrorCode
        /// A message about the error that occurred for the route calculation.
        public let message: String?

        @inlinable
        public init(code: RouteMatrixErrorCode, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct SearchForPositionResult: AWSDecodableShape {
        /// The distance in meters of a great-circle arc between the query position and the result.  A great-circle arc is the shortest path on a sphere, in this case the Earth. This returns the shortest distance between two locations.
        public let distance: Double
        /// Details about the search result, such as its address and position.
        public let place: Place
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later.  For SearchPlaceIndexForPosition operations, the PlaceId is returned only by place indexes that use HERE or Grab as a data provider.
        public let placeId: String?

        @inlinable
        public init(distance: Double, place: Place, placeId: String? = nil) {
            self.distance = distance
            self.place = place
            self.placeId = placeId
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case place = "Place"
            case placeId = "PlaceId"
        }
    }

    public struct SearchForSuggestionsResult: AWSDecodableShape {
        /// The Amazon Location categories that describe the Place. For more information about using categories, including a list of Amazon Location categories, see Categories and filtering, in the Amazon Location Service Developer  Guide.
        public let categories: [String]?
        /// The unique identifier of the Place. You can use this with the GetPlace operation to find the place again later, or to get full information for the Place. The GetPlace request must use the same PlaceIndex  resource as the SearchPlaceIndexForSuggestions that generated the Place  ID.  For SearchPlaceIndexForSuggestions operations, the PlaceId is returned by place indexes that use Esri, Grab, or HERE as data providers.
        public let placeId: String?
        /// Categories from the data provider that describe the Place that are not mapped to any Amazon Location categories.
        public let supplementalCategories: [String]?
        /// The text of the place suggestion, typically formatted as an address string.
        public let text: String

        @inlinable
        public init(categories: [String]? = nil, placeId: String? = nil, supplementalCategories: [String]? = nil, text: String) {
            self.categories = categories
            self.placeId = placeId
            self.supplementalCategories = supplementalCategories
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case categories = "Categories"
            case placeId = "PlaceId"
            case supplementalCategories = "SupplementalCategories"
            case text = "Text"
        }
    }

    public struct SearchForTextResult: AWSDecodableShape {
        /// The distance in meters of a great-circle arc between the bias position specified and the result. Distance will be returned only if a bias position was specified in the query.  A great-circle arc is the shortest path on a sphere, in this case the Earth. This returns the shortest distance between two locations.
        public let distance: Double?
        /// Details about the search result, such as its address and position.
        public let place: Place
        /// The unique identifier of the place. You can use this with the GetPlace operation to find the place again later.  For SearchPlaceIndexForText operations, the PlaceId is returned only by place indexes that use HERE or Grab as a data provider.
        public let placeId: String?
        /// The relative confidence in the match for a result among the results returned. For example, if more fields for an address match (including house number, street, city, country/region, and postal code), the relevance score is closer to 1. Returned only when the partner selected is Esri or Grab.
        public let relevance: Double?

        @inlinable
        public init(distance: Double? = nil, place: Place, placeId: String? = nil, relevance: Double? = nil) {
            self.distance = distance
            self.place = place
            self.placeId = placeId
            self.relevance = relevance
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case place = "Place"
            case placeId = "PlaceId"
            case relevance = "Relevance"
        }
    }

    public struct SearchPlaceIndexForPositionRequest: AWSEncodableShape {
        /// The name of the place index resource you want to use for the search.
        public let indexName: String
        /// The optional API key to authorize  the request.
        public let key: String?
        /// The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
        public let language: String?
        /// An optional parameter. The maximum number of results returned per request. Default value: 50
        public let maxResults: Int?
        /// Specifies the longitude and latitude of the position to query. This parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents a position with longitude -123.1174 and latitude 49.2847.
        public let position: [Double]

        @inlinable
        public init(indexName: String, key: String? = nil, language: String? = nil, maxResults: Int? = nil, position: [Double]) {
            self.indexName = indexName
            self.key = key
            self.language = language
            self.maxResults = maxResults
            self.position = position
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.indexName, key: "IndexName")
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encode(self.position, forKey: .position)
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case language = "Language"
            case maxResults = "MaxResults"
            case position = "Position"
        }
    }

    public struct SearchPlaceIndexForPositionResponse: AWSDecodableShape {
        /// Returns a list of Places closest to the specified position. Each result contains additional information about the Places returned.
        public let results: [SearchForPositionResult]
        /// Contains a summary of the request. Echoes the input values for Position, Language, MaxResults, and the DataSource of the place index.
        public let summary: SearchPlaceIndexForPositionSummary

        @inlinable
        public init(results: [SearchForPositionResult], summary: SearchPlaceIndexForPositionSummary) {
            self.results = results
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
            case summary = "Summary"
        }
    }

    public struct SearchPlaceIndexForPositionSummary: AWSDecodableShape {
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:   Esri   Grab   Here   For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// The preferred language used to return results. Matches the language in the request. The value is a valid BCP 47 language tag, for example, en for English.
        public let language: String?
        /// Contains the optional result count limit that is specified in the request. Default value: 50
        public let maxResults: Int?
        /// The position specified in the request.
        public let position: [Double]

        @inlinable
        public init(dataSource: String, language: String? = nil, maxResults: Int? = nil, position: [Double]) {
            self.dataSource = dataSource
            self.language = language
            self.maxResults = maxResults
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case language = "Language"
            case maxResults = "MaxResults"
            case position = "Position"
        }
    }

    public struct SearchPlaceIndexForSuggestionsRequest: AWSEncodableShape {
        /// An optional parameter that indicates a preference for place suggestions that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.   BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
        public let biasPosition: [Double]?
        /// An optional parameter that limits the search results by returning only suggestions within a specified bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542.   FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
        public let filterBBox: [Double]?
        /// A list of one or more Amazon Location categories to filter the returned places. If you  include more than one category, the results will include results that match  any of the categories listed. For more information about using categories, including a list of Amazon Location categories, see Categories and filtering, in the Amazon Location Service Developer  Guide.
        public let filterCategories: [String]?
        /// An optional parameter that limits the search results by returning only suggestions within the provided list of countries.   Use the ISO 3166 3-digit country code. For example, Australia uses three upper-case characters: AUS.
        public let filterCountries: [String]?
        /// The name of the place index resource you want to use for the search.
        public let indexName: String
        /// The optional API key to authorize  the request.
        public let key: String?
        /// The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Gr to get suggestions with the language parameter set to en. The results found will most likely be returned as Athens, Greece. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα, Ελλάδα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
        public let language: String?
        /// An optional parameter. The maximum number of results returned per request.  The default: 5
        public let maxResults: Int?
        /// The free-form partial text to use to generate place suggestions. For example, eiffel tow.
        public let text: String

        @inlinable
        public init(biasPosition: [Double]? = nil, filterBBox: [Double]? = nil, filterCategories: [String]? = nil, filterCountries: [String]? = nil, indexName: String, key: String? = nil, language: String? = nil, maxResults: Int? = nil, text: String) {
            self.biasPosition = biasPosition
            self.filterBBox = filterBBox
            self.filterCategories = filterCategories
            self.filterCountries = filterCountries
            self.indexName = indexName
            self.key = key
            self.language = language
            self.maxResults = maxResults
            self.text = text
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.biasPosition, forKey: .biasPosition)
            try container.encodeIfPresent(self.filterBBox, forKey: .filterBBox)
            try container.encodeIfPresent(self.filterCategories, forKey: .filterCategories)
            try container.encodeIfPresent(self.filterCountries, forKey: .filterCountries)
            request.encodePath(self.indexName, key: "IndexName")
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encode(self.text, forKey: .text)
        }

        public func validate(name: String) throws {
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, max: 2)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, min: 2)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, max: 4)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, min: 4)
            try self.filterCategories?.forEach {
                try validate($0, name: "filterCategories[]", parent: name, max: 35)
            }
            try self.validate(self.filterCategories, name: "filterCategories", parent: name, max: 5)
            try self.validate(self.filterCategories, name: "filterCategories", parent: name, min: 1)
            try self.filterCountries?.forEach {
                try validate($0, name: "filterCountries[]", parent: name, max: 3)
                try validate($0, name: "filterCountries[]", parent: name, min: 3)
                try validate($0, name: "filterCountries[]", parent: name, pattern: "^[A-Z]{3}$")
            }
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, max: 100)
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case filterBBox = "FilterBBox"
            case filterCategories = "FilterCategories"
            case filterCountries = "FilterCountries"
            case language = "Language"
            case maxResults = "MaxResults"
            case text = "Text"
        }
    }

    public struct SearchPlaceIndexForSuggestionsResponse: AWSDecodableShape {
        /// A list of place suggestions that best match the search text.
        public let results: [SearchForSuggestionsResult]
        /// Contains a summary of the request. Echoes the input values for BiasPosition, FilterBBox, FilterCountries, Language, MaxResults, and Text. Also includes the DataSource of the place index.
        public let summary: SearchPlaceIndexForSuggestionsSummary

        @inlinable
        public init(results: [SearchForSuggestionsResult], summary: SearchPlaceIndexForSuggestionsSummary) {
            self.results = results
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
            case summary = "Summary"
        }
    }

    public struct SearchPlaceIndexForSuggestionsSummary: AWSDecodableShape {
        /// Contains the coordinates for the optional bias position specified in the request. This parameter contains a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        public let biasPosition: [Double]?
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:   Esri   Grab   Here   For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// Contains the coordinates for the optional bounding box specified in the request.
        public let filterBBox: [Double]?
        /// The optional category filter specified in the request.
        public let filterCategories: [String]?
        /// Contains the optional country filter specified in the request.
        public let filterCountries: [String]?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid BCP 47 language tag, for example, en for English.
        public let language: String?
        /// Contains the optional result count limit specified in the request.
        public let maxResults: Int?
        /// The free-form partial text input specified in the request.
        public let text: String

        @inlinable
        public init(biasPosition: [Double]? = nil, dataSource: String, filterBBox: [Double]? = nil, filterCategories: [String]? = nil, filterCountries: [String]? = nil, language: String? = nil, maxResults: Int? = nil, text: String) {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCategories = filterCategories
            self.filterCountries = filterCountries
            self.language = language
            self.maxResults = maxResults
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case dataSource = "DataSource"
            case filterBBox = "FilterBBox"
            case filterCategories = "FilterCategories"
            case filterCountries = "FilterCountries"
            case language = "Language"
            case maxResults = "MaxResults"
            case text = "Text"
        }
    }

    public struct SearchPlaceIndexForTextRequest: AWSEncodableShape {
        /// An optional parameter that indicates a preference for places that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.   BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
        public let biasPosition: [Double]?
        /// An optional parameter that limits the search results by returning only places that are within the provided bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542.   FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
        public let filterBBox: [Double]?
        /// A list of one or more Amazon Location categories to filter the returned places. If you  include more than one category, the results will include results that match  any of the categories listed. For more information about using categories, including a list of Amazon Location categories, see Categories and filtering, in the Amazon Location Service Developer  Guide.
        public let filterCategories: [String]?
        /// An optional parameter that limits the search results by returning only places that are in a specified list of countries.   Valid values include ISO 3166 3-digit country codes. For example, Australia uses three upper-case characters: AUS.
        public let filterCountries: [String]?
        /// The name of the place index resource you want to use for the search.
        public let indexName: String
        /// The optional API key to authorize  the request.
        public let key: String?
        /// The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Greece, with the language parameter set to en. The result found will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
        public let language: String?
        /// An optional parameter. The maximum number of results returned per request.  The default: 50
        public let maxResults: Int?
        /// The address, name, city, or region to be used in the search in free-form text format. For example, 123 Any Street.
        public let text: String

        @inlinable
        public init(biasPosition: [Double]? = nil, filterBBox: [Double]? = nil, filterCategories: [String]? = nil, filterCountries: [String]? = nil, indexName: String, key: String? = nil, language: String? = nil, maxResults: Int? = nil, text: String) {
            self.biasPosition = biasPosition
            self.filterBBox = filterBBox
            self.filterCategories = filterCategories
            self.filterCountries = filterCountries
            self.indexName = indexName
            self.key = key
            self.language = language
            self.maxResults = maxResults
            self.text = text
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.biasPosition, forKey: .biasPosition)
            try container.encodeIfPresent(self.filterBBox, forKey: .filterBBox)
            try container.encodeIfPresent(self.filterCategories, forKey: .filterCategories)
            try container.encodeIfPresent(self.filterCountries, forKey: .filterCountries)
            request.encodePath(self.indexName, key: "IndexName")
            request.encodeQuery(self.key, key: "key")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encode(self.text, forKey: .text)
        }

        public func validate(name: String) throws {
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, max: 2)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, min: 2)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, max: 4)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, min: 4)
            try self.filterCategories?.forEach {
                try validate($0, name: "filterCategories[]", parent: name, max: 35)
            }
            try self.validate(self.filterCategories, name: "filterCategories", parent: name, max: 5)
            try self.validate(self.filterCategories, name: "filterCategories", parent: name, min: 1)
            try self.filterCountries?.forEach {
                try validate($0, name: "filterCountries[]", parent: name, max: 3)
                try validate($0, name: "filterCountries[]", parent: name, min: 3)
                try validate($0, name: "filterCountries[]", parent: name, pattern: "^[A-Z]{3}$")
            }
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, max: 100)
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case filterBBox = "FilterBBox"
            case filterCategories = "FilterCategories"
            case filterCountries = "FilterCountries"
            case language = "Language"
            case maxResults = "MaxResults"
            case text = "Text"
        }
    }

    public struct SearchPlaceIndexForTextResponse: AWSDecodableShape {
        /// A list of Places matching the input text. Each result contains additional information about the specific point of interest.  Not all response properties are included with all responses. Some properties may only be returned by specific data partners.
        public let results: [SearchForTextResult]
        /// Contains a summary of the request. Echoes the input values for BiasPosition, FilterBBox, FilterCountries, Language, MaxResults, and Text. Also includes the DataSource of the place index and the bounding box, ResultBBox, which surrounds the search results.
        public let summary: SearchPlaceIndexForTextSummary

        @inlinable
        public init(results: [SearchForTextResult], summary: SearchPlaceIndexForTextSummary) {
            self.results = results
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
            case summary = "Summary"
        }
    }

    public struct SearchPlaceIndexForTextSummary: AWSDecodableShape {
        /// Contains the coordinates for the optional bias position specified in the request. This parameter contains a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        public let biasPosition: [Double]?
        /// The geospatial data provider attached to the place index resource specified in the request. Values can be one of the following:   Esri   Grab   Here   For more information about data providers, see Amazon Location Service data providers.
        public let dataSource: String
        /// Contains the coordinates for the optional bounding box specified in the request.
        public let filterBBox: [Double]?
        /// The optional category filter specified in the request.
        public let filterCategories: [String]?
        /// Contains the optional country filter specified in the request.
        public let filterCountries: [String]?
        /// The preferred language used to return results. Matches the language in the request. The value is a valid BCP 47 language tag, for example, en for English.
        public let language: String?
        /// Contains the optional result count limit specified in the request.
        public let maxResults: Int?
        /// The bounding box that fully contains all search results.  If you specified the optional FilterBBox parameter in the request, ResultBBox is contained within FilterBBox.
        public let resultBBox: [Double]?
        /// The search text specified in the request.
        public let text: String

        @inlinable
        public init(biasPosition: [Double]? = nil, dataSource: String, filterBBox: [Double]? = nil, filterCategories: [String]? = nil, filterCountries: [String]? = nil, language: String? = nil, maxResults: Int? = nil, resultBBox: [Double]? = nil, text: String) {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCategories = filterCategories
            self.filterCountries = filterCountries
            self.language = language
            self.maxResults = maxResults
            self.resultBBox = resultBBox
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case dataSource = "DataSource"
            case filterBBox = "FilterBBox"
            case filterCategories = "FilterCategories"
            case filterCountries = "FilterCountries"
            case language = "Language"
            case maxResults = "MaxResults"
            case resultBBox = "ResultBBox"
            case text = "Text"
        }
    }

    public struct Step: AWSDecodableShape {
        /// The travel distance between the step's StartPosition and EndPosition.
        public let distance: Double
        /// The estimated travel time, in seconds, from the step's StartPosition to the EndPosition. . The travel mode and departure time that you specify in the request determines the calculated time.
        public let durationSeconds: Double
        /// The end position of a step. If the position the last step in the leg, this position is the same as the end position of the leg.
        public let endPosition: [Double]
        /// Represents the start position, or index, in a sequence of steps within the leg's line string geometry. For example, the index of the first step in a leg geometry is 0.  Included in the response for queries that set IncludeLegGeometry to True.
        public let geometryOffset: Int?
        /// The starting position of a step. If the position is the first step in the leg, this position is the same as the start position of the leg.
        public let startPosition: [Double]

        @inlinable
        public init(distance: Double, durationSeconds: Double, endPosition: [Double], geometryOffset: Int? = nil, startPosition: [Double]) {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometryOffset = geometryOffset
            self.startPosition = startPosition
        }

        private enum CodingKeys: String, CodingKey {
            case distance = "Distance"
            case durationSeconds = "DurationSeconds"
            case endPosition = "EndPosition"
            case geometryOffset = "GeometryOffset"
            case startPosition = "StartPosition"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource whose tags you want to update.   Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
        public let resourceArn: String
        /// Applies one or more tags to specific resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource.   Each tag key must be unique and must have exactly one associated value.   Maximum key length: 128 Unicode characters in UTF-8.   Maximum value length: 256 Unicode characters in UTF-8.   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @   Cannot use "aws:" as a prefix for a key.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.,:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimeZone: AWSDecodableShape {
        /// The name of the time zone, following the  IANA time zone standard. For example, America/Los_Angeles.
        public let name: String
        /// The time zone's offset, in seconds, from UTC.
        public let offset: Int?

        @inlinable
        public init(name: String, offset: Int? = nil) {
            self.name = name
            self.offset = offset
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case offset = "Offset"
        }
    }

    public struct TrackingFilterGeometry: AWSEncodableShape {
        /// The set of arrays which define the polygon. A polygon can have between 4 and 1000 vertices.
        public let polygon: [[[Double]]]?

        @inlinable
        public init(polygon: [[[Double]]]? = nil) {
            self.polygon = polygon
        }

        public func validate(name: String) throws {
            try self.polygon?.forEach {
                try validate($0, name: "polygon[]", parent: name, min: 4)
            }
            try self.validate(self.polygon, name: "polygon", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case polygon = "Polygon"
        }
    }

    public struct TruckDimensions: AWSEncodableShape {
        /// The height of the truck.   For example, 4.5.     For routes calculated with a HERE resource, this value must be between 0 and 50 meters.
        public let height: Double?
        /// The length of the truck.   For example, 15.5.     For routes calculated with a HERE resource, this value must be between 0 and 300 meters.
        public let length: Double?
        ///  Specifies the unit of measurement for the truck dimensions. Default Value: Meters
        public let unit: DimensionUnit?
        /// The width of the truck.   For example, 4.5.     For routes calculated with a HERE resource, this value must be between 0 and 50 meters.
        public let width: Double?

        @inlinable
        public init(height: Double? = nil, length: Double? = nil, unit: DimensionUnit? = nil, width: Double? = nil) {
            self.height = height
            self.length = length
            self.unit = unit
            self.width = width
        }

        private enum CodingKeys: String, CodingKey {
            case height = "Height"
            case length = "Length"
            case unit = "Unit"
            case width = "Width"
        }
    }

    public struct TruckWeight: AWSEncodableShape {
        /// The total weight of the truck.    For example, 3500.
        public let total: Double?
        /// The unit of measurement to use for the truck weight. Default Value: Kilograms
        public let unit: VehicleWeightUnit?

        @inlinable
        public init(total: Double? = nil, unit: VehicleWeightUnit? = nil) {
            self.total = total
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case total = "Total"
            case unit = "Unit"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource from which you want to remove tags.   Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
        public let resourceArn: String
        /// The list of tag keys to remove from the specified resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGeofenceCollectionRequest: AWSEncodableShape {
        /// The name of the geofence collection to update.
        public let collectionName: String
        /// Updates the description for the geofence collection.
        public let description: String?
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// This parameter is no longer used.
        public let pricingPlanDataSource: String?

        @inlinable
        public init(collectionName: String, description: String? = nil) {
            self.collectionName = collectionName
            self.description = description
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        @inlinable
        public init(collectionName: String, description: String? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil) {
            self.collectionName = collectionName
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collectionName, key: "CollectionName")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.pricingPlan, forKey: .pricingPlan)
            try container.encodeIfPresent(self.pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
        }
    }

    public struct UpdateGeofenceCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated geofence collection. Used to specify a resource across Amazon Web Services.   Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
        public let collectionArn: String
        /// The name of the updated geofence collection.
        public let collectionName: String
        /// The time when the geofence collection was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(collectionArn: String, collectionName: String, updateTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case collectionName = "CollectionName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdateKeyRequest: AWSEncodableShape {
        /// Updates the description for the API key resource.
        public let description: String?
        /// Updates the timestamp for when the API key resource will expire in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expireTime: Date?
        /// The boolean flag to be included for updating ExpireTime or Restrictions details. Must be set to true to update an API key resource that has been used in the past 7 days.  False if force update is not preferred Default value: False
        public let forceUpdate: Bool?
        /// The name of the API key resource to update.
        public let keyName: String
        /// Whether the API key should expire. Set to true to set the API key to have no expiration time.
        public let noExpiry: Bool?
        /// Updates the API key restrictions for the API key resource.
        public let restrictions: ApiKeyRestrictions?

        @inlinable
        public init(description: String? = nil, expireTime: Date? = nil, forceUpdate: Bool? = nil, keyName: String, noExpiry: Bool? = nil, restrictions: ApiKeyRestrictions? = nil) {
            self.description = description
            self.expireTime = expireTime
            self.forceUpdate = forceUpdate
            self.keyName = keyName
            self.noExpiry = noExpiry
            self.restrictions = restrictions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.expireTime, forKey: .expireTime)
            try container.encodeIfPresent(self.forceUpdate, forKey: .forceUpdate)
            request.encodePath(self.keyName, key: "KeyName")
            try container.encodeIfPresent(self.noExpiry, forKey: .noExpiry)
            try container.encodeIfPresent(self.restrictions, forKey: .restrictions)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.keyName, name: "keyName", parent: name, max: 100)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[-._\\w]+$")
            try self.restrictions?.validate(name: "\(name).restrictions")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case expireTime = "ExpireTime"
            case forceUpdate = "ForceUpdate"
            case noExpiry = "NoExpiry"
            case restrictions = "Restrictions"
        }
    }

    public struct UpdateKeyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the API key resource. Used when you need to specify a resource across all Amazon Web Services.   Format example: arn:aws:geo:region:account-id:key/ExampleKey
        public let keyArn: String
        /// The name of the API key resource.
        public let keyName: String
        /// The timestamp for when the API key resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(keyArn: String, keyName: String, updateTime: Date) {
            self.keyArn = keyArn
            self.keyName = keyName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn = "KeyArn"
            case keyName = "KeyName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdateMapRequest: AWSEncodableShape {
        /// Updates the parts of the map configuration that can be updated, including the political view.
        public let configurationUpdate: MapConfigurationUpdate?
        /// Updates the description for the map resource.
        public let description: String?
        /// The name of the map resource to update.
        public let mapName: String
        /// No longer used. If included, the only allowed value is  RequestBasedUsage.
        public let pricingPlan: PricingPlan?

        @inlinable
        public init(configurationUpdate: MapConfigurationUpdate? = nil, description: String? = nil, mapName: String) {
            self.configurationUpdate = configurationUpdate
            self.description = description
            self.mapName = mapName
            self.pricingPlan = nil
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(configurationUpdate: MapConfigurationUpdate? = nil, description: String? = nil, mapName: String, pricingPlan: PricingPlan? = nil) {
            self.configurationUpdate = configurationUpdate
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.configurationUpdate, forKey: .configurationUpdate)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.mapName, key: "MapName")
            try container.encodeIfPresent(self.pricingPlan, forKey: .pricingPlan)
        }

        public func validate(name: String) throws {
            try self.configurationUpdate?.validate(name: "\(name).configurationUpdate")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationUpdate = "ConfigurationUpdate"
            case description = "Description"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct UpdateMapResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated map resource. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:map/ExampleMap
        public let mapArn: String
        /// The name of the updated map resource.
        public let mapName: String
        /// The timestamp for when the map resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(mapArn: String, mapName: String, updateTime: Date) {
            self.mapArn = mapArn
            self.mapName = mapName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case mapArn = "MapArn"
            case mapName = "MapName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdatePlaceIndexRequest: AWSEncodableShape {
        /// Updates the data storage option for the place index resource.
        public let dataSourceConfiguration: DataSourceConfiguration?
        /// Updates the description for the place index resource.
        public let description: String?
        /// The name of the place index resource to update.
        public let indexName: String
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?

        @inlinable
        public init(dataSourceConfiguration: DataSourceConfiguration? = nil, description: String? = nil, indexName: String) {
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexName = indexName
            self.pricingPlan = nil
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(dataSourceConfiguration: DataSourceConfiguration? = nil, description: String? = nil, indexName: String, pricingPlan: PricingPlan? = nil) {
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.dataSourceConfiguration, forKey: .dataSourceConfiguration)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.indexName, key: "IndexName")
            try container.encodeIfPresent(self.pricingPlan, forKey: .pricingPlan)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceConfiguration = "DataSourceConfiguration"
            case description = "Description"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct UpdatePlaceIndexResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the upated place index resource. Used to specify a resource across Amazon Web Services.   Format example: arn:aws:geo:region:account-id:place- index/ExamplePlaceIndex
        public let indexArn: String
        /// The name of the updated place index resource.
        public let indexName: String
        /// The timestamp for when the place index resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(indexArn: String, indexName: String, updateTime: Date) {
            self.indexArn = indexArn
            self.indexName = indexName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case indexArn = "IndexArn"
            case indexName = "IndexName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdateRouteCalculatorRequest: AWSEncodableShape {
        /// The name of the route calculator resource to update.
        public let calculatorName: String
        /// Updates the description for the route calculator resource.
        public let description: String?
        /// No longer used. If included, the only allowed value is RequestBasedUsage.
        public let pricingPlan: PricingPlan?

        @inlinable
        public init(calculatorName: String, description: String? = nil) {
            self.calculatorName = calculatorName
            self.description = description
            self.pricingPlan = nil
        }

        @available(*, deprecated, message: "Members pricingPlan have been deprecated")
        @inlinable
        public init(calculatorName: String, description: String? = nil, pricingPlan: PricingPlan? = nil) {
            self.calculatorName = calculatorName
            self.description = description
            self.pricingPlan = pricingPlan
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.calculatorName, key: "CalculatorName")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.pricingPlan, forKey: .pricingPlan)
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, max: 100)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, min: 1)
            try self.validate(self.calculatorName, name: "calculatorName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct UpdateRouteCalculatorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated route calculator resource. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:route- calculator/ExampleCalculator
        public let calculatorArn: String
        /// The name of the updated route calculator resource.
        public let calculatorName: String
        /// The timestamp for when the route calculator was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(calculatorArn: String, calculatorName: String, updateTime: Date) {
            self.calculatorArn = calculatorArn
            self.calculatorName = calculatorName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case calculatorArn = "CalculatorArn"
            case calculatorName = "CalculatorName"
            case updateTime = "UpdateTime"
        }
    }

    public struct UpdateTrackerRequest: AWSEncodableShape {
        /// Updates the description for the tracker resource.
        public let description: String?
        /// Whether to enable position UPDATE events from this tracker to be sent to  EventBridge.  You do not need enable this feature to get ENTER and  EXIT events for geofences with this tracker. Those events are always sent to EventBridge.
        public let eventBridgeEnabled: Bool?
        /// Enables GeospatialQueries for a tracker that uses a Amazon Web Services KMS customer managed key. This parameter is only used if you are using a KMS customer managed key.
        public let kmsKeyEnableGeospatialQueries: Bool?
        /// Updates the position filtering for the tracker resource. Valid values:    TimeBased - Location updates are evaluated against linked geofence collections,  but not every location update is stored. If your update frequency is more often than 30 seconds,  only one update per 30 seconds is stored for each unique device ID.     DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are  ignored. Location updates within this distance are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.     AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This helps educe the effects of GPS noise  when displaying device trajectories on a map, and can help control costs by reducing the number of geofence evaluations.
        public let positionFiltering: PositionFiltering?
        /// No longer used. If included, the only allowed value is  RequestBasedUsage.
        public let pricingPlan: PricingPlan?
        /// This parameter is no longer used.
        public let pricingPlanDataSource: String?
        /// The name of the tracker resource to update.
        public let trackerName: String

        @inlinable
        public init(description: String? = nil, eventBridgeEnabled: Bool? = nil, kmsKeyEnableGeospatialQueries: Bool? = nil, positionFiltering: PositionFiltering? = nil, trackerName: String) {
            self.description = description
            self.eventBridgeEnabled = eventBridgeEnabled
            self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
            self.positionFiltering = positionFiltering
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.trackerName = trackerName
        }

        @available(*, deprecated, message: "Members pricingPlan, pricingPlanDataSource have been deprecated")
        @inlinable
        public init(description: String? = nil, eventBridgeEnabled: Bool? = nil, kmsKeyEnableGeospatialQueries: Bool? = nil, positionFiltering: PositionFiltering? = nil, pricingPlan: PricingPlan? = nil, pricingPlanDataSource: String? = nil, trackerName: String) {
            self.description = description
            self.eventBridgeEnabled = eventBridgeEnabled
            self.kmsKeyEnableGeospatialQueries = kmsKeyEnableGeospatialQueries
            self.positionFiltering = positionFiltering
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.eventBridgeEnabled, forKey: .eventBridgeEnabled)
            try container.encodeIfPresent(self.kmsKeyEnableGeospatialQueries, forKey: .kmsKeyEnableGeospatialQueries)
            try container.encodeIfPresent(self.positionFiltering, forKey: .positionFiltering)
            try container.encodeIfPresent(self.pricingPlan, forKey: .pricingPlan)
            try container.encodeIfPresent(self.pricingPlanDataSource, forKey: .pricingPlanDataSource)
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case eventBridgeEnabled = "EventBridgeEnabled"
            case kmsKeyEnableGeospatialQueries = "KmsKeyEnableGeospatialQueries"
            case positionFiltering = "PositionFiltering"
            case pricingPlan = "PricingPlan"
            case pricingPlanDataSource = "PricingPlanDataSource"
        }
    }

    public struct UpdateTrackerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated tracker resource. Used to specify a resource across AWS.   Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
        public let trackerArn: String
        /// The name of the updated tracker resource.
        public let trackerName: String
        /// The timestamp for when the tracker resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        @inlinable
        public init(trackerArn: String, trackerName: String, updateTime: Date) {
            self.trackerArn = trackerArn
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case trackerArn = "TrackerArn"
            case trackerName = "TrackerName"
            case updateTime = "UpdateTime"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The field where the invalid entry was detected.
        public let fieldList: [ValidationExceptionField]
        public let message: String
        /// A message with the reason for the validation exception error.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField], message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message with the reason for the validation exception error.
        public let message: String
        /// The field name where the invalid entry was detected.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct VerifyDevicePositionRequest: AWSEncodableShape {
        /// The device's state, including position, IP address, cell signals and Wi-Fi access points.
        public let deviceState: DeviceState
        /// The distance unit for the verification request. Default Value: Kilometers
        public let distanceUnit: DistanceUnit?
        /// The name of the tracker resource to be associated with verification request.
        public let trackerName: String

        @inlinable
        public init(deviceState: DeviceState, distanceUnit: DistanceUnit? = nil, trackerName: String) {
            self.deviceState = deviceState
            self.distanceUnit = distanceUnit
            self.trackerName = trackerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.deviceState, forKey: .deviceState)
            try container.encodeIfPresent(self.distanceUnit, forKey: .distanceUnit)
            request.encodePath(self.trackerName, key: "TrackerName")
        }

        public func validate(name: String) throws {
            try self.deviceState.validate(name: "\(name).deviceState")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceState = "DeviceState"
            case distanceUnit = "DistanceUnit"
        }
    }

    public struct VerifyDevicePositionResponse: AWSDecodableShape {
        /// The device identifier.
        public let deviceId: String
        /// The distance unit for the verification response.
        public let distanceUnit: DistanceUnit
        /// The inferred state of the device, given the provided position, IP address, cellular signals, and Wi-Fi- access points.
        public let inferredState: InferredState
        /// The timestamp for when the tracker resource received the device position in  ISO 8601  format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var receivedTime: Date
        /// The timestamp at which the device's position was determined. Uses  ISO 8601  format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        @inlinable
        public init(deviceId: String, distanceUnit: DistanceUnit, inferredState: InferredState, receivedTime: Date, sampleTime: Date) {
            self.deviceId = deviceId
            self.distanceUnit = distanceUnit
            self.inferredState = inferredState
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case distanceUnit = "DistanceUnit"
            case inferredState = "InferredState"
            case receivedTime = "ReceivedTime"
            case sampleTime = "SampleTime"
        }
    }

    public struct WiFiAccessPoint: AWSEncodableShape {
        /// Medium access control address (Mac).
        public let macAddress: String
        /// Received signal strength (dBm) of the WLAN measurement data.
        public let rss: Int

        @inlinable
        public init(macAddress: String, rss: Int) {
            self.macAddress = macAddress
            self.rss = rss
        }

        private enum CodingKeys: String, CodingKey {
            case macAddress = "MacAddress"
            case rss = "Rss"
        }
    }
}

// MARK: - Errors

/// Error enum for Location
public struct LocationErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Location
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request was denied because of insufficient access or permissions. Check with an administrator to verify your permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request was unsuccessful because of a conflict.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request has failed to process because of an unknown server error, exception, or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource that you've entered was not found in your AWS account.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The operation was denied because the request would exceed the maximum quota set for Amazon Location Service.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied because of request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input failed to meet the constraints specified by the AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension LocationErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": Location.ValidationException.self
    ]
}

extension LocationErrorType: Equatable {
    public static func == (lhs: LocationErrorType, rhs: LocationErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension LocationErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
