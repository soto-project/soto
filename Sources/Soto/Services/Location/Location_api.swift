//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Location service.
///
/// "Suite of geospatial services including Maps, Places, Routes, Tracking, and Geofencing"
public struct Location: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Location client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Location",
            serviceIdentifier: "geo",
            serviceProtocol: .restjson,
            apiVersion: "2020-11-19",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: LocationErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "us-gov-west-1": "geo-fips.us-gov-west-1.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Creates an association between a geofence collection and a tracker resource. This allows the tracker resource to communicate location data to the linked geofence collection.  You can associate up to five geofence collections to each tracker resource.  Currently not supported — Cross-account configurations, such as creating associations between a tracker resource in one account and a geofence collection in another account.
    @Sendable
    @inlinable
    public func associateTrackerConsumer(_ input: AssociateTrackerConsumerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateTrackerConsumerResponse {
        try await self.client.execute(
            operation: "AssociateTrackerConsumer", 
            path: "/tracking/v0/trackers/{TrackerName}/consumers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.tracking.", 
            logger: logger
        )
    }
    /// Creates an association between a geofence collection and a tracker resource. This allows the tracker resource to communicate location data to the linked geofence collection.  You can associate up to five geofence collections to each tracker resource.  Currently not supported — Cross-account configurations, such as creating associations between a tracker resource in one account and a geofence collection in another account.
    ///
    /// Parameters:
    ///   - consumerArn: The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker resource. Used when you need to specify a resource across all Amazon Web Services.   Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
    ///   - trackerName: The name of the tracker resource to be associated with a geofence collection.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateTrackerConsumer(
        consumerArn: String,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateTrackerConsumerResponse {
        let input = AssociateTrackerConsumerRequest(
            consumerArn: consumerArn, 
            trackerName: trackerName
        )
        return try await self.associateTrackerConsumer(input, logger: logger)
    }

    /// Deletes the position history of one or more devices from a tracker resource.
    @Sendable
    @inlinable
    public func batchDeleteDevicePositionHistory(_ input: BatchDeleteDevicePositionHistoryRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteDevicePositionHistoryResponse {
        try await self.client.execute(
            operation: "BatchDeleteDevicePositionHistory", 
            path: "/tracking/v0/trackers/{TrackerName}/delete-positions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tracking.", 
            logger: logger
        )
    }
    /// Deletes the position history of one or more devices from a tracker resource.
    ///
    /// Parameters:
    ///   - deviceIds: Devices whose position history you want to delete.   For example, for two devices: “DeviceIds” : [DeviceId1,DeviceId2]
    ///   - trackerName: The name of the tracker resource to delete the device position history from.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteDevicePositionHistory(
        deviceIds: [String],
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteDevicePositionHistoryResponse {
        let input = BatchDeleteDevicePositionHistoryRequest(
            deviceIds: deviceIds, 
            trackerName: trackerName
        )
        return try await self.batchDeleteDevicePositionHistory(input, logger: logger)
    }

    /// Deletes a batch of geofences from a geofence collection.  This operation deletes the resource permanently.
    @Sendable
    @inlinable
    public func batchDeleteGeofence(_ input: BatchDeleteGeofenceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteGeofenceResponse {
        try await self.client.execute(
            operation: "BatchDeleteGeofence", 
            path: "/geofencing/v0/collections/{CollectionName}/delete-geofences", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "geofencing.", 
            logger: logger
        )
    }
    /// Deletes a batch of geofences from a geofence collection.  This operation deletes the resource permanently.
    ///
    /// Parameters:
    ///   - collectionName: The geofence collection storing the geofences to be deleted.
    ///   - geofenceIds: The batch of geofences to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteGeofence(
        collectionName: String,
        geofenceIds: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteGeofenceResponse {
        let input = BatchDeleteGeofenceRequest(
            collectionName: collectionName, 
            geofenceIds: geofenceIds
        )
        return try await self.batchDeleteGeofence(input, logger: logger)
    }

    /// Evaluates device positions against the geofence geometries from a given geofence collection. This operation always returns an empty response because geofences are asynchronously evaluated. The evaluation determines if the device has entered or exited a geofenced area, and then publishes one of the following events to Amazon EventBridge:    ENTER if Amazon Location determines that the tracked device has entered a geofenced area.    EXIT if Amazon Location determines that the tracked device has exited a geofenced area.    The last geofence that a device was observed within is tracked for 30 days after the most recent device position update.   Geofence evaluation uses the given device position. It does not account for the optional Accuracy of a DevicePositionUpdate.   The DeviceID is used as a string to represent the device. You do not need to have a Tracker associated with the DeviceID.
    @Sendable
    @inlinable
    public func batchEvaluateGeofences(_ input: BatchEvaluateGeofencesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchEvaluateGeofencesResponse {
        try await self.client.execute(
            operation: "BatchEvaluateGeofences", 
            path: "/geofencing/v0/collections/{CollectionName}/positions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "geofencing.", 
            logger: logger
        )
    }
    /// Evaluates device positions against the geofence geometries from a given geofence collection. This operation always returns an empty response because geofences are asynchronously evaluated. The evaluation determines if the device has entered or exited a geofenced area, and then publishes one of the following events to Amazon EventBridge:    ENTER if Amazon Location determines that the tracked device has entered a geofenced area.    EXIT if Amazon Location determines that the tracked device has exited a geofenced area.    The last geofence that a device was observed within is tracked for 30 days after the most recent device position update.   Geofence evaluation uses the given device position. It does not account for the optional Accuracy of a DevicePositionUpdate.   The DeviceID is used as a string to represent the device. You do not need to have a Tracker associated with the DeviceID.
    ///
    /// Parameters:
    ///   - collectionName: The geofence collection used in evaluating the position of devices against its geofences.
    ///   - devicePositionUpdates: Contains device details for each device to be evaluated against the given geofence collection.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchEvaluateGeofences(
        collectionName: String,
        devicePositionUpdates: [DevicePositionUpdate],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchEvaluateGeofencesResponse {
        let input = BatchEvaluateGeofencesRequest(
            collectionName: collectionName, 
            devicePositionUpdates: devicePositionUpdates
        )
        return try await self.batchEvaluateGeofences(input, logger: logger)
    }

    /// Lists the latest device positions for requested devices.
    @Sendable
    @inlinable
    public func batchGetDevicePosition(_ input: BatchGetDevicePositionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetDevicePositionResponse {
        try await self.client.execute(
            operation: "BatchGetDevicePosition", 
            path: "/tracking/v0/trackers/{TrackerName}/get-positions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tracking.", 
            logger: logger
        )
    }
    /// Lists the latest device positions for requested devices.
    ///
    /// Parameters:
    ///   - deviceIds: Devices whose position you want to retrieve.   For example, for two devices: device-ids=DeviceId1&amp;device-ids=DeviceId2
    ///   - trackerName: The tracker resource retrieving the device position.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetDevicePosition(
        deviceIds: [String],
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetDevicePositionResponse {
        let input = BatchGetDevicePositionRequest(
            deviceIds: deviceIds, 
            trackerName: trackerName
        )
        return try await self.batchGetDevicePosition(input, logger: logger)
    }

    /// A batch request for storing geofence geometries into a given geofence collection, or updates the geometry of an existing geofence if a geofence ID is included in the request.
    @Sendable
    @inlinable
    public func batchPutGeofence(_ input: BatchPutGeofenceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchPutGeofenceResponse {
        try await self.client.execute(
            operation: "BatchPutGeofence", 
            path: "/geofencing/v0/collections/{CollectionName}/put-geofences", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "geofencing.", 
            logger: logger
        )
    }
    /// A batch request for storing geofence geometries into a given geofence collection, or updates the geometry of an existing geofence if a geofence ID is included in the request.
    ///
    /// Parameters:
    ///   - collectionName: The geofence collection storing the geofences.
    ///   - entries: The batch of geofences to be stored in a geofence collection.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchPutGeofence(
        collectionName: String,
        entries: [BatchPutGeofenceRequestEntry],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchPutGeofenceResponse {
        let input = BatchPutGeofenceRequest(
            collectionName: collectionName, 
            entries: entries
        )
        return try await self.batchPutGeofence(input, logger: logger)
    }

    /// Uploads position update data for one or more devices to a tracker resource (up to  10 devices per batch). Amazon Location uses the data when it reports the last known device  position and position history. Amazon Location retains location data for 30 days.  Position updates are handled based on the PositionFiltering  property of the tracker. When PositionFiltering is set to  TimeBased, updates are evaluated against linked geofence collections,  and location data is stored at a maximum of one position per 30 second interval.  If your update frequency is more often than every 30 seconds, only one update per  30 seconds is stored for each unique device ID. When PositionFiltering is set to DistanceBased  filtering, location data is stored and evaluated against linked geofence  collections only if the device has moved more than 30 m (98.4 ft). When PositionFiltering is set to AccuracyBased  filtering, location data is stored and evaluated against linked geofence  collections only if the device has moved more than the measured accuracy. For  example, if two consecutive updates from a device have a horizontal accuracy of  5 m and 10 m, the second update is neither stored or evaluated if the device has  moved less than 15 m. If PositionFiltering is set to  AccuracyBased filtering, Amazon Location uses the default value  { "Horizontal": 0} when accuracy is not provided on a DevicePositionUpdate.
    @Sendable
    @inlinable
    public func batchUpdateDevicePosition(_ input: BatchUpdateDevicePositionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdateDevicePositionResponse {
        try await self.client.execute(
            operation: "BatchUpdateDevicePosition", 
            path: "/tracking/v0/trackers/{TrackerName}/positions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tracking.", 
            logger: logger
        )
    }
    /// Uploads position update data for one or more devices to a tracker resource (up to  10 devices per batch). Amazon Location uses the data when it reports the last known device  position and position history. Amazon Location retains location data for 30 days.  Position updates are handled based on the PositionFiltering  property of the tracker. When PositionFiltering is set to  TimeBased, updates are evaluated against linked geofence collections,  and location data is stored at a maximum of one position per 30 second interval.  If your update frequency is more often than every 30 seconds, only one update per  30 seconds is stored for each unique device ID. When PositionFiltering is set to DistanceBased  filtering, location data is stored and evaluated against linked geofence  collections only if the device has moved more than 30 m (98.4 ft). When PositionFiltering is set to AccuracyBased  filtering, location data is stored and evaluated against linked geofence  collections only if the device has moved more than the measured accuracy. For  example, if two consecutive updates from a device have a horizontal accuracy of  5 m and 10 m, the second update is neither stored or evaluated if the device has  moved less than 15 m. If PositionFiltering is set to  AccuracyBased filtering, Amazon Location uses the default value  { "Horizontal": 0} when accuracy is not provided on a DevicePositionUpdate.
    ///
    /// Parameters:
    ///   - trackerName: The name of the tracker resource to update.
    ///   - updates: Contains the position update details for each device, up to 10 devices.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchUpdateDevicePosition(
        trackerName: String,
        updates: [DevicePositionUpdate],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchUpdateDevicePositionResponse {
        let input = BatchUpdateDevicePositionRequest(
            trackerName: trackerName, 
            updates: updates
        )
        return try await self.batchUpdateDevicePosition(input, logger: logger)
    }

    ///  Calculates a route given the following required parameters: DeparturePosition and DestinationPosition. Requires that you first create a route calculator resource. By default, a request that doesn't specify a departure time uses the best time of day to travel with the best traffic conditions when calculating the route. Additional options include:    Specifying a departure time using either DepartureTime or DepartNow. This calculates a route based on predictive traffic data at the given time.   You can't specify both DepartureTime and DepartNow in a single request. Specifying both parameters returns a validation error.     Specifying a travel mode using TravelMode sets the transportation mode used to calculate the routes. This also lets you specify additional route preferences in CarModeOptions if traveling by Car, or TruckModeOptions if traveling by Truck.  If you specify walking for the travel mode and your data  provider is Esri, the start and destination must be within 40km.
    @Sendable
    @inlinable
    public func calculateRoute(_ input: CalculateRouteRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CalculateRouteResponse {
        try await self.client.execute(
            operation: "CalculateRoute", 
            path: "/routes/v0/calculators/{CalculatorName}/calculate/route", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "routes.", 
            logger: logger
        )
    }
    ///  Calculates a route given the following required parameters: DeparturePosition and DestinationPosition. Requires that you first create a route calculator resource. By default, a request that doesn't specify a departure time uses the best time of day to travel with the best traffic conditions when calculating the route. Additional options include:    Specifying a departure time using either DepartureTime or DepartNow. This calculates a route based on predictive traffic data at the given time.   You can't specify both DepartureTime and DepartNow in a single request. Specifying both parameters returns a validation error.     Specifying a travel mode using TravelMode sets the transportation mode used to calculate the routes. This also lets you specify additional route preferences in CarModeOptions if traveling by Car, or TruckModeOptions if traveling by Truck.  If you specify walking for the travel mode and your data  provider is Esri, the start and destination must be within 40km.
    ///
    /// Parameters:
    ///   - arrivalTime: Specifies the desired time of arrival. Uses the given time to calculate the route.  Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.  ArrivalTime is not supported Esri.
    ///   - calculatorName: The name of the route calculator resource that you want to use to calculate the route.
    ///   - carModeOptions: Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
    ///   - departNow: Sets the time of departure as the current time. Uses the current time to calculate a route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route. Default Value: false  Valid Values: false | true
    ///   - departurePosition: The start position for the route. Defined in World Geodetic System (WGS 84) format: [longitude, latitude].   For example, [-123.115, 49.285]     If you specify a departure that's not located on a road, Amazon Location moves the position to the nearest road. If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error.  Valid Values: [-180 to 180,-90 to 90]
    ///   - departureTime: Specifies the desired time of departure. Uses the given time to calculate the route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.   In ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
    ///   - destinationPosition: The finish position for the route. Defined in World Geodetic System (WGS 84) format: [longitude, latitude].   For example, [-122.339, 47.615]     If you specify a destination that's not located on a road, Amazon Location moves the position to the nearest road.   Valid Values: [-180 to 180,-90 to 90]
    ///   - distanceUnit: Set the unit system to specify the distance. Default Value: Kilometers
    ///   - includeLegGeometry: Set to include the geometry details in the result for each path between a pair of positions. Default Value: false  Valid Values: false | true
    ///   - key: The optional API key to authorize  the request.
    ///   - optimizeFor: Specifies the distance to optimize for when calculating a route.
    ///   - travelMode: Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. You can choose Car, Truck,  Walking, Bicycle or Motorcycle as options for  the TravelMode.   Bicycle and Motorcycle are only valid when using Grab as a data provider, and only within Southeast Asia.  Truck is not available for Grab. For more details on the using Grab for routing, including areas of coverage, see GrabMaps in the Amazon Location Service Developer Guide.  The TravelMode you specify also determines how you specify route preferences:    If traveling by Car use the CarModeOptions parameter.   If traveling by Truck use the TruckModeOptions parameter.   Default Value: Car
    ///   - truckModeOptions: Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
    ///   - waypointPositions: Specifies an ordered list of up to 23 intermediate positions to include along a route between the departure position and destination position.    For example, from the DeparturePosition [-123.115, 49.285], the route follows the order that the waypoint positions are given [[-122.757, 49.0021],[-122.349, 47.620]]     If you specify a waypoint position that's not located on a road, Amazon Location moves the position to the nearest road.  Specifying more than 23 waypoints returns a 400 ValidationException error. If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a 400 RoutesValidationException error.  Valid Values: [-180 to 180,-90 to 90]
    ///   - logger: Logger use during operation
    @inlinable
    public func calculateRoute(
        arrivalTime: Date? = nil,
        calculatorName: String,
        carModeOptions: CalculateRouteCarModeOptions? = nil,
        departNow: Bool? = nil,
        departurePosition: [Double],
        departureTime: Date? = nil,
        destinationPosition: [Double],
        distanceUnit: DistanceUnit? = nil,
        includeLegGeometry: Bool? = nil,
        key: String? = nil,
        optimizeFor: OptimizationMode? = nil,
        travelMode: TravelMode? = nil,
        truckModeOptions: CalculateRouteTruckModeOptions? = nil,
        waypointPositions: [[Double]]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CalculateRouteResponse {
        let input = CalculateRouteRequest(
            arrivalTime: arrivalTime, 
            calculatorName: calculatorName, 
            carModeOptions: carModeOptions, 
            departNow: departNow, 
            departurePosition: departurePosition, 
            departureTime: departureTime, 
            destinationPosition: destinationPosition, 
            distanceUnit: distanceUnit, 
            includeLegGeometry: includeLegGeometry, 
            key: key, 
            optimizeFor: optimizeFor, 
            travelMode: travelMode, 
            truckModeOptions: truckModeOptions, 
            waypointPositions: waypointPositions
        )
        return try await self.calculateRoute(input, logger: logger)
    }

    ///  Calculates a route matrix given the following required parameters: DeparturePositions and DestinationPositions. CalculateRouteMatrix calculates routes and returns the travel time and travel distance from each departure position to each destination position in the request. For example, given departure positions A and B, and destination positions X and Y, CalculateRouteMatrix will return time and distance for routes from A to X, A to Y, B to X, and B to Y (in that order). The number of results returned (and routes calculated) will be the number of DeparturePositions times the number of DestinationPositions.  Your account is charged for each route calculated, not the number of requests.  Requires that you first create a route calculator resource. By default, a request that doesn't specify a departure time uses the best time of day to travel with the best traffic conditions when calculating routes. Additional options include:    Specifying a departure time using either DepartureTime or DepartNow. This calculates routes based on predictive traffic data at the given time.   You can't specify both DepartureTime and DepartNow in a single request. Specifying both parameters returns a validation error.     Specifying a travel mode using TravelMode sets the transportation mode used to calculate the routes. This also lets you specify additional route preferences in CarModeOptions if traveling by Car, or TruckModeOptions if traveling by Truck.
    @Sendable
    @inlinable
    public func calculateRouteMatrix(_ input: CalculateRouteMatrixRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CalculateRouteMatrixResponse {
        try await self.client.execute(
            operation: "CalculateRouteMatrix", 
            path: "/routes/v0/calculators/{CalculatorName}/calculate/route-matrix", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "routes.", 
            logger: logger
        )
    }
    ///  Calculates a route matrix given the following required parameters: DeparturePositions and DestinationPositions. CalculateRouteMatrix calculates routes and returns the travel time and travel distance from each departure position to each destination position in the request. For example, given departure positions A and B, and destination positions X and Y, CalculateRouteMatrix will return time and distance for routes from A to X, A to Y, B to X, and B to Y (in that order). The number of results returned (and routes calculated) will be the number of DeparturePositions times the number of DestinationPositions.  Your account is charged for each route calculated, not the number of requests.  Requires that you first create a route calculator resource. By default, a request that doesn't specify a departure time uses the best time of day to travel with the best traffic conditions when calculating routes. Additional options include:    Specifying a departure time using either DepartureTime or DepartNow. This calculates routes based on predictive traffic data at the given time.   You can't specify both DepartureTime and DepartNow in a single request. Specifying both parameters returns a validation error.     Specifying a travel mode using TravelMode sets the transportation mode used to calculate the routes. This also lets you specify additional route preferences in CarModeOptions if traveling by Car, or TruckModeOptions if traveling by Truck.
    ///
    /// Parameters:
    ///   - calculatorName: The name of the route calculator resource that you want to use to calculate the route matrix.
    ///   - carModeOptions: Specifies route preferences when traveling by Car, such as avoiding routes that use ferries or tolls. Requirements: TravelMode must be specified as Car.
    ///   - departNow: Sets the time of departure as the current time. Uses the current time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix. Default Value: false  Valid Values: false | true
    ///   - departurePositions: The list of departure (origin) positions for the route matrix. An array of points, each of which is itself a 2-value array defined in WGS 84 format: [longitude, latitude]. For example, [-123.115, 49.285].  Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See  Position restrictions in the Amazon Location Service Developer Guide.   For route calculators that use Esri as the data provider, if you specify a departure that's not located on a road, Amazon Location  moves the position to the nearest road. The snapped value is available in the result in SnappedDeparturePositions.  Valid Values: [-180 to 180,-90 to 90]
    ///   - departureTime: Specifies the desired time of departure. Uses the given time to calculate the route matrix. You can't set both DepartureTime and DepartNow. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix.  Setting a departure time in the past returns a 400 ValidationException error.    In ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. For example, 2020–07-2T12:15:20.000Z+01:00
    ///   - destinationPositions: The list of destination positions for the route matrix. An array of points, each of which is itself a 2-value array defined in WGS 84 format: [longitude, latitude]. For example, [-122.339, 47.615]   Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See  Position restrictions in the Amazon Location Service Developer Guide.   For route calculators that use Esri as the data provider, if you specify a destination that's not located on a road, Amazon Location  moves the position to the nearest road. The snapped value is available in the result in SnappedDestinationPositions.  Valid Values: [-180 to 180,-90 to 90]
    ///   - distanceUnit: Set the unit system to specify the distance. Default Value: Kilometers
    ///   - key: The optional API key to authorize  the request.
    ///   - travelMode: Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. The TravelMode you specify also determines how you specify route preferences:    If traveling by Car use the CarModeOptions parameter.   If traveling by Truck use the TruckModeOptions parameter.     Bicycle or Motorcycle are only valid when using Grab as a data provider, and only within Southeast Asia.  Truck is not available for Grab. For more information about using Grab as a data provider, see GrabMaps in the Amazon Location Service Developer Guide.  Default Value: Car
    ///   - truckModeOptions: Specifies route preferences when traveling by Truck, such as avoiding routes that use ferries or tolls, and truck specifications to consider when choosing an optimal road. Requirements: TravelMode must be specified as Truck.
    ///   - logger: Logger use during operation
    @inlinable
    public func calculateRouteMatrix(
        calculatorName: String,
        carModeOptions: CalculateRouteCarModeOptions? = nil,
        departNow: Bool? = nil,
        departurePositions: [[Double]],
        departureTime: Date? = nil,
        destinationPositions: [[Double]],
        distanceUnit: DistanceUnit? = nil,
        key: String? = nil,
        travelMode: TravelMode? = nil,
        truckModeOptions: CalculateRouteTruckModeOptions? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CalculateRouteMatrixResponse {
        let input = CalculateRouteMatrixRequest(
            calculatorName: calculatorName, 
            carModeOptions: carModeOptions, 
            departNow: departNow, 
            departurePositions: departurePositions, 
            departureTime: departureTime, 
            destinationPositions: destinationPositions, 
            distanceUnit: distanceUnit, 
            key: key, 
            travelMode: travelMode, 
            truckModeOptions: truckModeOptions
        )
        return try await self.calculateRouteMatrix(input, logger: logger)
    }

    /// Creates a geofence collection, which manages and stores geofences.
    @Sendable
    @inlinable
    public func createGeofenceCollection(_ input: CreateGeofenceCollectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateGeofenceCollectionResponse {
        try await self.client.execute(
            operation: "CreateGeofenceCollection", 
            path: "/geofencing/v0/collections", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.geofencing.", 
            logger: logger
        )
    }
    /// Creates a geofence collection, which manages and stores geofences.
    ///
    /// Parameters:
    ///   - collectionName: A custom name for the geofence collection. Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).    Must be a unique geofence collection name.   No spaces allowed. For example, ExampleGeofenceCollection.
    ///   - description: An optional description for the geofence collection.
    ///   - kmsKeyId: A key identifier for an Amazon Web Services KMS customer managed key. Enter a key ID, key ARN, alias name, or alias ARN.
    ///   - tags: Applies one or more tags to the geofence collection. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
    ///   - logger: Logger use during operation
    @inlinable
    public func createGeofenceCollection(
        collectionName: String,
        description: String? = nil,
        kmsKeyId: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateGeofenceCollectionResponse {
        let input = CreateGeofenceCollectionRequest(
            collectionName: collectionName, 
            description: description, 
            kmsKeyId: kmsKeyId, 
            tags: tags
        )
        return try await self.createGeofenceCollection(input, logger: logger)
    }

    /// Creates an API key resource in your Amazon Web Services account, which lets you grant actions for Amazon Location resources to the API key bearer.  For more information, see Using API keys.
    @Sendable
    @inlinable
    public func createKey(_ input: CreateKeyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKeyResponse {
        try await self.client.execute(
            operation: "CreateKey", 
            path: "/metadata/v0/keys", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.metadata.", 
            logger: logger
        )
    }
    /// Creates an API key resource in your Amazon Web Services account, which lets you grant actions for Amazon Location resources to the API key bearer.  For more information, see Using API keys.
    ///
    /// Parameters:
    ///   - description: An optional description for the API key resource.
    ///   - expireTime: The optional timestamp for when the API key resource will expire in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. One of NoExpiry or ExpireTime must be set.
    ///   - keyName: A custom name for the API key resource. Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).    Must be a unique API key name.   No spaces allowed. For example, ExampleAPIKey.
    ///   - noExpiry: Optionally set to true to set no expiration time for the API key. One of NoExpiry or ExpireTime must be set.
    ///   - restrictions: The API key restrictions for the API key resource.
    ///   - tags: Applies one or more tags to the map resource. A tag is a key-value pair that helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
    ///   - logger: Logger use during operation
    @inlinable
    public func createKey(
        description: String? = nil,
        expireTime: Date? = nil,
        keyName: String,
        noExpiry: Bool? = nil,
        restrictions: ApiKeyRestrictions,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateKeyResponse {
        let input = CreateKeyRequest(
            description: description, 
            expireTime: expireTime, 
            keyName: keyName, 
            noExpiry: noExpiry, 
            restrictions: restrictions, 
            tags: tags
        )
        return try await self.createKey(input, logger: logger)
    }

    /// Creates a map resource in your Amazon Web Services account, which provides map tiles of different styles sourced from global location data providers.  If your application is tracking or routing assets you use in your business, such  as delivery vehicles or employees, you must not use Esri as your geolocation  provider. See section 82 of the Amazon Web Services service terms for more details.
    @Sendable
    @inlinable
    public func createMap(_ input: CreateMapRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMapResponse {
        try await self.client.execute(
            operation: "CreateMap", 
            path: "/maps/v0/maps", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.maps.", 
            logger: logger
        )
    }
    /// Creates a map resource in your Amazon Web Services account, which provides map tiles of different styles sourced from global location data providers.  If your application is tracking or routing assets you use in your business, such  as delivery vehicles or employees, you must not use Esri as your geolocation  provider. See section 82 of the Amazon Web Services service terms for more details.
    ///
    /// Parameters:
    ///   - configuration: Specifies the MapConfiguration, including the map style, for the  map resource that you create. The map style defines the look of maps and the data  provider for your map resource.
    ///   - description: An optional description for the map resource.
    ///   - mapName: The name for the map resource. Requirements:   Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).    Must be a unique map resource name.    No spaces allowed. For example, ExampleMap.
    ///   - tags: Applies one or more tags to the map resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length:  256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
    ///   - logger: Logger use during operation
    @inlinable
    public func createMap(
        configuration: MapConfiguration,
        description: String? = nil,
        mapName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMapResponse {
        let input = CreateMapRequest(
            configuration: configuration, 
            description: description, 
            mapName: mapName, 
            tags: tags
        )
        return try await self.createMap(input, logger: logger)
    }

    /// Creates a place index resource in your Amazon Web Services account. Use a place index resource to geocode addresses and other text queries by using the SearchPlaceIndexForText operation, and reverse geocode coordinates by using the SearchPlaceIndexForPosition operation, and enable autosuggestions by using the SearchPlaceIndexForSuggestions operation.  If your application is tracking or routing assets you use in your business, such  as delivery vehicles or employees, you must not use Esri as your geolocation  provider. See section 82 of the Amazon Web Services service terms for more details.
    @Sendable
    @inlinable
    public func createPlaceIndex(_ input: CreatePlaceIndexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePlaceIndexResponse {
        try await self.client.execute(
            operation: "CreatePlaceIndex", 
            path: "/places/v0/indexes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.places.", 
            logger: logger
        )
    }
    /// Creates a place index resource in your Amazon Web Services account. Use a place index resource to geocode addresses and other text queries by using the SearchPlaceIndexForText operation, and reverse geocode coordinates by using the SearchPlaceIndexForPosition operation, and enable autosuggestions by using the SearchPlaceIndexForSuggestions operation.  If your application is tracking or routing assets you use in your business, such  as delivery vehicles or employees, you must not use Esri as your geolocation  provider. See section 82 of the Amazon Web Services service terms for more details.
    ///
    /// Parameters:
    ///   - dataSource: Specifies the geospatial data provider for the new place index.  This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error.  Valid values include:    Esri – For additional information about Esri's coverage in your region of interest, see Esri details on geocoding coverage.    Grab – Grab provides place index functionality for Southeast  Asia. For additional information about GrabMaps' coverage, see GrabMaps countries and areas covered.    Here – For additional information about HERE Technologies' coverage in your region of interest, see HERE details on goecoding coverage.  If you specify HERE Technologies (Here) as the data provider, you may not store results for locations in Japan. For more information, see the Amazon Web Services Service Terms for Amazon Location Service.    For additional information , see Data providers on the Amazon Location Service Developer Guide.
    ///   - dataSourceConfiguration: Specifies the data storage option requesting Places.
    ///   - description: The optional description for the place index resource.
    ///   - indexName: The name of the place index resource.  Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).   Must be a unique place index resource name.   No spaces allowed. For example, ExamplePlaceIndex.
    ///   - tags: Applies one or more tags to the place index resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource.   Each tag key must be unique and must have exactly one associated value.   Maximum key length: 128 Unicode characters in UTF-8.   Maximum value length: 256 Unicode characters in UTF-8.   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @   Cannot use "aws:" as a prefix for a key.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPlaceIndex(
        dataSource: String,
        dataSourceConfiguration: DataSourceConfiguration? = nil,
        description: String? = nil,
        indexName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePlaceIndexResponse {
        let input = CreatePlaceIndexRequest(
            dataSource: dataSource, 
            dataSourceConfiguration: dataSourceConfiguration, 
            description: description, 
            indexName: indexName, 
            tags: tags
        )
        return try await self.createPlaceIndex(input, logger: logger)
    }

    /// Creates a route calculator resource in your Amazon Web Services account. You can send requests to a route calculator resource to estimate travel time, distance, and get directions. A route calculator sources traffic and road network data from your chosen data provider.  If your application is tracking or routing assets you use in your business, such  as delivery vehicles or employees, you must not use Esri as your geolocation  provider. See section 82 of the Amazon Web Services service terms for more details.
    @Sendable
    @inlinable
    public func createRouteCalculator(_ input: CreateRouteCalculatorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRouteCalculatorResponse {
        try await self.client.execute(
            operation: "CreateRouteCalculator", 
            path: "/routes/v0/calculators", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.routes.", 
            logger: logger
        )
    }
    /// Creates a route calculator resource in your Amazon Web Services account. You can send requests to a route calculator resource to estimate travel time, distance, and get directions. A route calculator sources traffic and road network data from your chosen data provider.  If your application is tracking or routing assets you use in your business, such  as delivery vehicles or employees, you must not use Esri as your geolocation  provider. See section 82 of the Amazon Web Services service terms for more details.
    ///
    /// Parameters:
    ///   - calculatorName: The name of the route calculator resource.  Requirements:   Can use alphanumeric characters (A–Z, a–z, 0–9) , hyphens (-), periods (.), and underscores (_).   Must be a unique Route calculator resource name.   No spaces allowed. For example, ExampleRouteCalculator.
    ///   - dataSource: Specifies the data provider of traffic and road network data.  This field is case-sensitive. Enter the valid values as shown. For example, entering HERE returns an error.  Valid values include:    Esri – For additional information about Esri's coverage in your region of interest, see Esri details on street networks and traffic coverage. Route calculators that use Esri as a data source only calculate routes that are shorter than 400 km.    Grab – Grab provides routing functionality for Southeast Asia. For additional information about GrabMaps' coverage, see GrabMaps countries and areas covered.    Here – For additional information about HERE Technologies' coverage in your region of interest, see HERE car routing coverage and HERE truck routing coverage.   For additional information , see Data providers on the Amazon Location Service Developer Guide.
    ///   - description: The optional description for the route calculator resource.
    ///   - tags: Applies one or more tags to the route calculator resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.   For example: { "tag1" : "value1", "tag2" : "value2"}   Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRouteCalculator(
        calculatorName: String,
        dataSource: String,
        description: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRouteCalculatorResponse {
        let input = CreateRouteCalculatorRequest(
            calculatorName: calculatorName, 
            dataSource: dataSource, 
            description: description, 
            tags: tags
        )
        return try await self.createRouteCalculator(input, logger: logger)
    }

    /// Creates a tracker resource in your Amazon Web Services account, which lets you retrieve current and historical location of devices.
    @Sendable
    @inlinable
    public func createTracker(_ input: CreateTrackerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTrackerResponse {
        try await self.client.execute(
            operation: "CreateTracker", 
            path: "/tracking/v0/trackers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.tracking.", 
            logger: logger
        )
    }
    /// Creates a tracker resource in your Amazon Web Services account, which lets you retrieve current and historical location of devices.
    ///
    /// Parameters:
    ///   - description: An optional description for the tracker resource.
    ///   - eventBridgeEnabled: Whether to enable position UPDATE events from this tracker to be sent to  EventBridge.  You do not need enable this feature to get ENTER and  EXIT events for geofences with this tracker. Those events are always sent to EventBridge.
    ///   - kmsKeyEnableGeospatialQueries: Enables GeospatialQueries for a tracker that uses a Amazon Web Services KMS customer managed key. This parameter is only used if you are using a KMS customer managed key.  If you wish to encrypt your data using your own KMS customer managed key, then the Bounding Polygon Queries feature will be disabled by default.  This is because by using this feature, a representation of your device positions will not be encrypted using the your KMS managed key. The exact device position, however; is still encrypted using your managed key. You can choose to opt-in to the Bounding Polygon Quseries feature. This is done by setting the KmsKeyEnableGeospatialQueries parameter to  true when creating or updating a Tracker.
    ///   - kmsKeyId: A key identifier for an  Amazon Web Services  KMS customer managed key. Enter a key ID, key ARN, alias name, or alias ARN.
    ///   - positionFiltering: Specifies the position filtering for the tracker resource. Valid values:    TimeBased - Location updates are evaluated against linked geofence collections,  but not every location update is stored. If your update frequency is more often than 30 seconds,  only one update per 30 seconds is stored for each unique device ID.     DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are  ignored. Location updates within this area are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.     AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This can reduce the effects of GPS noise when displaying device trajectories on a map, and can help control your costs by reducing the number of geofence evaluations.    This field is optional. If not specified, the default value is TimeBased.
    ///   - tags: Applies one or more tags to the tracker resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource   Each resource tag must be unique with a maximum of one value.   Maximum key length: 128 Unicode characters in UTF-8   Maximum value length: 256 Unicode characters in UTF-8   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @.    Cannot use "aws:" as a prefix for a key.
    ///   - trackerName: The name for the tracker resource. Requirements:   Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).   Must be a unique tracker resource name.   No spaces allowed. For example, ExampleTracker.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTracker(
        description: String? = nil,
        eventBridgeEnabled: Bool? = nil,
        kmsKeyEnableGeospatialQueries: Bool? = nil,
        kmsKeyId: String? = nil,
        positionFiltering: PositionFiltering? = nil,
        tags: [String: String]? = nil,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateTrackerResponse {
        let input = CreateTrackerRequest(
            description: description, 
            eventBridgeEnabled: eventBridgeEnabled, 
            kmsKeyEnableGeospatialQueries: kmsKeyEnableGeospatialQueries, 
            kmsKeyId: kmsKeyId, 
            positionFiltering: positionFiltering, 
            tags: tags, 
            trackerName: trackerName
        )
        return try await self.createTracker(input, logger: logger)
    }

    /// Deletes a geofence collection from your Amazon Web Services account.  This operation deletes the resource permanently. If the geofence collection is the target of a tracker resource, the devices will no longer be monitored.
    @Sendable
    @inlinable
    public func deleteGeofenceCollection(_ input: DeleteGeofenceCollectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteGeofenceCollectionResponse {
        try await self.client.execute(
            operation: "DeleteGeofenceCollection", 
            path: "/geofencing/v0/collections/{CollectionName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.geofencing.", 
            logger: logger
        )
    }
    /// Deletes a geofence collection from your Amazon Web Services account.  This operation deletes the resource permanently. If the geofence collection is the target of a tracker resource, the devices will no longer be monitored.
    ///
    /// Parameters:
    ///   - collectionName: The name of the geofence collection to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteGeofenceCollection(
        collectionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteGeofenceCollectionResponse {
        let input = DeleteGeofenceCollectionRequest(
            collectionName: collectionName
        )
        return try await self.deleteGeofenceCollection(input, logger: logger)
    }

    /// Deletes the specified API key. The API key must have been deactivated more than 90 days previously.
    @Sendable
    @inlinable
    public func deleteKey(_ input: DeleteKeyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteKeyResponse {
        try await self.client.execute(
            operation: "DeleteKey", 
            path: "/metadata/v0/keys/{KeyName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.metadata.", 
            logger: logger
        )
    }
    /// Deletes the specified API key. The API key must have been deactivated more than 90 days previously.
    ///
    /// Parameters:
    ///   - forceDelete: ForceDelete bypasses an API key's expiry conditions and deletes the key. Set the parameter true to delete the key or to false to not preemptively delete the API key. Valid values: true, or false. Required: No  This action is irreversible. Only use ForceDelete if you are certain the key is no longer in use.
    ///   - keyName: The name of the API key to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteKey(
        forceDelete: Bool? = nil,
        keyName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteKeyResponse {
        let input = DeleteKeyRequest(
            forceDelete: forceDelete, 
            keyName: keyName
        )
        return try await self.deleteKey(input, logger: logger)
    }

    /// Deletes a map resource from your Amazon Web Services account.  This operation deletes the resource permanently. If the map is being used in an application, the map may not render.
    @Sendable
    @inlinable
    public func deleteMap(_ input: DeleteMapRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMapResponse {
        try await self.client.execute(
            operation: "DeleteMap", 
            path: "/maps/v0/maps/{MapName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.maps.", 
            logger: logger
        )
    }
    /// Deletes a map resource from your Amazon Web Services account.  This operation deletes the resource permanently. If the map is being used in an application, the map may not render.
    ///
    /// Parameters:
    ///   - mapName: The name of the map resource to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMap(
        mapName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteMapResponse {
        let input = DeleteMapRequest(
            mapName: mapName
        )
        return try await self.deleteMap(input, logger: logger)
    }

    /// Deletes a place index resource from your Amazon Web Services account.  This operation deletes the resource permanently.
    @Sendable
    @inlinable
    public func deletePlaceIndex(_ input: DeletePlaceIndexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePlaceIndexResponse {
        try await self.client.execute(
            operation: "DeletePlaceIndex", 
            path: "/places/v0/indexes/{IndexName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.places.", 
            logger: logger
        )
    }
    /// Deletes a place index resource from your Amazon Web Services account.  This operation deletes the resource permanently.
    ///
    /// Parameters:
    ///   - indexName: The name of the place index resource to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePlaceIndex(
        indexName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePlaceIndexResponse {
        let input = DeletePlaceIndexRequest(
            indexName: indexName
        )
        return try await self.deletePlaceIndex(input, logger: logger)
    }

    /// Deletes a route calculator resource from your Amazon Web Services account.  This operation deletes the resource permanently.
    @Sendable
    @inlinable
    public func deleteRouteCalculator(_ input: DeleteRouteCalculatorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteRouteCalculatorResponse {
        try await self.client.execute(
            operation: "DeleteRouteCalculator", 
            path: "/routes/v0/calculators/{CalculatorName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.routes.", 
            logger: logger
        )
    }
    /// Deletes a route calculator resource from your Amazon Web Services account.  This operation deletes the resource permanently.
    ///
    /// Parameters:
    ///   - calculatorName: The name of the route calculator resource to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRouteCalculator(
        calculatorName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteRouteCalculatorResponse {
        let input = DeleteRouteCalculatorRequest(
            calculatorName: calculatorName
        )
        return try await self.deleteRouteCalculator(input, logger: logger)
    }

    /// Deletes a tracker resource from your Amazon Web Services account.  This operation deletes the resource permanently. If the tracker resource is in use, you may encounter an error. Make sure that the target resource isn't a dependency for your applications.
    @Sendable
    @inlinable
    public func deleteTracker(_ input: DeleteTrackerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteTrackerResponse {
        try await self.client.execute(
            operation: "DeleteTracker", 
            path: "/tracking/v0/trackers/{TrackerName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.tracking.", 
            logger: logger
        )
    }
    /// Deletes a tracker resource from your Amazon Web Services account.  This operation deletes the resource permanently. If the tracker resource is in use, you may encounter an error. Make sure that the target resource isn't a dependency for your applications.
    ///
    /// Parameters:
    ///   - trackerName: The name of the tracker resource to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTracker(
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteTrackerResponse {
        let input = DeleteTrackerRequest(
            trackerName: trackerName
        )
        return try await self.deleteTracker(input, logger: logger)
    }

    /// Retrieves the geofence collection details.
    @Sendable
    @inlinable
    public func describeGeofenceCollection(_ input: DescribeGeofenceCollectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeGeofenceCollectionResponse {
        try await self.client.execute(
            operation: "DescribeGeofenceCollection", 
            path: "/geofencing/v0/collections/{CollectionName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.geofencing.", 
            logger: logger
        )
    }
    /// Retrieves the geofence collection details.
    ///
    /// Parameters:
    ///   - collectionName: The name of the geofence collection.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeGeofenceCollection(
        collectionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeGeofenceCollectionResponse {
        let input = DescribeGeofenceCollectionRequest(
            collectionName: collectionName
        )
        return try await self.describeGeofenceCollection(input, logger: logger)
    }

    /// Retrieves the API key resource details.
    @Sendable
    @inlinable
    public func describeKey(_ input: DescribeKeyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeKeyResponse {
        try await self.client.execute(
            operation: "DescribeKey", 
            path: "/metadata/v0/keys/{KeyName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.metadata.", 
            logger: logger
        )
    }
    /// Retrieves the API key resource details.
    ///
    /// Parameters:
    ///   - keyName: The name of the API key resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeKey(
        keyName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeKeyResponse {
        let input = DescribeKeyRequest(
            keyName: keyName
        )
        return try await self.describeKey(input, logger: logger)
    }

    /// Retrieves the map resource details.
    @Sendable
    @inlinable
    public func describeMap(_ input: DescribeMapRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeMapResponse {
        try await self.client.execute(
            operation: "DescribeMap", 
            path: "/maps/v0/maps/{MapName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.maps.", 
            logger: logger
        )
    }
    /// Retrieves the map resource details.
    ///
    /// Parameters:
    ///   - mapName: The name of the map resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeMap(
        mapName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeMapResponse {
        let input = DescribeMapRequest(
            mapName: mapName
        )
        return try await self.describeMap(input, logger: logger)
    }

    /// Retrieves the place index resource details.
    @Sendable
    @inlinable
    public func describePlaceIndex(_ input: DescribePlaceIndexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribePlaceIndexResponse {
        try await self.client.execute(
            operation: "DescribePlaceIndex", 
            path: "/places/v0/indexes/{IndexName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.places.", 
            logger: logger
        )
    }
    /// Retrieves the place index resource details.
    ///
    /// Parameters:
    ///   - indexName: The name of the place index resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func describePlaceIndex(
        indexName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribePlaceIndexResponse {
        let input = DescribePlaceIndexRequest(
            indexName: indexName
        )
        return try await self.describePlaceIndex(input, logger: logger)
    }

    /// Retrieves the route calculator resource details.
    @Sendable
    @inlinable
    public func describeRouteCalculator(_ input: DescribeRouteCalculatorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRouteCalculatorResponse {
        try await self.client.execute(
            operation: "DescribeRouteCalculator", 
            path: "/routes/v0/calculators/{CalculatorName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.routes.", 
            logger: logger
        )
    }
    /// Retrieves the route calculator resource details.
    ///
    /// Parameters:
    ///   - calculatorName: The name of the route calculator resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeRouteCalculator(
        calculatorName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeRouteCalculatorResponse {
        let input = DescribeRouteCalculatorRequest(
            calculatorName: calculatorName
        )
        return try await self.describeRouteCalculator(input, logger: logger)
    }

    /// Retrieves the tracker resource details.
    @Sendable
    @inlinable
    public func describeTracker(_ input: DescribeTrackerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeTrackerResponse {
        try await self.client.execute(
            operation: "DescribeTracker", 
            path: "/tracking/v0/trackers/{TrackerName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.tracking.", 
            logger: logger
        )
    }
    /// Retrieves the tracker resource details.
    ///
    /// Parameters:
    ///   - trackerName: The name of the tracker resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeTracker(
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeTrackerResponse {
        let input = DescribeTrackerRequest(
            trackerName: trackerName
        )
        return try await self.describeTracker(input, logger: logger)
    }

    /// Removes the association between a tracker resource and a geofence collection.  Once you unlink a tracker resource from a geofence collection, the tracker positions will no longer be automatically evaluated against geofences.
    @Sendable
    @inlinable
    public func disassociateTrackerConsumer(_ input: DisassociateTrackerConsumerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateTrackerConsumerResponse {
        try await self.client.execute(
            operation: "DisassociateTrackerConsumer", 
            path: "/tracking/v0/trackers/{TrackerName}/consumers/{ConsumerArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.tracking.", 
            logger: logger
        )
    }
    /// Removes the association between a tracker resource and a geofence collection.  Once you unlink a tracker resource from a geofence collection, the tracker positions will no longer be automatically evaluated against geofences.
    ///
    /// Parameters:
    ///   - consumerArn: The Amazon Resource Name (ARN) for the geofence collection to be disassociated from the tracker resource. Used when you need to specify a resource across all Amazon Web Services.    Format example: arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
    ///   - trackerName: The name of the tracker resource to be dissociated from the consumer.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateTrackerConsumer(
        consumerArn: String,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateTrackerConsumerResponse {
        let input = DisassociateTrackerConsumerRequest(
            consumerArn: consumerArn, 
            trackerName: trackerName
        )
        return try await self.disassociateTrackerConsumer(input, logger: logger)
    }

    /// Evaluates device positions against geofence geometries from a given geofence collection. The event forecasts three states for which a device can be in relative to a geofence:  ENTER: If a device is outside of a geofence, but would breach the fence if the device is moving at its current speed within time horizon window.  EXIT: If a device is inside of a geofence, but would breach the fence if the device is moving at its current speed within time horizon window.  IDLE: If a device is inside of a geofence, and the device is not moving.
    @Sendable
    @inlinable
    public func forecastGeofenceEvents(_ input: ForecastGeofenceEventsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ForecastGeofenceEventsResponse {
        try await self.client.execute(
            operation: "ForecastGeofenceEvents", 
            path: "/geofencing/v0/collections/{CollectionName}/forecast-geofence-events", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "geofencing.", 
            logger: logger
        )
    }
    /// Evaluates device positions against geofence geometries from a given geofence collection. The event forecasts three states for which a device can be in relative to a geofence:  ENTER: If a device is outside of a geofence, but would breach the fence if the device is moving at its current speed within time horizon window.  EXIT: If a device is inside of a geofence, but would breach the fence if the device is moving at its current speed within time horizon window.  IDLE: If a device is inside of a geofence, and the device is not moving.
    ///
    /// Parameters:
    ///   - collectionName: The name of the geofence collection.
    ///   - deviceState: The device's state, including current position and speed.
    ///   - distanceUnit: The distance unit used for the NearestDistance property returned in a forecasted event. The measurement system must match for DistanceUnit and SpeedUnit; if Kilometers is specified for DistanceUnit, then SpeedUnit must be KilometersPerHour.  Default Value: Kilometers
    ///   - maxResults: An optional limit for the number of resources returned in a single call. Default value: 20
    ///   - nextToken: The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    ///   - speedUnit: The speed unit for the device captured by the device state. The measurement system must match for DistanceUnit and SpeedUnit; if Kilometers is specified for DistanceUnit, then SpeedUnit must be KilometersPerHour. Default Value: KilometersPerHour.
    ///   - timeHorizonMinutes: Specifies the time horizon in minutes for the forecasted events.
    ///   - logger: Logger use during operation
    @inlinable
    public func forecastGeofenceEvents(
        collectionName: String,
        deviceState: ForecastGeofenceEventsDeviceState,
        distanceUnit: DistanceUnit? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        speedUnit: SpeedUnit? = nil,
        timeHorizonMinutes: Double? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ForecastGeofenceEventsResponse {
        let input = ForecastGeofenceEventsRequest(
            collectionName: collectionName, 
            deviceState: deviceState, 
            distanceUnit: distanceUnit, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            speedUnit: speedUnit, 
            timeHorizonMinutes: timeHorizonMinutes
        )
        return try await self.forecastGeofenceEvents(input, logger: logger)
    }

    /// Retrieves a device's most recent position according to its sample time.  Device positions are deleted after 30 days.
    @Sendable
    @inlinable
    public func getDevicePosition(_ input: GetDevicePositionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDevicePositionResponse {
        try await self.client.execute(
            operation: "GetDevicePosition", 
            path: "/tracking/v0/trackers/{TrackerName}/devices/{DeviceId}/positions/latest", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tracking.", 
            logger: logger
        )
    }
    /// Retrieves a device's most recent position according to its sample time.  Device positions are deleted after 30 days.
    ///
    /// Parameters:
    ///   - deviceId: The device whose position you want to retrieve.
    ///   - trackerName: The tracker resource receiving the position update.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDevicePosition(
        deviceId: String,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDevicePositionResponse {
        let input = GetDevicePositionRequest(
            deviceId: deviceId, 
            trackerName: trackerName
        )
        return try await self.getDevicePosition(input, logger: logger)
    }

    /// Retrieves the device position history from a tracker resource within a specified range of time.  Device positions are deleted after 30 days.
    @Sendable
    @inlinable
    public func getDevicePositionHistory(_ input: GetDevicePositionHistoryRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDevicePositionHistoryResponse {
        try await self.client.execute(
            operation: "GetDevicePositionHistory", 
            path: "/tracking/v0/trackers/{TrackerName}/devices/{DeviceId}/list-positions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tracking.", 
            logger: logger
        )
    }
    /// Retrieves the device position history from a tracker resource within a specified range of time.  Device positions are deleted after 30 days.
    ///
    /// Parameters:
    ///   - deviceId: The device whose position history you want to retrieve.
    ///   - endTimeExclusive: Specify the end time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be the time that the request is made. Requirement:   The time specified for EndTimeExclusive must be after the time for StartTimeInclusive.
    ///   - maxResults: An optional limit for the number of device positions returned in a single call. Default value: 100
    ///   - nextToken: The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
    ///   - startTimeInclusive: Specify the start time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be 24 hours prior to the time that the request is made. Requirement:   The time specified for StartTimeInclusive must be before EndTimeExclusive.
    ///   - trackerName: The tracker resource receiving the request for the device position history.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDevicePositionHistory(
        deviceId: String,
        endTimeExclusive: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTimeInclusive: Date? = nil,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDevicePositionHistoryResponse {
        let input = GetDevicePositionHistoryRequest(
            deviceId: deviceId, 
            endTimeExclusive: endTimeExclusive, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            startTimeInclusive: startTimeInclusive, 
            trackerName: trackerName
        )
        return try await self.getDevicePositionHistory(input, logger: logger)
    }

    /// Retrieves the geofence details from a geofence collection.  The returned geometry will always match the geometry format used when the geofence was created.
    @Sendable
    @inlinable
    public func getGeofence(_ input: GetGeofenceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetGeofenceResponse {
        try await self.client.execute(
            operation: "GetGeofence", 
            path: "/geofencing/v0/collections/{CollectionName}/geofences/{GeofenceId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "geofencing.", 
            logger: logger
        )
    }
    /// Retrieves the geofence details from a geofence collection.  The returned geometry will always match the geometry format used when the geofence was created.
    ///
    /// Parameters:
    ///   - collectionName: The geofence collection storing the target geofence.
    ///   - geofenceId: The geofence you're retrieving details for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getGeofence(
        collectionName: String,
        geofenceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetGeofenceResponse {
        let input = GetGeofenceRequest(
            collectionName: collectionName, 
            geofenceId: geofenceId
        )
        return try await self.getGeofence(input, logger: logger)
    }

    /// Retrieves glyphs used to display labels on a map.
    @Sendable
    @inlinable
    public func getMapGlyphs(_ input: GetMapGlyphsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMapGlyphsResponse {
        try await self.client.execute(
            operation: "GetMapGlyphs", 
            path: "/maps/v0/maps/{MapName}/glyphs/{FontStack}/{FontUnicodeRange}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "maps.", 
            logger: logger
        )
    }
    /// Retrieves glyphs used to display labels on a map.
    ///
    /// Parameters:
    ///   - fontStack: A comma-separated list of fonts to load glyphs from in order of preference. For example, Noto Sans Regular, Arial Unicode. Valid font stacks for Esri styles:    VectorEsriDarkGrayCanvas – Ubuntu Medium Italic | Ubuntu Medium | Ubuntu Italic | Ubuntu Regular | Ubuntu Bold    VectorEsriLightGrayCanvas – Ubuntu Italic | Ubuntu Regular | Ubuntu Light | Ubuntu Bold    VectorEsriTopographic – Noto Sans Italic | Noto Sans Regular | Noto Sans Bold | Noto Serif Regular | Roboto Condensed Light Italic    VectorEsriStreets – Arial Regular | Arial Italic | Arial Bold    VectorEsriNavigation – Arial Regular | Arial Italic | Arial Bold    Valid font stacks for HERE Technologies styles:   VectorHereContrast – Fira  GO Regular | Fira GO Bold    VectorHereExplore, VectorHereExploreTruck, HybridHereExploreSatellite –  Fira GO Italic | Fira GO Map |  Fira GO Map Bold | Noto Sans CJK JP Bold |  Noto Sans CJK JP Light |  Noto Sans CJK JP Regular    Valid font stacks for GrabMaps styles:   VectorGrabStandardLight, VectorGrabStandardDark –  Noto Sans Regular | Noto Sans Medium | Noto Sans Bold    Valid font stacks for Open Data styles:   VectorOpenDataStandardLight, VectorOpenDataStandardDark, VectorOpenDataVisualizationLight, VectorOpenDataVisualizationDark –  Amazon Ember Regular,Noto Sans Regular | Amazon Ember Bold,Noto Sans Bold |  Amazon Ember Medium,Noto Sans Medium | Amazon Ember Regular Italic,Noto Sans Italic |  Amazon Ember Condensed RC Regular,Noto Sans Regular |  Amazon Ember Condensed RC Bold,Noto Sans Bold | Amazon Ember Regular,Noto Sans Regular,Noto Sans Arabic Regular | Amazon Ember Condensed RC Bold,Noto Sans Bold,Noto Sans Arabic  Condensed Bold | Amazon Ember Bold,Noto Sans Bold,Noto Sans Arabic Bold | Amazon Ember Regular Italic,Noto Sans Italic,Noto Sans Arabic  Regular | Amazon Ember Condensed RC Regular,Noto Sans Regular,Noto Sans Arabic  Condensed Regular | Amazon Ember Medium,Noto Sans Medium,Noto Sans Arabic Medium     The fonts used by the Open Data map styles are combined fonts that use Amazon Ember for most glyphs but Noto Sans  for glyphs unsupported by Amazon Ember.
    ///   - fontUnicodeRange: A Unicode range of characters to download glyphs for. Each response will contain 256 characters. For example, 0–255 includes all characters from range U+0000 to 00FF. Must be aligned to multiples of 256.
    ///   - key: The optional API key to authorize  the request.
    ///   - mapName: The map resource associated with the glyph ﬁle.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMapGlyphs(
        fontStack: String,
        fontUnicodeRange: String,
        key: String? = nil,
        mapName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMapGlyphsResponse {
        let input = GetMapGlyphsRequest(
            fontStack: fontStack, 
            fontUnicodeRange: fontUnicodeRange, 
            key: key, 
            mapName: mapName
        )
        return try await self.getMapGlyphs(input, logger: logger)
    }

    /// Retrieves the sprite sheet corresponding to a map resource. The sprite sheet is a PNG image paired with a JSON document describing the offsets of individual icons that will be displayed on a rendered map.
    @Sendable
    @inlinable
    public func getMapSprites(_ input: GetMapSpritesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMapSpritesResponse {
        try await self.client.execute(
            operation: "GetMapSprites", 
            path: "/maps/v0/maps/{MapName}/sprites/{FileName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "maps.", 
            logger: logger
        )
    }
    /// Retrieves the sprite sheet corresponding to a map resource. The sprite sheet is a PNG image paired with a JSON document describing the offsets of individual icons that will be displayed on a rendered map.
    ///
    /// Parameters:
    ///   - fileName: The name of the sprite ﬁle. Use the following ﬁle names for the sprite sheet:    sprites.png     sprites@2x.png for high pixel density displays   For the JSON document containing image offsets. Use the following ﬁle names:    sprites.json     sprites@2x.json for high pixel density displays
    ///   - key: The optional API key to authorize  the request.
    ///   - mapName: The map resource associated with the sprite ﬁle.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMapSprites(
        fileName: String,
        key: String? = nil,
        mapName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMapSpritesResponse {
        let input = GetMapSpritesRequest(
            fileName: fileName, 
            key: key, 
            mapName: mapName
        )
        return try await self.getMapSprites(input, logger: logger)
    }

    /// Retrieves the map style descriptor from a map resource.  The style descriptor contains speciﬁcations on how features render on a map. For example, what data to display, what order to display the data in, and the style for the data. Style descriptors follow the Mapbox Style Specification.
    @Sendable
    @inlinable
    public func getMapStyleDescriptor(_ input: GetMapStyleDescriptorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMapStyleDescriptorResponse {
        try await self.client.execute(
            operation: "GetMapStyleDescriptor", 
            path: "/maps/v0/maps/{MapName}/style-descriptor", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "maps.", 
            logger: logger
        )
    }
    /// Retrieves the map style descriptor from a map resource.  The style descriptor contains speciﬁcations on how features render on a map. For example, what data to display, what order to display the data in, and the style for the data. Style descriptors follow the Mapbox Style Specification.
    ///
    /// Parameters:
    ///   - key: The optional API key to authorize  the request.
    ///   - mapName: The map resource to retrieve the style descriptor from.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMapStyleDescriptor(
        key: String? = nil,
        mapName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMapStyleDescriptorResponse {
        let input = GetMapStyleDescriptorRequest(
            key: key, 
            mapName: mapName
        )
        return try await self.getMapStyleDescriptor(input, logger: logger)
    }

    /// Retrieves a vector data tile from the map resource. Map tiles are used by clients to render a map. they're addressed using a grid arrangement with an X coordinate, Y coordinate, and Z (zoom) level.  The origin (0, 0) is the top left of the map. Increasing the zoom level by 1 doubles both the X and Y dimensions, so a tile containing data for the entire world at (0/0/0) will be split into 4 tiles at zoom 1 (1/0/0, 1/0/1, 1/1/0, 1/1/1).
    @Sendable
    @inlinable
    public func getMapTile(_ input: GetMapTileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMapTileResponse {
        try await self.client.execute(
            operation: "GetMapTile", 
            path: "/maps/v0/maps/{MapName}/tiles/{Z}/{X}/{Y}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "maps.", 
            logger: logger
        )
    }
    /// Retrieves a vector data tile from the map resource. Map tiles are used by clients to render a map. they're addressed using a grid arrangement with an X coordinate, Y coordinate, and Z (zoom) level.  The origin (0, 0) is the top left of the map. Increasing the zoom level by 1 doubles both the X and Y dimensions, so a tile containing data for the entire world at (0/0/0) will be split into 4 tiles at zoom 1 (1/0/0, 1/0/1, 1/1/0, 1/1/1).
    ///
    /// Parameters:
    ///   - key: The optional API key to authorize  the request.
    ///   - mapName: The map resource to retrieve the map tiles from.
    ///   - x: The X axis value for the map tile.
    ///   - y: The Y axis value for the map tile.
    ///   - z: The zoom value for the map tile.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMapTile(
        key: String? = nil,
        mapName: String,
        x: String,
        y: String,
        z: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMapTileResponse {
        let input = GetMapTileRequest(
            key: key, 
            mapName: mapName, 
            x: x, 
            y: y, 
            z: z
        )
        return try await self.getMapTile(input, logger: logger)
    }

    /// Finds a place by its unique ID. A PlaceId is returned by other search operations.  A PlaceId is valid only if all of the following are the same in the original search request and the call to GetPlace.   Customer Amazon Web Services account   Amazon Web Services Region   Data provider specified in the place index resource
    @Sendable
    @inlinable
    public func getPlace(_ input: GetPlaceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPlaceResponse {
        try await self.client.execute(
            operation: "GetPlace", 
            path: "/places/v0/indexes/{IndexName}/places/{PlaceId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "places.", 
            logger: logger
        )
    }
    /// Finds a place by its unique ID. A PlaceId is returned by other search operations.  A PlaceId is valid only if all of the following are the same in the original search request and the call to GetPlace.   Customer Amazon Web Services account   Amazon Web Services Region   Data provider specified in the place index resource
    ///
    /// Parameters:
    ///   - indexName: The name of the place index resource that you want to use for the search.
    ///   - key: The optional API key to authorize  the request.
    ///   - language: The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    ///   - placeId: The identifier of the place to find.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPlace(
        indexName: String,
        key: String? = nil,
        language: String? = nil,
        placeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPlaceResponse {
        let input = GetPlaceRequest(
            indexName: indexName, 
            key: key, 
            language: language, 
            placeId: placeId
        )
        return try await self.getPlace(input, logger: logger)
    }

    /// A batch request to retrieve all device positions.
    @Sendable
    @inlinable
    public func listDevicePositions(_ input: ListDevicePositionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDevicePositionsResponse {
        try await self.client.execute(
            operation: "ListDevicePositions", 
            path: "/tracking/v0/trackers/{TrackerName}/list-positions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tracking.", 
            logger: logger
        )
    }
    /// A batch request to retrieve all device positions.
    ///
    /// Parameters:
    ///   - filterGeometry: The geometry used to filter device positions.
    ///   - maxResults: An optional limit for the number of entries returned in a single call. Default value: 100
    ///   - nextToken: The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    ///   - trackerName: The tracker resource containing the requested devices.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDevicePositions(
        filterGeometry: TrackingFilterGeometry? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDevicePositionsResponse {
        let input = ListDevicePositionsRequest(
            filterGeometry: filterGeometry, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            trackerName: trackerName
        )
        return try await self.listDevicePositions(input, logger: logger)
    }

    /// Lists geofence collections in your Amazon Web Services account.
    @Sendable
    @inlinable
    public func listGeofenceCollections(_ input: ListGeofenceCollectionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListGeofenceCollectionsResponse {
        try await self.client.execute(
            operation: "ListGeofenceCollections", 
            path: "/geofencing/v0/list-collections", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.geofencing.", 
            logger: logger
        )
    }
    /// Lists geofence collections in your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - maxResults: An optional limit for the number of resources returned in a single call.  Default value: 100
    ///   - nextToken: The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
    ///   - logger: Logger use during operation
    @inlinable
    public func listGeofenceCollections(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListGeofenceCollectionsResponse {
        let input = ListGeofenceCollectionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listGeofenceCollections(input, logger: logger)
    }

    /// Lists geofences stored in a given geofence collection.
    @Sendable
    @inlinable
    public func listGeofences(_ input: ListGeofencesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListGeofencesResponse {
        try await self.client.execute(
            operation: "ListGeofences", 
            path: "/geofencing/v0/collections/{CollectionName}/list-geofences", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "geofencing.", 
            logger: logger
        )
    }
    /// Lists geofences stored in a given geofence collection.
    ///
    /// Parameters:
    ///   - collectionName: The name of the geofence collection storing the list of geofences.
    ///   - maxResults: An optional limit for the number of geofences returned in a single call.  Default value: 100
    ///   - nextToken: The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
    ///   - logger: Logger use during operation
    @inlinable
    public func listGeofences(
        collectionName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListGeofencesResponse {
        let input = ListGeofencesRequest(
            collectionName: collectionName, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listGeofences(input, logger: logger)
    }

    /// Lists API key resources in your Amazon Web Services account.
    @Sendable
    @inlinable
    public func listKeys(_ input: ListKeysRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKeysResponse {
        try await self.client.execute(
            operation: "ListKeys", 
            path: "/metadata/v0/list-keys", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.metadata.", 
            logger: logger
        )
    }
    /// Lists API key resources in your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - filter: Optionally filter the list to only Active or Expired API keys.
    ///   - maxResults: An optional limit for the number of resources returned in a single call.  Default value: 100
    ///   - nextToken: The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
    ///   - logger: Logger use during operation
    @inlinable
    public func listKeys(
        filter: ApiKeyFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKeysResponse {
        let input = ListKeysRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKeys(input, logger: logger)
    }

    /// Lists map resources in your Amazon Web Services account.
    @Sendable
    @inlinable
    public func listMaps(_ input: ListMapsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMapsResponse {
        try await self.client.execute(
            operation: "ListMaps", 
            path: "/maps/v0/list-maps", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.maps.", 
            logger: logger
        )
    }
    /// Lists map resources in your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - maxResults: An optional limit for the number of resources returned in a single call.  Default value: 100
    ///   - nextToken: The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    ///   - logger: Logger use during operation
    @inlinable
    public func listMaps(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMapsResponse {
        let input = ListMapsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listMaps(input, logger: logger)
    }

    /// Lists place index resources in your Amazon Web Services account.
    @Sendable
    @inlinable
    public func listPlaceIndexes(_ input: ListPlaceIndexesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPlaceIndexesResponse {
        try await self.client.execute(
            operation: "ListPlaceIndexes", 
            path: "/places/v0/list-indexes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.places.", 
            logger: logger
        )
    }
    /// Lists place index resources in your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - maxResults: An optional limit for the maximum number of results returned in a single call. Default value: 100
    ///   - nextToken: The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
    ///   - logger: Logger use during operation
    @inlinable
    public func listPlaceIndexes(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPlaceIndexesResponse {
        let input = ListPlaceIndexesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listPlaceIndexes(input, logger: logger)
    }

    /// Lists route calculator resources in your Amazon Web Services account.
    @Sendable
    @inlinable
    public func listRouteCalculators(_ input: ListRouteCalculatorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRouteCalculatorsResponse {
        try await self.client.execute(
            operation: "ListRouteCalculators", 
            path: "/routes/v0/list-calculators", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.routes.", 
            logger: logger
        )
    }
    /// Lists route calculator resources in your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - maxResults: An optional maximum number of results returned in a single call. Default Value: 100
    ///   - nextToken: The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default Value: null
    ///   - logger: Logger use during operation
    @inlinable
    public func listRouteCalculators(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRouteCalculatorsResponse {
        let input = ListRouteCalculatorsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listRouteCalculators(input, logger: logger)
    }

    /// Returns a list of tags that are applied to the specified Amazon Location resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.metadata.", 
            logger: logger
        )
    }
    /// Returns a list of tags that are applied to the specified Amazon Location resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.   Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Lists geofence collections currently associated to the given tracker resource.
    @Sendable
    @inlinable
    public func listTrackerConsumers(_ input: ListTrackerConsumersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTrackerConsumersResponse {
        try await self.client.execute(
            operation: "ListTrackerConsumers", 
            path: "/tracking/v0/trackers/{TrackerName}/list-consumers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.tracking.", 
            logger: logger
        )
    }
    /// Lists geofence collections currently associated to the given tracker resource.
    ///
    /// Parameters:
    ///   - maxResults: An optional limit for the number of resources returned in a single call.  Default value: 100
    ///   - nextToken: The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
    ///   - trackerName: The tracker resource whose associated geofence collections you want to list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTrackerConsumers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTrackerConsumersResponse {
        let input = ListTrackerConsumersRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            trackerName: trackerName
        )
        return try await self.listTrackerConsumers(input, logger: logger)
    }

    /// Lists tracker resources in your Amazon Web Services account.
    @Sendable
    @inlinable
    public func listTrackers(_ input: ListTrackersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTrackersResponse {
        try await self.client.execute(
            operation: "ListTrackers", 
            path: "/tracking/v0/list-trackers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.tracking.", 
            logger: logger
        )
    }
    /// Lists tracker resources in your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - maxResults: An optional limit for the number of resources returned in a single call.  Default value: 100
    ///   - nextToken: The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
    ///   - logger: Logger use during operation
    @inlinable
    public func listTrackers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTrackersResponse {
        let input = ListTrackersRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listTrackers(input, logger: logger)
    }

    /// Stores a geofence geometry in a given geofence collection, or updates the geometry of an existing geofence if a geofence ID is included in the request.
    @Sendable
    @inlinable
    public func putGeofence(_ input: PutGeofenceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutGeofenceResponse {
        try await self.client.execute(
            operation: "PutGeofence", 
            path: "/geofencing/v0/collections/{CollectionName}/geofences/{GeofenceId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "geofencing.", 
            logger: logger
        )
    }
    /// Stores a geofence geometry in a given geofence collection, or updates the geometry of an existing geofence if a geofence ID is included in the request.
    ///
    /// Parameters:
    ///   - collectionName: The geofence collection to store the geofence in.
    ///   - geofenceId: An identifier for the geofence. For example, ExampleGeofence-1.
    ///   - geofenceProperties: Associates one of more properties with the geofence. A property is a key-value pair stored with the geofence and added to any geofence event triggered with that geofence. Format: "key" : "value"
    ///   - geometry: Contains the details to specify the position of the geofence. Can be a polygon, a circle or a polygon encoded in Geobuf format. Including multiple selections will return a validation error.  The  geofence polygon format supports a maximum of 1,000 vertices. The Geofence Geobuf format supports a maximum of 100,000 vertices.
    ///   - logger: Logger use during operation
    @inlinable
    public func putGeofence(
        collectionName: String,
        geofenceId: String,
        geofenceProperties: [String: String]? = nil,
        geometry: GeofenceGeometry,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutGeofenceResponse {
        let input = PutGeofenceRequest(
            collectionName: collectionName, 
            geofenceId: geofenceId, 
            geofenceProperties: geofenceProperties, 
            geometry: geometry
        )
        return try await self.putGeofence(input, logger: logger)
    }

    /// Reverse geocodes a given coordinate and returns a legible address. Allows you to search for Places or points of interest near a given position.
    @Sendable
    @inlinable
    public func searchPlaceIndexForPosition(_ input: SearchPlaceIndexForPositionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchPlaceIndexForPositionResponse {
        try await self.client.execute(
            operation: "SearchPlaceIndexForPosition", 
            path: "/places/v0/indexes/{IndexName}/search/position", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "places.", 
            logger: logger
        )
    }
    /// Reverse geocodes a given coordinate and returns a legible address. Allows you to search for Places or points of interest near a given position.
    ///
    /// Parameters:
    ///   - indexName: The name of the place index resource you want to use for the search.
    ///   - key: The optional API key to authorize  the request.
    ///   - language: The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for a location around Athens, Greece, with the language parameter set to en. The city in the results will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the city in the results will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    ///   - maxResults: An optional parameter. The maximum number of results returned per request. Default value: 50
    ///   - position: Specifies the longitude and latitude of the position to query. This parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents a position with longitude -123.1174 and latitude 49.2847.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchPlaceIndexForPosition(
        indexName: String,
        key: String? = nil,
        language: String? = nil,
        maxResults: Int? = nil,
        position: [Double],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchPlaceIndexForPositionResponse {
        let input = SearchPlaceIndexForPositionRequest(
            indexName: indexName, 
            key: key, 
            language: language, 
            maxResults: maxResults, 
            position: position
        )
        return try await self.searchPlaceIndexForPosition(input, logger: logger)
    }

    /// Generates suggestions for addresses and points of interest based on partial or misspelled free-form text. This operation is also known as autocomplete, autosuggest, or fuzzy matching. Optional parameters let you narrow your search results by bounding box or country, or bias your search toward a specific position on the globe.  You can search for suggested place names near a specified position by using BiasPosition, or filter results within a bounding box by using FilterBBox. These parameters are mutually exclusive; using both BiasPosition and FilterBBox in the same command returns an error.
    @Sendable
    @inlinable
    public func searchPlaceIndexForSuggestions(_ input: SearchPlaceIndexForSuggestionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchPlaceIndexForSuggestionsResponse {
        try await self.client.execute(
            operation: "SearchPlaceIndexForSuggestions", 
            path: "/places/v0/indexes/{IndexName}/search/suggestions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "places.", 
            logger: logger
        )
    }
    /// Generates suggestions for addresses and points of interest based on partial or misspelled free-form text. This operation is also known as autocomplete, autosuggest, or fuzzy matching. Optional parameters let you narrow your search results by bounding box or country, or bias your search toward a specific position on the globe.  You can search for suggested place names near a specified position by using BiasPosition, or filter results within a bounding box by using FilterBBox. These parameters are mutually exclusive; using both BiasPosition and FilterBBox in the same command returns an error.
    ///
    /// Parameters:
    ///   - biasPosition: An optional parameter that indicates a preference for place suggestions that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.   BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
    ///   - filterBBox: An optional parameter that limits the search results by returning only suggestions within a specified bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542.   FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
    ///   - filterCategories: A list of one or more Amazon Location categories to filter the returned places. If you  include more than one category, the results will include results that match  any of the categories listed. For more information about using categories, including a list of Amazon Location categories, see Categories and filtering, in the Amazon Location Service Developer  Guide.
    ///   - filterCountries: An optional parameter that limits the search results by returning only suggestions within the provided list of countries.   Use the ISO 3166 3-digit country code. For example, Australia uses three upper-case characters: AUS.
    ///   - indexName: The name of the place index resource you want to use for the search.
    ///   - key: The optional API key to authorize  the request.
    ///   - language: The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Gr to get suggestions with the language parameter set to en. The results found will most likely be returned as Athens, Greece. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα, Ελλάδα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    ///   - maxResults: An optional parameter. The maximum number of results returned per request.  The default: 5
    ///   - text: The free-form partial text to use to generate place suggestions. For example, eiffel tow.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchPlaceIndexForSuggestions(
        biasPosition: [Double]? = nil,
        filterBBox: [Double]? = nil,
        filterCategories: [String]? = nil,
        filterCountries: [String]? = nil,
        indexName: String,
        key: String? = nil,
        language: String? = nil,
        maxResults: Int? = nil,
        text: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchPlaceIndexForSuggestionsResponse {
        let input = SearchPlaceIndexForSuggestionsRequest(
            biasPosition: biasPosition, 
            filterBBox: filterBBox, 
            filterCategories: filterCategories, 
            filterCountries: filterCountries, 
            indexName: indexName, 
            key: key, 
            language: language, 
            maxResults: maxResults, 
            text: text
        )
        return try await self.searchPlaceIndexForSuggestions(input, logger: logger)
    }

    /// Geocodes free-form text, such as an address, name, city, or region to allow you to search for Places or points of interest.  Optional parameters let you narrow your search results by bounding box or country, or bias your search toward a specific position on the globe.  You can search for places near a given position using BiasPosition, or filter results within a bounding box using FilterBBox. Providing both parameters simultaneously returns an error.  Search results are returned in order of highest to lowest relevance.
    @Sendable
    @inlinable
    public func searchPlaceIndexForText(_ input: SearchPlaceIndexForTextRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchPlaceIndexForTextResponse {
        try await self.client.execute(
            operation: "SearchPlaceIndexForText", 
            path: "/places/v0/indexes/{IndexName}/search/text", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "places.", 
            logger: logger
        )
    }
    /// Geocodes free-form text, such as an address, name, city, or region to allow you to search for Places or points of interest.  Optional parameters let you narrow your search results by bounding box or country, or bias your search toward a specific position on the globe.  You can search for places near a given position using BiasPosition, or filter results within a bounding box using FilterBBox. Providing both parameters simultaneously returns an error.  Search results are returned in order of highest to lowest relevance.
    ///
    /// Parameters:
    ///   - biasPosition: An optional parameter that indicates a preference for places that are closer to a specified position. If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude. For example, [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.   BiasPosition and FilterBBox are mutually exclusive. Specifying both options results in an error.
    ///   - filterBBox: An optional parameter that limits the search results by returning only places that are within the provided bounding box. If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box. For example, [-12.7935, -37.4835, -12.0684, -36.9542] represents a bounding box where the southwest corner has longitude -12.7935 and latitude -37.4835, and the northeast corner has longitude -12.0684 and latitude -36.9542.   FilterBBox and BiasPosition are mutually exclusive. Specifying both options results in an error.
    ///   - filterCategories: A list of one or more Amazon Location categories to filter the returned places. If you  include more than one category, the results will include results that match  any of the categories listed. For more information about using categories, including a list of Amazon Location categories, see Categories and filtering, in the Amazon Location Service Developer  Guide.
    ///   - filterCountries: An optional parameter that limits the search results by returning only places that are in a specified list of countries.   Valid values include ISO 3166 3-digit country codes. For example, Australia uses three upper-case characters: AUS.
    ///   - indexName: The name of the place index resource you want to use for the search.
    ///   - key: The optional API key to authorize  the request.
    ///   - language: The preferred language used to return results. The value must be a valid BCP 47 language tag, for example, en for English. This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result. For an example, we'll use the Greek language. You search for Athens, Greece, with the language parameter set to en. The result found will most likely be returned as Athens. If you set the language parameter to el, for Greek, then the result found will more likely be returned as Αθήνα. If the data provider does not have a value for Greek, the result will be in a language that the provider does support.
    ///   - maxResults: An optional parameter. The maximum number of results returned per request.  The default: 50
    ///   - text: The address, name, city, or region to be used in the search in free-form text format. For example, 123 Any Street.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchPlaceIndexForText(
        biasPosition: [Double]? = nil,
        filterBBox: [Double]? = nil,
        filterCategories: [String]? = nil,
        filterCountries: [String]? = nil,
        indexName: String,
        key: String? = nil,
        language: String? = nil,
        maxResults: Int? = nil,
        text: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchPlaceIndexForTextResponse {
        let input = SearchPlaceIndexForTextRequest(
            biasPosition: biasPosition, 
            filterBBox: filterBBox, 
            filterCategories: filterCategories, 
            filterCountries: filterCountries, 
            indexName: indexName, 
            key: key, 
            language: language, 
            maxResults: maxResults, 
            text: text
        )
        return try await self.searchPlaceIndexForText(input, logger: logger)
    }

    /// Assigns one or more tags (key-value pairs) to the specified Amazon Location Service resource. Tags can help you organize and categorize your resources. You can also use them to scope user permissions, by granting a user permission to access or change only resources with certain tag values. You can use the TagResource operation with an Amazon Location Service resource that already has tags. If you specify a new tag key for the resource, this tag is appended to the tags already associated with the resource. If you specify a tag key that's already associated with the resource, the new tag value that you specify replaces the previous value for that tag.  You can associate up to 50 tags with a resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.metadata.", 
            logger: logger
        )
    }
    /// Assigns one or more tags (key-value pairs) to the specified Amazon Location Service resource. Tags can help you organize and categorize your resources. You can also use them to scope user permissions, by granting a user permission to access or change only resources with certain tag values. You can use the TagResource operation with an Amazon Location Service resource that already has tags. If you specify a new tag key for the resource, this tag is appended to the tags already associated with the resource. If you specify a tag key that's already associated with the resource, the new tag value that you specify replaces the previous value for that tag.  You can associate up to 50 tags with a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource whose tags you want to update.   Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    ///   - tags: Applies one or more tags to specific resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources. Format: "key" : "value"  Restrictions:   Maximum 50 tags per resource.   Each tag key must be unique and must have exactly one associated value.   Maximum key length: 128 Unicode characters in UTF-8.   Maximum value length: 256 Unicode characters in UTF-8.   Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @   Cannot use "aws:" as a prefix for a key.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes one or more tags from the specified Amazon Location resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{ResourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.metadata.", 
            logger: logger
        )
    }
    /// Removes one or more tags from the specified Amazon Location resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource from which you want to remove tags.   Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    ///   - tagKeys: The list of tag keys to remove from the specified resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates the specified properties of a given geofence collection.
    @Sendable
    @inlinable
    public func updateGeofenceCollection(_ input: UpdateGeofenceCollectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateGeofenceCollectionResponse {
        try await self.client.execute(
            operation: "UpdateGeofenceCollection", 
            path: "/geofencing/v0/collections/{CollectionName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.geofencing.", 
            logger: logger
        )
    }
    /// Updates the specified properties of a given geofence collection.
    ///
    /// Parameters:
    ///   - collectionName: The name of the geofence collection to update.
    ///   - description: Updates the description for the geofence collection.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateGeofenceCollection(
        collectionName: String,
        description: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateGeofenceCollectionResponse {
        let input = UpdateGeofenceCollectionRequest(
            collectionName: collectionName, 
            description: description
        )
        return try await self.updateGeofenceCollection(input, logger: logger)
    }

    /// Updates the specified properties of a given API key resource.
    @Sendable
    @inlinable
    public func updateKey(_ input: UpdateKeyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateKeyResponse {
        try await self.client.execute(
            operation: "UpdateKey", 
            path: "/metadata/v0/keys/{KeyName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.metadata.", 
            logger: logger
        )
    }
    /// Updates the specified properties of a given API key resource.
    ///
    /// Parameters:
    ///   - description: Updates the description for the API key resource.
    ///   - expireTime: Updates the timestamp for when the API key resource will expire in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///   - forceUpdate: The boolean flag to be included for updating ExpireTime or Restrictions details. Must be set to true to update an API key resource that has been used in the past 7 days.  False if force update is not preferred Default value: False
    ///   - keyName: The name of the API key resource to update.
    ///   - noExpiry: Whether the API key should expire. Set to true to set the API key to have no expiration time.
    ///   - restrictions: Updates the API key restrictions for the API key resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateKey(
        description: String? = nil,
        expireTime: Date? = nil,
        forceUpdate: Bool? = nil,
        keyName: String,
        noExpiry: Bool? = nil,
        restrictions: ApiKeyRestrictions? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateKeyResponse {
        let input = UpdateKeyRequest(
            description: description, 
            expireTime: expireTime, 
            forceUpdate: forceUpdate, 
            keyName: keyName, 
            noExpiry: noExpiry, 
            restrictions: restrictions
        )
        return try await self.updateKey(input, logger: logger)
    }

    /// Updates the specified properties of a given map resource.
    @Sendable
    @inlinable
    public func updateMap(_ input: UpdateMapRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateMapResponse {
        try await self.client.execute(
            operation: "UpdateMap", 
            path: "/maps/v0/maps/{MapName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.maps.", 
            logger: logger
        )
    }
    /// Updates the specified properties of a given map resource.
    ///
    /// Parameters:
    ///   - configurationUpdate: Updates the parts of the map configuration that can be updated, including the political view.
    ///   - description: Updates the description for the map resource.
    ///   - mapName: The name of the map resource to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateMap(
        configurationUpdate: MapConfigurationUpdate? = nil,
        description: String? = nil,
        mapName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateMapResponse {
        let input = UpdateMapRequest(
            configurationUpdate: configurationUpdate, 
            description: description, 
            mapName: mapName
        )
        return try await self.updateMap(input, logger: logger)
    }

    /// Updates the specified properties of a given place index resource.
    @Sendable
    @inlinable
    public func updatePlaceIndex(_ input: UpdatePlaceIndexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePlaceIndexResponse {
        try await self.client.execute(
            operation: "UpdatePlaceIndex", 
            path: "/places/v0/indexes/{IndexName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.places.", 
            logger: logger
        )
    }
    /// Updates the specified properties of a given place index resource.
    ///
    /// Parameters:
    ///   - dataSourceConfiguration: Updates the data storage option for the place index resource.
    ///   - description: Updates the description for the place index resource.
    ///   - indexName: The name of the place index resource to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePlaceIndex(
        dataSourceConfiguration: DataSourceConfiguration? = nil,
        description: String? = nil,
        indexName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePlaceIndexResponse {
        let input = UpdatePlaceIndexRequest(
            dataSourceConfiguration: dataSourceConfiguration, 
            description: description, 
            indexName: indexName
        )
        return try await self.updatePlaceIndex(input, logger: logger)
    }

    /// Updates the specified properties for a given route calculator resource.
    @Sendable
    @inlinable
    public func updateRouteCalculator(_ input: UpdateRouteCalculatorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateRouteCalculatorResponse {
        try await self.client.execute(
            operation: "UpdateRouteCalculator", 
            path: "/routes/v0/calculators/{CalculatorName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.routes.", 
            logger: logger
        )
    }
    /// Updates the specified properties for a given route calculator resource.
    ///
    /// Parameters:
    ///   - calculatorName: The name of the route calculator resource to update.
    ///   - description: Updates the description for the route calculator resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRouteCalculator(
        calculatorName: String,
        description: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateRouteCalculatorResponse {
        let input = UpdateRouteCalculatorRequest(
            calculatorName: calculatorName, 
            description: description
        )
        return try await self.updateRouteCalculator(input, logger: logger)
    }

    /// Updates the specified properties of a given tracker resource.
    @Sendable
    @inlinable
    public func updateTracker(_ input: UpdateTrackerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateTrackerResponse {
        try await self.client.execute(
            operation: "UpdateTracker", 
            path: "/tracking/v0/trackers/{TrackerName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "cp.tracking.", 
            logger: logger
        )
    }
    /// Updates the specified properties of a given tracker resource.
    ///
    /// Parameters:
    ///   - description: Updates the description for the tracker resource.
    ///   - eventBridgeEnabled: Whether to enable position UPDATE events from this tracker to be sent to  EventBridge.  You do not need enable this feature to get ENTER and  EXIT events for geofences with this tracker. Those events are always sent to EventBridge.
    ///   - kmsKeyEnableGeospatialQueries: Enables GeospatialQueries for a tracker that uses a Amazon Web Services KMS customer managed key. This parameter is only used if you are using a KMS customer managed key.
    ///   - positionFiltering: Updates the position filtering for the tracker resource. Valid values:    TimeBased - Location updates are evaluated against linked geofence collections,  but not every location update is stored. If your update frequency is more often than 30 seconds,  only one update per 30 seconds is stored for each unique device ID.     DistanceBased - If the device has moved less than 30 m (98.4 ft), location updates are  ignored. Location updates within this distance are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map.     AccuracyBased - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This helps educe the effects of GPS noise  when displaying device trajectories on a map, and can help control costs by reducing the number of geofence evaluations.
    ///   - trackerName: The name of the tracker resource to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateTracker(
        description: String? = nil,
        eventBridgeEnabled: Bool? = nil,
        kmsKeyEnableGeospatialQueries: Bool? = nil,
        positionFiltering: PositionFiltering? = nil,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateTrackerResponse {
        let input = UpdateTrackerRequest(
            description: description, 
            eventBridgeEnabled: eventBridgeEnabled, 
            kmsKeyEnableGeospatialQueries: kmsKeyEnableGeospatialQueries, 
            positionFiltering: positionFiltering, 
            trackerName: trackerName
        )
        return try await self.updateTracker(input, logger: logger)
    }

    /// Verifies the integrity of the device's position by determining if it was reported behind a proxy, and by comparing it to an inferred position estimated based on the device's state.
    @Sendable
    @inlinable
    public func verifyDevicePosition(_ input: VerifyDevicePositionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> VerifyDevicePositionResponse {
        try await self.client.execute(
            operation: "VerifyDevicePosition", 
            path: "/tracking/v0/trackers/{TrackerName}/positions/verify", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "tracking.", 
            logger: logger
        )
    }
    /// Verifies the integrity of the device's position by determining if it was reported behind a proxy, and by comparing it to an inferred position estimated based on the device's state.
    ///
    /// Parameters:
    ///   - deviceState: The device's state, including position, IP address, cell signals and Wi-Fi access points.
    ///   - distanceUnit: The distance unit for the verification request. Default Value: Kilometers
    ///   - trackerName: The name of the tracker resource to be associated with verification request.
    ///   - logger: Logger use during operation
    @inlinable
    public func verifyDevicePosition(
        deviceState: DeviceState,
        distanceUnit: DistanceUnit? = nil,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> VerifyDevicePositionResponse {
        let input = VerifyDevicePositionRequest(
            deviceState: deviceState, 
            distanceUnit: distanceUnit, 
            trackerName: trackerName
        )
        return try await self.verifyDevicePosition(input, logger: logger)
    }
}

extension Location {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Location, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Location {
    /// Return PaginatorSequence for operation ``forecastGeofenceEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func forecastGeofenceEventsPaginator(
        _ input: ForecastGeofenceEventsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ForecastGeofenceEventsRequest, ForecastGeofenceEventsResponse> {
        return .init(
            input: input,
            command: self.forecastGeofenceEvents,
            inputKey: \ForecastGeofenceEventsRequest.nextToken,
            outputKey: \ForecastGeofenceEventsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``forecastGeofenceEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - collectionName: The name of the geofence collection.
    ///   - deviceState: The device's state, including current position and speed.
    ///   - distanceUnit: The distance unit used for the NearestDistance property returned in a forecasted event. The measurement system must match for DistanceUnit and SpeedUnit; if Kilometers is specified for DistanceUnit, then SpeedUnit must be KilometersPerHour.  Default Value: Kilometers
    ///   - maxResults: An optional limit for the number of resources returned in a single call. Default value: 20
    ///   - speedUnit: The speed unit for the device captured by the device state. The measurement system must match for DistanceUnit and SpeedUnit; if Kilometers is specified for DistanceUnit, then SpeedUnit must be KilometersPerHour. Default Value: KilometersPerHour.
    ///   - timeHorizonMinutes: Specifies the time horizon in minutes for the forecasted events.
    ///   - logger: Logger used for logging
    @inlinable
    public func forecastGeofenceEventsPaginator(
        collectionName: String,
        deviceState: ForecastGeofenceEventsDeviceState,
        distanceUnit: DistanceUnit? = nil,
        maxResults: Int? = nil,
        speedUnit: SpeedUnit? = nil,
        timeHorizonMinutes: Double? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ForecastGeofenceEventsRequest, ForecastGeofenceEventsResponse> {
        let input = ForecastGeofenceEventsRequest(
            collectionName: collectionName, 
            deviceState: deviceState, 
            distanceUnit: distanceUnit, 
            maxResults: maxResults, 
            speedUnit: speedUnit, 
            timeHorizonMinutes: timeHorizonMinutes
        )
        return self.forecastGeofenceEventsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getDevicePositionHistory(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getDevicePositionHistoryPaginator(
        _ input: GetDevicePositionHistoryRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetDevicePositionHistoryRequest, GetDevicePositionHistoryResponse> {
        return .init(
            input: input,
            command: self.getDevicePositionHistory,
            inputKey: \GetDevicePositionHistoryRequest.nextToken,
            outputKey: \GetDevicePositionHistoryResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getDevicePositionHistory(_:logger:)``.
    ///
    /// - Parameters:
    ///   - deviceId: The device whose position history you want to retrieve.
    ///   - endTimeExclusive: Specify the end time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be the time that the request is made. Requirement:   The time specified for EndTimeExclusive must be after the time for StartTimeInclusive.
    ///   - maxResults: An optional limit for the number of device positions returned in a single call. Default value: 100
    ///   - startTimeInclusive: Specify the start time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be 24 hours prior to the time that the request is made. Requirement:   The time specified for StartTimeInclusive must be before EndTimeExclusive.
    ///   - trackerName: The tracker resource receiving the request for the device position history.
    ///   - logger: Logger used for logging
    @inlinable
    public func getDevicePositionHistoryPaginator(
        deviceId: String,
        endTimeExclusive: Date? = nil,
        maxResults: Int? = nil,
        startTimeInclusive: Date? = nil,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetDevicePositionHistoryRequest, GetDevicePositionHistoryResponse> {
        let input = GetDevicePositionHistoryRequest(
            deviceId: deviceId, 
            endTimeExclusive: endTimeExclusive, 
            maxResults: maxResults, 
            startTimeInclusive: startTimeInclusive, 
            trackerName: trackerName
        )
        return self.getDevicePositionHistoryPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDevicePositions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevicePositionsPaginator(
        _ input: ListDevicePositionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDevicePositionsRequest, ListDevicePositionsResponse> {
        return .init(
            input: input,
            command: self.listDevicePositions,
            inputKey: \ListDevicePositionsRequest.nextToken,
            outputKey: \ListDevicePositionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDevicePositions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filterGeometry: The geometry used to filter device positions.
    ///   - maxResults: An optional limit for the number of entries returned in a single call. Default value: 100
    ///   - trackerName: The tracker resource containing the requested devices.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevicePositionsPaginator(
        filterGeometry: TrackingFilterGeometry? = nil,
        maxResults: Int? = nil,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDevicePositionsRequest, ListDevicePositionsResponse> {
        let input = ListDevicePositionsRequest(
            filterGeometry: filterGeometry, 
            maxResults: maxResults, 
            trackerName: trackerName
        )
        return self.listDevicePositionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listGeofenceCollections(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listGeofenceCollectionsPaginator(
        _ input: ListGeofenceCollectionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListGeofenceCollectionsRequest, ListGeofenceCollectionsResponse> {
        return .init(
            input: input,
            command: self.listGeofenceCollections,
            inputKey: \ListGeofenceCollectionsRequest.nextToken,
            outputKey: \ListGeofenceCollectionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listGeofenceCollections(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: An optional limit for the number of resources returned in a single call.  Default value: 100
    ///   - logger: Logger used for logging
    @inlinable
    public func listGeofenceCollectionsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListGeofenceCollectionsRequest, ListGeofenceCollectionsResponse> {
        let input = ListGeofenceCollectionsRequest(
            maxResults: maxResults
        )
        return self.listGeofenceCollectionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listGeofences(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listGeofencesPaginator(
        _ input: ListGeofencesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListGeofencesRequest, ListGeofencesResponse> {
        return .init(
            input: input,
            command: self.listGeofences,
            inputKey: \ListGeofencesRequest.nextToken,
            outputKey: \ListGeofencesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listGeofences(_:logger:)``.
    ///
    /// - Parameters:
    ///   - collectionName: The name of the geofence collection storing the list of geofences.
    ///   - maxResults: An optional limit for the number of geofences returned in a single call.  Default value: 100
    ///   - logger: Logger used for logging
    @inlinable
    public func listGeofencesPaginator(
        collectionName: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListGeofencesRequest, ListGeofencesResponse> {
        let input = ListGeofencesRequest(
            collectionName: collectionName, 
            maxResults: maxResults
        )
        return self.listGeofencesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listKeys(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listKeysPaginator(
        _ input: ListKeysRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListKeysRequest, ListKeysResponse> {
        return .init(
            input: input,
            command: self.listKeys,
            inputKey: \ListKeysRequest.nextToken,
            outputKey: \ListKeysResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listKeys(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: Optionally filter the list to only Active or Expired API keys.
    ///   - maxResults: An optional limit for the number of resources returned in a single call.  Default value: 100
    ///   - logger: Logger used for logging
    @inlinable
    public func listKeysPaginator(
        filter: ApiKeyFilter? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListKeysRequest, ListKeysResponse> {
        let input = ListKeysRequest(
            filter: filter, 
            maxResults: maxResults
        )
        return self.listKeysPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMaps(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMapsPaginator(
        _ input: ListMapsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMapsRequest, ListMapsResponse> {
        return .init(
            input: input,
            command: self.listMaps,
            inputKey: \ListMapsRequest.nextToken,
            outputKey: \ListMapsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMaps(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: An optional limit for the number of resources returned in a single call.  Default value: 100
    ///   - logger: Logger used for logging
    @inlinable
    public func listMapsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMapsRequest, ListMapsResponse> {
        let input = ListMapsRequest(
            maxResults: maxResults
        )
        return self.listMapsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPlaceIndexes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPlaceIndexesPaginator(
        _ input: ListPlaceIndexesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPlaceIndexesRequest, ListPlaceIndexesResponse> {
        return .init(
            input: input,
            command: self.listPlaceIndexes,
            inputKey: \ListPlaceIndexesRequest.nextToken,
            outputKey: \ListPlaceIndexesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPlaceIndexes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: An optional limit for the maximum number of results returned in a single call. Default value: 100
    ///   - logger: Logger used for logging
    @inlinable
    public func listPlaceIndexesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPlaceIndexesRequest, ListPlaceIndexesResponse> {
        let input = ListPlaceIndexesRequest(
            maxResults: maxResults
        )
        return self.listPlaceIndexesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRouteCalculators(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRouteCalculatorsPaginator(
        _ input: ListRouteCalculatorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRouteCalculatorsRequest, ListRouteCalculatorsResponse> {
        return .init(
            input: input,
            command: self.listRouteCalculators,
            inputKey: \ListRouteCalculatorsRequest.nextToken,
            outputKey: \ListRouteCalculatorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRouteCalculators(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: An optional maximum number of results returned in a single call. Default Value: 100
    ///   - logger: Logger used for logging
    @inlinable
    public func listRouteCalculatorsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRouteCalculatorsRequest, ListRouteCalculatorsResponse> {
        let input = ListRouteCalculatorsRequest(
            maxResults: maxResults
        )
        return self.listRouteCalculatorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTrackerConsumers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTrackerConsumersPaginator(
        _ input: ListTrackerConsumersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTrackerConsumersRequest, ListTrackerConsumersResponse> {
        return .init(
            input: input,
            command: self.listTrackerConsumers,
            inputKey: \ListTrackerConsumersRequest.nextToken,
            outputKey: \ListTrackerConsumersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTrackerConsumers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: An optional limit for the number of resources returned in a single call.  Default value: 100
    ///   - trackerName: The tracker resource whose associated geofence collections you want to list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTrackerConsumersPaginator(
        maxResults: Int? = nil,
        trackerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTrackerConsumersRequest, ListTrackerConsumersResponse> {
        let input = ListTrackerConsumersRequest(
            maxResults: maxResults, 
            trackerName: trackerName
        )
        return self.listTrackerConsumersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTrackers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTrackersPaginator(
        _ input: ListTrackersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTrackersRequest, ListTrackersResponse> {
        return .init(
            input: input,
            command: self.listTrackers,
            inputKey: \ListTrackersRequest.nextToken,
            outputKey: \ListTrackersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTrackers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: An optional limit for the number of resources returned in a single call.  Default value: 100
    ///   - logger: Logger used for logging
    @inlinable
    public func listTrackersPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTrackersRequest, ListTrackersResponse> {
        let input = ListTrackersRequest(
            maxResults: maxResults
        )
        return self.listTrackersPaginator(input, logger: logger)
    }
}

extension Location.ForecastGeofenceEventsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Location.ForecastGeofenceEventsRequest {
        return .init(
            collectionName: self.collectionName,
            deviceState: self.deviceState,
            distanceUnit: self.distanceUnit,
            maxResults: self.maxResults,
            nextToken: token,
            speedUnit: self.speedUnit,
            timeHorizonMinutes: self.timeHorizonMinutes
        )
    }
}

extension Location.GetDevicePositionHistoryRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Location.GetDevicePositionHistoryRequest {
        return .init(
            deviceId: self.deviceId,
            endTimeExclusive: self.endTimeExclusive,
            maxResults: self.maxResults,
            nextToken: token,
            startTimeInclusive: self.startTimeInclusive,
            trackerName: self.trackerName
        )
    }
}

extension Location.ListDevicePositionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Location.ListDevicePositionsRequest {
        return .init(
            filterGeometry: self.filterGeometry,
            maxResults: self.maxResults,
            nextToken: token,
            trackerName: self.trackerName
        )
    }
}

extension Location.ListGeofenceCollectionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Location.ListGeofenceCollectionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Location.ListGeofencesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Location.ListGeofencesRequest {
        return .init(
            collectionName: self.collectionName,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Location.ListKeysRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Location.ListKeysRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Location.ListMapsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Location.ListMapsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Location.ListPlaceIndexesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Location.ListPlaceIndexesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Location.ListRouteCalculatorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Location.ListRouteCalculatorsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Location.ListTrackerConsumersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Location.ListTrackerConsumersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            trackerName: self.trackerName
        )
    }
}

extension Location.ListTrackersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Location.ListTrackersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
