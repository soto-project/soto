//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension SSM {
    ///  Describes details about the activation, such as the date and time the activation was created, its expiration date, the Identity and Access Management (IAM) role assigned to the instances in the activation, and the number of instances registered by using this activation.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeActivationsPaginator<Result>(
        _ input: DescribeActivationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeActivationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeActivations,
            inputKey: \DescribeActivationsRequest.nextToken,
            outputKey: \DescribeActivationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeActivationsPaginator(
        _ input: DescribeActivationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeActivationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeActivations,
            inputKey: \DescribeActivationsRequest.nextToken,
            outputKey: \DescribeActivationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Views information about a specific execution of a specific association.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeAssociationExecutionTargetsPaginator<Result>(
        _ input: DescribeAssociationExecutionTargetsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeAssociationExecutionTargetsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeAssociationExecutionTargets,
            inputKey: \DescribeAssociationExecutionTargetsRequest.nextToken,
            outputKey: \DescribeAssociationExecutionTargetsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeAssociationExecutionTargetsPaginator(
        _ input: DescribeAssociationExecutionTargetsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeAssociationExecutionTargetsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeAssociationExecutionTargets,
            inputKey: \DescribeAssociationExecutionTargetsRequest.nextToken,
            outputKey: \DescribeAssociationExecutionTargetsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Views all executions for a specific association ID.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeAssociationExecutionsPaginator<Result>(
        _ input: DescribeAssociationExecutionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeAssociationExecutionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeAssociationExecutions,
            inputKey: \DescribeAssociationExecutionsRequest.nextToken,
            outputKey: \DescribeAssociationExecutionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeAssociationExecutionsPaginator(
        _ input: DescribeAssociationExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeAssociationExecutionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeAssociationExecutions,
            inputKey: \DescribeAssociationExecutionsRequest.nextToken,
            outputKey: \DescribeAssociationExecutionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Provides details about all active and terminated Automation executions.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeAutomationExecutionsPaginator<Result>(
        _ input: DescribeAutomationExecutionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeAutomationExecutionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeAutomationExecutions,
            inputKey: \DescribeAutomationExecutionsRequest.nextToken,
            outputKey: \DescribeAutomationExecutionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeAutomationExecutionsPaginator(
        _ input: DescribeAutomationExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeAutomationExecutionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeAutomationExecutions,
            inputKey: \DescribeAutomationExecutionsRequest.nextToken,
            outputKey: \DescribeAutomationExecutionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Information about all active and terminated step executions in an Automation workflow.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeAutomationStepExecutionsPaginator<Result>(
        _ input: DescribeAutomationStepExecutionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeAutomationStepExecutionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeAutomationStepExecutions,
            inputKey: \DescribeAutomationStepExecutionsRequest.nextToken,
            outputKey: \DescribeAutomationStepExecutionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeAutomationStepExecutionsPaginator(
        _ input: DescribeAutomationStepExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeAutomationStepExecutionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeAutomationStepExecutions,
            inputKey: \DescribeAutomationStepExecutionsRequest.nextToken,
            outputKey: \DescribeAutomationStepExecutionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all patches eligible to be included in a patch baseline.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeAvailablePatchesPaginator<Result>(
        _ input: DescribeAvailablePatchesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeAvailablePatchesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeAvailablePatches,
            inputKey: \DescribeAvailablePatchesRequest.nextToken,
            outputKey: \DescribeAvailablePatchesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeAvailablePatchesPaginator(
        _ input: DescribeAvailablePatchesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeAvailablePatchesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeAvailablePatches,
            inputKey: \DescribeAvailablePatchesRequest.nextToken,
            outputKey: \DescribeAvailablePatchesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  All associations for the instance(s).
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEffectiveInstanceAssociationsPaginator<Result>(
        _ input: DescribeEffectiveInstanceAssociationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeEffectiveInstanceAssociationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEffectiveInstanceAssociations,
            inputKey: \DescribeEffectiveInstanceAssociationsRequest.nextToken,
            outputKey: \DescribeEffectiveInstanceAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEffectiveInstanceAssociationsPaginator(
        _ input: DescribeEffectiveInstanceAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeEffectiveInstanceAssociationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEffectiveInstanceAssociations,
            inputKey: \DescribeEffectiveInstanceAssociationsRequest.nextToken,
            outputKey: \DescribeEffectiveInstanceAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves the current effective patches (the patch and the approval state) for the specified patch baseline. Applies to patch baselines for Windows only.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEffectivePatchesForPatchBaselinePaginator<Result>(
        _ input: DescribeEffectivePatchesForPatchBaselineRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeEffectivePatchesForPatchBaselineResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEffectivePatchesForPatchBaseline,
            inputKey: \DescribeEffectivePatchesForPatchBaselineRequest.nextToken,
            outputKey: \DescribeEffectivePatchesForPatchBaselineResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEffectivePatchesForPatchBaselinePaginator(
        _ input: DescribeEffectivePatchesForPatchBaselineRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeEffectivePatchesForPatchBaselineResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEffectivePatchesForPatchBaseline,
            inputKey: \DescribeEffectivePatchesForPatchBaselineRequest.nextToken,
            outputKey: \DescribeEffectivePatchesForPatchBaselineResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  The status of the associations for the instance(s).
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstanceAssociationsStatusPaginator<Result>(
        _ input: DescribeInstanceAssociationsStatusRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInstanceAssociationsStatusResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstanceAssociationsStatus,
            inputKey: \DescribeInstanceAssociationsStatusRequest.nextToken,
            outputKey: \DescribeInstanceAssociationsStatusResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstanceAssociationsStatusPaginator(
        _ input: DescribeInstanceAssociationsStatusRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInstanceAssociationsStatusResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstanceAssociationsStatus,
            inputKey: \DescribeInstanceAssociationsStatusRequest.nextToken,
            outputKey: \DescribeInstanceAssociationsStatusResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes one or more of your instances, including information about the operating system platform, the version of SSM Agent installed on the instance, instance status, and so on. If you specify one or more instance IDs, it returns information for those instances. If you don't specify instance IDs, it returns information for all your instances. If you specify an instance ID that isn't valid or an instance that you don't own, you receive an error.  The IamRole field for this API operation is the Identity and Access Management (IAM) role assigned to on-premises instances. This call doesn't return the IAM role for EC2 instances.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstanceInformationPaginator<Result>(
        _ input: DescribeInstanceInformationRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInstanceInformationResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstanceInformation,
            inputKey: \DescribeInstanceInformationRequest.nextToken,
            outputKey: \DescribeInstanceInformationResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstanceInformationPaginator(
        _ input: DescribeInstanceInformationRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInstanceInformationResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstanceInformation,
            inputKey: \DescribeInstanceInformationRequest.nextToken,
            outputKey: \DescribeInstanceInformationResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves the high-level patch state of one or more instances.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstancePatchStatesPaginator<Result>(
        _ input: DescribeInstancePatchStatesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInstancePatchStatesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstancePatchStates,
            inputKey: \DescribeInstancePatchStatesRequest.nextToken,
            outputKey: \DescribeInstancePatchStatesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstancePatchStatesPaginator(
        _ input: DescribeInstancePatchStatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInstancePatchStatesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstancePatchStates,
            inputKey: \DescribeInstancePatchStatesRequest.nextToken,
            outputKey: \DescribeInstancePatchStatesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves the high-level patch state for the instances in the specified patch group.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstancePatchStatesForPatchGroupPaginator<Result>(
        _ input: DescribeInstancePatchStatesForPatchGroupRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInstancePatchStatesForPatchGroupResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstancePatchStatesForPatchGroup,
            inputKey: \DescribeInstancePatchStatesForPatchGroupRequest.nextToken,
            outputKey: \DescribeInstancePatchStatesForPatchGroupResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstancePatchStatesForPatchGroupPaginator(
        _ input: DescribeInstancePatchStatesForPatchGroupRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInstancePatchStatesForPatchGroupResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstancePatchStatesForPatchGroup,
            inputKey: \DescribeInstancePatchStatesForPatchGroupRequest.nextToken,
            outputKey: \DescribeInstancePatchStatesForPatchGroupResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves information about the patches on the specified instance and their state relative to the patch baseline being used for the instance.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInstancePatchesPaginator<Result>(
        _ input: DescribeInstancePatchesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInstancePatchesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInstancePatches,
            inputKey: \DescribeInstancePatchesRequest.nextToken,
            outputKey: \DescribeInstancePatchesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInstancePatchesPaginator(
        _ input: DescribeInstancePatchesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInstancePatchesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInstancePatches,
            inputKey: \DescribeInstancePatchesRequest.nextToken,
            outputKey: \DescribeInstancePatchesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes a specific delete inventory operation.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeInventoryDeletionsPaginator<Result>(
        _ input: DescribeInventoryDeletionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeInventoryDeletionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeInventoryDeletions,
            inputKey: \DescribeInventoryDeletionsRequest.nextToken,
            outputKey: \DescribeInventoryDeletionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeInventoryDeletionsPaginator(
        _ input: DescribeInventoryDeletionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeInventoryDeletionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeInventoryDeletions,
            inputKey: \DescribeInventoryDeletionsRequest.nextToken,
            outputKey: \DescribeInventoryDeletionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves the individual task executions (one per target) for a particular task run as part of a maintenance window execution.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeMaintenanceWindowExecutionTaskInvocationsPaginator<Result>(
        _ input: DescribeMaintenanceWindowExecutionTaskInvocationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeMaintenanceWindowExecutionTaskInvocationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeMaintenanceWindowExecutionTaskInvocations,
            inputKey: \DescribeMaintenanceWindowExecutionTaskInvocationsRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowExecutionTaskInvocationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeMaintenanceWindowExecutionTaskInvocationsPaginator(
        _ input: DescribeMaintenanceWindowExecutionTaskInvocationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeMaintenanceWindowExecutionTaskInvocationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeMaintenanceWindowExecutionTaskInvocations,
            inputKey: \DescribeMaintenanceWindowExecutionTaskInvocationsRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowExecutionTaskInvocationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  For a given maintenance window execution, lists the tasks that were run.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeMaintenanceWindowExecutionTasksPaginator<Result>(
        _ input: DescribeMaintenanceWindowExecutionTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeMaintenanceWindowExecutionTasksResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeMaintenanceWindowExecutionTasks,
            inputKey: \DescribeMaintenanceWindowExecutionTasksRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowExecutionTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeMaintenanceWindowExecutionTasksPaginator(
        _ input: DescribeMaintenanceWindowExecutionTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeMaintenanceWindowExecutionTasksResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeMaintenanceWindowExecutionTasks,
            inputKey: \DescribeMaintenanceWindowExecutionTasksRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowExecutionTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the executions of a maintenance window. This includes information about when the maintenance window was scheduled to be active, and information about tasks registered and run with the maintenance window.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeMaintenanceWindowExecutionsPaginator<Result>(
        _ input: DescribeMaintenanceWindowExecutionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeMaintenanceWindowExecutionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeMaintenanceWindowExecutions,
            inputKey: \DescribeMaintenanceWindowExecutionsRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowExecutionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeMaintenanceWindowExecutionsPaginator(
        _ input: DescribeMaintenanceWindowExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeMaintenanceWindowExecutionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeMaintenanceWindowExecutions,
            inputKey: \DescribeMaintenanceWindowExecutionsRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowExecutionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves information about upcoming executions of a maintenance window.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeMaintenanceWindowSchedulePaginator<Result>(
        _ input: DescribeMaintenanceWindowScheduleRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeMaintenanceWindowScheduleResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeMaintenanceWindowSchedule,
            inputKey: \DescribeMaintenanceWindowScheduleRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowScheduleResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeMaintenanceWindowSchedulePaginator(
        _ input: DescribeMaintenanceWindowScheduleRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeMaintenanceWindowScheduleResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeMaintenanceWindowSchedule,
            inputKey: \DescribeMaintenanceWindowScheduleRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowScheduleResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the targets registered with the maintenance window.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeMaintenanceWindowTargetsPaginator<Result>(
        _ input: DescribeMaintenanceWindowTargetsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeMaintenanceWindowTargetsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeMaintenanceWindowTargets,
            inputKey: \DescribeMaintenanceWindowTargetsRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowTargetsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeMaintenanceWindowTargetsPaginator(
        _ input: DescribeMaintenanceWindowTargetsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeMaintenanceWindowTargetsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeMaintenanceWindowTargets,
            inputKey: \DescribeMaintenanceWindowTargetsRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowTargetsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the tasks in a maintenance window.  For maintenance window tasks without a specified target, you can't supply values for --max-errors and --max-concurrency. Instead, the system inserts a placeholder value of 1, which may be reported in the response to this command. These values don't affect the running of your task and can be ignored.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeMaintenanceWindowTasksPaginator<Result>(
        _ input: DescribeMaintenanceWindowTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeMaintenanceWindowTasksResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeMaintenanceWindowTasks,
            inputKey: \DescribeMaintenanceWindowTasksRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeMaintenanceWindowTasksPaginator(
        _ input: DescribeMaintenanceWindowTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeMaintenanceWindowTasksResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeMaintenanceWindowTasks,
            inputKey: \DescribeMaintenanceWindowTasksRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowTasksResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves the maintenance windows in an account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeMaintenanceWindowsPaginator<Result>(
        _ input: DescribeMaintenanceWindowsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeMaintenanceWindowsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeMaintenanceWindows,
            inputKey: \DescribeMaintenanceWindowsRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeMaintenanceWindowsPaginator(
        _ input: DescribeMaintenanceWindowsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeMaintenanceWindowsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeMaintenanceWindows,
            inputKey: \DescribeMaintenanceWindowsRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves information about the maintenance window targets or tasks that an instance is associated with.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeMaintenanceWindowsForTargetPaginator<Result>(
        _ input: DescribeMaintenanceWindowsForTargetRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeMaintenanceWindowsForTargetResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeMaintenanceWindowsForTarget,
            inputKey: \DescribeMaintenanceWindowsForTargetRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowsForTargetResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeMaintenanceWindowsForTargetPaginator(
        _ input: DescribeMaintenanceWindowsForTargetRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeMaintenanceWindowsForTargetResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeMaintenanceWindowsForTarget,
            inputKey: \DescribeMaintenanceWindowsForTargetRequest.nextToken,
            outputKey: \DescribeMaintenanceWindowsForTargetResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Query a set of OpsItems. You must have permission in Identity and Access Management (IAM) to query a list of OpsItems. For more information, see Getting started with OpsCenter in the Amazon Web Services Systems Manager User Guide. Operations engineers and IT professionals use Amazon Web Services Systems Manager OpsCenter to view, investigate, and remediate operational issues impacting the performance and health of their Amazon Web Services resources. For more information, see OpsCenter in the Amazon Web Services Systems Manager User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeOpsItemsPaginator<Result>(
        _ input: DescribeOpsItemsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeOpsItemsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeOpsItems,
            inputKey: \DescribeOpsItemsRequest.nextToken,
            outputKey: \DescribeOpsItemsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeOpsItemsPaginator(
        _ input: DescribeOpsItemsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeOpsItemsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeOpsItems,
            inputKey: \DescribeOpsItemsRequest.nextToken,
            outputKey: \DescribeOpsItemsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Get information about a parameter. Request results are returned on a best-effort basis. If you specify MaxResults in the request, the response includes information up to the limit specified. The number of items returned, however, can be between zero and the value of MaxResults. If the service reaches an internal limit while processing the results, it stops the operation and returns the matching values up to that point and a NextToken. You can specify the NextToken in a subsequent call to get the next set of results.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeParametersPaginator<Result>(
        _ input: DescribeParametersRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeParametersResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeParameters,
            inputKey: \DescribeParametersRequest.nextToken,
            outputKey: \DescribeParametersResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeParametersPaginator(
        _ input: DescribeParametersRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeParametersResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeParameters,
            inputKey: \DescribeParametersRequest.nextToken,
            outputKey: \DescribeParametersResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the patch baselines in your account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describePatchBaselinesPaginator<Result>(
        _ input: DescribePatchBaselinesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribePatchBaselinesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describePatchBaselines,
            inputKey: \DescribePatchBaselinesRequest.nextToken,
            outputKey: \DescribePatchBaselinesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describePatchBaselinesPaginator(
        _ input: DescribePatchBaselinesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribePatchBaselinesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describePatchBaselines,
            inputKey: \DescribePatchBaselinesRequest.nextToken,
            outputKey: \DescribePatchBaselinesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all patch groups that have been registered with patch baselines.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describePatchGroupsPaginator<Result>(
        _ input: DescribePatchGroupsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribePatchGroupsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describePatchGroups,
            inputKey: \DescribePatchGroupsRequest.nextToken,
            outputKey: \DescribePatchGroupsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describePatchGroupsPaginator(
        _ input: DescribePatchGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribePatchGroupsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describePatchGroups,
            inputKey: \DescribePatchGroupsRequest.nextToken,
            outputKey: \DescribePatchGroupsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the properties of available patches organized by product, product family, classification, severity, and other properties of available patches. You can use the reported properties in the filters you specify in requests for operations such as CreatePatchBaseline, UpdatePatchBaseline, DescribeAvailablePatches, and DescribePatchBaselines. The following section lists the properties that can be used in filters for each major operating system type:  AMAZON_LINUX  Valid properties: PRODUCT | CLASSIFICATION | SEVERITY   AMAZON_LINUX_2  Valid properties: PRODUCT | CLASSIFICATION | SEVERITY   CENTOS  Valid properties: PRODUCT | CLASSIFICATION | SEVERITY   DEBIAN  Valid properties: PRODUCT | PRIORITY   MACOS  Valid properties: PRODUCT | CLASSIFICATION   ORACLE_LINUX  Valid properties: PRODUCT | CLASSIFICATION | SEVERITY   REDHAT_ENTERPRISE_LINUX  Valid properties: PRODUCT | CLASSIFICATION | SEVERITY   SUSE  Valid properties: PRODUCT | CLASSIFICATION | SEVERITY   UBUNTU  Valid properties: PRODUCT | PRIORITY   WINDOWS  Valid properties: PRODUCT | PRODUCT_FAMILY | CLASSIFICATION | MSRC_SEVERITY
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describePatchPropertiesPaginator<Result>(
        _ input: DescribePatchPropertiesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribePatchPropertiesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describePatchProperties,
            inputKey: \DescribePatchPropertiesRequest.nextToken,
            outputKey: \DescribePatchPropertiesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describePatchPropertiesPaginator(
        _ input: DescribePatchPropertiesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribePatchPropertiesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describePatchProperties,
            inputKey: \DescribePatchPropertiesRequest.nextToken,
            outputKey: \DescribePatchPropertiesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves a list of all active sessions (both connected and disconnected) or terminated sessions from the past 30 days.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSessionsPaginator<Result>(
        _ input: DescribeSessionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeSessionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSessions,
            inputKey: \DescribeSessionsRequest.nextToken,
            outputKey: \DescribeSessionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSessionsPaginator(
        _ input: DescribeSessionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeSessionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSessions,
            inputKey: \DescribeSessionsRequest.nextToken,
            outputKey: \DescribeSessionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Query inventory information.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getInventoryPaginator<Result>(
        _ input: GetInventoryRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetInventoryResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getInventory,
            inputKey: \GetInventoryRequest.nextToken,
            outputKey: \GetInventoryResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getInventoryPaginator(
        _ input: GetInventoryRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetInventoryResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getInventory,
            inputKey: \GetInventoryRequest.nextToken,
            outputKey: \GetInventoryResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Return a list of inventory type names for the account, or return a list of attribute names for a specific Inventory item type.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getInventorySchemaPaginator<Result>(
        _ input: GetInventorySchemaRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetInventorySchemaResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getInventorySchema,
            inputKey: \GetInventorySchemaRequest.nextToken,
            outputKey: \GetInventorySchemaResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getInventorySchemaPaginator(
        _ input: GetInventorySchemaRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetInventorySchemaResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getInventorySchema,
            inputKey: \GetInventorySchemaRequest.nextToken,
            outputKey: \GetInventorySchemaResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  View a summary of operations metadata (OpsData) based on specified filters and aggregators. OpsData can include information about Amazon Web Services Systems Manager OpsCenter operational workitems (OpsItems) as well as information about any Amazon Web Services resource or service configured to report OpsData to Amazon Web Services Systems Manager Explorer.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getOpsSummaryPaginator<Result>(
        _ input: GetOpsSummaryRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetOpsSummaryResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getOpsSummary,
            inputKey: \GetOpsSummaryRequest.nextToken,
            outputKey: \GetOpsSummaryResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getOpsSummaryPaginator(
        _ input: GetOpsSummaryRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetOpsSummaryResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getOpsSummary,
            inputKey: \GetOpsSummaryRequest.nextToken,
            outputKey: \GetOpsSummaryResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves the history of all changes to a parameter.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getParameterHistoryPaginator<Result>(
        _ input: GetParameterHistoryRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetParameterHistoryResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getParameterHistory,
            inputKey: \GetParameterHistoryRequest.nextToken,
            outputKey: \GetParameterHistoryResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getParameterHistoryPaginator(
        _ input: GetParameterHistoryRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetParameterHistoryResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getParameterHistory,
            inputKey: \GetParameterHistoryRequest.nextToken,
            outputKey: \GetParameterHistoryResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieve information about one or more parameters in a specific hierarchy.  Request results are returned on a best-effort basis. If you specify MaxResults in the request, the response includes information up to the limit specified. The number of items returned, however, can be between zero and the value of MaxResults. If the service reaches an internal limit while processing the results, it stops the operation and returns the matching values up to that point and a NextToken. You can specify the NextToken in a subsequent call to get the next set of results.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getParametersByPathPaginator<Result>(
        _ input: GetParametersByPathRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetParametersByPathResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getParametersByPath,
            inputKey: \GetParametersByPathRequest.nextToken,
            outputKey: \GetParametersByPathResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getParametersByPathPaginator(
        _ input: GetParametersByPathRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetParametersByPathResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getParametersByPath,
            inputKey: \GetParametersByPathRequest.nextToken,
            outputKey: \GetParametersByPathResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Retrieves all versions of an association for a specific association ID.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAssociationVersionsPaginator<Result>(
        _ input: ListAssociationVersionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAssociationVersionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAssociationVersions,
            inputKey: \ListAssociationVersionsRequest.nextToken,
            outputKey: \ListAssociationVersionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAssociationVersionsPaginator(
        _ input: ListAssociationVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAssociationVersionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAssociationVersions,
            inputKey: \ListAssociationVersionsRequest.nextToken,
            outputKey: \ListAssociationVersionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns all State Manager associations in the current account and Region. You can limit the results to a specific State Manager association document or instance by specifying a filter. State Manager is a capability of Amazon Web Services Systems Manager.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAssociationsPaginator<Result>(
        _ input: ListAssociationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAssociationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAssociations,
            inputKey: \ListAssociationsRequest.nextToken,
            outputKey: \ListAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAssociationsPaginator(
        _ input: ListAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAssociationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAssociations,
            inputKey: \ListAssociationsRequest.nextToken,
            outputKey: \ListAssociationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  An invocation is copy of a command sent to a specific instance. A command can apply to one or more instances. A command invocation applies to one instance. For example, if a user runs SendCommand against three instances, then a command invocation is created for each requested instance ID. ListCommandInvocations provide status about command execution.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listCommandInvocationsPaginator<Result>(
        _ input: ListCommandInvocationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListCommandInvocationsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listCommandInvocations,
            inputKey: \ListCommandInvocationsRequest.nextToken,
            outputKey: \ListCommandInvocationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listCommandInvocationsPaginator(
        _ input: ListCommandInvocationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListCommandInvocationsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listCommandInvocations,
            inputKey: \ListCommandInvocationsRequest.nextToken,
            outputKey: \ListCommandInvocationsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the commands requested by users of the account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listCommandsPaginator<Result>(
        _ input: ListCommandsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListCommandsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listCommands,
            inputKey: \ListCommandsRequest.nextToken,
            outputKey: \ListCommandsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listCommandsPaginator(
        _ input: ListCommandsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListCommandsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listCommands,
            inputKey: \ListCommandsRequest.nextToken,
            outputKey: \ListCommandsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  For a specified resource ID, this API operation returns a list of compliance statuses for different resource types. Currently, you can only specify one resource ID per call. List results depend on the criteria specified in the filter.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listComplianceItemsPaginator<Result>(
        _ input: ListComplianceItemsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListComplianceItemsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listComplianceItems,
            inputKey: \ListComplianceItemsRequest.nextToken,
            outputKey: \ListComplianceItemsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listComplianceItemsPaginator(
        _ input: ListComplianceItemsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListComplianceItemsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listComplianceItems,
            inputKey: \ListComplianceItemsRequest.nextToken,
            outputKey: \ListComplianceItemsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a summary count of compliant and non-compliant resources for a compliance type. For example, this call can return State Manager associations, patches, or custom compliance types according to the filter criteria that you specify.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listComplianceSummariesPaginator<Result>(
        _ input: ListComplianceSummariesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListComplianceSummariesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listComplianceSummaries,
            inputKey: \ListComplianceSummariesRequest.nextToken,
            outputKey: \ListComplianceSummariesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listComplianceSummariesPaginator(
        _ input: ListComplianceSummariesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListComplianceSummariesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listComplianceSummaries,
            inputKey: \ListComplianceSummariesRequest.nextToken,
            outputKey: \ListComplianceSummariesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List all versions for a document.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDocumentVersionsPaginator<Result>(
        _ input: ListDocumentVersionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDocumentVersionsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listDocumentVersions,
            inputKey: \ListDocumentVersionsRequest.nextToken,
            outputKey: \ListDocumentVersionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDocumentVersionsPaginator(
        _ input: ListDocumentVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDocumentVersionsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listDocumentVersions,
            inputKey: \ListDocumentVersionsRequest.nextToken,
            outputKey: \ListDocumentVersionsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns all Systems Manager (SSM) documents in the current account and Region. You can limit the results of this request by using a filter.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDocumentsPaginator<Result>(
        _ input: ListDocumentsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDocumentsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listDocuments,
            inputKey: \ListDocumentsRequest.nextToken,
            outputKey: \ListDocumentsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDocumentsPaginator(
        _ input: ListDocumentsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDocumentsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listDocuments,
            inputKey: \ListDocumentsRequest.nextToken,
            outputKey: \ListDocumentsResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of all OpsItem events in the current Region and account. You can limit the results to events associated with specific OpsItems by specifying a filter.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listOpsItemEventsPaginator<Result>(
        _ input: ListOpsItemEventsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListOpsItemEventsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listOpsItemEvents,
            inputKey: \ListOpsItemEventsRequest.nextToken,
            outputKey: \ListOpsItemEventsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listOpsItemEventsPaginator(
        _ input: ListOpsItemEventsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListOpsItemEventsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listOpsItemEvents,
            inputKey: \ListOpsItemEventsRequest.nextToken,
            outputKey: \ListOpsItemEventsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all related-item resources associated with an OpsItem.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listOpsItemRelatedItemsPaginator<Result>(
        _ input: ListOpsItemRelatedItemsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListOpsItemRelatedItemsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listOpsItemRelatedItems,
            inputKey: \ListOpsItemRelatedItemsRequest.nextToken,
            outputKey: \ListOpsItemRelatedItemsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listOpsItemRelatedItemsPaginator(
        _ input: ListOpsItemRelatedItemsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListOpsItemRelatedItemsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listOpsItemRelatedItems,
            inputKey: \ListOpsItemRelatedItemsRequest.nextToken,
            outputKey: \ListOpsItemRelatedItemsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Amazon Web Services Systems Manager calls this API operation when displaying all Application Manager OpsMetadata objects or blobs.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listOpsMetadataPaginator<Result>(
        _ input: ListOpsMetadataRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListOpsMetadataResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listOpsMetadata,
            inputKey: \ListOpsMetadataRequest.nextToken,
            outputKey: \ListOpsMetadataResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listOpsMetadataPaginator(
        _ input: ListOpsMetadataRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListOpsMetadataResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listOpsMetadata,
            inputKey: \ListOpsMetadataRequest.nextToken,
            outputKey: \ListOpsMetadataResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a resource-level summary count. The summary includes information about compliant and non-compliant statuses and detailed compliance-item severity counts, according to the filter criteria you specify.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listResourceComplianceSummariesPaginator<Result>(
        _ input: ListResourceComplianceSummariesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListResourceComplianceSummariesResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listResourceComplianceSummaries,
            inputKey: \ListResourceComplianceSummariesRequest.nextToken,
            outputKey: \ListResourceComplianceSummariesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listResourceComplianceSummariesPaginator(
        _ input: ListResourceComplianceSummariesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListResourceComplianceSummariesResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listResourceComplianceSummaries,
            inputKey: \ListResourceComplianceSummariesRequest.nextToken,
            outputKey: \ListResourceComplianceSummariesResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists your resource data sync configurations. Includes information about the last time a sync attempted to start, the last sync status, and the last time a sync successfully completed. The number of sync configurations might be too large to return using a single call to ListResourceDataSync. You can limit the number of sync configurations returned by using the MaxResults parameter. To determine whether there are more sync configurations to list, check the value of NextToken in the output. If there are more sync configurations to list, you can request them by specifying the NextToken returned in the call to the parameter of a subsequent call.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listResourceDataSyncPaginator<Result>(
        _ input: ListResourceDataSyncRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListResourceDataSyncResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listResourceDataSync,
            inputKey: \ListResourceDataSyncRequest.nextToken,
            outputKey: \ListResourceDataSyncResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listResourceDataSyncPaginator(
        _ input: ListResourceDataSyncRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListResourceDataSyncResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listResourceDataSync,
            inputKey: \ListResourceDataSyncRequest.nextToken,
            outputKey: \ListResourceDataSyncResult.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension SSM.DescribeActivationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeActivationsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeAssociationExecutionTargetsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeAssociationExecutionTargetsRequest {
        return .init(
            associationId: self.associationId,
            executionId: self.executionId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeAssociationExecutionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeAssociationExecutionsRequest {
        return .init(
            associationId: self.associationId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeAutomationExecutionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeAutomationExecutionsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeAutomationStepExecutionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeAutomationStepExecutionsRequest {
        return .init(
            automationExecutionId: self.automationExecutionId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            reverseOrder: self.reverseOrder
        )
    }
}

extension SSM.DescribeAvailablePatchesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeAvailablePatchesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeEffectiveInstanceAssociationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeEffectiveInstanceAssociationsRequest {
        return .init(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeEffectivePatchesForPatchBaselineRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeEffectivePatchesForPatchBaselineRequest {
        return .init(
            baselineId: self.baselineId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeInstanceAssociationsStatusRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeInstanceAssociationsStatusRequest {
        return .init(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeInstanceInformationRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeInstanceInformationRequest {
        return .init(
            filters: self.filters,
            instanceInformationFilterList: self.instanceInformationFilterList,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeInstancePatchStatesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeInstancePatchStatesRequest {
        return .init(
            instanceIds: self.instanceIds,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeInstancePatchStatesForPatchGroupRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeInstancePatchStatesForPatchGroupRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            patchGroup: self.patchGroup
        )
    }
}

extension SSM.DescribeInstancePatchesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeInstancePatchesRequest {
        return .init(
            filters: self.filters,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeInventoryDeletionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeInventoryDeletionsRequest {
        return .init(
            deletionId: self.deletionId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeMaintenanceWindowExecutionTaskInvocationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeMaintenanceWindowExecutionTaskInvocationsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            taskId: self.taskId,
            windowExecutionId: self.windowExecutionId
        )
    }
}

extension SSM.DescribeMaintenanceWindowExecutionTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeMaintenanceWindowExecutionTasksRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowExecutionId: self.windowExecutionId
        )
    }
}

extension SSM.DescribeMaintenanceWindowExecutionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeMaintenanceWindowExecutionsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowId: self.windowId
        )
    }
}

extension SSM.DescribeMaintenanceWindowScheduleRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeMaintenanceWindowScheduleRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType,
            targets: self.targets,
            windowId: self.windowId
        )
    }
}

extension SSM.DescribeMaintenanceWindowTargetsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeMaintenanceWindowTargetsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowId: self.windowId
        )
    }
}

extension SSM.DescribeMaintenanceWindowTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeMaintenanceWindowTasksRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowId: self.windowId
        )
    }
}

extension SSM.DescribeMaintenanceWindowsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeMaintenanceWindowsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribeMaintenanceWindowsForTargetRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeMaintenanceWindowsForTargetRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType,
            targets: self.targets
        )
    }
}

extension SSM.DescribeOpsItemsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeOpsItemsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            opsItemFilters: self.opsItemFilters
        )
    }
}

extension SSM.DescribeParametersRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeParametersRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            parameterFilters: self.parameterFilters
        )
    }
}

extension SSM.DescribePatchBaselinesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribePatchBaselinesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribePatchGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribePatchGroupsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.DescribePatchPropertiesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribePatchPropertiesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            operatingSystem: self.operatingSystem,
            patchSet: self.patchSet,
            property: self.property
        )
    }
}

extension SSM.DescribeSessionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.DescribeSessionsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            state: self.state
        )
    }
}

extension SSM.GetInventoryRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.GetInventoryRequest {
        return .init(
            aggregators: self.aggregators,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resultAttributes: self.resultAttributes
        )
    }
}

extension SSM.GetInventorySchemaRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.GetInventorySchemaRequest {
        return .init(
            aggregator: self.aggregator,
            maxResults: self.maxResults,
            nextToken: token,
            subType: self.subType,
            typeName: self.typeName
        )
    }
}

extension SSM.GetOpsSummaryRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.GetOpsSummaryRequest {
        return .init(
            aggregators: self.aggregators,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resultAttributes: self.resultAttributes,
            syncName: self.syncName
        )
    }
}

extension SSM.GetParameterHistoryRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.GetParameterHistoryRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            withDecryption: self.withDecryption
        )
    }
}

extension SSM.GetParametersByPathRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.GetParametersByPathRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            parameterFilters: self.parameterFilters,
            path: self.path,
            recursive: self.recursive,
            withDecryption: self.withDecryption
        )
    }
}

extension SSM.ListAssociationVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListAssociationVersionsRequest {
        return .init(
            associationId: self.associationId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.ListAssociationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListAssociationsRequest {
        return .init(
            associationFilterList: self.associationFilterList,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.ListCommandInvocationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListCommandInvocationsRequest {
        return .init(
            commandId: self.commandId,
            details: self.details,
            filters: self.filters,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.ListCommandsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListCommandsRequest {
        return .init(
            commandId: self.commandId,
            filters: self.filters,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.ListComplianceItemsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListComplianceItemsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIds: self.resourceIds,
            resourceTypes: self.resourceTypes
        )
    }
}

extension SSM.ListComplianceSummariesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListComplianceSummariesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.ListDocumentVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListDocumentVersionsRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension SSM.ListDocumentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListDocumentsRequest {
        return .init(
            documentFilterList: self.documentFilterList,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.ListOpsItemEventsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListOpsItemEventsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.ListOpsItemRelatedItemsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListOpsItemRelatedItemsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            opsItemId: self.opsItemId
        )
    }
}

extension SSM.ListOpsMetadataRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListOpsMetadataRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.ListResourceComplianceSummariesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListResourceComplianceSummariesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSM.ListResourceDataSyncRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> SSM.ListResourceDataSyncRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            syncType: self.syncType
        )
    }
}
